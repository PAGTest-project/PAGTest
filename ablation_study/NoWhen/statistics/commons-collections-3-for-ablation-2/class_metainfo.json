[{"uris": "src/test/java/org/apache/commons/collections4/MapPerformance.java.MapPerformance", "name": "MapPerformance", "file_path": "src/test/java/org/apache/commons/collections4/MapPerformance.java", "superclasses": "", "methods": ["[void]main(String[])", "[void]test(Map<String, String>,String)", "[void]testAll()"], "method_uris": ["src/test/java/org/apache/commons/collections4/MapPerformance.java.MapPerformance.[void]main(String[])", "src/test/java/org/apache/commons/collections4/MapPerformance.java.MapPerformance.[void]test(Map<String, String>,String)", "src/test/java/org/apache/commons/collections4/MapPerformance.java.MapPerformance.[void]testAll()"], "overrides": null, "attributes": [{"original_string": "    private static final class DummyMap<K, V> implements Map<K, V> {\n        @Override\n        public void clear() {\n        }\n        @Override\n        public boolean containsKey(final Object key) {\n            return false;\n        }\n        @Override\n        public boolean containsValue(final Object value) {\n            return false;\n        }\n        @Override\n        public Set<Map.Entry<K, V>> entrySet() {\n            return null;\n        }\n        @Override\n        public V get(final Object key) {\n            return null;\n        }\n        @Override\n        public boolean isEmpty() {\n            return false;\n        }\n        @Override\n        public Set<K> keySet() {\n            return null;\n        }\n        @Override\n        public V put(final K key, final V value) {\n            return null;\n        }\n        @Override\n        public void putAll(final Map<? extends K, ? extends V> t) {\n        }\n        @Override\n        public V remove(final Object key) {\n            return null;\n        }\n        @Override\n        public int size() {\n            return 0;\n        }\n        @Override\n        public Collection<V> values() {\n            return null;\n        }\n    }", "definition": "    private static final class DummyMap<K, V> implements Map<K, V>", "class_docstring": "", "name": "DummyMap", "super_interfaces": ["Map<K, V>"], "superclasses": "", "attributes": {"modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @Override\n        public void clear() {\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "clear", "params": [], "body": "                            {\n        }", "signature": "@Override\n        public void clear()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean containsKey(final Object key) {\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "containsKey", "params": [{"name": "key", "type": "Object"}], "body": "                                                     {\n            return false;\n        }", "signature": "@Override\n        public boolean containsKey(final Object key)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean containsValue(final Object value) {\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "containsValue", "params": [{"name": "value", "type": "Object"}], "body": "                                                         {\n            return false;\n        }", "signature": "@Override\n        public boolean containsValue(final Object value)"}, {"syntax_pass": true, "original_string": "        @Override\n        public Set<Map.Entry<K, V>> entrySet() {\n            return null;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Set<Map.Entry<K, V>>", "classes": []}, "name": "entrySet", "params": [], "body": "                                               {\n            return null;\n        }", "signature": "@Override\n        public Set<Map.Entry<K, V>> entrySet()"}, {"syntax_pass": true, "original_string": "        @Override\n        public V get(final Object key) {\n            return null;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "get", "params": [{"name": "key", "type": "Object"}], "body": "                                       {\n            return null;\n        }", "signature": "@Override\n        public V get(final Object key)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isEmpty() {\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isEmpty", "params": [], "body": "                                 {\n            return false;\n        }", "signature": "@Override\n        public boolean isEmpty()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Set<K> keySet() {\n            return null;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Set<K>", "classes": []}, "name": "keySet", "params": [], "body": "                               {\n            return null;\n        }", "signature": "@Override\n        public Set<K> keySet()"}, {"syntax_pass": true, "original_string": "        @Override\n        public V put(final K key, final V value) {\n            return null;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "put", "params": [{"name": "key", "type": "K"}, {"name": "value", "type": "V"}], "body": "                                                 {\n            return null;\n        }", "signature": "@Override\n        public V put(final K key, final V value)"}, {"syntax_pass": true, "original_string": "        @Override\n        public void putAll(final Map<? extends K, ? extends V> t) {\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "putAll", "params": [{"name": "t", "type": "Map<? extends K, ? extends V>"}], "body": "                                                                  {\n        }", "signature": "@Override\n        public void putAll(final Map<? extends K, ? extends V> t)"}, {"syntax_pass": true, "original_string": "        @Override\n        public V remove(final Object key) {\n            return null;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "remove", "params": [{"name": "key", "type": "Object"}], "body": "                                          {\n            return null;\n        }", "signature": "@Override\n        public V remove(final Object key)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int size() {\n            return 0;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "size", "params": [], "body": "                          {\n            return 0;\n        }", "signature": "@Override\n        public int size()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Collection<V> values() {\n            return null;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Collection<V>", "classes": []}, "name": "values", "params": [], "body": "                                      {\n            return null;\n        }", "signature": "@Override\n        public Collection<V> values()"}]}], "class_docstring": "\n{@code MapPerformanceTest} is designed to perform basic Map performance tests.\n", "original_string": "public class MapPerformance {\n\n    private static final class DummyMap<K, V> implements Map<K, V> {\n        @Override\n        public void clear() {\n        }\n        @Override\n        public boolean containsKey(final Object key) {\n            return false;\n        }\n        @Override\n        public boolean containsValue(final Object value) {\n            return false;\n        }\n        @Override\n        public Set<Map.Entry<K, V>> entrySet() {\n            return null;\n        }\n        @Override\n        public V get(final Object key) {\n            return null;\n        }\n        @Override\n        public boolean isEmpty() {\n            return false;\n        }\n        @Override\n        public Set<K> keySet() {\n            return null;\n        }\n        @Override\n        public V put(final K key, final V value) {\n            return null;\n        }\n        @Override\n        public void putAll(final Map<? extends K, ? extends V> t) {\n        }\n        @Override\n        public V remove(final Object key) {\n            return null;\n        }\n        @Override\n        public int size() {\n            return 0;\n        }\n        @Override\n        public Collection<V> values() {\n            return null;\n        }\n    }\n\n    /** The total number of runs for each test */\n    private static final int RUNS = 20000000;\n\n    /**\n     * Main method\n     */\n    public static void main(final String[] args) {\n        testAll();\n    }\n\n    private static void test(final Map<String, String> map, final String name) {\n        long startMillis = 0, endMillis = 0;\n//        int total = 0;\n        startMillis = System.currentTimeMillis();\n        for (int i = RUNS; i > 0; i--) {\n//            if (map.get(\"Alpha\") != null) total++;\n//            if (map.get(\"Beta\") != null) total++;\n//            if (map.get(\"Gamma\") != null) total++;\n            map.put(\"Alpha\", \"A\");\n            map.put(\"Beta\", \"B\");\n            map.put(\"Beta\", \"C\");\n            map.put(\"Gamma\", \"D\");\n//            map.remove(\"Gamma\");\n//            map.remove(\"Beta\");\n//            map.remove(\"Alpha\");\n            map.put(\"Delta\", \"E\");\n            map.clear();\n        }\n        endMillis = System.currentTimeMillis();\n        System.out.println(name + (endMillis - startMillis));\n    }\n\n    private static void testAll() {\n        final Map<String, String> dummyMap = new DummyMap<>();\n        final Map<String, String> hashMap = new HashMap<>();\n//        hashMap.put(\"Alpha\", \"A\");\n//        hashMap.put(\"Beta\", \"B\");\n//        hashMap.put(\"Gamma\", \"C\");\n//        hashMap.put(\"Delta\", \"D\");\n        final Map<String, String> flatMap = new Flat3Map<>(hashMap);\n        System.out.println(flatMap);\n//        Map<String, String> unmodHashMap = Collections.unmodifiableMap(new HashMap<String, String>(hashMap));\n//        Map fastHashMap = new FastHashMap(hashMap);\n//        Map<String, String> treeMap = new TreeMap<String, String>(hashMap);\n//        Map linkedMap = new LinkedHashMap(hashMap);\n//        Map syncMap = Collections.unmodifiableMap(new HashMap(hashMap));\n//        Map bucketMap = new StaticBucketMap();\n//        bucketMap.putAll(hashMap);\n//        Map doubleMap = new DoubleOrderedMap(hashMap);\n\n        // dummy is required as the VM seems to hotspot the first call to the\n        // test method with the given type\n        test(dummyMap,      \"         Dummy \");\n        test(dummyMap,      \"         Dummy \");\n        test(dummyMap,      \"         Dummy \");\n        test(flatMap,       \"         Flat3 \");\n        test(hashMap,       \"       HashMap \");\n\n        test(flatMap,       \"         Flat3 \");\n        test(flatMap,       \"         Flat3 \");\n        test(flatMap,       \"         Flat3 \");\n\n        test(hashMap,       \"       HashMap \");\n        test(hashMap,       \"       HashMap \");\n        test(hashMap,       \"       HashMap \");\n\n//        test(treeMap,       \"       TreeMap \");\n//        test(treeMap,       \"       TreeMap \");\n//        test(treeMap,       \"       TreeMap \");\n\n//        test(unmodHashMap,  \"Unmod(HashMap) \");\n//        test(unmodHashMap,  \"Unmod(HashMap) \");\n//        test(unmodHashMap,  \"Unmod(HashMap) \");\n//\n//        test(syncMap,       \" Sync(HashMap) \");\n//        test(syncMap,       \" Sync(HashMap) \");\n//        test(syncMap,       \" Sync(HashMap) \");\n//\n//        test(fastHashMap,   \"   FastHashMap \");\n//        test(fastHashMap,   \"   FastHashMap \");\n//        test(fastHashMap,   \"   FastHashMap \");\n//\n//        test(seqMap,        \"    SeqHashMap \");\n//        test(seqMap,        \"    SeqHashMap \");\n//        test(seqMap,        \"    SeqHashMap \");\n//\n//        test(linkedMap,     \" LinkedHashMap \");\n//        test(linkedMap,     \" LinkedHashMap \");\n//        test(linkedMap,     \" LinkedHashMap \");\n//\n//        test(bucketMap,     \"     BucketMap \");\n//        test(bucketMap,     \"     BucketMap \");\n//        test(bucketMap,     \"     BucketMap \");\n//\n//        test(doubleMap,     \"     DoubleMap \");\n//        test(doubleMap,     \"     DoubleMap \");\n//        test(doubleMap,     \"     DoubleMap \");\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final int RUNS = 20000000;", "docstring": " The total number of runs for each test", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "int", "name": "RUNS = 20000000", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/GuavaTestlibTest.java.GuavaTestlibTest", "name": "GuavaTestlibTest", "file_path": "src/test/java/org/apache/commons/collections4/GuavaTestlibTest.java", "superclasses": "TestCase", "methods": ["[Test]suite()", "[Test]suiteList(String,Supplier<List<String>>)", "[Test]suiteMap(String,Supplier<Map<String, String>>)"], "method_uris": ["src/test/java/org/apache/commons/collections4/GuavaTestlibTest.java.GuavaTestlibTest.[Test]suite()", "src/test/java/org/apache/commons/collections4/GuavaTestlibTest.java.GuavaTestlibTest.[Test]suiteList(String,Supplier<List<String>>)", "src/test/java/org/apache/commons/collections4/GuavaTestlibTest.java.GuavaTestlibTest.[Test]suiteMap(String,Supplier<Map<String, String>>)"], "overrides": null, "attributes": [], "class_docstring": "\nThis test uses Google's Guava Testlib testing libraries to validate the\ncontract of collection classes in Commons Collections. This was introduced\nafter COLLECTIONS-802, where the issue reported was found with Testlib.\n\n@see <a href=\"https://github.com/google/guava/tree/master/guava-testlib\">https://github.com/google/guava/tree/master/guava-testlib</a>\n@see <a href=\"https://issues.apache.org/jira/browse/COLLECTIONS-802\">https://issues.apache.org/jira/browse/COLLECTIONS-802</a>\n", "original_string": "public final class GuavaTestlibTest extends TestCase {\n\n    public static Test suite() {\n        final TestSuite test = new TestSuite();\n        // Map\n        test.addTest(suiteMap(\"HashedMap\", HashedMap::new));\n        test.addTest(suiteMap(\"LinkedMap\", LinkedMap::new));\n        test.addTest(suiteMap(\"LRUMap\", LRUMap::new));\n        test.addTest(suiteMap(\"ReferenceMap\", ReferenceMap::new));\n        // List\n        test.addTest(suiteList(\"TreeList\", TreeList::new));\n        // TODO: In COLLECTIONS-811 we enabled the list tests for TreeList, but these other two types did not\n        //       pass the tests. Someone needs to confirm if it is a bug in the code, or we need to change the\n        //       test features.\n        // test.addTest(suiteList(\"GrowthList\", GrowthList::new, CollectionFeature.SERIALIZABLE));\n        // test.addTest(suiteList(\"CursorableLinkedList\", CursorableLinkedList::new, CollectionFeature.SERIALIZABLE));\n        return test;\n    }\n\n    /**\n     * Programmatically create a JUnit (3, 4) Test Suite for Guava testlib tests with Lists.\n     * @param name name of the test\n     * @param factory factory to create new Lists\n     * @param features test features used in the tests\n     * @return a JUnit 3, 4 Test Suite\n     */\n    private static Test suiteList(final String name, final Supplier<List<String>> factory, final Feature<?>... features) {\n        final ListTestSuiteBuilder<String> suite = ListTestSuiteBuilder.using(new TestStringListGenerator() {\n            @Override\n            protected List<String> create(final String[] elements) {\n                final List<String> list = factory.get();\n                Collections.addAll(list, elements);\n                return list;\n            }\n        })\n                .named(name)\n                .withFeatures(\n                        CollectionSize.ANY,\n                        ListFeature.GENERAL_PURPOSE,\n                        ListFeature.REMOVE_OPERATIONS,\n                        CollectionFeature.ALLOWS_NULL_VALUES,\n                        CollectionFeature.DESCENDING_VIEW,\n                        CollectionFeature.SUBSET_VIEW);\n        suite.withFeatures(features);\n        return suite.createTestSuite();\n    }\n\n    /**\n     * Programmatically create a JUnit (3, 4) Test Suite for Guava testlib tests with Maps.\n     * @param name name of the test\n     * @param factory factory to create new Maps\n     * @return a JUnit 3, 4 Test Suite\n     */\n    private static Test suiteMap(final String name, final Supplier<Map<String, String>> factory) {\n        return MapTestSuiteBuilder.using(new TestStringMapGenerator() {\n            @Override\n            protected Map<String, String> create(final Map.Entry<String, String>[] entries) {\n                final Map<String, String> map = factory.get();\n                for (final Map.Entry<String, String> entry : entries) {\n                    map.put(entry.getKey(), entry.getValue());\n                }\n                return map;\n            }\n        })\n                .named(name)\n                .withFeatures(\n                        CollectionSize.ANY, MapFeature.GENERAL_PURPOSE,\n                        MapFeature.ALLOWS_ANY_NULL_QUERIES, CollectionFeature.SUPPORTS_ITERATOR_REMOVE)\n                .createTestSuite();\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/BulkTest.java.BulkTest", "name": "BulkTest", "file_path": "src/test/java/org/apache/commons/collections4/BulkTest.java", "superclasses": "", "methods": ["[]BulkTest(String)", "[Object]clone()", "[String]getName()", "[String]getVerboseName()", "[String[]]ignoredTests()", "[void]setName(String)", "[void]setVerboseName(String)", "[String]toString()"], "method_uris": ["src/test/java/org/apache/commons/collections4/BulkTest.java.BulkTest.[]BulkTest(String)", "src/test/java/org/apache/commons/collections4/BulkTest.java.BulkTest.[Object]clone()", "src/test/java/org/apache/commons/collections4/BulkTest.java.BulkTest.[String]getName()", "src/test/java/org/apache/commons/collections4/BulkTest.java.BulkTest.[String]getVerboseName()", "src/test/java/org/apache/commons/collections4/BulkTest.java.BulkTest.[String[]]ignoredTests()", "src/test/java/org/apache/commons/collections4/BulkTest.java.BulkTest.[void]setName(String)", "src/test/java/org/apache/commons/collections4/BulkTest.java.BulkTest.[void]setVerboseName(String)", "src/test/java/org/apache/commons/collections4/BulkTest.java.BulkTest.[String]toString()"], "overrides": null, "attributes": [], "class_docstring": "\nA {@link TestCase} that can define both simple and bulk test methods.\n<p>\nA <em>simple test method</em> is the type of test traditionally\nsupplied by {@link TestCase}.  To define a simple test, create a public\nno-argument method whose name starts with \"test\".  You can specify\nthe name of simple test in the constructor of {@code BulkTest};\na subsequent call to {@link TestCase#run} will run that simple test.\n<p>\nA <em>bulk test method</em>, on the other hand, returns a new instance\nof {@code BulkTest}, which can itself define new simple and bulk\ntest methods.  By using the {@link #makeSuite} method, you can\nautomatically create a hierarchical suite of tests and child bulk tests.\n<p>\nFor instance, consider the following two classes:\n\n<Pre>\n public class SetTest extends BulkTest {\n\n     private Set set;\n\n     public SetTest(Set set) {\n         this.set = set;\n     }\n\n     @Test\n     public void testContains() {\n         boolean r = set.contains(set.iterator().next()));\n         assertTrue(\"Set should contain first element, r);\n     }\n\n     @Test\n     public void testClear() {\n         set.clear();\n         assertTrue(\"Set should be empty after clear\", set.isEmpty());\n     }\n }\n\n\n public class HashMapTest extends BulkTest {\n\n     private Map makeFullMap() {\n         HashMap result = new HashMap();\n         result.put(\"1\", \"One\");\n         result.put(\"2\", \"Two\");\n         return result;\n     }\n\n     @Test\n     public void testClear() {\n         Map map = makeFullMap();\n         map.clear();\n         assertTrue(\"Map empty after clear\", map.isEmpty());\n     }\n\n     public BulkTest bulkTestKeySet() {\n         return new SetTest(makeFullMap().keySet());\n     }\n\n     public BulkTest bulkTestEntrySet() {\n         return new SetTest(makeFullMap().entrySet());\n     }\n }\n </Pre>\n\n In the above examples, {@code SetTest} defines two\n simple test methods and no bulk test methods; {@code HashMapTest}\n defines one simple test method and two bulk test methods.  When\n {@code makeSuite(HashMapTest.class).run} is executed,\n <em>five</em> simple test methods will be run, in this order:<P>\n\n <Ol>\n <Li>HashMapTest.testClear()\n <Li>HashMapTest.bulkTestKeySet().testContains();\n <Li>HashMapTest.bulkTestKeySet().testClear();\n <Li>HashMapTest.bulkTestEntrySet().testContains();\n <Li>HashMapTest.bulkTestEntrySet().testClear();\n </Ol>\n\n In the graphical junit test runners, the tests would be displayed in\n the following tree:<P>\n\n <UL>\n <LI>HashMapTest</LI>\n     <UL>\n     <LI>testClear\n     <LI>bulkTestKeySet\n         <UL>\n         <LI>testContains\n         <LI>testClear\n         </UL>\n     <LI>bulkTestEntrySet\n         <UL>\n         <LI>testContains\n         <LI>testClear\n         </UL>\n     </UL>\n </UL>\n\n A subclass can override a superclass's bulk test by\n returning {@code null} from the bulk test method.  If you only\n want to override specific simple tests within a bulk test, use the\n {@link #ignoredTests} method.<P>\n\n Note that if you want to use the bulk test methods, you <em>must</em>\n define your {@code suite()} method to use {@link #makeSuite}.\n The ordinary {@link TestSuite} constructor doesn't know how to\n interpret bulk test methods.\n", "original_string": "public class BulkTest implements Cloneable {\n\n    // Note:  BulkTest is Cloneable to make it easier to construct\n    // BulkTest instances for simple test methods that are defined in\n    // anonymous inner classes.  Basically we don't have to worry about\n    // finding weird constructors.  (And even if we found them, technically\n    // it'd be illegal for anyone but the outer class to invoke them).\n    // Given one BulkTest instance, we can just clone it and reset the\n    // method name for every simple test it defines.\n\n    /** Path to test data resources */\n    protected static final String TEST_DATA_PATH = \"src/test/resources/org/apache/commons/collections4/data/test/\";\n\n    /** Path to test properties resources */\n    public static final String TEST_PROPERTIES_PATH = \"src/test/resources/org/apache/commons/collections4/properties/\";\n\n    /**\n     *  The full name of this bulk test instance.  This is the full name\n     *  that is compared to {@link #ignoredTests} to see if this\n     *  test should be ignored.  It's also displayed in the text runner\n     *  to ease debugging.\n     */\n    private String verboseName;\n\n    /**\n     *  the name of the simple test method\n     */\n    private String name;\n\n    /**\n     *  Constructs a new {@code BulkTest} instance that will run the\n     *  specified simple test.\n     *\n     *  @param name  the name of the simple test method to run\n     */\n    public BulkTest(final String name) {\n        this.name = name;\n        this.verboseName = getClass().getName();\n    }\n\n    /**\n     *  Creates a clone of this {@code BulkTest}.<P>\n     *\n     *  @return  a clone of this {@code BulkTest}\n     */\n    @Override\n    public Object clone() {\n        try {\n            return super.clone();\n        } catch (final CloneNotSupportedException e) {\n            throw new Error(); // should never happen\n        }\n    }\n\n    /**\n     *  Returns the name of the simple test method of this {@code BulkTest}.\n     *\n     *  @return the name of the simple test method of this {@code BulkTest}\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * For Apache Commons BeanUtils until all components migrate to JUnit 5.\n     */\n    public String getVerboseName() {\n        return verboseName;\n    }\n\n    /**\n     *  Returns an array of test names to ignore.<P>\n     *\n     *  If a test that's defined by this {@code BulkTest} or\n     *  by one of its bulk test methods has a name that's in the returned\n     *  array, then that simple test will not be executed.<P>\n     *\n     *  A test's name is formed by taking the class name of the\n     *  root {@code BulkTest}, eliminating the package name, then\n     *  appending the names of any bulk test methods that were invoked\n     *  to get to the simple test, and then appending the simple test\n     *  method name.  The method names are delimited by periods:\n     *\n     *  <pre>\n     *  HashMapTest.bulkTestEntrySet.testClear\n     *  </pre>\n     *\n     *  is the name of one of the simple tests defined in the sample classes\n     *  described above.  If the sample {@code HashMapTest} class\n     *  included this method:\n     *\n     *  <pre>\n     *  public String[] ignoredTests() {\n     *      return new String[] { \"HashMapTest.bulkTestEntrySet.testClear\" };\n     *  }\n     *  </pre>\n     *\n     *  then the entry set's clear method wouldn't be tested, but the key\n     *  set's clear method would.\n     *\n     *  @return an array of the names of tests to ignore, or null if\n     *   no tests should be ignored\n     */\n    public String[] ignoredTests() {\n        return null;\n    }\n\n    /**\n     * For Apache Commons BeanUtils until all components migrate to JUnit 5.\n     */\n    public void setName(final String name) {\n        this.name = name;\n    }\n\n    /**\n     * For Apache Commons BeanUtils until all components migrate to JUnit 5.\n     */\n    public void setVerboseName(final String verboseName) {\n        this.verboseName = verboseName;\n    }\n\n    /**\n     *  Returns the display name of this {@code BulkTest}.\n     *\n     *  @return the display name of this {@code BulkTest}\n     */\n    @Override\n    public String toString() {\n        return getName() + \"(\" + verboseName + \") \";\n    }\n\n}", "super_interfaces": ["Cloneable"], "fields": [{"attribute_expression": "protected static final String TEST_DATA_PATH = \"src/test/resources/org/apache/commons/collections4/data/test/\";", "docstring": " Path to test data resources", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "String", "name": "TEST_DATA_PATH = \"src/test/resources/org/apache/commons/collections4/data/test/\"", "syntax_pass": true}, {"attribute_expression": "public static final String TEST_PROPERTIES_PATH = \"src/test/resources/org/apache/commons/collections4/properties/\";", "docstring": " Path to test properties resources", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "TEST_PROPERTIES_PATH = \"src/test/resources/org/apache/commons/collections4/properties/\"", "syntax_pass": true}, {"attribute_expression": "private String verboseName;", "docstring": "\n The full name of this bulk test instance.  This is the full name\n that is compared to {@link #ignoredTests} to see if this\n test should be ignored.  It's also displayed in the text runner\n to ease debugging.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "verboseName", "syntax_pass": true}, {"attribute_expression": "private String name;", "docstring": "\n the name of the simple test method\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "name", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/TestUtils.java.TestUtils", "name": "TestUtils", "file_path": "src/test/java/org/apache/commons/collections4/TestUtils.java", "superclasses": "", "methods": ["[void]assertSameAfterSerialization(Object)", "[void]assertSameAfterSerialization(String,Object)", "[]TestUtils()"], "method_uris": ["src/test/java/org/apache/commons/collections4/TestUtils.java.TestUtils.[void]assertSameAfterSerialization(Object)", "src/test/java/org/apache/commons/collections4/TestUtils.java.TestUtils.[void]assertSameAfterSerialization(String,Object)", "src/test/java/org/apache/commons/collections4/TestUtils.java.TestUtils.[]TestUtils()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public final class TestUtils {\n\n    /**\n     * Asserts that deserialization of the object returns the same object as the\n     * one that was serialized.\n     * <p>\n     * Effect of method call is the same as:\n     * {@code assertSameAfterSerialization(null, o)}.\n     *\n     * @param o object that will be tested.\n     * @see #assertSameAfterSerialization(String, Object)\n     */\n    public static void assertSameAfterSerialization(final Object o) {\n        assertSameAfterSerialization(null, o);\n    }\n\n    /**\n     * Asserts that deserialization of the object returns the same object as the\n     * one that was serialized. Object is first serialized, then deserialized\n     * and finally check is performed to see if original and deserialized\n     * object references are the same.\n     * <p>\n     * This method is especially good for testing singleton pattern on classes\n     * that support serialization.\n     *\n     * @param msg the identifying message for the {@code AssertionError}.\n     * @param o object that will be tested.\n     * @see #assertSameAfterSerialization(Object)\n     */\n    public static void assertSameAfterSerialization(final String msg, final Object o) {\n        try {\n            // write object to byte buffer\n            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            final ObjectOutputStream oos = new ObjectOutputStream(baos);\n            oos.writeObject(o);\n            oos.close();\n\n            // read same object from byte buffer\n            final InputStream is = new ByteArrayInputStream(baos.toByteArray());\n            final ObjectInputStream ois = new ObjectInputStream(is);\n            final Object object = ois.readObject();\n            ois.close();\n\n            // assert that original object and deserialized objects are the same\n            assertSame(o, object, msg);\n        } catch (final IOException | ClassNotFoundException e) {\n            // should never happen\n            throw new RuntimeException(e);\n        }\n    }\n\n    private TestUtils() {\n        // empty\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/bag/HashBagTest.java.HashBagTest", "name": "HashBagTest", "file_path": "src/test/java/org/apache/commons/collections4/bag/HashBagTest.java", "superclasses": "", "methods": ["[]HashBagTest()", "[String]getCompatibilityVersion()", "[int]getIterationBehaviour()", "[Bag<T>]makeObject()"], "method_uris": ["src/test/java/org/apache/commons/collections4/bag/HashBagTest.java.HashBagTest.[]HashBagTest()", "src/test/java/org/apache/commons/collections4/bag/HashBagTest.java.HashBagTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/bag/HashBagTest.java.HashBagTest.[int]getIterationBehaviour()", "src/test/java/org/apache/commons/collections4/bag/HashBagTest.java.HashBagTest.[Bag<T>]makeObject()"], "overrides": null, "attributes": [], "class_docstring": "\nExtension of {@link AbstractBagTest} for exercising the {@link HashBag}\nimplementation.\n", "original_string": "public class HashBagTest<T> extends AbstractBagTest<T> {\n\n    public HashBagTest() {\n        super(HashBagTest.class.getSimpleName());\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    @Override\n    protected int getIterationBehaviour() {\n        return UNORDERED;\n    }\n\n    @Override\n    public Bag<T> makeObject() {\n        return new HashBag<>();\n    }\n\n//    public void testCreate() throws Exception {\n//        Bag<T> bag = makeObject();\n//        writeExternalFormToDisk((java.io.Serializable) bag, \"src/test/resources/data/test/HashBag.emptyCollection.version4.obj\");\n//        bag = makeFullCollection();\n//        writeExternalFormToDisk((java.io.Serializable) bag, \"src/test/resources/data/test/HashBag.fullCollection.version4.obj\");\n//    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/bag/SynchronizedBagTest.java.SynchronizedBagTest", "name": "SynchronizedBagTest", "file_path": "src/test/java/org/apache/commons/collections4/bag/SynchronizedBagTest.java", "superclasses": "", "methods": ["[]SynchronizedBagTest()", "[String]getCompatibilityVersion()", "[int]getIterationBehaviour()", "[Bag<T>]makeObject()"], "method_uris": ["src/test/java/org/apache/commons/collections4/bag/SynchronizedBagTest.java.SynchronizedBagTest.[]SynchronizedBagTest()", "src/test/java/org/apache/commons/collections4/bag/SynchronizedBagTest.java.SynchronizedBagTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/bag/SynchronizedBagTest.java.SynchronizedBagTest.[int]getIterationBehaviour()", "src/test/java/org/apache/commons/collections4/bag/SynchronizedBagTest.java.SynchronizedBagTest.[Bag<T>]makeObject()"], "overrides": null, "attributes": [], "class_docstring": "\nExtension of {@link AbstractBagTest} for exercising the {@link SynchronizedBag} implementation.\n", "original_string": "public class SynchronizedBagTest<T> extends AbstractBagTest<T> {\n\n    public SynchronizedBagTest() {\n        super(SynchronizedBagTest.class.getSimpleName());\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    @Override\n    protected int getIterationBehaviour() {\n        return UNORDERED;\n    }\n\n    @Override\n    public Bag<T> makeObject() {\n        return SynchronizedBag.synchronizedBag(new HashBag<>());\n    }\n\n//    public void testCreate() throws Exception {\n//        Bag<T> bag = makeObject();\n//        writeExternalFormToDisk((java.io.Serializable) bag, \"src/test/resources/data/test/SynchronizedBag.emptyCollection.version4.obj\");\n//        bag = makeFullCollection();\n//        writeExternalFormToDisk((java.io.Serializable) bag, \"src/test/resources/data/test/SynchronizedBag.fullCollection.version4.obj\");\n//    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/collection/SynchronizedCollectionTest.java.SynchronizedCollectionTest", "name": "SynchronizedCollectionTest", "file_path": "src/test/java/org/apache/commons/collections4/collection/SynchronizedCollectionTest.java", "superclasses": "", "methods": ["[]SynchronizedCollectionTest()", "[String]getCompatibilityVersion()", "[Collection<E>]makeConfirmedCollection()", "[Collection<E>]makeConfirmedFullCollection()", "[Collection<E>]makeObject()"], "method_uris": ["src/test/java/org/apache/commons/collections4/collection/SynchronizedCollectionTest.java.SynchronizedCollectionTest.[]SynchronizedCollectionTest()", "src/test/java/org/apache/commons/collections4/collection/SynchronizedCollectionTest.java.SynchronizedCollectionTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/collection/SynchronizedCollectionTest.java.SynchronizedCollectionTest.[Collection<E>]makeConfirmedCollection()", "src/test/java/org/apache/commons/collections4/collection/SynchronizedCollectionTest.java.SynchronizedCollectionTest.[Collection<E>]makeConfirmedFullCollection()", "src/test/java/org/apache/commons/collections4/collection/SynchronizedCollectionTest.java.SynchronizedCollectionTest.[Collection<E>]makeObject()"], "overrides": null, "attributes": [], "class_docstring": "\nExtension of {@link AbstractCollectionTest} for exercising the\n{@link SynchronizedCollection} implementation.\n", "original_string": "public class SynchronizedCollectionTest<E> extends AbstractCollectionTest<E> {\n\n    public SynchronizedCollectionTest() {\n        super(SynchronizedCollectionTest.class.getSimpleName());\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    @Override\n    public Collection<E> makeConfirmedCollection() {\n        return new ArrayList<>();\n    }\n\n    @Override\n    public Collection<E> makeConfirmedFullCollection() {\n        return new ArrayList<>(Arrays.asList(getFullElements()));\n    }\n\n    @Override\n    public Collection<E> makeObject() {\n        return SynchronizedCollection.synchronizedCollection(new ArrayList<>());\n    }\n\n//    public void testCreate() throws Exception {\n//        resetEmpty();\n//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/SynchronizedCollection.emptyCollection.version4.obj\");\n//        resetFull();\n//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/SynchronizedCollection.fullCollection.version4.obj\");\n//    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/map/FixedSizeMapTest.java.FixedSizeMapTest", "name": "FixedSizeMapTest", "file_path": "src/test/java/org/apache/commons/collections4/map/FixedSizeMapTest.java", "superclasses": "", "methods": ["[]FixedSizeMapTest()", "[String]getCompatibilityVersion()", "[boolean]isPutAddSupported()", "[boolean]isRemoveSupported()", "[IterableMap<K, V>]makeFullMap()", "[IterableMap<K, V>]makeObject()"], "method_uris": ["src/test/java/org/apache/commons/collections4/map/FixedSizeMapTest.java.FixedSizeMapTest.[]FixedSizeMapTest()", "src/test/java/org/apache/commons/collections4/map/FixedSizeMapTest.java.FixedSizeMapTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/map/FixedSizeMapTest.java.FixedSizeMapTest.[boolean]isPutAddSupported()", "src/test/java/org/apache/commons/collections4/map/FixedSizeMapTest.java.FixedSizeMapTest.[boolean]isRemoveSupported()", "src/test/java/org/apache/commons/collections4/map/FixedSizeMapTest.java.FixedSizeMapTest.[IterableMap<K, V>]makeFullMap()", "src/test/java/org/apache/commons/collections4/map/FixedSizeMapTest.java.FixedSizeMapTest.[IterableMap<K, V>]makeObject()"], "overrides": null, "attributes": [], "class_docstring": "\nExtension of {@link AbstractMapTest} for exercising the {@link FixedSizeMap}\nimplementation.\n", "original_string": "public class FixedSizeMapTest<K, V> extends AbstractIterableMapTest<K, V> {\n\n    public FixedSizeMapTest() {\n        super(FixedSizeMapTest.class.getSimpleName());\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    @Override\n    public boolean isPutAddSupported() {\n        return false;\n    }\n\n    @Override\n    public boolean isRemoveSupported() {\n        return false;\n    }\n\n    @Override\n    public IterableMap<K, V> makeFullMap() {\n        final Map<K, V> map = new HashMap<>();\n        addSampleMappings(map);\n        return FixedSizeMap.fixedSizeMap(map);\n    }\n\n    @Override\n    public IterableMap<K, V> makeObject() {\n        return FixedSizeMap.fixedSizeMap(new HashMap<>());\n    }\n\n//    public void testCreate() throws Exception {\n//        resetEmpty();\n//        writeExternalFormToDisk(\n//            (java.io.Serializable) map,\n//            \"src/test/resources/data/test/FixedSizeMap.emptyCollection.version4.obj\");\n//        resetFull();\n//        writeExternalFormToDisk(\n//            (java.io.Serializable) map,\n//            \"src/test/resources/data/test/FixedSizeMap.fullCollection.version4.obj\");\n//    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/map/IdentityMap.java.IdentityMap", "name": "IdentityMap", "file_path": "src/test/java/org/apache/commons/collections4/map/IdentityMap.java", "superclasses": "", "methods": ["[]IdentityMap()", "[]IdentityMap(int)", "[]IdentityMap(int,float)", "[]IdentityMap(Map<K, V>)", "[IdentityMap<K, V>]clone()", "[IdentityEntry<K, V>]createEntry(HashEntry<K, V>,int,K,V)", "[int]hash(Object)", "[boolean]isEqualKey(Object,Object)", "[boolean]isEqualValue(Object,Object)", "[void]readObject(ObjectInputStream)", "[void]writeObject(ObjectOutputStream)"], "method_uris": ["src/test/java/org/apache/commons/collections4/map/IdentityMap.java.IdentityMap.[]IdentityMap()", "src/test/java/org/apache/commons/collections4/map/IdentityMap.java.IdentityMap.[]IdentityMap(int)", "src/test/java/org/apache/commons/collections4/map/IdentityMap.java.IdentityMap.[]IdentityMap(int,float)", "src/test/java/org/apache/commons/collections4/map/IdentityMap.java.IdentityMap.[]IdentityMap(Map<K, V>)", "src/test/java/org/apache/commons/collections4/map/IdentityMap.java.IdentityMap.[IdentityMap<K, V>]clone()", "src/test/java/org/apache/commons/collections4/map/IdentityMap.java.IdentityMap.[IdentityEntry<K, V>]createEntry(HashEntry<K, V>,int,K,V)", "src/test/java/org/apache/commons/collections4/map/IdentityMap.java.IdentityMap.[int]hash(Object)", "src/test/java/org/apache/commons/collections4/map/IdentityMap.java.IdentityMap.[boolean]isEqualKey(Object,Object)", "src/test/java/org/apache/commons/collections4/map/IdentityMap.java.IdentityMap.[boolean]isEqualValue(Object,Object)", "src/test/java/org/apache/commons/collections4/map/IdentityMap.java.IdentityMap.[void]readObject(ObjectInputStream)", "src/test/java/org/apache/commons/collections4/map/IdentityMap.java.IdentityMap.[void]writeObject(ObjectOutputStream)"], "overrides": null, "attributes": [{"original_string": "    protected static class IdentityEntry<K, V> extends HashEntry<K, V> {\n\n        protected IdentityEntry(final HashEntry<K, V> next, final int hashCode, final K key, final V value) {\n            super(next, hashCode, key, value);\n        }\n\n        @Override\n        public boolean equals(final Object obj) {\n            if (obj == this) {\n                return true;\n            }\n            if (!(obj instanceof Entry)) {\n                return false;\n            }\n            final Map.Entry<?, ?> other = (Map.Entry<?, ?>) obj;\n            return\n                getKey() == other.getKey() &&\n                getValue() == other.getValue();\n        }\n\n        @Override\n        public int hashCode() {\n            return System.identityHashCode(getKey()) ^\n                   System.identityHashCode(getValue());\n        }\n    }", "definition": "    protected static class IdentityEntry<K, V> extends HashEntry<K, V>", "class_docstring": "\nHashEntry.\n\n@param <K> the key type.\n@param <V> the value type.\n", "name": "IdentityEntry", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "protected static", "marker_annotations": [], "non_marker_annotations": ["protected", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        protected IdentityEntry(final HashEntry<K, V> next, final int hashCode, final K key, final V value) {\n            super(next, hashCode, key, value);\n        }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "name": "IdentityEntry", "params": [{"name": "next", "type": "HashEntry<K, V>"}, {"name": "hashCode", "type": "int"}, {"name": "key", "type": "K"}, {"name": "value", "type": "V"}], "body": "                                                                                                            {\n            super(next, hashCode, key, value);\n        }", "signature": "protected IdentityEntry(final HashEntry<K, V> next, final int hashCode, final K key, final V value)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean equals(final Object obj) {\n            if (obj == this) {\n                return true;\n            }\n            if (!(obj instanceof Entry)) {\n                return false;\n            }\n            final Map.Entry<?, ?> other = (Map.Entry<?, ?>) obj;\n            return\n                getKey() == other.getKey() &&\n                getValue() == other.getValue();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "obj", "type": "Object"}], "body": "                                                {\n            if (obj == this) {\n                return true;\n            }\n            if (!(obj instanceof Entry)) {\n                return false;\n            }\n            final Map.Entry<?, ?> other = (Map.Entry<?, ?>) obj;\n            return\n                getKey() == other.getKey() &&\n                getValue() == other.getValue();\n        }", "signature": "@Override\n        public boolean equals(final Object obj)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int hashCode() {\n            return System.identityHashCode(getKey()) ^\n                   System.identityHashCode(getValue());\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                              {\n            return System.identityHashCode(getKey()) ^\n                   System.identityHashCode(getValue());\n        }", "signature": "@Override\n        public int hashCode()"}]}], "class_docstring": "\nA {@code Map} implementation that matches keys and values based\non {@code ==} not {@code equals()}.\n<p>\n<strong>This map will violate the detail of various Map and map view contracts.</strong>\nAs a general rule, don't compare this map to other maps. In particular, you can't\nuse decorators like {@link ListOrderedMap} on it, which silently assume that these\ncontracts are fulfilled.\n<p>\n<strong>Note that IdentityMap is not synchronized and is not thread-safe.</strong>\nIf you wish to use this map from multiple threads concurrently, you must use\nappropriate synchronization. The simplest approach is to wrap this map\nusing {@link java.util.Collections#synchronizedMap(Map)}. This class may throw\nexceptions when accessed by concurrent threads without synchronization.\n<p>\nFrom 4.0, this class is replaced by java.util.IdentityHashMap but kept as a\ntest-class because it is still used by the ReferenceIdentityMapTest.\n\n@param <K> the type of the keys in this map\n@param <V> the type of the values in this map\n", "original_string": "public class IdentityMap<K, V>\n        extends AbstractHashedMap<K, V> implements Serializable, Cloneable {\n\n    /**\n     * HashEntry.\n     *\n     * @param <K> the key type.\n     * @param <V> the value type.\n     */\n    protected static class IdentityEntry<K, V> extends HashEntry<K, V> {\n\n        protected IdentityEntry(final HashEntry<K, V> next, final int hashCode, final K key, final V value) {\n            super(next, hashCode, key, value);\n        }\n\n        @Override\n        public boolean equals(final Object obj) {\n            if (obj == this) {\n                return true;\n            }\n            if (!(obj instanceof Entry)) {\n                return false;\n            }\n            final Map.Entry<?, ?> other = (Map.Entry<?, ?>) obj;\n            return\n                getKey() == other.getKey() &&\n                getValue() == other.getValue();\n        }\n\n        @Override\n        public int hashCode() {\n            return System.identityHashCode(getKey()) ^\n                   System.identityHashCode(getValue());\n        }\n    }\n\n    /** Serialisation version */\n    private static final long serialVersionUID = 2028493495224302329L;\n\n    /**\n     * Constructs a new empty map with default size and load factor.\n     */\n    public IdentityMap() {\n        super(DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_THRESHOLD);\n    }\n\n    /**\n     * Constructs a new, empty map with the specified initial capacity.\n     *\n     * @param initialCapacity  the initial capacity\n     * @throws IllegalArgumentException if the initial capacity is negative\n     */\n    public IdentityMap(final int initialCapacity) {\n        super(initialCapacity);\n    }\n\n    /**\n     * Constructs a new, empty map with the specified initial capacity and\n     * load factor.\n     *\n     * @param initialCapacity  the initial capacity\n     * @param loadFactor  the load factor\n     * @throws IllegalArgumentException if the initial capacity is negative\n     * @throws IllegalArgumentException if the load factor is less than zero\n     */\n    public IdentityMap(final int initialCapacity, final float loadFactor) {\n        super(initialCapacity, loadFactor);\n    }\n\n    /**\n     * Constructor copying elements from another map.\n     *\n     * @param map  the map to copy\n     * @throws NullPointerException if the map is null\n     */\n    public IdentityMap(final Map<K, V> map) {\n        super(map);\n    }\n\n    /**\n     * Clones the map without cloning the keys or values.\n     *\n     * @return a shallow clone\n     */\n    @Override\n    public IdentityMap<K, V> clone() {\n        return (IdentityMap<K, V>) super.clone();\n    }\n\n    /**\n     * Creates an entry to store the data.\n     * This implementation creates an IdentityEntry instance.\n     *\n     * @param next  the next entry in sequence\n     * @param hashCode  the hash code to use\n     * @param key  the key to store\n     * @param value  the value to store\n     * @return the newly created entry\n     */\n    @Override\n    protected IdentityEntry<K, V> createEntry(final HashEntry<K, V> next, final int hashCode,\n                                              final K key, final V value) {\n        return new IdentityEntry<>(next, hashCode, key, value);\n    }\n\n    /**\n     * Gets the hash code for the key specified.\n     * This implementation uses the identity hash code.\n     *\n     * @param key  the key to get a hash code for\n     * @return the hash code\n     */\n    @Override\n    protected int hash(final Object key) {\n        return System.identityHashCode(key);\n    }\n\n    /**\n     * Compares two keys for equals.\n     * This implementation uses {@code ==}.\n     *\n     * @param key1  the first key to compare\n     * @param key2  the second key to compare\n     * @return true if equal by identity\n     */\n    @Override\n    protected boolean isEqualKey(final Object key1, final Object key2) {\n        return key1 == key2;\n    }\n\n    /**\n     * Compares two values for equals.\n     * This implementation uses {@code ==}.\n     *\n     * @param value1  the first value to compare\n     * @param value2  the second value to compare\n     * @return true if equal by identity\n     */\n    @Override\n    protected boolean isEqualValue(final Object value1, final Object value2) {\n        return value1 == value2;\n    }\n\n    /**\n     * Deserializes an instance from an ObjectInputStream.\n     *\n     * @param in The source ObjectInputStream.\n     * @throws IOException            Any of the usual Input/Output related exceptions.\n     * @throws ClassNotFoundException A class of a serialized object cannot be found.\n     */\n    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        doReadObject(in);\n    }\n\n    /**\n     * Serializes this object to an ObjectOutputStream.\n     *\n     * @param out the target ObjectOutputStream.\n     * @throws IOException thrown when an I/O errors occur writing to the target stream.\n     */\n    private void writeObject(final ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        doWriteObject(out);\n    }\n\n}", "super_interfaces": ["Serializable", "Cloneable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 2028493495224302329L;", "docstring": " Serialisation version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 2028493495224302329L", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/map/EmptyMapMutator.java.EmptyMapMutator", "name": "EmptyMapMutator", "file_path": "src/test/java/org/apache/commons/collections4/map/EmptyMapMutator.java", "superclasses": "", "methods": ["[V]put(CompositeMap<K, V>,Map<K, V>[],K,V)", "[void]putAll(CompositeMap<K, V>,Map<K, V>[],Map<? extends K, ? extends V>)", "[void]resolveCollision(CompositeMap<K, V>,Map<K, V>,Map<K, V>,Collection<K>)"], "method_uris": ["src/test/java/org/apache/commons/collections4/map/EmptyMapMutator.java.EmptyMapMutator.[V]put(CompositeMap<K, V>,Map<K, V>[],K,V)", "src/test/java/org/apache/commons/collections4/map/EmptyMapMutator.java.EmptyMapMutator.[void]putAll(CompositeMap<K, V>,Map<K, V>[],Map<? extends K, ? extends V>)", "src/test/java/org/apache/commons/collections4/map/EmptyMapMutator.java.EmptyMapMutator.[void]resolveCollision(CompositeMap<K, V>,Map<K, V>,Map<K, V>,Collection<K>)"], "overrides": null, "attributes": [], "class_docstring": "\nThis class is used in TestCompositeMap. When testing serialization,\nthe class has to be separate of TestCompositeMap, else the test\nclass also has to be serialized.\n", "original_string": "final class EmptyMapMutator<K, V> implements CompositeMap.MapMutator<K, V> {\n    /** Serialization version */\n    private static final long serialVersionUID = -2729718980002476794L;\n\n    @Override\n    public V put(final CompositeMap<K, V> map, final Map<K, V>[] composited, final K key, final V value) {\n        return composited[0].put(key, value);\n    }\n\n    @Override\n    public void putAll(final CompositeMap<K, V> map, final Map<K, V>[] composited, final Map<? extends K, ? extends V> t) {\n        composited[0].putAll(t);\n    }\n\n    @Override\n    public void resolveCollision(final CompositeMap<K, V> composite,\n        final Map<K, V> existing,\n        final Map<K, V> added,\n        final Collection<K> intersect) {\n        // Do nothing\n    }\n\n}", "super_interfaces": ["CompositeMap.MapMutator<K, V>"], "fields": [{"attribute_expression": "private static final long serialVersionUID = -2729718980002476794L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -2729718980002476794L", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/map/FixedSizeSortedMapTest.java.FixedSizeSortedMapTest", "name": "FixedSizeSortedMapTest", "file_path": "src/test/java/org/apache/commons/collections4/map/FixedSizeSortedMapTest.java", "superclasses": "", "methods": ["[]FixedSizeSortedMapTest()", "[String]getCompatibilityVersion()", "[boolean]isPutAddSupported()", "[boolean]isRemoveSupported()", "[boolean]isSubMapViewsSerializable()", "[SortedMap<K, V>]makeFullMap()", "[SortedMap<K, V>]makeObject()"], "method_uris": ["src/test/java/org/apache/commons/collections4/map/FixedSizeSortedMapTest.java.FixedSizeSortedMapTest.[]FixedSizeSortedMapTest()", "src/test/java/org/apache/commons/collections4/map/FixedSizeSortedMapTest.java.FixedSizeSortedMapTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/map/FixedSizeSortedMapTest.java.FixedSizeSortedMapTest.[boolean]isPutAddSupported()", "src/test/java/org/apache/commons/collections4/map/FixedSizeSortedMapTest.java.FixedSizeSortedMapTest.[boolean]isRemoveSupported()", "src/test/java/org/apache/commons/collections4/map/FixedSizeSortedMapTest.java.FixedSizeSortedMapTest.[boolean]isSubMapViewsSerializable()", "src/test/java/org/apache/commons/collections4/map/FixedSizeSortedMapTest.java.FixedSizeSortedMapTest.[SortedMap<K, V>]makeFullMap()", "src/test/java/org/apache/commons/collections4/map/FixedSizeSortedMapTest.java.FixedSizeSortedMapTest.[SortedMap<K, V>]makeObject()"], "overrides": null, "attributes": [], "class_docstring": "\nExtension of {@link AbstractSortedMapTest} for exercising the {@link FixedSizeSortedMap}\nimplementation.\n", "original_string": "public class FixedSizeSortedMapTest<K, V> extends AbstractSortedMapTest<K, V> {\n\n    public FixedSizeSortedMapTest() {\n        super(FixedSizeSortedMapTest.class.getSimpleName());\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    @Override\n    public boolean isPutAddSupported() {\n        return false;\n    }\n\n    @Override\n    public boolean isRemoveSupported() {\n        return false;\n    }\n\n    @Override\n    public boolean isSubMapViewsSerializable() {\n        // TreeMap sub map views have a bug in deserialization.\n        return false;\n    }\n\n    @Override\n    public SortedMap<K, V> makeFullMap() {\n        final SortedMap<K, V> map = new TreeMap<>();\n        addSampleMappings(map);\n        return FixedSizeSortedMap.fixedSizeSortedMap(map);\n    }\n\n    @Override\n    public SortedMap<K, V> makeObject() {\n        return FixedSizeSortedMap.fixedSizeSortedMap(new TreeMap<>());\n    }\n\n//    public void testCreate() throws Exception {\n//        resetEmpty();\n//        writeExternalFormToDisk(\n//            (java.io.Serializable) map,\n//            \"src/test/resources/data/test/FixedSizeSortedMap.emptyCollection.version4.obj\");\n//        resetFull();\n//        writeExternalFormToDisk(\n//            (java.io.Serializable) map,\n//            \"src/test/resources/data/test/FixedSizeSortedMap.fullCollection.version4.obj\");\n//    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/functors/CatchAndRethrowClosureTest.java.CatchAndRethrowClosureTest", "name": "CatchAndRethrowClosureTest", "file_path": "src/test/java/org/apache/commons/collections4/functors/CatchAndRethrowClosureTest.java", "superclasses": "AbstractClosureTest", "methods": ["[Closure<T>]generateIOExceptionClosure()", "[Closure<T>]generateNoExceptionClosure()", "[Closure<T>]generateNullPointerExceptionClosure()", "[Closure<T>]generateClosure()", "[Collection<DynamicTest>]testThrowingClosure()"], "method_uris": ["src/test/java/org/apache/commons/collections4/functors/CatchAndRethrowClosureTest.java.CatchAndRethrowClosureTest.[Closure<T>]generateIOExceptionClosure()", "src/test/java/org/apache/commons/collections4/functors/CatchAndRethrowClosureTest.java.CatchAndRethrowClosureTest.[Closure<T>]generateNoExceptionClosure()", "src/test/java/org/apache/commons/collections4/functors/CatchAndRethrowClosureTest.java.CatchAndRethrowClosureTest.[Closure<T>]generateNullPointerExceptionClosure()", "src/test/java/org/apache/commons/collections4/functors/CatchAndRethrowClosureTest.java.CatchAndRethrowClosureTest.[Closure<T>]generateClosure()", "src/test/java/org/apache/commons/collections4/functors/CatchAndRethrowClosureTest.java.CatchAndRethrowClosureTest.[Collection<DynamicTest>]testThrowingClosure()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class CatchAndRethrowClosureTest extends AbstractClosureTest {\n\n    private static <T> Closure<T> generateIOExceptionClosure() {\n        return new CatchAndRethrowClosure<T>() {\n\n            @Override\n            protected void executeAndThrow(final T input) throws IOException  {\n                throw new IOException();\n            }\n        };\n    }\n\n    private static <T> Closure<T> generateNoExceptionClosure() {\n        return new CatchAndRethrowClosure<T>() {\n\n            @Override\n            protected void executeAndThrow(final T input) {\n            }\n        };\n    }\n\n    private static <T> Closure<T> generateNullPointerExceptionClosure() {\n        return new CatchAndRethrowClosure<T>() {\n\n            @Override\n            protected void executeAndThrow(final T input) {\n                throw new NullPointerException();\n            }\n        };\n    }\n\n    @Override\n    protected <T> Closure<T> generateClosure() {\n        return generateNoExceptionClosure();\n    }\n\n    @TestFactory\n    public Collection<DynamicTest> testThrowingClosure() {\n\n        return Arrays.asList(\n\n                dynamicTest(\"Closure NoException\", () -> {\n                    final Closure<Integer> closure = generateNoExceptionClosure();\n                    closure.execute(Integer.valueOf(0));\n                }),\n                dynamicTest(\"Closure IOException\", () -> {\n                    final Closure<Integer> closure = generateIOExceptionClosure();\n                    final FunctorException thrown = assertThrows(FunctorException.class, () -> closure.execute(Integer.valueOf(0)));\n                    assertTrue(thrown.getCause() instanceof IOException);\n                }),\n                dynamicTest(\"Closure NullPointerException\", () -> {\n                    final Closure<Integer> closure = generateNullPointerExceptionClosure();\n                    assertThrows(NullPointerException.class, () -> closure.execute(Integer.valueOf(0)));\n                })\n\n        );\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/comparators/ComparableComparatorTest.java.ComparableComparatorTest", "name": "ComparableComparatorTest", "file_path": "src/test/java/org/apache/commons/collections4/comparators/ComparableComparatorTest.java", "superclasses": "", "methods": ["[]ComparableComparatorTest()", "[List<Integer>]getComparableObjectsOrdered()", "[String]getCompatibilityVersion()", "[Comparator<Integer>]makeObject()"], "method_uris": ["src/test/java/org/apache/commons/collections4/comparators/ComparableComparatorTest.java.ComparableComparatorTest.[]ComparableComparatorTest()", "src/test/java/org/apache/commons/collections4/comparators/ComparableComparatorTest.java.ComparableComparatorTest.[List<Integer>]getComparableObjectsOrdered()", "src/test/java/org/apache/commons/collections4/comparators/ComparableComparatorTest.java.ComparableComparatorTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/comparators/ComparableComparatorTest.java.ComparableComparatorTest.[Comparator<Integer>]makeObject()"], "overrides": null, "attributes": [], "class_docstring": "\nTests for ComparableComparator.\n", "original_string": "@SuppressWarnings(\"boxing\")\npublic class ComparableComparatorTest extends AbstractComparatorTest<Integer> {\n\n    public ComparableComparatorTest() {\n        super(ComparableComparatorTest.class.getSimpleName());\n    }\n\n    @Override\n    public List<Integer> getComparableObjectsOrdered() {\n        final List<Integer> list = new LinkedList<>();\n        list.add(1);\n        list.add(2);\n        list.add(3);\n        list.add(4);\n        list.add(5);\n        return list;\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    @Override\n    public Comparator<Integer> makeObject() {\n        return new ComparableComparator<>();\n    }\n\n//    public void testCreate() throws Exception {\n//        writeExternalFormToDisk((java.io.Serializable) makeObject(), \"src/test/resources/data/test/ComparableComparator.version4.obj\");\n//    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/trie/PatriciaTrie2Test.java.PatriciaTrie2Test", "name": "PatriciaTrie2Test", "file_path": "src/test/java/org/apache/commons/collections4/trie/PatriciaTrie2Test.java", "superclasses": "", "methods": ["[]PatriciaTrie2Test()", "[String]getCompatibilityVersion()", "[boolean]isAllowNullKey()", "[OrderedMap<String, V>]makeObject()"], "method_uris": ["src/test/java/org/apache/commons/collections4/trie/PatriciaTrie2Test.java.PatriciaTrie2Test.[]PatriciaTrie2Test()", "src/test/java/org/apache/commons/collections4/trie/PatriciaTrie2Test.java.PatriciaTrie2Test.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/trie/PatriciaTrie2Test.java.PatriciaTrie2Test.[boolean]isAllowNullKey()", "src/test/java/org/apache/commons/collections4/trie/PatriciaTrie2Test.java.PatriciaTrie2Test.[OrderedMap<String, V>]makeObject()"], "overrides": null, "attributes": [], "class_docstring": "\nJUnit test of the OrderedMap interface of a PatriciaTrie.\n", "original_string": "public class PatriciaTrie2Test<V> extends AbstractOrderedMapTest<String, V> {\n\n    public PatriciaTrie2Test() {\n        super(PatriciaTrie2Test.class.getSimpleName());\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    @Override\n    public boolean isAllowNullKey() {\n        return false;\n    }\n\n    @Override\n    public OrderedMap<String, V> makeObject() {\n        return new PatriciaTrie<>();\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/iterators/ArrayListIterator2Test.java.ArrayListIterator2Test", "name": "ArrayListIterator2Test", "file_path": "src/test/java/org/apache/commons/collections4/iterators/ArrayListIterator2Test.java", "superclasses": "", "methods": ["[]ArrayListIterator2Test()", "[ArrayListIterator<E>]makeArrayListIterator(Object)", "[ArrayListIterator<E>]makeArrayListIterator(Object,int)", "[ArrayListIterator<E>]makeArrayListIterator(Object,int,int)", "[ArrayListIterator<E>]makeEmptyIterator()", "[ArrayListIterator<E>]makeObject()"], "method_uris": ["src/test/java/org/apache/commons/collections4/iterators/ArrayListIterator2Test.java.ArrayListIterator2Test.[]ArrayListIterator2Test()", "src/test/java/org/apache/commons/collections4/iterators/ArrayListIterator2Test.java.ArrayListIterator2Test.[ArrayListIterator<E>]makeArrayListIterator(Object)", "src/test/java/org/apache/commons/collections4/iterators/ArrayListIterator2Test.java.ArrayListIterator2Test.[ArrayListIterator<E>]makeArrayListIterator(Object,int)", "src/test/java/org/apache/commons/collections4/iterators/ArrayListIterator2Test.java.ArrayListIterator2Test.[ArrayListIterator<E>]makeArrayListIterator(Object,int,int)", "src/test/java/org/apache/commons/collections4/iterators/ArrayListIterator2Test.java.ArrayListIterator2Test.[ArrayListIterator<E>]makeEmptyIterator()", "src/test/java/org/apache/commons/collections4/iterators/ArrayListIterator2Test.java.ArrayListIterator2Test.[ArrayListIterator<E>]makeObject()"], "overrides": null, "attributes": [], "class_docstring": "\nTest the ArrayListIterator class with primitives.\n\n@param <E> the type of elements tested by this iterator.\n", "original_string": "public class ArrayListIterator2Test<E> extends ArrayIterator2Test<E> {\n\n    public ArrayListIterator2Test() {\n    }\n\n    public ArrayListIterator<E> makeArrayListIterator(final Object array) {\n        return new ArrayListIterator<>(array);\n    }\n\n    public ArrayListIterator<E> makeArrayListIterator(final Object array, final int index) {\n        return new ArrayListIterator<>(array, index);\n    }\n\n    public ArrayListIterator<E> makeArrayListIterator(final Object array, final int start, final int end) {\n        return new ArrayListIterator<>(array, start, end);\n    }\n\n    @Override\n    public ArrayListIterator<E> makeEmptyIterator() {\n        return new ArrayListIterator<>(new int[0]);\n    }\n\n    @Override\n    public ArrayListIterator<E> makeObject() {\n        return new ArrayListIterator<>(testArray);\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/iterators/ObjectArrayListIterator2Test.java.ObjectArrayListIterator2Test", "name": "ObjectArrayListIterator2Test", "file_path": "src/test/java/org/apache/commons/collections4/iterators/ObjectArrayListIterator2Test.java", "superclasses": "", "methods": ["[]ObjectArrayListIterator2Test()", "[ObjectArrayListIterator<E>]makeArrayListIterator(E[])", "[ObjectArrayListIterator<E>]makeEmptyIterator()", "[ObjectArrayListIterator<E>]makeObject()", "[boolean]supportsAdd()", "[boolean]supportsRemove()"], "method_uris": ["src/test/java/org/apache/commons/collections4/iterators/ObjectArrayListIterator2Test.java.ObjectArrayListIterator2Test.[]ObjectArrayListIterator2Test()", "src/test/java/org/apache/commons/collections4/iterators/ObjectArrayListIterator2Test.java.ObjectArrayListIterator2Test.[ObjectArrayListIterator<E>]makeArrayListIterator(E[])", "src/test/java/org/apache/commons/collections4/iterators/ObjectArrayListIterator2Test.java.ObjectArrayListIterator2Test.[ObjectArrayListIterator<E>]makeEmptyIterator()", "src/test/java/org/apache/commons/collections4/iterators/ObjectArrayListIterator2Test.java.ObjectArrayListIterator2Test.[ObjectArrayListIterator<E>]makeObject()", "src/test/java/org/apache/commons/collections4/iterators/ObjectArrayListIterator2Test.java.ObjectArrayListIterator2Test.[boolean]supportsAdd()", "src/test/java/org/apache/commons/collections4/iterators/ObjectArrayListIterator2Test.java.ObjectArrayListIterator2Test.[boolean]supportsRemove()"], "overrides": null, "attributes": [], "class_docstring": "\nTests the ObjectArrayListIterator class.\n\n@param <E> the type of elements tested by this iterator.\n", "original_string": "public class ObjectArrayListIterator2Test<E> extends AbstractListIteratorTest<E> {\n\n    protected String[] testArray = { \"One\", \"Two\", \"Three\" };\n\n    public ObjectArrayListIterator2Test() {\n        super(ObjectArrayListIterator2Test.class.getSimpleName());\n    }\n\n    public ObjectArrayListIterator<E> makeArrayListIterator(final E[] array) {\n        return new ObjectArrayListIterator<>(array);\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public ObjectArrayListIterator<E> makeEmptyIterator() {\n        return new ObjectArrayListIterator<>((E[]) new Object[0]);\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public ObjectArrayListIterator<E> makeObject() {\n        return new ObjectArrayListIterator<>((E[]) testArray);\n    }\n\n    @Override\n    public boolean supportsAdd() {\n        return false;\n    }\n\n    @Override\n    public boolean supportsRemove() {\n        return false;\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "protected String[] testArray = { \"One\", \"Two\", \"Three\" };", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "String[]", "name": "testArray = { \"One\", \"Two\", \"Three\" }", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/bidimap/TreeBidiMapTest.java.TreeBidiMapTest", "name": "TreeBidiMapTest", "file_path": "src/test/java/org/apache/commons/collections4/bidimap/TreeBidiMapTest.java", "superclasses": "", "methods": ["[]TreeBidiMapTest()", "[String]getCompatibilityVersion()", "[String[]]ignoredTests()", "[boolean]isAllowNullKey()", "[boolean]isAllowNullValue()", "[boolean]isSetValueSupported()", "[TreeMap<K, V>]makeConfirmedMap()", "[BidiMap<K, V>]makeObject()"], "method_uris": ["src/test/java/org/apache/commons/collections4/bidimap/TreeBidiMapTest.java.TreeBidiMapTest.[]TreeBidiMapTest()", "src/test/java/org/apache/commons/collections4/bidimap/TreeBidiMapTest.java.TreeBidiMapTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/bidimap/TreeBidiMapTest.java.TreeBidiMapTest.[String[]]ignoredTests()", "src/test/java/org/apache/commons/collections4/bidimap/TreeBidiMapTest.java.TreeBidiMapTest.[boolean]isAllowNullKey()", "src/test/java/org/apache/commons/collections4/bidimap/TreeBidiMapTest.java.TreeBidiMapTest.[boolean]isAllowNullValue()", "src/test/java/org/apache/commons/collections4/bidimap/TreeBidiMapTest.java.TreeBidiMapTest.[boolean]isSetValueSupported()", "src/test/java/org/apache/commons/collections4/bidimap/TreeBidiMapTest.java.TreeBidiMapTest.[TreeMap<K, V>]makeConfirmedMap()", "src/test/java/org/apache/commons/collections4/bidimap/TreeBidiMapTest.java.TreeBidiMapTest.[BidiMap<K, V>]makeObject()"], "overrides": null, "attributes": [], "class_docstring": "\nJUnit tests.\n", "original_string": "public class TreeBidiMapTest<K extends Comparable<K>, V extends Comparable<V>> extends AbstractOrderedBidiMapTest<K, V> {\n\n    public TreeBidiMapTest() {\n        super(TreeBidiMapTest.class.getSimpleName());\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    /**\n     * Override to prevent infinite recursion of tests.\n     */\n    @Override\n    public String[] ignoredTests() {\n        return new String[] {\"TreeBidiMapTest.bulkTestInverseMap.bulkTestInverseMap\"};\n    }\n\n    @Override\n    public boolean isAllowNullKey() {\n        return false;\n    }\n\n    @Override\n    public boolean isAllowNullValue() {\n        return false;\n    }\n\n    @Override\n    public boolean isSetValueSupported() {\n        return false;\n    }\n\n    @Override\n    public TreeMap<K, V> makeConfirmedMap() {\n        return new TreeMap<>();\n    }\n\n    @Override\n    public BidiMap<K, V> makeObject() {\n        return new TreeBidiMap<>();\n    }\n\n//    public void testCreate() throws Exception {\n//        resetEmpty();\n//        writeExternalFormToDisk((java.io.Serializable) map, \"src/test/resources/data/test/TreeBidiMap.emptyCollection.version4.obj\");\n//        resetFull();\n//        writeExternalFormToDisk((java.io.Serializable) map, \"src/test/resources/data/test/TreeBidiMap.fullCollection.version4.obj\");\n//    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/bidimap/DualHashBidiMapTest.java.DualHashBidiMapTest", "name": "DualHashBidiMapTest", "file_path": "src/test/java/org/apache/commons/collections4/bidimap/DualHashBidiMapTest.java", "superclasses": "", "methods": ["[]DualHashBidiMapTest()", "[int]getIterationBehaviour()", "[String[]]ignoredTests()", "[DualHashBidiMap<K, V>]makeObject()"], "method_uris": ["src/test/java/org/apache/commons/collections4/bidimap/DualHashBidiMapTest.java.DualHashBidiMapTest.[]DualHashBidiMapTest()", "src/test/java/org/apache/commons/collections4/bidimap/DualHashBidiMapTest.java.DualHashBidiMapTest.[int]getIterationBehaviour()", "src/test/java/org/apache/commons/collections4/bidimap/DualHashBidiMapTest.java.DualHashBidiMapTest.[String[]]ignoredTests()", "src/test/java/org/apache/commons/collections4/bidimap/DualHashBidiMapTest.java.DualHashBidiMapTest.[DualHashBidiMap<K, V>]makeObject()"], "overrides": null, "attributes": [], "class_docstring": "\nJUnit tests.\n", "original_string": "public class DualHashBidiMapTest<K, V> extends AbstractBidiMapTest<K, V> {\n\n    public DualHashBidiMapTest() {\n        super(DualHashBidiMapTest.class.getSimpleName());\n    }\n\n    @Override\n    protected int getIterationBehaviour() {\n        return AbstractCollectionTest.UNORDERED;\n    }\n\n    /**\n     * Override to prevent infinite recursion of tests.\n     */\n    @Override\n    public String[] ignoredTests() {\n        return new String[] { \"DualHashBidiMapTest.bulkTestInverseMap.bulkTestInverseMap\" };\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public DualHashBidiMap<K, V> makeObject() {\n        return new DualHashBidiMap<>();\n    }\n\n//    public void testCreate() throws Exception {\n//        resetEmpty();\n//        writeExternalFormToDisk((java.io.Serializable) map, \"src/test/resources/data/test/DualHashBidiMap.emptyCollection.version4.obj\");\n//        resetFull();\n//        writeExternalFormToDisk((java.io.Serializable) map, \"src/test/resources/data/test/DualHashBidiMap.fullCollection.version4.obj\");\n//    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/bidimap/DualLinkedHashBidiMapTest.java.DualLinkedHashBidiMapTest", "name": "DualLinkedHashBidiMapTest", "file_path": "src/test/java/org/apache/commons/collections4/bidimap/DualLinkedHashBidiMapTest.java", "superclasses": "", "methods": ["[]DualLinkedHashBidiMapTest()", "[String]getCompatibilityVersion()", "[String[]]ignoredTests()", "[DualLinkedHashBidiMap<K, V>]makeObject()"], "method_uris": ["src/test/java/org/apache/commons/collections4/bidimap/DualLinkedHashBidiMapTest.java.DualLinkedHashBidiMapTest.[]DualLinkedHashBidiMapTest()", "src/test/java/org/apache/commons/collections4/bidimap/DualLinkedHashBidiMapTest.java.DualLinkedHashBidiMapTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/bidimap/DualLinkedHashBidiMapTest.java.DualLinkedHashBidiMapTest.[String[]]ignoredTests()", "src/test/java/org/apache/commons/collections4/bidimap/DualLinkedHashBidiMapTest.java.DualLinkedHashBidiMapTest.[DualLinkedHashBidiMap<K, V>]makeObject()"], "overrides": null, "attributes": [], "class_docstring": "\nJUnit tests.\n", "original_string": "public class DualLinkedHashBidiMapTest<K, V> extends AbstractBidiMapTest<K, V> {\n\n    public DualLinkedHashBidiMapTest() {\n        super(DualLinkedHashBidiMapTest.class.getSimpleName());\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    /**\n     * Override to prevent infinite recursion of tests.\n     */\n    @Override\n    public String[] ignoredTests() {\n        return new String[] { \"DualLinkedHashBidiMapTest.bulkTestInverseMap.bulkTestInverseMap\" };\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public DualLinkedHashBidiMap<K, V> makeObject() {\n        return new DualLinkedHashBidiMap<>();\n    }\n\n//    public void testCreate() throws Exception {\n//        resetEmpty();\n//        writeExternalFormToDisk((java.io.Serializable) map, \"src/test/resources/data/test/DualLinkedHashBidiMap.emptyCollection.version4.obj\");\n//        resetFull();\n//        writeExternalFormToDisk((java.io.Serializable) map, \"src/test/resources/data/test/DualLinkedHashBidiMap.fullCollection.version4.obj\");\n//    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/bidimap/AbstractOrderedBidiMapDecoratorTest.java.AbstractOrderedBidiMapDecoratorTest", "name": "AbstractOrderedBidiMapDecoratorTest", "file_path": "src/test/java/org/apache/commons/collections4/bidimap/AbstractOrderedBidiMapDecoratorTest.java", "superclasses": "", "methods": ["[]AbstractOrderedBidiMapDecoratorTest(String)", "[boolean]isAllowNullKey()", "[boolean]isAllowNullValue()", "[boolean]isSetValueSupported()", "[SortedMap<K, V>]makeConfirmedMap()", "[OrderedBidiMap<K, V>]makeObject()"], "method_uris": ["src/test/java/org/apache/commons/collections4/bidimap/AbstractOrderedBidiMapDecoratorTest.java.AbstractOrderedBidiMapDecoratorTest.[]AbstractOrderedBidiMapDecoratorTest(String)", "src/test/java/org/apache/commons/collections4/bidimap/AbstractOrderedBidiMapDecoratorTest.java.AbstractOrderedBidiMapDecoratorTest.[boolean]isAllowNullKey()", "src/test/java/org/apache/commons/collections4/bidimap/AbstractOrderedBidiMapDecoratorTest.java.AbstractOrderedBidiMapDecoratorTest.[boolean]isAllowNullValue()", "src/test/java/org/apache/commons/collections4/bidimap/AbstractOrderedBidiMapDecoratorTest.java.AbstractOrderedBidiMapDecoratorTest.[boolean]isSetValueSupported()", "src/test/java/org/apache/commons/collections4/bidimap/AbstractOrderedBidiMapDecoratorTest.java.AbstractOrderedBidiMapDecoratorTest.[SortedMap<K, V>]makeConfirmedMap()", "src/test/java/org/apache/commons/collections4/bidimap/AbstractOrderedBidiMapDecoratorTest.java.AbstractOrderedBidiMapDecoratorTest.[OrderedBidiMap<K, V>]makeObject()"], "overrides": null, "attributes": [{"original_string": "    private static final class TestOrderedBidiMap<K, V> extends AbstractOrderedBidiMapDecorator<K, V> {\n\n        private TestOrderedBidiMap<V, K> inverse;\n\n        TestOrderedBidiMap() {\n            super(new DualTreeBidiMap<>());\n        }\n\n        TestOrderedBidiMap(final OrderedBidiMap<K, V> map) {\n            super(map);\n        }\n\n        @Override\n        public OrderedBidiMap<V, K> inverseBidiMap() {\n            if (inverse == null) {\n                inverse = new TestOrderedBidiMap<>(decorated().inverseBidiMap());\n                inverse.inverse = this;\n            }\n            return inverse;\n        }\n    }", "definition": "    private static final class TestOrderedBidiMap<K, V> extends AbstractOrderedBidiMapDecorator<K, V>", "class_docstring": "\nSimple class to actually test.\n", "name": "TestOrderedBidiMap", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "fields": [{"attribute_expression": "private TestOrderedBidiMap<V, K> inverse;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "TestOrderedBidiMap<V, K>", "name": "inverse", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        TestOrderedBidiMap() {\n            super(new DualTreeBidiMap<>());\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "TestOrderedBidiMap", "params": [], "body": "                             {\n            super(new DualTreeBidiMap<>());\n        }", "signature": "TestOrderedBidiMap()"}, {"syntax_pass": true, "original_string": "        TestOrderedBidiMap(final OrderedBidiMap<K, V> map) {\n            super(map);\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "TestOrderedBidiMap", "params": [{"name": "map", "type": "OrderedBidiMap<K, V>"}], "body": "                                                           {\n            super(map);\n        }", "signature": "TestOrderedBidiMap(final OrderedBidiMap<K, V> map)"}, {"syntax_pass": true, "original_string": "        @Override\n        public OrderedBidiMap<V, K> inverseBidiMap() {\n            if (inverse == null) {\n                inverse = new TestOrderedBidiMap<>(decorated().inverseBidiMap());\n                inverse.inverse = this;\n            }\n            return inverse;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "OrderedBidiMap<V, K>", "classes": []}, "name": "inverseBidiMap", "params": [], "body": "                                                     {\n            if (inverse == null) {\n                inverse = new TestOrderedBidiMap<>(decorated().inverseBidiMap());\n                inverse.inverse = this;\n            }\n            return inverse;\n        }", "signature": "@Override\n        public OrderedBidiMap<V, K> inverseBidiMap()"}]}], "class_docstring": "\nTest class for AbstractOrderedBidiMapDecorator.\n\n@param <K> the type of the keys in this map\n@param <V> the type of the values in this map\n", "original_string": "public class AbstractOrderedBidiMapDecoratorTest<K, V>\n        extends AbstractOrderedBidiMapTest<K, V> {\n\n    /**\n     * Simple class to actually test.\n     */\n    private static final class TestOrderedBidiMap<K, V> extends AbstractOrderedBidiMapDecorator<K, V> {\n\n        private TestOrderedBidiMap<V, K> inverse;\n\n        TestOrderedBidiMap() {\n            super(new DualTreeBidiMap<>());\n        }\n\n        TestOrderedBidiMap(final OrderedBidiMap<K, V> map) {\n            super(map);\n        }\n\n        @Override\n        public OrderedBidiMap<V, K> inverseBidiMap() {\n            if (inverse == null) {\n                inverse = new TestOrderedBidiMap<>(decorated().inverseBidiMap());\n                inverse.inverse = this;\n            }\n            return inverse;\n        }\n    }\n\n    public AbstractOrderedBidiMapDecoratorTest(final String testName) {\n        super(testName);\n    }\n\n    @Override\n    public boolean isAllowNullKey() {\n        return false;\n    }\n\n    @Override\n    public boolean isAllowNullValue() {\n        return false;\n    }\n\n    @Override\n    public boolean isSetValueSupported() {\n        return true;\n    }\n\n    @Override\n    public SortedMap<K, V> makeConfirmedMap() {\n        return new TreeMap<>();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public OrderedBidiMap<K, V> makeObject() {\n        return new TestOrderedBidiMap<>();\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/bidimap/DualTreeBidiMapTest.java.DualTreeBidiMapTest", "name": "DualTreeBidiMapTest", "file_path": "src/test/java/org/apache/commons/collections4/bidimap/DualTreeBidiMapTest.java", "superclasses": "", "methods": ["[]DualTreeBidiMapTest()", "[String[]]ignoredTests()", "[DualTreeBidiMap<K, V>]makeObject()"], "method_uris": ["src/test/java/org/apache/commons/collections4/bidimap/DualTreeBidiMapTest.java.DualTreeBidiMapTest.[]DualTreeBidiMapTest()", "src/test/java/org/apache/commons/collections4/bidimap/DualTreeBidiMapTest.java.DualTreeBidiMapTest.[String[]]ignoredTests()", "src/test/java/org/apache/commons/collections4/bidimap/DualTreeBidiMapTest.java.DualTreeBidiMapTest.[DualTreeBidiMap<K, V>]makeObject()"], "overrides": null, "attributes": [], "class_docstring": "\nJUnit tests.\n", "original_string": "public class DualTreeBidiMapTest<K extends Comparable<K>, V extends Comparable<V>> extends AbstractSortedBidiMapTest<K, V> {\n\n    public DualTreeBidiMapTest() {\n        super(DualTreeBidiMapTest.class.getSimpleName());\n    }\n\n    /**\n     * Override to prevent infinite recursion of tests.\n     */\n    @Override\n    public String[] ignoredTests() {\n        final String recursiveTest = \"DualTreeBidiMapTest.bulkTestInverseMap.bulkTestInverseMap\";\n        return new String[] { recursiveTest };\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public DualTreeBidiMap<K, V> makeObject() {\n        return new DualTreeBidiMap<>();\n    }\n\n//    public void testCreate() throws Exception {\n//        resetEmpty();\n//        writeExternalFormToDisk((java.io.Serializable) map, \"src/test/resources/data/test/DualTreeBidiMap.emptyCollection.version4.obj\");\n//        resetFull();\n//        writeExternalFormToDisk((java.io.Serializable) map, \"src/test/resources/data/test/DualTreeBidiMap.fullCollection.version4.obj\");\n//    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/set/EmptySetMutator.java.EmptySetMutator", "name": "EmptySetMutator", "file_path": "src/test/java/org/apache/commons/collections4/set/EmptySetMutator.java", "superclasses": "", "methods": ["[]EmptySetMutator(Set<E>)", "[boolean]add(CompositeSet<E>,List<Set<E>>,E)", "[boolean]addAll(CompositeSet<E>,List<Set<E>>,Collection<? extends E>)", "[void]resolveCollision(CompositeSet<E>,Set<E>,Set<E>,Collection<E>)"], "method_uris": ["src/test/java/org/apache/commons/collections4/set/EmptySetMutator.java.EmptySetMutator.[]EmptySetMutator(Set<E>)", "src/test/java/org/apache/commons/collections4/set/EmptySetMutator.java.EmptySetMutator.[boolean]add(CompositeSet<E>,List<Set<E>>,E)", "src/test/java/org/apache/commons/collections4/set/EmptySetMutator.java.EmptySetMutator.[boolean]addAll(CompositeSet<E>,List<Set<E>>,Collection<? extends E>)", "src/test/java/org/apache/commons/collections4/set/EmptySetMutator.java.EmptySetMutator.[void]resolveCollision(CompositeSet<E>,Set<E>,Set<E>,Collection<E>)"], "overrides": null, "attributes": [], "class_docstring": "\nThis class is used in CompositeSetTest. When testing serialization,\nthe class has to be separate of CompositeSetTest, else the test\nclass also has to be serialized.\n", "original_string": "final class EmptySetMutator<E> implements CompositeSet.SetMutator<E> {\n\n    /** Serialization version */\n    private static final long serialVersionUID = 5321193666420238910L;\n\n    private final Set<E> contained;\n\n    EmptySetMutator(final Set<E> contained) {\n        this.contained = contained;\n    }\n\n    @Override\n    public boolean add(final CompositeSet<E> composite, final List<Set<E>> collections, final E obj) {\n        return contained.add(obj);\n    }\n\n    @Override\n    public boolean addAll(final CompositeSet<E> composite, final List<Set<E>> collections, final Collection<? extends E> coll) {\n        return contained.addAll(coll);\n    }\n\n    @Override\n    public void resolveCollision(final CompositeSet<E> comp, final Set<E> existing, final Set<E> added, final Collection<E> intersects) {\n        throw new IllegalArgumentException();\n    }\n}", "super_interfaces": ["CompositeSet.SetMutator<E>"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 5321193666420238910L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 5321193666420238910L", "syntax_pass": true}, {"attribute_expression": "private final Set<E> contained;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Set<E>", "name": "contained", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/set/MapBackedSetTest.java.MapBackedSetTest", "name": "MapBackedSetTest", "file_path": "src/test/java/org/apache/commons/collections4/set/MapBackedSetTest.java", "superclasses": "", "methods": ["[]MapBackedSetTest()", "[String]getCompatibilityVersion()", "[Set<E>]makeObject()"], "method_uris": ["src/test/java/org/apache/commons/collections4/set/MapBackedSetTest.java.MapBackedSetTest.[]MapBackedSetTest()", "src/test/java/org/apache/commons/collections4/set/MapBackedSetTest.java.MapBackedSetTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/set/MapBackedSetTest.java.MapBackedSetTest.[Set<E>]makeObject()"], "overrides": null, "attributes": [], "class_docstring": "\nJUnit test.\n", "original_string": "public class MapBackedSetTest<E> extends AbstractSetTest<E> {\n\n    public MapBackedSetTest() {\n        super(MapBackedSetTest.class.getSimpleName());\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    @Override\n    public Set<E> makeObject() {\n        return MapBackedSet.mapBackedSet(new HashedMap<>());\n    }\n\n//    public void testCreate() throws Exception {\n//        resetEmpty();\n//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/MapBackedSet.emptyCollection.version4.obj\");\n//        resetFull();\n//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/MapBackedSet.fullCollection.version4.obj\");\n//    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/junit/ObjectToStringComparator.java.ObjectToStringComparator", "name": "ObjectToStringComparator", "file_path": "src/test/java/org/apache/commons/collections4/junit/ObjectToStringComparator.java", "superclasses": "", "methods": ["[int]compare(Object,Object)"], "method_uris": ["src/test/java/org/apache/commons/collections4/junit/ObjectToStringComparator.java.ObjectToStringComparator.[int]compare(Object,Object)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public final class ObjectToStringComparator implements Comparator<Object>, Serializable {\n\n    /**\n     * Singleton instance.\n     */\n    public static final ObjectToStringComparator INSTANCE = new ObjectToStringComparator();\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public int compare(final Object o1, final Object o2) {\n        if (o1 == null && o2 == null) {\n            return 0;\n        }\n        if (o1 == null) {\n            return 1;\n        }\n        if (o2 == null) {\n            return -1;\n        }\n        return o1.toString().compareTo(o2.toString());\n    }\n}", "super_interfaces": ["Comparator<Object>", "Serializable"], "fields": [{"attribute_expression": "public static final ObjectToStringComparator INSTANCE = new ObjectToStringComparator();", "docstring": "\nSingleton instance.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "ObjectToStringComparator", "name": "INSTANCE = new ObjectToStringComparator()", "syntax_pass": true}, {"attribute_expression": "private static final long serialVersionUID = 1L;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 1L", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromSimpleBloomFilterTest.java.IndexExtractorFromSimpleBloomFilterTest", "name": "IndexExtractorFromSimpleBloomFilterTest", "file_path": "src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromSimpleBloomFilterTest.java", "superclasses": "AbstractIndexExtractorTest", "methods": ["[IndexExtractor]createEmptyExtractor()", "[IndexExtractor]createExtractor()", "[int]getAsIndexArrayBehaviour()", "[int[]]getExpectedIndices()"], "method_uris": ["src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromSimpleBloomFilterTest.java.IndexExtractorFromSimpleBloomFilterTest.[IndexExtractor]createEmptyExtractor()", "src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromSimpleBloomFilterTest.java.IndexExtractorFromSimpleBloomFilterTest.[IndexExtractor]createExtractor()", "src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromSimpleBloomFilterTest.java.IndexExtractorFromSimpleBloomFilterTest.[int]getAsIndexArrayBehaviour()", "src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromSimpleBloomFilterTest.java.IndexExtractorFromSimpleBloomFilterTest.[int[]]getExpectedIndices()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class IndexExtractorFromSimpleBloomFilterTest extends AbstractIndexExtractorTest {\n\n    protected Shape shape = Shape.fromKM(17, 72);\n\n    @Override\n    protected IndexExtractor createEmptyExtractor() {\n        return new SimpleBloomFilter(shape);\n    }\n\n    @Override\n    protected IndexExtractor createExtractor() {\n        final Hasher hasher = new IncrementingHasher(3, 2);\n        final BloomFilter bf = new SimpleBloomFilter(shape);\n        bf.merge(hasher);\n        return bf;\n    }\n\n    @Override\n    protected int getAsIndexArrayBehaviour() {\n        return DISTINCT | ORDERED;\n    }\n\n    @Override\n    protected int[] getExpectedIndices() {\n        return new int[] {3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35};\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "protected Shape shape = Shape.fromKM(17, 72);", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Shape", "name": "shape = Shape.fromKM(17, 72)", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/bloomfilter/BitMapExtractorFromWrappedBloomFilterTest.java.BitMapExtractorFromWrappedBloomFilterTest", "name": "BitMapExtractorFromWrappedBloomFilterTest", "file_path": "src/test/java/org/apache/commons/collections4/bloomfilter/BitMapExtractorFromWrappedBloomFilterTest.java", "superclasses": "AbstractBitMapExtractorTest", "methods": ["[BitMapExtractor]createEmptyExtractor()", "[BitMapExtractor]createExtractor()"], "method_uris": ["src/test/java/org/apache/commons/collections4/bloomfilter/BitMapExtractorFromWrappedBloomFilterTest.java.BitMapExtractorFromWrappedBloomFilterTest.[BitMapExtractor]createEmptyExtractor()", "src/test/java/org/apache/commons/collections4/bloomfilter/BitMapExtractorFromWrappedBloomFilterTest.java.BitMapExtractorFromWrappedBloomFilterTest.[BitMapExtractor]createExtractor()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class BitMapExtractorFromWrappedBloomFilterTest extends AbstractBitMapExtractorTest {\n\n    protected Shape shape = Shape.fromKM(17, 72);\n\n    @Override\n    protected BitMapExtractor createEmptyExtractor() {\n        return new WrappedBloomFilter(new DefaultBloomFilterTest.SparseDefaultBloomFilter(shape)) {\n            @Override\n            public BloomFilter copy() {\n                final BloomFilter result = new DefaultBloomFilterTest.SparseDefaultBloomFilter(shape);\n                result.merge(getWrapped());\n                return result;\n            }\n        };\n    }\n\n    @Override\n    protected BitMapExtractor createExtractor() {\n        final Hasher hasher = new IncrementingHasher(0, 1);\n        final BloomFilter bf = new WrappedBloomFilter(new DefaultBloomFilterTest.SparseDefaultBloomFilter(shape)) {\n            @Override\n            public BloomFilter copy() {\n                final BloomFilter result = new DefaultBloomFilterTest.SparseDefaultBloomFilter(shape);\n                result.merge(getWrapped());\n                return result;\n            }\n        };\n        bf.merge(hasher);\n        return bf;\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "protected Shape shape = Shape.fromKM(17, 72);", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Shape", "name": "shape = Shape.fromKM(17, 72)", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/bloomfilter/CellExtractorFromDefaultIndexExtractorTest.java.CellExtractorFromDefaultIndexExtractorTest", "name": "CellExtractorFromDefaultIndexExtractorTest", "file_path": "src/test/java/org/apache/commons/collections4/bloomfilter/CellExtractorFromDefaultIndexExtractorTest.java", "superclasses": "AbstractCellExtractorTest", "methods": ["[CellExtractor]createEmptyExtractor()", "[CellExtractor]createExtractor()", "[int[]]getExpectedIndices()", "[int[]]getExpectedValues()"], "method_uris": ["src/test/java/org/apache/commons/collections4/bloomfilter/CellExtractorFromDefaultIndexExtractorTest.java.CellExtractorFromDefaultIndexExtractorTest.[CellExtractor]createEmptyExtractor()", "src/test/java/org/apache/commons/collections4/bloomfilter/CellExtractorFromDefaultIndexExtractorTest.java.CellExtractorFromDefaultIndexExtractorTest.[CellExtractor]createExtractor()", "src/test/java/org/apache/commons/collections4/bloomfilter/CellExtractorFromDefaultIndexExtractorTest.java.CellExtractorFromDefaultIndexExtractorTest.[int[]]getExpectedIndices()", "src/test/java/org/apache/commons/collections4/bloomfilter/CellExtractorFromDefaultIndexExtractorTest.java.CellExtractorFromDefaultIndexExtractorTest.[int[]]getExpectedValues()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class CellExtractorFromDefaultIndexExtractorTest extends AbstractCellExtractorTest {\n\n    int[] data = {0, 63, 1, 64, 128, 1, 127};\n    int[] indices = {0, 1, 63, 64, 127, 128};\n    int[] values = {1, 2, 1, 1, 1, 1 };\n\n    @Override\n    protected CellExtractor createEmptyExtractor() {\n        return CellExtractor.from(IndexExtractor.fromIndexArray());\n    }\n\n    @Override\n    protected CellExtractor createExtractor() {\n        return CellExtractor.from(IndexExtractor.fromIndexArray(data));\n    }\n\n    @Override\n    protected int[] getExpectedIndices() {\n        return indices;\n    }\n\n    @Override\n    protected int[] getExpectedValues() {\n        return values;\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "int[] data = {0, 63, 1, 64, 128, 1, 127};", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int[]", "name": "data = {0, 63, 1, 64, 128, 1, 127}", "syntax_pass": true}, {"attribute_expression": "int[] indices = {0, 1, 63, 64, 127, 128};", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int[]", "name": "indices = {0, 1, 63, 64, 127, 128}", "syntax_pass": true}, {"attribute_expression": "int[] values = {1, 2, 1, 1, 1, 1 };", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int[]", "name": "values = {1, 2, 1, 1, 1, 1 }", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/bloomfilter/CellExtractorFromLayeredBloomFilterTest.java.CellExtractorFromLayeredBloomFilterTest", "name": "CellExtractorFromLayeredBloomFilterTest", "file_path": "src/test/java/org/apache/commons/collections4/bloomfilter/CellExtractorFromLayeredBloomFilterTest.java", "superclasses": "AbstractCellExtractorTest", "methods": ["[CellExtractor]createEmptyExtractor()", "[CellExtractor]createExtractor()", "[int[]]getExpectedIndices()", "[int[]]getExpectedValues()"], "method_uris": ["src/test/java/org/apache/commons/collections4/bloomfilter/CellExtractorFromLayeredBloomFilterTest.java.CellExtractorFromLayeredBloomFilterTest.[CellExtractor]createEmptyExtractor()", "src/test/java/org/apache/commons/collections4/bloomfilter/CellExtractorFromLayeredBloomFilterTest.java.CellExtractorFromLayeredBloomFilterTest.[CellExtractor]createExtractor()", "src/test/java/org/apache/commons/collections4/bloomfilter/CellExtractorFromLayeredBloomFilterTest.java.CellExtractorFromLayeredBloomFilterTest.[int[]]getExpectedIndices()", "src/test/java/org/apache/commons/collections4/bloomfilter/CellExtractorFromLayeredBloomFilterTest.java.CellExtractorFromLayeredBloomFilterTest.[int[]]getExpectedValues()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class CellExtractorFromLayeredBloomFilterTest extends AbstractCellExtractorTest {\n\n    protected Shape shape = Shape.fromKM(17, 72);\n\n    @Override\n    protected CellExtractor createEmptyExtractor() {\n        return CellExtractor.from(LayeredBloomFilterTest.fixed(shape, 10));\n    }\n\n    @Override\n    protected CellExtractor createExtractor() {\n        final Hasher hasher = new IncrementingHasher(3, 2);\n        final BloomFilter bf = LayeredBloomFilterTest.fixed(shape, 10);\n        bf.merge(hasher);\n        return CellExtractor.from(bf);\n    }\n\n    @Override\n    protected int[] getExpectedIndices() {\n        return new int[] {3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35};\n    }\n\n    @Override\n    protected int[] getExpectedValues() {\n        return new int[] {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "protected Shape shape = Shape.fromKM(17, 72);", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Shape", "name": "shape = Shape.fromKM(17, 72)", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromArrayCountingBloomFilterTest.java.IndexExtractorFromArrayCountingBloomFilterTest", "name": "IndexExtractorFromArrayCountingBloomFilterTest", "file_path": "src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromArrayCountingBloomFilterTest.java", "superclasses": "AbstractIndexExtractorTest", "methods": ["[IndexExtractor]createEmptyExtractor()", "[IndexExtractor]createExtractor()", "[int]getAsIndexArrayBehaviour()", "[int[]]getExpectedIndices()"], "method_uris": ["src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromArrayCountingBloomFilterTest.java.IndexExtractorFromArrayCountingBloomFilterTest.[IndexExtractor]createEmptyExtractor()", "src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromArrayCountingBloomFilterTest.java.IndexExtractorFromArrayCountingBloomFilterTest.[IndexExtractor]createExtractor()", "src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromArrayCountingBloomFilterTest.java.IndexExtractorFromArrayCountingBloomFilterTest.[int]getAsIndexArrayBehaviour()", "src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromArrayCountingBloomFilterTest.java.IndexExtractorFromArrayCountingBloomFilterTest.[int[]]getExpectedIndices()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class IndexExtractorFromArrayCountingBloomFilterTest extends AbstractIndexExtractorTest {\n\n    protected Shape shape = Shape.fromKM(17, 72);\n\n    @Override\n    protected IndexExtractor createEmptyExtractor() {\n        return new ArrayCountingBloomFilter(shape);\n    }\n\n    @Override\n    protected IndexExtractor createExtractor() {\n        final ArrayCountingBloomFilter filter = new ArrayCountingBloomFilter(shape);\n        filter.merge(new IncrementingHasher(0, 1));\n        filter.merge(new IncrementingHasher(5, 1));\n        return filter;\n    }\n\n    @Override\n    protected int getAsIndexArrayBehaviour() {\n        return DISTINCT | ORDERED;\n    }\n\n    @Override\n    protected int[] getExpectedIndices() {\n        return new int[] {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21};\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "protected Shape shape = Shape.fromKM(17, 72);", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Shape", "name": "shape = Shape.fromKM(17, 72)", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromUniqueHasherTest.java.IndexExtractorFromUniqueHasherTest", "name": "IndexExtractorFromUniqueHasherTest", "file_path": "src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromUniqueHasherTest.java", "superclasses": "AbstractIndexExtractorTest", "methods": ["[IndexExtractor]createEmptyExtractor()", "[IndexExtractor]createExtractor()", "[int]getAsIndexArrayBehaviour()", "[int[]]getExpectedIndices()"], "method_uris": ["src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromUniqueHasherTest.java.IndexExtractorFromUniqueHasherTest.[IndexExtractor]createEmptyExtractor()", "src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromUniqueHasherTest.java.IndexExtractorFromUniqueHasherTest.[IndexExtractor]createExtractor()", "src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromUniqueHasherTest.java.IndexExtractorFromUniqueHasherTest.[int]getAsIndexArrayBehaviour()", "src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromUniqueHasherTest.java.IndexExtractorFromUniqueHasherTest.[int[]]getExpectedIndices()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class IndexExtractorFromUniqueHasherTest extends AbstractIndexExtractorTest {\n\n    @Override\n    protected IndexExtractor createEmptyExtractor() {\n        return NullHasher.INSTANCE.indices(Shape.fromKM(17, 72));\n    }\n\n    @Override\n    protected IndexExtractor createExtractor() {\n        // hasher has collisions and wraps\n        return new IncrementingHasher(4, 8).indices(Shape.fromKM(17, 72)).uniqueIndices();\n    }\n\n    @Override\n    protected int getAsIndexArrayBehaviour() {\n        return DISTINCT;\n    }\n\n    @Override\n    protected int[] getExpectedIndices() {\n        return new int[] {4, 12, 20, 28, 36, 44, 52, 60, 68};\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/bloomfilter/TestingHashers.java.TestingHashers", "name": "TestingHashers", "file_path": "src/test/java/org/apache/commons/collections4/bloomfilter/TestingHashers.java", "superclasses": "", "methods": ["[T]mergeHashers(T)", "[T]populateEntireFilter(T)", "[T]populateFromHashersFrom1AndFrom11(T)", "[T]populateRange(T,int,int)", "[Hasher]randomHasher()", "[]TestingHashers()"], "method_uris": ["src/test/java/org/apache/commons/collections4/bloomfilter/TestingHashers.java.TestingHashers.[T]mergeHashers(T)", "src/test/java/org/apache/commons/collections4/bloomfilter/TestingHashers.java.TestingHashers.[T]populateEntireFilter(T)", "src/test/java/org/apache/commons/collections4/bloomfilter/TestingHashers.java.TestingHashers.[T]populateFromHashersFrom1AndFrom11(T)", "src/test/java/org/apache/commons/collections4/bloomfilter/TestingHashers.java.TestingHashers.[T]populateRange(T,int,int)", "src/test/java/org/apache/commons/collections4/bloomfilter/TestingHashers.java.TestingHashers.[Hasher]randomHasher()", "src/test/java/org/apache/commons/collections4/bloomfilter/TestingHashers.java.TestingHashers.[]TestingHashers()"], "overrides": null, "attributes": [], "class_docstring": "\nA collection of methods and statics that represent standard hashers in testing.\n", "original_string": "public class TestingHashers {\n    /**\n     * Hasher that increments from 1.\n     */\n    public static final Hasher FROM1 = new IncrementingHasher(1, 1);\n\n    /**\n     * Hasher that increments from 11.\n     */\n    public static final Hasher FROM11 = new IncrementingHasher(11, 1);\n\n    /**\n     * Merge several Hashers together into a single Bloom filter.\n     * @param <T> The type of bloom filter.\n     * @param filter The Bloom filter to populate\n     * @param hashers The hashers to merge\n     * @return {@code filter} for chaining\n     */\n    public static <T extends BloomFilter> T mergeHashers(final T filter, final Hasher... hashers) {\n        for (final Hasher h : hashers) {\n            filter.merge(h);\n        }\n        return filter;\n    }\n\n    /**\n     * Enables all bits in the filter.\n     * @param <T> the Bloom filter type.\n     * @param filter the Bloom filter to populate\n     * @return {@code filter} for chaining\n     */\n    public static <T extends BloomFilter> T populateEntireFilter(final T filter) {\n        return populateRange(filter, 0, filter.getShape().getNumberOfBits() - 1);\n    }\n\n    /**\n     * Merge {@code from1} and {@code from11} into a single Bloom filter.\n     * @param <T> The type of bloom filter.\n     * @param filter The Bloom filter to populate\n     * @return {@code filter} for chaining\n     */\n    public static <T extends BloomFilter> T populateFromHashersFrom1AndFrom11(final T filter) {\n        return mergeHashers(filter, FROM1, FROM11);\n    }\n\n    /**\n     * Enables all bits in a range (inclusive).\n     * @param <T> the Bloom filter type.\n     * @param filter the Bloom filter to populate\n     * @param start the starting bit to enable.\n     * @param end the last bit to enable.\n     * @return {@code filter} for chaining\n     */\n    public static <T extends BloomFilter> T populateRange(final T filter, final int start, final int end) {\n        filter.merge((IndexExtractor) p -> {\n            for (int i = start; i <= end; i++) {\n                if (!p.test(i)) {\n                    return false;\n                }\n            }\n            return true;\n        });\n        return filter;\n    }\n\n    /**\n     * Creates an EnhancedDoubleHasher hasher from 2 random longs.\n     */\n    public static Hasher randomHasher() {\n        return new EnhancedDoubleHasher(ThreadLocalRandom.current().nextLong(), ThreadLocalRandom.current().nextLong());\n    }\n\n    /**\n     * Do not instantiate.\n     */\n    private TestingHashers() {\n        // empty\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final Hasher FROM1 = new IncrementingHasher(1, 1);", "docstring": "\nHasher that increments from 1.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Hasher", "name": "FROM1 = new IncrementingHasher(1, 1)", "syntax_pass": true}, {"attribute_expression": "public static final Hasher FROM11 = new IncrementingHasher(11, 1);", "docstring": "\nHasher that increments from 11.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Hasher", "name": "FROM11 = new IncrementingHasher(11, 1)", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/bloomfilter/BitMapExtractorFromArrayCountingBloomFilterTest.java.BitMapExtractorFromArrayCountingBloomFilterTest", "name": "BitMapExtractorFromArrayCountingBloomFilterTest", "file_path": "src/test/java/org/apache/commons/collections4/bloomfilter/BitMapExtractorFromArrayCountingBloomFilterTest.java", "superclasses": "AbstractBitMapExtractorTest", "methods": ["[BitMapExtractor]createEmptyExtractor()", "[BitMapExtractor]createExtractor()"], "method_uris": ["src/test/java/org/apache/commons/collections4/bloomfilter/BitMapExtractorFromArrayCountingBloomFilterTest.java.BitMapExtractorFromArrayCountingBloomFilterTest.[BitMapExtractor]createEmptyExtractor()", "src/test/java/org/apache/commons/collections4/bloomfilter/BitMapExtractorFromArrayCountingBloomFilterTest.java.BitMapExtractorFromArrayCountingBloomFilterTest.[BitMapExtractor]createExtractor()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class BitMapExtractorFromArrayCountingBloomFilterTest extends AbstractBitMapExtractorTest {\n\n    protected Shape shape = Shape.fromKM(17, 72);\n\n    @Override\n    protected BitMapExtractor createEmptyExtractor() {\n        return new ArrayCountingBloomFilter(shape);\n    }\n\n    @Override\n    protected BitMapExtractor createExtractor() {\n        final ArrayCountingBloomFilter filter = new ArrayCountingBloomFilter(shape);\n        final Hasher hasher = new IncrementingHasher(0, 1);\n        filter.merge(hasher);\n        return filter;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "protected Shape shape = Shape.fromKM(17, 72);", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Shape", "name": "shape = Shape.fromKM(17, 72)", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/bloomfilter/ArrayCountingBloomFilterTest.java.ArrayCountingBloomFilterTest", "name": "ArrayCountingBloomFilterTest", "file_path": "src/test/java/org/apache/commons/collections4/bloomfilter/ArrayCountingBloomFilterTest.java", "superclasses": "", "methods": ["[ArrayCountingBloomFilter]createEmptyFilter(Shape)"], "method_uris": ["src/test/java/org/apache/commons/collections4/bloomfilter/ArrayCountingBloomFilterTest.java.ArrayCountingBloomFilterTest.[ArrayCountingBloomFilter]createEmptyFilter(Shape)"], "overrides": null, "attributes": [], "class_docstring": "\nTests for the {@link ArrayCountingBloomFilter}.\n", "original_string": "public class ArrayCountingBloomFilterTest extends AbstractCountingBloomFilterTest<ArrayCountingBloomFilter> {\n\n    @Override\n    protected ArrayCountingBloomFilter createEmptyFilter(final Shape shape) {\n        return new ArrayCountingBloomFilter(shape);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromIntArrayTest.java.IndexExtractorFromIntArrayTest", "name": "IndexExtractorFromIntArrayTest", "file_path": "src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromIntArrayTest.java", "superclasses": "AbstractIndexExtractorTest", "methods": ["[IndexExtractor]createEmptyExtractor()", "[IndexExtractor]createExtractor()", "[int]getAsIndexArrayBehaviour()", "[int[]]getExpectedIndices()"], "method_uris": ["src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromIntArrayTest.java.IndexExtractorFromIntArrayTest.[IndexExtractor]createEmptyExtractor()", "src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromIntArrayTest.java.IndexExtractorFromIntArrayTest.[IndexExtractor]createExtractor()", "src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromIntArrayTest.java.IndexExtractorFromIntArrayTest.[int]getAsIndexArrayBehaviour()", "src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromIntArrayTest.java.IndexExtractorFromIntArrayTest.[int[]]getExpectedIndices()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class IndexExtractorFromIntArrayTest extends AbstractIndexExtractorTest {\n\n    int[] data = {6, 8, 1, 2, 4, 4, 5};\n\n    @Override\n    protected IndexExtractor createEmptyExtractor() {\n        return IndexExtractor.fromIndexArray();\n    }\n\n    @Override\n    protected IndexExtractor createExtractor() {\n        return IndexExtractor.fromIndexArray(data);\n    }\n\n    @Override\n    protected int getAsIndexArrayBehaviour() {\n        return 0;\n    }\n\n    @Override\n    protected int[] getExpectedIndices() {\n        return data;\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "int[] data = {6, 8, 1, 2, 4, 4, 5};", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int[]", "name": "data = {6, 8, 1, 2, 4, 4, 5}", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/bloomfilter/BloomFilteExtractorFromLayeredBloomFilterTest.java.BloomFilteExtractorFromLayeredBloomFilterTest", "name": "BloomFilteExtractorFromLayeredBloomFilterTest", "file_path": "src/test/java/org/apache/commons/collections4/bloomfilter/BloomFilteExtractorFromLayeredBloomFilterTest.java", "superclasses": "AbstractBloomFilterExtractorTest", "methods": ["[BloomFilterExtractor]createUnderTest()"], "method_uris": ["src/test/java/org/apache/commons/collections4/bloomfilter/BloomFilteExtractorFromLayeredBloomFilterTest.java.BloomFilteExtractorFromLayeredBloomFilterTest.[BloomFilterExtractor]createUnderTest()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class BloomFilteExtractorFromLayeredBloomFilterTest extends AbstractBloomFilterExtractorTest {\n\n    @Override\n    protected BloomFilterExtractor createUnderTest(final BloomFilter... filters) {\n        final Shape shape = filters[0].getShape();\n        final LayerManager layerManager = LayerManager.builder().setSupplier(() -> new SimpleBloomFilter(shape))\n                .setExtendCheck(LayerManager.ExtendCheck.advanceOnPopulated()).setCleanup(LayerManager.Cleanup.noCleanup()).get();\n        final LayeredBloomFilter underTest = new LayeredBloomFilter(shape, layerManager);\n        for (final BloomFilter bf : filters) {\n            underTest.merge(bf);\n        }\n        return underTest;\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromSparseBloomFilterTest.java.IndexExtractorFromSparseBloomFilterTest", "name": "IndexExtractorFromSparseBloomFilterTest", "file_path": "src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromSparseBloomFilterTest.java", "superclasses": "AbstractIndexExtractorTest", "methods": ["[IndexExtractor]createEmptyExtractor()", "[IndexExtractor]createExtractor()", "[int]getAsIndexArrayBehaviour()", "[int[]]getExpectedIndices()"], "method_uris": ["src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromSparseBloomFilterTest.java.IndexExtractorFromSparseBloomFilterTest.[IndexExtractor]createEmptyExtractor()", "src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromSparseBloomFilterTest.java.IndexExtractorFromSparseBloomFilterTest.[IndexExtractor]createExtractor()", "src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromSparseBloomFilterTest.java.IndexExtractorFromSparseBloomFilterTest.[int]getAsIndexArrayBehaviour()", "src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromSparseBloomFilterTest.java.IndexExtractorFromSparseBloomFilterTest.[int[]]getExpectedIndices()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class IndexExtractorFromSparseBloomFilterTest extends AbstractIndexExtractorTest {\n\n    protected Shape shape = Shape.fromKM(17, 72);\n\n    @Override\n    protected IndexExtractor createEmptyExtractor() {\n        return new SparseBloomFilter(shape);\n    }\n\n    @Override\n    protected IndexExtractor createExtractor() {\n        final Hasher hasher = new IncrementingHasher(4, 7);\n        final BloomFilter bf = new SparseBloomFilter(shape);\n        bf.merge(hasher);\n        return bf;\n    }\n\n    @Override\n    protected int getAsIndexArrayBehaviour() {\n        return DISTINCT | ORDERED;\n    }\n\n    @Override\n    protected int[] getExpectedIndices() {\n        return new int[] { 2, 4, 9, 11, 16, 18, 23, 25, 30, 32, 37, 39, 44, 46, 53, 60, 67 };\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "protected Shape shape = Shape.fromKM(17, 72);", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Shape", "name": "shape = Shape.fromKM(17, 72)", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/bloomfilter/NullHasher.java.NullHasher", "name": "NullHasher", "file_path": "src/test/java/org/apache/commons/collections4/bloomfilter/NullHasher.java", "superclasses": "", "methods": ["[]NullHasher()", "[IndexExtractor]indices(Shape)"], "method_uris": ["src/test/java/org/apache/commons/collections4/bloomfilter/NullHasher.java.NullHasher.[]NullHasher()", "src/test/java/org/apache/commons/collections4/bloomfilter/NullHasher.java.NullHasher.[IndexExtractor]indices(Shape)"], "overrides": null, "attributes": [], "class_docstring": "\nA Hasher that returns no values.\n\n<p>To be used for testing only.</p>\n", "original_string": "final class NullHasher implements Hasher {\n\n    /**\n     * The instance of the Null Hasher.\n     */\n    static final NullHasher INSTANCE = new NullHasher();\n\n    private static final IndexExtractor INDEX_EXTRACTOR = new IndexExtractor() {\n        @Override\n        public int[] asIndexArray() {\n            return new int[0];\n        }\n\n        @Override\n        public boolean processIndices(final IntPredicate consumer) {\n            Objects.requireNonNull(consumer, \"consumer\");\n            return true;\n        }\n    };\n\n    private NullHasher() {\n        // No instances\n    }\n\n    @Override\n    public IndexExtractor indices(final Shape shape) {\n        Objects.requireNonNull(shape, \"shape\");\n        return INDEX_EXTRACTOR;\n    }\n}", "super_interfaces": ["Hasher"], "fields": [{"attribute_expression": "static final NullHasher INSTANCE = new NullHasher();", "docstring": "\nThe instance of the Null Hasher.\n", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "NullHasher", "name": "INSTANCE = new NullHasher()", "syntax_pass": true}, {"attribute_expression": "private static final IndexExtractor INDEX_EXTRACTOR = new IndexExtractor() {\n        @Override\n        public int[] asIndexArray() {\n            return new int[0];\n        }\n\n        @Override\n        public boolean processIndices(final IntPredicate consumer) {\n            Objects.requireNonNull(consumer, \"consumer\");\n            return true;\n        }\n    };", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "IndexExtractor", "name": "INDEX_EXTRACTOR = new IndexExtractor() {\n        @Override\n        public int[] asIndexArray() {\n            return new int[0];\n        }\n\n        @Override\n        public boolean processIndices(final IntPredicate consumer) {\n            Objects.requireNonNull(consumer, \"consumer\");\n            return true;\n        }\n    }", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromHasherTest.java.IndexExtractorFromHasherTest", "name": "IndexExtractorFromHasherTest", "file_path": "src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromHasherTest.java", "superclasses": "AbstractIndexExtractorTest", "methods": ["[IndexExtractor]createEmptyExtractor()", "[IndexExtractor]createExtractor()", "[int]getAsIndexArrayBehaviour()", "[int[]]getExpectedIndices()"], "method_uris": ["src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromHasherTest.java.IndexExtractorFromHasherTest.[IndexExtractor]createEmptyExtractor()", "src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromHasherTest.java.IndexExtractorFromHasherTest.[IndexExtractor]createExtractor()", "src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromHasherTest.java.IndexExtractorFromHasherTest.[int]getAsIndexArrayBehaviour()", "src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromHasherTest.java.IndexExtractorFromHasherTest.[int[]]getExpectedIndices()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class IndexExtractorFromHasherTest extends AbstractIndexExtractorTest {\n\n    @Override\n    protected IndexExtractor createEmptyExtractor() {\n        return NullHasher.INSTANCE.indices(Shape.fromKM(17, 72));\n    }\n\n    @Override\n    protected IndexExtractor createExtractor() {\n        // hasher has collisions and wraps\n        return new IncrementingHasher(4, 8).indices(Shape.fromKM(17, 72));\n    }\n\n    @Override\n    protected int getAsIndexArrayBehaviour() {\n        return 0;\n    }\n\n    @Override\n    protected int[] getExpectedIndices() {\n        return new int[] {4, 12, 20, 28, 36, 44, 52, 60, 68, 4, 12, 20, 28, 36, 44, 52, 60};\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/bloomfilter/BitMapExtractorFromSparseBloomFilterTest.java.BitMapExtractorFromSparseBloomFilterTest", "name": "BitMapExtractorFromSparseBloomFilterTest", "file_path": "src/test/java/org/apache/commons/collections4/bloomfilter/BitMapExtractorFromSparseBloomFilterTest.java", "superclasses": "AbstractBitMapExtractorTest", "methods": ["[BitMapExtractor]createEmptyExtractor()", "[BitMapExtractor]createExtractor()"], "method_uris": ["src/test/java/org/apache/commons/collections4/bloomfilter/BitMapExtractorFromSparseBloomFilterTest.java.BitMapExtractorFromSparseBloomFilterTest.[BitMapExtractor]createEmptyExtractor()", "src/test/java/org/apache/commons/collections4/bloomfilter/BitMapExtractorFromSparseBloomFilterTest.java.BitMapExtractorFromSparseBloomFilterTest.[BitMapExtractor]createExtractor()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class BitMapExtractorFromSparseBloomFilterTest extends AbstractBitMapExtractorTest {\n\n    protected Shape shape = Shape.fromKM(17, 72);\n\n    @Override\n    protected BitMapExtractor createEmptyExtractor() {\n        return new SparseBloomFilter(shape);\n    }\n\n    @Override\n    protected BitMapExtractor createExtractor() {\n        final Hasher hasher = new IncrementingHasher(0, 1);\n        final BloomFilter bf = new SparseBloomFilter(shape);\n        bf.merge(hasher);\n        return bf;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "protected Shape shape = Shape.fromKM(17, 72);", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Shape", "name": "shape = Shape.fromKM(17, 72)", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/bloomfilter/BitMapExtractorFromSimpleBloomFilterTest.java.BitMapExtractorFromSimpleBloomFilterTest", "name": "BitMapExtractorFromSimpleBloomFilterTest", "file_path": "src/test/java/org/apache/commons/collections4/bloomfilter/BitMapExtractorFromSimpleBloomFilterTest.java", "superclasses": "AbstractBitMapExtractorTest", "methods": ["[BitMapExtractor]createEmptyExtractor()", "[BitMapExtractor]createExtractor()"], "method_uris": ["src/test/java/org/apache/commons/collections4/bloomfilter/BitMapExtractorFromSimpleBloomFilterTest.java.BitMapExtractorFromSimpleBloomFilterTest.[BitMapExtractor]createEmptyExtractor()", "src/test/java/org/apache/commons/collections4/bloomfilter/BitMapExtractorFromSimpleBloomFilterTest.java.BitMapExtractorFromSimpleBloomFilterTest.[BitMapExtractor]createExtractor()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class BitMapExtractorFromSimpleBloomFilterTest extends AbstractBitMapExtractorTest {\n\n    protected Shape shape = Shape.fromKM(17, 72);\n\n    @Override\n    protected BitMapExtractor createEmptyExtractor() {\n        return new SimpleBloomFilter(shape);\n    }\n\n    @Override\n    protected BitMapExtractor createExtractor() {\n        final Hasher hasher = new IncrementingHasher(0, 1);\n        final BloomFilter bf = new SimpleBloomFilter(shape);\n        bf.merge(hasher);\n        return bf;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "protected Shape shape = Shape.fromKM(17, 72);", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Shape", "name": "shape = Shape.fromKM(17, 72)", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/bloomfilter/ArrayHasher.java.ArrayHasher", "name": "ArrayHasher", "file_path": "src/test/java/org/apache/commons/collections4/bloomfilter/ArrayHasher.java", "superclasses": "", "methods": ["[]ArrayHasher()", "[IndexExtractor]indices(Shape)"], "method_uris": ["src/test/java/org/apache/commons/collections4/bloomfilter/ArrayHasher.java.ArrayHasher.[]ArrayHasher()", "src/test/java/org/apache/commons/collections4/bloomfilter/ArrayHasher.java.ArrayHasher.[IndexExtractor]indices(Shape)"], "overrides": null, "attributes": [{"original_string": "    private final class Extractor implements IndexExtractor {\n        Shape shape;\n\n        Extractor(final Shape shape) {\n            this.shape = shape;\n        }\n\n        @Override\n        public boolean processIndices(final IntPredicate consumer) {\n            Objects.requireNonNull(consumer, \"consumer\");\n\n            int pos = 0;\n            for (int i = 0; i < shape.getNumberOfHashFunctions(); i++) {\n                final int result = values[pos++] % shape.getNumberOfBits();\n                pos %= values.length;\n                if (!consumer.test(result)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }", "definition": "    private final class Extractor implements IndexExtractor", "class_docstring": "", "name": "Extractor", "super_interfaces": ["IndexExtractor"], "superclasses": "", "attributes": {"modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "fields": [{"attribute_expression": "Shape shape;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "Shape", "name": "shape", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        Extractor(final Shape shape) {\n            this.shape = shape;\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Extractor", "params": [{"name": "shape", "type": "Shape"}], "body": "                                     {\n            this.shape = shape;\n        }", "signature": "Extractor(final Shape shape)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean processIndices(final IntPredicate consumer) {\n            Objects.requireNonNull(consumer, \"consumer\");\n\n            int pos = 0;\n            for (int i = 0; i < shape.getNumberOfHashFunctions(); i++) {\n                final int result = values[pos++] % shape.getNumberOfBits();\n                pos %= values.length;\n                if (!consumer.test(result)) {\n                    return false;\n                }\n            }\n            return true;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "processIndices", "params": [{"name": "consumer", "type": "IntPredicate"}], "body": "                                                                   {\n            Objects.requireNonNull(consumer, \"consumer\");\n\n            int pos = 0;\n            for (int i = 0; i < shape.getNumberOfHashFunctions(); i++) {\n                final int result = values[pos++] % shape.getNumberOfBits();\n                pos %= values.length;\n                if (!consumer.test(result)) {\n                    return false;\n                }\n            }\n            return true;\n        }", "signature": "@Override\n        public boolean processIndices(final IntPredicate consumer)"}]}], "class_docstring": "\nA Testing Hasher that returns the array values % shape.getNumberOfBits().\n\n<p>To be used for testing only.</p>\n", "original_string": "public final class ArrayHasher implements Hasher {\n    private final class Extractor implements IndexExtractor {\n        Shape shape;\n\n        Extractor(final Shape shape) {\n            this.shape = shape;\n        }\n\n        @Override\n        public boolean processIndices(final IntPredicate consumer) {\n            Objects.requireNonNull(consumer, \"consumer\");\n\n            int pos = 0;\n            for (int i = 0; i < shape.getNumberOfHashFunctions(); i++) {\n                final int result = values[pos++] % shape.getNumberOfBits();\n                pos %= values.length;\n                if (!consumer.test(result)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n\n    private final int[] values;\n\n    public ArrayHasher(final int... values) {\n        this.values = values;\n    }\n\n    @Override\n    public IndexExtractor indices(final Shape shape) {\n        Objects.requireNonNull(shape, \"shape\");\n        return new Extractor(shape);\n    }\n}", "super_interfaces": ["Hasher"], "fields": [{"attribute_expression": "private final int[] values;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int[]", "name": "values", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBloomFilterExtractorTest.java.DefaultBloomFilterExtractorTest", "name": "DefaultBloomFilterExtractorTest", "file_path": "src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBloomFilterExtractorTest.java", "superclasses": "AbstractBloomFilterExtractorTest", "methods": ["[BloomFilterExtractor]createUnderTest()"], "method_uris": ["src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBloomFilterExtractorTest.java.DefaultBloomFilterExtractorTest.[BloomFilterExtractor]createUnderTest()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class DefaultBloomFilterExtractorTest extends AbstractBloomFilterExtractorTest {\n\n    @Override\n    protected BloomFilterExtractor createUnderTest(final BloomFilter... filters) {\n        return bloomFilterPredicate -> {\n            for (final BloomFilter bf : filters) {\n                if (!bloomFilterPredicate.test(bf)) {\n                    return false;\n                }\n            }\n            return true;\n        };\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/bloomfilter/BloomFilterExtractorFromBloomFilterArrayTest.java.BloomFilterExtractorFromBloomFilterArrayTest", "name": "BloomFilterExtractorFromBloomFilterArrayTest", "file_path": "src/test/java/org/apache/commons/collections4/bloomfilter/BloomFilterExtractorFromBloomFilterArrayTest.java", "superclasses": "AbstractBloomFilterExtractorTest", "methods": ["[BloomFilterExtractor]createUnderTest()"], "method_uris": ["src/test/java/org/apache/commons/collections4/bloomfilter/BloomFilterExtractorFromBloomFilterArrayTest.java.BloomFilterExtractorFromBloomFilterArrayTest.[BloomFilterExtractor]createUnderTest()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class BloomFilterExtractorFromBloomFilterArrayTest extends AbstractBloomFilterExtractorTest {\n\n    @Override\n    protected BloomFilterExtractor createUnderTest(final BloomFilter... filters) {\n        return BloomFilterExtractor.fromBloomFilterArray(filters);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/bloomfilter/CellExtractorFromArrayCountingBloomFilterTest.java.CellExtractorFromArrayCountingBloomFilterTest", "name": "CellExtractorFromArrayCountingBloomFilterTest", "file_path": "src/test/java/org/apache/commons/collections4/bloomfilter/CellExtractorFromArrayCountingBloomFilterTest.java", "superclasses": "AbstractCellExtractorTest", "methods": ["[CellExtractor]createEmptyExtractor()", "[CellExtractor]createExtractor()", "[int[]]getExpectedIndices()", "[int[]]getExpectedValues()"], "method_uris": ["src/test/java/org/apache/commons/collections4/bloomfilter/CellExtractorFromArrayCountingBloomFilterTest.java.CellExtractorFromArrayCountingBloomFilterTest.[CellExtractor]createEmptyExtractor()", "src/test/java/org/apache/commons/collections4/bloomfilter/CellExtractorFromArrayCountingBloomFilterTest.java.CellExtractorFromArrayCountingBloomFilterTest.[CellExtractor]createExtractor()", "src/test/java/org/apache/commons/collections4/bloomfilter/CellExtractorFromArrayCountingBloomFilterTest.java.CellExtractorFromArrayCountingBloomFilterTest.[int[]]getExpectedIndices()", "src/test/java/org/apache/commons/collections4/bloomfilter/CellExtractorFromArrayCountingBloomFilterTest.java.CellExtractorFromArrayCountingBloomFilterTest.[int[]]getExpectedValues()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class CellExtractorFromArrayCountingBloomFilterTest extends AbstractCellExtractorTest {\n\n    protected Shape shape = Shape.fromKM(17, 72);\n\n    @Override\n    protected CellExtractor createEmptyExtractor() {\n        return new ArrayCountingBloomFilter(shape);\n    }\n\n    @Override\n    protected CellExtractor createExtractor() {\n        final ArrayCountingBloomFilter filter = new ArrayCountingBloomFilter(shape);\n        filter.merge(new IncrementingHasher(0, 1));\n        filter.merge(new IncrementingHasher(5, 1));\n        return filter;\n    }\n\n    @Override\n    protected int[] getExpectedIndices() {\n        return new int[] {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21};\n    }\n\n    @Override\n    protected int[] getExpectedValues() {\n        return new int[] {1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1};\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "protected Shape shape = Shape.fromKM(17, 72);", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Shape", "name": "shape = Shape.fromKM(17, 72)", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/bloomfilter/IncrementingHasher.java.IncrementingHasher", "name": "IncrementingHasher", "file_path": "src/test/java/org/apache/commons/collections4/bloomfilter/IncrementingHasher.java", "superclasses": "", "methods": ["[]IncrementingHasher(long,long)", "[IndexExtractor]indices(Shape)"], "method_uris": ["src/test/java/org/apache/commons/collections4/bloomfilter/IncrementingHasher.java.IncrementingHasher.[]IncrementingHasher(long,long)", "src/test/java/org/apache/commons/collections4/bloomfilter/IncrementingHasher.java.IncrementingHasher.[IndexExtractor]indices(Shape)"], "overrides": null, "attributes": [], "class_docstring": "\nA Hasher that implements simple combinatorial hashing as described by\n<a href=\"https://www.eecs.harvard.edu/~michaelm/postscripts/tr-02-05.pdf\">Krisch and Mitzenmacher</a>.\n\n<p>To be used for testing only.</p>\n", "original_string": "public final class IncrementingHasher implements Hasher {\n\n    /**\n     * The initial hash value.\n     */\n    private final long initial;\n\n    /**\n     * The value to increment the hash value by.\n     */\n    private final long increment;\n\n    /**\n     * Constructs the IncrementingHasher from 2 longs.  The long values will be interpreted as unsigned values.\n     * <p>\n     * The initial hash value will be the modulus of the initial value.\n     * Subsequent values will be calculated by repeatedly adding the increment to the last value and taking the modulus.\n     * </p>\n     * @param initial The initial value for the hasher.\n     * @param increment The value to increment the hash by on each iteration.\n     */\n    public IncrementingHasher(final long initial, final long increment) {\n        this.initial = initial;\n        this.increment = increment;\n    }\n\n    @Override\n    public IndexExtractor indices(final Shape shape) {\n        Objects.requireNonNull(shape, \"shape\");\n\n        return new IndexExtractor() {\n            @Override\n            public int[] asIndexArray() {\n                final int[] result = new int[shape.getNumberOfHashFunctions()];\n                final int[] idx = new int[1];\n\n                // This method needs to return duplicate indices\n\n                processIndices(i -> {\n                    result[idx[0]++] = i;\n                    return true;\n                });\n                return result;\n            }\n\n            @Override\n            public boolean processIndices(final IntPredicate consumer) {\n                Objects.requireNonNull(consumer, \"consumer\");\n                final int bits = shape.getNumberOfBits();\n\n                // Essentially this is computing a wrapped modulus from a start point and an\n                // increment. So actually you only need two modulus operations before the loop.\n                // This avoids any modulus operation inside the while loop. It uses a long index\n                // to avoid overflow.\n\n                long index = BitMaps.mod(initial, bits);\n                final int inc = BitMaps.mod(increment, bits);\n\n                for (int functionalCount = 0; functionalCount < shape.getNumberOfHashFunctions(); functionalCount++) {\n                    if (!consumer.test((int) index)) {\n                        return false;\n                    }\n                    index += inc;\n                    index = index >= bits ? index - bits : index;\n                }\n                return true;\n            }\n        };\n    }\n}", "super_interfaces": ["Hasher"], "fields": [{"attribute_expression": "private final long initial;", "docstring": "\nThe initial hash value.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "long", "name": "initial", "syntax_pass": true}, {"attribute_expression": "private final long increment;", "docstring": "\nThe value to increment the hash value by.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "long", "name": "increment", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/bloomfilter/BitMapExtractorFromLayeredBloomFilterTest.java.BitMapExtractorFromLayeredBloomFilterTest", "name": "BitMapExtractorFromLayeredBloomFilterTest", "file_path": "src/test/java/org/apache/commons/collections4/bloomfilter/BitMapExtractorFromLayeredBloomFilterTest.java", "superclasses": "AbstractBitMapExtractorTest", "methods": ["[BitMapExtractor]createEmptyExtractor()", "[BitMapExtractor]createExtractor()"], "method_uris": ["src/test/java/org/apache/commons/collections4/bloomfilter/BitMapExtractorFromLayeredBloomFilterTest.java.BitMapExtractorFromLayeredBloomFilterTest.[BitMapExtractor]createEmptyExtractor()", "src/test/java/org/apache/commons/collections4/bloomfilter/BitMapExtractorFromLayeredBloomFilterTest.java.BitMapExtractorFromLayeredBloomFilterTest.[BitMapExtractor]createExtractor()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class BitMapExtractorFromLayeredBloomFilterTest extends AbstractBitMapExtractorTest {\n\n    protected Shape shape = Shape.fromKM(17, 72);\n\n    @Override\n    protected BitMapExtractor createEmptyExtractor() {\n        return LayeredBloomFilterTest.fixed(shape, 10);\n    }\n\n    @Override\n    protected BitMapExtractor createExtractor() {\n        final Hasher hasher = new IncrementingHasher(0, 1);\n        final BloomFilter bf = LayeredBloomFilterTest.fixed(shape, 10);\n        bf.merge(hasher);\n        return bf;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "protected Shape shape = Shape.fromKM(17, 72);", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Shape", "name": "shape = Shape.fromKM(17, 72)", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/bloomfilter/DefaultCellExtractorTest.java.DefaultCellExtractorTest", "name": "DefaultCellExtractorTest", "file_path": "src/test/java/org/apache/commons/collections4/bloomfilter/DefaultCellExtractorTest.java", "superclasses": "AbstractCellExtractorTest", "methods": ["[CellExtractor]createEmptyExtractor()", "[CellExtractor]createExtractor()", "[int[]]getExpectedIndices()", "[int[]]getExpectedValues()", "[int]getForEachIndexBehaviour()"], "method_uris": ["src/test/java/org/apache/commons/collections4/bloomfilter/DefaultCellExtractorTest.java.DefaultCellExtractorTest.[CellExtractor]createEmptyExtractor()", "src/test/java/org/apache/commons/collections4/bloomfilter/DefaultCellExtractorTest.java.DefaultCellExtractorTest.[CellExtractor]createExtractor()", "src/test/java/org/apache/commons/collections4/bloomfilter/DefaultCellExtractorTest.java.DefaultCellExtractorTest.[int[]]getExpectedIndices()", "src/test/java/org/apache/commons/collections4/bloomfilter/DefaultCellExtractorTest.java.DefaultCellExtractorTest.[int[]]getExpectedValues()", "src/test/java/org/apache/commons/collections4/bloomfilter/DefaultCellExtractorTest.java.DefaultCellExtractorTest.[int]getForEachIndexBehaviour()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class DefaultCellExtractorTest extends AbstractCellExtractorTest {\n\n    /** Make forEachIndex unordered and contain duplicates. */\n    private final int[] indices = {1, 2, 3, 5};\n    private final int[] values = {1, 4, 9, 25};\n\n    @Override\n    protected CellExtractor createEmptyExtractor() {\n        return consumer -> true;\n    }\n\n    @Override\n    protected CellExtractor createExtractor() {\n        return consumer -> {\n            for (int i = 0; i < indices.length; i++) {\n                if (!consumer.test(indices[i], values[i] )) {\n                    return false;\n                }\n            }\n            return true;\n        };\n    }\n\n    @Override\n    protected int[] getExpectedIndices() {\n        return indices;\n    }\n\n    @Override\n    protected int[] getExpectedValues() {\n        return values;\n    }\n\n    @Override\n    protected int getForEachIndexBehaviour() {\n        // The default method has the same behavior as the forEachCount() method.\n        return 0;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final int[] indices = {1, 2, 3, 5};", "docstring": " Make forEachIndex unordered and contain duplicates.", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int[]", "name": "indices = {1, 2, 3, 5}", "syntax_pass": true}, {"attribute_expression": "private final int[] values = {1, 4, 9, 25};", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int[]", "name": "values = {1, 4, 9, 25}", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/multiset/HashMultiSetTest.java.HashMultiSetTest", "name": "HashMultiSetTest", "file_path": "src/test/java/org/apache/commons/collections4/multiset/HashMultiSetTest.java", "superclasses": "", "methods": ["[]HashMultiSetTest()", "[String]getCompatibilityVersion()", "[int]getIterationBehaviour()", "[MultiSet<T>]makeObject()"], "method_uris": ["src/test/java/org/apache/commons/collections4/multiset/HashMultiSetTest.java.HashMultiSetTest.[]HashMultiSetTest()", "src/test/java/org/apache/commons/collections4/multiset/HashMultiSetTest.java.HashMultiSetTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/multiset/HashMultiSetTest.java.HashMultiSetTest.[int]getIterationBehaviour()", "src/test/java/org/apache/commons/collections4/multiset/HashMultiSetTest.java.HashMultiSetTest.[MultiSet<T>]makeObject()"], "overrides": null, "attributes": [], "class_docstring": "\nExtension of {@link AbstractMultiSetTest} for exercising the\n{@link HashMultiSet} implementation.\n", "original_string": "public class HashMultiSetTest<T> extends AbstractMultiSetTest<T> {\n\n    public HashMultiSetTest() {\n        super(HashMultiSetTest.class.getSimpleName());\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4.1\";\n    }\n\n    @Override\n    protected int getIterationBehaviour() {\n        return UNORDERED;\n    }\n\n    @Override\n    public MultiSet<T> makeObject() {\n        return new HashMultiSet<>();\n    }\n\n//    public void testCreate() throws Exception {\n//        MultiSet<T> multiset = makeObject();\n//        writeExternalFormToDisk((java.io.Serializable) multiset, \"src/test/resources/data/test/HashMultiSet.emptyCollection.version4.1.obj\");\n//        multiset = makeFullCollection();\n//        writeExternalFormToDisk((java.io.Serializable) multiset, \"src/test/resources/data/test/HashMultiSet.fullCollection.version4.1.obj\");\n//    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/multiset/SynchronizedMultiSetTest.java.SynchronizedMultiSetTest", "name": "SynchronizedMultiSetTest", "file_path": "src/test/java/org/apache/commons/collections4/multiset/SynchronizedMultiSetTest.java", "superclasses": "", "methods": ["[]SynchronizedMultiSetTest()", "[String]getCompatibilityVersion()", "[int]getIterationBehaviour()", "[MultiSet<T>]makeObject()"], "method_uris": ["src/test/java/org/apache/commons/collections4/multiset/SynchronizedMultiSetTest.java.SynchronizedMultiSetTest.[]SynchronizedMultiSetTest()", "src/test/java/org/apache/commons/collections4/multiset/SynchronizedMultiSetTest.java.SynchronizedMultiSetTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/multiset/SynchronizedMultiSetTest.java.SynchronizedMultiSetTest.[int]getIterationBehaviour()", "src/test/java/org/apache/commons/collections4/multiset/SynchronizedMultiSetTest.java.SynchronizedMultiSetTest.[MultiSet<T>]makeObject()"], "overrides": null, "attributes": [], "class_docstring": "\nExtension of {@link AbstractMultiSetTest} for exercising the\n{@link SynchronizedMultiSet} implementation.\n", "original_string": "public class SynchronizedMultiSetTest<T> extends AbstractMultiSetTest<T> {\n\n    public SynchronizedMultiSetTest() {\n        super(SynchronizedMultiSetTest.class.getSimpleName());\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4.1\";\n    }\n\n    @Override\n    protected int getIterationBehaviour() {\n        return UNORDERED;\n    }\n\n    @Override\n    public MultiSet<T> makeObject() {\n        return SynchronizedMultiSet.synchronizedMultiSet(new HashMultiSet<>());\n    }\n\n//    public void testCreate() throws Exception {\n//        MultiSet<T> multiset = makeObject();\n//        writeExternalFormToDisk((java.io.Serializable) multiset, \"src/test/resources/data/test/SynchronizedMultiSet.emptyCollection.version4.1.obj\");\n//        multiset = makeFullCollection();\n//        writeExternalFormToDisk((java.io.Serializable) multiset, \"src/test/resources/data/test/SynchronizedMultiSet.fullCollection.version4.1.obj\");\n//    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils", "name": "MapUtils", "file_path": "src/main/java/org/apache/commons/collections4/MapUtils.java", "superclasses": "", "methods": ["[R]applyDefaultFunction(Map<? super K, ?>,K,BiFunction<Map<? super K, ?>, K, R>,Function<K, R>)", "[R]applyDefaultFunction(Map<? super K, ?>,K,BiFunction<Map<? super K, ?>, K, R>,Function<K, R>,R)", "[R]applyDefaultValue(Map<? super K, ?>,K,BiFunction<Map<? super K, ?>, K, R>,R)", "[void]debugPrint(PrintStream,Object,Map<?, ?>)", "[Map<K, V>]emptyIfNull(Map<K, V>)", "[IterableMap<K, V>]fixedSizeMap(Map<K, V>)", "[SortedMap<K, V>]fixedSizeSortedMap(SortedMap<K, V>)", "[Boolean]getBoolean(Map<? super K, ?>,K)", "[Boolean]getBoolean(Map<? super K, ?>,K,Boolean)", "[Boolean]getBoolean(Map<? super K, ?>,K,Function<K, Boolean>)", "[boolean]getBooleanValue(Map<? super K, ?>,K)", "[boolean]getBooleanValue(Map<? super K, ?>,K,boolean)", "[boolean]getBooleanValue(Map<? super K, ?>,K,Function<K, Boolean>)", "[Byte]getByte(Map<? super K, ?>,K)", "[Byte]getByte(Map<? super K, ?>,K,Byte)", "[Byte]getByte(Map<? super K, ?>,K,Function<K, Byte>)", "[byte]getByteValue(Map<? super K, ?>,K)", "[byte]getByteValue(Map<? super K, ?>,K,byte)", "[byte]getByteValue(Map<? super K, ?>,K,Function<K, Byte>)", "[Double]getDouble(Map<? super K, ?>,K)", "[Double]getDouble(Map<? super K, ?>,K,Double)", "[Double]getDouble(Map<? super K, ?>,K,Function<K, Double>)", "[double]getDoubleValue(Map<? super K, ?>,K)", "[double]getDoubleValue(Map<? super K, ?>,K,double)", "[double]getDoubleValue(Map<? super K, ?>,K,Function<K, Double>)", "[Float]getFloat(Map<? super K, ?>,K)", "[Float]getFloat(Map<? super K, ?>,K,Float)", "[Float]getFloat(Map<? super K, ?>,K,Function<K, Float>)", "[float]getFloatValue(Map<? super K, ?>,K)", "[float]getFloatValue(Map<? super K, ?>,K,float)", "[float]getFloatValue(Map<? super K, ?>,K,Function<K, Float>)", "[Integer]getInteger(Map<? super K, ?>,K)", "[Integer]getInteger(Map<? super K, ?>,K,Function<K, Integer>)", "[Integer]getInteger(Map<? super K, ?>,K,Integer)", "[int]getIntValue(Map<? super K, ?>,K)", "[int]getIntValue(Map<? super K, ?>,K,Function<K, Integer>)", "[int]getIntValue(Map<? super K, ?>,K,int)", "[Long]getLong(Map<? super K, ?>,K)", "[Long]getLong(Map<? super K, ?>,K,Function<K, Long>)", "[Long]getLong(Map<? super K, ?>,K,Long)", "[long]getLongValue(Map<? super K, ?>,K)", "[long]getLongValue(Map<? super K, ?>,K,Function<K, Long>)", "[long]getLongValue(Map<? super K, ?>,K,long)", "[Map<?, ?>]getMap(Map<? super K, ?>,K)", "[Map<?, ?>]getMap(Map<? super K, ?>,K,Function<K, Map<?, ?>>)", "[Map<?, ?>]getMap(Map<? super K, ?>,K,Map<?, ?>)", "[Number]getNumber(Map<? super K, ?>,K)", "[Number]getNumber(Map<? super K, ?>,K,Function<K, Number>)", "[Number]getNumber(Map<? super K, ?>,K,Number)", "[V]getObject(Map<? super K, V>,K)", "[V]getObject(Map<K, V>,K,V)", "[Short]getShort(Map<? super K, ?>,K)", "[Short]getShort(Map<? super K, ?>,K,Function<K, Short>)", "[Short]getShort(Map<? super K, ?>,K,Short)", "[short]getShortValue(Map<? super K, ?>,K)", "[short]getShortValue(Map<? super K, ?>,K,Function<K, Short>)", "[short]getShortValue(Map<? super K, ?>,K,short)", "[String]getString(Map<? super K, ?>,K)", "[String]getString(Map<? super K, ?>,K,Function<K, String>)", "[String]getString(Map<? super K, ?>,K,String)", "[Map<V, K>]invertMap(Map<K, V>)", "[boolean]isEmpty(Map<?, ?>)", "[boolean]isNotEmpty(Map<?, ?>)", "[IterableMap<K, V>]iterableMap(Map<K, V>)", "[IterableSortedMap<K, V>]iterableSortedMap(SortedMap<K, V>)", "[IterableMap<K, V>]lazyMap(Map<K, V>,Factory<? extends V>)", "[IterableMap<K, V>]lazyMap(Map<K, V>,Transformer<? super K, ? extends V>)", "[SortedMap<K, V>]lazySortedMap(SortedMap<K, V>,Factory<? extends V>)", "[SortedMap<K, V>]lazySortedMap(SortedMap<K, V>,Transformer<? super K, ? extends V>)", "[MultiValueMap<K, V>]multiValueMap(Map<K, ? super Collection<V>>)", "[MultiValueMap<K, V>]multiValueMap(Map<K, C>,Class<C>)", "[MultiValueMap<K, V>]multiValueMap(Map<K, C>,Factory<C>)", "[OrderedMap<K, V>]orderedMap(Map<K, V>)", "[void]populateMap(Map<K, V>,Iterable<? extends E>,Transformer<E, K>,Transformer<E, V>)", "[void]populateMap(Map<K, V>,Iterable<? extends V>,Transformer<V, K>)", "[void]populateMap(MultiMap<K, V>,Iterable<? extends E>,Transformer<E, K>,Transformer<E, V>)", "[void]populateMap(MultiMap<K, V>,Iterable<? extends V>,Transformer<V, K>)", "[IterableMap<K, V>]predicatedMap(Map<K, V>,Predicate<? super K>,Predicate<? super V>)", "[SortedMap<K, V>]predicatedSortedMap(SortedMap<K, V>,Predicate<? super K>,Predicate<? super V>)", "[void]printIndent(PrintStream,int)", "[Map<K, V>]putAll(Map<K, V>,Object[])", "[void]safeAddToMap(Map<? super K, Object>,K,Object)", "[int]size(Map<?, ?>)", "[Map<K, V>]synchronizedMap(Map<K, V>)", "[SortedMap<K, V>]synchronizedSortedMap(SortedMap<K, V>)", "[Map<String, Object>]toMap(ResourceBundle)", "[Properties]toProperties(Map<K, V>)", "[IterableMap<K, V>]transformedMap(Map<K, V>,Transformer<? super K, ? extends K>,Transformer<? super V, ? extends V>)", "[SortedMap<K, V>]transformedSortedMap(SortedMap<K, V>,Transformer<? super K, ? extends K>,Transformer<? super V, ? extends V>)", "[Map<K, V>]unmodifiableMap(Map<? extends K, ? extends V>)", "[SortedMap<K, V>]unmodifiableSortedMap(SortedMap<K, ? extends V>)", "[void]verbosePrint(PrintStream,Object,Map<?, ?>)", "[void]verbosePrintInternal(PrintStream,Object,Map<?, ?>,Deque<Map<?, ?>>,boolean)", "[]MapUtils()"], "method_uris": ["src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[R]applyDefaultFunction(Map<? super K, ?>,K,BiFunction<Map<? super K, ?>, K, R>,Function<K, R>)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[R]applyDefaultFunction(Map<? super K, ?>,K,BiFunction<Map<? super K, ?>, K, R>,Function<K, R>,R)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[R]applyDefaultValue(Map<? super K, ?>,K,BiFunction<Map<? super K, ?>, K, R>,R)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[void]debugPrint(PrintStream,Object,Map<?, ?>)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[Map<K, V>]emptyIfNull(Map<K, V>)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[IterableMap<K, V>]fixedSizeMap(Map<K, V>)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[SortedMap<K, V>]fixedSizeSortedMap(SortedMap<K, V>)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[Boolean]getBoolean(Map<? super K, ?>,K)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[Boolean]getBoolean(Map<? super K, ?>,K,Boolean)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[Boolean]getBoolean(Map<? super K, ?>,K,Function<K, Boolean>)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[boolean]getBooleanValue(Map<? super K, ?>,K)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[boolean]getBooleanValue(Map<? super K, ?>,K,boolean)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[boolean]getBooleanValue(Map<? super K, ?>,K,Function<K, Boolean>)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[Byte]getByte(Map<? super K, ?>,K)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[Byte]getByte(Map<? super K, ?>,K,Byte)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[Byte]getByte(Map<? super K, ?>,K,Function<K, Byte>)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[byte]getByteValue(Map<? super K, ?>,K)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[byte]getByteValue(Map<? super K, ?>,K,byte)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[byte]getByteValue(Map<? super K, ?>,K,Function<K, Byte>)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[Double]getDouble(Map<? super K, ?>,K)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[Double]getDouble(Map<? super K, ?>,K,Double)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[Double]getDouble(Map<? super K, ?>,K,Function<K, Double>)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[double]getDoubleValue(Map<? super K, ?>,K)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[double]getDoubleValue(Map<? super K, ?>,K,double)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[double]getDoubleValue(Map<? super K, ?>,K,Function<K, Double>)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[Float]getFloat(Map<? super K, ?>,K)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[Float]getFloat(Map<? super K, ?>,K,Float)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[Float]getFloat(Map<? super K, ?>,K,Function<K, Float>)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[float]getFloatValue(Map<? super K, ?>,K)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[float]getFloatValue(Map<? super K, ?>,K,float)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[float]getFloatValue(Map<? super K, ?>,K,Function<K, Float>)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[Integer]getInteger(Map<? super K, ?>,K)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[Integer]getInteger(Map<? super K, ?>,K,Function<K, Integer>)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[Integer]getInteger(Map<? super K, ?>,K,Integer)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[int]getIntValue(Map<? super K, ?>,K)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[int]getIntValue(Map<? super K, ?>,K,Function<K, Integer>)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[int]getIntValue(Map<? super K, ?>,K,int)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[Long]getLong(Map<? super K, ?>,K)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[Long]getLong(Map<? super K, ?>,K,Function<K, Long>)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[Long]getLong(Map<? super K, ?>,K,Long)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[long]getLongValue(Map<? super K, ?>,K)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[long]getLongValue(Map<? super K, ?>,K,Function<K, Long>)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[long]getLongValue(Map<? super K, ?>,K,long)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[Map<?, ?>]getMap(Map<? super K, ?>,K)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[Map<?, ?>]getMap(Map<? super K, ?>,K,Function<K, Map<?, ?>>)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[Map<?, ?>]getMap(Map<? super K, ?>,K,Map<?, ?>)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[Number]getNumber(Map<? super K, ?>,K)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[Number]getNumber(Map<? super K, ?>,K,Function<K, Number>)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[Number]getNumber(Map<? super K, ?>,K,Number)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[V]getObject(Map<? super K, V>,K)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[V]getObject(Map<K, V>,K,V)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[Short]getShort(Map<? super K, ?>,K)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[Short]getShort(Map<? super K, ?>,K,Function<K, Short>)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[Short]getShort(Map<? super K, ?>,K,Short)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[short]getShortValue(Map<? super K, ?>,K)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[short]getShortValue(Map<? super K, ?>,K,Function<K, Short>)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[short]getShortValue(Map<? super K, ?>,K,short)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[String]getString(Map<? super K, ?>,K)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[String]getString(Map<? super K, ?>,K,Function<K, String>)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[String]getString(Map<? super K, ?>,K,String)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[Map<V, K>]invertMap(Map<K, V>)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[boolean]isEmpty(Map<?, ?>)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[boolean]isNotEmpty(Map<?, ?>)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[IterableMap<K, V>]iterableMap(Map<K, V>)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[IterableSortedMap<K, V>]iterableSortedMap(SortedMap<K, V>)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[IterableMap<K, V>]lazyMap(Map<K, V>,Factory<? extends V>)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[IterableMap<K, V>]lazyMap(Map<K, V>,Transformer<? super K, ? extends V>)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[SortedMap<K, V>]lazySortedMap(SortedMap<K, V>,Factory<? extends V>)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[SortedMap<K, V>]lazySortedMap(SortedMap<K, V>,Transformer<? super K, ? extends V>)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[MultiValueMap<K, V>]multiValueMap(Map<K, ? super Collection<V>>)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[MultiValueMap<K, V>]multiValueMap(Map<K, C>,Class<C>)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[MultiValueMap<K, V>]multiValueMap(Map<K, C>,Factory<C>)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[OrderedMap<K, V>]orderedMap(Map<K, V>)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[void]populateMap(Map<K, V>,Iterable<? extends E>,Transformer<E, K>,Transformer<E, V>)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[void]populateMap(Map<K, V>,Iterable<? extends V>,Transformer<V, K>)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[void]populateMap(MultiMap<K, V>,Iterable<? extends E>,Transformer<E, K>,Transformer<E, V>)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[void]populateMap(MultiMap<K, V>,Iterable<? extends V>,Transformer<V, K>)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[IterableMap<K, V>]predicatedMap(Map<K, V>,Predicate<? super K>,Predicate<? super V>)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[SortedMap<K, V>]predicatedSortedMap(SortedMap<K, V>,Predicate<? super K>,Predicate<? super V>)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[void]printIndent(PrintStream,int)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[Map<K, V>]putAll(Map<K, V>,Object[])", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[void]safeAddToMap(Map<? super K, Object>,K,Object)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[int]size(Map<?, ?>)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[Map<K, V>]synchronizedMap(Map<K, V>)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[SortedMap<K, V>]synchronizedSortedMap(SortedMap<K, V>)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[Map<String, Object>]toMap(ResourceBundle)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[Properties]toProperties(Map<K, V>)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[IterableMap<K, V>]transformedMap(Map<K, V>,Transformer<? super K, ? extends K>,Transformer<? super V, ? extends V>)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[SortedMap<K, V>]transformedSortedMap(SortedMap<K, V>,Transformer<? super K, ? extends K>,Transformer<? super V, ? extends V>)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[Map<K, V>]unmodifiableMap(Map<? extends K, ? extends V>)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[SortedMap<K, V>]unmodifiableSortedMap(SortedMap<K, ? extends V>)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[void]verbosePrint(PrintStream,Object,Map<?, ?>)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[void]verbosePrintInternal(PrintStream,Object,Map<?, ?>,Deque<Map<?, ?>>,boolean)", "src/main/java/org/apache/commons/collections4/MapUtils.java.MapUtils.[]MapUtils()"], "overrides": null, "attributes": [], "class_docstring": "\nProvides utility methods and decorators for {@link Map} and {@link SortedMap} instances.\n<p>\nIt contains various type safe methods as well as other useful features like deep copying.\n</p>\n<p>\nIt also provides the following decorators:\n</p>\n\n<ul>\n<li>{@link #fixedSizeMap(Map)}\n<li>{@link #fixedSizeSortedMap(SortedMap)}\n<li>{@link #lazyMap(Map,Factory)}\n<li>{@link #lazyMap(Map,Transformer)}\n<li>{@link #lazySortedMap(SortedMap,Factory)}\n<li>{@link #lazySortedMap(SortedMap,Transformer)}\n<li>{@link #predicatedMap(Map,Predicate,Predicate)}\n<li>{@link #predicatedSortedMap(SortedMap,Predicate,Predicate)}\n<li>{@link #transformedMap(Map, Transformer, Transformer)}\n<li>{@link #transformedSortedMap(SortedMap, Transformer, Transformer)}\n<li>{@link #multiValueMap( Map )}\n<li>{@link #multiValueMap( Map, Class )}\n<li>{@link #multiValueMap( Map, Factory )}\n</ul>\n\n@since 1.0\n", "original_string": "@SuppressWarnings(\"deprecation\")\npublic class MapUtils {\n\n    /**\n     * An empty unmodifiable sorted map. This is not provided in the JDK.\n     */\n    @SuppressWarnings(\"rawtypes\")\n    public static final SortedMap EMPTY_SORTED_MAP = UnmodifiableSortedMap.unmodifiableSortedMap(new TreeMap<>());\n\n    /**\n     * String used to indent the verbose and debug Map prints.\n     */\n    private static final String INDENT_STRING = \"    \";\n\n    /**\n     * Applies the {@code getFunction} and returns its result if non-null, if null returns the result of applying the\n     * default function.\n     *\n     * @param <K> The key type.\n     * @param <R> The result type.\n     * @param map The map to query.\n     * @param key The key into the map.\n     * @param getFunction The get function.\n     * @param defaultFunction The function to provide a default value.\n     * @return The result of applying a function.\n     */\n    private static <K, R> R applyDefaultFunction(final Map<? super K, ?> map, final K key,\n            final BiFunction<Map<? super K, ?>, K, R> getFunction, final Function<K, R> defaultFunction) {\n        return applyDefaultFunction(map, key, getFunction, defaultFunction, null);\n    }\n\n    /**\n     * Applies the {@code getFunction} and returns its result if non-null, if null returns the result of applying the\n     * default function.\n     *\n     * @param <K> The key type.\n     * @param <R> The result type.\n     * @param map The map to query.\n     * @param key The key into the map.\n     * @param getFunction The get function.\n     * @param defaultFunction The function to provide a default value.\n     * @param defaultValue The default value.\n     * @return The result of applying a function.\n     */\n    private static <K, R> R applyDefaultFunction(final Map<? super K, ?> map, final K key,\n            final BiFunction<Map<? super K, ?>, K, R> getFunction, final Function<K, R> defaultFunction,\n            final R defaultValue) {\n        R value = map != null && getFunction != null ? getFunction.apply(map, key) : null;\n        if (value == null) {\n            value = defaultFunction != null ? defaultFunction.apply(key) : null;\n        }\n        return value != null ? value : defaultValue;\n    }\n\n    /**\n     * Applies the {@code getFunction} and returns its result if non-null, if null returns the {@code defaultValue}.\n     *\n     * @param <K> The key type.\n     * @param <R> The result type.\n     * @param map The map to query.\n     * @param key The key into the map.\n     * @param getFunction The get function.\n     * @param defaultValue The default value.\n     * @return The result of applying a function.\n     */\n    private static <K, R> R applyDefaultValue(final Map<? super K, ?> map, final K key,\n            final BiFunction<Map<? super K, ?>, K, R> getFunction, final R defaultValue) {\n        final R value = map != null && getFunction != null ? getFunction.apply(map, key) : null;\n        return value == null ? defaultValue : value;\n    }\n\n    /**\n     * Prints the given map with nice line breaks.\n     * <p>\n     * This method prints a nicely formatted String describing the Map. Each map entry will be printed with key, value\n     * and value class name. When the value is a Map, recursive behavior occurs.\n     * </p>\n     * <p>\n     * This method is NOT thread-safe in any special way. You must manually synchronize on either this class or the\n     * stream as required.\n     * </p>\n     *\n     * @param out the stream to print to, must not be null\n     * @param label The label to be used, may be {@code null}. If {@code null}, the label is not output. It\n     *        typically represents the name of the property in a bean or similar.\n     * @param map The map to print, may be {@code null}. If {@code null}, the text 'null' is output.\n     * @throws NullPointerException if the stream is {@code null}\n     */\n    public static void debugPrint(final PrintStream out, final Object label, final Map<?, ?> map) {\n        verbosePrintInternal(out, label, map, new ArrayDeque<>(), true);\n    }\n\n    /**\n     * Returns an immutable empty map if the argument is {@code null}, or the argument itself otherwise.\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param map the map, possibly {@code null}\n     * @return an empty map if the argument is {@code null}\n     */\n    public static <K, V> Map<K, V> emptyIfNull(final Map<K, V> map) {\n        return map == null ? Collections.<K, V>emptyMap() : map;\n    }\n\n    /**\n     * Returns a fixed-sized map backed by the given map. Elements may not be added or removed from the returned map,\n     * but existing elements can be changed (for instance, via the {@link Map#put(Object,Object)} method).\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param map the map whose size to fix, must not be null\n     * @return a fixed-size map backed by that map\n     * @throws NullPointerException if the Map is null\n     */\n    public static <K, V> IterableMap<K, V> fixedSizeMap(final Map<K, V> map) {\n        return FixedSizeMap.fixedSizeMap(map);\n    }\n\n    /**\n     * Returns a fixed-sized sorted map backed by the given sorted map. Elements may not be added or removed from the\n     * returned map, but existing elements can be changed (for instance, via the {@link Map#put(Object,Object)} method).\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param map the map whose size to fix, must not be null\n     * @return a fixed-size map backed by that map\n     * @throws NullPointerException if the SortedMap is null\n     */\n    public static <K, V> SortedMap<K, V> fixedSizeSortedMap(final SortedMap<K, V> map) {\n        return FixedSizeSortedMap.fixedSizeSortedMap(map);\n    }\n\n    /**\n     * Gets a Boolean from a Map in a null-safe manner.\n     * <p>\n     * If the value is a {@code Boolean} it is returned directly. If the value is a {@code String} and it\n     * equals 'true' ignoring case then {@code true} is returned, otherwise {@code false}. If the value is a\n     * {@code Number} an integer zero value returns {@code false} and non-zero returns {@code true}.\n     * Otherwise, {@code null} is returned.\n     * </p>\n     *\n     * @param <K> the key type\n     * @param map the map to use\n     * @param key the key to look up\n     * @return the value in the Map as a Boolean, {@code null} if null map input\n     */\n    public static <K> Boolean getBoolean(final Map<? super K, ?> map, final K key) {\n        if (map != null) {\n            final Object answer = map.get(key);\n            if (answer != null) {\n                if (answer instanceof Boolean) {\n                    return (Boolean) answer;\n                }\n                if (answer instanceof String) {\n                    return Boolean.valueOf((String) answer);\n                }\n                if (answer instanceof Number) {\n                    final Number n = (Number) answer;\n                    return n.intValue() != 0 ? Boolean.TRUE : Boolean.FALSE;\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Looks up the given key in the given map, converting the result into a boolean, using the default value if the\n     * conversion fails.\n     *\n     * @param <K> the key type\n     * @param map the map whose value to look up\n     * @param key the key of the value to look up in that map\n     * @param defaultValue what to return if the value is null or if the conversion fails\n     * @return the value in the map as a boolean, or defaultValue if the original value is null, the map is null or the\n     *         boolean conversion fails\n     */\n    public static <K> Boolean getBoolean(final Map<? super K, ?> map, final K key, final Boolean defaultValue) {\n        return applyDefaultValue(map, key, MapUtils::getBoolean, defaultValue);\n    }\n\n    /**\n     * Looks up the given key in the given map, converting the result into a boolean, using the defaultFunction to\n     * produce the default value if the conversion fails.\n     *\n     * @param <K> the key type\n     * @param map the map whose value to look up\n     * @param key the key of the value to look up in that map\n     * @param defaultFunction what to produce the default value if the value is null or if the conversion fails\n     * @return the value in the map as a boolean, or defaultValue produced by the defaultFunction if the original value\n     *         is null, the map is null or the boolean conversion fails\n     * @since 4.5.0\n     */\n    public static <K> Boolean getBoolean(final Map<? super K, ?> map, final K key,\n            final Function<K, Boolean> defaultFunction) {\n        return applyDefaultFunction(map, key, MapUtils::getBoolean, defaultFunction);\n    }\n\n    /**\n     * Gets a boolean from a Map in a null-safe manner.\n     * <p>\n     * If the value is a {@code Boolean} its value is returned. If the value is a {@code String} and it equals\n     * 'true' ignoring case then {@code true} is returned, otherwise {@code false}. If the value is a\n     * {@code Number} an integer zero value returns {@code false} and non-zero returns {@code true}.\n     * Otherwise, {@code false} is returned.\n     * </p>\n     *\n     * @param <K> the key type\n     * @param map the map to use\n     * @param key the key to look up\n     * @return the value in the Map as a Boolean, {@code false} if null map input\n     */\n    public static <K> boolean getBooleanValue(final Map<? super K, ?> map, final K key) {\n        return Boolean.TRUE.equals(getBoolean(map, key));\n    }\n\n    /**\n     * Gets a boolean from a Map in a null-safe manner, using the default value if the conversion fails.\n     * <p>\n     * If the value is a {@code Boolean} its value is returned. If the value is a {@code String} and it equals\n     * 'true' ignoring case then {@code true} is returned, otherwise {@code false}. If the value is a\n     * {@code Number} an integer zero value returns {@code false} and non-zero returns {@code true}.\n     * Otherwise, {@code defaultValue} is returned.\n     * </p>\n     *\n     * @param <K> the key type\n     * @param map the map to use\n     * @param key the key to look up\n     * @param defaultValue return if the value is null or if the conversion fails\n     * @return the value in the Map as a Boolean, {@code defaultValue} if null map input\n     */\n    public static <K> boolean getBooleanValue(final Map<? super K, ?> map, final K key, final boolean defaultValue) {\n        return applyDefaultValue(map, key, MapUtils::getBoolean, defaultValue).booleanValue();\n    }\n\n    /**\n     * Gets a boolean from a Map in a null-safe manner, using the default value produced by the defaultFunction if the\n     * conversion fails.\n     * <p>\n     * If the value is a {@code Boolean} its value is returned. If the value is a {@code String} and it equals\n     * 'true' ignoring case then {@code true} is returned, otherwise {@code false}. If the value is a\n     * {@code Number} an integer zero value returns {@code false} and non-zero returns {@code true}.\n     * Otherwise, defaultValue produced by the {@code defaultFunction} is returned.\n     * </p>\n     *\n     * @param <K> the key type\n     * @param map the map to use\n     * @param key the key to look up\n     * @param defaultFunction produce the default value to return if the value is null or if the conversion fails\n     * @return the value in the Map as a Boolean, default value produced by the {@code defaultFunction} if null map\n     *         input\n     * @since 4.5.0\n     */\n    public static <K> boolean getBooleanValue(final Map<? super K, ?> map, final K key,\n            final Function<K, Boolean> defaultFunction) {\n        return applyDefaultFunction(map, key, MapUtils::getBoolean, defaultFunction, false).booleanValue();\n    }\n\n    /**\n     * Gets a Byte from a Map in a null-safe manner.\n     * <p>\n     * The Byte is obtained from the results of {@link #getNumber(Map,Object)}.\n     * </p>\n     *\n     * @param <K> the key type\n     * @param map the map to use\n     * @param key the key to look up\n     * @return the value in the Map as a Byte, {@code null} if null map input\n     */\n    public static <K> Byte getByte(final Map<? super K, ?> map, final K key) {\n        final Number answer = getNumber(map, key);\n        if (answer == null) {\n            return null;\n        }\n        if (answer instanceof Byte) {\n            return (Byte) answer;\n        }\n        return Byte.valueOf(answer.byteValue());\n    }\n\n    /**\n     * Looks up the given key in the given map, converting the result into a byte, using the default value if the\n     * conversion fails.\n     *\n     * @param <K> the key type\n     * @param map the map whose value to look up\n     * @param key the key of the value to look up in that map\n     * @param defaultValue what to return if the value is null or if the conversion fails\n     * @return the value in the map as a number, or defaultValue if the original value is null, the map is null or the\n     *         number conversion fails\n     */\n    public static <K> Byte getByte(final Map<? super K, ?> map, final K key, final Byte defaultValue) {\n        return applyDefaultValue(map, key, MapUtils::getByte, defaultValue);\n    }\n\n    /**\n     * Looks up the given key in the given map, converting the result into a byte, using the defaultFunction to produce\n     * the default value if the conversion fails.\n     *\n     * @param <K> the key type\n     * @param map the map whose value to look up\n     * @param key the key of the value to look up in that map\n     * @param defaultFunction what to produce the default value if the value is null or if the conversion fails\n     * @return the value in the map as a number, or defaultValue produced by the defaultFunction if the original value\n     *         is null, the map is null or the number conversion fails\n     * @since 4.5.0\n     */\n    public static <K> Byte getByte(final Map<? super K, ?> map, final K key, final Function<K, Byte> defaultFunction) {\n        return applyDefaultFunction(map, key, MapUtils::getByte, defaultFunction);\n    }\n\n    /**\n     * Gets a byte from a Map in a null-safe manner.\n     * <p>\n     * The byte is obtained from the results of {@link #getNumber(Map,Object)}.\n     * </p>\n     *\n     * @param <K> the key type\n     * @param map the map to use\n     * @param key the key to look up\n     * @return the value in the Map as a byte, {@code 0} if null map input\n     */\n    public static <K> byte getByteValue(final Map<? super K, ?> map, final K key) {\n        return applyDefaultValue(map, key, MapUtils::getByte, 0).byteValue();\n    }\n\n    /**\n     * Gets a byte from a Map in a null-safe manner, using the default value if the conversion fails.\n     * <p>\n     * The byte is obtained from the results of {@link #getNumber(Map,Object)}.\n     * </p>\n     *\n     * @param <K> the key type\n     * @param map the map to use\n     * @param key the key to look up\n     * @param defaultValue return if the value is null or if the conversion fails\n     * @return the value in the Map as a byte, {@code defaultValue} if null map input\n     */\n    public static <K> byte getByteValue(final Map<? super K, ?> map, final K key, final byte defaultValue) {\n        return applyDefaultValue(map, key, MapUtils::getByte, defaultValue).byteValue();\n    }\n\n    /**\n     * Gets a byte from a Map in a null-safe manner, using the default value produced by the defaultFunction if the\n     * conversion fails.\n     * <p>\n     * The byte is obtained from the results of {@link #getNumber(Map,Object)}.\n     * </p>\n     *\n     * @param <K> the key type\n     * @param map the map to use\n     * @param key the key to look up\n     * @param defaultFunction produce the default value to return if the value is null or if the conversion fails\n     * @return the value in the Map as a byte, default value produced by the {@code defaultFunction} if null map\n     *         input\n     * @since 4.5.0\n     */\n    public static <K> byte getByteValue(final Map<? super K, ?> map, final K key,\n            final Function<K, Byte> defaultFunction) {\n        return applyDefaultFunction(map, key, MapUtils::getByte, defaultFunction, (byte) 0).byteValue();\n    }\n\n    /**\n     * Gets a Double from a Map in a null-safe manner.\n     * <p>\n     * The Double is obtained from the results of {@link #getNumber(Map,Object)}.\n     * </p>\n     *\n     * @param <K> the key type\n     * @param map the map to use\n     * @param key the key to look up\n     * @return the value in the Map as a Double, {@code null} if null map input\n     */\n    public static <K> Double getDouble(final Map<? super K, ?> map, final K key) {\n        final Number answer = getNumber(map, key);\n        if (answer == null) {\n            return null;\n        }\n        if (answer instanceof Double) {\n            return (Double) answer;\n        }\n        return Double.valueOf(answer.doubleValue());\n    }\n\n    /**\n     * Looks up the given key in the given map, converting the result into a double, using the default value if the\n     * conversion fails.\n     *\n     * @param <K> the key type\n     * @param map the map whose value to look up\n     * @param key the key of the value to look up in that map\n     * @param defaultValue what to return if the value is null or if the conversion fails\n     * @return the value in the map as a number, or defaultValue if the original value is null, the map is null or the\n     *         number conversion fails\n     */\n    public static <K> Double getDouble(final Map<? super K, ?> map, final K key, final Double defaultValue) {\n        return applyDefaultValue(map, key, MapUtils::getDouble, defaultValue);\n    }\n\n    /**\n     * Looks up the given key in the given map, converting the result into a double, using the defaultFunction to\n     * produce the default value if the conversion fails.\n     *\n     * @param <K> the key type\n     * @param map the map whose value to look up\n     * @param key the key of the value to look up in that map\n     * @param defaultFunction what to produce the default value if the value is null or if the conversion fails\n     * @return the value in the map as a number, or defaultValue produced by the defaultFunction if the original value\n     *         is null, the map is null or the number conversion fails\n     * @since 4.5.0\n     */\n    public static <K> Double getDouble(final Map<? super K, ?> map, final K key,\n            final Function<K, Double> defaultFunction) {\n        return applyDefaultFunction(map, key, MapUtils::getDouble, defaultFunction);\n    }\n\n    /**\n     * Gets a double from a Map in a null-safe manner.\n     * <p>\n     * The double is obtained from the results of {@link #getNumber(Map,Object)}.\n     * </p>\n     *\n     * @param <K> the key type\n     * @param map the map to use\n     * @param key the key to look up\n     * @return the value in the Map as a double, {@code 0.0} if null map input\n     */\n    public static <K> double getDoubleValue(final Map<? super K, ?> map, final K key) {\n        return applyDefaultValue(map, key, MapUtils::getDouble, 0d).doubleValue();\n    }\n\n    /**\n     * Gets a double from a Map in a null-safe manner, using the default value if the conversion fails.\n     * <p>\n     * The double is obtained from the results of {@link #getNumber(Map,Object)}.\n     * </p>\n     *\n     * @param <K> the key type\n     * @param map the map to use\n     * @param key the key to look up\n     * @param defaultValue return if the value is null or if the conversion fails\n     * @return the value in the Map as a double, {@code defaultValue} if null map input\n     */\n    public static <K> double getDoubleValue(final Map<? super K, ?> map, final K key, final double defaultValue) {\n        return applyDefaultValue(map, key, MapUtils::getDouble, defaultValue).doubleValue();\n    }\n\n    /**\n     * Gets a double from a Map in a null-safe manner, using the default value produced by the defaultFunction if the\n     * conversion fails.\n     * <p>\n     * The double is obtained from the results of {@link #getNumber(Map,Object)}.\n     * </p>\n     *\n     * @param <K> the key type\n     * @param map the map to use\n     * @param key the key to look up\n     * @param defaultFunction produce the default value to return if the value is null or if the conversion fails\n     * @return the value in the Map as a double, default value produced by the {@code defaultFunction} if null map\n     *         input\n     * @since 4.5.0\n     */\n    public static <K> double getDoubleValue(final Map<? super K, ?> map, final K key,\n            final Function<K, Double> defaultFunction) {\n        return applyDefaultFunction(map, key, MapUtils::getDouble, defaultFunction, 0d).doubleValue();\n    }\n\n    /**\n     * Gets a Float from a Map in a null-safe manner.\n     * <p>\n     * The Float is obtained from the results of {@link #getNumber(Map,Object)}.\n     * </p>\n     *\n     * @param <K> the key type\n     * @param map the map to use\n     * @param key the key to look up\n     * @return the value in the Map as a Float, {@code null} if null map input\n     */\n    public static <K> Float getFloat(final Map<? super K, ?> map, final K key) {\n        final Number answer = getNumber(map, key);\n        if (answer == null) {\n            return null;\n        }\n        if (answer instanceof Float) {\n            return (Float) answer;\n        }\n        return Float.valueOf(answer.floatValue());\n    }\n\n    /**\n     * Looks up the given key in the given map, converting the result into a float, using the default value if the\n     * conversion fails.\n     *\n     * @param <K> the key type\n     * @param map the map whose value to look up\n     * @param key the key of the value to look up in that map\n     * @param defaultValue what to return if the value is null or if the conversion fails\n     * @return the value in the map as a number, or defaultValue if the original value is null, the map is null or the\n     *         number conversion fails\n     */\n    public static <K> Float getFloat(final Map<? super K, ?> map, final K key, final Float defaultValue) {\n        return applyDefaultValue(map, key, MapUtils::getFloat, defaultValue);\n    }\n\n    /**\n     * Looks up the given key in the given map, converting the result into a float, using the defaultFunction to produce\n     * the default value if the conversion fails.\n     *\n     * @param <K> the key type\n     * @param map the map whose value to look up\n     * @param key the key of the value to look up in that map\n     * @param defaultFunction what to produce the default value if the value is null or if the conversion fails\n     * @return the value in the map as a number, or defaultValue produced by the defaultFunction if the original value\n     *         is null, the map is null or the number conversion fails\n     * @since 4.5.0\n     */\n    public static <K> Float getFloat(final Map<? super K, ?> map, final K key,\n            final Function<K, Float> defaultFunction) {\n        return applyDefaultFunction(map, key, MapUtils::getFloat, defaultFunction);\n    }\n\n    /**\n     * Gets a float from a Map in a null-safe manner.\n     * <p>\n     * The float is obtained from the results of {@link #getNumber(Map,Object)}.\n     * </p>\n     *\n     * @param <K> the key type\n     * @param map the map to use\n     * @param key the key to look up\n     * @return the value in the Map as a float, {@code 0.0F} if null map input\n     */\n    public static <K> float getFloatValue(final Map<? super K, ?> map, final K key) {\n        return applyDefaultValue(map, key, MapUtils::getFloat, 0f).floatValue();\n    }\n\n    /**\n     * Gets a float from a Map in a null-safe manner, using the default value if the conversion fails.\n     * <p>\n     * The float is obtained from the results of {@link #getNumber(Map,Object)}.\n     * </p>\n     *\n     * @param <K> the key type\n     * @param map the map to use\n     * @param key the key to look up\n     * @param defaultValue return if the value is null or if the conversion fails\n     * @return the value in the Map as a float, {@code defaultValue} if null map input\n     */\n    public static <K> float getFloatValue(final Map<? super K, ?> map, final K key, final float defaultValue) {\n        return applyDefaultValue(map, key, MapUtils::getFloat, defaultValue).floatValue();\n    }\n\n    /**\n     * Gets a float from a Map in a null-safe manner, using the default value produced by the defaultFunction if the\n     * conversion fails.\n     * <p>\n     * The float is obtained from the results of {@link #getNumber(Map,Object)}.\n     * </p>\n     *\n     * @param <K> the key type\n     * @param map the map to use\n     * @param key the key to look up\n     * @param defaultFunction produce the default value to return if the value is null or if the conversion fails\n     * @return the value in the Map as a float, default value produced by the {@code defaultFunction} if null map\n     *         input\n     * @since 4.5.0\n     */\n    public static <K> float getFloatValue(final Map<? super K, ?> map, final K key,\n            final Function<K, Float> defaultFunction) {\n        return applyDefaultFunction(map, key, MapUtils::getFloat, defaultFunction, 0f).floatValue();\n    }\n\n    /**\n     * Gets an Integer from a Map in a null-safe manner.\n     * <p>\n     * The Integer is obtained from the results of {@link #getNumber(Map,Object)}.\n     * </p>\n     *\n     * @param <K> the key type\n     * @param map the map to use\n     * @param key the key to look up\n     * @return the value in the Map as an Integer, {@code null} if null map input\n     */\n    public static <K> Integer getInteger(final Map<? super K, ?> map, final K key) {\n        final Number answer = getNumber(map, key);\n        if (answer == null) {\n            return null;\n        }\n        if (answer instanceof Integer) {\n            return (Integer) answer;\n        }\n        return Integer.valueOf(answer.intValue());\n    }\n\n    /**\n     * Looks up the given key in the given map, converting the result into an integer, using the defaultFunction to\n     * produce the default value if the conversion fails.\n     *\n     * @param <K> the key type\n     * @param map the map whose value to look up\n     * @param key the key of the value to look up in that map\n     * @param defaultFunction what to produce the default value if the value is null or if the conversion fails\n     * @return the value in the map as a number, or defaultValue produced by the defaultFunction if the original value\n     *         is null, the map is null or the number conversion fails\n     * @since 4.5.0\n     */\n    public static <K> Integer getInteger(final Map<? super K, ?> map, final K key,\n            final Function<K, Integer> defaultFunction) {\n        return applyDefaultFunction(map, key, MapUtils::getInteger, defaultFunction);\n    }\n\n    /**\n     * Looks up the given key in the given map, converting the result into an integer, using the default value if the\n     * conversion fails.\n     *\n     * @param <K> the key type\n     * @param map the map whose value to look up\n     * @param key the key of the value to look up in that map\n     * @param defaultValue what to return if the value is null or if the conversion fails\n     * @return the value in the map as a number, or defaultValue if the original value is null, the map is null or the\n     *         number conversion fails\n     */\n    public static <K> Integer getInteger(final Map<? super K, ?> map, final K key, final Integer defaultValue) {\n        return applyDefaultValue(map, key, MapUtils::getInteger, defaultValue);\n    }\n\n    /**\n     * Gets an int from a Map in a null-safe manner.\n     * <p>\n     * The int is obtained from the results of {@link #getNumber(Map,Object)}.\n     * </p>\n     *\n     * @param <K> the key type\n     * @param map the map to use\n     * @param key the key to look up\n     * @return the value in the Map as an int, {@code 0} if null map input\n     */\n    public static <K> int getIntValue(final Map<? super K, ?> map, final K key) {\n        return applyDefaultValue(map, key, MapUtils::getInteger, 0).intValue();\n    }\n\n    /**\n     * Gets an int from a Map in a null-safe manner, using the default value produced by the defaultFunction if the\n     * conversion fails.\n     * <p>\n     * The int is obtained from the results of {@link #getNumber(Map,Object)}.\n     * </p>\n     *\n     * @param <K> the key type\n     * @param map the map to use\n     * @param key the key to look up\n     * @param defaultFunction produce the default value to return if the value is null or if the conversion fails\n     * @return the value in the Map as an int, default value produced by the {@code defaultFunction} if null map\n     *         input\n     * @since 4.5.0\n     */\n    public static <K> int getIntValue(final Map<? super K, ?> map, final K key,\n            final Function<K, Integer> defaultFunction) {\n        return applyDefaultFunction(map, key, MapUtils::getInteger, defaultFunction, 0).byteValue();\n    }\n\n    /**\n     * Gets an int from a Map in a null-safe manner, using the default value if the conversion fails.\n     * <p>\n     * The int is obtained from the results of {@link #getNumber(Map,Object)}.\n     * </p>\n     *\n     * @param <K> the key type\n     * @param map the map to use\n     * @param key the key to look up\n     * @param defaultValue return if the value is null or if the conversion fails\n     * @return the value in the Map as an int, {@code defaultValue} if null map input\n     */\n    public static <K> int getIntValue(final Map<? super K, ?> map, final K key, final int defaultValue) {\n        return applyDefaultValue(map, key, MapUtils::getInteger, defaultValue).intValue();\n    }\n\n    /**\n     * Gets a Long from a Map in a null-safe manner.\n     * <p>\n     * The Long is obtained from the results of {@link #getNumber(Map,Object)}.\n     * </p>\n     *\n     * @param <K> the key type\n     * @param map the map to use\n     * @param key the key to look up\n     * @return the value in the Map as a Long, {@code null} if null map input\n     */\n    public static <K> Long getLong(final Map<? super K, ?> map, final K key) {\n        final Number answer = getNumber(map, key);\n        if (answer == null) {\n            return null;\n        }\n        if (answer instanceof Long) {\n            return (Long) answer;\n        }\n        return Long.valueOf(answer.longValue());\n    }\n\n    /**\n     * Looks up the given key in the given map, converting the result into a Long, using the defaultFunction to produce\n     * the default value if the conversion fails.\n     *\n     * @param <K> the key type\n     * @param map the map whose value to look up\n     * @param key the key of the value to look up in that map\n     * @param defaultFunction what to produce the default value if the value is null or if the conversion fails\n     * @return the value in the map as a number, or defaultValue produced by the defaultFunction if the original value\n     *         is null, the map is null or the number conversion fails\n     * @since 4.5.0\n     */\n    public static <K> Long getLong(final Map<? super K, ?> map, final K key, final Function<K, Long> defaultFunction) {\n        return applyDefaultFunction(map, key, MapUtils::getLong, defaultFunction);\n    }\n\n    /**\n     * Looks up the given key in the given map, converting the result into a long, using the default value if the\n     * conversion fails.\n     *\n     * @param <K> the key type\n     * @param map the map whose value to look up\n     * @param key the key of the value to look up in that map\n     * @param defaultValue what to return if the value is null or if the conversion fails\n     * @return the value in the map as a number, or defaultValue if the original value is null, the map is null or the\n     *         number conversion fails\n     */\n    public static <K> Long getLong(final Map<? super K, ?> map, final K key, final Long defaultValue) {\n        return applyDefaultValue(map, key, MapUtils::getLong, defaultValue);\n    }\n\n    /**\n     * Gets a long from a Map in a null-safe manner.\n     * <p>\n     * The long is obtained from the results of {@link #getNumber(Map,Object)}.\n     * </p>\n     *\n     * @param <K> the key type\n     * @param map the map to use\n     * @param key the key to look up\n     * @return the value in the Map as a long, {@code 0L} if null map input\n     */\n    public static <K> long getLongValue(final Map<? super K, ?> map, final K key) {\n        return applyDefaultValue(map, key, MapUtils::getLong, 0L).longValue();\n    }\n\n    /**\n     * Gets a long from a Map in a null-safe manner, using the default value produced by the defaultFunction if the\n     * conversion fails.\n     * <p>\n     * The long is obtained from the results of {@link #getNumber(Map,Object)}.\n     * </p>\n     *\n     * @param <K> the key type\n     * @param map the map to use\n     * @param key the key to look up\n     * @param defaultFunction produce the default value to return if the value is null or if the conversion fails\n     * @return the value in the Map as a long, default value produced by the {@code defaultFunction} if null map\n     *         input\n     * @since 4.5.0\n     */\n    public static <K> long getLongValue(final Map<? super K, ?> map, final K key,\n            final Function<K, Long> defaultFunction) {\n        return applyDefaultFunction(map, key, MapUtils::getLong, defaultFunction, 0L).byteValue();\n    }\n\n    /**\n     * Gets a long from a Map in a null-safe manner, using the default value if the conversion fails.\n     * <p>\n     * The long is obtained from the results of {@link #getNumber(Map,Object)}.\n     * </p>\n     *\n     * @param <K> the key type\n     * @param map the map to use\n     * @param key the key to look up\n     * @param defaultValue return if the value is null or if the conversion fails\n     * @return the value in the Map as a long, {@code defaultValue} if null map input\n     */\n    public static <K> long getLongValue(final Map<? super K, ?> map, final K key, final long defaultValue) {\n        return applyDefaultValue(map, key, MapUtils::getLong, defaultValue).longValue();\n    }\n\n    /**\n     * Gets a Map from a Map in a null-safe manner.\n     * <p>\n     * If the value returned from the specified map is not a Map then {@code null} is returned.\n     * </p>\n     *\n     * @param <K> the key type\n     * @param map the map to use\n     * @param key the key to look up\n     * @return the value in the Map as a Map, {@code null} if null map input\n     */\n    public static <K> Map<?, ?> getMap(final Map<? super K, ?> map, final K key) {\n        if (map != null) {\n            final Object answer = map.get(key);\n            if (answer instanceof Map) {\n                return (Map<?, ?>) answer;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Looks up the given key in the given map, converting the result into a map, using the defaultFunction to produce\n     * the default value if the conversion fails.\n     *\n     * @param <K> the key type\n     * @param map the map whose value to look up\n     * @param key the key of the value to look up in that map\n     * @param defaultFunction what to produce the default value if the value is null or if the conversion fails\n     * @return the value in the map as a number, or defaultValue produced by the defaultFunction if the original value\n     *         is null, the map is null or the map conversion fails\n     * @since 4.5.0\n     */\n    public static <K> Map<?, ?> getMap(final Map<? super K, ?> map, final K key,\n            final Function<K, Map<?, ?>> defaultFunction) {\n        return applyDefaultFunction(map, key, MapUtils::getMap, defaultFunction);\n    }\n\n    /**\n     * Looks up the given key in the given map, converting the result into a map, using the default value if the\n     * conversion fails.\n     *\n     * @param <K> the key type\n     * @param map the map whose value to look up\n     * @param key the key of the value to look up in that map\n     * @param defaultValue what to return if the value is null or if the conversion fails\n     * @return the value in the map as a number, or defaultValue if the original value is null, the map is null or the\n     *         map conversion fails\n     */\n    public static <K> Map<?, ?> getMap(final Map<? super K, ?> map, final K key, final Map<?, ?> defaultValue) {\n        return applyDefaultValue(map, key, MapUtils::getMap, defaultValue);\n    }\n\n    /**\n     * Gets a Number from a Map in a null-safe manner.\n     * <p>\n     * If the value is a {@code Number} it is returned directly. If the value is a {@code String} it is\n     * converted using {@link NumberFormat#parse(String)} on the system default formatter returning {@code null} if\n     * the conversion fails. Otherwise, {@code null} is returned.\n     * </p>\n     *\n     * @param <K> the key type\n     * @param map the map to use\n     * @param key the key to look up\n     * @return the value in the Map as a Number, {@code null} if null map input\n     */\n    public static <K> Number getNumber(final Map<? super K, ?> map, final K key) {\n        if (map != null) {\n            final Object answer = map.get(key);\n            if (answer != null) {\n                if (answer instanceof Number) {\n                    return (Number) answer;\n                }\n                if (answer instanceof String) {\n                    try {\n                        final String text = (String) answer;\n                        return NumberFormat.getInstance().parse(text);\n                    } catch (final ParseException e) { // NOPMD\n                        // failure means null is returned\n                    }\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Looks up the given key in the given map, converting the result into a number, using the defaultFunction to\n     * produce the default value if the conversion fails.\n     *\n     * @param <K> the key type\n     * @param map the map whose value to look up\n     * @param key the key of the value to look up in that map\n     * @param defaultFunction what to produce the default value if the value is null or if the conversion fails\n     * @return the value in the map as a number, or defaultValue produced by the defaultFunction if the original value\n     *         is null, the map is null or the number conversion fails\n     * @since 4.5.0\n     */\n    public static <K> Number getNumber(final Map<? super K, ?> map, final K key,\n            final Function<K, Number> defaultFunction) {\n        return applyDefaultFunction(map, key, MapUtils::getNumber, defaultFunction);\n    }\n\n    /**\n     * Looks up the given key in the given map, converting the result into a number, using the default value if the\n     * conversion fails.\n     *\n     * @param <K> the key type\n     * @param map the map whose value to look up\n     * @param key the key of the value to look up in that map\n     * @param defaultValue what to return if the value is null or if the conversion fails\n     * @return the value in the map as a number, or defaultValue if the original value is null, the map is null or the\n     *         number conversion fails\n     */\n    public static <K> Number getNumber(final Map<? super K, ?> map, final K key, final Number defaultValue) {\n        return applyDefaultValue(map, key, MapUtils::getNumber, defaultValue);\n    }\n\n    /**\n     * Gets from a Map in a null-safe manner.\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param map the map to use\n     * @param key the key to look up\n     * @return the value in the Map, {@code null} if null map input\n     */\n    public static <K, V> V getObject(final Map<? super K, V> map, final K key) {\n        if (map != null) {\n            return map.get(key);\n        }\n        return null;\n    }\n\n    /**\n     * Looks up the given key in the given map, converting null into the given default value.\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param map the map whose value to look up\n     * @param key the key of the value to look up in that map\n     * @param defaultValue what to return if the value is null\n     * @return the value in the map, or defaultValue if the original value is null or the map is null\n     */\n    public static <K, V> V getObject(final Map<K, V> map, final K key, final V defaultValue) {\n        if (map != null) {\n            final V answer = map.get(key);\n            if (answer != null) {\n                return answer;\n            }\n        }\n        return defaultValue;\n    }\n\n    /**\n     * Gets a Short from a Map in a null-safe manner.\n     * <p>\n     * The Short is obtained from the results of {@link #getNumber(Map,Object)}.\n     * </p>\n     *\n     * @param <K> the key type\n     * @param map the map to use\n     * @param key the key to look up\n     * @return the value in the Map as a Short, {@code null} if null map input\n     */\n    public static <K> Short getShort(final Map<? super K, ?> map, final K key) {\n        final Number answer = getNumber(map, key);\n        if (answer == null) {\n            return null;\n        }\n        if (answer instanceof Short) {\n            return (Short) answer;\n        }\n        return Short.valueOf(answer.shortValue());\n    }\n\n    /**\n     * Looks up the given key in the given map, converting the result into a short, using the defaultFunction to produce\n     * the default value if the conversion fails.\n     *\n     * @param <K> the key type\n     * @param map the map whose value to look up\n     * @param key the key of the value to look up in that map\n     * @param defaultFunction what to produce the default value if the value is null or if the conversion fails\n     * @return the value in the map as a number, or defaultValue produced by the defaultFunction if the original value\n     *         is null, the map is null or the number conversion fails\n     * @since 4.5.0\n     */\n    public static <K> Short getShort(final Map<? super K, ?> map, final K key,\n            final Function<K, Short> defaultFunction) {\n        return applyDefaultFunction(map, key, MapUtils::getShort, defaultFunction);\n    }\n\n    /**\n     * Looks up the given key in the given map, converting the result into a short, using the default value if the\n     * conversion fails.\n     *\n     * @param <K> the key type\n     * @param map the map whose value to look up\n     * @param key the key of the value to look up in that map\n     * @param defaultValue what to return if the value is null or if the conversion fails\n     * @return the value in the map as a number, or defaultValue if the original value is null, the map is null or the\n     *         number conversion fails\n     */\n    public static <K> Short getShort(final Map<? super K, ?> map, final K key, final Short defaultValue) {\n        return applyDefaultValue(map, key, MapUtils::getShort, defaultValue);\n    }\n\n    /**\n     * Gets a short from a Map in a null-safe manner.\n     * <p>\n     * The short is obtained from the results of {@link #getNumber(Map,Object)}.\n     * </p>\n     *\n     * @param <K> the key type\n     * @param map the map to use\n     * @param key the key to look up\n     * @return the value in the Map as a short, {@code 0} if null map input\n     */\n    public static <K> short getShortValue(final Map<? super K, ?> map, final K key) {\n        return applyDefaultValue(map, key, MapUtils::getShort, 0).shortValue();\n    }\n\n    /**\n     * Gets a short from a Map in a null-safe manner, using the default value produced by the defaultFunction if the\n     * conversion fails.\n     * <p>\n     * The short is obtained from the results of {@link #getNumber(Map,Object)}.\n     * </p>\n     *\n     * @param <K> the key type\n     * @param map the map to use\n     * @param key the key to look up\n     * @param defaultFunction produce the default value to return if the value is null or if the conversion fails\n     * @return the value in the Map as a short, default value produced by the {@code defaultFunction} if null map\n     *         input\n     * @since 4.5.0\n     */\n    public static <K> short getShortValue(final Map<? super K, ?> map, final K key,\n            final Function<K, Short> defaultFunction) {\n        return applyDefaultFunction(map, key, MapUtils::getShort, defaultFunction, (short) 0).shortValue();\n    }\n\n    /**\n     * Gets a short from a Map in a null-safe manner, using the default value if the conversion fails.\n     * <p>\n     * The short is obtained from the results of {@link #getNumber(Map,Object)}.\n     * </p>\n     *\n     * @param <K> the key type\n     * @param map the map to use\n     * @param key the key to look up\n     * @param defaultValue return if the value is null or if the conversion fails\n     * @return the value in the Map as a short, {@code defaultValue} if null map input\n     */\n    public static <K> short getShortValue(final Map<? super K, ?> map, final K key, final short defaultValue) {\n        return applyDefaultValue(map, key, MapUtils::getShort, defaultValue).shortValue();\n    }\n\n    /**\n     * Gets a String from a Map in a null-safe manner.\n     * <p>\n     * The String is obtained via {@code toString}.\n     * </p>\n     *\n     * @param <K> the key type\n     * @param map the map to use\n     * @param key the key to look up\n     * @return the value in the Map as a String, {@code null} if null map input\n     */\n    public static <K> String getString(final Map<? super K, ?> map, final K key) {\n        if (map != null) {\n            final Object answer = map.get(key);\n            if (answer != null) {\n                return answer.toString();\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Looks up the given key in the given map, converting the result into a string, using the defaultFunction to\n     * produce the default value if the conversion fails.\n     *\n     * @param <K> the key type\n     * @param map the map whose value to look up\n     * @param key the key of the value to look up in that map\n     * @param defaultFunction what to produce the default value if the value is null or if the conversion fails\n     * @return the value in the map as a string, or defaultValue produced by the defaultFunction if the original value\n     *         is null, the map is null or the string conversion fails\n     * @since 4.5.0\n     */\n    public static <K> String getString(final Map<? super K, ?> map, final K key,\n            final Function<K, String> defaultFunction) {\n        return applyDefaultFunction(map, key, MapUtils::getString, defaultFunction);\n    }\n\n    /**\n     * Looks up the given key in the given map, converting the result into a string, using the default value if the\n     * conversion fails.\n     *\n     * @param <K> the key type\n     * @param map the map whose value to look up\n     * @param key the key of the value to look up in that map\n     * @param defaultValue what to return if the value is null or if the conversion fails\n     * @return the value in the map as a string, or defaultValue if the original value is null, the map is null or the\n     *         string conversion fails\n     */\n    public static <K> String getString(final Map<? super K, ?> map, final K key, final String defaultValue) {\n        return applyDefaultValue(map, key, MapUtils::getString, defaultValue);\n    }\n\n    /**\n     * Inverts the supplied map returning a new HashMap such that the keys of the input are swapped with the values.\n     * <p>\n     * This operation assumes that the inverse mapping is well defined. If the input map had multiple entries with the\n     * same value mapped to different keys, the returned map will map one of those keys to the value, but the exact key\n     * which will be mapped is undefined.\n     * </p>\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param map the map to invert, must not be null\n     * @return a new HashMap containing the inverted data\n     * @throws NullPointerException if the map is null\n     */\n    public static <K, V> Map<V, K> invertMap(final Map<K, V> map) {\n        Objects.requireNonNull(map, \"map\");\n        final Map<V, K> out = new HashMap<>(map.size());\n        for (final Entry<K, V> entry : map.entrySet()) {\n            out.put(entry.getValue(), entry.getKey());\n        }\n        return out;\n    }\n\n    /**\n     * Null-safe check if the specified map is empty.\n     * <p>\n     * Null returns true.\n     * </p>\n     *\n     * @param map the map to check, may be null\n     * @return true if empty or null\n     * @since 3.2\n     */\n    public static boolean isEmpty(final Map<?, ?> map) {\n        return map == null || map.isEmpty();\n    }\n\n    /**\n     * Null-safe check if the specified map is not empty.\n     * <p>\n     * Null returns false.\n     * </p>\n     *\n     * @param map the map to check, may be null\n     * @return true if non-null and non-empty\n     * @since 3.2\n     */\n    public static boolean isNotEmpty(final Map<?, ?> map) {\n        return !isEmpty(map);\n    }\n\n    /**\n     * Gets the specified {@link Map} as an {@link IterableMap}.\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param map to wrap if necessary.\n     * @return IterableMap&lt;K, V&gt;\n     * @throws NullPointerException if map is null\n     * @since 4.0\n     */\n    public static <K, V> IterableMap<K, V> iterableMap(final Map<K, V> map) {\n        Objects.requireNonNull(map, \"map\");\n        return map instanceof IterableMap ? (IterableMap<K, V>) map : new AbstractMapDecorator<K, V>(map) {\n            // empty\n        };\n    }\n\n    /**\n     * Gets the specified {@link SortedMap} as an {@link IterableSortedMap}.\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param sortedMap to wrap if necessary\n     * @return {@link IterableSortedMap}&lt;K, V&gt;\n     * @throws NullPointerException if sortedMap is null\n     * @since 4.0\n     */\n    public static <K, V> IterableSortedMap<K, V> iterableSortedMap(final SortedMap<K, V> sortedMap) {\n        Objects.requireNonNull(sortedMap, \"sortedMap\");\n        return sortedMap instanceof IterableSortedMap ? (IterableSortedMap<K, V>) sortedMap\n                : new AbstractSortedMapDecorator<K, V>(sortedMap) {\n                    // empty\n                };\n    }\n\n    /**\n     * Returns a \"lazy\" map whose values will be created on demand.\n     * <p>\n     * When the key passed to the returned map's {@link Map#get(Object)} method is not present in the map, then the\n     * factory will be used to create a new object and that object will become the value associated with that key.\n     * </p>\n     * <p>\n     * For instance:\n     * </p>\n     * <pre>\n     * Factory factory = new Factory() {\n     *     public Object create() {\n     *         return new Date();\n     *     }\n     * }\n     * Map lazyMap = MapUtils.lazyMap(new HashMap(), factory);\n     * Object obj = lazyMap.get(\"test\");\n     * </pre>\n     * <p>\n     * After the above code is executed, {@code obj} will contain a new {@code Date} instance. Furthermore,\n     * that {@code Date} instance is the value for the {@code \"test\"} key in the map.\n     * </p>\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param map the map to make lazy, must not be null\n     * @param factory the factory for creating new objects, must not be null\n     * @return a lazy map backed by the given map\n     * @throws NullPointerException if the Map or Factory is null\n     */\n    public static <K, V> IterableMap<K, V> lazyMap(final Map<K, V> map, final Factory<? extends V> factory) {\n        return LazyMap.lazyMap(map, factory);\n    }\n\n    /**\n     * Returns a \"lazy\" map whose values will be created on demand.\n     * <p>\n     * When the key passed to the returned map's {@link Map#get(Object)} method is not present in the map, then the\n     * factory will be used to create a new object and that object will become the value associated with that key. The\n     * factory is a {@link Transformer} that will be passed the key which it must transform into the value.\n     * </p>\n     * <p>\n     * For instance:\n     * </p>\n     * <pre>\n     * Transformer factory = new Transformer() {\n     *     public Object transform(Object mapKey) {\n     *         return new File(mapKey);\n     *     }\n     * }\n     * Map lazyMap = MapUtils.lazyMap(new HashMap(), factory);\n     * Object obj = lazyMap.get(\"C:/dev\");\n     * </pre>\n     *\n     * <p>\n     * After the above code is executed, {@code obj} will contain a new {@code File} instance for the C drive\n     * dev directory. Furthermore, that {@code File} instance is the value for the {@code \"C:/dev\"} key in the\n     * map.\n     * </p>\n     * <p>\n     * If a lazy map is wrapped by a synchronized map, the result is a simple synchronized cache. When an object is not\n     * is the cache, the cache itself calls back to the factory Transformer to populate itself, all within the same\n     * synchronized block.\n     * </p>\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param map the map to make lazy, must not be null\n     * @param transformerFactory the factory for creating new objects, must not be null\n     * @return a lazy map backed by the given map\n     * @throws NullPointerException if the Map or Transformer is null\n     */\n    public static <K, V> IterableMap<K, V> lazyMap(final Map<K, V> map,\n            final Transformer<? super K, ? extends V> transformerFactory) {\n        return LazyMap.lazyMap(map, transformerFactory);\n    }\n\n    /**\n     * Returns a \"lazy\" sorted map whose values will be created on demand.\n     * <p>\n     * When the key passed to the returned map's {@link Map#get(Object)} method is not present in the map, then the\n     * factory will be used to create a new object and that object will become the value associated with that key.\n     * </p>\n     * <p>\n     * For instance:\n     * </p>\n     * <pre>\n     * Factory factory = new Factory() {\n     *     public Object create() {\n     *         return new Date();\n     *     }\n     * }\n     * SortedMap lazy = MapUtils.lazySortedMap(new TreeMap(), factory);\n     * Object obj = lazy.get(\"test\");\n     * </pre>\n     * <p>\n     * After the above code is executed, {@code obj} will contain a new {@code Date} instance. Furthermore,\n     * that {@code Date} instance is the value for the {@code \"test\"} key.\n     * </p>\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param map the map to make lazy, must not be null\n     * @param factory the factory for creating new objects, must not be null\n     * @return a lazy map backed by the given map\n     * @throws NullPointerException if the SortedMap or Factory is null\n     */\n    public static <K, V> SortedMap<K, V> lazySortedMap(final SortedMap<K, V> map, final Factory<? extends V> factory) {\n        return LazySortedMap.lazySortedMap(map, factory);\n    }\n\n    /**\n     * Returns a \"lazy\" sorted map whose values will be created on demand.\n     * <p>\n     * When the key passed to the returned map's {@link Map#get(Object)} method is not present in the map, then the\n     * factory will be used to create a new object and that object will become the value associated with that key. The\n     * factory is a {@link Transformer} that will be passed the key which it must transform into the value.\n     * </p>\n     * <p>\n     * For instance:\n     * </p>\n     * <pre>\n     * Transformer factory = new Transformer() {\n     *     public Object transform(Object mapKey) {\n     *         return new File(mapKey);\n     *     }\n     * }\n     * SortedMap lazy = MapUtils.lazySortedMap(new TreeMap(), factory);\n     * Object obj = lazy.get(\"C:/dev\");\n     * </pre>\n     * <p>\n     * After the above code is executed, {@code obj} will contain a new {@code File} instance for the C drive\n     * dev directory. Furthermore, that {@code File} instance is the value for the {@code \"C:/dev\"} key in the\n     * map.\n     * </p>\n     * <p>\n     * If a lazy map is wrapped by a synchronized map, the result is a simple synchronized cache. When an object is not\n     * is the cache, the cache itself calls back to the factory Transformer to populate itself, all within the same\n     * synchronized block.\n     * </p>\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param map the map to make lazy, must not be null\n     * @param transformerFactory the factory for creating new objects, must not be null\n     * @return a lazy map backed by the given map\n     * @throws NullPointerException if the Map or Transformer is null\n     */\n    public static <K, V> SortedMap<K, V> lazySortedMap(final SortedMap<K, V> map,\n            final Transformer<? super K, ? extends V> transformerFactory) {\n        return LazySortedMap.lazySortedMap(map, transformerFactory);\n    }\n\n    /**\n     * Creates a multi-value map backed by the given map which returns collections of type ArrayList.\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param map the map to decorate\n     * @return a multi-value map backed by the given map which returns ArrayLists of values.\n     * @see MultiValueMap\n     * @since 3.2\n     * @deprecated since 4.1, use {@link MultiValuedMap} instead\n     */\n    @Deprecated\n    public static <K, V> MultiValueMap<K, V> multiValueMap(final Map<K, ? super Collection<V>> map) {\n        return MultiValueMap.<K, V>multiValueMap(map);\n    }\n\n    /**\n     * Creates a multi-value map backed by the given map which returns collections of the specified type.\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param <C> the collection class type\n     * @param map the map to decorate\n     * @param collectionClass the type of collections to return from the map (must contain public no-arg constructor and\n     *        extend Collection)\n     * @return a multi-value map backed by the given map which returns collections of the specified type\n     * @see MultiValueMap\n     * @since 3.2\n     * @deprecated since 4.1, use {@link MultiValuedMap} instead\n     */\n    @Deprecated\n    public static <K, V, C extends Collection<V>> MultiValueMap<K, V> multiValueMap(final Map<K, C> map,\n            final Class<C> collectionClass) {\n        return MultiValueMap.multiValueMap(map, collectionClass);\n    }\n\n    /**\n     * Creates a multi-value map backed by the given map which returns collections created by the specified collection\n     * factory.\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param <C> the collection class type\n     * @param map the map to decorate\n     * @param collectionFactory a factor which creates collection objects\n     * @return a multi-value map backed by the given map which returns collections created by the specified collection\n     *         factory\n     * @see MultiValueMap\n     * @since 3.2\n     * @deprecated since 4.1, use {@link MultiValuedMap} instead\n     */\n    @Deprecated\n    public static <K, V, C extends Collection<V>> MultiValueMap<K, V> multiValueMap(final Map<K, C> map,\n            final Factory<C> collectionFactory) {\n        return MultiValueMap.multiValueMap(map, collectionFactory);\n    }\n\n    /**\n     * Returns a map that maintains the order of keys that are added backed by the given map.\n     * <p>\n     * If a key is added twice, the order is determined by the first add. The order is observed through the keySet,\n     * values and entrySet.\n     * </p>\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param map the map to order, must not be null\n     * @return an ordered map backed by the given map\n     * @throws NullPointerException if the Map is null\n     */\n    public static <K, V> OrderedMap<K, V> orderedMap(final Map<K, V> map) {\n        return ListOrderedMap.listOrderedMap(map);\n    }\n\n    /**\n     * Populates a Map using the supplied {@code Transformer}s to transform the elements into keys and values.\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param <E> the type of object contained in the {@link Iterable}\n     * @param map the {@code Map} to populate.\n     * @param elements the {@code Iterable} containing the input values for the map.\n     * @param keyTransformer the {@code Transformer} used to transform the element into a key value\n     * @param valueTransformer the {@code Transformer} used to transform the element into a value\n     * @throws NullPointerException if the map, elements or transformers are null\n     */\n    public static <K, V, E> void populateMap(final Map<K, V> map, final Iterable<? extends E> elements,\n            final Transformer<E, K> keyTransformer, final Transformer<E, V> valueTransformer) {\n        for (final E temp : elements) {\n            map.put(keyTransformer.apply(temp), valueTransformer.apply(temp));\n        }\n    }\n\n    /**\n     * Populates a Map using the supplied {@code Transformer} to transform the elements into keys, using the\n     * unaltered element as the value in the {@code Map}.\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param map the {@code Map} to populate.\n     * @param elements the {@code Iterable} containing the input values for the map.\n     * @param keyTransformer the {@code Transformer} used to transform the element into a key value\n     * @throws NullPointerException if the map, elements or transformer are null\n     */\n    public static <K, V> void populateMap(final Map<K, V> map, final Iterable<? extends V> elements,\n            final Transformer<V, K> keyTransformer) {\n        populateMap(map, elements, keyTransformer, TransformerUtils.<V>nopTransformer());\n    }\n\n    /**\n     * Populates a MultiMap using the supplied {@code Transformer}s to transform the elements into keys and values.\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param <E> the type of object contained in the {@link Iterable}\n     * @param map the {@code MultiMap} to populate.\n     * @param elements the {@code Iterable} containing the input values for the map.\n     * @param keyTransformer the {@code Transformer} used to transform the element into a key value\n     * @param valueTransformer the {@code Transformer} used to transform the element into a value\n     * @throws NullPointerException if the map, collection or transformers are null\n     */\n    public static <K, V, E> void populateMap(final MultiMap<K, V> map, final Iterable<? extends E> elements,\n            final Transformer<E, K> keyTransformer, final Transformer<E, V> valueTransformer) {\n        for (final E temp : elements) {\n            map.put(keyTransformer.apply(temp), valueTransformer.apply(temp));\n        }\n    }\n\n    /**\n     * Populates a MultiMap using the supplied {@code Transformer} to transform the elements into keys, using the\n     * unaltered element as the value in the {@code MultiMap}.\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param map the {@code MultiMap} to populate.\n     * @param elements the {@code Iterable} to use as input values for the map.\n     * @param keyTransformer the {@code Transformer} used to transform the element into a key value\n     * @throws NullPointerException if the map, elements or transformer are null\n     */\n    public static <K, V> void populateMap(final MultiMap<K, V> map, final Iterable<? extends V> elements,\n            final Transformer<V, K> keyTransformer) {\n        populateMap(map, elements, keyTransformer, TransformerUtils.<V>nopTransformer());\n    }\n\n    /**\n     * Returns a predicated (validating) map backed by the given map.\n     * <p>\n     * Only objects that pass the tests in the given predicates can be added to the map. Trying to add an invalid object\n     * results in an IllegalArgumentException. Keys must pass the key predicate, values must pass the value predicate.\n     * It is important not to use the original map after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     * </p>\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param map the map to predicate, must not be null\n     * @param keyPred the predicate for keys, null means no check\n     * @param valuePred the predicate for values, null means no check\n     * @return a predicated map backed by the given map\n     * @throws NullPointerException if the Map is null\n     */\n    public static <K, V> IterableMap<K, V> predicatedMap(final Map<K, V> map, final Predicate<? super K> keyPred,\n            final Predicate<? super V> valuePred) {\n        return PredicatedMap.predicatedMap(map, keyPred, valuePred);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted map backed by the given map.\n     * <p>\n     * Only objects that pass the tests in the given predicates can be added to the map. Trying to add an invalid object\n     * results in an IllegalArgumentException. Keys must pass the key predicate, values must pass the value predicate.\n     * It is important not to use the original map after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     * </p>\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param map the map to predicate, must not be null\n     * @param keyPred the predicate for keys, null means no check\n     * @param valuePred the predicate for values, null means no check\n     * @return a predicated map backed by the given map\n     * @throws NullPointerException if the SortedMap is null\n     */\n    public static <K, V> SortedMap<K, V> predicatedSortedMap(final SortedMap<K, V> map,\n            final Predicate<? super K> keyPred, final Predicate<? super V> valuePred) {\n        return PredicatedSortedMap.predicatedSortedMap(map, keyPred, valuePred);\n    }\n\n    /**\n     * Writes indentation to the given stream.\n     *\n     * @param out the stream to indent\n     * @param indent the index of the indentation\n     */\n    private static void printIndent(final PrintStream out, final int indent) {\n        for (int i = 0; i < indent; i++) {\n            out.print(INDENT_STRING);\n        }\n    }\n\n    /**\n     * Puts all the keys and values from the specified array into the map.\n     * <p>\n     * This method is an alternative to the {@link java.util.Map#putAll(java.util.Map)} method and constructors. It\n     * allows you to build a map from an object array of various possible styles.\n     * </p>\n     * <p>\n     * If the first entry in the object array implements {@link java.util.Map.Entry} or {@link KeyValue} then the key\n     * and value are added from that object. If the first entry in the object array is an object array itself, then it\n     * is assumed that index 0 in the sub-array is the key and index 1 is the value. Otherwise, the array is treated as\n     * keys and values in alternate indices.\n     * </p>\n     * <p>\n     * For example, to create a color map:\n     * </p>\n     * <pre>\n     * Map colorMap = MapUtils.putAll(new HashMap(),\n     *         new String[][] { { \"RED\", \"#FF0000\" }, { \"GREEN\", \"#00FF00\" }, { \"BLUE\", \"#0000FF\" } });\n     * </pre>\n     * <p>\n     * or:\n     * </p>\n     * <pre>\n     * Map colorMap = MapUtils.putAll(new HashMap(),\n     *         new String[] { \"RED\", \"#FF0000\", \"GREEN\", \"#00FF00\", \"BLUE\", \"#0000FF\" });\n     * </pre>\n     * <p>\n     * or:\n     * </p>\n     * <pre>\n     * Map colorMap = MapUtils.putAll(new HashMap(), new Map.Entry[] { new DefaultMapEntry(\"RED\", \"#FF0000\"),\n     *         new DefaultMapEntry(\"GREEN\", \"#00FF00\"), new DefaultMapEntry(\"BLUE\", \"#0000FF\") });\n     * </pre>\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param map the map to populate, must not be null\n     * @param array an array to populate from, null ignored\n     * @return the input map\n     * @throws NullPointerException if map is null\n     * @throws IllegalArgumentException if sub-array or entry matching used and an entry is invalid\n     * @throws ClassCastException if the array contents is mixed\n     * @since 3.2\n     */\n    @SuppressWarnings(\"unchecked\") // As per Javadoc throws CCE for invalid array contents\n    public static <K, V> Map<K, V> putAll(final Map<K, V> map, final Object[] array) {\n        Objects.requireNonNull(map, \"map\");\n        if (array == null || array.length == 0) {\n            return map;\n        }\n        final Object obj = array[0];\n        if (obj instanceof Map.Entry) {\n            for (final Object element : array) {\n                // cast ok here, type is checked above\n                final Map.Entry<K, V> entry = (Map.Entry<K, V>) element;\n                map.put(entry.getKey(), entry.getValue());\n            }\n        } else if (obj instanceof KeyValue) {\n            for (final Object element : array) {\n                // cast ok here, type is checked above\n                final KeyValue<K, V> keyval = (KeyValue<K, V>) element;\n                map.put(keyval.getKey(), keyval.getValue());\n            }\n        } else if (obj instanceof Object[]) {\n            for (int i = 0; i < array.length; i++) {\n                final Object[] sub = (Object[]) array[i];\n                if (sub == null || sub.length < 2) {\n                    throw new IllegalArgumentException(\"Invalid array element: \" + i);\n                }\n                // these casts can fail if array has incorrect types\n                map.put((K) sub[0], (V) sub[1]);\n            }\n        } else {\n            for (int i = 0; i < array.length - 1;) {\n                // these casts can fail if array has incorrect types\n                map.put((K) array[i++], (V) array[i++]);\n            }\n        }\n        return map;\n    }\n\n    /**\n     * Protects against adding null values to a map.\n     * <p>\n     * This method checks the value being added to the map, and if it is null it is replaced by an empty string.\n     * </p>\n     * <p>\n     * This could be useful if the map does not accept null values, or for receiving data from a source that may provide\n     * null or empty string which should be held in the same way in the map.\n     * </p>\n     * <p>\n     * Keys are not validated. Note that this method can be used to circumvent the map's value type at runtime.\n     * </p>\n     *\n     * @param <K> the key type\n     * @param map the map to add to, must not be null\n     * @param key the key\n     * @param value the value, null converted to \"\"\n     * @throws NullPointerException if the map is null\n     */\n    public static <K> void safeAddToMap(final Map<? super K, Object> map, final K key, final Object value)\n            throws NullPointerException {\n        Objects.requireNonNull(map, \"map\");\n        map.put(key, value == null ? \"\" : value);\n    }\n\n    /**\n     * Gets the given map size or 0 if the map is null\n     *\n     * @param map a Map or null\n     * @return the given map size or 0 if the map is null\n     */\n    public static int size(final Map<?, ?> map) {\n        return map == null ? 0 : map.size();\n    }\n\n    /**\n     * Returns a synchronized map backed by the given map.\n     * <p>\n     * You must manually synchronize on the returned buffer's iterator to avoid non-deterministic behavior:\n     * </p>\n     * <pre>\n     * Map m = MapUtils.synchronizedMap(myMap);\n     * Sets s = m.keySet(); // outside synchronized block\n     * synchronized (m) { // synchronized on MAP!\n     *     Iterator i = s.iterator();\n     *     while (i.hasNext()) {\n     *         process(i.next());\n     *     }\n     * }\n     * </pre>\n     * <p>\n     * This method uses the implementation in {@link java.util.Collections Collections}.\n     * </p>\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param map the map to synchronize, must not be null\n     * @return a synchronized map backed by the given map\n     */\n    public static <K, V> Map<K, V> synchronizedMap(final Map<K, V> map) {\n        return Collections.synchronizedMap(map);\n    }\n\n    /**\n     * Returns a synchronized sorted map backed by the given sorted map.\n     * <p>\n     * You must manually synchronize on the returned buffer's iterator to avoid non-deterministic behavior:\n     * </p>\n     * <pre>\n     * Map m = MapUtils.synchronizedSortedMap(myMap);\n     * Sets s = m.keySet(); // outside synchronized block\n     * synchronized (m) { // synchronized on MAP!\n     *     Iterator i = s.iterator();\n     *     while (i.hasNext()) {\n     *         process(i.next());\n     *     }\n     * }\n     * </pre>\n     * <p>\n     * This method uses the implementation in {@link java.util.Collections Collections}.\n     * </p>\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param map the map to synchronize, must not be null\n     * @return a synchronized map backed by the given map\n     * @throws NullPointerException if the map is null\n     */\n    public static <K, V> SortedMap<K, V> synchronizedSortedMap(final SortedMap<K, V> map) {\n        return Collections.synchronizedSortedMap(map);\n    }\n\n    /**\n     * Creates a new HashMap using data copied from a ResourceBundle.\n     *\n     * @param resourceBundle the resource bundle to convert, must not be null\n     * @return the HashMap containing the data\n     * @throws NullPointerException if the bundle is null\n     */\n    public static Map<String, Object> toMap(final ResourceBundle resourceBundle) {\n        Objects.requireNonNull(resourceBundle, \"resourceBundle\");\n        final Enumeration<String> enumeration = resourceBundle.getKeys();\n        final Map<String, Object> map = new HashMap<>();\n\n        while (enumeration.hasMoreElements()) {\n            final String key = enumeration.nextElement();\n            final Object value = resourceBundle.getObject(key);\n            map.put(key, value);\n        }\n\n        return map;\n    }\n\n    /**\n     * Gets a new Properties object initialized with the values from a Map. A null input will return an empty properties\n     * object.\n     * <p>\n     * A Properties object may only store non-null keys and values, thus if the provided map contains either a key or\n     * value which is {@code null}, a {@link NullPointerException} will be thrown.\n     * </p>\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param map the map to convert to a Properties object\n     * @return the properties object\n     * @throws NullPointerException if a key or value in the provided map is {@code null}\n     */\n    public static <K, V> Properties toProperties(final Map<K, V> map) {\n        final Properties answer = new Properties();\n        if (map != null) {\n            for (final Entry<K, V> entry2 : map.entrySet()) {\n                final Map.Entry<?, ?> entry = entry2;\n                final Object key = entry.getKey();\n                final Object value = entry.getValue();\n                answer.put(key, value);\n            }\n        }\n        return answer;\n    }\n\n    /**\n     * Returns a transformed map backed by the given map.\n     * <p>\n     * This method returns a new map (decorating the specified map) that will transform any new entries added to it.\n     * Existing entries in the specified map will not be transformed. If you want that behavior, see\n     * {@link TransformedMap#transformedMap}.\n     * </p>\n     * <p>\n     * Each object is passed through the transformers as it is added to the Map. It is important not to use the original\n     * map after invoking this method, as it is a backdoor for adding untransformed objects.\n     * </p>\n     * <p>\n     * If there are any elements already in the map being decorated, they are NOT transformed.\n     * </p>\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param map the map to transform, must not be null, typically empty\n     * @param keyTransformer the transformer for the map keys, null means no transformation\n     * @param valueTransformer the transformer for the map values, null means no transformation\n     * @return a transformed map backed by the given map\n     * @throws NullPointerException if the Map is null\n     */\n    public static <K, V> IterableMap<K, V> transformedMap(final Map<K, V> map,\n            final Transformer<? super K, ? extends K> keyTransformer,\n            final Transformer<? super V, ? extends V> valueTransformer) {\n        return TransformedMap.transformingMap(map, keyTransformer, valueTransformer);\n    }\n\n    /**\n     * Returns a transformed sorted map backed by the given map.\n     * <p>\n     * This method returns a new sorted map (decorating the specified map) that will transform any new entries added to\n     * it. Existing entries in the specified map will not be transformed. If you want that behavior, see\n     * {@link TransformedSortedMap#transformedSortedMap}.\n     * </p>\n     * <p>\n     * Each object is passed through the transformers as it is added to the Map. It is important not to use the original\n     * map after invoking this method, as it is a backdoor for adding untransformed objects.\n     * </p>\n     * <p>\n     * If there are any elements already in the map being decorated, they are NOT transformed.\n     * </p>\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param map the map to transform, must not be null, typically empty\n     * @param keyTransformer the transformer for the map keys, null means no transformation\n     * @param valueTransformer the transformer for the map values, null means no transformation\n     * @return a transformed map backed by the given map\n     * @throws NullPointerException if the SortedMap is null\n     */\n    public static <K, V> SortedMap<K, V> transformedSortedMap(final SortedMap<K, V> map,\n            final Transformer<? super K, ? extends K> keyTransformer,\n            final Transformer<? super V, ? extends V> valueTransformer) {\n        return TransformedSortedMap.transformingSortedMap(map, keyTransformer, valueTransformer);\n    }\n\n    /**\n     * Returns an unmodifiable map backed by the given map.\n     * <p>\n     * This method uses the implementation in the decorators subpackage.\n     * </p>\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param map the map to make unmodifiable, must not be null\n     * @return an unmodifiable map backed by the given map\n     * @throws NullPointerException if the map is null\n     */\n    public static <K, V> Map<K, V> unmodifiableMap(final Map<? extends K, ? extends V> map) {\n        return UnmodifiableMap.unmodifiableMap(map);\n    }\n\n    /**\n     * Returns an unmodifiable sorted map backed by the given sorted map.\n     * <p>\n     * This method uses the implementation in the decorators subpackage.\n     * </p>\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param map the sorted map to make unmodifiable, must not be null\n     * @return an unmodifiable map backed by the given map\n     * @throws NullPointerException if the map is null\n     */\n    public static <K, V> SortedMap<K, V> unmodifiableSortedMap(final SortedMap<K, ? extends V> map) {\n        return UnmodifiableSortedMap.unmodifiableSortedMap(map);\n    }\n\n    /**\n     * Prints the given map with nice line breaks.\n     * <p>\n     * This method prints a nicely formatted String describing the Map. Each map entry will be printed with key and\n     * value. When the value is a Map, recursive behavior occurs.\n     * </p>\n     * <p>\n     * This method is NOT thread-safe in any special way. You must manually synchronize on either this class or the\n     * stream as required.\n     * </p>\n     *\n     * @param out the stream to print to, must not be null\n     * @param label The label to be used, may be {@code null}. If {@code null}, the label is not output. It\n     *        typically represents the name of the property in a bean or similar.\n     * @param map The map to print, may be {@code null}. If {@code null}, the text 'null' is output.\n     * @throws NullPointerException if the stream is {@code null}\n     */\n    public static void verbosePrint(final PrintStream out, final Object label, final Map<?, ?> map) {\n        verbosePrintInternal(out, label, map, new ArrayDeque<>(), false);\n    }\n\n    /**\n     * Implementation providing functionality for {@link #debugPrint} and for {@link #verbosePrint}. This prints the\n     * given map with nice line breaks. If the debug flag is true, it additionally prints the type of the object value.\n     * If the contents of a map include the map itself, then the text <em>(this Map)</em> is printed out. If the\n     * contents include a parent container of the map, the text <em>(ancestor[i] Map)</em> is printed, where it actually\n     * indicates the number of levels which must be traversed in the sequential list of ancestors (e.g. father,\n     * grandfather, great-grandfather, etc.).\n     *\n     * @param out the stream to print to\n     * @param label the label to be used, may be {@code null}. If {@code null}, the label is not output. It\n     *        typically represents the name of the property in a bean or similar.\n     * @param map the map to print, may be {@code null}. If {@code null}, the text 'null' is output\n     * @param lineage a stack consisting of any maps in which the previous argument is contained. This is checked to\n     *        avoid infinite recursion when printing the output\n     * @param debug flag indicating whether type names should be output.\n     * @throws NullPointerException if the stream is {@code null}\n     */\n    private static void verbosePrintInternal(final PrintStream out, final Object label, final Map<?, ?> map,\n            final Deque<Map<?, ?>> lineage, final boolean debug) {\n        printIndent(out, lineage.size());\n\n        if (map == null) {\n            if (label != null) {\n                out.print(label);\n                out.print(\" = \");\n            }\n            out.println(\"null\");\n            return;\n        }\n        if (label != null) {\n            out.print(label);\n            out.println(\" = \");\n        }\n\n        printIndent(out, lineage.size());\n        out.println(\"{\");\n\n        lineage.addLast(map);\n\n        for (final Map.Entry<?, ?> entry : map.entrySet()) {\n            final Object childKey = entry.getKey();\n            final Object childValue = entry.getValue();\n            if (childValue instanceof Map && !lineage.contains(childValue)) {\n                verbosePrintInternal(out, childKey == null ? \"null\" : childKey, (Map<?, ?>) childValue, lineage, debug);\n            } else {\n                printIndent(out, lineage.size());\n                out.print(childKey);\n                out.print(\" = \");\n\n                final int lineageIndex = IterableUtils.indexOf(lineage, PredicateUtils.equalPredicate(childValue));\n                if (lineageIndex == -1) {\n                    out.print(childValue);\n                } else if (lineage.size() - 1 == lineageIndex) {\n                    out.print(\"(this Map)\");\n                } else {\n                    out.print(\"(ancestor[\" + (lineage.size() - 1 - lineageIndex - 1) + \"] Map)\");\n                }\n\n                if (debug && childValue != null) {\n                    out.print(' ');\n                    out.println(childValue.getClass().getName());\n                } else {\n                    out.println();\n                }\n            }\n        }\n\n        lineage.removeLast();\n\n        printIndent(out, lineage.size());\n        out.println(debug ? \"} \" + map.getClass().getName() : \"}\");\n    }\n\n    /**\n     * Don't allow instances.\n     */\n    private MapUtils() {\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "@SuppressWarnings(\"rawtypes\")\n    public static final SortedMap EMPTY_SORTED_MAP = UnmodifiableSortedMap.unmodifiableSortedMap(new TreeMap<>());", "docstring": "\nAn empty unmodifiable sorted map. This is not provided in the JDK.\n", "modifiers": "@SuppressWarnings(\"rawtypes\")\n    public static final", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"rawtypes\")", "public", "static", "final"], "comments": [], "type": "SortedMap", "name": "EMPTY_SORTED_MAP = UnmodifiableSortedMap.unmodifiableSortedMap(new TreeMap<>())", "syntax_pass": true}, {"attribute_expression": "private static final String INDENT_STRING = \"    \";", "docstring": "\nString used to indent the verbose and debug Map prints.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "INDENT_STRING = \"    \"", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/MultiMapUtils.java.MultiMapUtils", "name": "MultiMapUtils", "file_path": "src/main/java/org/apache/commons/collections4/MultiMapUtils.java", "superclasses": "", "methods": ["[MultiValuedMap<K, V>]emptyIfNull(MultiValuedMap<K, V>)", "[MultiValuedMap<K, V>]emptyMultiValuedMap()", "[Collection<V>]getCollection(MultiValuedMap<K, V>,K)", "[Bag<V>]getValuesAsBag(MultiValuedMap<K, V>,K)", "[List<V>]getValuesAsList(MultiValuedMap<K, V>,K)", "[Set<V>]getValuesAsSet(MultiValuedMap<K, V>,K)", "[boolean]isEmpty(MultiValuedMap<?, ?>)", "[ListValuedMap<K, V>]newListValuedHashMap()", "[SetValuedMap<K, V>]newSetValuedHashMap()", "[MultiValuedMap<K, V>]transformedMultiValuedMap(MultiValuedMap<K, V>,Transformer<? super K, ? extends K>,Transformer<? super V, ? extends V>)", "[MultiValuedMap<K, V>]unmodifiableMultiValuedMap(MultiValuedMap<? extends K, ? extends V>)", "[]MultiMapUtils()"], "method_uris": ["src/main/java/org/apache/commons/collections4/MultiMapUtils.java.MultiMapUtils.[MultiValuedMap<K, V>]emptyIfNull(MultiValuedMap<K, V>)", "src/main/java/org/apache/commons/collections4/MultiMapUtils.java.MultiMapUtils.[MultiValuedMap<K, V>]emptyMultiValuedMap()", "src/main/java/org/apache/commons/collections4/MultiMapUtils.java.MultiMapUtils.[Collection<V>]getCollection(MultiValuedMap<K, V>,K)", "src/main/java/org/apache/commons/collections4/MultiMapUtils.java.MultiMapUtils.[Bag<V>]getValuesAsBag(MultiValuedMap<K, V>,K)", "src/main/java/org/apache/commons/collections4/MultiMapUtils.java.MultiMapUtils.[List<V>]getValuesAsList(MultiValuedMap<K, V>,K)", "src/main/java/org/apache/commons/collections4/MultiMapUtils.java.MultiMapUtils.[Set<V>]getValuesAsSet(MultiValuedMap<K, V>,K)", "src/main/java/org/apache/commons/collections4/MultiMapUtils.java.MultiMapUtils.[boolean]isEmpty(MultiValuedMap<?, ?>)", "src/main/java/org/apache/commons/collections4/MultiMapUtils.java.MultiMapUtils.[ListValuedMap<K, V>]newListValuedHashMap()", "src/main/java/org/apache/commons/collections4/MultiMapUtils.java.MultiMapUtils.[SetValuedMap<K, V>]newSetValuedHashMap()", "src/main/java/org/apache/commons/collections4/MultiMapUtils.java.MultiMapUtils.[MultiValuedMap<K, V>]transformedMultiValuedMap(MultiValuedMap<K, V>,Transformer<? super K, ? extends K>,Transformer<? super V, ? extends V>)", "src/main/java/org/apache/commons/collections4/MultiMapUtils.java.MultiMapUtils.[MultiValuedMap<K, V>]unmodifiableMultiValuedMap(MultiValuedMap<? extends K, ? extends V>)", "src/main/java/org/apache/commons/collections4/MultiMapUtils.java.MultiMapUtils.[]MultiMapUtils()"], "overrides": null, "attributes": [], "class_docstring": "\nProvides utility methods and decorators for {@link MultiValuedMap} instances.\n<p>\nIt contains various type safe and null safe methods. Additionally, it provides\nthe following decorators:\n</p>\n<ul>\n  <li>{@link #unmodifiableMultiValuedMap(MultiValuedMap)}</li>\n  <li>{@link #transformedMultiValuedMap(MultiValuedMap, Transformer, Transformer)}</li>\n</ul>\n\n@since 4.1\n", "original_string": "public class MultiMapUtils {\n\n    /**\n     * An empty {@link UnmodifiableMultiValuedMap}.\n     */\n    @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n    public static final MultiValuedMap EMPTY_MULTI_VALUED_MAP =\n            UnmodifiableMultiValuedMap.unmodifiableMultiValuedMap(new ArrayListValuedHashMap(0, 0));\n\n    /**\n     * Returns an immutable empty {@code MultiValuedMap} if the argument is\n     * {@code null}, or the argument itself otherwise.\n     *\n     * @param <K> the type of key in the map\n     * @param <V> the type of value in the map\n     * @param map  the map, may be null\n     * @return an empty {@link MultiValuedMap} if the argument is null\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static <K, V> MultiValuedMap<K, V> emptyIfNull(final MultiValuedMap<K, V> map) {\n        return map == null ? EMPTY_MULTI_VALUED_MAP : map;\n    }\n\n    /**\n     * Returns immutable EMPTY_MULTI_VALUED_MAP with generic type safety.\n     *\n     * @param <K> the type of key in the map\n     * @param <V> the type of value in the map\n     * @return immutable and empty {@code MultiValuedMap}\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static <K, V> MultiValuedMap<K, V> emptyMultiValuedMap() {\n        return EMPTY_MULTI_VALUED_MAP;\n    }\n\n    // Null safe methods\n\n    /**\n     * Gets a Collection from {@code MultiValuedMap} in a null-safe manner.\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param map  the {@link MultiValuedMap} to use\n     * @param key  the key to look up\n     * @return the Collection in the {@link MultiValuedMap}, or null if input map is null\n     */\n    public static <K, V> Collection<V> getCollection(final MultiValuedMap<K, V> map, final K key) {\n        if (map != null) {\n            return map.get(key);\n        }\n        return null;\n    }\n\n    /**\n     * Gets a Bag from {@code MultiValuedMap} in a null-safe manner.\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param map  the {@link MultiValuedMap} to use\n     * @param key  the key to look up\n     * @return the Collection in the {@link MultiValuedMap} as Bag, or null if input map is null\n     */\n    public static <K, V> Bag<V> getValuesAsBag(final MultiValuedMap<K, V> map, final K key) {\n        if (map != null) {\n            final Collection<V> col = map.get(key);\n            if (col instanceof Bag) {\n                return (Bag<V>) col;\n            }\n            return new HashBag<>(col);\n        }\n        return null;\n    }\n\n    /**\n     * Gets a List from {@code MultiValuedMap} in a null-safe manner.\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param map  the {@link MultiValuedMap} to use\n     * @param key  the key to look up\n     * @return the Collection in the {@link MultiValuedMap} as List, or null if input map is null\n     */\n    public static <K, V> List<V> getValuesAsList(final MultiValuedMap<K, V> map, final K key) {\n        if (map != null) {\n            final Collection<V> col = map.get(key);\n            if (col instanceof List) {\n                return (List<V>) col;\n            }\n            return new ArrayList<>(col);\n        }\n        return null;\n    }\n\n    // TODO: review the getValuesAsXXX methods - depending on the actual MultiValuedMap type, changes\n    // to the returned collection might update the backing map. This should be clarified and/or prevented.\n\n    /**\n     * Gets a Set from {@code MultiValuedMap} in a null-safe manner.\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param map  the {@link MultiValuedMap} to use\n     * @param key  the key to look up\n     * @return the Collection in the {@link MultiValuedMap} as Set, or null if input map is null\n     */\n    public static <K, V> Set<V> getValuesAsSet(final MultiValuedMap<K, V> map, final K key) {\n        if (map != null) {\n            final Collection<V> col = map.get(key);\n            if (col instanceof Set) {\n                return (Set<V>) col;\n            }\n            return new HashSet<>(col);\n        }\n        return null;\n    }\n\n    /**\n     * Null-safe check if the specified {@code MultiValuedMap} is empty.\n     * <p>\n     * If the provided map is null, returns true.\n     *\n     * @param map  the map to check, may be null\n     * @return true if the map is empty or null\n     */\n    public static boolean isEmpty(final MultiValuedMap<?, ?> map) {\n        return map == null || map.isEmpty();\n    }\n\n    /**\n     * Creates a {@link ListValuedMap} with an {@link java.util.ArrayList ArrayList} as\n     * collection class to store the values mapped to a key.\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @return a new {@code ListValuedMap}\n     */\n    public static <K, V> ListValuedMap<K, V> newListValuedHashMap() {\n        return new ArrayListValuedHashMap<>();\n    }\n\n    /**\n     * Creates a {@link SetValuedMap} with an {@link java.util.HashSet HashSet} as\n     * collection class to store the values mapped to a key.\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @return a new {@link SetValuedMap}\n     */\n    public static <K, V> SetValuedMap<K, V> newSetValuedHashMap() {\n        return new HashSetValuedHashMap<>();\n    }\n\n    /**\n     * Returns a {@code TransformedMultiValuedMap} backed by the given map.\n     * <p>\n     * This method returns a new {@code MultiValuedMap} (decorating the\n     * specified map) that will transform any new entries added to it. Existing\n     * entries in the specified map will not be transformed. If you want that\n     * behavior, see {@link TransformedMultiValuedMap#transformedMap}.\n     * <p>\n     * Each object is passed through the transformers as it is added to the Map.\n     * It is important not to use the original map after invoking this method,\n     * as it is a back door for adding untransformed objects.\n     * <p>\n     * If there are any elements already in the map being decorated, they are\n     * NOT transformed.\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param map  the {@link MultiValuedMap} to transform, must not be null, typically empty\n     * @param keyTransformer  the transformer for the map keys, null means no transformation\n     * @param valueTransformer  the transformer for the map values, null means no transformation\n     * @return a transformed {@code MultiValuedMap} backed by the given map\n     * @throws NullPointerException if map is null\n     */\n    public static <K, V> MultiValuedMap<K, V> transformedMultiValuedMap(final MultiValuedMap<K, V> map,\n            final Transformer<? super K, ? extends K> keyTransformer,\n            final Transformer<? super V, ? extends V> valueTransformer) {\n        return TransformedMultiValuedMap.transformingMap(map, keyTransformer, valueTransformer);\n    }\n\n    /**\n     * Returns an {@code UnmodifiableMultiValuedMap} backed by the given\n     * map.\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param map  the {@link MultiValuedMap} to decorate, must not be null\n     * @return an unmodifiable {@link MultiValuedMap} backed by the provided map\n     * @throws NullPointerException if map is null\n     */\n    public static <K, V> MultiValuedMap<K, V> unmodifiableMultiValuedMap(\n            final MultiValuedMap<? extends K, ? extends V> map) {\n        return UnmodifiableMultiValuedMap.<K, V>unmodifiableMultiValuedMap(map);\n    }\n\n    /**\n     * Don't allow instances.\n     */\n    private MultiMapUtils() {\n        // empty\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n    public static final MultiValuedMap EMPTY_MULTI_VALUED_MAP =\n            UnmodifiableMultiValuedMap.unmodifiableMultiValuedMap(new ArrayListValuedHashMap(0, 0));", "docstring": "\nAn empty {@link UnmodifiableMultiValuedMap}.\n", "modifiers": "@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n    public static final", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings({ \"rawtypes\", \"unchecked\" })", "public", "static", "final"], "comments": [], "type": "MultiValuedMap", "name": "EMPTY_MULTI_VALUED_MAP =\n            UnmodifiableMultiValuedMap.unmodifiableMultiValuedMap(new ArrayListValuedHashMap(0, 0))", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/FactoryUtils.java.FactoryUtils", "name": "FactoryUtils", "file_path": "src/main/java/org/apache/commons/collections4/FactoryUtils.java", "superclasses": "", "methods": ["[Factory<T>]constantFactory(T)", "[Factory<T>]exceptionFactory()", "[Factory<T>]instantiateFactory(Class<T>)", "[Factory<T>]instantiateFactory(Class<T>,Class<?>[],Object[])", "[Factory<T>]nullFactory()", "[Factory<T>]prototypeFactory(T)", "[]FactoryUtils()"], "method_uris": ["src/main/java/org/apache/commons/collections4/FactoryUtils.java.FactoryUtils.[Factory<T>]constantFactory(T)", "src/main/java/org/apache/commons/collections4/FactoryUtils.java.FactoryUtils.[Factory<T>]exceptionFactory()", "src/main/java/org/apache/commons/collections4/FactoryUtils.java.FactoryUtils.[Factory<T>]instantiateFactory(Class<T>)", "src/main/java/org/apache/commons/collections4/FactoryUtils.java.FactoryUtils.[Factory<T>]instantiateFactory(Class<T>,Class<?>[],Object[])", "src/main/java/org/apache/commons/collections4/FactoryUtils.java.FactoryUtils.[Factory<T>]nullFactory()", "src/main/java/org/apache/commons/collections4/FactoryUtils.java.FactoryUtils.[Factory<T>]prototypeFactory(T)", "src/main/java/org/apache/commons/collections4/FactoryUtils.java.FactoryUtils.[]FactoryUtils()"], "overrides": null, "attributes": [], "class_docstring": "\n{@code FactoryUtils} provides reference implementations and utilities\nfor the Factory functor interface. The supplied factories are:\n<ul>\n<li>Prototype - clones a specified object\n<li>Instantiate - creates objects using reflection\n<li>Constant - always returns the same object\n<li>Null - always returns null\n<li>Exception - always throws an exception\n</ul>\n<p>\nSince v4.1 only factories which are considered to be safe are\nSerializable. Factories considered to be unsafe for serialization are:\n<ul>\n<li>Prototype\n<li>Instantiate\n</ul>\n\n@since 3.0\n", "original_string": "public class FactoryUtils {\n\n    /**\n     * Creates a Factory that will return the same object each time the factory\n     * is used. No check is made that the object is immutable. In general, only\n     * immutable objects should use the constant factory. Mutable objects should\n     * use the prototype factory.\n     *\n     * @see org.apache.commons.collections4.functors.ConstantFactory\n     *\n     * @param <T> the type that the factory creates\n     * @param constantToReturn  the constant object to return each time in the factory\n     * @return the {@code constant} factory.\n     */\n    public static <T> Factory<T> constantFactory(final T constantToReturn) {\n        return ConstantFactory.constantFactory(constantToReturn);\n    }\n\n    /**\n     * Gets a Factory that always throws an exception.\n     * This could be useful during testing as a placeholder.\n     *\n     * @see org.apache.commons.collections4.functors.ExceptionFactory\n     *\n     * @param <T> the type that the factory creates\n     * @return the factory\n     */\n    public static <T> Factory<T> exceptionFactory() {\n        return ExceptionFactory.<T>exceptionFactory();\n    }\n\n    /**\n     * Creates a Factory that can create objects of a specific type using\n     * a no-args constructor.\n     *\n     * @see org.apache.commons.collections4.functors.InstantiateFactory\n     *\n     * @param <T> the type that the factory creates\n     * @param classToInstantiate  the Class to instantiate each time in the factory\n     * @return the {@code reflection} factory\n     * @throws NullPointerException if the classToInstantiate is null\n     */\n    public static <T> Factory<T> instantiateFactory(final Class<T> classToInstantiate) {\n        return InstantiateFactory.instantiateFactory(classToInstantiate, null, null);\n    }\n\n    /**\n     * Creates a Factory that can create objects of a specific type using\n     * the arguments specified to this method.\n     *\n     * @see org.apache.commons.collections4.functors.InstantiateFactory\n     *\n     * @param <T> the type that the factory creates\n     * @param classToInstantiate  the Class to instantiate each time in the factory\n     * @param paramTypes  parameter types for the constructor, can be null\n     * @param args  the arguments to pass to the constructor, can be null\n     * @return the {@code reflection} factory\n     * @throws NullPointerException if the classToInstantiate is null\n     * @throws IllegalArgumentException if the paramTypes and args don't match\n     * @throws IllegalArgumentException if the constructor doesn't exist\n     */\n    public static <T> Factory<T> instantiateFactory(final Class<T> classToInstantiate, final Class<?>[] paramTypes,\n                                                    final Object[] args) {\n        return InstantiateFactory.instantiateFactory(classToInstantiate, paramTypes, args);\n    }\n\n    /**\n     * Gets a Factory that will return null each time the factory is used.\n     * This could be useful during testing as a placeholder.\n     *\n     * @see org.apache.commons.collections4.functors.ConstantFactory\n     * @param <T> the \"type\" of null object the factory should return.\n     * @return the factory\n     */\n    public static <T> Factory<T> nullFactory() {\n        return ConstantFactory.<T>constantFactory(null);\n    }\n\n    /**\n     * Creates a Factory that will return a clone of the same prototype object\n     * each time the factory is used. The prototype will be cloned using one of these\n     * techniques (in order):\n     *\n     * <ul>\n     * <li>public clone method</li>\n     * <li>public copy constructor</li>\n     * <li>serialization clone</li>\n     * </ul>\n     *\n     * @see org.apache.commons.collections4.functors.PrototypeFactory\n     *\n     * @param <T> the type that the factory creates\n     * @param prototype  the object to clone each time in the factory\n     * @return the {@code prototype} factory, or a {@link ConstantFactory#NULL_INSTANCE} if\n     * the {@code prototype} is {@code null}\n     * @throws IllegalArgumentException if the prototype cannot be cloned\n     */\n    public static <T> Factory<T> prototypeFactory(final T prototype) {\n        return PrototypeFactory.<T>prototypeFactory(prototype);\n    }\n\n    /**\n     * Don't allow instances.\n     */\n    private FactoryUtils() {\n        // empty\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/org/apache/commons/collections4/FluentIterable.java.FluentIterable", "name": "FluentIterable", "file_path": "src/main/java/org/apache/commons/collections4/FluentIterable.java", "superclasses": "", "methods": ["[FluentIterable<T>]empty()", "[FluentIterable<T>]of(Iterable<T>)", "[FluentIterable<T>]of(T)", "[FluentIterable<T>]of()", "[]FluentIterable()", "[]FluentIterable(Iterable<E>)", "[boolean]allMatch(Predicate<? super E>)", "[boolean]anyMatch(Predicate<? super E>)", "[FluentIterable<E>]append()", "[FluentIterable<E>]append(Iterable<? extends E>)", "[Enumeration<E>]asEnumeration()", "[FluentIterable<E>]collate(Iterable<? extends E>)", "[FluentIterable<E>]collate(Iterable<? extends E>,Comparator<? super E>)", "[boolean]contains(Object)", "[void]copyInto(Collection<? super E>)", "[FluentIterable<E>]eval()", "[FluentIterable<E>]filter(Predicate<? super E>)", "[void]forEach(Closure<? super E>)", "[E]get(int)", "[boolean]isEmpty()", "[Iterator<E>]iterator()", "[FluentIterable<E>]limit(long)", "[FluentIterable<E>]loop()", "[FluentIterable<E>]reverse()", "[int]size()", "[FluentIterable<E>]skip(long)", "[E[]]toArray(Class<E>)", "[List<E>]toList()", "[String]toString()", "[FluentIterable<O>]transform(Transformer<? super E, ? extends O>)", "[FluentIterable<E>]unique()", "[FluentIterable<E>]unmodifiable()", "[FluentIterable<E>]zip(Iterable<? extends E>)", "[FluentIterable<E>]zip()"], "method_uris": ["src/main/java/org/apache/commons/collections4/FluentIterable.java.FluentIterable.[FluentIterable<T>]empty()", "src/main/java/org/apache/commons/collections4/FluentIterable.java.FluentIterable.[FluentIterable<T>]of(Iterable<T>)", "src/main/java/org/apache/commons/collections4/FluentIterable.java.FluentIterable.[FluentIterable<T>]of(T)", "src/main/java/org/apache/commons/collections4/FluentIterable.java.FluentIterable.[FluentIterable<T>]of()", "src/main/java/org/apache/commons/collections4/FluentIterable.java.FluentIterable.[]FluentIterable()", "src/main/java/org/apache/commons/collections4/FluentIterable.java.FluentIterable.[]FluentIterable(Iterable<E>)", "src/main/java/org/apache/commons/collections4/FluentIterable.java.FluentIterable.[boolean]allMatch(Predicate<? super E>)", "src/main/java/org/apache/commons/collections4/FluentIterable.java.FluentIterable.[boolean]anyMatch(Predicate<? super E>)", "src/main/java/org/apache/commons/collections4/FluentIterable.java.FluentIterable.[FluentIterable<E>]append()", "src/main/java/org/apache/commons/collections4/FluentIterable.java.FluentIterable.[FluentIterable<E>]append(Iterable<? extends E>)", "src/main/java/org/apache/commons/collections4/FluentIterable.java.FluentIterable.[Enumeration<E>]asEnumeration()", "src/main/java/org/apache/commons/collections4/FluentIterable.java.FluentIterable.[FluentIterable<E>]collate(Iterable<? extends E>)", "src/main/java/org/apache/commons/collections4/FluentIterable.java.FluentIterable.[FluentIterable<E>]collate(Iterable<? extends E>,Comparator<? super E>)", "src/main/java/org/apache/commons/collections4/FluentIterable.java.FluentIterable.[boolean]contains(Object)", "src/main/java/org/apache/commons/collections4/FluentIterable.java.FluentIterable.[void]copyInto(Collection<? super E>)", "src/main/java/org/apache/commons/collections4/FluentIterable.java.FluentIterable.[FluentIterable<E>]eval()", "src/main/java/org/apache/commons/collections4/FluentIterable.java.FluentIterable.[FluentIterable<E>]filter(Predicate<? super E>)", "src/main/java/org/apache/commons/collections4/FluentIterable.java.FluentIterable.[void]forEach(Closure<? super E>)", "src/main/java/org/apache/commons/collections4/FluentIterable.java.FluentIterable.[E]get(int)", "src/main/java/org/apache/commons/collections4/FluentIterable.java.FluentIterable.[boolean]isEmpty()", "src/main/java/org/apache/commons/collections4/FluentIterable.java.FluentIterable.[Iterator<E>]iterator()", "src/main/java/org/apache/commons/collections4/FluentIterable.java.FluentIterable.[FluentIterable<E>]limit(long)", "src/main/java/org/apache/commons/collections4/FluentIterable.java.FluentIterable.[FluentIterable<E>]loop()", "src/main/java/org/apache/commons/collections4/FluentIterable.java.FluentIterable.[FluentIterable<E>]reverse()", "src/main/java/org/apache/commons/collections4/FluentIterable.java.FluentIterable.[int]size()", "src/main/java/org/apache/commons/collections4/FluentIterable.java.FluentIterable.[FluentIterable<E>]skip(long)", "src/main/java/org/apache/commons/collections4/FluentIterable.java.FluentIterable.[E[]]toArray(Class<E>)", "src/main/java/org/apache/commons/collections4/FluentIterable.java.FluentIterable.[List<E>]toList()", "src/main/java/org/apache/commons/collections4/FluentIterable.java.FluentIterable.[String]toString()", "src/main/java/org/apache/commons/collections4/FluentIterable.java.FluentIterable.[FluentIterable<O>]transform(Transformer<? super E, ? extends O>)", "src/main/java/org/apache/commons/collections4/FluentIterable.java.FluentIterable.[FluentIterable<E>]unique()", "src/main/java/org/apache/commons/collections4/FluentIterable.java.FluentIterable.[FluentIterable<E>]unmodifiable()", "src/main/java/org/apache/commons/collections4/FluentIterable.java.FluentIterable.[FluentIterable<E>]zip(Iterable<? extends E>)", "src/main/java/org/apache/commons/collections4/FluentIterable.java.FluentIterable.[FluentIterable<E>]zip()"], "overrides": null, "attributes": [], "class_docstring": "\nA FluentIterable provides a powerful yet simple API for manipulating\nIterable instances in a fluent manner.\n<p>\nA FluentIterable can be created either from an Iterable or from a set\nof elements. The following types of methods are provided:\n</p>\n<ul>\n  <li>fluent methods which return a new {@code FluentIterable} instance,\n      providing a view of the original iterable (e.g. filter(Predicate));\n  <li>conversion methods which copy the FluentIterable's contents into a\n      new collection or array (e.g. toList());\n  <li>utility methods which answer questions about the FluentIterable's\n      contents (e.g. size(), anyMatch(Predicate)).\n  <li>\n</ul>\n<p>\nThe following example outputs the first 3 even numbers in the range [1, 10]\ninto a list:\n</p>\n<pre>\nList&lt;String&gt; result =\n  FluentIterable\n      .of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n      .filter(new Predicate&lt;Integer&gt;() {\n                  public boolean evaluate(Integer number) {\n                       return number % 2 == 0;\n                  }\n             )\n      .transform(TransformerUtils.stringValueTransformer())\n      .limit(3)\n      .toList();\n</pre>\nThe resulting list will contain the following elements:\n<pre>[2, 4, 6]</pre>\n\n@param <E>  the element type\n@since 4.1\n", "original_string": "public class FluentIterable<E> implements Iterable<E> {\n\n    /**\n     * Creates a new empty FluentIterable.\n     *\n     * @param <T>  the element type\n     * @return a new empty FluentIterable\n     */\n    public static <T> FluentIterable<T> empty() {\n        return IterableUtils.EMPTY_ITERABLE;\n    }\n\n    /**\n     * Constructs a new FluentIterable from the provided iterable. If the\n     * iterable is already an instance of FluentIterable, the instance\n     * will be returned instead.\n     * <p>\n     * The returned iterable's iterator supports {@code remove()} when the\n     * corresponding input iterator supports it.\n     *\n     * @param <T>  the element type\n     * @param iterable  the iterable to wrap into a FluentIterable, may not be null\n     * @return a new FluentIterable wrapping the provided iterable\n     * @throws NullPointerException if iterable is null\n     */\n    public static <T> FluentIterable<T> of(final Iterable<T> iterable) {\n        Objects.requireNonNull(iterable, \"iterable\");\n        if (iterable instanceof FluentIterable<?>) {\n            return (FluentIterable<T>) iterable;\n        }\n        return new FluentIterable<>(iterable);\n    }\n\n    /**\n     * Creates a new FluentIterable of the single provided element.\n     * <p>\n     * The returned iterable's iterator does not support {@code remove()}.\n     *\n     * @param <T>  the element type\n     * @param singleton  the singleton element\n     * @return a new FluentIterable containing the singleton\n     */\n    public static <T> FluentIterable<T> of(final T singleton) {\n        return of(IteratorUtils.asIterable(new SingletonIterator<>(singleton, false)));\n    }\n\n    /**\n     * Creates a new FluentIterable from the provided elements.\n     * <p>\n     * The returned iterable's iterator does not support {@code remove()}.\n     *\n     * @param <T>  the element type\n     * @param elements  the elements to be contained in the FluentIterable\n     * @return a new FluentIterable containing the provided elements\n     */\n    public static <T> FluentIterable<T> of(final T... elements) {\n        return of(Arrays.asList(elements));\n    }\n\n    /** A reference to the wrapped iterable. */\n    private final Iterable<E> iterable;\n\n    /**\n     * Don't allow instances.\n     */\n    FluentIterable() {\n        iterable = this;\n    }\n\n    /**\n     * Create a new FluentIterable by wrapping the provided iterable.\n     * @param iterable  the iterable to wrap\n     */\n    private FluentIterable(final Iterable<E> iterable) {\n        this.iterable = iterable;\n    }\n\n    /**\n     * Checks if all elements contained in this iterable are matching the\n     * provided predicate.\n     * <p>\n     * A {@code null} or empty iterable returns true.\n     *\n     * @param predicate  the predicate to use, may not be null\n     * @return true if all elements contained in this iterable match the predicate,\n     *   false otherwise\n     * @throws NullPointerException if predicate is null\n     */\n    public boolean allMatch(final Predicate<? super E> predicate) {\n        return IterableUtils.matchesAll(iterable, predicate);\n    }\n\n    /**\n     * Checks if this iterable contains any element matching the provided predicate.\n     * <p>\n     * A {@code null} or empty iterable returns false.\n     *\n     * @param predicate  the predicate to use, may not be null\n     * @return true if at least one element contained in this iterable matches the predicate,\n     *   false otherwise\n     * @throws NullPointerException if predicate is null\n     */\n    public boolean anyMatch(final Predicate<? super E> predicate) {\n        return IterableUtils.matchesAny(iterable, predicate);\n    }\n\n    /**\n     * Returns a new FluentIterable whose iterator will first traverse\n     * the elements of the current iterable, followed by the provided\n     * elements.\n     *\n     * @param elements  the elements to append to the iterable\n     * @return a new iterable, combining this iterable with the elements\n     */\n    public FluentIterable<E> append(final E... elements) {\n        return append(Arrays.asList(elements));\n    }\n\n    /**\n     * Returns a new FluentIterable whose iterator will first traverse\n     * the elements of the current iterable, followed by the elements\n     * of the provided iterable.\n     *\n     * @param other  the other iterable to combine, may not be null\n     * @return a new iterable, combining this iterable with other\n     * @throws NullPointerException if other is null\n     */\n    public FluentIterable<E> append(final Iterable<? extends E> other) {\n        return of(IterableUtils.chainedIterable(iterable, other));\n    }\n\n    /**\n     * Returns an Enumeration that will enumerate all elements contained\n     * in this iterable.\n     *\n     * @return an Enumeration over the elements of this iterable\n     */\n    public Enumeration<E> asEnumeration() {\n        return IteratorUtils.asEnumeration(iterator());\n    }\n\n    /**\n     * Returns a new FluentIterable whose iterator will traverse the\n     * elements of the current and provided iterable in natural order.\n     * <p>\n     * Example: natural ordering\n     * <ul>\n     *   <li>this contains elements [1, 3, 5, 7]\n     *   <li>other contains elements [2, 4, 6, 8]\n     * </ul>\n     * <p>\n     * The returned iterable will traverse the elements in the following\n     * order: [1, 2, 3, 4, 5, 6, 7, 8]\n     *\n     * @param other  the other iterable to collate, may not be null\n     * @return a new iterable, collating this iterable with the other in natural order\n     * @throws NullPointerException if other is null\n     * @see org.apache.commons.collections4.iterators.CollatingIterator\n     */\n    public FluentIterable<E> collate(final Iterable<? extends E> other) {\n        return of(IterableUtils.collatedIterable(iterable, other));\n    }\n\n    /**\n     * Returns a new FluentIterable whose iterator will traverse the\n     * elements of the current and provided iterable according to the\n     * ordering defined by a comparator.\n     * <p>\n     * Example: descending order\n     * <ul>\n     *   <li>this contains elements [7, 5, 3, 1]\n     *   <li>other contains elements [8, 6, 4, 2]\n     * </ul>\n     * <p>\n     * The returned iterable will traverse the elements in the following\n     * order: [8, 7, 6, 5, 4, 3, 2, 1]\n     *\n     * @param comparator  the comparator to define an ordering, may be null,\n     *   in which case natural ordering will be used\n     * @param other  the other iterable to collate, may not be null\n     * @return a new iterable, collating this iterable with the other in natural order\n     * @throws NullPointerException if other is null\n     * @see org.apache.commons.collections4.iterators.CollatingIterator\n     */\n    public FluentIterable<E> collate(final Iterable<? extends E> other,\n                                     final Comparator<? super E> comparator) {\n        return of(IterableUtils.collatedIterable(comparator, iterable, other));\n    }\n\n    /**\n     * Checks if the object is contained in this iterable.\n     *\n     * @param object  the object to check\n     * @return true if the object is contained in this iterable, false otherwise\n     */\n    public boolean contains(final Object object) {\n        return IterableUtils.contains(iterable, object);\n    }\n\n    /**\n     * Traverses an iterator of this iterable and adds all elements\n     * to the provided collection.\n     *\n     * @param collection  the collection to add the elements\n     * @throws NullPointerException if collection is null\n     */\n    public void copyInto(final Collection<? super E> collection) {\n        Objects.requireNonNull(collection, \"collection\");\n        CollectionUtils.addAll(collection, iterable);\n    }\n\n    /**\n     * This method fully traverses an iterator of this iterable and returns\n     * a new iterable with the same contents, but without any reference\n     * to the originating iterables and/or iterators.\n     * <p>\n     * Calling this method is equivalent to:\n     * <pre>\n     *   FluentIterable&lt;E&gt; someIterable = ...;\n     *   FluentIterable.of(someIterable.toList());\n     * </pre>\n     *\n     * @return a new iterable with the same contents as this iterable\n     */\n    public FluentIterable<E> eval() {\n        return of(toList());\n    }\n\n    /**\n     * Returns a new FluentIterable whose iterator will only return\n     * elements from this iterable matching the provided predicate.\n     *\n     * @param predicate  the predicate used to filter elements\n     * @return a new iterable, providing a filtered view of this iterable\n     * @throws NullPointerException if predicate is null\n     */\n    public FluentIterable<E> filter(final Predicate<? super E> predicate) {\n        return of(IterableUtils.filteredIterable(iterable, predicate));\n    }\n\n    /**\n     * Applies the closure to all elements contained in this iterable.\n     *\n     * @param closure  the closure to apply to each element, may not be null\n     * @throws NullPointerException if closure is null\n     */\n    public void forEach(final Closure<? super E> closure) {\n        IterableUtils.forEach(iterable, closure);\n    }\n\n    /**\n     * Returns the element at the provided position in this iterable.\n     * In order to return the element, an iterator needs to be traversed\n     * up to the requested position.\n     *\n     * @param position  the position of the element to return\n     * @return the element\n     * @throws IndexOutOfBoundsException if the provided position is outside the\n     *   valid range of this iterable: [0, size)\n     */\n    public E get(final int position) {\n        return IterableUtils.get(iterable, position);\n    }\n\n    /**\n     * Checks if this iterable is empty.\n     *\n     * @return true if this iterable does not contain any elements, false otherwise\n     */\n    public boolean isEmpty() {\n        return IterableUtils.isEmpty(iterable);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public Iterator<E> iterator() {\n        return iterable.iterator();\n    }\n\n    /**\n     * Returns a new FluentIterable whose iterator will return at most\n     * the provided maximum number of elements from this iterable.\n     *\n     * @param maxSize  the maximum number of elements\n     * @return a new iterable, providing a bounded view of this iterable\n     * @throws IllegalArgumentException if maxSize is negative\n     */\n    public FluentIterable<E> limit(final long maxSize) {\n        return of(IterableUtils.boundedIterable(iterable, maxSize));\n    }\n\n    /**\n     * Returns a new FluentIterable whose iterator will loop infinitely\n     * over the elements from this iterable.\n     *\n     * @return a new iterable, providing a looping view of this iterable\n     */\n    public FluentIterable<E> loop() {\n        return of(IterableUtils.loopingIterable(iterable));\n    }\n\n    /**\n     * Returns a new FluentIterable whose iterator will traverse the\n     * elements from this iterable in reverse order.\n     *\n     * @return a new iterable, providing a reversed view of this iterable\n     */\n    public FluentIterable<E> reverse() {\n        return of(IterableUtils.reversedIterable(iterable));\n    }\n\n    /**\n     * Returns the number of elements that are contained in this iterable.\n     * In order to determine the size, an iterator needs to be traversed.\n     *\n     * @return the size of this iterable\n     */\n    public int size() {\n        return IterableUtils.size(iterable);\n    }\n\n    /**\n     * Returns a new FluentIterable whose iterator will skip the first\n     * N elements from this iterable.\n     *\n     * @param elementsToSkip  the number of elements to skip\n     * @return a new iterable, providing a view of this iterable by skipping\n     *   the first N elements\n     * @throws IllegalArgumentException if elementsToSkip is negative\n     */\n    public FluentIterable<E> skip(final long elementsToSkip) {\n        return of(IterableUtils.skippingIterable(iterable, elementsToSkip));\n    }\n\n    /**\n     * Returns an array containing all elements of this iterable by traversing\n     * its iterator.\n     *\n     * @param arrayClass  the class of array to create\n     * @return an array of the iterable contents\n     * @throws ArrayStoreException if arrayClass is invalid\n     */\n    public E[] toArray(final Class<E> arrayClass) {\n        return IteratorUtils.toArray(iterator(), arrayClass);\n    }\n\n    /**\n     * Returns a mutable list containing all elements of this iterable\n     * by traversing its iterator.\n     * <p>\n     * The returned list is guaranteed to be mutable.\n     *\n     * @return a list of the iterable contents\n     */\n    public List<E> toList() {\n        return IterableUtils.toList(iterable);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public String toString() {\n        return IterableUtils.toString(iterable);\n    }\n\n    /**\n     * Returns a new FluentIterable whose iterator will return all elements\n     * of this iterable transformed by the provided transformer.\n     *\n     * @param <O>  the output element type\n     * @param transformer  the transformer applied to each element\n     * @return a new iterable, providing a transformed view of this iterable\n     * @throws NullPointerException if transformer is null\n     */\n    public <O> FluentIterable<O> transform(final Transformer<? super E, ? extends O> transformer) {\n        return of(IterableUtils.transformedIterable(iterable, transformer));\n    }\n\n    /**\n     * Returns a new FluentIterable whose iterator will return a unique view\n     * of this iterable.\n     *\n     * @return a new iterable, providing a unique view of this iterable\n     */\n    public FluentIterable<E> unique() {\n        return of(IterableUtils.uniqueIterable(iterable));\n    }\n\n    /**\n     * Returns a new FluentIterable whose iterator will return an unmodifiable\n     * view of this iterable.\n     *\n     * @return a new iterable, providing an unmodifiable view of this iterable\n     */\n    public FluentIterable<E> unmodifiable() {\n        return of(IterableUtils.unmodifiableIterable(iterable));\n    }\n\n    /**\n     * Returns a new FluentIterable whose iterator will traverse\n     * the elements of this iterable and the other iterable in\n     * alternating order.\n     *\n     * @param other  the other iterable to interleave, may not be null\n     * @return a new iterable, interleaving this iterable with others\n     * @throws NullPointerException if other is null\n     */\n    public FluentIterable<E> zip(final Iterable<? extends E> other) {\n        return of(IterableUtils.zippingIterable(iterable, other));\n    }\n\n    /**\n     * Returns a new FluentIterable whose iterator will traverse\n     * the elements of this iterable and the other iterables in\n     * alternating order.\n     *\n     * @param others  the iterables to interleave, may not be null\n     * @return a new iterable, interleaving this iterable with others\n     * @throws NullPointerException if either of the provided iterables is null\n     */\n    public FluentIterable<E> zip(final Iterable<? extends E>... others) {\n        return of(IterableUtils.zippingIterable(iterable, others));\n    }\n\n}", "super_interfaces": ["Iterable<E>"], "fields": [{"attribute_expression": "private final Iterable<E> iterable;", "docstring": " A reference to the wrapped iterable.", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Iterable<E>", "name": "iterable", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/TrieUtils.java.TrieUtils", "name": "TrieUtils", "file_path": "src/main/java/org/apache/commons/collections4/TrieUtils.java", "superclasses": "", "methods": ["[Trie<K, V>]unmodifiableTrie(Trie<K, ? extends V>)", "[]TrieUtils()"], "method_uris": ["src/main/java/org/apache/commons/collections4/TrieUtils.java.TrieUtils.[Trie<K, V>]unmodifiableTrie(Trie<K, ? extends V>)", "src/main/java/org/apache/commons/collections4/TrieUtils.java.TrieUtils.[]TrieUtils()"], "overrides": null, "attributes": [], "class_docstring": "\nA collection of {@link Trie} utilities.\n\n@since 4.0\n", "original_string": "public class TrieUtils {\n\n    /**\n     * Returns an unmodifiable instance of a {@link Trie}\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param trie  the trie to make unmodifiable, must not be null\n     * @return an unmodifiable trie backed by the given trie\n     * @throws NullPointerException if trie is null\n     *\n     * @see java.util.Collections#unmodifiableMap(java.util.Map)\n     */\n    public static <K, V> Trie<K, V> unmodifiableTrie(final Trie<K, ? extends V> trie) {\n        return UnmodifiableTrie.unmodifiableTrie(trie);\n    }\n\n    /**\n     * Don't allow instances.\n     */\n    private TrieUtils() {\n        // empty\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/org/apache/commons/collections4/MultiSetUtils.java.MultiSetUtils", "name": "MultiSetUtils", "file_path": "src/main/java/org/apache/commons/collections4/MultiSetUtils.java", "superclasses": "", "methods": ["[MultiSet<E>]emptyMultiSet()", "[MultiSet<E>]predicatedMultiSet(MultiSet<E>,Predicate<? super E>)", "[MultiSet<E>]synchronizedMultiSet(MultiSet<E>)", "[MultiSet<E>]unmodifiableMultiSet(MultiSet<? extends E>)", "[]MultiSetUtils()"], "method_uris": ["src/main/java/org/apache/commons/collections4/MultiSetUtils.java.MultiSetUtils.[MultiSet<E>]emptyMultiSet()", "src/main/java/org/apache/commons/collections4/MultiSetUtils.java.MultiSetUtils.[MultiSet<E>]predicatedMultiSet(MultiSet<E>,Predicate<? super E>)", "src/main/java/org/apache/commons/collections4/MultiSetUtils.java.MultiSetUtils.[MultiSet<E>]synchronizedMultiSet(MultiSet<E>)", "src/main/java/org/apache/commons/collections4/MultiSetUtils.java.MultiSetUtils.[MultiSet<E>]unmodifiableMultiSet(MultiSet<? extends E>)", "src/main/java/org/apache/commons/collections4/MultiSetUtils.java.MultiSetUtils.[]MultiSetUtils()"], "overrides": null, "attributes": [], "class_docstring": "\nProvides utility methods and decorators for {@link MultiSet} instances.\n\n@since 4.1\n", "original_string": "public class MultiSetUtils {\n\n    /**\n     * An empty unmodifiable multiset.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty multiset is compatible with any type\n    public static final MultiSet EMPTY_MULTISET =\n        UnmodifiableMultiSet.unmodifiableMultiSet(new HashMultiSet<>());\n\n    /**\n     * Gets an empty {@code MultiSet}.\n     *\n     * @param <E> the element type\n     * @return an empty MultiSet\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty multiset is compatible with any type\n    public static <E> MultiSet<E> emptyMultiSet() {\n        return EMPTY_MULTISET;\n    }\n\n    /**\n     * Returns a predicated (validating) multiset backed by the given multiset.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the multiset. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original multiset\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     *\n     * @param <E> the element type\n     * @param multiset the multiset to predicate, must not be null\n     * @param predicate the predicate for the multiset, must not be null\n     * @return a predicated multiset backed by the given multiset\n     * @throws NullPointerException if the MultiSet or Predicate is null\n     */\n    public static <E> MultiSet<E> predicatedMultiSet(final MultiSet<E> multiset,\n            final Predicate<? super E> predicate) {\n        return PredicatedMultiSet.predicatedMultiSet(multiset, predicate);\n    }\n\n    /**\n     * Returns a synchronized (thread-safe) multiset backed by the given multiset.\n     * In order to guarantee serial access, it is critical that all access to the\n     * backing multiset is accomplished through the returned multiset.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned multiset\n     * when iterating over it:\n     *\n     * <pre>\n     * MultiSet multiset = MultiSetUtils.synchronizedMultiSet(new HashMultiSet());\n     * ...\n     * synchronized(multiset) {\n     *     Iterator i = multiset.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param multiset the multiset to synchronize, must not be null\n     * @return a synchronized multiset backed by that multiset\n     * @throws NullPointerException if the MultiSet is null\n     */\n    public static <E> MultiSet<E> synchronizedMultiSet(final MultiSet<E> multiset) {\n        return SynchronizedMultiSet.synchronizedMultiSet(multiset);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given multiset. Any modification attempts\n     * to the returned multiset will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param multiset the multiset whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that multiset\n     * @throws NullPointerException if the MultiSet is null\n     */\n    public static <E> MultiSet<E> unmodifiableMultiSet(final MultiSet<? extends E> multiset) {\n        return UnmodifiableMultiSet.unmodifiableMultiSet(multiset);\n    }\n\n    /**\n     * Don't allow instances.\n     */\n    private MultiSetUtils() {\n        // empty\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "@SuppressWarnings(\"rawtypes\") // OK, empty multiset is compatible with any type\n    public static final MultiSet EMPTY_MULTISET =\n        UnmodifiableMultiSet.unmodifiableMultiSet(new HashMultiSet<>());", "docstring": "\nAn empty unmodifiable multiset.\n", "modifiers": "@SuppressWarnings(\"rawtypes\") // OK, empty multiset is compatible with any type\n    public static final", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"rawtypes\")", "public", "static", "final"], "comments": ["// OK, empty multiset is compatible with any type"], "type": "MultiSet", "name": "EMPTY_MULTISET =\n        UnmodifiableMultiSet.unmodifiableMultiSet(new HashMultiSet<>())", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/ArrayUtils.java.ArrayUtils", "name": "ArrayUtils", "file_path": "src/main/java/org/apache/commons/collections4/ArrayUtils.java", "superclasses": "", "methods": ["[boolean]contains(Object[],Object)", "[int]indexOf(Object[],Object,int)", "[int]indexOf(T[],Object)", "[]ArrayUtils()"], "method_uris": ["src/main/java/org/apache/commons/collections4/ArrayUtils.java.ArrayUtils.[boolean]contains(Object[],Object)", "src/main/java/org/apache/commons/collections4/ArrayUtils.java.ArrayUtils.[int]indexOf(Object[],Object,int)", "src/main/java/org/apache/commons/collections4/ArrayUtils.java.ArrayUtils.[int]indexOf(T[],Object)", "src/main/java/org/apache/commons/collections4/ArrayUtils.java.ArrayUtils.[]ArrayUtils()"], "overrides": null, "attributes": [], "class_docstring": "\n<p>\nOperations on arrays, primitive arrays (like {@code int[]}) and primitive wrapper arrays (like {@code Integer[]}).\n</p>\n<p>\nThis class tries to handle {@code null} input gracefully. An exception will not be thrown for a {@code null} array input. However, an Object array that\ncontains a {@code null} element may throw an exception. Each method documents its behavior.\n</p>\n<p>\nPackage private, might move to an internal package if this needs to be public.\n</p>\n<p>\n#ThreadSafe#\n</p>\n\n@since 4.2 (Copied from Apache Commons Lang.)\n", "original_string": "final class ArrayUtils {\n\n    /**\n     * <p>\n     * Checks if the object is in the given array.\n     * </p>\n     * <p>\n     * The method returns {@code false} if a {@code null} array is passed in.\n     * </p>\n     *\n     * @param array        the array to search through\n     * @param objectToFind the object to find\n     * @return {@code true} if the array contains the object\n     */\n    static boolean contains(final Object[] array, final Object objectToFind) {\n        return indexOf(array, objectToFind) != CollectionUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>\n     * Finds the index of the given object in the array starting at the given index.\n     * </p>\n     * <p>\n     * This method returns {@link CollectionUtils#INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.\n     * </p>\n     * <p>\n     * A negative startIndex is treated as zero. A startIndex larger than the array length will return {@link CollectionUtils#INDEX_NOT_FOUND} ({@code -1}).\n     * </p>\n     *\n     * @param array        the array to search through for the object, may be {@code null}\n     * @param objectToFind the object to find, may be {@code null}\n     * @param startIndex   the index to start searching at\n     * @return the index of the object within the array starting at the index, {@link CollectionUtils#INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null}\n     *         array input\n     */\n    static int indexOf(final Object[] array, final Object objectToFind, int startIndex) {\n        if (array == null) {\n            return CollectionUtils.INDEX_NOT_FOUND;\n        }\n        if (startIndex < 0) {\n            startIndex = 0;\n        }\n        if (objectToFind == null) {\n            for (int i = startIndex; i < array.length; i++) {\n                if (array[i] == null) {\n                    return i;\n                }\n            }\n        } else {\n            for (int i = startIndex; i < array.length; i++) {\n                if (objectToFind.equals(array[i])) {\n                    return i;\n                }\n            }\n        }\n        return CollectionUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * <p>\n     * Finds the index of the given object in the array.\n     * </p>\n     * <p>\n     * This method returns {@link CollectionUtils#INDEX_NOT_FOUND} ({@code -1}) for a {@code null} input array.\n     * </p>\n     *\n     * @param array        the array to search through for the object, may be {@code null}\n     * @param objectToFind the object to find, may be {@code null}\n     * @return the index of the object within the array, {@link CollectionUtils#INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input\n     */\n    static <T> int indexOf(final T[] array, final Object objectToFind) {\n        return indexOf(array, objectToFind, 0);\n    }\n\n    /**\n     * Don't allow instances.\n     */\n    private ArrayUtils() {\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/org/apache/commons/collections4/TransformerUtils.java.TransformerUtils", "name": "TransformerUtils", "file_path": "src/main/java/org/apache/commons/collections4/TransformerUtils.java", "superclasses": "", "methods": ["[Transformer<T, T>]asTransformer(Closure<? super T>)", "[Transformer<I, O>]asTransformer(Factory<? extends O>)", "[Transformer<T, Boolean>]asTransformer(Predicate<? super T>)", "[Transformer<T, T>]chainedTransformer(Collection<? extends Transformer<? super T, ? extends T>>)", "[Transformer<T, T>]chainedTransformer()", "[Transformer<T, T>]cloneTransformer()", "[Transformer<I, O>]constantTransformer(O)", "[Transformer<I, O>]exceptionTransformer()", "[Transformer<I, O>]ifTransformer(Predicate<? super I>,Transformer<? super I, ? extends O>,Transformer<? super I, ? extends O>)", "[Transformer<T, T>]ifTransformer(Predicate<? super T>,Transformer<? super T, ? extends T>)", "[Transformer<Class<? extends T>, T>]instantiateTransformer()", "[Transformer<Class<? extends T>, T>]instantiateTransformer(Class<?>[],Object[])", "[Transformer<I, O>]invokerTransformer(String)", "[Transformer<I, O>]invokerTransformer(String,Class<?>[],Object[])", "[Transformer<I, O>]mapTransformer(Map<? super I, ? extends O>)", "[Transformer<T, T>]nopTransformer()", "[Transformer<I, O>]nullTransformer()", "[Transformer<T, String>]stringValueTransformer()", "[Transformer<I, O>]switchMapTransformer(Map<I, Transformer<I, O>>)", "[Transformer<I, O>]switchTransformer(Map<Predicate<I>, Transformer<I, O>>)", "[Transformer<I, O>]switchTransformer(Predicate<? super I>,Transformer<? super I, ? extends O>,Transformer<? super I, ? extends O>)", "[Transformer<I, O>]switchTransformer(Predicate<? super I>[],Transformer<? super I, ? extends O>[])", "[Transformer<I, O>]switchTransformer(Predicate<? super I>[],Transformer<? super I, ? extends O>[],Transformer<? super I, ? extends O>)", "[]TransformerUtils()"], "method_uris": ["src/main/java/org/apache/commons/collections4/TransformerUtils.java.TransformerUtils.[Transformer<T, T>]asTransformer(Closure<? super T>)", "src/main/java/org/apache/commons/collections4/TransformerUtils.java.TransformerUtils.[Transformer<I, O>]asTransformer(Factory<? extends O>)", "src/main/java/org/apache/commons/collections4/TransformerUtils.java.TransformerUtils.[Transformer<T, Boolean>]asTransformer(Predicate<? super T>)", "src/main/java/org/apache/commons/collections4/TransformerUtils.java.TransformerUtils.[Transformer<T, T>]chainedTransformer(Collection<? extends Transformer<? super T, ? extends T>>)", "src/main/java/org/apache/commons/collections4/TransformerUtils.java.TransformerUtils.[Transformer<T, T>]chainedTransformer()", "src/main/java/org/apache/commons/collections4/TransformerUtils.java.TransformerUtils.[Transformer<T, T>]cloneTransformer()", "src/main/java/org/apache/commons/collections4/TransformerUtils.java.TransformerUtils.[Transformer<I, O>]constantTransformer(O)", "src/main/java/org/apache/commons/collections4/TransformerUtils.java.TransformerUtils.[Transformer<I, O>]exceptionTransformer()", "src/main/java/org/apache/commons/collections4/TransformerUtils.java.TransformerUtils.[Transformer<I, O>]ifTransformer(Predicate<? super I>,Transformer<? super I, ? extends O>,Transformer<? super I, ? extends O>)", "src/main/java/org/apache/commons/collections4/TransformerUtils.java.TransformerUtils.[Transformer<T, T>]ifTransformer(Predicate<? super T>,Transformer<? super T, ? extends T>)", "src/main/java/org/apache/commons/collections4/TransformerUtils.java.TransformerUtils.[Transformer<Class<? extends T>, T>]instantiateTransformer()", "src/main/java/org/apache/commons/collections4/TransformerUtils.java.TransformerUtils.[Transformer<Class<? extends T>, T>]instantiateTransformer(Class<?>[],Object[])", "src/main/java/org/apache/commons/collections4/TransformerUtils.java.TransformerUtils.[Transformer<I, O>]invokerTransformer(String)", "src/main/java/org/apache/commons/collections4/TransformerUtils.java.TransformerUtils.[Transformer<I, O>]invokerTransformer(String,Class<?>[],Object[])", "src/main/java/org/apache/commons/collections4/TransformerUtils.java.TransformerUtils.[Transformer<I, O>]mapTransformer(Map<? super I, ? extends O>)", "src/main/java/org/apache/commons/collections4/TransformerUtils.java.TransformerUtils.[Transformer<T, T>]nopTransformer()", "src/main/java/org/apache/commons/collections4/TransformerUtils.java.TransformerUtils.[Transformer<I, O>]nullTransformer()", "src/main/java/org/apache/commons/collections4/TransformerUtils.java.TransformerUtils.[Transformer<T, String>]stringValueTransformer()", "src/main/java/org/apache/commons/collections4/TransformerUtils.java.TransformerUtils.[Transformer<I, O>]switchMapTransformer(Map<I, Transformer<I, O>>)", "src/main/java/org/apache/commons/collections4/TransformerUtils.java.TransformerUtils.[Transformer<I, O>]switchTransformer(Map<Predicate<I>, Transformer<I, O>>)", "src/main/java/org/apache/commons/collections4/TransformerUtils.java.TransformerUtils.[Transformer<I, O>]switchTransformer(Predicate<? super I>,Transformer<? super I, ? extends O>,Transformer<? super I, ? extends O>)", "src/main/java/org/apache/commons/collections4/TransformerUtils.java.TransformerUtils.[Transformer<I, O>]switchTransformer(Predicate<? super I>[],Transformer<? super I, ? extends O>[])", "src/main/java/org/apache/commons/collections4/TransformerUtils.java.TransformerUtils.[Transformer<I, O>]switchTransformer(Predicate<? super I>[],Transformer<? super I, ? extends O>[],Transformer<? super I, ? extends O>)", "src/main/java/org/apache/commons/collections4/TransformerUtils.java.TransformerUtils.[]TransformerUtils()"], "overrides": null, "attributes": [], "class_docstring": "\n{@code TransformerUtils} provides reference implementations and\nutilities for the Transformer functor interface. The supplied transformers are:\n<ul>\n<li>Invoker - returns the result of a method call on the input object\n<li>Clone - returns a clone of the input object\n<li>Constant - always returns the same object\n<li>Closure - performs a Closure and returns the input object\n<li>Predicate - returns the result of the predicate as a Boolean\n<li>Factory - returns a new object from a factory\n<li>Chained - chains two or more transformers together\n<li>If - calls one transformer or another based on a predicate\n<li>Switch - calls one transformer based on one or more predicates\n<li>SwitchMap - calls one transformer looked up from a Map\n<li>Instantiate - the Class input object is instantiated\n<li>Map - returns an object from a supplied Map\n<li>Null - always returns null\n<li>NOP - returns the input object, which should be immutable\n<li>Exception - always throws an exception\n<li>StringValue - returns a {@link String} representation of the input object\n</ul>\n<p>\nSince v4.1 only transformers which are considered to be safe are\nSerializable. Transformers considered to be unsafe for serialization are:\n</p>\n<ul>\n<li>Invoker\n<li>Clone\n<li>Instantiate\n</ul>\n\n@since 3.0\n", "original_string": "public class TransformerUtils {\n\n    /**\n     * Creates a Transformer that calls a Closure each time the transformer is used.\n     * The transformer returns the input object.\n     *\n     * @param <T>  the input/output type\n     * @param closure  the closure to run each time in the transformer, not null\n     * @return the transformer\n     * @throws NullPointerException if the closure is null\n     * @see ClosureTransformer\n     */\n    public static <T> Transformer<T, T> asTransformer(final Closure<? super T> closure) {\n        return ClosureTransformer.closureTransformer(closure);\n    }\n\n    /**\n     * Creates a Transformer that calls a Factory each time the transformer is used.\n     * The transformer will return the value returned by the factory.\n     *\n     * @param <I>  the input type\n     * @param <O>  the output type\n     * @param factory  the factory to run each time in the transformer, not null\n     * @return the transformer\n     * @throws NullPointerException if the factory is null\n     * @see FactoryTransformer\n     */\n    public static <I, O> Transformer<I, O> asTransformer(final Factory<? extends O> factory) {\n        return FactoryTransformer.factoryTransformer(factory);\n    }\n\n    /**\n     * Creates a Transformer that calls a Predicate each time the transformer is used.\n     * The transformer will return either {@link Boolean#TRUE} or {@link Boolean#FALSE}.\n     *\n     * @param <T>  the input type\n     * @param predicate  the predicate to run each time in the transformer, not null\n     * @return the transformer\n     * @throws NullPointerException if the predicate is null\n     * @see PredicateTransformer\n     */\n    public static <T> Transformer<T, Boolean> asTransformer(final Predicate<? super T> predicate) {\n        return PredicateTransformer.predicateTransformer(predicate);\n    }\n\n    /**\n     * Create a new Transformer that calls each transformer in turn, passing the\n     * result into the next transformer. The ordering is that of the iterator()\n     * method on the collection.\n     *\n     * @param <T>  the input/output type\n     * @param transformers  a collection of transformers to chain\n     * @return the transformer\n     * @throws NullPointerException if the transformers collection or any of the transformers is null\n     * @see ChainedTransformer\n     */\n    public static <T> Transformer<T, T> chainedTransformer(\n            final Collection<? extends Transformer<? super T, ? extends T>> transformers) {\n        return ChainedTransformer.chainedTransformer(transformers);\n    }\n\n    /**\n     * Create a new Transformer that calls each transformer in turn, passing the\n     * result into the next transformer.\n     *\n     * @param <T>  the input/output type\n     * @param transformers  an array of transformers to chain\n     * @return the transformer\n     * @throws NullPointerException if the transformers array or any of the transformers is null\n     * @see ChainedTransformer\n     */\n    public static <T> Transformer<T, T> chainedTransformer(\n            final Transformer<? super T, ? extends T>... transformers) {\n        return ChainedTransformer.chainedTransformer(transformers);\n    }\n\n    /**\n     * Gets a transformer that returns a clone of the input object.\n     * The input object will be cloned using one of these techniques (in order):\n     * <ul>\n     * <li>public clone method</li>\n     * <li>public copy constructor</li>\n     * <li>serialization clone</li>\n     * </ul>\n     *\n     * @param <T>  the input/output type\n     * @return the transformer\n     * @see CloneTransformer\n     */\n    public static <T> Transformer<T, T> cloneTransformer() {\n        return CloneTransformer.cloneTransformer();\n    }\n\n    /**\n     * Creates a Transformer that will return the same object each time the\n     * transformer is used.\n     *\n     * @param <I>  the input type\n     * @param <O>  the output type\n     * @param constantToReturn  the constant object to return each time in the transformer\n     * @return the transformer.\n     * @see ConstantTransformer\n     */\n    public static <I, O> Transformer<I, O> constantTransformer(final O constantToReturn) {\n        return ConstantTransformer.constantTransformer(constantToReturn);\n    }\n\n    /**\n     * Gets a transformer that always throws an exception.\n     * This could be useful during testing as a placeholder.\n     *\n     * @param <I>  the input type\n     * @param <O>  the output type\n     * @return the transformer\n     * @see ExceptionTransformer\n     */\n    public static <I, O> Transformer<I, O> exceptionTransformer() {\n        return ExceptionTransformer.exceptionTransformer();\n    }\n\n    /**\n     * Create a new Transformer that calls one of two transformers depending\n     * on the specified predicate.\n     *\n     * @param <I>  the input type\n     * @param <O>  the output type\n     * @param predicate  the predicate to switch on\n     * @param trueTransformer  the transformer called if the predicate is true\n     * @param falseTransformer  the transformer called if the predicate is false\n     * @return the transformer\n     * @throws NullPointerException if either the predicate or transformer is null\n     * @see IfTransformer\n     * @since 4.1\n     */\n    public static <I, O> Transformer<I, O> ifTransformer(final Predicate<? super I> predicate,\n                                                         final Transformer<? super I, ? extends O> trueTransformer,\n                                                         final Transformer<? super I, ? extends O> falseTransformer) {\n        return IfTransformer.ifTransformer(predicate, trueTransformer, falseTransformer);\n    }\n\n    /**\n     * Create a new Transformer that calls the transformer if the predicate is true,\n     * otherwise the input object is returned unchanged.\n     *\n     * @param <T>  the input / output type\n     * @param predicate  the predicate to switch on\n     * @param trueTransformer  the transformer called if the predicate is true\n     * @return the transformer\n     * @throws NullPointerException if either the predicate or transformer is null\n     * @see IfTransformer\n     * @since 4.1\n     */\n    public static <T> Transformer<T, T> ifTransformer(final Predicate<? super T> predicate,\n                                                      final Transformer<? super T, ? extends T> trueTransformer) {\n        return IfTransformer.ifTransformer(predicate, trueTransformer);\n    }\n\n    /**\n     * Gets a Transformer that expects an input Class object that it will instantiate.\n     *\n     * @param <T>  the output type\n     * @return the transformer\n     * @see InstantiateTransformer\n     */\n    public static <T> Transformer<Class<? extends T>, T> instantiateTransformer() {\n        return InstantiateTransformer.instantiateTransformer();\n    }\n\n    /**\n     * Creates a Transformer that expects an input Class object that it will\n     * instantiate. The constructor used is determined by the arguments specified\n     * to this method.\n     *\n     * @param <T>  the output type\n     * @param paramTypes  parameter types for the constructor, can be null\n     * @param args  the arguments to pass to the constructor, can be null\n     * @return the transformer\n     * @throws IllegalArgumentException if the paramTypes and args don't match\n     * @see InstantiateTransformer\n     */\n    public static <T> Transformer<Class<? extends T>, T> instantiateTransformer(\n            final Class<?>[] paramTypes, final Object[] args) {\n        return InstantiateTransformer.instantiateTransformer(paramTypes, args);\n    }\n\n    /**\n     * Gets a Transformer that invokes a method on the input object.\n     * The method must have no parameters. If the input object is {@code null},\n     * {@code null} is returned.\n     *\n     * <p>\n     * For example, {@code TransformerUtils.invokerTransformer(\"getName\");}\n     * will call the {@code getName} method on the input object to\n     * determine the transformer result.\n     * </p>\n     *\n     * @param <I>  the input type\n     * @param <O>  the output type\n     * @param methodName  the method name to call on the input object, may not be null\n     * @return the transformer\n     * @throws NullPointerException if the methodName is null.\n     * @see InvokerTransformer\n     */\n    public static <I, O> Transformer<I, O> invokerTransformer(final String methodName) {\n        return InvokerTransformer.invokerTransformer(methodName, null, null);\n    }\n\n    /**\n     * Gets a Transformer that invokes a method on the input object.\n     * The method parameters are specified. If the input object is {@code null},\n     * {@code null} is returned.\n     *\n     * @param <I>  the input type\n     * @param <O>  the output type\n     * @param methodName  the name of the method\n     * @param paramTypes  the parameter types\n     * @param args  the arguments\n     * @return the transformer\n     * @throws NullPointerException if the method name is null\n     * @throws IllegalArgumentException if the paramTypes and args don't match\n     * @see InvokerTransformer\n     */\n    public static <I, O> Transformer<I, O> invokerTransformer(final String methodName, final Class<?>[] paramTypes,\n                                                              final Object[] args) {\n        return InvokerTransformer.invokerTransformer(methodName, paramTypes, args);\n    }\n\n    /**\n     * Creates a Transformer that uses the passed in Map to transform the input\n     * object (as a simple lookup).\n     *\n     * @param <I>  the input type\n     * @param <O>  the output type\n     * @param map  the map to use to transform the objects\n     * @return the transformer, or {@link ConstantTransformer#nullTransformer()} if the\n     *   {@code map} is {@code null}\n     * @see MapTransformer\n     */\n    public static <I, O> Transformer<I, O> mapTransformer(final Map<? super I, ? extends O> map) {\n        return MapTransformer.mapTransformer(map);\n    }\n\n    /**\n     * Gets a transformer that returns the input object.\n     * The input object should be immutable to maintain the\n     * contract of Transformer (although this is not checked).\n     *\n     * @param <T>  the input/output type\n     * @return the transformer\n     * @see NOPTransformer\n     */\n    public static <T> Transformer<T, T> nopTransformer() {\n        return NOPTransformer.nopTransformer();\n    }\n\n    /**\n     * Gets a transformer that always returns null.\n     *\n     * @param <I>  the input type\n     * @param <O>  the output type\n     * @return the transformer\n     * @see ConstantTransformer\n     */\n    public static <I, O> Transformer<I, O> nullTransformer() {\n        return ConstantTransformer.nullTransformer();\n    }\n\n    /**\n     * Gets a transformer that returns a {@link String}\n     * representation of the input object. This is achieved via the\n     * {@code toString} method, {@code null} returns 'null'.\n     *\n     * @param <T>  the input type\n     * @return the transformer\n     * @see StringValueTransformer\n     */\n    public static <T> Transformer<T, String> stringValueTransformer() {\n        return StringValueTransformer.stringValueTransformer();\n    }\n\n    /**\n     * Create a new Transformer that uses the input object as a key to find the\n     * transformer to call.\n     * <p>\n     * The Map consists of object keys and Transformer values. A transformer\n     * is called if the input object equals the key. If there is no match, the\n     * default transformer is called. The default transformer is set in the map\n     * using a null key. If no default is set, null will be returned in a default case.\n     *\n     * @param <I>  the input type\n     * @param <O>  the output type\n     * @param objectsAndTransformers  a map of objects to transformers\n     * @return the transformer\n     * @throws NullPointerException if the map is null\n     * @throws NullPointerException if any transformer in the map is null\n     * @see SwitchTransformer\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static <I, O> Transformer<I, O> switchMapTransformer(\n            final Map<I, Transformer<I, O>> objectsAndTransformers) {\n\n        Objects.requireNonNull(objectsAndTransformers, \"objectsAndTransformers\");\n        final Transformer<? super I, ? extends O> def = objectsAndTransformers.remove(null);\n        final int size = objectsAndTransformers.size();\n        final Transformer<? super I, ? extends O>[] trs = new Transformer[size];\n        final Predicate<I>[] preds = new Predicate[size];\n        int i = 0;\n        for (final Map.Entry<I, Transformer<I, O>> entry : objectsAndTransformers.entrySet()) {\n            preds[i] = EqualPredicate.<I>equalPredicate(entry.getKey());\n            trs[i++] = entry.getValue();\n        }\n        return switchTransformer(preds, trs, def);\n    }\n\n    /**\n     * Create a new Transformer that calls one of the transformers depending\n     * on the predicates.\n     * <p>\n     * The Map consists of Predicate keys and Transformer values. A transformer\n     * is called if its matching predicate returns true. Each predicate is evaluated\n     * until one returns true. If no predicates evaluate to true, the default\n     * transformer is called. The default transformer is set in the map with a\n     * null key. If no default transformer is set, null will be returned in a default\n     * case. The ordering is that of the iterator() method on the entryset collection\n     * of the map.\n     *\n     * @param <I>  the input type\n     * @param <O>  the output type\n     * @param predicatesAndTransformers  a map of predicates to transformers\n     * @return the transformer\n     * @throws NullPointerException if the map is null\n     * @throws NullPointerException if any transformer in the map is null\n     * @throws ClassCastException  if the map elements are of the wrong type\n     * @see SwitchTransformer\n     */\n    public static <I, O> Transformer<I, O> switchTransformer(\n            final Map<Predicate<I>, Transformer<I, O>> predicatesAndTransformers) {\n        return SwitchTransformer.switchTransformer(predicatesAndTransformers);\n    }\n\n    /**\n     * Create a new Transformer that calls one of two transformers depending\n     * on the specified predicate.\n     *\n     * @param <I>  the input type\n     * @param <O>  the output type\n     * @param predicate  the predicate to switch on\n     * @param trueTransformer  the transformer called if the predicate is true\n     * @param falseTransformer  the transformer called if the predicate is false\n     * @return the transformer\n     * @throws NullPointerException if either the predicate or transformer is null\n     * @see SwitchTransformer\n     * @deprecated as of 4.1, use {@link #ifTransformer(Predicate, Transformer, Transformer)}\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Deprecated\n    public static <I, O> Transformer<I, O> switchTransformer(final Predicate<? super I> predicate,\n            final Transformer<? super I, ? extends O> trueTransformer,\n            final Transformer<? super I, ? extends O> falseTransformer) {\n        return SwitchTransformer.switchTransformer(new Predicate[] { predicate },\n                                                   new Transformer[] { trueTransformer }, falseTransformer);\n    }\n\n    /**\n     * Create a new Transformer that calls one of the transformers depending\n     * on the predicates. The transformer at array location 0 is called if the\n     * predicate at array location 0 returned true. Each predicate is evaluated\n     * until one returns true. If no predicates evaluate to true, null is returned.\n     *\n     * @param <I>  the input type\n     * @param <O>  the output type\n     * @param predicates  an array of predicates to check\n     * @param transformers  an array of transformers to call\n     * @return the transformer\n     * @throws NullPointerException if either array is null\n     * @throws NullPointerException if any element in the arrays is null\n     * @throws IllegalArgumentException if the arrays have different sizes\n     * @see SwitchTransformer\n     */\n    public static <I, O> Transformer<I, O> switchTransformer(final Predicate<? super I>[] predicates,\n            final Transformer<? super I, ? extends O>[] transformers) {\n        return SwitchTransformer.switchTransformer(predicates, transformers, null);\n    }\n\n    /**\n     * Create a new Transformer that calls one of the transformers depending\n     * on the predicates. The transformer at array location 0 is called if the\n     * predicate at array location 0 returned true. Each predicate is evaluated\n     * until one returns true. If no predicates evaluate to true, the default\n     * transformer is called. If the default transformer is null, null is returned.\n     *\n     * @param <I>  the input type\n     * @param <O>  the output type\n     * @param predicates  an array of predicates to check\n     * @param transformers  an array of transformers to call\n     * @param defaultTransformer  the default to call if no predicate matches, null means return null\n     * @return the transformer\n     * @throws NullPointerException if either array is null\n     * @throws NullPointerException if any element in the arrays is null\n     * @throws IllegalArgumentException if the arrays have different sizes\n     * @see SwitchTransformer\n     */\n    public static <I, O> Transformer<I, O> switchTransformer(final Predicate<? super I>[] predicates,\n            final Transformer<? super I, ? extends O>[] transformers,\n            final Transformer<? super I, ? extends O> defaultTransformer) {\n        return SwitchTransformer.switchTransformer(predicates, transformers, defaultTransformer);\n    }\n\n    /**\n     * This class is not normally instantiated.\n     */\n    private TransformerUtils() {\n        // empty\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/org/apache/commons/collections4/SetUtils.java.SetUtils", "name": "SetUtils", "file_path": "src/main/java/org/apache/commons/collections4/SetUtils.java", "superclasses": "", "methods": ["[SetView<E>]difference(Set<? extends E>,Set<? extends E>)", "[SetView<E>]disjunction(Set<? extends E>,Set<? extends E>)", "[Set<T>]emptyIfNull(Set<T>)", "[Set<E>]emptySet()", "[SortedSet<E>]emptySortedSet()", "[int]hashCodeForSet(Collection<T>)", "[HashSet<E>]hashSet()", "[SetView<E>]intersection(Set<? extends E>,Set<? extends E>)", "[boolean]isEqualSet(Collection<?>,Collection<?>)", "[Set<E>]newIdentityHashSet()", "[Set<E>]orderedSet(Set<E>)", "[SortedSet<E>]predicatedNavigableSet(NavigableSet<E>,Predicate<? super E>)", "[Set<E>]predicatedSet(Set<E>,Predicate<? super E>)", "[SortedSet<E>]predicatedSortedSet(SortedSet<E>,Predicate<? super E>)", "[Set<E>]synchronizedSet(Set<E>)", "[SortedSet<E>]synchronizedSortedSet(SortedSet<E>)", "[SortedSet<E>]transformedNavigableSet(NavigableSet<E>,Transformer<? super E, ? extends E>)", "[Set<E>]transformedSet(Set<E>,Transformer<? super E, ? extends E>)", "[SortedSet<E>]transformedSortedSet(SortedSet<E>,Transformer<? super E, ? extends E>)", "[SetView<E>]union(Set<? extends E>,Set<? extends E>)", "[SortedSet<E>]unmodifiableNavigableSet(NavigableSet<E>)", "[Set<E>]unmodifiableSet()", "[Set<E>]unmodifiableSet(Set<? extends E>)", "[SortedSet<E>]unmodifiableSortedSet(SortedSet<E>)", "[]SetUtils()"], "method_uris": ["src/main/java/org/apache/commons/collections4/SetUtils.java.SetUtils.[SetView<E>]difference(Set<? extends E>,Set<? extends E>)", "src/main/java/org/apache/commons/collections4/SetUtils.java.SetUtils.[SetView<E>]disjunction(Set<? extends E>,Set<? extends E>)", "src/main/java/org/apache/commons/collections4/SetUtils.java.SetUtils.[Set<T>]emptyIfNull(Set<T>)", "src/main/java/org/apache/commons/collections4/SetUtils.java.SetUtils.[Set<E>]emptySet()", "src/main/java/org/apache/commons/collections4/SetUtils.java.SetUtils.[SortedSet<E>]emptySortedSet()", "src/main/java/org/apache/commons/collections4/SetUtils.java.SetUtils.[int]hashCodeForSet(Collection<T>)", "src/main/java/org/apache/commons/collections4/SetUtils.java.SetUtils.[HashSet<E>]hashSet()", "src/main/java/org/apache/commons/collections4/SetUtils.java.SetUtils.[SetView<E>]intersection(Set<? extends E>,Set<? extends E>)", "src/main/java/org/apache/commons/collections4/SetUtils.java.SetUtils.[boolean]isEqualSet(Collection<?>,Collection<?>)", "src/main/java/org/apache/commons/collections4/SetUtils.java.SetUtils.[Set<E>]newIdentityHashSet()", "src/main/java/org/apache/commons/collections4/SetUtils.java.SetUtils.[Set<E>]orderedSet(Set<E>)", "src/main/java/org/apache/commons/collections4/SetUtils.java.SetUtils.[SortedSet<E>]predicatedNavigableSet(NavigableSet<E>,Predicate<? super E>)", "src/main/java/org/apache/commons/collections4/SetUtils.java.SetUtils.[Set<E>]predicatedSet(Set<E>,Predicate<? super E>)", "src/main/java/org/apache/commons/collections4/SetUtils.java.SetUtils.[SortedSet<E>]predicatedSortedSet(SortedSet<E>,Predicate<? super E>)", "src/main/java/org/apache/commons/collections4/SetUtils.java.SetUtils.[Set<E>]synchronizedSet(Set<E>)", "src/main/java/org/apache/commons/collections4/SetUtils.java.SetUtils.[SortedSet<E>]synchronizedSortedSet(SortedSet<E>)", "src/main/java/org/apache/commons/collections4/SetUtils.java.SetUtils.[SortedSet<E>]transformedNavigableSet(NavigableSet<E>,Transformer<? super E, ? extends E>)", "src/main/java/org/apache/commons/collections4/SetUtils.java.SetUtils.[Set<E>]transformedSet(Set<E>,Transformer<? super E, ? extends E>)", "src/main/java/org/apache/commons/collections4/SetUtils.java.SetUtils.[SortedSet<E>]transformedSortedSet(SortedSet<E>,Transformer<? super E, ? extends E>)", "src/main/java/org/apache/commons/collections4/SetUtils.java.SetUtils.[SetView<E>]union(Set<? extends E>,Set<? extends E>)", "src/main/java/org/apache/commons/collections4/SetUtils.java.SetUtils.[SortedSet<E>]unmodifiableNavigableSet(NavigableSet<E>)", "src/main/java/org/apache/commons/collections4/SetUtils.java.SetUtils.[Set<E>]unmodifiableSet()", "src/main/java/org/apache/commons/collections4/SetUtils.java.SetUtils.[Set<E>]unmodifiableSet(Set<? extends E>)", "src/main/java/org/apache/commons/collections4/SetUtils.java.SetUtils.[SortedSet<E>]unmodifiableSortedSet(SortedSet<E>)", "src/main/java/org/apache/commons/collections4/SetUtils.java.SetUtils.[]SetUtils()"], "overrides": null, "attributes": [{"original_string": "    public abstract static class SetView<E> extends AbstractSet<E> {\n\n        /**\n         * Copies the contents of this view into the provided set.\n         *\n         * @param <S> the set type\n         * @param set  the set for copying the contents\n         */\n        public <S extends Set<E>> void copyInto(final S set) {\n            CollectionUtils.addAll(set, this);\n        }\n\n        /**\n         * Return an iterator for this view; the returned iterator is\n         * not required to be unmodifiable.\n         * @return a new iterator for this view\n         */\n        protected abstract Iterator<E> createIterator();\n\n        @Override\n        public Iterator<E> iterator() {\n            return IteratorUtils.unmodifiableIterator(createIterator());\n        }\n\n        @Override\n        public int size() {\n            return IteratorUtils.size(iterator());\n        }\n\n        /**\n         * Returns a new set containing the contents of this view.\n         *\n         * @return a new set containing all elements of this view\n         */\n        public Set<E> toSet() {\n            final Set<E> set = new HashSet<>(size());\n            copyInto(set);\n            return set;\n        }\n    }", "definition": "    public abstract static class SetView<E> extends AbstractSet<E>", "class_docstring": "\nAn unmodifiable <b>view</b> of a set that may be backed by other sets.\n<p>\nIf the decorated sets change, this view will change as well. The contents\nof this view can be transferred to another instance via the {@link #copyInto(Set)}\nand {@link #toSet()} methods.\n\n@param <E> the element type\n@since 4.1\n", "name": "SetView", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public abstract static", "marker_annotations": [], "non_marker_annotations": ["public", "abstract", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public <S extends Set<E>> void copyInto(final S set) {\n            CollectionUtils.addAll(set, this);\n        }", "docstring": "\nCopies the contents of this view into the provided set.\n\n@param <S> the set type\n@param set  the set for copying the contents\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "copyInto", "params": [{"name": "set", "type": "S"}], "body": "                                                             {\n            CollectionUtils.addAll(set, this);\n        }", "signature": "public <S extends Set<E>> void copyInto(final S set)"}, {"syntax_pass": true, "original_string": "        protected abstract Iterator<E> createIterator();", "docstring": "\nReturn an iterator for this view; the returned iterator is\nnot required to be unmodifiable.\n@return a new iterator for this view\n", "attributes": {"modifiers": "protected abstract", "marker_annotations": [], "non_marker_annotations": ["protected", "abstract"], "comments": [], "return_type": "Iterator<E>", "classes": []}, "name": "createIterator", "params": [], "body": "", "signature": "protected abstract Iterator<E> createIterator()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Iterator<E> iterator() {\n            return IteratorUtils.unmodifiableIterator(createIterator());\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Iterator<E>", "classes": []}, "name": "iterator", "params": [], "body": "                                      {\n            return IteratorUtils.unmodifiableIterator(createIterator());\n        }", "signature": "@Override\n        public Iterator<E> iterator()"}, {"syntax_pass": true, "original_string": "        @Override\n        public int size() {\n            return IteratorUtils.size(iterator());\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "size", "params": [], "body": "                          {\n            return IteratorUtils.size(iterator());\n        }", "signature": "@Override\n        public int size()"}, {"syntax_pass": true, "original_string": "        public Set<E> toSet() {\n            final Set<E> set = new HashSet<>(size());\n            copyInto(set);\n            return set;\n        }", "docstring": "\nReturns a new set containing the contents of this view.\n\n@return a new set containing all elements of this view\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Set<E>", "classes": []}, "name": "toSet", "params": [], "body": "                              {\n            final Set<E> set = new HashSet<>(size());\n            copyInto(set);\n            return set;\n        }", "signature": "public Set<E> toSet()"}]}], "class_docstring": "\nProvides utility methods and decorators for\n{@link Set} and {@link SortedSet} instances.\n\n@since 2.1\n", "original_string": "public class SetUtils {\n\n    /**\n     * An unmodifiable <b>view</b> of a set that may be backed by other sets.\n     * <p>\n     * If the decorated sets change, this view will change as well. The contents\n     * of this view can be transferred to another instance via the {@link #copyInto(Set)}\n     * and {@link #toSet()} methods.\n     *\n     * @param <E> the element type\n     * @since 4.1\n     */\n    public abstract static class SetView<E> extends AbstractSet<E> {\n\n        /**\n         * Copies the contents of this view into the provided set.\n         *\n         * @param <S> the set type\n         * @param set  the set for copying the contents\n         */\n        public <S extends Set<E>> void copyInto(final S set) {\n            CollectionUtils.addAll(set, this);\n        }\n\n        /**\n         * Return an iterator for this view; the returned iterator is\n         * not required to be unmodifiable.\n         * @return a new iterator for this view\n         */\n        protected abstract Iterator<E> createIterator();\n\n        @Override\n        public Iterator<E> iterator() {\n            return IteratorUtils.unmodifiableIterator(createIterator());\n        }\n\n        @Override\n        public int size() {\n            return IteratorUtils.size(iterator());\n        }\n\n        /**\n         * Returns a new set containing the contents of this view.\n         *\n         * @return a new set containing all elements of this view\n         */\n        public Set<E> toSet() {\n            final Set<E> set = new HashSet<>(size());\n            copyInto(set);\n            return set;\n        }\n    }\n\n    /**\n     * An empty unmodifiable sorted set.\n     * This is not provided in the JDK.\n     */\n    @SuppressWarnings(\"rawtypes\")\n    public static final SortedSet EMPTY_SORTED_SET =\n            UnmodifiableSortedSet.unmodifiableSortedSet(new TreeSet<>());\n\n    /**\n     * Returns an unmodifiable <b>view</b> containing the difference of the given\n     * {@link Set}s, denoted by {@code a \\ b} (or {@code a - b}).\n     * <p>\n     * The returned view contains all elements of {@code a} that are not a member\n     * of {@code b}.\n     *\n     * @param <E> the generic type that is able to represent the types contained\n     *   in both input sets.\n     * @param setA  the set to subtract from, must not be null\n     * @param setB  the set to subtract, must not be null\n     * @return a view of the relative complement of the two sets\n     * @since 4.1\n     */\n    public static <E> SetView<E> difference(final Set<? extends E> setA, final Set<? extends E> setB) {\n        Objects.requireNonNull(setA, \"setA\");\n        Objects.requireNonNull(setB, \"setB\");\n\n        final Predicate<E> notContainedInB = object -> !setB.contains(object);\n\n        return new SetView<E>() {\n            @Override\n            public boolean contains(final Object o) {\n                return setA.contains(o) && !setB.contains(o);\n            }\n\n            @Override\n            public Iterator<E> createIterator() {\n                return IteratorUtils.filteredIterator(setA.iterator(), notContainedInB);\n            }\n        };\n    }\n\n    /**\n     * Returns an unmodifiable <b>view</b> of the symmetric difference of the given\n     * {@link Set}s.\n     * <p>\n     * The returned view contains all elements of {@code a} and {@code b} that are\n     * not a member of the other set.\n     * <p>\n     * This is equivalent to {@code union(difference(a, b), difference(b, a))}.\n     *\n     * @param <E> the generic type that is able to represent the types contained\n     *   in both input sets.\n     * @param setA  the first set, must not be null\n     * @param setB  the second set, must not be null\n     * @return a view of the symmetric difference of the two sets\n     * @since 4.1\n     */\n    public static <E> SetView<E> disjunction(final Set<? extends E> setA, final Set<? extends E> setB) {\n        Objects.requireNonNull(setA, \"setA\");\n        Objects.requireNonNull(setB, \"setB\");\n\n        final SetView<E> aMinusB = difference(setA, setB);\n        final SetView<E> bMinusA = difference(setB, setA);\n\n        return new SetView<E>() {\n            @Override\n            public boolean contains(final Object o) {\n                return setA.contains(o) ^ setB.contains(o);\n            }\n\n            @Override\n            public Iterator<E> createIterator() {\n                return IteratorUtils.chainedIterator(aMinusB.iterator(), bMinusA.iterator());\n            }\n\n            @Override\n            public boolean isEmpty() {\n                return aMinusB.isEmpty() && bMinusA.isEmpty();\n            }\n\n            @Override\n            public int size() {\n                return aMinusB.size() + bMinusA.size();\n            }\n        };\n    }\n\n    /**\n     * Returns an immutable empty set if the argument is {@code null},\n     * or the argument itself otherwise.\n     *\n     * @param <T> the element type\n     * @param set the set, possibly {@code null}\n     * @return an empty set if the argument is {@code null}\n     */\n    public static <T> Set<T> emptyIfNull(final Set<T> set) {\n        return set == null ? Collections.<T>emptySet() : set;\n    }\n\n    /**\n     * Gets a typed empty unmodifiable Set.\n     * @param <E> the element type\n     * @return an empty Set\n     */\n    public static <E> Set<E> emptySet() {\n        return Collections.<E>emptySet();\n    }\n\n    /**\n     * Gets a typed empty unmodifiable sorted set.\n     * @param <E> the element type\n     * @return an empty sorted Set\n     */\n    @SuppressWarnings(\"unchecked\") // empty set is OK for any type\n    public static <E> SortedSet<E> emptySortedSet() {\n        return EMPTY_SORTED_SET;\n    }\n\n    /**\n     * Generates a hash code using the algorithm specified in\n     * {@link java.util.Set#hashCode()}.\n     * <p>\n     * This method is useful for implementing {@code Set} when you cannot\n     * extend AbstractSet. The method takes Collection instances to enable other\n     * collection types to use the Set implementation algorithm.\n     *\n     * @param <T> the element type\n     * @see java.util.Set#hashCode()\n     * @param set  the set to calculate the hash code for, may be null\n     * @return the hash code\n     */\n    public static <T> int hashCodeForSet(final Collection<T> set) {\n        if (set == null) {\n            return 0;\n        }\n\n        int hashCode = 0;\n        for (final T obj : set) {\n            if (obj != null) {\n                hashCode += obj.hashCode();\n            }\n        }\n        return hashCode;\n    }\n\n    /**\n     * Creates a set from the given items. If the passed var-args argument is {@code\n     * null}, then the method returns {@code null}.\n     * @param <E> the element type\n     * @param items the elements that make up the new set\n     * @return a set\n     * @since 4.3\n     */\n    public static <E> HashSet<E> hashSet(final E... items) {\n        if (items == null) {\n            return null;\n        }\n        return new HashSet<>(Arrays.asList(items));\n    }\n\n    /**\n     * Returns an unmodifiable <b>view</b> of the intersection of the given {@link Set}s.\n     * <p>\n     * The returned view contains all elements that are members of both input sets\n     * ({@code a} and {@code b}).\n     *\n     * @param <E> the generic type that is able to represent the types contained\n     *   in both input sets.\n     * @param setA  the first set, must not be null\n     * @param setB  the second set, must not be null\n     * @return a view of the intersection of the two sets\n     * @since 4.1\n     */\n    public static <E> SetView<E> intersection(final Set<? extends E> setA, final Set<? extends E> setB) {\n        Objects.requireNonNull(setA, \"setA\");\n        Objects.requireNonNull(setB, \"setB\");\n\n        return new SetView<E>() {\n            @Override\n            public boolean contains(final Object o) {\n                return setA.contains(o) && setB.contains(o);\n            }\n\n            @Override\n            public Iterator<E> createIterator() {\n                return IteratorUtils.filteredIterator(setA.iterator(), setB::contains);\n            }\n        };\n    }\n\n    /**\n     * Tests two sets for equality as per the {@code equals()} contract\n     * in {@link java.util.Set#equals(Object)}.\n     * <p>\n     * This method is useful for implementing {@code Set} when you cannot\n     * extend AbstractSet. The method takes Collection instances to enable other\n     * collection types to use the Set implementation algorithm.\n     * <p>\n     * The relevant text (slightly paraphrased as this is a static method) is:\n     * <blockquote>\n     * <p>Two sets are considered equal if they have\n     * the same size, and every member of the first set is contained in\n     * the second. This ensures that the {@code equals} method works\n     * properly across different implementations of the {@code Set}\n     * interface.</p>\n     *\n     * <p>\n     * This implementation first checks if the two sets are the same object:\n     * if so it returns {@code true}.  Then, it checks if the two sets are\n     * identical in size; if not, it returns false. If so, it returns\n     * {@code a.containsAll((Collection) b)}.</p>\n     * </blockquote>\n     *\n     * @see java.util.Set\n     * @param set1  the first set, may be null\n     * @param set2  the second set, may be null\n     * @return whether the sets are equal by value comparison\n     */\n    public static boolean isEqualSet(final Collection<?> set1, final Collection<?> set2) {\n        if (set1 == set2) {\n            return true;\n        }\n        if (set1 == null || set2 == null || set1.size() != set2.size()) {\n            return false;\n        }\n\n        return set1.containsAll(set2);\n    }\n\n    /**\n     * Returns a new hash set that matches elements based on {@code ==} not\n     * {@code equals()}.\n     * <p>\n     * <strong>This set will violate the detail of various Set contracts.</strong>\n     * As a general rule, don't compare this set to other sets. In particular, you can't\n     * use decorators like {@link ListOrderedSet} on it, which silently assume that these\n     * contracts are fulfilled.\n     * <p>\n     * <strong>Note that the returned set is not synchronized and is not thread-safe.</strong>\n     * If you wish to use this set from multiple threads concurrently, you must use\n     * appropriate synchronization. The simplest approach is to wrap this map\n     * using {@link java.util.Collections#synchronizedSet(Set)}. This class may throw\n     * exceptions when accessed by concurrent threads without synchronization.\n     *\n     * @param <E>  the element type\n     * @return a new identity hash set\n     * @since 4.1\n     */\n    public static <E> Set<E> newIdentityHashSet() {\n        return Collections.newSetFromMap(new IdentityHashMap<>());\n    }\n\n    /**\n     * Returns a set that maintains the order of elements that are added\n     * backed by the given set.\n     * <p>\n     * If an element is added twice, the order is determined by the first add.\n     * The order is observed through the iterator or toArray.\n     *\n     * @param <E> the element type\n     * @param set  the set to order, must not be null\n     * @return an ordered set backed by the given set\n     * @throws NullPointerException if the set is null\n     */\n    public static <E> Set<E> orderedSet(final Set<E> set) {\n        return ListOrderedSet.listOrderedSet(set);\n    }\n\n    /**\n     * Returns a predicated (validating) navigable set backed by the given navigable set.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to the set.\n     * Trying to add an invalid object results in an IllegalArgumentException.\n     * It is important not to use the original set after invoking this method,\n     * as it is a backdoor for adding invalid objects.\n     *\n     * @param <E> the element type\n     * @param set  the navigable set to predicate, must not be null\n     * @param predicate  the predicate for the navigable set, must not be null\n     * @return a predicated navigable set backed by the given navigable set\n     * @throws NullPointerException if the set or predicate is null\n     * @since 4.1\n     */\n    public static <E> SortedSet<E> predicatedNavigableSet(final NavigableSet<E> set,\n                                                          final Predicate<? super E> predicate) {\n        return PredicatedNavigableSet.predicatedNavigableSet(set, predicate);\n    }\n\n    /**\n     * Returns a predicated (validating) set backed by the given set.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to the set.\n     * Trying to add an invalid object results in an IllegalArgumentException.\n     * It is important not to use the original set after invoking this method,\n     * as it is a backdoor for adding invalid objects.\n     *\n     * @param <E> the element type\n     * @param set  the set to predicate, must not be null\n     * @param predicate  the predicate for the set, must not be null\n     * @return a predicated set backed by the given set\n     * @throws NullPointerException if the set or predicate is null\n     */\n    public static <E> Set<E> predicatedSet(final Set<E> set, final Predicate<? super E> predicate) {\n        return PredicatedSet.predicatedSet(set, predicate);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted set backed by the given sorted set.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to the set.\n     * Trying to add an invalid object results in an IllegalArgumentException.\n     * It is important not to use the original set after invoking this method,\n     * as it is a backdoor for adding invalid objects.\n     *\n     * @param <E> the element type\n     * @param set  the sorted set to predicate, must not be null\n     * @param predicate  the predicate for the sorted set, must not be null\n     * @return a predicated sorted set backed by the given sorted set\n     * @throws NullPointerException if the set or predicate is null\n     */\n    public static <E> SortedSet<E> predicatedSortedSet(final SortedSet<E> set,\n                                                       final Predicate<? super E> predicate) {\n        return PredicatedSortedSet.predicatedSortedSet(set, predicate);\n    }\n\n    // Set\n    /**\n     * Returns a synchronized set backed by the given set.\n     * <p>\n     * You must manually synchronize on the returned set's iterator to\n     * avoid non-deterministic behavior:\n     *\n     * <pre>\n     * Sets s = SetUtils.synchronizedSet(mySet);\n     * synchronized (s) {\n     *     Iterator i = s.iterator();\n     *     while (i.hasNext()) {\n     *         process (i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * This method is just a wrapper for {@link Collections#synchronizedSet(Set)}.\n     *\n     * @param <E> the element type\n     * @param set  the set to synchronize, must not be null\n     * @return a synchronized set backed by the given set\n     * @throws NullPointerException if the set is null\n     */\n    public static <E> Set<E> synchronizedSet(final Set<E> set) {\n        return Collections.synchronizedSet(set);\n    }\n\n    // SortedSet\n    /**\n     * Returns a synchronized sorted set backed by the given sorted set.\n     * <p>\n     * You must manually synchronize on the returned set's iterator to\n     * avoid non-deterministic behavior:\n     *\n     * <pre>\n     * Set s = SetUtils.synchronizedSortedSet(mySet);\n     * synchronized (s) {\n     *     Iterator i = s.iterator();\n     *     while (i.hasNext()) {\n     *         process (i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * This method is just a wrapper for {@link Collections#synchronizedSortedSet(SortedSet)}.\n     *\n     * @param <E> the element type\n     * @param set  the sorted set to synchronize, must not be null\n     * @return a synchronized set backed by the given set\n     * @throws NullPointerException if the set is null\n     */\n    public static <E> SortedSet<E> synchronizedSortedSet(final SortedSet<E> set) {\n        return Collections.synchronizedSortedSet(set);\n    }\n\n    /**\n     * Returns a transformed navigable set backed by the given navigable set.\n     * <p>\n     * Each object is passed through the transformer as it is added to the\n     * Set. It is important not to use the original set after invoking this\n     * method, as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified set will not be transformed.\n     * If you want that behavior, see {@link TransformedNavigableSet#transformedNavigableSet}.\n     *\n     * @param <E> the element type\n     * @param set  the navigable set to transform, must not be null\n     * @param transformer  the transformer for the set, must not be null\n     * @return a transformed set backed by the given set\n     * @throws NullPointerException if the set or transformer is null\n     * @since 4.1\n     */\n    public static <E> SortedSet<E> transformedNavigableSet(final NavigableSet<E> set,\n                                                           final Transformer<? super E, ? extends E> transformer) {\n        return TransformedNavigableSet.transformingNavigableSet(set, transformer);\n    }\n\n    /**\n     * Returns a transformed set backed by the given set.\n     * <p>\n     * Each object is passed through the transformer as it is added to the\n     * Set. It is important not to use the original set after invoking this\n     * method, as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified set will not be transformed.\n     * If you want that behavior, see {@link TransformedSet#transformedSet}.\n     *\n     * @param <E> the element type\n     * @param set  the set to transform, must not be null\n     * @param transformer  the transformer for the set, must not be null\n     * @return a transformed set backed by the given set\n     * @throws NullPointerException if the set or transformer is null\n     */\n    public static <E> Set<E> transformedSet(final Set<E> set,\n                                            final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSet.transformingSet(set, transformer);\n    }\n\n    /**\n     * Returns a transformed sorted set backed by the given set.\n     * <p>\n     * Each object is passed through the transformer as it is added to the\n     * Set. It is important not to use the original set after invoking this\n     * method, as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified set will not be transformed.\n     * If you want that behavior, see {@link TransformedSortedSet#transformedSortedSet}.\n     *\n     * @param <E> the element type\n     * @param set  the set to transform, must not be null\n     * @param transformer  the transformer for the set, must not be null\n     * @return a transformed set backed by the given set\n     * @throws NullPointerException if the set or transformer is null\n     */\n    public static <E> SortedSet<E> transformedSortedSet(final SortedSet<E> set,\n                                                        final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedSet.transformingSortedSet(set, transformer);\n    }\n\n    // Set operations\n\n    /**\n     * Returns an unmodifiable <b>view</b> of the union of the given {@link Set}s.\n     * <p>\n     * The returned view contains all elements of {@code a} and {@code b}.\n     *\n     * @param <E> the generic type that is able to represent the types contained\n     *   in both input sets.\n     * @param setA  the first set, must not be null\n     * @param setB  the second set, must not be null\n     * @return a view of the union of the two set\n     * @throws NullPointerException if either input set is null\n     * @since 4.1\n     */\n    public static <E> SetView<E> union(final Set<? extends E> setA, final Set<? extends E> setB) {\n        Objects.requireNonNull(setA, \"setA\");\n        Objects.requireNonNull(setB, \"setB\");\n\n        final SetView<E> bMinusA = difference(setB, setA);\n\n        return new SetView<E>() {\n            @Override\n            public boolean contains(final Object o) {\n                return setA.contains(o) || setB.contains(o);\n            }\n\n            @Override\n            public Iterator<E> createIterator() {\n                return IteratorUtils.chainedIterator(setA.iterator(), bMinusA.iterator());\n            }\n\n            @Override\n            public boolean isEmpty() {\n                return setA.isEmpty() && setB.isEmpty();\n            }\n\n            @Override\n            public int size() {\n                return setA.size() + bMinusA.size();\n            }\n        };\n    }\n\n    // NavigableSet\n    /**\n     * Returns an unmodifiable navigable set backed by the given navigable set.\n     * <p>\n     * This method uses the implementation in the decorators subpackage.\n     *\n     * @param <E> the element type\n     * @param set  the navigable set to make unmodifiable, must not be null\n     * @return an unmodifiable set backed by the given set\n     * @throws NullPointerException if the set is null\n     * @since 4.1\n     */\n    public static <E> SortedSet<E> unmodifiableNavigableSet(final NavigableSet<E> set) {\n        return UnmodifiableNavigableSet.unmodifiableNavigableSet(set);\n    }\n\n    /**\n     * Creates an unmodifiable set from the given items. If the passed var-args argument is {@code\n     * null}, then the method returns {@code null}.\n     * @param <E> the element type\n     * @param items the elements that make up the new set\n     * @return a set\n     * @since 4.3\n     */\n    public static <E> Set<E> unmodifiableSet(final E... items) {\n        if (items == null) {\n            return null;\n        }\n        return UnmodifiableSet.unmodifiableSet(hashSet(items));\n    }\n\n    /**\n     * Returns an unmodifiable set backed by the given set.\n     * <p>\n     * This method uses the implementation in the decorators subpackage.\n     *\n     * @param <E> the element type\n     * @param set  the set to make unmodifiable, must not be null\n     * @return an unmodifiable set backed by the given set\n     * @throws NullPointerException if the set is null\n     */\n    public static <E> Set<E> unmodifiableSet(final Set<? extends E> set) {\n        return UnmodifiableSet.unmodifiableSet(set);\n    }\n\n    /**\n     * Returns an unmodifiable sorted set backed by the given sorted set.\n     * <p>\n     * This method uses the implementation in the decorators subpackage.\n     *\n     * @param <E> the element type\n     * @param set  the sorted set to make unmodifiable, must not be null\n     * @return an unmodifiable set backed by the given set\n     * @throws NullPointerException if the set is null\n     */\n    public static <E> SortedSet<E> unmodifiableSortedSet(final SortedSet<E> set) {\n        return UnmodifiableSortedSet.unmodifiableSortedSet(set);\n    }\n\n    /**\n     * Don't allow instances.\n     */\n    private SetUtils() {\n        // empty\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "@SuppressWarnings(\"rawtypes\")\n    public static final SortedSet EMPTY_SORTED_SET =\n            UnmodifiableSortedSet.unmodifiableSortedSet(new TreeSet<>());", "docstring": "\nAn empty unmodifiable sorted set.\nThis is not provided in the JDK.\n", "modifiers": "@SuppressWarnings(\"rawtypes\")\n    public static final", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"rawtypes\")", "public", "static", "final"], "comments": [], "type": "SortedSet", "name": "EMPTY_SORTED_SET =\n            UnmodifiableSortedSet.unmodifiableSortedSet(new TreeSet<>())", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/CollectionUtils.java.CollectionUtils", "name": "CollectionUtils", "file_path": "src/main/java/org/apache/commons/collections4/CollectionUtils.java", "superclasses": "", "methods": ["[boolean]addAll(Collection<C>)", "[boolean]addAll(Collection<C>,Enumeration<? extends C>)", "[boolean]addAll(Collection<C>,Iterable<? extends C>)", "[boolean]addAll(Collection<C>,Iterator<? extends C>)", "[boolean]addIgnoreNull(Collection<T>,T)", "[int]cardinality(O,Iterable<? super O>)", "[void]checkIndexBounds(int)", "[List<O>]collate(Iterable<? extends O>,Iterable<? extends O>)", "[List<O>]collate(Iterable<? extends O>,Iterable<? extends O>,boolean)", "[List<O>]collate(Iterable<? extends O>,Iterable<? extends O>,Comparator<? super O>)", "[List<O>]collate(Iterable<? extends O>,Iterable<? extends O>,Comparator<? super O>,boolean)", "[R]collect(Iterable<? extends I>,Transformer<? super I, ? extends O>,R)", "[Collection<O>]collect(Iterable<I>,Transformer<? super I, ? extends O>)", "[R]collect(Iterator<? extends I>,Transformer<? super I, ? extends O>,R)", "[Collection<O>]collect(Iterator<I>,Transformer<? super I, ? extends O>)", "[boolean]containsAll(Collection<?>,Collection<?>)", "[boolean]containsAny(Collection<?>,Collection<?>)", "[boolean]containsAny(Collection<?>)", "[int]countMatches(Iterable<C>,Predicate<? super C>)", "[Collection<O>]disjunction(Iterable<? extends O>,Iterable<? extends O>)", "[Collection<T>]emptyCollection()", "[Collection<T>]emptyIfNull(Collection<T>)", "[boolean]exists(Iterable<C>,Predicate<? super C>)", "[E]extractSingleton(Collection<E>)", "[boolean]filter(Iterable<T>,Predicate<? super T>)", "[boolean]filterInverse(Iterable<T>,Predicate<? super T>)", "[T]find(Iterable<T>,Predicate<? super T>)", "[T]forAllButLastDo(Iterable<T>,C)", "[T]forAllButLastDo(Iterator<T>,C)", "[C]forAllDo(Iterable<T>,C)", "[C]forAllDo(Iterator<T>,C)", "[T]get(Iterable<T>,int)", "[T]get(Iterator<T>,int)", "[Map.Entry<K, V>]get(Map<K, V>,int)", "[Object]get(Object,int)", "[Map<O, Integer>]getCardinalityMap(Iterable<? extends O>)", "[int]hashCode(Collection<? extends E>,Equator<? super E>)", "[Collection<O>]intersection(Iterable<? extends O>,Iterable<? extends O>)", "[boolean]isEmpty(Collection<?>)", "[boolean]isEqualCollection(Collection<?>,Collection<?>)", "[boolean]isEqualCollection(Collection<? extends E>,Collection<? extends E>,Equator<? super E>)", "[boolean]isFull(Collection<? extends Object>)", "[boolean]isNotEmpty(Collection<?>)", "[boolean]isProperSubCollection(Collection<?>,Collection<?>)", "[boolean]isSubCollection(Collection<?>,Collection<?>)", "[boolean]matchesAll(Iterable<C>,Predicate<? super C>)", "[int]maxSize(Collection<? extends Object>)", "[Collection<List<E>>]permutations(Collection<E>)", "[Collection<C>]predicatedCollection(Collection<C>,Predicate<? super C>)", "[Collection<E>]removeAll(Collection<E>,Collection<?>)", "[Collection<E>]removeAll(Iterable<E>,Iterable<? extends E>,Equator<? super E>)", "[Collection<E>]removeCount(Collection<E>,int,int)", "[Collection<E>]removeRange(Collection<E>,int,int)", "[Collection<C>]retainAll(Collection<C>,Collection<?>)", "[Collection<E>]retainAll(Iterable<E>,Iterable<? extends E>,Equator<? super E>)", "[void]reverseArray(Object[])", "[Collection<O>]select(Iterable<? extends O>,Predicate<? super O>)", "[R]select(Iterable<? extends O>,Predicate<? super O>,R)", "[R]select(Iterable<? extends O>,Predicate<? super O>,R,R)", "[Collection<O>]selectRejected(Iterable<? extends O>,Predicate<? super O>)", "[R]selectRejected(Iterable<? extends O>,Predicate<? super O>,R)", "[int]size(Object)", "[boolean]sizeIsEmpty(Object)", "[Collection<O>]subtract(Iterable<? extends O>,Iterable<? extends O>)", "[Collection<O>]subtract(Iterable<? extends O>,Iterable<? extends O>,Predicate<O>)", "[Collection<C>]synchronizedCollection(Collection<C>)", "[void]transform(Collection<C>,Transformer<? super C, ? extends C>)", "[Collection<E>]transformingCollection(Collection<E>,Transformer<? super E, ? extends E>)", "[Collection<O>]union(Iterable<? extends O>,Iterable<? extends O>)", "[Collection<C>]unmodifiableCollection(Collection<? extends C>)", "[]CollectionUtils()"], "method_uris": ["src/main/java/org/apache/commons/collections4/CollectionUtils.java.CollectionUtils.[boolean]addAll(Collection<C>)", "src/main/java/org/apache/commons/collections4/CollectionUtils.java.CollectionUtils.[boolean]addAll(Collection<C>,Enumeration<? extends C>)", "src/main/java/org/apache/commons/collections4/CollectionUtils.java.CollectionUtils.[boolean]addAll(Collection<C>,Iterable<? extends C>)", "src/main/java/org/apache/commons/collections4/CollectionUtils.java.CollectionUtils.[boolean]addAll(Collection<C>,Iterator<? extends C>)", "src/main/java/org/apache/commons/collections4/CollectionUtils.java.CollectionUtils.[boolean]addIgnoreNull(Collection<T>,T)", "src/main/java/org/apache/commons/collections4/CollectionUtils.java.CollectionUtils.[int]cardinality(O,Iterable<? super O>)", "src/main/java/org/apache/commons/collections4/CollectionUtils.java.CollectionUtils.[void]checkIndexBounds(int)", "src/main/java/org/apache/commons/collections4/CollectionUtils.java.CollectionUtils.[List<O>]collate(Iterable<? extends O>,Iterable<? extends O>)", "src/main/java/org/apache/commons/collections4/CollectionUtils.java.CollectionUtils.[List<O>]collate(Iterable<? extends O>,Iterable<? extends O>,boolean)", "src/main/java/org/apache/commons/collections4/CollectionUtils.java.CollectionUtils.[List<O>]collate(Iterable<? extends O>,Iterable<? extends O>,Comparator<? super O>)", "src/main/java/org/apache/commons/collections4/CollectionUtils.java.CollectionUtils.[List<O>]collate(Iterable<? extends O>,Iterable<? extends O>,Comparator<? super O>,boolean)", "src/main/java/org/apache/commons/collections4/CollectionUtils.java.CollectionUtils.[R]collect(Iterable<? extends I>,Transformer<? super I, ? extends O>,R)", "src/main/java/org/apache/commons/collections4/CollectionUtils.java.CollectionUtils.[Collection<O>]collect(Iterable<I>,Transformer<? super I, ? extends O>)", "src/main/java/org/apache/commons/collections4/CollectionUtils.java.CollectionUtils.[R]collect(Iterator<? extends I>,Transformer<? super I, ? extends O>,R)", "src/main/java/org/apache/commons/collections4/CollectionUtils.java.CollectionUtils.[Collection<O>]collect(Iterator<I>,Transformer<? super I, ? extends O>)", "src/main/java/org/apache/commons/collections4/CollectionUtils.java.CollectionUtils.[boolean]containsAll(Collection<?>,Collection<?>)", "src/main/java/org/apache/commons/collections4/CollectionUtils.java.CollectionUtils.[boolean]containsAny(Collection<?>,Collection<?>)", "src/main/java/org/apache/commons/collections4/CollectionUtils.java.CollectionUtils.[boolean]containsAny(Collection<?>)", "src/main/java/org/apache/commons/collections4/CollectionUtils.java.CollectionUtils.[int]countMatches(Iterable<C>,Predicate<? super C>)", "src/main/java/org/apache/commons/collections4/CollectionUtils.java.CollectionUtils.[Collection<O>]disjunction(Iterable<? extends O>,Iterable<? extends O>)", "src/main/java/org/apache/commons/collections4/CollectionUtils.java.CollectionUtils.[Collection<T>]emptyCollection()", "src/main/java/org/apache/commons/collections4/CollectionUtils.java.CollectionUtils.[Collection<T>]emptyIfNull(Collection<T>)", "src/main/java/org/apache/commons/collections4/CollectionUtils.java.CollectionUtils.[boolean]exists(Iterable<C>,Predicate<? super C>)", "src/main/java/org/apache/commons/collections4/CollectionUtils.java.CollectionUtils.[E]extractSingleton(Collection<E>)", "src/main/java/org/apache/commons/collections4/CollectionUtils.java.CollectionUtils.[boolean]filter(Iterable<T>,Predicate<? super T>)", "src/main/java/org/apache/commons/collections4/CollectionUtils.java.CollectionUtils.[boolean]filterInverse(Iterable<T>,Predicate<? super T>)", "src/main/java/org/apache/commons/collections4/CollectionUtils.java.CollectionUtils.[T]find(Iterable<T>,Predicate<? super T>)", "src/main/java/org/apache/commons/collections4/CollectionUtils.java.CollectionUtils.[T]forAllButLastDo(Iterable<T>,C)", "src/main/java/org/apache/commons/collections4/CollectionUtils.java.CollectionUtils.[T]forAllButLastDo(Iterator<T>,C)", "src/main/java/org/apache/commons/collections4/CollectionUtils.java.CollectionUtils.[C]forAllDo(Iterable<T>,C)", "src/main/java/org/apache/commons/collections4/CollectionUtils.java.CollectionUtils.[C]forAllDo(Iterator<T>,C)", "src/main/java/org/apache/commons/collections4/CollectionUtils.java.CollectionUtils.[T]get(Iterable<T>,int)", "src/main/java/org/apache/commons/collections4/CollectionUtils.java.CollectionUtils.[T]get(Iterator<T>,int)", "src/main/java/org/apache/commons/collections4/CollectionUtils.java.CollectionUtils.[Map.Entry<K, V>]get(Map<K, V>,int)", "src/main/java/org/apache/commons/collections4/CollectionUtils.java.CollectionUtils.[Object]get(Object,int)", "src/main/java/org/apache/commons/collections4/CollectionUtils.java.CollectionUtils.[Map<O, Integer>]getCardinalityMap(Iterable<? extends O>)", "src/main/java/org/apache/commons/collections4/CollectionUtils.java.CollectionUtils.[int]hashCode(Collection<? extends E>,Equator<? super E>)", "src/main/java/org/apache/commons/collections4/CollectionUtils.java.CollectionUtils.[Collection<O>]intersection(Iterable<? extends O>,Iterable<? extends O>)", "src/main/java/org/apache/commons/collections4/CollectionUtils.java.CollectionUtils.[boolean]isEmpty(Collection<?>)", "src/main/java/org/apache/commons/collections4/CollectionUtils.java.CollectionUtils.[boolean]isEqualCollection(Collection<?>,Collection<?>)", "src/main/java/org/apache/commons/collections4/CollectionUtils.java.CollectionUtils.[boolean]isEqualCollection(Collection<? extends E>,Collection<? extends E>,Equator<? super E>)", "src/main/java/org/apache/commons/collections4/CollectionUtils.java.CollectionUtils.[boolean]isFull(Collection<? extends Object>)", "src/main/java/org/apache/commons/collections4/CollectionUtils.java.CollectionUtils.[boolean]isNotEmpty(Collection<?>)", "src/main/java/org/apache/commons/collections4/CollectionUtils.java.CollectionUtils.[boolean]isProperSubCollection(Collection<?>,Collection<?>)", "src/main/java/org/apache/commons/collections4/CollectionUtils.java.CollectionUtils.[boolean]isSubCollection(Collection<?>,Collection<?>)", "src/main/java/org/apache/commons/collections4/CollectionUtils.java.CollectionUtils.[boolean]matchesAll(Iterable<C>,Predicate<? super C>)", "src/main/java/org/apache/commons/collections4/CollectionUtils.java.CollectionUtils.[int]maxSize(Collection<? extends Object>)", "src/main/java/org/apache/commons/collections4/CollectionUtils.java.CollectionUtils.[Collection<List<E>>]permutations(Collection<E>)", "src/main/java/org/apache/commons/collections4/CollectionUtils.java.CollectionUtils.[Collection<C>]predicatedCollection(Collection<C>,Predicate<? super C>)", "src/main/java/org/apache/commons/collections4/CollectionUtils.java.CollectionUtils.[Collection<E>]removeAll(Collection<E>,Collection<?>)", "src/main/java/org/apache/commons/collections4/CollectionUtils.java.CollectionUtils.[Collection<E>]removeAll(Iterable<E>,Iterable<? extends E>,Equator<? super E>)", "src/main/java/org/apache/commons/collections4/CollectionUtils.java.CollectionUtils.[Collection<E>]removeCount(Collection<E>,int,int)", "src/main/java/org/apache/commons/collections4/CollectionUtils.java.CollectionUtils.[Collection<E>]removeRange(Collection<E>,int,int)", "src/main/java/org/apache/commons/collections4/CollectionUtils.java.CollectionUtils.[Collection<C>]retainAll(Collection<C>,Collection<?>)", "src/main/java/org/apache/commons/collections4/CollectionUtils.java.CollectionUtils.[Collection<E>]retainAll(Iterable<E>,Iterable<? extends E>,Equator<? super E>)", "src/main/java/org/apache/commons/collections4/CollectionUtils.java.CollectionUtils.[void]reverseArray(Object[])", "src/main/java/org/apache/commons/collections4/CollectionUtils.java.CollectionUtils.[Collection<O>]select(Iterable<? extends O>,Predicate<? super O>)", "src/main/java/org/apache/commons/collections4/CollectionUtils.java.CollectionUtils.[R]select(Iterable<? extends O>,Predicate<? super O>,R)", "src/main/java/org/apache/commons/collections4/CollectionUtils.java.CollectionUtils.[R]select(Iterable<? extends O>,Predicate<? super O>,R,R)", "src/main/java/org/apache/commons/collections4/CollectionUtils.java.CollectionUtils.[Collection<O>]selectRejected(Iterable<? extends O>,Predicate<? super O>)", "src/main/java/org/apache/commons/collections4/CollectionUtils.java.CollectionUtils.[R]selectRejected(Iterable<? extends O>,Predicate<? super O>,R)", "src/main/java/org/apache/commons/collections4/CollectionUtils.java.CollectionUtils.[int]size(Object)", "src/main/java/org/apache/commons/collections4/CollectionUtils.java.CollectionUtils.[boolean]sizeIsEmpty(Object)", "src/main/java/org/apache/commons/collections4/CollectionUtils.java.CollectionUtils.[Collection<O>]subtract(Iterable<? extends O>,Iterable<? extends O>)", "src/main/java/org/apache/commons/collections4/CollectionUtils.java.CollectionUtils.[Collection<O>]subtract(Iterable<? extends O>,Iterable<? extends O>,Predicate<O>)", "src/main/java/org/apache/commons/collections4/CollectionUtils.java.CollectionUtils.[Collection<C>]synchronizedCollection(Collection<C>)", "src/main/java/org/apache/commons/collections4/CollectionUtils.java.CollectionUtils.[void]transform(Collection<C>,Transformer<? super C, ? extends C>)", "src/main/java/org/apache/commons/collections4/CollectionUtils.java.CollectionUtils.[Collection<E>]transformingCollection(Collection<E>,Transformer<? super E, ? extends E>)", "src/main/java/org/apache/commons/collections4/CollectionUtils.java.CollectionUtils.[Collection<O>]union(Iterable<? extends O>,Iterable<? extends O>)", "src/main/java/org/apache/commons/collections4/CollectionUtils.java.CollectionUtils.[Collection<C>]unmodifiableCollection(Collection<? extends C>)", "src/main/java/org/apache/commons/collections4/CollectionUtils.java.CollectionUtils.[]CollectionUtils()"], "overrides": null, "attributes": [{"original_string": "    private static class CardinalityHelper<O> {\n\n        static boolean equals(final Collection<?> a, final Collection<?> b) {\n            return new HashBag<>(a).equals(new HashBag<>(b));\n        }\n\n        /** Contains the cardinality for each object in collection A. */\n        final Bag<O> cardinalityA;\n\n        /** Contains the cardinality for each object in collection B. */\n        final Bag<O> cardinalityB;\n\n        /**\n         * Creates a new CardinalityHelper for two collections.\n         *\n         * @param a  the first collection\n         * @param b  the second collection\n         */\n        CardinalityHelper(final Iterable<? extends O> a, final Iterable<? extends O> b) {\n            cardinalityA = new HashBag<>(a);\n            cardinalityB = new HashBag<>(b);\n        }\n\n        /**\n         * Gets the frequency of this object in collection A.\n         *\n         * @param key the key whose associated frequency is to be returned.\n         * @return the frequency of the object in collection A\n         */\n        public int freqA(final Object key) {\n            return getFreq(key, cardinalityA);\n        }\n\n        /**\n         * Gets the frequency of this object in collection B.\n         *\n         * @param key the key whose associated frequency is to be returned.\n         * @return the frequency of the object in collection B\n         */\n        public int freqB(final Object key) {\n            return getFreq(key, cardinalityB);\n        }\n\n        private int getFreq(final Object key, final Bag<?> freqMap) {\n            return freqMap.getCount(key);\n        }\n\n        /**\n         * Gets the maximum frequency of an object.\n         *\n         * @param obj  the object\n         * @return the maximum frequency of the object\n         */\n        public final int max(final Object obj) {\n            return Math.max(freqA(obj), freqB(obj));\n        }\n\n        /**\n         * Gets the minimum frequency of an object.\n         *\n         * @param obj  the object\n         * @return the minimum frequency of the object\n         */\n        public final int min(final Object obj) {\n            return Math.min(freqA(obj), freqB(obj));\n        }\n    }", "definition": "    private static class CardinalityHelper<O>", "class_docstring": "\nHelper class to easily access cardinality properties of two collections.\n@param <O>  the element type\n", "name": "CardinalityHelper", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "final Bag<O> cardinalityA;", "docstring": " Contains the cardinality for each object in collection A.", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Bag<O>", "name": "cardinalityA", "syntax_pass": true}, {"attribute_expression": "final Bag<O> cardinalityB;", "docstring": " Contains the cardinality for each object in collection B.", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Bag<O>", "name": "cardinalityB", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        static boolean equals(final Collection<?> a, final Collection<?> b) {\n            return new HashBag<>(a).equals(new HashBag<>(b));\n        }", "docstring": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "a", "type": "Collection<?>"}, {"name": "b", "type": "Collection<?>"}], "body": "                                                                            {\n            return new HashBag<>(a).equals(new HashBag<>(b));\n        }", "signature": "static boolean equals(final Collection<?> a, final Collection<?> b)"}, {"syntax_pass": true, "original_string": "        CardinalityHelper(final Iterable<? extends O> a, final Iterable<? extends O> b) {\n            cardinalityA = new HashBag<>(a);\n            cardinalityB = new HashBag<>(b);\n        }", "docstring": "\nCreates a new CardinalityHelper for two collections.\n\n@param a  the first collection\n@param b  the second collection\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "CardinalityHelper", "params": [{"name": "a", "type": "Iterable<? extends O>"}, {"name": "b", "type": "Iterable<? extends O>"}], "body": "                                                                                        {\n            cardinalityA = new HashBag<>(a);\n            cardinalityB = new HashBag<>(b);\n        }", "signature": "CardinalityHelper(final Iterable<? extends O> a, final Iterable<? extends O> b)"}, {"syntax_pass": true, "original_string": "        public int freqA(final Object key) {\n            return getFreq(key, cardinalityA);\n        }", "docstring": "\nGets the frequency of this object in collection A.\n\n@param key the key whose associated frequency is to be returned.\n@return the frequency of the object in collection A\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "freqA", "params": [{"name": "key", "type": "Object"}], "body": "                                           {\n            return getFreq(key, cardinalityA);\n        }", "signature": "public int freqA(final Object key)"}, {"syntax_pass": true, "original_string": "        public int freqB(final Object key) {\n            return getFreq(key, cardinalityB);\n        }", "docstring": "\nGets the frequency of this object in collection B.\n\n@param key the key whose associated frequency is to be returned.\n@return the frequency of the object in collection B\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "freqB", "params": [{"name": "key", "type": "Object"}], "body": "                                           {\n            return getFreq(key, cardinalityB);\n        }", "signature": "public int freqB(final Object key)"}, {"syntax_pass": true, "original_string": "        private int getFreq(final Object key, final Bag<?> freqMap) {\n            return freqMap.getCount(key);\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "int", "classes": []}, "name": "getFreq", "params": [{"name": "key", "type": "Object"}, {"name": "freqMap", "type": "Bag<?>"}], "body": "                                                                    {\n            return freqMap.getCount(key);\n        }", "signature": "private int getFreq(final Object key, final Bag<?> freqMap)"}, {"syntax_pass": true, "original_string": "        public final int max(final Object obj) {\n            return Math.max(freqA(obj), freqB(obj));\n        }", "docstring": "\nGets the maximum frequency of an object.\n\n@param obj  the object\n@return the maximum frequency of the object\n", "attributes": {"modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "return_type": "int", "classes": []}, "name": "max", "params": [{"name": "obj", "type": "Object"}], "body": "                                               {\n            return Math.max(freqA(obj), freqB(obj));\n        }", "signature": "public final int max(final Object obj)"}, {"syntax_pass": true, "original_string": "        public final int min(final Object obj) {\n            return Math.min(freqA(obj), freqB(obj));\n        }", "docstring": "\nGets the minimum frequency of an object.\n\n@param obj  the object\n@return the minimum frequency of the object\n", "attributes": {"modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "return_type": "int", "classes": []}, "name": "min", "params": [{"name": "obj", "type": "Object"}], "body": "                                               {\n            return Math.min(freqA(obj), freqB(obj));\n        }", "signature": "public final int min(final Object obj)"}]}, {"original_string": "    private static final class EquatorWrapper<O> {\n        private final Equator<? super O> equator;\n        private final O object;\n\n        EquatorWrapper(final Equator<? super O> equator, final O object) {\n            this.equator = equator;\n            this.object = object;\n        }\n\n        @Override\n        public boolean equals(final Object obj) {\n            if (!(obj instanceof EquatorWrapper)) {\n                return false;\n            }\n            @SuppressWarnings(\"unchecked\")\n            final EquatorWrapper<O> otherObj = (EquatorWrapper<O>) obj;\n            return equator.equate(object, otherObj.getObject());\n        }\n\n        public O getObject() {\n            return object;\n        }\n\n        @Override\n        public int hashCode() {\n            return equator.hash(object);\n        }\n    }", "definition": "    private static final class EquatorWrapper<O>", "class_docstring": "\nWraps another object and uses the provided Equator to implement\n{@link #equals(Object)} and {@link #hashCode()}.\n<p>\nThis class can be used to store objects into a Map.\n</p>\n\n@param <O>  the element type\n@since 4.0\n", "name": "EquatorWrapper", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "fields": [{"attribute_expression": "private final Equator<? super O> equator;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Equator<? super O>", "name": "equator", "syntax_pass": true}, {"attribute_expression": "private final O object;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "O", "name": "object", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        EquatorWrapper(final Equator<? super O> equator, final O object) {\n            this.equator = equator;\n            this.object = object;\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "EquatorWrapper", "params": [{"name": "equator", "type": "Equator<? super O>"}, {"name": "object", "type": "O"}], "body": "                                                                         {\n            this.equator = equator;\n            this.object = object;\n        }", "signature": "EquatorWrapper(final Equator<? super O> equator, final O object)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean equals(final Object obj) {\n            if (!(obj instanceof EquatorWrapper)) {\n                return false;\n            }\n            @SuppressWarnings(\"unchecked\")\n            final EquatorWrapper<O> otherObj = (EquatorWrapper<O>) obj;\n            return equator.equate(object, otherObj.getObject());\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "obj", "type": "Object"}], "body": "                                                {\n            if (!(obj instanceof EquatorWrapper)) {\n                return false;\n            }\n            @SuppressWarnings(\"unchecked\")\n            final EquatorWrapper<O> otherObj = (EquatorWrapper<O>) obj;\n            return equator.equate(object, otherObj.getObject());\n        }", "signature": "@Override\n        public boolean equals(final Object obj)"}, {"syntax_pass": true, "original_string": "        public O getObject() {\n            return object;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "O", "classes": []}, "name": "getObject", "params": [], "body": "                             {\n            return object;\n        }", "signature": "public O getObject()"}, {"syntax_pass": true, "original_string": "        @Override\n        public int hashCode() {\n            return equator.hash(object);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                              {\n            return equator.hash(object);\n        }", "signature": "@Override\n        public int hashCode()"}]}, {"original_string": "    private static final class SetOperationCardinalityHelper<O> extends CardinalityHelper<O> implements Iterable<O> {\n\n        /** Contains the unique elements of the two collections. */\n        private final Set<O> elements;\n\n        /** Output collection. */\n        private final List<O> newList;\n\n        /**\n         * Create a new set operation helper from the two collections.\n         * @param a  the first collection\n         * @param b  the second collection\n         */\n        SetOperationCardinalityHelper(final Iterable<? extends O> a, final Iterable<? extends O> b) {\n            super(a, b);\n            elements = new HashSet<>();\n            addAll(elements, a);\n            addAll(elements, b);\n            // the resulting list must contain at least each unique element, but may grow\n            newList = new ArrayList<>(elements.size());\n        }\n\n        @Override\n        public Iterator<O> iterator() {\n            return elements.iterator();\n        }\n\n        /**\n         * Returns the resulting collection.\n         * @return the result\n         */\n        public Collection<O> list() {\n            return newList;\n        }\n\n        /**\n         * Add the object {@code count} times to the result collection.\n         * @param obj  the object to add\n         * @param count  the count\n         */\n        public void setCardinality(final O obj, final int count) {\n            for (int i = 0; i < count; i++) {\n                newList.add(obj);\n            }\n        }\n\n    }", "definition": "    private static final class SetOperationCardinalityHelper<O> extends CardinalityHelper<O> implements Iterable<O>", "class_docstring": "\nHelper class for set-related operations, e.g. union, subtract, intersection.\n@param <O>  the element type\n", "name": "SetOperationCardinalityHelper", "super_interfaces": ["Iterable<O>"], "superclasses": "", "attributes": {"modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "fields": [{"attribute_expression": "private final Set<O> elements;", "docstring": " Contains the unique elements of the two collections.", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Set<O>", "name": "elements", "syntax_pass": true}, {"attribute_expression": "private final List<O> newList;", "docstring": " Output collection.", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<O>", "name": "newList", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        SetOperationCardinalityHelper(final Iterable<? extends O> a, final Iterable<? extends O> b) {\n            super(a, b);\n            elements = new HashSet<>();\n            addAll(elements, a);\n            addAll(elements, b);\n            // the resulting list must contain at least each unique element, but may grow\n            newList = new ArrayList<>(elements.size());\n        }", "docstring": "\nCreate a new set operation helper from the two collections.\n@param a  the first collection\n@param b  the second collection\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "SetOperationCardinalityHelper", "params": [{"name": "a", "type": "Iterable<? extends O>"}, {"name": "b", "type": "Iterable<? extends O>"}], "body": "                                                                                                    {\n            super(a, b);\n            elements = new HashSet<>();\n            addAll(elements, a);\n            addAll(elements, b);\n            // the resulting list must contain at least each unique element, but may grow\n            newList = new ArrayList<>(elements.size());\n        }", "signature": "SetOperationCardinalityHelper(final Iterable<? extends O> a, final Iterable<? extends O> b)"}, {"syntax_pass": true, "original_string": "        @Override\n        public Iterator<O> iterator() {\n            return elements.iterator();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Iterator<O>", "classes": []}, "name": "iterator", "params": [], "body": "                                      {\n            return elements.iterator();\n        }", "signature": "@Override\n        public Iterator<O> iterator()"}, {"syntax_pass": true, "original_string": "        public Collection<O> list() {\n            return newList;\n        }", "docstring": "\nReturns the resulting collection.\n@return the result\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Collection<O>", "classes": []}, "name": "list", "params": [], "body": "                                    {\n            return newList;\n        }", "signature": "public Collection<O> list()"}, {"syntax_pass": true, "original_string": "        public void setCardinality(final O obj, final int count) {\n            for (int i = 0; i < count; i++) {\n                newList.add(obj);\n            }\n        }", "docstring": "\nAdd the object {@code count} times to the result collection.\n@param obj  the object to add\n@param count  the count\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setCardinality", "params": [{"name": "obj", "type": "O"}, {"name": "count", "type": "int"}], "body": "                                                                 {\n            for (int i = 0; i < count; i++) {\n                newList.add(obj);\n            }\n        }", "signature": "public void setCardinality(final O obj, final int count)"}]}], "class_docstring": "\nProvides utility methods and decorators for {@link Collection} instances.\n<p>\nVarious utility methods might put the input objects into a Set/Map/Bag. In case\nthe input objects override {@link Object#equals(Object)}, it is mandatory that\nthe general contract of the {@link Object#hashCode()} method is maintained.\n</p>\n<p>\nNOTE: From 4.0, method parameters will take {@link Iterable} objects when possible.\n</p>\n\n@since 1.0\n", "original_string": "public class CollectionUtils {\n\n    /**\n     * Helper class to easily access cardinality properties of two collections.\n     * @param <O>  the element type\n     */\n    private static class CardinalityHelper<O> {\n\n        static boolean equals(final Collection<?> a, final Collection<?> b) {\n            return new HashBag<>(a).equals(new HashBag<>(b));\n        }\n\n        /** Contains the cardinality for each object in collection A. */\n        final Bag<O> cardinalityA;\n\n        /** Contains the cardinality for each object in collection B. */\n        final Bag<O> cardinalityB;\n\n        /**\n         * Creates a new CardinalityHelper for two collections.\n         *\n         * @param a  the first collection\n         * @param b  the second collection\n         */\n        CardinalityHelper(final Iterable<? extends O> a, final Iterable<? extends O> b) {\n            cardinalityA = new HashBag<>(a);\n            cardinalityB = new HashBag<>(b);\n        }\n\n        /**\n         * Gets the frequency of this object in collection A.\n         *\n         * @param key the key whose associated frequency is to be returned.\n         * @return the frequency of the object in collection A\n         */\n        public int freqA(final Object key) {\n            return getFreq(key, cardinalityA);\n        }\n\n        /**\n         * Gets the frequency of this object in collection B.\n         *\n         * @param key the key whose associated frequency is to be returned.\n         * @return the frequency of the object in collection B\n         */\n        public int freqB(final Object key) {\n            return getFreq(key, cardinalityB);\n        }\n\n        private int getFreq(final Object key, final Bag<?> freqMap) {\n            return freqMap.getCount(key);\n        }\n\n        /**\n         * Gets the maximum frequency of an object.\n         *\n         * @param obj  the object\n         * @return the maximum frequency of the object\n         */\n        public final int max(final Object obj) {\n            return Math.max(freqA(obj), freqB(obj));\n        }\n\n        /**\n         * Gets the minimum frequency of an object.\n         *\n         * @param obj  the object\n         * @return the minimum frequency of the object\n         */\n        public final int min(final Object obj) {\n            return Math.min(freqA(obj), freqB(obj));\n        }\n    }\n\n    /**\n     * Wraps another object and uses the provided Equator to implement\n     * {@link #equals(Object)} and {@link #hashCode()}.\n     * <p>\n     * This class can be used to store objects into a Map.\n     * </p>\n     *\n     * @param <O>  the element type\n     * @since 4.0\n     */\n    private static final class EquatorWrapper<O> {\n        private final Equator<? super O> equator;\n        private final O object;\n\n        EquatorWrapper(final Equator<? super O> equator, final O object) {\n            this.equator = equator;\n            this.object = object;\n        }\n\n        @Override\n        public boolean equals(final Object obj) {\n            if (!(obj instanceof EquatorWrapper)) {\n                return false;\n            }\n            @SuppressWarnings(\"unchecked\")\n            final EquatorWrapper<O> otherObj = (EquatorWrapper<O>) obj;\n            return equator.equate(object, otherObj.getObject());\n        }\n\n        public O getObject() {\n            return object;\n        }\n\n        @Override\n        public int hashCode() {\n            return equator.hash(object);\n        }\n    }\n\n    /**\n     * Helper class for set-related operations, e.g. union, subtract, intersection.\n     * @param <O>  the element type\n     */\n    private static final class SetOperationCardinalityHelper<O> extends CardinalityHelper<O> implements Iterable<O> {\n\n        /** Contains the unique elements of the two collections. */\n        private final Set<O> elements;\n\n        /** Output collection. */\n        private final List<O> newList;\n\n        /**\n         * Create a new set operation helper from the two collections.\n         * @param a  the first collection\n         * @param b  the second collection\n         */\n        SetOperationCardinalityHelper(final Iterable<? extends O> a, final Iterable<? extends O> b) {\n            super(a, b);\n            elements = new HashSet<>();\n            addAll(elements, a);\n            addAll(elements, b);\n            // the resulting list must contain at least each unique element, but may grow\n            newList = new ArrayList<>(elements.size());\n        }\n\n        @Override\n        public Iterator<O> iterator() {\n            return elements.iterator();\n        }\n\n        /**\n         * Returns the resulting collection.\n         * @return the result\n         */\n        public Collection<O> list() {\n            return newList;\n        }\n\n        /**\n         * Add the object {@code count} times to the result collection.\n         * @param obj  the object to add\n         * @param count  the count\n         */\n        public void setCardinality(final O obj, final int count) {\n            for (int i = 0; i < count; i++) {\n                newList.add(obj);\n            }\n        }\n\n    }\n\n    /**\n     * The index value when an element is not found in a collection or array: {@code -1}.\n     *\n     * @since 4.5.0\n     */\n    public static final int INDEX_NOT_FOUND = -1;\n    /**\n     * Default prefix used while converting an Iterator to its String representation.\n     *\n     * @since 4.5.0\n     */\n    public static final String DEFAULT_TOSTRING_PREFIX = \"[\";\n\n    /**\n     * Default suffix used while converting an Iterator to its String representation.\n     *\n     * @since 4.5.0\n     */\n    public static final String DEFAULT_TOSTRING_SUFFIX = \"]\";\n\n    /**\n     * A String for Colon  (\":\").\n     *\n     * @since 4.5.0\n     */\n    public static final String COLON = \":\";\n\n    /**\n     * A String for Comma (\",\").\n     *\n     * @since 4.5.0\n     */\n    public static final String COMMA = \",\";\n\n    /**\n     * An empty unmodifiable collection.\n     * The JDK provides empty Set and List implementations which could be used for\n     * this purpose. However they could be cast to Set or List which might be\n     * undesirable. This implementation only implements Collection.\n     */\n    @SuppressWarnings(\"rawtypes\") // we deliberately use the raw type here\n    public static final Collection EMPTY_COLLECTION = Collections.emptyList();\n\n    /**\n     * Adds all elements in the array to the given collection.\n     *\n     * @param <C>  the type of object the {@link Collection} contains\n     * @param collection  the collection to add to, must not be null\n     * @param elements  the array of elements to add, must not be null\n     * @return {@code true} if the collection was changed, {@code false} otherwise\n     * @throws NullPointerException if the collection or elements is null\n     */\n    public static <C> boolean addAll(final Collection<C> collection, final C... elements) {\n        Objects.requireNonNull(collection, \"collection\");\n        Objects.requireNonNull(elements, \"elements\");\n        boolean changed = false;\n        for (final C element : elements) {\n            changed |= collection.add(element);\n        }\n        return changed;\n    }\n\n    /**\n     * Adds all elements in the enumeration to the given collection.\n     *\n     * @param <C>  the type of object the {@link Collection} contains\n     * @param collection  the collection to add to, must not be null\n     * @param enumeration  the enumeration of elements to add, must not be null\n     * @return {@code true} if the collections was changed, {@code false} otherwise\n     * @throws NullPointerException if the collection or enumeration is null\n     */\n    public static <C> boolean addAll(final Collection<C> collection, final Enumeration<? extends C> enumeration) {\n        Objects.requireNonNull(collection, \"collection\");\n        Objects.requireNonNull(enumeration, \"enumeration\");\n        boolean changed = false;\n        while (enumeration.hasMoreElements()) {\n            changed |= collection.add(enumeration.nextElement());\n        }\n        return changed;\n    }\n\n    /**\n     * Adds all elements in the {@link Iterable} to the given collection. If the\n     * {@link Iterable} is a {@link Collection} then it is cast and will be\n     * added using {@link Collection#addAll(Collection)} instead of iterating.\n     *\n     * @param <C>  the type of object the {@link Collection} contains\n     * @param collection  the collection to add to, must not be null\n     * @param iterable  the iterable of elements to add, must not be null\n     * @return a boolean indicating whether the collection has changed or not.\n     * @throws NullPointerException if the collection or iterable is null\n     */\n    public static <C> boolean addAll(final Collection<C> collection, final Iterable<? extends C> iterable) {\n        Objects.requireNonNull(collection, \"collection\");\n        Objects.requireNonNull(iterable, \"iterable\");\n        if (iterable instanceof Collection<?>) {\n            return collection.addAll((Collection<? extends C>) iterable);\n        }\n        return addAll(collection, iterable.iterator());\n    }\n\n    /**\n     * Adds all elements in the iteration to the given collection.\n     *\n     * @param <C>  the type of object the {@link Collection} contains\n     * @param collection  the collection to add to, must not be null\n     * @param iterator  the iterator of elements to add, must not be null\n     * @return a boolean indicating whether the collection has changed or not.\n     * @throws NullPointerException if the collection or iterator is null\n     */\n    public static <C> boolean addAll(final Collection<C> collection, final Iterator<? extends C> iterator) {\n        Objects.requireNonNull(collection, \"collection\");\n        Objects.requireNonNull(iterator, \"iterator\");\n        boolean changed = false;\n        while (iterator.hasNext()) {\n            changed |= collection.add(iterator.next());\n        }\n        return changed;\n    }\n\n    /**\n     * Adds an element to the collection unless the element is null.\n     *\n     * @param <T>  the type of object the {@link Collection} contains\n     * @param collection  the collection to add to, must not be null\n     * @param object  the object to add, if null it will not be added\n     * @return true if the collection changed\n     * @throws NullPointerException if the collection is null\n     * @since 3.2\n     */\n    public static <T> boolean addIgnoreNull(final Collection<T> collection, final T object) {\n        Objects.requireNonNull(collection, \"collection\");\n        return object != null && collection.add(object);\n    }\n\n    /**\n     * Returns the number of occurrences of <em>obj</em> in <em>coll</em>.\n     *\n     * @param obj the object to find the cardinality of\n     * @param collection the {@link Iterable} to search\n     * @param <O> the type of object that the {@link Iterable} may contain.\n     * @return the number of occurrences of obj in coll\n     * @throws NullPointerException if collection is null\n     * @deprecated since 4.1, use {@link IterableUtils#frequency(Iterable, Object)} instead.\n     *   Be aware that the order of parameters has changed.\n     */\n    @Deprecated\n    public static <O> int cardinality(final O obj, final Iterable<? super O> collection) {\n        return IterableUtils.frequency(Objects.requireNonNull(collection, \"collection\"), obj);\n    }\n\n    /**\n     * Ensures an index is not negative.\n     * @param index the index to check.\n     * @throws IndexOutOfBoundsException if the index is negative.\n     */\n    static void checkIndexBounds(final int index) {\n        if (index < 0) {\n            throw new IndexOutOfBoundsException(\"Index cannot be negative: \" + index);\n        }\n    }\n\n    /**\n     * Merges two sorted Collections, a and b, into a single, sorted List\n     * such that the natural ordering of the elements is retained.\n     * <p>\n     * Uses the standard O(n) merge algorithm for combining two sorted lists.\n     * </p>\n     *\n     * @param <O>  the element type\n     * @param a  the first collection, must not be null\n     * @param b  the second collection, must not be null\n     * @return a new sorted List, containing the elements of Collection a and b\n     * @throws NullPointerException if either collection is null\n     * @since 4.0\n     */\n    public static <O extends Comparable<? super O>> List<O> collate(final Iterable<? extends O> a,\n                                                                    final Iterable<? extends O> b) {\n        return collate(a, b, ComparatorUtils.<O>naturalComparator(), true);\n    }\n\n    /**\n     * Merges two sorted Collections, a and b, into a single, sorted List\n     * such that the natural ordering of the elements is retained.\n     * <p>\n     * Uses the standard O(n) merge algorithm for combining two sorted lists.\n     * </p>\n     *\n     * @param <O>  the element type\n     * @param a  the first collection, must not be null\n     * @param b  the second collection, must not be null\n     * @param includeDuplicates  if {@code true} duplicate elements will be retained, otherwise\n     *   they will be removed in the output collection\n     * @return a new sorted List, containing the elements of Collection a and b\n     * @throws NullPointerException if either collection is null\n     * @since 4.0\n     */\n    public static <O extends Comparable<? super O>> List<O> collate(final Iterable<? extends O> a,\n                                                                    final Iterable<? extends O> b,\n                                                                    final boolean includeDuplicates) {\n        return collate(a, b, ComparatorUtils.<O>naturalComparator(), includeDuplicates);\n    }\n\n    /**\n     * Merges two sorted Collections, a and b, into a single, sorted List\n     * such that the ordering of the elements according to Comparator c is retained.\n     * <p>\n     * Uses the standard O(n) merge algorithm for combining two sorted lists.\n     * </p>\n     *\n     * @param <O>  the element type\n     * @param a  the first collection, must not be null\n     * @param b  the second collection, must not be null\n     * @param c  the comparator to use for the merge.\n     * @return a new sorted List, containing the elements of Collection a and b\n     * @throws NullPointerException if either collection or the comparator is null\n     * @since 4.0\n     */\n    public static <O> List<O> collate(final Iterable<? extends O> a, final Iterable<? extends O> b,\n                                      final Comparator<? super O> c) {\n        return collate(a, b, c, true);\n    }\n\n    /**\n     * Merges two sorted Collections, a and b, into a single, sorted List\n     * such that the ordering of the elements according to Comparator c is retained.\n     * <p>\n     * Uses the standard O(n) merge algorithm for combining two sorted lists.\n     * </p>\n     *\n     * @param <O>  the element type\n     * @param iterableA  the first collection, must not be null\n     * @param iterableB  the second collection, must not be null\n     * @param comparator  the comparator to use for the merge.\n     * @param includeDuplicates  if {@code true} duplicate elements will be retained, otherwise\n     *   they will be removed in the output collection\n     * @return a new sorted List, containing the elements of Collection a and b\n     * @throws NullPointerException if either collection or the comparator is null\n     * @since 4.0\n     */\n    public static <O> List<O> collate(final Iterable<? extends O> iterableA, final Iterable<? extends O> iterableB,\n                                      final Comparator<? super O> comparator, final boolean includeDuplicates) {\n\n        Objects.requireNonNull(iterableA, \"iterableA\");\n        Objects.requireNonNull(iterableB, \"iterableB\");\n        Objects.requireNonNull(comparator, \"comparator\");\n\n        // if both Iterables are a Collection, we can estimate the size\n        final int totalSize = iterableA instanceof Collection<?> && iterableB instanceof Collection<?> ?\n                Math.max(1, ((Collection<?>) iterableA).size() + ((Collection<?>) iterableB).size()) : 10;\n\n        final Iterator<O> iterator = new CollatingIterator<>(comparator, iterableA.iterator(), iterableB.iterator());\n        if (includeDuplicates) {\n            return IteratorUtils.toList(iterator, totalSize);\n        }\n        final ArrayList<O> mergedList = new ArrayList<>(totalSize);\n\n        O lastItem = null;\n        while (iterator.hasNext()) {\n            final O item = iterator.next();\n            if (lastItem == null || !lastItem.equals(item)) {\n                mergedList.add(item);\n            }\n            lastItem = item;\n        }\n\n        mergedList.trimToSize();\n        return mergedList;\n    }\n\n    /**\n     * Transforms all elements from input collection with the given transformer\n     * and adds them to the output collection.\n     * <p>\n     * If the input collection or transformer is null, there is no change to the\n     * output collection.\n     * </p>\n     *\n     * @param <I>  the type of object in the input collection\n     * @param <O>  the type of object in the output collection\n     * @param <R>  the type of the output collection\n     * @param inputCollection  the collection to get the input from, may be null\n     * @param transformer  the transformer to use, may be null\n     * @param outputCollection  the collection to output into, may not be null if inputCollection\n     *   and transformer are not null\n     * @return the output collection with the transformed input added\n     * @throws NullPointerException if the outputCollection is null and both, inputCollection and\n     *   transformer are not null\n     */\n    public static <I, O, R extends Collection<? super O>> R collect(final Iterable<? extends I> inputCollection,\n            final Transformer<? super I, ? extends O> transformer, final R outputCollection) {\n        if (inputCollection != null) {\n            return collect(inputCollection.iterator(), transformer, outputCollection);\n        }\n        return outputCollection;\n    }\n\n    /**\n     * Returns a new Collection containing all elements of the input collection\n     * transformed by the given transformer.\n     * <p>\n     * If the input collection or transformer is null, the result is an empty list.\n     * </p>\n     *\n     * @param <I>  the type of object in the input collection\n     * @param <O>  the type of object in the output collection\n     * @param inputCollection  the collection to get the input from, may not be null\n     * @param transformer  the transformer to use, may be null\n     * @return the transformed result (new list)\n     * @throws NullPointerException if the outputCollection is null and both, inputCollection and\n     *   transformer are not null\n     */\n    public static <I, O> Collection<O> collect(final Iterable<I> inputCollection,\n                                               final Transformer<? super I, ? extends O> transformer) {\n        int size = 0;\n        if (null != inputCollection) {\n            size = inputCollection instanceof Collection<?> ? ((Collection<?>) inputCollection).size() : 0;\n        }\n        final Collection<O> answer = size == 0 ? new ArrayList<>() : new ArrayList<>(size);\n        return collect(inputCollection, transformer, answer);\n    }\n\n    /**\n     * Transforms all elements from the input iterator with the given transformer\n     * and adds them to the output collection.\n     * <p>\n     * If the input iterator or transformer is null, there is no change to the\n     * output collection.\n     * </p>\n     *\n     * @param <I>  the type of object in the input collection\n     * @param <O>  the type of object in the output collection\n     * @param <R>  the type of the output collection\n     * @param inputIterator  the iterator to get the input from, may be null\n     * @param transformer  the transformer to use, may be null\n     * @param outputCollection  the collection to output into, may not be null if inputIterator\n     *   and transformer are not null\n     * @return the outputCollection with the transformed input added\n     * @throws NullPointerException if the output collection is null and both, inputIterator and\n     *   transformer are not null\n     */\n    public static <I, O, R extends Collection<? super O>> R collect(final Iterator<? extends I> inputIterator,\n            final Transformer<? super I, ? extends O> transformer, final R outputCollection) {\n        if (inputIterator != null && transformer != null) {\n            while (inputIterator.hasNext()) {\n                final I item = inputIterator.next();\n                final O value = transformer.apply(item);\n                outputCollection.add(value);\n            }\n        }\n        return outputCollection;\n    }\n\n    /**\n     * Transforms all elements from the input iterator with the given transformer\n     * and adds them to the output collection.\n     * <p>\n     * If the input iterator or transformer is null, the result is an empty list.\n     * </p>\n     *\n     * @param <I>  the type of object in the input collection\n     * @param <O>  the type of object in the output collection\n     * @param inputIterator  the iterator to get the input from, may be null\n     * @param transformer  the transformer to use, may be null\n     * @return the transformed result (new list)\n     */\n    public static <I, O> Collection<O> collect(final Iterator<I> inputIterator,\n                                               final Transformer<? super I, ? extends O> transformer) {\n        return collect(inputIterator, transformer, new ArrayList<>());\n    }\n\n    /**\n     * Returns {@code true} iff all elements of {@code coll2} are also contained\n     * in {@code coll1}. The cardinality of values in {@code coll2} is not taken into account,\n     * which is the same behavior as {@link Collection#containsAll(Collection)}.\n     * <p>\n     * In other words, this method returns {@code true} iff the\n     * {@link #intersection} of <em>coll1</em> and <em>coll2</em> has the same cardinality as\n     * the set of unique values from {@code coll2}. In case {@code coll2} is empty, {@code true}\n     * will be returned.\n     * </p>\n     * <p>\n     * This method is intended as a replacement for {@link Collection#containsAll(Collection)}\n     * with a guaranteed runtime complexity of {@code O(n + m)}. Depending on the type of\n     * {@link Collection} provided, this method will be much faster than calling\n     * {@link Collection#containsAll(Collection)} instead, though this will come at the\n     * cost of an additional space complexity O(n).\n     * </p>\n     *\n     * @param coll1  the first collection, must not be null\n     * @param coll2  the second collection, must not be null\n     * @return {@code true} iff the intersection of the collections has the same cardinality\n     *   as the set of unique elements from the second collection\n     * @throws NullPointerException if coll1 or coll2 is null\n     * @since 4.0\n     */\n    public static boolean containsAll(final Collection<?> coll1, final Collection<?> coll2) {\n        Objects.requireNonNull(coll1, \"coll1\");\n        Objects.requireNonNull(coll2, \"coll2\");\n        if (coll2.isEmpty()) {\n            return true;\n        }\n        final Set<Object> elementsAlreadySeen = new HashSet<>();\n        for (final Object nextElement : coll2) {\n            if (elementsAlreadySeen.contains(nextElement)) {\n                continue;\n            }\n\n            boolean foundCurrentElement = false;\n            for (final Object p : coll1) {\n                elementsAlreadySeen.add(p);\n                if (Objects.equals(nextElement, p)) {\n                    foundCurrentElement = true;\n                    break;\n                }\n            }\n\n            if (!foundCurrentElement) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns {@code true} iff at least one element is in both collections.\n     * <p>\n     * In other words, this method returns {@code true} iff the\n     * {@link #intersection} of <em>coll1</em> and <em>coll2</em> is not empty.\n     * </p>\n     *\n     * @param coll1  the first collection, must not be null\n     * @param coll2  the second collection, must not be null\n     * @return {@code true} iff the intersection of the collections is non-empty\n     * @throws NullPointerException if coll1 or coll2 is null\n     * @since 2.1\n     * @see #intersection\n     */\n    public static boolean containsAny(final Collection<?> coll1, final Collection<?> coll2) {\n        Objects.requireNonNull(coll1, \"coll1\");\n        Objects.requireNonNull(coll2, \"coll2\");\n        if (coll1.size() < coll2.size()) {\n            for (final Object aColl1 : coll1) {\n                if (coll2.contains(aColl1)) {\n                    return true;\n                }\n            }\n        } else {\n            for (final Object aColl2 : coll2) {\n                if (coll1.contains(aColl2)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Returns {@code true} iff at least one element is in both collections.\n     * <p>\n     * In other words, this method returns {@code true} iff the\n     * {@link #intersection} of <em>coll1</em> and <em>coll2</em> is not empty.\n     * </p>\n     *\n     * @param <T> the type of object to lookup in {@code coll1}.\n     * @param coll1  the first collection, must not be null\n     * @param coll2  the second collection, must not be null\n     * @return {@code true} iff the intersection of the collections is non-empty\n     * @throws NullPointerException if coll1 or coll2 is null\n     * @since 4.2\n     * @see #intersection\n     */\n    public static <T> boolean containsAny(final Collection<?> coll1, @SuppressWarnings(\"unchecked\") final T... coll2) {\n        Objects.requireNonNull(coll1, \"coll1\");\n        Objects.requireNonNull(coll2, \"coll2\");\n        if (coll1.size() < coll2.length) {\n            for (final Object aColl1 : coll1) {\n                if (ArrayUtils.contains(coll2, aColl1)) {\n                    return true;\n                }\n            }\n        } else {\n            for (final Object aColl2 : coll2) {\n                if (coll1.contains(aColl2)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Counts the number of elements in the input collection that match the\n     * predicate.\n     * <p>\n     * A {@code null} collection or predicate matches no elements.\n     * </p>\n     *\n     * @param <C>  the type of object the {@link Iterable} contains\n     * @param input  the {@link Iterable} to get the input from, may be null\n     * @param predicate  the predicate to use, may be null\n     * @return the number of matches for the predicate in the collection\n     * @deprecated since 4.1, use {@link IterableUtils#countMatches(Iterable, Predicate)} instead\n     */\n    @Deprecated\n    public static <C> int countMatches(final Iterable<C> input, final Predicate<? super C> predicate) {\n        return predicate == null ? 0 : (int) IterableUtils.countMatches(input, predicate);\n    }\n\n    /**\n     * Returns a {@link Collection} containing the exclusive disjunction\n     * (symmetric difference) of the given {@link Iterable}s.\n     * <p>\n     * The cardinality of each element <em>e</em> in the returned\n     * {@link Collection} will be equal to\n     * <code>max(cardinality(<em>e</em>,<em>a</em>),cardinality(<em>e</em>,<em>b</em>)) - min(cardinality(<em>e</em>,<em>a</em>),\n     * cardinality(<em>e</em>,<em>b</em>))</code>.\n     * </p>\n     * <p>\n     * This is equivalent to\n     * {@code {@link #subtract subtract}({@link #union union(a,b)},{@link #intersection intersection(a,b)})}\n     * or\n     * {@code {@link #union union}({@link #subtract subtract(a,b)},{@link #subtract subtract(b,a)})}.\n     * </p>\n     *\n     * @param a the first collection, must not be null\n     * @param b the second collection, must not be null\n     * @param <O> the generic type that is able to represent the types contained\n     *        in both input collections.\n     * @return the symmetric difference of the two collections\n     * @throws NullPointerException if either collection is null\n     */\n    public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b) {\n        Objects.requireNonNull(a, \"a\");\n        Objects.requireNonNull(b, \"b\");\n        final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<>(a, b);\n        for (final O obj : helper) {\n            helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n        }\n        return helper.list();\n    }\n\n    /**\n     * Returns the immutable EMPTY_COLLECTION with generic type safety.\n     *\n     * @see #EMPTY_COLLECTION\n     * @since 4.0\n     * @param <T> the element type\n     * @return immutable empty collection\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty collection is compatible with any type\n    public static <T> Collection<T> emptyCollection() {\n        return EMPTY_COLLECTION;\n    }\n\n    /**\n     * Returns an immutable empty collection if the argument is {@code null},\n     * or the argument itself otherwise.\n     *\n     * @param <T> the element type\n     * @param collection the collection, possibly {@code null}\n     * @return an empty collection if the argument is {@code null}\n     */\n    public static <T> Collection<T> emptyIfNull(final Collection<T> collection) {\n        return collection == null ? emptyCollection() : collection;\n    }\n\n    /**\n     * Answers true if a predicate is true for at least one element of a\n     * collection.\n     * <p>\n     * A {@code null} collection or predicate returns false.\n     * </p>\n     *\n     * @param <C>  the type of object the {@link Iterable} contains\n     * @param input  the {@link Iterable} to get the input from, may be null\n     * @param predicate  the predicate to use, may be null\n     * @return true if at least one element of the collection matches the predicate\n     * @deprecated since 4.1, use {@link IterableUtils#matchesAny(Iterable, Predicate)} instead\n     */\n    @Deprecated\n    public static <C> boolean exists(final Iterable<C> input, final Predicate<? super C> predicate) {\n        return predicate != null && IterableUtils.matchesAny(input, predicate);\n    }\n\n    /**\n     * Extract the lone element of the specified Collection.\n     *\n     * @param <E> collection type\n     * @param collection to read\n     * @return sole member of collection\n     * @throws NullPointerException if collection is null\n     * @throws IllegalArgumentException if collection is empty or contains more than one element\n     * @since 4.0\n     */\n    public static <E> E extractSingleton(final Collection<E> collection) {\n        Objects.requireNonNull(collection, \"collection\");\n        if (collection.size() != 1) {\n            throw new IllegalArgumentException(\"Can extract singleton only when collection size == 1\");\n        }\n        return collection.iterator().next();\n    }\n\n    /**\n     * Filter the collection by applying a Predicate to each element. If the\n     * predicate returns false, remove the element.\n     * <p>\n     * If the input collection or predicate is null, there is no change made.\n     * </p>\n     *\n     * @param <T>  the type of object the {@link Iterable} contains\n     * @param collection  the collection to get the input from, may be null\n     * @param predicate  the predicate to use as a filter, may be null\n     * @return true if the collection is modified by this call, false otherwise.\n     */\n    public static <T> boolean filter(final Iterable<T> collection, final Predicate<? super T> predicate) {\n        boolean result = false;\n        if (collection != null && predicate != null) {\n            for (final Iterator<T> it = collection.iterator(); it.hasNext();) {\n                if (!predicate.test(it.next())) {\n                    it.remove();\n                    result = true;\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Filter the collection by applying a Predicate to each element. If the\n     * predicate returns true, remove the element.\n     * <p>\n     * This is equivalent to {@code filter(collection, PredicateUtils.notPredicate(predicate))}\n     * if predicate is != null.\n     * </p>\n     * <p>\n     * If the input collection or predicate is null, there is no change made.\n     * </p>\n     *\n     * @param <T>  the type of object the {@link Iterable} contains\n     * @param collection  the collection to get the input from, may be null\n     * @param predicate  the predicate to use as a filter, may be null\n     * @return true if the collection is modified by this call, false otherwise.\n     */\n    public static <T> boolean filterInverse(final Iterable<T> collection, final Predicate<? super T> predicate) {\n        return filter(collection, predicate == null ? null : PredicateUtils.notPredicate(predicate));\n    }\n\n    /**\n     * Finds the first element in the given collection which matches the given predicate.\n     * <p>\n     * If the input collection or predicate is null, or no element of the collection\n     * matches the predicate, null is returned.\n     * </p>\n     *\n     * @param <T>  the type of object the {@link Iterable} contains\n     * @param collection  the collection to search, may be null\n     * @param predicate  the predicate to use, may be null\n     * @return the first element of the collection which matches the predicate or null if none could be found\n     * @deprecated since 4.1, use {@link IterableUtils#find(Iterable, Predicate)} instead\n     */\n    @Deprecated\n    public static <T> T find(final Iterable<T> collection, final Predicate<? super T> predicate) {\n        return predicate != null ? IterableUtils.find(collection, predicate) : null;\n    }\n\n    /**\n     * Executes the given closure on each but the last element in the collection.\n     * <p>\n     * If the input collection or closure is null, there is no change made.\n     * </p>\n     *\n     * @param <T>  the type of object the {@link Iterable} contains\n     * @param <C>  the closure type\n     * @param collection  the collection to get the input from, may be null\n     * @param closure  the closure to perform, may be null\n     * @return the last element in the collection, or null if either collection or closure is null\n     * @since 4.0\n     * @deprecated since 4.1, use {@link IterableUtils#forEachButLast(Iterable, Closure)} instead\n     */\n    @Deprecated\n    public static <T, C extends Closure<? super T>> T forAllButLastDo(final Iterable<T> collection,\n                                                                      final C closure) {\n        return closure != null ? IterableUtils.forEachButLast(collection, closure) : null;\n    }\n\n    /**\n     * Executes the given closure on each but the last element in the collection.\n     * <p>\n     * If the input collection or closure is null, there is no change made.\n     * </p>\n     *\n     * @param <T>  the type of object the {@link Collection} contains\n     * @param <C>  the closure type\n     * @param iterator  the iterator to get the input from, may be null\n     * @param closure  the closure to perform, may be null\n     * @return the last element in the collection, or null if either iterator or closure is null\n     * @since 4.0\n     * @deprecated since 4.1, use {@link IteratorUtils#forEachButLast(Iterator, Closure)} instead\n     */\n    @Deprecated\n    public static <T, C extends Closure<? super T>> T forAllButLastDo(final Iterator<T> iterator, final C closure) {\n        return closure != null ? IteratorUtils.forEachButLast(iterator, closure) : null;\n    }\n\n    /**\n     * Executes the given closure on each element in the collection.\n     * <p>\n     * If the input collection or closure is null, there is no change made.\n     * </p>\n     *\n     * @param <T>  the type of object the {@link Iterable} contains\n     * @param <C>  the closure type\n     * @param collection  the collection to get the input from, may be null\n     * @param closure  the closure to perform, may be null\n     * @return closure\n     * @deprecated since 4.1, use {@link IterableUtils#forEach(Iterable, Closure)} instead\n     */\n    @Deprecated\n    public static <T, C extends Closure<? super T>> C forAllDo(final Iterable<T> collection, final C closure) {\n        if (closure != null) {\n            IterableUtils.forEach(collection, closure);\n        }\n        return closure;\n    }\n\n    /**\n     * Executes the given closure on each element in the collection.\n     * <p>\n     * If the input collection or closure is null, there is no change made.\n     * </p>\n     *\n     * @param <T>  the type of object the {@link Iterator} contains\n     * @param <C>  the closure type\n     * @param iterator  the iterator to get the input from, may be null\n     * @param closure  the closure to perform, may be null\n     * @return closure\n     * @since 4.0\n     * @deprecated since 4.1, use {@link IteratorUtils#forEach(Iterator, Closure)} instead\n     */\n    @Deprecated\n    public static <T, C extends Closure<? super T>> C forAllDo(final Iterator<T> iterator, final C closure) {\n        if (closure != null) {\n            IteratorUtils.forEach(iterator, closure);\n        }\n        return closure;\n    }\n\n    /**\n     * Returns the {@code index}-th value in the {@code iterable}'s {@link Iterator}, throwing\n     * {@code IndexOutOfBoundsException} if there is no such element.\n     * <p>\n     * If the {@link Iterable} is a {@link List}, then it will use {@link List#get(int)}.\n     * </p>\n     *\n     * @param iterable  the {@link Iterable} to get a value from\n     * @param index  the index to get\n     * @param <T> the type of object in the {@link Iterable}.\n     * @return the object at the specified index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     * @deprecated since 4.1, use {@code IterableUtils.get(Iterable, int)} instead\n     */\n    @Deprecated\n    public static <T> T get(final Iterable<T> iterable, final int index) {\n        Objects.requireNonNull(iterable, \"iterable\");\n        return IterableUtils.get(iterable, index);\n    }\n\n    /**\n     * Returns the {@code index}-th value in {@link Iterator}, throwing\n     * {@code IndexOutOfBoundsException} if there is no such element.\n     * <p>\n     * The Iterator is advanced to {@code index} (or to the end, if\n     * {@code index} exceeds the number of entries) as a side effect of this method.\n     * </p>\n     *\n     * @param iterator  the iterator to get a value from\n     * @param index  the index to get\n     * @param <T> the type of object in the {@link Iterator}\n     * @return the object at the specified index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     * @throws IllegalArgumentException if the object type is invalid\n     * @throws NullPointerException if iterator is null\n     * @deprecated since 4.1, use {@code IteratorUtils.get(Iterator, int)} instead\n     */\n    @Deprecated\n    public static <T> T get(final Iterator<T> iterator, final int index) {\n        Objects.requireNonNull(iterator, \"iterator\");\n        return IteratorUtils.get(iterator, index);\n    }\n\n    /**\n     * Returns the {@code index}-th {@code Map.Entry} in the {@code map}'s {@code entrySet},\n     * throwing {@code IndexOutOfBoundsException} if there is no such element.\n     *\n     * @param <K>  the key type in the {@link Map}\n     * @param <V>  the value type in the {@link Map}\n     * @param map  the object to get a value from\n     * @param index  the index to get\n     * @return the object at the specified index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public static <K, V> Map.Entry<K, V> get(final Map<K, V> map, final int index) {\n        Objects.requireNonNull(map, \"map\");\n        checkIndexBounds(index);\n        return get(map.entrySet(), index);\n    }\n\n    /**\n     * Returns the {@code index}-th value in {@code object}, throwing\n     * {@code IndexOutOfBoundsException} if there is no such element or\n     * {@code IllegalArgumentException} if {@code object} is not an\n     * instance of one of the supported types.\n     * <p>\n     * The supported types, and associated semantics are:\n     * </p>\n     * <ul>\n     * <li> Map -- the value returned is the {@code Map.Entry} in position\n     *      {@code index} in the map's {@code entrySet} iterator,\n     *      if there is such an entry.</li>\n     * <li> List -- this method is equivalent to the list's get method.</li>\n     * <li> Array -- the {@code index}-th array entry is returned,\n     *      if there is such an entry; otherwise an {@code IndexOutOfBoundsException}\n     *      is thrown.</li>\n     * <li> Collection -- the value returned is the {@code index}-th object\n     *      returned by the collection's default iterator, if there is such an element.</li>\n     * <li> Iterator or Enumeration -- the value returned is the\n     *      {@code index}-th object in the Iterator/Enumeration, if there\n     *      is such an element.  The Iterator/Enumeration is advanced to\n     *      {@code index} (or to the end, if {@code index} exceeds the\n     *      number of entries) as a side effect of this method.</li>\n     * </ul>\n     *\n     * @param object  the object to get a value from\n     * @param index  the index to get\n     * @return the object at the specified index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     * @throws IllegalArgumentException if the object type is invalid\n     */\n    public static Object get(final Object object, final int index) {\n        final int i = index;\n        if (i < 0) {\n            throw new IndexOutOfBoundsException(\"Index cannot be negative: \" + i);\n        }\n        if (object instanceof Map<?, ?>) {\n            final Map<?, ?> map = (Map<?, ?>) object;\n            final Iterator<?> iterator = map.entrySet().iterator();\n            return IteratorUtils.get(iterator, i);\n        }\n        if (object instanceof Object[]) {\n            return ((Object[]) object)[i];\n        }\n        if (object instanceof Iterator<?>) {\n            final Iterator<?> it = (Iterator<?>) object;\n            return IteratorUtils.get(it, i);\n        }\n        if (object instanceof Iterable<?>) {\n            final Iterable<?> iterable = (Iterable<?>) object;\n            return IterableUtils.get(iterable, i);\n        }\n        if (object instanceof Enumeration<?>) {\n            final Enumeration<?> it = (Enumeration<?>) object;\n            return EnumerationUtils.get(it, i);\n        }\n        if (object == null) {\n            throw new IllegalArgumentException(\"Unsupported object type: null\");\n        }\n        try {\n            return Array.get(object, i);\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n\n    /**\n     * Returns a {@link Map} mapping each unique element in the given\n     * {@link Collection} to an {@link Integer} representing the number\n     * of occurrences of that element in the {@link Collection}.\n     * <p>\n     * Only those elements present in the collection will appear as\n     * keys in the map.\n     * </p>\n     *\n     * @param <O>  the type of object in the returned {@link Map}. This is a super type of &lt;I&gt;.\n     * @param coll  the collection to get the cardinality map for, must not be null\n     * @return the populated cardinality map\n     * @throws NullPointerException if coll is null\n     */\n    public static <O> Map<O, Integer> getCardinalityMap(final Iterable<? extends O> coll) {\n        Objects.requireNonNull(coll, \"coll\");\n        final Map<O, Integer> count = new HashMap<>();\n        for (final O obj : coll) {\n            final Integer c = count.get(obj);\n            if (c == null) {\n                count.put(obj, Integer.valueOf(1));\n            } else {\n                count.put(obj, Integer.valueOf(c.intValue() + 1));\n            }\n        }\n        return count;\n    }\n\n    /**\n     * Returns the hash code of the input collection using the hash method of an equator.\n     *\n     * <p>\n     * Returns 0 if the input collection is {@code null}.\n     * </p>\n     *\n     * @param <E>  the element type\n     * @param collection  the input collection\n     * @param equator  the equator used for generate hashCode\n     * @return the hash code of the input collection using the hash method of an equator\n     * @throws NullPointerException if the equator is {@code null}\n     * @since 4.5.0\n     */\n    public static <E> int hashCode(final Collection<? extends E> collection,\n            final Equator<? super E> equator) {\n        Objects.requireNonNull(equator, \"equator\");\n        if (null == collection) {\n            return 0;\n        }\n        int hashCode = 1;\n        for (final E e : collection) {\n            hashCode = 31 * hashCode + equator.hash(e);\n        }\n        return hashCode;\n    }\n\n    /**\n     * Returns a {@link Collection} containing the intersection of the given\n     * {@link Iterable}s.\n     * <p>\n     * The cardinality of each element in the returned {@link Collection} will\n     * be equal to the minimum of the cardinality of that element in the two\n     * given {@link Iterable}s.\n     * </p>\n     *\n     * @param a the first collection, must not be null\n     * @param b the second collection, must not be null\n     * @param <O> the generic type that is able to represent the types contained\n     *        in both input collections.\n     * @return the intersection of the two collections\n     * @throws NullPointerException if either collection is null\n     * @see Collection#retainAll\n     * @see #containsAny\n     */\n    public static <O> Collection<O> intersection(final Iterable<? extends O> a, final Iterable<? extends O> b) {\n        Objects.requireNonNull(a, \"a\");\n        Objects.requireNonNull(b, \"b\");\n        final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<>(a, b);\n        for (final O obj : helper) {\n            helper.setCardinality(obj, helper.min(obj));\n        }\n        return helper.list();\n    }\n\n    /**\n     * Null-safe check if the specified collection is empty.\n     * <p>\n     * Null returns true.\n     * </p>\n     *\n     * @param coll  the collection to check, may be null\n     * @return true if empty or null\n     * @since 3.2\n     */\n    public static boolean isEmpty(final Collection<?> coll) {\n        return coll == null || coll.isEmpty();\n    }\n\n    /**\n     * Returns {@code true} iff the given {@link Collection}s contain\n     * exactly the same elements with exactly the same cardinalities.\n     * <p>\n     * That is, iff the cardinality of <em>e</em> in <em>a</em> is\n     * equal to the cardinality of <em>e</em> in <em>b</em>,\n     * for each element <em>e</em> in <em>a</em> or <em>b</em>.\n     * </p>\n     *\n     * @param a  the first collection, must not be null\n     * @param b  the second collection, must not be null\n     * @return {@code true} iff the collections contain the same elements with the same cardinalities.\n     * @throws NullPointerException if either collection is null\n     */\n    public static boolean isEqualCollection(final Collection<?> a, final Collection<?> b) {\n        return CardinalityHelper.equals(a, b);\n    }\n\n    /**\n     * Returns {@code true} iff the given {@link Collection}s contain\n     * exactly the same elements with exactly the same cardinalities.\n     * <p>\n     * That is, iff the cardinality of <em>e</em> in <em>a</em> is\n     * equal to the cardinality of <em>e</em> in <em>b</em>,\n     * for each element <em>e</em> in <em>a</em> or <em>b</em>.\n     * </p>\n     * <p>\n     * <b>Note:</b> from version 4.1 onwards this method requires the input\n     * collections and equator to be of compatible type (using bounded wildcards).\n     * Providing incompatible arguments (e.g. by casting to their rawtypes)\n     * will result in a {@code ClassCastException} thrown at runtime.\n     * </p>\n     *\n     * @param <E>  the element type\n     * @param a  the first collection, must not be null\n     * @param b  the second collection, must not be null\n     * @param equator  the Equator used for testing equality\n     * @return {@code true} iff the collections contain the same elements with the same cardinalities.\n     * @throws NullPointerException if either collection or equator is null\n     * @since 4.0\n     */\n    public static <E> boolean isEqualCollection(final Collection<? extends E> a,\n                                                final Collection<? extends E> b,\n                                                final Equator<? super E> equator) {\n        Objects.requireNonNull(a, \"a\");\n        Objects.requireNonNull(b, \"b\");\n        Objects.requireNonNull(equator, \"equator\");\n\n        if (a.size() != b.size()) {\n            return false;\n        }\n\n        @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n        final Transformer<E, ?> transformer = input -> new EquatorWrapper(equator, input);\n\n        return isEqualCollection(collect(a, transformer), collect(b, transformer));\n    }\n\n    /**\n     * Returns true if no more elements can be added to the Collection.\n     * <p>\n     * This method uses the {@link BoundedCollection} interface to determine the\n     * full status. If the collection does not implement this interface then\n     * false is returned.\n     * </p>\n     * <p>\n     * The collection does not have to implement this interface directly.\n     * If the collection has been decorated using the decorators subpackage\n     * then these will be removed to access the BoundedCollection.\n     * </p>\n     *\n     * @param collection  the collection to check\n     * @return true if the BoundedCollection is full\n     * @throws NullPointerException if the collection is null\n     */\n    public static boolean isFull(final Collection<? extends Object> collection) {\n        Objects.requireNonNull(collection, \"collection\");\n        if (collection instanceof BoundedCollection) {\n            return ((BoundedCollection<?>) collection).isFull();\n        }\n        try {\n            final BoundedCollection<?> bcoll =\n                    UnmodifiableBoundedCollection.unmodifiableBoundedCollection(collection);\n            return bcoll.isFull();\n        } catch (final IllegalArgumentException ex) {\n            return false;\n        }\n    }\n\n    /**\n     * Null-safe check if the specified collection is not empty.\n     * <p>\n     * Null returns false.\n     * </p>\n     *\n     * @param coll  the collection to check, may be null\n     * @return true if non-null and non-empty\n     * @since 3.2\n     */\n    public static boolean isNotEmpty(final Collection<?> coll) {\n        return !isEmpty(coll);\n    }\n\n    /**\n     * Returns {@code true} iff <em>a</em> is a <em>proper</em> sub-collection of <em>b</em>,\n     * that is, iff the cardinality of <em>e</em> in <em>a</em> is less\n     * than or equal to the cardinality of <em>e</em> in <em>b</em>,\n     * for each element <em>e</em> in <em>a</em>, and there is at least one\n     * element <em>f</em> such that the cardinality of <em>f</em> in <em>b</em>\n     * is strictly greater than the cardinality of <em>f</em> in <em>a</em>.\n     * <p>\n     * The implementation assumes\n     * </p>\n     * <ul>\n     *    <li>{@code a.size()} and {@code b.size()} represent the\n     *    total cardinality of <em>a</em> and <em>b</em>, resp. </li>\n     *    <li>{@code a.size() &lt; Integer.MAXVALUE}</li>\n     * </ul>\n     *\n     * @param a  the first (sub?) collection, must not be null\n     * @param b  the second (super?) collection, must not be null\n     * @return {@code true} iff <em>a</em> is a <em>proper</em> sub-collection of <em>b</em>\n     * @throws NullPointerException if either collection is null\n     * @see #isSubCollection\n     * @see Collection#containsAll\n     */\n    public static boolean isProperSubCollection(final Collection<?> a, final Collection<?> b) {\n        Objects.requireNonNull(a, \"a\");\n        Objects.requireNonNull(b, \"b\");\n        return a.size() < b.size() && isSubCollection(a, b);\n    }\n\n    /**\n     * Returns {@code true} iff <em>a</em> is a sub-collection of <em>b</em>,\n     * that is, iff the cardinality of <em>e</em> in <em>a</em> is less than or\n     * equal to the cardinality of <em>e</em> in <em>b</em>, for each element <em>e</em>\n     * in <em>a</em>.\n     *\n     * @param a the first (sub?) collection, must not be null\n     * @param b the second (super?) collection, must not be null\n     * @return {@code true} iff <em>a</em> is a sub-collection of <em>b</em>\n     * @throws NullPointerException if either collection is null\n     * @see #isProperSubCollection\n     * @see Collection#containsAll\n     */\n    public static boolean isSubCollection(final Collection<?> a, final Collection<?> b) {\n        Objects.requireNonNull(a, \"a\");\n        Objects.requireNonNull(b, \"b\");\n        final CardinalityHelper<Object> helper = new CardinalityHelper<>(a, b);\n        for (final Object obj : a) {\n            if (helper.freqA(obj) > helper.freqB(obj)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Answers true if a predicate is true for every element of a\n     * collection.\n     *\n     * <p>\n     * A {@code null} predicate returns false.\n     * </p>\n     * <p>\n     * A {@code null} or empty collection returns true.\n     * </p>\n     *\n     * @param <C>  the type of object the {@link Iterable} contains\n     * @param input  the {@link Iterable} to get the input from, may be null\n     * @param predicate  the predicate to use, may be null\n     * @return true if every element of the collection matches the predicate or if the\n     * collection is empty, false otherwise\n     * @since 4.0\n     * @deprecated since 4.1, use {@link IterableUtils#matchesAll(Iterable, Predicate)} instead\n     */\n    @Deprecated\n    public static <C> boolean matchesAll(final Iterable<C> input, final Predicate<? super C> predicate) {\n        return predicate != null && IterableUtils.matchesAll(input, predicate);\n    }\n\n    /**\n     * Gets the maximum number of elements that the Collection can contain.\n     * <p>\n     * This method uses the {@link BoundedCollection} interface to determine the\n     * maximum size. If the collection does not implement this interface then\n     * -1 is returned.\n     * </p>\n     * <p>\n     * The collection does not have to implement this interface directly.\n     * If the collection has been decorated using the decorators subpackage\n     * then these will be removed to access the BoundedCollection.\n     * </p>\n     *\n     * @param collection  the collection to check\n     * @return the maximum size of the BoundedCollection, -1 if no maximum size\n     * @throws NullPointerException if the collection is null\n     */\n    public static int maxSize(final Collection<? extends Object> collection) {\n        Objects.requireNonNull(collection, \"collection\");\n        if (collection instanceof BoundedCollection) {\n            return ((BoundedCollection<?>) collection).maxSize();\n        }\n        try {\n            final BoundedCollection<?> bcoll =\n                    UnmodifiableBoundedCollection.unmodifiableBoundedCollection(collection);\n            return bcoll.maxSize();\n        } catch (final IllegalArgumentException ex) {\n            return -1;\n        }\n    }\n\n    /**\n     * Returns a {@link Collection} of all the permutations of the input collection.\n     * <p>\n     * NOTE: the number of permutations of a given collection is equal to n!, where\n     * n is the size of the collection. Thus, the resulting collection will become\n     * <b>very</b> large for collections &gt; 10 (e.g. 10! = 3628800, 15! = 1307674368000).\n     * </p>\n     * <p>\n     * For larger collections it is advised to use a {@link PermutationIterator} to\n     * iterate over all permutations.\n     * </p>\n     *\n     * @see PermutationIterator\n     *\n     * @param <E>  the element type\n     * @param collection  the collection to create permutations for, must not be null\n     * @return an unordered collection of all permutations of the input collection\n     * @throws NullPointerException if collection is null\n     * @since 4.0\n     */\n    public static <E> Collection<List<E>> permutations(final Collection<E> collection) {\n        Objects.requireNonNull(collection, \"collection\");\n        final PermutationIterator<E> it = new PermutationIterator<>(collection);\n        final Collection<List<E>> result = new ArrayList<>();\n        while (it.hasNext()) {\n            result.add(it.next());\n        }\n        return result;\n    }\n\n    /**\n     * Returns a predicated (validating) collection backed by the given collection.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to the collection.\n     * Trying to add an invalid object results in an IllegalArgumentException.\n     * It is important not to use the original collection after invoking this method,\n     * as it is a backdoor for adding invalid objects.\n     * </p>\n     *\n     * @param <C> the type of objects in the Collection.\n     * @param collection  the collection to predicate, must not be null\n     * @param predicate  the predicate for the collection, must not be null\n     * @return a predicated collection backed by the given collection\n     * @throws NullPointerException if the collection or predicate is null\n     */\n    public static <C> Collection<C> predicatedCollection(final Collection<C> collection,\n                                                         final Predicate<? super C> predicate) {\n        Objects.requireNonNull(collection, \"collection\");\n        Objects.requireNonNull(predicate, \"predicate\");\n        return PredicatedCollection.predicatedCollection(collection, predicate);\n    }\n\n    /**\n     * Removes the elements in {@code remove} from {@code collection}. That is, this\n     * method returns a collection containing all the elements in {@code c}\n     * that are not in {@code remove}. The cardinality of an element {@code e}\n     * in the returned collection is the same as the cardinality of {@code e}\n     * in {@code collection} unless {@code remove} contains {@code e}, in which\n     * case the cardinality is zero. This method is useful if you do not wish to modify\n     * the collection {@code c} and thus cannot call {@code collection.removeAll(remove);}.\n     * <p>\n     * This implementation iterates over {@code collection}, checking each element in\n     * turn to see if it's contained in {@code remove}. If it's not contained, it's added\n     * to the returned list. As a consequence, it is advised to use a collection type for\n     * {@code remove} that provides a fast (e.g. O(1)) implementation of\n     * {@link Collection#contains(Object)}.\n     * </p>\n     *\n     * @param <E>  the type of object the {@link Collection} contains\n     * @param collection  the collection from which items are removed (in the returned collection)\n     * @param remove  the items to be removed from the returned {@code collection}\n     * @return a {@code Collection} containing all the elements of {@code collection} except\n     * any elements that also occur in {@code remove}.\n     * @throws NullPointerException if either parameter is null\n     * @since 4.0 (method existed in 3.2 but was completely broken)\n     */\n    public static <E> Collection<E> removeAll(final Collection<E> collection, final Collection<?> remove) {\n        return ListUtils.removeAll(collection, remove);\n    }\n\n    /**\n     * Removes all elements in {@code remove} from {@code collection}.\n     * That is, this method returns a collection containing all the elements in\n     * {@code collection} that are not in {@code remove}. The\n     * cardinality of an element {@code e} in the returned collection is\n     * the same as the cardinality of {@code e} in {@code collection}\n     * unless {@code remove} contains {@code e}, in which case the\n     * cardinality is zero. This method is useful if you do not wish to modify\n     * the collection {@code c} and thus cannot call\n     * {@code collection.removeAll(remove)}.\n     * <p>\n     * Moreover this method uses an {@link Equator} instead of\n     * {@link Object#equals(Object)} to determine the equality of the elements\n     * in {@code collection} and {@code remove}. Hence this method is\n     * useful in cases where the equals behavior of an object needs to be\n     * modified without changing the object itself.\n     * </p>\n     *\n     * @param <E> the type of object the {@link Collection} contains\n     * @param collection the collection from which items are removed (in the returned collection)\n     * @param remove the items to be removed from the returned collection\n     * @param equator the Equator used for testing equality\n     * @return a {@code Collection} containing all the elements of {@code collection}\n     * except any element that if equal according to the {@code equator}\n     * @throws NullPointerException if any of the parameters is null\n     * @since 4.1\n     */\n    public static <E> Collection<E> removeAll(final Iterable<E> collection,\n                                              final Iterable<? extends E> remove,\n                                              final Equator<? super E> equator) {\n        Objects.requireNonNull(collection, \"collection\");\n        Objects.requireNonNull(remove, \"remove\");\n        Objects.requireNonNull(equator, \"equator\");\n        final Transformer<E, EquatorWrapper<E>> transformer = input -> new EquatorWrapper<>(equator, input);\n\n        final Set<EquatorWrapper<E>> removeSet =\n                collect(remove, transformer, new HashSet<>());\n\n        final List<E> list = new ArrayList<>();\n        for (final E element : collection) {\n            if (!removeSet.contains(new EquatorWrapper<>(equator, element))) {\n                list.add(element);\n            }\n        }\n        return list;\n    }\n\n    /**\n     * Removes the specified number of elements from the start index in the collection and returns them.\n     * This method modifies the input collections.\n     *\n     * @param <E>  the type of object the {@link Collection} contains\n     * @param input  the collection will be operated, can't be null\n     * @param startIndex  the start index (inclusive) to remove element, can't be less than 0\n     * @param count  the specified number to remove, can't be less than 1\n     * @return collection of elements that removed from the input collection\n     * @throws NullPointerException if input is null\n     * @since 4.5.0\n     */\n    public static <E> Collection<E> removeCount(final Collection<E> input, int startIndex, int count) {\n        Objects.requireNonNull(input, \"input\");\n        if (startIndex < 0) {\n            throw new IndexOutOfBoundsException(\"The start index can't be less than 0.\");\n        }\n        if (count < 0) {\n            throw new IndexOutOfBoundsException(\"The count can't be less than 0.\");\n        }\n        if (input.size() < startIndex + count) {\n            throw new IndexOutOfBoundsException(\n                    \"The sum of start index and count can't be greater than the size of collection.\");\n        }\n\n        final Collection<E> result = new ArrayList<>(count);\n        final Iterator<E> iterator = input.iterator();\n        while (count > 0) {\n            if (startIndex > 0) {\n                startIndex -= 1;\n                iterator.next();\n                continue;\n            }\n            count -= 1;\n            result.add(iterator.next());\n            iterator.remove();\n        }\n        return result;\n    }\n\n    /**\n     * Removes elements whose index are between startIndex, inclusive and endIndex,\n     * exclusive in the collection and returns them.\n     * This method modifies the input collections.\n     *\n     * @param <E>  the type of object the {@link Collection} contains\n     * @param input  the collection will be operated, must not be null\n     * @param startIndex  the start index (inclusive) to remove element, must not be less than 0\n     * @param endIndex  the end index (exclusive) to remove, must not be less than startIndex\n     * @return collection of elements that removed from the input collection\n     * @throws NullPointerException if input is null\n     * @since 4.5.0\n     */\n    public static <E> Collection<E> removeRange(final Collection<E> input, final int startIndex, final int endIndex) {\n        Objects.requireNonNull(input, \"input\");\n        if (endIndex < startIndex) {\n            throw new IllegalArgumentException(\"The end index can't be less than the start index.\");\n        }\n        if (input.size() < endIndex) {\n            throw new IndexOutOfBoundsException(\"The end index can't be greater than the size of collection.\");\n        }\n        return removeCount(input, startIndex, endIndex - startIndex);\n    }\n\n    /**\n     * Returns a collection containing all the elements in {@code collection}\n     * that are also in {@code retain}. The cardinality of an element {@code e}\n     * in the returned collection is the same as the cardinality of {@code e}\n     * in {@code collection} unless {@code retain} does not contain {@code e}, in which\n     * case the cardinality is zero. This method is useful if you do not wish to modify\n     * the collection {@code c} and thus cannot call {@code c.retainAll(retain);}.\n     * <p>\n     * This implementation iterates over {@code collection}, checking each element in\n     * turn to see if it's contained in {@code retain}. If it's contained, it's added\n     * to the returned list. As a consequence, it is advised to use a collection type for\n     * {@code retain} that provides a fast (e.g. O(1)) implementation of\n     * {@link Collection#contains(Object)}.\n     * </p>\n     *\n     * @param <C>  the type of object the {@link Collection} contains\n     * @param collection  the collection whose contents are the target of the #retailAll operation\n     * @param retain  the collection containing the elements to be retained in the returned collection\n     * @return a {@code Collection} containing all the elements of {@code collection}\n     * that occur at least once in {@code retain}.\n     * @throws NullPointerException if either parameter is null\n     * @since 3.2\n     */\n    public static <C> Collection<C> retainAll(final Collection<C> collection, final Collection<?> retain) {\n        Objects.requireNonNull(collection, \"collection\");\n        Objects.requireNonNull(retain, \"retain\");\n        return ListUtils.retainAll(collection, retain);\n    }\n\n    /**\n     * Returns a collection containing all the elements in\n     * {@code collection} that are also in {@code retain}. The\n     * cardinality of an element {@code e} in the returned collection is\n     * the same as the cardinality of {@code e} in {@code collection}\n     * unless {@code retain} does not contain {@code e}, in which case\n     * the cardinality is zero. This method is useful if you do not wish to\n     * modify the collection {@code c} and thus cannot call\n     * {@code c.retainAll(retain);}.\n     * <p>\n     * Moreover this method uses an {@link Equator} instead of\n     * {@link Object#equals(Object)} to determine the equality of the elements\n     * in {@code collection} and {@code retain}. Hence this method is\n     * useful in cases where the equals behavior of an object needs to be\n     * modified without changing the object itself.\n     * </p>\n     *\n     * @param <E> the type of object the {@link Collection} contains\n     * @param collection the collection whose contents are the target of the {@code retainAll} operation\n     * @param retain the collection containing the elements to be retained in the returned collection\n     * @param equator the Equator used for testing equality\n     * @return a {@code Collection} containing all the elements of {@code collection}\n     * that occur at least once in {@code retain} according to the {@code equator}\n     * @throws NullPointerException if any of the parameters is null\n     * @since 4.1\n     */\n    public static <E> Collection<E> retainAll(final Iterable<E> collection,\n                                              final Iterable<? extends E> retain,\n                                              final Equator<? super E> equator) {\n        Objects.requireNonNull(collection, \"collection\");\n        Objects.requireNonNull(retain, \"retain\");\n        Objects.requireNonNull(equator, \"equator\");\n        final Transformer<E, EquatorWrapper<E>> transformer = input -> new EquatorWrapper<>(equator, input);\n\n        final Set<EquatorWrapper<E>> retainSet =\n                collect(retain, transformer, new HashSet<>());\n\n        final List<E> list = new ArrayList<>();\n        for (final E element : collection) {\n            if (retainSet.contains(new EquatorWrapper<>(equator, element))) {\n                list.add(element);\n            }\n        }\n        return list;\n    }\n\n    /**\n     * Reverses the order of the given array.\n     *\n     * @param array  the array to reverse\n     */\n    public static void reverseArray(final Object[] array) {\n        Objects.requireNonNull(array, \"array\");\n        int i = 0;\n        int j = array.length - 1;\n        Object tmp;\n\n        while (j > i) {\n            tmp = array[j];\n            array[j] = array[i];\n            array[i] = tmp;\n            j--;\n            i++;\n        }\n    }\n\n    /**\n     * Selects all elements from input collection which match the given\n     * predicate into an output collection.\n     * <p>\n     * A {@code null} predicate matches no elements.\n     * </p>\n     *\n     * @param <O>  the type of object the {@link Iterable} contains\n     * @param inputCollection  the collection to get the input from, may not be null\n     * @param predicate  the predicate to use, may be null\n     * @return the elements matching the predicate (new list)\n     */\n    public static <O> Collection<O> select(final Iterable<? extends O> inputCollection,\n                                           final Predicate<? super O> predicate) {\n        int size = 0;\n        if (null != inputCollection) {\n            size = inputCollection instanceof Collection<?> ? ((Collection<?>) inputCollection).size() : 0;\n        }\n        final Collection<O> answer = size == 0 ? new ArrayList<>() : new ArrayList<>(size);\n        return select(inputCollection, predicate, answer);\n    }\n\n    /**\n     * Selects all elements from input collection which match the given\n     * predicate and adds them to outputCollection.\n     * <p>\n     * If the input collection or predicate is null, there is no change to the\n     * output collection.\n     * </p>\n     *\n     * @param <O>  the type of object the {@link Iterable} contains\n     * @param <R>  the type of the output {@link Collection}\n     * @param inputCollection  the collection to get the input from, may be null\n     * @param predicate  the predicate to use, may be null\n     * @param outputCollection  the collection to output into, may not be null if the inputCollection\n     *   and predicate or not null\n     * @return the outputCollection\n     */\n    public static <O, R extends Collection<? super O>> R select(final Iterable<? extends O> inputCollection,\n            final Predicate<? super O> predicate, final R outputCollection) {\n\n        if (inputCollection != null && predicate != null) {\n            for (final O item : inputCollection) {\n                if (predicate.test(item)) {\n                    outputCollection.add(item);\n                }\n            }\n        }\n        return outputCollection;\n    }\n\n    /**\n     * Selects all elements from inputCollection into an output and rejected collection,\n     * based on the evaluation of the given predicate.\n     * <p>\n     * Elements matching the predicate are added to the {@code outputCollection},\n     * all other elements are added to the {@code rejectedCollection}.\n     * </p>\n     * <p>\n     * If the input predicate is {@code null}, no elements are added to\n     * {@code outputCollection} or {@code rejectedCollection}.\n     * </p>\n     * <p>\n     * Note: calling the method is equivalent to the following code snippet:\n     * </p>\n     * <pre>\n     *   select(inputCollection, predicate, outputCollection);\n     *   selectRejected(inputCollection, predicate, rejectedCollection);\n     * </pre>\n     *\n     * @param <O>  the type of object the {@link Iterable} contains\n     * @param <R>  the type of the output {@link Collection}\n     * @param inputCollection  the collection to get the input from, may be null\n     * @param predicate  the predicate to use, may be null\n     * @param outputCollection  the collection to output selected elements into, may not be null if the\n     *   inputCollection and predicate are not null\n     * @param rejectedCollection  the collection to output rejected elements into, may not be null if the\n     *   inputCollection or predicate are not null\n     * @return the outputCollection\n     * @since 4.1\n     */\n    public static <O, R extends Collection<? super O>> R select(final Iterable<? extends O> inputCollection,\n            final Predicate<? super O> predicate, final R outputCollection, final R rejectedCollection) {\n\n        if (inputCollection != null && predicate != null) {\n            for (final O element : inputCollection) {\n                if (predicate.test(element)) {\n                    outputCollection.add(element);\n                } else {\n                    rejectedCollection.add(element);\n                }\n            }\n        }\n        return outputCollection;\n    }\n\n    /**\n     * Selects all elements from inputCollection which don't match the given\n     * predicate into an output collection.\n     * <p>\n     * If the input predicate is {@code null}, the result is an empty\n     * list.\n     * </p>\n     *\n     * @param <O>  the type of object the {@link Iterable} contains\n     * @param inputCollection  the collection to get the input from, may not be null\n     * @param predicate  the predicate to use, may be null\n     * @return the elements <b>not</b> matching the predicate (new list)\n     */\n    public static <O> Collection<O> selectRejected(final Iterable<? extends O> inputCollection,\n                                                   final Predicate<? super O> predicate) {\n        int size = 0;\n        if (null != inputCollection) {\n            size = inputCollection instanceof Collection<?> ? ((Collection<?>) inputCollection).size() : 0;\n        }\n        final Collection<O> answer = size == 0 ? new ArrayList<>() : new ArrayList<>(size);\n        return selectRejected(inputCollection, predicate, answer);\n    }\n\n    /**\n     * Selects all elements from inputCollection which don't match the given\n     * predicate and adds them to outputCollection.\n     * <p>\n     * If the input predicate is {@code null}, no elements are added to\n     * {@code outputCollection}.\n     * </p>\n     *\n     * @param <O>  the type of object the {@link Iterable} contains\n     * @param <R>  the type of the output {@link Collection}\n     * @param inputCollection  the collection to get the input from, may be null\n     * @param predicate  the predicate to use, may be null\n     * @param outputCollection  the collection to output into, may not be null if the inputCollection\n     *   and predicate or not null\n     * @return outputCollection\n     */\n    public static <O, R extends Collection<? super O>> R selectRejected(final Iterable<? extends O> inputCollection,\n            final Predicate<? super O> predicate, final R outputCollection) {\n\n        if (inputCollection != null && predicate != null) {\n            for (final O item : inputCollection) {\n                if (!predicate.test(item)) {\n                    outputCollection.add(item);\n                }\n            }\n        }\n        return outputCollection;\n    }\n\n    /**\n     * Gets the size of the collection/iterator specified.\n     * <p>\n     * This method can handles objects as follows\n     * </p>\n     * <ul>\n     * <li>Collection - the collection size\n     * <li>Map - the map size\n     * <li>Array - the array size\n     * <li>Iterator - the number of elements remaining in the iterator\n     * <li>Enumeration - the number of elements remaining in the enumeration\n     * </ul>\n     *\n     * @param object  the object to get the size of, may be null\n     * @return the size of the specified collection or 0 if the object was null\n     * @throws IllegalArgumentException thrown if object is not recognized\n     * @since 3.1\n     */\n    public static int size(final Object object) {\n        if (object == null) {\n            return 0;\n        }\n        int total = 0;\n        if (object instanceof Map<?, ?>) {\n            total = ((Map<?, ?>) object).size();\n        } else if (object instanceof Collection<?>) {\n            total = ((Collection<?>) object).size();\n        } else if (object instanceof Iterable<?>) {\n            total = IterableUtils.size((Iterable<?>) object);\n        } else if (object instanceof Object[]) {\n            total = ((Object[]) object).length;\n        } else if (object instanceof Iterator<?>) {\n            total = IteratorUtils.size((Iterator<?>) object);\n        } else if (object instanceof Enumeration<?>) {\n            final Enumeration<?> it = (Enumeration<?>) object;\n            while (it.hasMoreElements()) {\n                total++;\n                it.nextElement();\n            }\n        } else {\n            try {\n                total = Array.getLength(object);\n            } catch (final IllegalArgumentException ex) {\n                throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n            }\n        }\n        return total;\n    }\n\n    /**\n     * Checks if the specified collection/array/iterator is empty.\n     * <p>\n     * This method can handles objects as follows\n     * </p>\n     * <ul>\n     * <li>Collection - via collection isEmpty\n     * <li>Map - via map isEmpty\n     * <li>Array - using array size\n     * <li>Iterator - via hasNext\n     * <li>Enumeration - via hasMoreElements\n     * </ul>\n     * <p>\n     * Note: This method is named to avoid clashing with\n     * {@link #isEmpty(Collection)}.\n     * </p>\n     *\n     * @param object  the object to get the size of, may be null\n     * @return true if empty or null\n     * @throws IllegalArgumentException thrown if object is not recognized\n     * @since 3.2\n     */\n    public static boolean sizeIsEmpty(final Object object) {\n        if (object == null) {\n            return true;\n        }\n        if (object instanceof Collection<?>) {\n            return ((Collection<?>) object).isEmpty();\n        }\n        if (object instanceof Iterable<?>) {\n            return IterableUtils.isEmpty((Iterable<?>) object);\n        }\n        if (object instanceof Map<?, ?>) {\n            return ((Map<?, ?>) object).isEmpty();\n        }\n        if (object instanceof Object[]) {\n            return ((Object[]) object).length == 0;\n        }\n        if (object instanceof Iterator<?>) {\n            return !((Iterator<?>) object).hasNext();\n        }\n        if (object instanceof Enumeration<?>) {\n            return !((Enumeration<?>) object).hasMoreElements();\n        }\n        try {\n            return Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n\n    /**\n     * Returns a new {@link Collection} containing {@code <em>a</em> - <em>b</em>}.\n     * The cardinality of each element <em>e</em> in the returned {@link Collection}\n     * will be the cardinality of <em>e</em> in <em>a</em> minus the cardinality\n     * of <em>e</em> in <em>b</em>, or zero, whichever is greater.\n     *\n     * @param a  the collection to subtract from, must not be null\n     * @param b  the collection to subtract, must not be null\n     * @param <O> the generic type that is able to represent the types contained\n     *        in both input collections.\n     * @return a new collection with the results\n     * @see Collection#removeAll\n     */\n    public static <O> Collection<O> subtract(final Iterable<? extends O> a, final Iterable<? extends O> b) {\n        final Predicate<O> p = TruePredicate.truePredicate();\n        return subtract(a, b, p);\n    }\n\n    /**\n     * Returns a new {@link Collection} containing <em>a</em> minus a subset of\n     * <em>b</em>.  Only the elements of <em>b</em> that satisfy the predicate\n     * condition, <em>p</em> are subtracted from <em>a</em>.\n     *\n     * <p>\n     * The cardinality of each element <em>e</em> in the returned {@link Collection}\n     * that satisfies the predicate condition will be the cardinality of <em>e</em> in <em>a</em>\n     * minus the cardinality of <em>e</em> in <em>b</em>, or zero, whichever is greater.\n     * </p>\n     * <p>\n     * The cardinality of each element <em>e</em> in the returned {@link Collection} that does <b>not</b>\n     * satisfy the predicate condition will be equal to the cardinality of <em>e</em> in <em>a</em>.\n     * </p>\n     *\n     * @param a  the collection to subtract from, must not be null\n     * @param b  the collection to subtract, must not be null\n     * @param p  the condition used to determine which elements of <em>b</em> are\n     *        subtracted.\n     * @param <O> the generic type that is able to represent the types contained\n     *        in both input collections.\n     * @return a new collection with the results\n     * @throws NullPointerException if either collection or p is null\n     * @since 4.0\n     * @see Collection#removeAll\n     */\n    public static <O> Collection<O> subtract(final Iterable<? extends O> a,\n                                             final Iterable<? extends O> b,\n                                             final Predicate<O> p) {\n        Objects.requireNonNull(a, \"a\");\n        Objects.requireNonNull(b, \"b\");\n        Objects.requireNonNull(p, \"p\");\n        final ArrayList<O> list = new ArrayList<>();\n        final HashBag<O> bag = new HashBag<>();\n        for (final O element : b) {\n            if (p.test(element)) {\n                bag.add(element);\n            }\n        }\n        for (final O element : a) {\n            if (!bag.remove(element, 1)) {\n                list.add(element);\n            }\n        }\n        return list;\n    }\n\n    /**\n     * Returns a synchronized collection backed by the given collection.\n     * <p>\n     * You must manually synchronize on the returned buffer's iterator to\n     * avoid non-deterministic behavior:\n     * </p>\n     * <pre>\n     * Collection c = CollectionUtils.synchronizedCollection(myCollection);\n     * synchronized (c) {\n     *     Iterator i = c.iterator();\n     *     while (i.hasNext()) {\n     *         process (i.next());\n     *     }\n     * }\n     * </pre>\n     * <p>\n     * This method uses the implementation in the decorators subpackage.\n     * </p>\n     *\n     * @param <C>  the type of object the {@link Collection} contains\n     * @param collection  the collection to synchronize, must not be null\n     * @return a synchronized collection backed by the given collection\n     * @throws NullPointerException if the collection is null\n     * @deprecated since 4.1, use {@link java.util.Collections#synchronizedCollection(Collection)} instead\n     */\n    @Deprecated\n    public static <C> Collection<C> synchronizedCollection(final Collection<C> collection) {\n        Objects.requireNonNull(collection, \"collection\");\n        return SynchronizedCollection.synchronizedCollection(collection);\n    }\n\n    /**\n     * Transform the collection by applying a Transformer to each element.\n     * <p>\n     * If the input collection or transformer is null, there is no change made.\n     * </p>\n     * <p>\n     * This routine is best for Lists, for which set() is used to do the\n     * transformations \"in place.\" For other Collections, clear() and addAll()\n     * are used to replace elements.\n     * </p>\n     * <p>\n     * If the input collection controls its input, such as a Set, and the\n     * Transformer creates duplicates (or are otherwise invalid), the collection\n     * may reduce in size due to calling this method.\n     * </p>\n     *\n     * @param <C>  the type of object the {@link Collection} contains\n     * @param collection  the {@link Collection} to get the input from, may be null\n     * @param transformer  the transformer to perform, may be null\n     */\n    public static <C> void transform(final Collection<C> collection,\n                                     final Transformer<? super C, ? extends C> transformer) {\n\n        if (collection != null && transformer != null) {\n            if (collection instanceof List<?>) {\n                final List<C> list = (List<C>) collection;\n                for (final ListIterator<C> it = list.listIterator(); it.hasNext();) {\n                    it.set(transformer.apply(it.next()));\n                }\n            } else {\n                final Collection<C> resultCollection = collect(collection, transformer);\n                collection.clear();\n                collection.addAll(resultCollection);\n            }\n        }\n    }\n\n    /**\n     * Returns a transformed bag backed by the given collection.\n     * <p>\n     * Each object is passed through the transformer as it is added to the\n     * Collection. It is important not to use the original collection after invoking this\n     * method, as it is a backdoor for adding untransformed objects.\n     * </p>\n     * <p>\n     * Existing entries in the specified collection will not be transformed.\n     * If you want that behavior, see {@link TransformedCollection#transformedCollection}.\n     * </p>\n     *\n     * @param <E> the type of object the {@link Collection} contains\n     * @param collection  the collection to predicate, must not be null\n     * @param transformer  the transformer for the collection, must not be null\n     * @return a transformed collection backed by the given collection\n     * @throws NullPointerException if the collection or transformer is null\n     */\n    public static <E> Collection<E> transformingCollection(final Collection<E> collection,\n            final Transformer<? super E, ? extends E> transformer) {\n        Objects.requireNonNull(collection, \"collection\");\n        Objects.requireNonNull(transformer, \"transformer\");\n        return TransformedCollection.transformingCollection(collection, transformer);\n    }\n\n    /**\n     * Returns a {@link Collection} containing the union of the given\n     * {@link Iterable}s.\n     * <p>\n     * The cardinality of each element in the returned {@link Collection} will\n     * be equal to the maximum of the cardinality of that element in the two\n     * given {@link Iterable}s.\n     * </p>\n     *\n     * @param a the first collection, must not be null\n     * @param b the second collection, must not be null\n     * @param <O> the generic type that is able to represent the types contained\n     *        in both input collections.\n     * @return the union of the two collections\n     * @throws NullPointerException if either collection is null\n     * @see Collection#addAll\n     */\n    public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b) {\n        Objects.requireNonNull(a, \"a\");\n        Objects.requireNonNull(b, \"b\");\n        final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<>(a, b);\n        for (final O obj : helper) {\n            helper.setCardinality(obj, helper.max(obj));\n        }\n        return helper.list();\n    }\n\n    /**\n     * Returns an unmodifiable collection backed by the given collection.\n     * <p>\n     * This method uses the implementation in the decorators subpackage.\n     * </p>\n     *\n     * @param <C>  the type of object the {@link Collection} contains\n     * @param collection  the collection to make unmodifiable, must not be null\n     * @return an unmodifiable collection backed by the given collection\n     * @throws NullPointerException if the collection is null\n     * @deprecated since 4.1, use {@link java.util.Collections#unmodifiableCollection(Collection)} instead\n     */\n    @Deprecated\n    public static <C> Collection<C> unmodifiableCollection(final Collection<? extends C> collection) {\n        Objects.requireNonNull(collection, \"collection\");\n        return UnmodifiableCollection.unmodifiableCollection(collection);\n    }\n\n    /**\n     * Don't allow instances.\n     */\n    private CollectionUtils() {\n        // empty\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final int INDEX_NOT_FOUND = -1;", "docstring": "\nThe index value when an element is not found in a collection or array: {@code -1}.\n\n@since 4.5.0\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "int", "name": "INDEX_NOT_FOUND = -1", "syntax_pass": true}, {"attribute_expression": "public static final String DEFAULT_TOSTRING_PREFIX = \"[\";", "docstring": "\nDefault prefix used while converting an Iterator to its String representation.\n\n@since 4.5.0\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "DEFAULT_TOSTRING_PREFIX = \"[\"", "syntax_pass": true}, {"attribute_expression": "public static final String DEFAULT_TOSTRING_SUFFIX = \"]\";", "docstring": "\nDefault suffix used while converting an Iterator to its String representation.\n\n@since 4.5.0\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "DEFAULT_TOSTRING_SUFFIX = \"]\"", "syntax_pass": true}, {"attribute_expression": "public static final String COLON = \":\";", "docstring": "\nA String for Colon  (\":\").\n\n@since 4.5.0\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "COLON = \":\"", "syntax_pass": true}, {"attribute_expression": "public static final String COMMA = \",\";", "docstring": "\nA String for Comma (\",\").\n\n@since 4.5.0\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "COMMA = \",\"", "syntax_pass": true}, {"attribute_expression": "@SuppressWarnings(\"rawtypes\") // we deliberately use the raw type here\n    public static final Collection EMPTY_COLLECTION = Collections.emptyList();", "docstring": "\nAn empty unmodifiable collection.\nThe JDK provides empty Set and List implementations which could be used for\nthis purpose. However they could be cast to Set or List which might be\nundesirable. This implementation only implements Collection.\n", "modifiers": "@SuppressWarnings(\"rawtypes\") // we deliberately use the raw type here\n    public static final", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"rawtypes\")", "public", "static", "final"], "comments": ["// we deliberately use the raw type here"], "type": "Collection", "name": "EMPTY_COLLECTION = Collections.emptyList()", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/ListUtils.java.ListUtils", "name": "ListUtils", "file_path": "src/main/java/org/apache/commons/collections4/ListUtils.java", "superclasses": "", "methods": ["[List<T>]defaultIfNull(List<T>,List<T>)", "[List<T>]emptyIfNull(List<T>)", "[List<E>]fixedSizeList(List<E>)", "[T]getFirst(List<T>)", "[T]getLast(List<T>)", "[int]hashCodeForList(Collection<?>)", "[int]indexOf(List<E>,Predicate<E>)", "[List<E>]intersection(List<? extends E>,List<? extends E>)", "[boolean]isEqualList(Collection<?>,Collection<?>)", "[List<E>]lazyList(List<E>,Factory<? extends E>)", "[List<E>]lazyList(List<E>,Transformer<Integer, ? extends E>)", "[String]longestCommonSubsequence(CharSequence,CharSequence)", "[List<E>]longestCommonSubsequence(List<E>,List<E>)", "[List<E>]longestCommonSubsequence(List<E>,List<E>,Equator<? super E>)", "[List<List<T>>]partition(List<T>,int)", "[List<E>]predicatedList(List<E>,Predicate<E>)", "[List<E>]removeAll(Collection<E>,Collection<?>)", "[List<E>]retainAll(Collection<E>,Collection<?>)", "[List<E>]select(Collection<? extends E>,Predicate<? super E>)", "[List<E>]selectRejected(Collection<? extends E>,Predicate<? super E>)", "[List<E>]subtract(List<E>,List<? extends E>)", "[List<E>]sum(List<? extends E>,List<? extends E>)", "[List<E>]synchronizedList(List<E>)", "[List<E>]transformedList(List<E>,Transformer<? super E, ? extends E>)", "[List<E>]union(List<? extends E>,List<? extends E>)", "[List<E>]unmodifiableList(List<? extends E>)", "[]ListUtils()"], "method_uris": ["src/main/java/org/apache/commons/collections4/ListUtils.java.ListUtils.[List<T>]defaultIfNull(List<T>,List<T>)", "src/main/java/org/apache/commons/collections4/ListUtils.java.ListUtils.[List<T>]emptyIfNull(List<T>)", "src/main/java/org/apache/commons/collections4/ListUtils.java.ListUtils.[List<E>]fixedSizeList(List<E>)", "src/main/java/org/apache/commons/collections4/ListUtils.java.ListUtils.[T]getFirst(List<T>)", "src/main/java/org/apache/commons/collections4/ListUtils.java.ListUtils.[T]getLast(List<T>)", "src/main/java/org/apache/commons/collections4/ListUtils.java.ListUtils.[int]hashCodeForList(Collection<?>)", "src/main/java/org/apache/commons/collections4/ListUtils.java.ListUtils.[int]indexOf(List<E>,Predicate<E>)", "src/main/java/org/apache/commons/collections4/ListUtils.java.ListUtils.[List<E>]intersection(List<? extends E>,List<? extends E>)", "src/main/java/org/apache/commons/collections4/ListUtils.java.ListUtils.[boolean]isEqualList(Collection<?>,Collection<?>)", "src/main/java/org/apache/commons/collections4/ListUtils.java.ListUtils.[List<E>]lazyList(List<E>,Factory<? extends E>)", "src/main/java/org/apache/commons/collections4/ListUtils.java.ListUtils.[List<E>]lazyList(List<E>,Transformer<Integer, ? extends E>)", "src/main/java/org/apache/commons/collections4/ListUtils.java.ListUtils.[String]longestCommonSubsequence(CharSequence,CharSequence)", "src/main/java/org/apache/commons/collections4/ListUtils.java.ListUtils.[List<E>]longestCommonSubsequence(List<E>,List<E>)", "src/main/java/org/apache/commons/collections4/ListUtils.java.ListUtils.[List<E>]longestCommonSubsequence(List<E>,List<E>,Equator<? super E>)", "src/main/java/org/apache/commons/collections4/ListUtils.java.ListUtils.[List<List<T>>]partition(List<T>,int)", "src/main/java/org/apache/commons/collections4/ListUtils.java.ListUtils.[List<E>]predicatedList(List<E>,Predicate<E>)", "src/main/java/org/apache/commons/collections4/ListUtils.java.ListUtils.[List<E>]removeAll(Collection<E>,Collection<?>)", "src/main/java/org/apache/commons/collections4/ListUtils.java.ListUtils.[List<E>]retainAll(Collection<E>,Collection<?>)", "src/main/java/org/apache/commons/collections4/ListUtils.java.ListUtils.[List<E>]select(Collection<? extends E>,Predicate<? super E>)", "src/main/java/org/apache/commons/collections4/ListUtils.java.ListUtils.[List<E>]selectRejected(Collection<? extends E>,Predicate<? super E>)", "src/main/java/org/apache/commons/collections4/ListUtils.java.ListUtils.[List<E>]subtract(List<E>,List<? extends E>)", "src/main/java/org/apache/commons/collections4/ListUtils.java.ListUtils.[List<E>]sum(List<? extends E>,List<? extends E>)", "src/main/java/org/apache/commons/collections4/ListUtils.java.ListUtils.[List<E>]synchronizedList(List<E>)", "src/main/java/org/apache/commons/collections4/ListUtils.java.ListUtils.[List<E>]transformedList(List<E>,Transformer<? super E, ? extends E>)", "src/main/java/org/apache/commons/collections4/ListUtils.java.ListUtils.[List<E>]union(List<? extends E>,List<? extends E>)", "src/main/java/org/apache/commons/collections4/ListUtils.java.ListUtils.[List<E>]unmodifiableList(List<? extends E>)", "src/main/java/org/apache/commons/collections4/ListUtils.java.ListUtils.[]ListUtils()"], "overrides": null, "attributes": [{"original_string": "    private static final class CharSequenceAsList extends AbstractList<Character> {\n        private final CharSequence sequence;\n\n        CharSequenceAsList(final CharSequence sequence) {\n            this.sequence = sequence;\n        }\n\n        @Override\n        public Character get(final int index) {\n            return Character.valueOf(sequence.charAt(index));\n        }\n\n        @Override\n        public int size() {\n            return sequence.length();\n        }\n    }", "definition": "    private static final class CharSequenceAsList extends AbstractList<Character>", "class_docstring": "\nA simple wrapper to use a CharSequence as List.\n", "name": "CharSequenceAsList", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "fields": [{"attribute_expression": "private final CharSequence sequence;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "CharSequence", "name": "sequence", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        CharSequenceAsList(final CharSequence sequence) {\n            this.sequence = sequence;\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "CharSequenceAsList", "params": [{"name": "sequence", "type": "CharSequence"}], "body": "                                                        {\n            this.sequence = sequence;\n        }", "signature": "CharSequenceAsList(final CharSequence sequence)"}, {"syntax_pass": true, "original_string": "        @Override\n        public Character get(final int index) {\n            return Character.valueOf(sequence.charAt(index));\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Character", "classes": []}, "name": "get", "params": [{"name": "index", "type": "int"}], "body": "                                              {\n            return Character.valueOf(sequence.charAt(index));\n        }", "signature": "@Override\n        public Character get(final int index)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int size() {\n            return sequence.length();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "size", "params": [], "body": "                          {\n            return sequence.length();\n        }", "signature": "@Override\n        public int size()"}]}, {"original_string": "    private static final class LcsVisitor<E> implements CommandVisitor<E> {\n        private final ArrayList<E> sequence;\n\n        LcsVisitor() {\n            sequence = new ArrayList<>();\n        }\n\n        public List<E> getSubSequence() {\n            return sequence;\n        }\n\n        @Override\n        public void visitDeleteCommand(final E object) {\n            // noop\n        }\n\n        @Override\n        public void visitInsertCommand(final E object) {\n            // noop\n        }\n\n        @Override\n        public void visitKeepCommand(final E object) {\n            sequence.add(object);\n        }\n    }", "definition": "    private static final class LcsVisitor<E> implements CommandVisitor<E>", "class_docstring": "\nA helper class used to construct the longest common subsequence.\n", "name": "LcsVisitor", "super_interfaces": ["CommandVisitor<E>"], "superclasses": "", "attributes": {"modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "fields": [{"attribute_expression": "private final ArrayList<E> sequence;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ArrayList<E>", "name": "sequence", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        LcsVisitor() {\n            sequence = new ArrayList<>();\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "LcsVisitor", "params": [], "body": "                     {\n            sequence = new ArrayList<>();\n        }", "signature": "LcsVisitor()"}, {"syntax_pass": true, "original_string": "        public List<E> getSubSequence() {\n            return sequence;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<E>", "classes": []}, "name": "getSubSequence", "params": [], "body": "                                        {\n            return sequence;\n        }", "signature": "public List<E> getSubSequence()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void visitDeleteCommand(final E object) {\n            // noop\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "visitDeleteCommand", "params": [{"name": "object", "type": "E"}], "body": "                                                       {\n            // noop\n        }", "signature": "@Override\n        public void visitDeleteCommand(final E object)"}, {"syntax_pass": true, "original_string": "        @Override\n        public void visitInsertCommand(final E object) {\n            // noop\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "visitInsertCommand", "params": [{"name": "object", "type": "E"}], "body": "                                                       {\n            // noop\n        }", "signature": "@Override\n        public void visitInsertCommand(final E object)"}, {"syntax_pass": true, "original_string": "        @Override\n        public void visitKeepCommand(final E object) {\n            sequence.add(object);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "visitKeepCommand", "params": [{"name": "object", "type": "E"}], "body": "                                                     {\n            sequence.add(object);\n        }", "signature": "@Override\n        public void visitKeepCommand(final E object)"}]}, {"original_string": "    private static final class Partition<T> extends AbstractList<List<T>> {\n        private final List<T> list;\n        private final int size;\n\n        private Partition(final List<T> list, final int size) {\n            this.list = list;\n            this.size = size;\n        }\n\n        @Override\n        public List<T> get(final int index) {\n            final int listSize = size();\n            if (index < 0) {\n                throw new IndexOutOfBoundsException(\"Index \" + index + \" must not be negative\");\n            }\n            if (index >= listSize) {\n                throw new IndexOutOfBoundsException(\"Index \" + index + \" must be less than size \" +\n                                                    listSize);\n            }\n            final int start = index * size;\n            final int end = Math.min(start + size, list.size());\n            return list.subList(start, end);\n        }\n\n        @Override\n        public boolean isEmpty() {\n            return list.isEmpty();\n        }\n\n        @Override\n        public int size() {\n            return (int) Math.ceil((double) list.size() / (double) size);\n        }\n    }", "definition": "    private static final class Partition<T> extends AbstractList<List<T>>", "class_docstring": "\nProvides a partition view on a {@link List}.\n@since 4.0\n", "name": "Partition", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "fields": [{"attribute_expression": "private final List<T> list;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<T>", "name": "list", "syntax_pass": true}, {"attribute_expression": "private final int size;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "size", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        private Partition(final List<T> list, final int size) {\n            this.list = list;\n            this.size = size;\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "Partition", "params": [{"name": "list", "type": "List<T>"}, {"name": "size", "type": "int"}], "body": "                                                              {\n            this.list = list;\n            this.size = size;\n        }", "signature": "private Partition(final List<T> list, final int size)"}, {"syntax_pass": true, "original_string": "        @Override\n        public List<T> get(final int index) {\n            final int listSize = size();\n            if (index < 0) {\n                throw new IndexOutOfBoundsException(\"Index \" + index + \" must not be negative\");\n            }\n            if (index >= listSize) {\n                throw new IndexOutOfBoundsException(\"Index \" + index + \" must be less than size \" +\n                                                    listSize);\n            }\n            final int start = index * size;\n            final int end = Math.min(start + size, list.size());\n            return list.subList(start, end);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<T>", "classes": []}, "name": "get", "params": [{"name": "index", "type": "int"}], "body": "                                            {\n            final int listSize = size();\n            if (index < 0) {\n                throw new IndexOutOfBoundsException(\"Index \" + index + \" must not be negative\");\n            }\n            if (index >= listSize) {\n                throw new IndexOutOfBoundsException(\"Index \" + index + \" must be less than size \" +\n                                                    listSize);\n            }\n            final int start = index * size;\n            final int end = Math.min(start + size, list.size());\n            return list.subList(start, end);\n        }", "signature": "@Override\n        public List<T> get(final int index)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isEmpty() {\n            return list.isEmpty();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isEmpty", "params": [], "body": "                                 {\n            return list.isEmpty();\n        }", "signature": "@Override\n        public boolean isEmpty()"}, {"syntax_pass": true, "original_string": "        @Override\n        public int size() {\n            return (int) Math.ceil((double) list.size() / (double) size);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "size", "params": [], "body": "                          {\n            return (int) Math.ceil((double) list.size() / (double) size);\n        }", "signature": "@Override\n        public int size()"}]}], "class_docstring": "\nProvides utility methods and decorators for {@link List} instances.\n\n@since 1.0\n", "original_string": "public class ListUtils {\n    /**\n     * A simple wrapper to use a CharSequence as List.\n     */\n    private static final class CharSequenceAsList extends AbstractList<Character> {\n        private final CharSequence sequence;\n\n        CharSequenceAsList(final CharSequence sequence) {\n            this.sequence = sequence;\n        }\n\n        @Override\n        public Character get(final int index) {\n            return Character.valueOf(sequence.charAt(index));\n        }\n\n        @Override\n        public int size() {\n            return sequence.length();\n        }\n    }\n\n    /**\n     * A helper class used to construct the longest common subsequence.\n     */\n    private static final class LcsVisitor<E> implements CommandVisitor<E> {\n        private final ArrayList<E> sequence;\n\n        LcsVisitor() {\n            sequence = new ArrayList<>();\n        }\n\n        public List<E> getSubSequence() {\n            return sequence;\n        }\n\n        @Override\n        public void visitDeleteCommand(final E object) {\n            // noop\n        }\n\n        @Override\n        public void visitInsertCommand(final E object) {\n            // noop\n        }\n\n        @Override\n        public void visitKeepCommand(final E object) {\n            sequence.add(object);\n        }\n    }\n\n    /**\n     * Provides a partition view on a {@link List}.\n     * @since 4.0\n     */\n    private static final class Partition<T> extends AbstractList<List<T>> {\n        private final List<T> list;\n        private final int size;\n\n        private Partition(final List<T> list, final int size) {\n            this.list = list;\n            this.size = size;\n        }\n\n        @Override\n        public List<T> get(final int index) {\n            final int listSize = size();\n            if (index < 0) {\n                throw new IndexOutOfBoundsException(\"Index \" + index + \" must not be negative\");\n            }\n            if (index >= listSize) {\n                throw new IndexOutOfBoundsException(\"Index \" + index + \" must be less than size \" +\n                                                    listSize);\n            }\n            final int start = index * size;\n            final int end = Math.min(start + size, list.size());\n            return list.subList(start, end);\n        }\n\n        @Override\n        public boolean isEmpty() {\n            return list.isEmpty();\n        }\n\n        @Override\n        public int size() {\n            return (int) Math.ceil((double) list.size() / (double) size);\n        }\n    }\n\n    /**\n     * Returns either the passed in list, or if the list is {@code null},\n     * the value of {@code defaultList}.\n     *\n     * @param <T> the element type\n     * @param list  the list, possibly {@code null}\n     * @param defaultList  the returned values if list is {@code null}\n     * @return an empty list if the argument is {@code null}\n     * @since 4.0\n     */\n    public static <T> List<T> defaultIfNull(final List<T> list, final List<T> defaultList) {\n        return list == null ? defaultList : list;\n    }\n\n    /**\n     * Returns an immutable empty list if the argument is {@code null},\n     * or the argument itself otherwise.\n     *\n     * @param <T> the element type\n     * @param list the list, possibly {@code null}\n     * @return an empty list if the argument is {@code null}\n     */\n    public static <T> List<T> emptyIfNull(final List<T> list) {\n        return list == null ? Collections.<T>emptyList() : list;\n    }\n\n    /**\n     * Returns a fixed-sized list backed by the given list.\n     * Elements may not be added or removed from the returned list, but\n     * existing elements can be changed (for instance, via the\n     * {@link List#set(int, Object)} method).\n     *\n     * @param <E>  the element type\n     * @param list  the list whose size to fix, must not be null\n     * @return a fixed-size list backed by that list\n     * @throws NullPointerException  if the List is null\n     */\n    public static <E> List<E> fixedSizeList(final List<E> list) {\n        return FixedSizeList.fixedSizeList(list);\n    }\n\n    /**\n     * Gets the first element of a list.\n     * <p>\n     * Shorthand for {@code list.get(0)}\n     * </p>\n     * @param <T> The list type.\n     * @param list The list.\n     * @return the first element of a list.\n     * @see List#get(int)\n     * @since 4.5.0\n     */\n    public static <T> T getFirst(final List<T> list) {\n        return Objects.requireNonNull(list, \"list\").get(0);\n    }\n\n    /**\n     * Gets the last element of a list.\n     * <p>\n     * Shorthand for {@code list.get(list.size() - 1)}\n     * </p>\n     * @param <T> The list type.\n     * @param list The list.\n     * @return the last element of a list.\n     * @see List#get(int)\n     * @since 4.5.0\n     */\n    public static <T> T getLast(final List<T> list) {\n        return Objects.requireNonNull(list, \"list\").get(list.size() - 1);\n    }\n\n    /**\n     * Generates a hash code using the algorithm specified in\n     * {@link java.util.List#hashCode()}.\n     * <p>\n     * This method is useful for implementing {@code List} when you cannot\n     * extend AbstractList. The method takes Collection instances to enable other\n     * collection types to use the List implementation algorithm.\n     *\n     * @see java.util.List#hashCode()\n     * @param list  the list to generate the hashCode for, may be null\n     * @return the hash code\n     */\n    public static int hashCodeForList(final Collection<?> list) {\n        if (list == null) {\n            return 0;\n        }\n        int hashCode = 1;\n\n        for (final Object obj : list) {\n            hashCode = 31 * hashCode + (obj == null ? 0 : obj.hashCode());\n        }\n        return hashCode;\n    }\n\n    /**\n     * Finds the first index in the given List which matches the given predicate.\n     * <p>\n     * If the input List or predicate is null, or no element of the List\n     * matches the predicate, -1 is returned.\n     *\n     * @param <E>  the element type\n     * @param list the List to search, may be null\n     * @param predicate  the predicate to use, may be null\n     * @return the first index of an Object in the List which matches the predicate or -1 if none could be found\n     */\n    public static <E> int indexOf(final List<E> list, final Predicate<E> predicate) {\n        if (list != null && predicate != null) {\n            for (int i = 0; i < list.size(); i++) {\n                final E item = list.get(i);\n                if (predicate.test(item)) {\n                    return i;\n                }\n            }\n        }\n        return CollectionUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * Returns a new list containing all elements that are contained in\n     * both given lists.\n     *\n     * @param <E> the element type\n     * @param list1  the first list\n     * @param list2  the second list\n     * @return  the intersection of those two lists\n     * @throws NullPointerException if either list is null\n     */\n    public static <E> List<E> intersection(final List<? extends E> list1, final List<? extends E> list2) {\n        final List<E> result = new ArrayList<>();\n\n        List<? extends E> smaller = list1;\n        List<? extends E> larger = list2;\n        if (list1.size() > list2.size()) {\n            smaller = list2;\n            larger = list1;\n        }\n\n        final HashSet<E> hashSet = new HashSet<>(smaller);\n\n        for (final E e : larger) {\n            if (hashSet.contains(e)) {\n                result.add(e);\n                hashSet.remove(e);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Tests two lists for value-equality as per the equality contract in\n     * {@link java.util.List#equals(Object)}.\n     * <p>\n     * This method is useful for implementing {@code List} when you cannot\n     * extend AbstractList. The method takes Collection instances to enable other\n     * collection types to use the List implementation algorithm.\n     * <p>\n     * The relevant text (slightly paraphrased as this is a static method) is:\n     * <blockquote>\n     * Compares the two list objects for equality.  Returns\n     * {@code true} if and only if both\n     * lists have the same size, and all corresponding pairs of elements in\n     * the two lists are <em>equal</em>.  (Two elements {@code e1} and\n     * {@code e2} are <em>equal</em> if {@code (e1==null ? e2==null :\n     * e1.equals(e2))}.)  In other words, two lists are defined to be\n     * equal if they contain the same elements in the same order.  This\n     * definition ensures that the equals method works properly across\n     * different implementations of the {@code List} interface.\n     * </blockquote>\n     *\n     * <b>Note:</b> The behavior of this method is undefined if the lists are\n     * modified during the equals comparison.\n     *\n     * @see java.util.List\n     * @param list1  the first list, may be null\n     * @param list2  the second list, may be null\n     * @return whether the lists are equal by value comparison\n     */\n    public static boolean isEqualList(final Collection<?> list1, final Collection<?> list2) {\n        if (list1 == list2) {\n            return true;\n        }\n        if (list1 == null || list2 == null || list1.size() != list2.size()) {\n            return false;\n        }\n\n        final Iterator<?> it1 = list1.iterator();\n        final Iterator<?> it2 = list2.iterator();\n\n        while (it1.hasNext() && it2.hasNext()) {\n            final Object obj1 = it1.next();\n            final Object obj2 = it2.next();\n\n            if (!Objects.equals(obj1, obj2)) {\n                return false;\n            }\n        }\n\n        return !(it1.hasNext() || it2.hasNext());\n    }\n\n    /**\n     * Returns a \"lazy\" list whose elements will be created on demand.\n     * <p>\n     * When the index passed to the returned list's {@link List#get(int) get}\n     * method is greater than the list's size, then the factory will be used\n     * to create a new object and that object will be inserted at that index.\n     * <p>\n     * For instance:\n     *\n     * <pre>\n     * Factory&lt;Date&gt; factory = new Factory&lt;Date&gt;() {\n     *     public Date create() {\n     *         return new Date();\n     *     }\n     * }\n     * List&lt;Date&gt; lazy = ListUtils.lazyList(new ArrayList&lt;Date&gt;(), factory);\n     * Date date = lazy.get(3);\n     * </pre>\n     *\n     * After the above code is executed, {@code date} will refer to\n     * a new {@code Date} instance. Furthermore, that {@code Date}\n     * instance is the fourth element in the list.  The first, second,\n     * and third element are all set to {@code null}.\n     *\n     * @param <E> the element type\n     * @param list  the list to make lazy, must not be null\n     * @param factory  the factory for creating new objects, must not be null\n     * @return a lazy list backed by the given list\n     * @throws NullPointerException if the List or Factory is null\n     */\n    public static <E> List<E> lazyList(final List<E> list, final Factory<? extends E> factory) {\n        return LazyList.lazyList(list, factory);\n    }\n\n    /**\n     * Returns a \"lazy\" list whose elements will be created on demand.\n     * <p>\n     * When the index passed to the returned list's {@link List#get(int) get}\n     * method is greater than the list's size, then the transformer will be used\n     * to create a new object and that object will be inserted at that index.\n     * <p>\n     * For instance:\n     *\n     * <pre>\n     * List&lt;Integer&gt; hours = Arrays.asList(7, 5, 8, 2);\n     * Transformer&lt;Integer,Date&gt; transformer = input -&gt; LocalDateTime.now().withHour(hours.get(input));\n     * List&lt;LocalDateTime&gt; lazy = ListUtils.lazyList(new ArrayList&lt;LocalDateTime&gt;(), transformer);\n     * Date date = lazy.get(3);\n     * </pre>\n     *\n     * After the above code is executed, {@code date} will refer to\n     * a new {@code Date} instance. Furthermore, that {@code Date}\n     * instance is the fourth element in the list.  The first, second,\n     * and third element are all set to {@code null}.\n     *\n     * @param <E> the element type\n     * @param list  the list to make lazy, must not be null\n     * @param transformer  the transformer for creating new objects, must not be null\n     * @return a lazy list backed by the given list\n     * @throws NullPointerException if the List or Transformer is null\n     */\n    public static <E> List<E> lazyList(final List<E> list, final Transformer<Integer, ? extends E> transformer) {\n        return LazyList.lazyList(list, transformer);\n    }\n\n    /**\n     * Returns the longest common subsequence (LCS) of two {@link CharSequence} objects.\n     * <p>\n     * This is a convenience method for using {@link #longestCommonSubsequence(List, List)}\n     * with {@link CharSequence} instances.\n     *\n     * @param charSequenceA  the first sequence\n     * @param charSequenceB  the second sequence\n     * @return the longest common subsequence as {@link String}\n     * @throws NullPointerException if either sequence is {@code null}\n     * @since 4.0\n     */\n    public static String longestCommonSubsequence(final CharSequence charSequenceA, final CharSequence charSequenceB) {\n        Objects.requireNonNull(charSequenceA, \"charSequenceA\");\n        Objects.requireNonNull(charSequenceB, \"charSequenceB\");\n        final List<Character> lcs = longestCommonSubsequence(new CharSequenceAsList(charSequenceA),\n                new CharSequenceAsList(charSequenceB));\n        final StringBuilder sb = new StringBuilder();\n        for (final Character ch : lcs) {\n            sb.append(ch);\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Returns the longest common subsequence (LCS) of two sequences (lists).\n     *\n     * @param <E>  the element type\n     * @param a  the first list\n     * @param b  the second list\n     * @return the longest common subsequence\n     * @throws NullPointerException if either list is {@code null}\n     * @since 4.0\n     */\n    public static <E> List<E> longestCommonSubsequence(final List<E> a, final List<E> b) {\n        return longestCommonSubsequence( a, b, DefaultEquator.defaultEquator() );\n    }\n\n    /**\n     * Returns the longest common subsequence (LCS) of two sequences (lists).\n     *\n     * @param <E>  the element type\n     * @param listA  the first list\n     * @param listB  the second list\n     * @param equator  the equator used to test object equality\n     * @return the longest common subsequence\n     * @throws NullPointerException if either list or the equator is {@code null}\n     * @since 4.0\n     */\n    public static <E> List<E> longestCommonSubsequence(final List<E> listA, final List<E> listB,\n                                                       final Equator<? super E> equator) {\n        Objects.requireNonNull(listA, \"listA\");\n        Objects.requireNonNull(listB, \"listB\");\n        Objects.requireNonNull(equator, \"equator\");\n\n        final SequencesComparator<E> comparator = new SequencesComparator<>(listA, listB, equator);\n        final EditScript<E> script = comparator.getScript();\n        final LcsVisitor<E> visitor = new LcsVisitor<>();\n        script.visit(visitor);\n        return visitor.getSubSequence();\n    }\n\n    /**\n     * Returns consecutive {@link List#subList(int, int) sublists} of a\n     * list, each of the same size (the final list may be smaller). For example,\n     * partitioning a list containing {@code [a, b, c, d, e]} with a partition\n     * size of 3 yields {@code [[a, b, c], [d, e]]} -- an outer list containing\n     * two inner lists of three and two elements, all in the original order.\n     * <p>\n     * The outer list is unmodifiable, but reflects the latest state of the\n     * source list. The inner lists are sublist views of the original list,\n     * produced on demand using {@link List#subList(int, int)}, and are subject\n     * to all the usual caveats about modification as explained in that API.\n     * <p>\n     * Adapted from https://github.com/google/guava\n     *\n     * @param <T> the element type\n     * @param list  the list to return consecutive sublists of\n     * @param size  the desired size of each sublist (the last may be smaller)\n     * @return a list of consecutive sublists\n     * @throws NullPointerException if list is null\n     * @throws IllegalArgumentException if size is not strictly positive\n     * @since 4.0\n     */\n    public static <T> List<List<T>> partition(final List<T> list, final int size) {\n        Objects.requireNonNull(list, \"list\");\n        if (size <= 0) {\n            throw new IllegalArgumentException(\"Size must be greater than 0\");\n        }\n        return new Partition<>(list, size);\n    }\n\n    /**\n     * Returns a predicated (validating) list backed by the given list.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to the list.\n     * Trying to add an invalid object results in an IllegalArgumentException.\n     * It is important not to use the original list after invoking this method,\n     * as it is a backdoor for adding invalid objects.\n     *\n     * @param <E> the element type\n     * @param list  the list to predicate, must not be null\n     * @param predicate  the predicate for the list, must not be null\n     * @return a predicated list backed by the given list\n     * @throws NullPointerException if the List or Predicate is null\n     */\n    public static <E> List<E> predicatedList(final List<E> list, final Predicate<E> predicate) {\n        return PredicatedList.predicatedList(list, predicate);\n    }\n\n    /**\n     * Removes the elements in {@code remove} from {@code collection}. That is, this\n     * method returns a list containing all the elements in {@code collection}\n     * that are not in {@code remove}. The cardinality of an element {@code e}\n     * in the returned collection is the same as the cardinality of {@code e}\n     * in {@code collection} unless {@code remove} contains {@code e}, in which\n     * case the cardinality is zero. This method is useful if you do not wish to modify\n     * {@code collection} and thus cannot call {@code collection.removeAll(remove);}.\n     * <p>\n     * This implementation iterates over {@code collection}, checking each element in\n     * turn to see if it's contained in {@code remove}. If it's not contained, it's added\n     * to the returned list. As a consequence, it is advised to use a collection type for\n     * {@code remove} that provides a fast (e.g. O(1)) implementation of\n     * {@link Collection#contains(Object)}.\n     *\n     * @param <E>  the element type\n     * @param collection  the collection from which items are removed (in the returned collection)\n     * @param remove  the items to be removed from the returned {@code collection}\n     * @return a {@code List} containing all the elements of {@code c} except\n     * any elements that also occur in {@code remove}.\n     * @throws NullPointerException if either parameter is null\n     * @since 3.2\n     */\n    public static <E> List<E> removeAll(final Collection<E> collection, final Collection<?> remove) {\n        Objects.requireNonNull(collection, \"collection\");\n        Objects.requireNonNull(remove, \"remove\");\n        final List<E> list = new ArrayList<>();\n        for (final E obj : collection) {\n            if (!remove.contains(obj)) {\n                list.add(obj);\n            }\n        }\n        return list;\n    }\n\n    /**\n     * Returns a List containing all the elements in {@code collection}\n     * that are also in {@code retain}. The cardinality of an element {@code e}\n     * in the returned list is the same as the cardinality of {@code e}\n     * in {@code collection} unless {@code retain} does not contain {@code e}, in which\n     * case the cardinality is zero. This method is useful if you do not wish to modify\n     * the collection {@code c} and thus cannot call {@code collection.retainAll(retain);}.\n     * <p>\n     * This implementation iterates over {@code collection}, checking each element in\n     * turn to see if it's contained in {@code retain}. If it's contained, it's added\n     * to the returned list. As a consequence, it is advised to use a collection type for\n     * {@code retain} that provides a fast (e.g. O(1)) implementation of\n     * {@link Collection#contains(Object)}.\n     *\n     * @param <E>  the element type\n     * @param collection  the collection whose contents are the target of the #retailAll operation\n     * @param retain  the collection containing the elements to be retained in the returned collection\n     * @return a {@code List} containing all the elements of {@code c}\n     * that occur at least once in {@code retain}.\n     * @throws NullPointerException if either parameter is null\n     * @since 3.2\n     */\n    public static <E> List<E> retainAll(final Collection<E> collection, final Collection<?> retain) {\n        final List<E> list = new ArrayList<>(Math.min(collection.size(), retain.size()));\n\n        for (final E obj : collection) {\n            if (retain.contains(obj)) {\n                list.add(obj);\n            }\n        }\n        return list;\n    }\n\n    /**\n     * Selects all elements from input collection which match the given\n     * predicate into an output list.\n     * <p>\n     * A {@code null} predicate matches no elements.\n     *\n     * @param <E> the element type\n     * @param inputCollection  the collection to get the input from, may not be null\n     * @param predicate  the predicate to use, may be null\n     * @return the elements matching the predicate (new list)\n     * @throws NullPointerException if the input list is null\n     *\n     * @since 4.0\n     * @see CollectionUtils#select(Iterable, Predicate)\n     */\n    public static <E> List<E> select(final Collection<? extends E> inputCollection,\n            final Predicate<? super E> predicate) {\n        return CollectionUtils.select(inputCollection, predicate, new ArrayList<>(inputCollection.size()));\n    }\n\n    /**\n     * Selects all elements from inputCollection which don't match the given\n     * predicate into an output collection.\n     * <p>\n     * If the input predicate is {@code null}, the result is an empty list.\n     *\n     * @param <E> the element type\n     * @param inputCollection the collection to get the input from, may not be null\n     * @param predicate the predicate to use, may be null\n     * @return the elements <b>not</b> matching the predicate (new list)\n     * @throws NullPointerException if the input collection is null\n     *\n     * @since 4.0\n     * @see CollectionUtils#selectRejected(Iterable, Predicate)\n     */\n    public static <E> List<E> selectRejected(final Collection<? extends E> inputCollection,\n            final Predicate<? super E> predicate) {\n        return CollectionUtils.selectRejected(inputCollection, predicate, new ArrayList<>(inputCollection.size()));\n    }\n\n    /**\n     * Subtracts all elements in the second list from the first list,\n     * placing the results in a new list.\n     * <p>\n     * This differs from {@link List#removeAll(Collection)} in that\n     * cardinality is respected; if <Code>list1</Code> contains two\n     * occurrences of <Code>null</Code> and <Code>list2</Code> only\n     * contains one occurrence, then the returned list will still contain\n     * one occurrence.\n     *\n     * @param <E> the element type\n     * @param list1  the list to subtract from\n     * @param list2  the list to subtract\n     * @return a new list containing the results\n     * @throws NullPointerException if either list is null\n     */\n    public static <E> List<E> subtract(final List<E> list1, final List<? extends E> list2) {\n        final ArrayList<E> result = new ArrayList<>();\n        final HashBag<E> bag = new HashBag<>(list2);\n        for (final E e : list1) {\n            if (!bag.remove(e, 1)) {\n                result.add(e);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns the sum of the given lists.  This is their intersection\n     * subtracted from their union.\n     *\n     * @param <E> the element type\n     * @param list1  the first list\n     * @param list2  the second list\n     * @return  a new list containing the sum of those lists\n     * @throws NullPointerException if either list is null\n     */\n    public static <E> List<E> sum(final List<? extends E> list1, final List<? extends E> list2) {\n        return subtract(union(list1, list2), intersection(list1, list2));\n    }\n\n    /**\n     * Returns a synchronized list backed by the given list.\n     * <p>\n     * You must manually synchronize on the returned list's iterator to\n     * avoid non-deterministic behavior:\n     *\n     * <pre>\n     * List list = ListUtils.synchronizedList(myList);\n     * synchronized (list) {\n     *     Iterator i = list.iterator();\n     *     while (i.hasNext()) {\n     *         process (i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * This method is just a wrapper for {@link Collections#synchronizedList(List)}.\n     *\n     * @param <E> the element type\n     * @param list  the list to synchronize, must not be null\n     * @return a synchronized list backed by the given list\n     * @throws NullPointerException if the list is null\n     */\n    public static <E> List<E> synchronizedList(final List<E> list) {\n        return Collections.synchronizedList(list);\n    }\n\n    /**\n     * Returns a transformed list backed by the given list.\n     * <p>\n     * This method returns a new list (decorating the specified list) that\n     * will transform any new entries added to it.\n     * Existing entries in the specified list will not be transformed.\n     * <p>\n     * Each object is passed through the transformer as it is added to the\n     * List. It is important not to use the original list after invoking this\n     * method, as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified list will not be transformed.\n     * If you want that behavior, see {@link TransformedList#transformedList}.\n     *\n     * @param <E> the element type\n     * @param list  the list to predicate, must not be null\n     * @param transformer  the transformer for the list, must not be null\n     * @return a transformed list backed by the given list\n     * @throws NullPointerException if the List or Transformer is null\n     */\n    public static <E> List<E> transformedList(final List<E> list,\n                                              final Transformer<? super E, ? extends E> transformer) {\n        return TransformedList.transformingList(list, transformer);\n    }\n\n    /**\n     * Returns a new list containing the second list appended to the\n     * first list.  The {@link List#addAll(Collection)} operation is\n     * used to append the two given lists into a new list.\n     *\n     * @param <E> the element type\n     * @param list1  the first list\n     * @param list2  the second list\n     * @return a new list containing the union of those lists\n     * @throws NullPointerException if either list is null\n     */\n    public static <E> List<E> union(final List<? extends E> list1, final List<? extends E> list2) {\n        final ArrayList<E> result = new ArrayList<>(list1.size() + list2.size());\n        result.addAll(list1);\n        result.addAll(list2);\n        return result;\n    }\n\n    /**\n     * Returns an unmodifiable list backed by the given list.\n     * <p>\n     * This method uses the implementation in the decorators subpackage.\n     *\n     * @param <E>  the element type\n     * @param list  the list to make unmodifiable, must not be null\n     * @return an unmodifiable list backed by the given list\n     * @throws NullPointerException if the list is null\n     */\n    public static <E> List<E> unmodifiableList(final List<? extends E> list) {\n        return UnmodifiableList.unmodifiableList(list);\n    }\n\n    /**\n     * Don't allow instances.\n     */\n    private ListUtils() {\n        // empty\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/org/apache/commons/collections4/ArrayStack.java.ArrayStack", "name": "ArrayStack", "file_path": "src/main/java/org/apache/commons/collections4/ArrayStack.java", "superclasses": "", "methods": ["[]ArrayStack()", "[]ArrayStack(int)", "[boolean]empty()", "[E]peek()", "[E]peek(int)", "[E]pop()", "[E]push(E)", "[int]search(Object)"], "method_uris": ["src/main/java/org/apache/commons/collections4/ArrayStack.java.ArrayStack.[]ArrayStack()", "src/main/java/org/apache/commons/collections4/ArrayStack.java.ArrayStack.[]ArrayStack(int)", "src/main/java/org/apache/commons/collections4/ArrayStack.java.ArrayStack.[boolean]empty()", "src/main/java/org/apache/commons/collections4/ArrayStack.java.ArrayStack.[E]peek()", "src/main/java/org/apache/commons/collections4/ArrayStack.java.ArrayStack.[E]peek(int)", "src/main/java/org/apache/commons/collections4/ArrayStack.java.ArrayStack.[E]pop()", "src/main/java/org/apache/commons/collections4/ArrayStack.java.ArrayStack.[E]push(E)", "src/main/java/org/apache/commons/collections4/ArrayStack.java.ArrayStack.[int]search(Object)"], "overrides": null, "attributes": [], "class_docstring": "\nAn implementation of the {@link java.util.Stack} API that is based on an\n{@code ArrayList} instead of a {@code Vector}, so it is not\nsynchronized to protect against multithreaded access.  The implementation\nis therefore operates faster in environments where you do not need to\nworry about multiple thread contention.\n<p>\nThe removal order of an {@code ArrayStack} is based on insertion\norder: The most recently added element is removed first.  The iteration\norder is <em>not</em> the same as the removal order.  The iterator returns\nelements from the bottom up.\n</p>\n<p>\nUnlike {@code Stack}, {@code ArrayStack} accepts null entries.\n<p>\n<b>Note:</b> From version 4.0 onwards, this class does not implement the\nremoved {@code Buffer} interface anymore.\n</p>\n\n@param <E> the type of elements in this list\n@see java.util.Stack\n@since 1.0\n@deprecated use {@link java.util.ArrayDeque} instead (available from Java 1.6)\n", "original_string": "@Deprecated\npublic class ArrayStack<E> extends ArrayList<E> {\n\n    /** Ensure serialization compatibility */\n    private static final long serialVersionUID = 2130079159931574599L;\n\n    /**\n     * Constructs a new empty {@code ArrayStack}. The initial size\n     * is controlled by {@code ArrayList} and is currently 10.\n     */\n    public ArrayStack() {\n    }\n\n    /**\n     * Constructs a new empty {@code ArrayStack} with an initial size.\n     *\n     * @param initialSize  the initial size to use\n     * @throws IllegalArgumentException  if the specified initial size\n     *  is negative\n     */\n    public ArrayStack(final int initialSize) {\n        super(initialSize);\n    }\n\n    /**\n     * Return {@code true} if this stack is currently empty.\n     * <p>\n     * This method exists for compatibility with {@link java.util.Stack}.\n     * New users of this class should use {@code isEmpty} instead.\n     *\n     * @return true if the stack is currently empty\n     */\n    public boolean empty() {\n        return isEmpty();\n    }\n\n    /**\n     * Returns the top item off of this stack without removing it.\n     *\n     * @return the top item on the stack\n     * @throws EmptyStackException  if the stack is empty\n     */\n    public E peek() throws EmptyStackException {\n        final int n = size();\n        if (n <= 0) {\n            throw new EmptyStackException();\n        }\n        return get(n - 1);\n    }\n\n    /**\n     * Returns the n'th item down (zero-relative) from the top of this\n     * stack without removing it.\n     *\n     * @param n  the number of items down to go\n     * @return the n'th item on the stack, zero relative\n     * @throws EmptyStackException  if there are not enough items on the\n     *  stack to satisfy this request\n     */\n    public E peek(final int n) throws EmptyStackException {\n        final int m = size() - n - 1;\n        if (m < 0) {\n            throw new EmptyStackException();\n        }\n        return get(m);\n    }\n\n    /**\n     * Pops the top item off of this stack and return it.\n     *\n     * @return the top item on the stack\n     * @throws EmptyStackException  if the stack is empty\n     */\n    public E pop() throws EmptyStackException {\n        final int n = size();\n        if (n <= 0) {\n            throw new EmptyStackException();\n        }\n        return remove(n - 1);\n    }\n\n    /**\n     * Pushes a new item onto the top of this stack. The pushed item is also\n     * returned. This is equivalent to calling {@code add}.\n     *\n     * @param item  the item to be added\n     * @return the item just pushed\n     */\n    public E push(final E item) {\n        add(item);\n        return item;\n    }\n\n    /**\n     * Returns the one-based position of the distance from the top that the\n     * specified object exists on this stack, where the top-most element is\n     * considered to be at distance {@code 1}.  If the object is not\n     * present on the stack, return {@code -1} instead.  The\n     * {@code equals()} method is used to compare to the items\n     * in this stack.\n     *\n     * @param object  the object to be searched for\n     * @return the 1-based depth into the stack of the object, or -1 if not found\n     */\n    public int search(final Object object) {\n        int i = size() - 1;        // Current index\n        int n = 1;                 // Current distance\n        while (i >= 0) {\n            final Object current = get(i);\n            if (object == null && current == null ||\n                object != null && object.equals(current)) {\n                return n;\n            }\n            i--;\n            n++;\n        }\n        return -1;\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = 2130079159931574599L;", "docstring": " Ensure serialization compatibility", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 2130079159931574599L", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/FunctorException.java.FunctorException", "name": "FunctorException", "file_path": "src/main/java/org/apache/commons/collections4/FunctorException.java", "superclasses": "RuntimeException", "methods": ["[]FunctorException()", "[]FunctorException(String)", "[]FunctorException(String,Throwable)", "[]FunctorException(Throwable)"], "method_uris": ["src/main/java/org/apache/commons/collections4/FunctorException.java.FunctorException.[]FunctorException()", "src/main/java/org/apache/commons/collections4/FunctorException.java.FunctorException.[]FunctorException(String)", "src/main/java/org/apache/commons/collections4/FunctorException.java.FunctorException.[]FunctorException(String,Throwable)", "src/main/java/org/apache/commons/collections4/FunctorException.java.FunctorException.[]FunctorException(Throwable)"], "overrides": null, "attributes": [], "class_docstring": "\nRuntime exception thrown from functors.\nIf required, a root cause error can be wrapped within this one.\n\n@since 3.0\n", "original_string": "public class FunctorException extends RuntimeException {\n\n    /** Serialization version */\n    private static final long serialVersionUID = -4704772662059351193L;\n\n    /**\n     * Constructs a new {@code FunctorException} without specified\n     * detail message.\n     */\n    public FunctorException() {\n    }\n\n    /**\n     * Constructs a new {@code FunctorException} with specified\n     * detail message.\n     *\n     * @param msg  the error message.\n     */\n    public FunctorException(final String msg) {\n        super(msg);\n    }\n\n    /**\n     * Constructs a new {@code FunctorException} with specified\n     * detail message and nested {@code Throwable} root cause.\n     *\n     * @param msg        the error message.\n     * @param rootCause  the exception or error that caused this exception\n     *                   to be thrown.\n     */\n    public FunctorException(final String msg, final Throwable rootCause) {\n        super(msg, rootCause);\n    }\n\n    /**\n     * Constructs a new {@code FunctorException} with specified\n     * nested {@code Throwable} root cause.\n     *\n     * @param rootCause  the exception or error that caused this exception\n     *                   to be thrown.\n     */\n    public FunctorException(final Throwable rootCause) {\n        super(rootCause);\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = -4704772662059351193L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -4704772662059351193L", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/ComparatorUtils.java.ComparatorUtils", "name": "ComparatorUtils", "file_path": "src/main/java/org/apache/commons/collections4/ComparatorUtils.java", "superclasses": "", "methods": ["[Comparator<Boolean>]booleanComparator(boolean)", "[Comparator<E>]chainedComparator(Collection<Comparator<E>>)", "[Comparator<E>]chainedComparator()", "[E]max(E,E,Comparator<E>)", "[E]min(E,E,Comparator<E>)", "[Comparator<E>]naturalComparator()", "[Comparator<E>]nullHighComparator(Comparator<E>)", "[Comparator<E>]nullLowComparator(Comparator<E>)", "[Comparator<E>]reversedComparator(Comparator<E>)", "[Comparator<I>]transformedComparator(Comparator<O>,Transformer<? super I, ? extends O>)", "[]ComparatorUtils()"], "method_uris": ["src/main/java/org/apache/commons/collections4/ComparatorUtils.java.ComparatorUtils.[Comparator<Boolean>]booleanComparator(boolean)", "src/main/java/org/apache/commons/collections4/ComparatorUtils.java.ComparatorUtils.[Comparator<E>]chainedComparator(Collection<Comparator<E>>)", "src/main/java/org/apache/commons/collections4/ComparatorUtils.java.ComparatorUtils.[Comparator<E>]chainedComparator()", "src/main/java/org/apache/commons/collections4/ComparatorUtils.java.ComparatorUtils.[E]max(E,E,Comparator<E>)", "src/main/java/org/apache/commons/collections4/ComparatorUtils.java.ComparatorUtils.[E]min(E,E,Comparator<E>)", "src/main/java/org/apache/commons/collections4/ComparatorUtils.java.ComparatorUtils.[Comparator<E>]naturalComparator()", "src/main/java/org/apache/commons/collections4/ComparatorUtils.java.ComparatorUtils.[Comparator<E>]nullHighComparator(Comparator<E>)", "src/main/java/org/apache/commons/collections4/ComparatorUtils.java.ComparatorUtils.[Comparator<E>]nullLowComparator(Comparator<E>)", "src/main/java/org/apache/commons/collections4/ComparatorUtils.java.ComparatorUtils.[Comparator<E>]reversedComparator(Comparator<E>)", "src/main/java/org/apache/commons/collections4/ComparatorUtils.java.ComparatorUtils.[Comparator<I>]transformedComparator(Comparator<O>,Transformer<? super I, ? extends O>)", "src/main/java/org/apache/commons/collections4/ComparatorUtils.java.ComparatorUtils.[]ComparatorUtils()"], "overrides": null, "attributes": [], "class_docstring": "\nProvides convenient static utility methods for <Code>Comparator</Code>\nobjects.\n<p>\nMost of the functionality in this class can also be found in the\n{@code comparators} package. This class merely provides a\nconvenient central place if you have use for more than one class\nin the {@code comparators} subpackage.\n</p>\n\n@since 2.1\n", "original_string": "public class ComparatorUtils {\n\n    @SuppressWarnings(\"rawtypes\")\n    private static final Comparator[] EMPTY_COMPARATOR_ARRAY = {};\n\n    /**\n     * Comparator for natural sort order.\n     *\n     * @see ComparableComparator#comparableComparator()\n     */\n    @SuppressWarnings({ \"rawtypes\", \"unchecked\" }) // explicit type needed for Java 1.5 compilation\n    public static final Comparator NATURAL_COMPARATOR = ComparableComparator.<Comparable>comparableComparator();\n\n    /**\n     * Gets a Comparator that can sort Boolean objects.\n     * <p>\n     * The parameter specifies whether true or false is sorted first.\n     * </p>\n     * <p>\n     * The comparator throws NullPointerException if a null value is compared.\n     * </p>\n     *\n     * @param trueFirst  when {@code true}, sort\n     *        {@code true} {@link Boolean}s before\n     *        {@code false} {@link Boolean}s.\n     * @return  a comparator that sorts booleans\n     */\n    public static Comparator<Boolean> booleanComparator(final boolean trueFirst) {\n        return BooleanComparator.booleanComparator(trueFirst);\n    }\n\n    /**\n     * Gets a comparator that compares using a collection of {@link Comparator}s,\n     * applied in (default iterator) sequence until one returns not equal or the\n     * collection is exhausted.\n     *\n     * @param <E>  the object type to compare\n     * @param comparators  the comparators to use, not null or empty or containing nulls\n     * @return a {@link ComparatorChain} formed from the input comparators\n     * @throws NullPointerException if comparators collection is null or contains a null\n     * @throws ClassCastException if the comparators collection contains the wrong object type\n     * @see ComparatorChain\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static <E> Comparator<E> chainedComparator(final Collection<Comparator<E>> comparators) {\n        return chainedComparator(comparators.toArray(EMPTY_COMPARATOR_ARRAY));\n    }\n\n    /**\n     * Gets a comparator that compares using an array of {@link Comparator}s, applied\n     * in sequence until one returns not equal or the array is exhausted.\n     *\n     * @param <E>  the object type to compare\n     * @param comparators  the comparators to use, not null or empty or containing nulls\n     * @return a {@link ComparatorChain} formed from the input comparators\n     * @throws NullPointerException if comparators array is null or contains a null\n     * @see ComparatorChain\n     */\n    public static <E> Comparator<E> chainedComparator(final Comparator<E>... comparators) {\n        final ComparatorChain<E> chain = new ComparatorChain<>();\n        for (final Comparator<E> comparator : comparators) {\n            chain.addComparator(Objects.requireNonNull(comparator, \"comparator\"));\n        }\n        return chain;\n    }\n\n    /**\n     * Returns the largest of the given objects according to the given\n     * comparator, returning the second object if the comparator\n     * returns equal.\n     *\n     * @param <E>  the object type to compare\n     * @param o1  the first object to compare\n     * @param o2  the second object to compare\n     * @param comparator  the sort order to use\n     * @return  the larger of the two objects\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static <E> E max(final E o1, final E o2, Comparator<E> comparator) {\n        if (comparator == null) {\n            comparator = NATURAL_COMPARATOR;\n        }\n        final int c = comparator.compare(o1, o2);\n        return c > 0 ? o1 : o2;\n    }\n\n    /**\n     * Returns the smallest of the given objects according to the given\n     * comparator, returning the second object if the comparator\n     * returns equal.\n     *\n     * @param <E>  the object type to compare\n     * @param o1  the first object to compare\n     * @param o2  the second object to compare\n     * @param comparator  the sort order to use\n     * @return  the smaller of the two objects\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static <E> E min(final E o1, final E o2, Comparator<E> comparator) {\n        if (comparator == null) {\n            comparator = NATURAL_COMPARATOR;\n        }\n        final int c = comparator.compare(o1, o2);\n        return c < 0 ? o1 : o2;\n    }\n\n    /**\n     * Gets a comparator that uses the natural order of the objects.\n     *\n     * @param <E>  the object type to compare\n     * @return  a comparator which uses natural order\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static <E extends Comparable<? super E>> Comparator<E> naturalComparator() {\n        return NATURAL_COMPARATOR;\n    }\n\n    /**\n     * Gets a Comparator that controls the comparison of {@code null} values.\n     * <p>\n     * The returned comparator will consider a null value to be greater than\n     * any nonnull value, and equal to any other null value.  Two nonnull\n     * values will be evaluated with the given comparator.\n     * </p>\n     *\n     * @param <E>  the object type to compare\n     * @param comparator the comparator that wants to allow nulls\n     * @return  a version of that comparator that allows nulls\n     * @see NullComparator\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static <E> Comparator<E> nullHighComparator(Comparator<E> comparator) {\n        if (comparator == null) {\n            comparator = NATURAL_COMPARATOR;\n        }\n        return new NullComparator<>(comparator, true);\n    }\n\n    /**\n     * Gets a Comparator that controls the comparison of {@code null} values.\n     * <p>\n     * The returned comparator will consider a null value to be less than\n     * any nonnull value, and equal to any other null value.  Two nonnull\n     * values will be evaluated with the given comparator.\n     * </p>\n     *\n     * @param <E>  the object type to compare\n     * @param comparator the comparator that wants to allow nulls\n     * @return  a version of that comparator that allows nulls\n     * @see NullComparator\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static <E> Comparator<E> nullLowComparator(Comparator<E> comparator) {\n        if (comparator == null) {\n            comparator = NATURAL_COMPARATOR;\n        }\n        return new NullComparator<>(comparator, false);\n    }\n\n    /**\n     * Gets a comparator that reverses the order of the given comparator.\n     *\n     * @param <E>  the object type to compare\n     * @param comparator  the comparator to reverse\n     * @return  a comparator that reverses the order of the input comparator\n     * @see ReverseComparator\n     */\n    public static <E> Comparator<E> reversedComparator(final Comparator<E> comparator) {\n        return new ReverseComparator<>(comparator);\n    }\n\n    /**\n     * Gets a Comparator that passes transformed objects to the given comparator.\n     * <p>\n     * Objects passed to the returned comparator will first be transformed\n     * by the given transformer before they are compared by the given\n     * comparator.\n     * </p>\n     *\n     * @param <I>  the input object type of the transformed comparator\n     * @param <O>  the object type of the decorated comparator\n     * @param comparator  the sort order to use\n     * @param transformer  the transformer to use\n     * @return  a comparator that transforms its input objects before comparing them\n     * @see  TransformingComparator\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static <I, O> Comparator<I> transformedComparator(Comparator<O> comparator,\n            final Transformer<? super I, ? extends O> transformer) {\n\n        if (comparator == null) {\n            comparator = NATURAL_COMPARATOR;\n        }\n        return new TransformingComparator<>(transformer, comparator);\n    }\n\n    /**\n     * Don't allow instances.\n     */\n    private ComparatorUtils() {\n        // empty\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "@SuppressWarnings(\"rawtypes\")\n    private static final Comparator[] EMPTY_COMPARATOR_ARRAY = {};", "docstring": "", "modifiers": "@SuppressWarnings(\"rawtypes\")\n    private static final", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"rawtypes\")", "private", "static", "final"], "comments": [], "type": "Comparator[]", "name": "EMPTY_COMPARATOR_ARRAY = {}", "syntax_pass": true}, {"attribute_expression": "@SuppressWarnings({ \"rawtypes\", \"unchecked\" }) // explicit type needed for Java 1.5 compilation\n    public static final Comparator NATURAL_COMPARATOR = ComparableComparator.<Comparable>comparableComparator();", "docstring": "\nComparator for natural sort order.\n\n@see ComparableComparator#comparableComparator()\n", "modifiers": "@SuppressWarnings({ \"rawtypes\", \"unchecked\" }) // explicit type needed for Java 1.5 compilation\n    public static final", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings({ \"rawtypes\", \"unchecked\" })", "public", "static", "final"], "comments": ["// explicit type needed for Java 1.5 compilation"], "type": "Comparator", "name": "NATURAL_COMPARATOR = ComparableComparator.<Comparable>comparableComparator()", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/QueueUtils.java.QueueUtils", "name": "QueueUtils", "file_path": "src/main/java/org/apache/commons/collections4/QueueUtils.java", "superclasses": "", "methods": ["[Queue<E>]emptyQueue()", "[Queue<E>]predicatedQueue(Queue<E>,Predicate<? super E>)", "[Queue<E>]synchronizedQueue(Queue<E>)", "[Queue<E>]transformingQueue(Queue<E>,Transformer<? super E, ? extends E>)", "[Queue<E>]unmodifiableQueue(Queue<? extends E>)", "[]QueueUtils()"], "method_uris": ["src/main/java/org/apache/commons/collections4/QueueUtils.java.QueueUtils.[Queue<E>]emptyQueue()", "src/main/java/org/apache/commons/collections4/QueueUtils.java.QueueUtils.[Queue<E>]predicatedQueue(Queue<E>,Predicate<? super E>)", "src/main/java/org/apache/commons/collections4/QueueUtils.java.QueueUtils.[Queue<E>]synchronizedQueue(Queue<E>)", "src/main/java/org/apache/commons/collections4/QueueUtils.java.QueueUtils.[Queue<E>]transformingQueue(Queue<E>,Transformer<? super E, ? extends E>)", "src/main/java/org/apache/commons/collections4/QueueUtils.java.QueueUtils.[Queue<E>]unmodifiableQueue(Queue<? extends E>)", "src/main/java/org/apache/commons/collections4/QueueUtils.java.QueueUtils.[]QueueUtils()"], "overrides": null, "attributes": [], "class_docstring": "\nProvides utility methods and decorators for {@link Queue} instances.\n\n@since 4.0\n", "original_string": "public class QueueUtils {\n\n    /**\n     * An empty unmodifiable queue.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty queue is compatible with any type\n    public static final Queue EMPTY_QUEUE = UnmodifiableQueue.unmodifiableQueue(new LinkedList<>());\n\n    /**\n     * Gets an empty {@code Queue}.\n     *\n     * @param <E> the type of the elements in the queue\n     * @return an empty {@link Queue}\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty queue is compatible with any type\n    public static <E> Queue<E> emptyQueue() {\n        return EMPTY_QUEUE;\n    }\n\n    /**\n     * Returns a predicated (validating) queue backed by the given queue.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to the queue.\n     * Trying to add an invalid object results in an IllegalArgumentException.\n     * It is important not to use the original queue after invoking this method,\n     * as it is a backdoor for adding invalid objects.\n     *\n     * @param <E> the type of the elements in the queue\n     * @param queue  the queue to predicate, must not be null\n     * @param predicate  the predicate used to evaluate new elements, must not be null\n     * @return a predicated queue\n     * @throws NullPointerException if the queue or predicate is null\n     */\n    public static <E> Queue<E> predicatedQueue(final Queue<E> queue, final Predicate<? super E> predicate) {\n        return PredicatedQueue.predicatedQueue(queue, predicate);\n    }\n\n    /**\n     * Returns a synchronized (thread-safe) queue backed by the given queue.\n     * In order to guarantee serial access, it is critical that all access to the\n     * backing queue is accomplished through the returned queue.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned queue\n     * when iterating over it:\n     *\n     * <pre>\n     * Queue queue = QueueUtils.synchronizedQueue(new CircularFifoQueue());\n     * ...\n     * synchronized(queue) {\n     *     Iterator i = queue.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param queue the queue to synchronize, must not be null\n     * @return a synchronized queue backed by that queue\n     * @throws NullPointerException if the queue is null\n     * @since 4.2\n     */\n    public static <E> Queue<E> synchronizedQueue(final Queue<E> queue) {\n        return SynchronizedQueue.synchronizedQueue(queue);\n    }\n\n    /**\n     * Returns a transformed queue backed by the given queue.\n     * <p>\n     * Each object is passed through the transformer as it is added to the\n     * Queue. It is important not to use the original queue after invoking this\n     * method, as it is a backdoor for adding untransformed objects.\n     * <p>\n     * Existing entries in the specified queue will not be transformed.\n     * If you want that behavior, see {@link TransformedQueue#transformedQueue}.\n     *\n     * @param <E> the type of the elements in the queue\n     * @param queue  the queue to predicate, must not be null\n     * @param transformer  the transformer for the queue, must not be null\n     * @return a transformed queue backed by the given queue\n     * @throws NullPointerException if the queue or transformer is null\n     */\n    public static <E> Queue<E> transformingQueue(final Queue<E> queue, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedQueue.transformingQueue(queue, transformer);\n    }\n\n    /**\n     * Returns an unmodifiable queue backed by the given queue.\n     *\n     * @param <E> the type of the elements in the queue\n     * @param queue  the queue to make unmodifiable, must not be null\n     * @return an unmodifiable queue backed by that queue\n     * @throws NullPointerException if the queue is null\n     */\n    public static <E> Queue<E> unmodifiableQueue(final Queue<? extends E> queue) {\n        return UnmodifiableQueue.unmodifiableQueue(queue);\n    }\n\n    /**\n     * Don't allow instances.\n     */\n    private QueueUtils() {\n        // empty\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "@SuppressWarnings(\"rawtypes\") // OK, empty queue is compatible with any type\n    public static final Queue EMPTY_QUEUE = UnmodifiableQueue.unmodifiableQueue(new LinkedList<>());", "docstring": "\nAn empty unmodifiable queue.\n", "modifiers": "@SuppressWarnings(\"rawtypes\") // OK, empty queue is compatible with any type\n    public static final", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"rawtypes\")", "public", "static", "final"], "comments": ["// OK, empty queue is compatible with any type"], "type": "Queue", "name": "EMPTY_QUEUE = UnmodifiableQueue.unmodifiableQueue(new LinkedList<>())", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/BagUtils.java.BagUtils", "name": "BagUtils", "file_path": "src/main/java/org/apache/commons/collections4/BagUtils.java", "superclasses": "", "methods": ["[Bag<E>]collectionBag(Bag<E>)", "[Bag<E>]emptyBag()", "[SortedBag<E>]emptySortedBag()", "[Bag<E>]predicatedBag(Bag<E>,Predicate<? super E>)", "[SortedBag<E>]predicatedSortedBag(SortedBag<E>,Predicate<? super E>)", "[Bag<E>]synchronizedBag(Bag<E>)", "[SortedBag<E>]synchronizedSortedBag(SortedBag<E>)", "[Bag<E>]transformingBag(Bag<E>,Transformer<? super E, ? extends E>)", "[SortedBag<E>]transformingSortedBag(SortedBag<E>,Transformer<? super E, ? extends E>)", "[Bag<E>]unmodifiableBag(Bag<? extends E>)", "[SortedBag<E>]unmodifiableSortedBag(SortedBag<E>)", "[]BagUtils()"], "method_uris": ["src/main/java/org/apache/commons/collections4/BagUtils.java.BagUtils.[Bag<E>]collectionBag(Bag<E>)", "src/main/java/org/apache/commons/collections4/BagUtils.java.BagUtils.[Bag<E>]emptyBag()", "src/main/java/org/apache/commons/collections4/BagUtils.java.BagUtils.[SortedBag<E>]emptySortedBag()", "src/main/java/org/apache/commons/collections4/BagUtils.java.BagUtils.[Bag<E>]predicatedBag(Bag<E>,Predicate<? super E>)", "src/main/java/org/apache/commons/collections4/BagUtils.java.BagUtils.[SortedBag<E>]predicatedSortedBag(SortedBag<E>,Predicate<? super E>)", "src/main/java/org/apache/commons/collections4/BagUtils.java.BagUtils.[Bag<E>]synchronizedBag(Bag<E>)", "src/main/java/org/apache/commons/collections4/BagUtils.java.BagUtils.[SortedBag<E>]synchronizedSortedBag(SortedBag<E>)", "src/main/java/org/apache/commons/collections4/BagUtils.java.BagUtils.[Bag<E>]transformingBag(Bag<E>,Transformer<? super E, ? extends E>)", "src/main/java/org/apache/commons/collections4/BagUtils.java.BagUtils.[SortedBag<E>]transformingSortedBag(SortedBag<E>,Transformer<? super E, ? extends E>)", "src/main/java/org/apache/commons/collections4/BagUtils.java.BagUtils.[Bag<E>]unmodifiableBag(Bag<? extends E>)", "src/main/java/org/apache/commons/collections4/BagUtils.java.BagUtils.[SortedBag<E>]unmodifiableSortedBag(SortedBag<E>)", "src/main/java/org/apache/commons/collections4/BagUtils.java.BagUtils.[]BagUtils()"], "overrides": null, "attributes": [], "class_docstring": "\nProvides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n\n@since 2.1\n", "original_string": "public class BagUtils {\n\n    /**\n     * An empty unmodifiable bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<>());\n\n    /**\n     * An empty unmodifiable sorted bag.\n     */\n    @SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<>());\n\n    /**\n     * Returns a bag that complies to the Collection contract, backed by the given bag.\n     *\n     * @param <E> the element type\n     * @param bag the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return CollectionBag.collectionBag(bag);\n    }\n\n    /**\n     * Gets an empty {@code Bag}.\n     *\n     * @param <E> the element type\n     * @return an empty Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> Bag<E> emptyBag() {\n        return EMPTY_BAG;\n    }\n\n    /**\n     * Gets an empty {@code SortedBag}.\n     *\n     * @param <E> the element type\n     * @return an empty sorted Bag\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n    public static <E> SortedBag<E> emptySortedBag() {\n        return (SortedBag<E>) EMPTY_SORTED_BAG;\n    }\n\n    /**\n     * Returns a predicated (validating) bag backed by the given bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     * </p>\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the Bag or Predicate is null\n     */\n    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return PredicatedBag.predicatedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a predicated (validating) sorted bag backed by the given sorted\n     * bag.\n     * <p>\n     * Only objects that pass the test in the given predicate can be added to\n     * the bag. Trying to add an invalid object results in an\n     * IllegalArgumentException. It is important not to use the original bag\n     * after invoking this method, as it is a backdoor for adding invalid\n     * objects.\n     * </p>\n     *\n     * @param <E> the element type\n     * @param bag the sorted bag to predicate, must not be null\n     * @param predicate the predicate for the bag, must not be null\n     * @return a predicated bag backed by the given bag\n     * @throws NullPointerException if the SortedBag or Predicate is null\n     */\n    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n            final Predicate<? super E> predicate) {\n        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n    }\n\n    /**\n     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n     * order to guarantee serial access, it is critical that all access to the\n     * backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     * </p>\n     *\n     * <pre>\n     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n        return SynchronizedBag.synchronizedBag(bag);\n    }\n\n    /**\n     * Returns a synchronized (thread-safe) sorted bag backed by the given\n     * sorted bag. In order to guarantee serial access, it is critical that all\n     * access to the backing bag is accomplished through the returned bag.\n     * <p>\n     * It is imperative that the user manually synchronize on the returned bag\n     * when iterating over it:\n     * </p>\n     *\n     * <pre>\n     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n     * ...\n     * synchronized(bag) {\n     *     Iterator i = bag.iterator(); // Must be in synchronized block\n     *     while (i.hasNext())\n     *         foo(i.next());\n     *     }\n     * }\n     * </pre>\n     *\n     * Failure to follow this advice may result in non-deterministic behavior.\n     *\n     * @param <E> the element type\n     * @param bag the bag to synchronize, must not be null\n     * @return a synchronized bag backed by that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n    }\n\n    /**\n     * Returns a transformed bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * </p>\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behavior, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n     * </p>\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return TransformedBag.transformingBag(bag, transformer);\n    }\n\n    /**\n     * Returns a transformed sorted bag backed by the given bag.\n     * <p>\n     * Each object is passed through the transformer as it is added to the Bag.\n     * It is important not to use the original bag after invoking this method,\n     * as it is a backdoor for adding untransformed objects.\n     * </p>\n     * <p>\n     * Existing entries in the specified bag will not be transformed.\n     * If you want that behavior, see\n     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n     * </p>\n     *\n     * @param <E> the element type\n     * @param bag the bag to predicate, must not be null\n     * @param transformer the transformer for the bag, must not be null\n     * @return a transformed bag backed by the given bag\n     * @throws NullPointerException if the Bag or Transformer is null\n     */\n    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given bag. Any modification attempts\n     * to the returned bag will raise an {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the Bag is null\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        return UnmodifiableBag.unmodifiableBag(bag);\n    }\n\n    /**\n     * Returns an unmodifiable view of the given sorted bag. Any modification\n     * attempts to the returned bag will raise an\n     * {@link UnsupportedOperationException}.\n     *\n     * @param <E> the element type\n     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n     * @return an unmodifiable view of that bag\n     * @throws NullPointerException if the SortedBag is null\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n    }\n\n    /**\n     * Don't allow instances.\n     */\n    private BagUtils() {\n        // empty\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "@SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<>());", "docstring": "\nAn empty unmodifiable bag.\n", "modifiers": "@SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"rawtypes\")", "public", "static", "final"], "comments": ["// OK, empty bag is compatible with any type"], "type": "Bag", "name": "EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<>())", "syntax_pass": true}, {"attribute_expression": "@SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final Bag EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<>());", "docstring": "\nAn empty unmodifiable sorted bag.\n", "modifiers": "@SuppressWarnings(\"rawtypes\") // OK, empty bag is compatible with any type\n    public static final", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"rawtypes\")", "public", "static", "final"], "comments": ["// OK, empty bag is compatible with any type"], "type": "Bag", "name": "EMPTY_SORTED_BAG =\n            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<>())", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/EnumerationUtils.java.EnumerationUtils", "name": "EnumerationUtils", "file_path": "src/main/java/org/apache/commons/collections4/EnumerationUtils.java", "superclasses": "", "methods": ["[Iterable<T>]asIterable(Enumeration<T>)", "[T]get(Enumeration<T>,int)", "[List<E>]toList(Enumeration<? extends E>)", "[List<String>]toList(StringTokenizer)", "[]EnumerationUtils()"], "method_uris": ["src/main/java/org/apache/commons/collections4/EnumerationUtils.java.EnumerationUtils.[Iterable<T>]asIterable(Enumeration<T>)", "src/main/java/org/apache/commons/collections4/EnumerationUtils.java.EnumerationUtils.[T]get(Enumeration<T>,int)", "src/main/java/org/apache/commons/collections4/EnumerationUtils.java.EnumerationUtils.[List<E>]toList(Enumeration<? extends E>)", "src/main/java/org/apache/commons/collections4/EnumerationUtils.java.EnumerationUtils.[List<String>]toList(StringTokenizer)", "src/main/java/org/apache/commons/collections4/EnumerationUtils.java.EnumerationUtils.[]EnumerationUtils()"], "overrides": null, "attributes": [], "class_docstring": "\nProvides utility methods for {@link Enumeration} instances.\n\n@since 3.0\n", "original_string": "public class EnumerationUtils {\n\n    /**\n     * Creates an {@link Iterable} that wraps an {@link Enumeration}. The returned {@link Iterable} can be used for a\n     * single iteration.\n     *\n     * @param <T> the element type\n     * @param enumeration the enumeration to use, may not be null\n     * @return a new, single use {@link Iterable}\n     * @since 4.5.0\n     */\n    public static <T> Iterable<T> asIterable(final Enumeration<T> enumeration) {\n        return new IteratorIterable<>(new EnumerationIterator<>(enumeration));\n    }\n\n    /**\n     * Returns the {@code index}-th value in the {@link Enumeration}, throwing\n     * {@code IndexOutOfBoundsException} if there is no such element.\n     * <p>\n     * The Enumeration is advanced to {@code index} (or to the end, if\n     * {@code index} exceeds the number of entries) as a side effect of this method.\n     *\n     * @param e  the enumeration to get a value from\n     * @param index  the index to get\n     * @param <T> the type of object in the {@link Enumeration}\n     * @return the object at the specified index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     * @throws IllegalArgumentException if the object type is invalid\n     * @since 4.1\n     */\n    public static <T> T get(final Enumeration<T> e, final int index) {\n        CollectionUtils.checkIndexBounds(index);\n        int i = index;\n        while (e.hasMoreElements()) {\n            i--;\n            if (i == -1) {\n                return e.nextElement();\n            }\n            e.nextElement();\n        }\n        throw new IndexOutOfBoundsException(\"Entry does not exist: \" + i);\n    }\n\n    /**\n     * Creates a list based on an enumeration.\n     *\n     * <p>As the enumeration is traversed, an ArrayList of its values is\n     * created. The new list is returned.</p>\n     *\n     * @param <E> the element type\n     * @param enumeration  the enumeration to traverse, which should not be {@code null}.\n     * @return a list containing all elements of the given enumeration\n     * @throws NullPointerException if the enumeration parameter is {@code null}.\n     */\n    public static <E> List<E> toList(final Enumeration<? extends E> enumeration) {\n        return IteratorUtils.toList(new EnumerationIterator<>(enumeration));\n    }\n\n    /**\n     * Override toList(Enumeration) for StringTokenizer as it implements Enumeration&lt;Object&gt;\n     * for the sake of backward compatibility.\n     *\n     * @param stringTokenizer  the tokenizer to convert to a {@link List}&lt;{@link String}&gt;\n     * @return a list containing all tokens of the given StringTokenizer\n     */\n    public static List<String> toList(final StringTokenizer stringTokenizer) {\n        final List<String> result = new ArrayList<>(stringTokenizer.countTokens());\n        while (stringTokenizer.hasMoreTokens()) {\n            result.add(stringTokenizer.nextToken());\n        }\n        return result;\n    }\n\n    /**\n     * Don't allow instances.\n     */\n    private EnumerationUtils() {\n        // no instances.\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/org/apache/commons/collections4/IteratorUtils.java.IteratorUtils", "name": "IteratorUtils", "file_path": "src/main/java/org/apache/commons/collections4/IteratorUtils.java", "superclasses": "", "methods": ["[ResettableIterator<E>]arrayIterator()", "[ResettableIterator<E>]arrayIterator(E[],int)", "[ResettableIterator<E>]arrayIterator(E[],int,int)", "[ResettableIterator<E>]arrayIterator(Object)", "[ResettableIterator<E>]arrayIterator(Object,int)", "[ResettableIterator<E>]arrayIterator(Object,int,int)", "[ResettableListIterator<E>]arrayListIterator()", "[ResettableListIterator<E>]arrayListIterator(E[],int)", "[ResettableListIterator<E>]arrayListIterator(E[],int,int)", "[ResettableListIterator<E>]arrayListIterator(Object)", "[ResettableListIterator<E>]arrayListIterator(Object,int)", "[ResettableListIterator<E>]arrayListIterator(Object,int,int)", "[Enumeration<E>]asEnumeration(Iterator<? extends E>)", "[Iterable<E>]asIterable(Iterator<? extends E>)", "[Iterator<E>]asIterator(Enumeration<? extends E>)", "[Iterator<E>]asIterator(Enumeration<? extends E>,Collection<? super E>)", "[Iterable<E>]asMultipleUseIterable(Iterator<? extends E>)", "[BoundedIterator<E>]boundedIterator(Iterator<? extends E>,long)", "[BoundedIterator<E>]boundedIterator(Iterator<? extends E>,long,long)", "[Iterator<E>]chainedIterator(Collection<Iterator<? extends E>>)", "[Iterator<E>]chainedIterator()", "[Iterator<E>]chainedIterator(Iterator<? extends E>,Iterator<? extends E>)", "[Iterator<E>]collatedIterator(Comparator<? super E>,Collection<Iterator<? extends E>>)", "[Iterator<E>]collatedIterator(Comparator<? super E>)", "[Iterator<E>]collatedIterator(Comparator<? super E>,Iterator<? extends E>,Iterator<? extends E>)", "[boolean]contains(Iterator<E>,Object)", "[ResettableIterator<E>]emptyIterator()", "[ResettableListIterator<E>]emptyListIterator()", "[MapIterator<K, V>]emptyMapIterator()", "[OrderedIterator<E>]emptyOrderedIterator()", "[OrderedMapIterator<K, V>]emptyOrderedMapIterator()", "[Iterator<E>]filteredIterator(Iterator<? extends E>,Predicate<? super E>)", "[ListIterator<E>]filteredListIterator(ListIterator<? extends E>,Predicate<? super E>)", "[E]find(Iterator<E>,Predicate<? super E>)", "[E]first(Iterator<E>)", "[void]forEach(Iterator<E>,Closure<? super E>)", "[E]forEachButLast(Iterator<E>,Closure<? super E>)", "[E]get(Iterator<E>,int)", "[Iterator<?>]getIterator(Object)", "[int]indexOf(Iterator<E>,Predicate<? super E>)", "[boolean]isEmpty(Iterator<?>)", "[ResettableIterator<E>]loopingIterator(Collection<? extends E>)", "[ResettableListIterator<E>]loopingListIterator(List<E>)", "[boolean]matchesAll(Iterator<E>,Predicate<? super E>)", "[boolean]matchesAny(Iterator<E>,Predicate<? super E>)", "[NodeListIterator]nodeListIterator(Node)", "[NodeListIterator]nodeListIterator(NodeList)", "[Iterator<E>]objectGraphIterator(E,Transformer<? super E, ? extends E>)", "[Iterator<E>]peekingIterator(Iterator<? extends E>)", "[Iterator<E>]pushbackIterator(Iterator<? extends E>)", "[ResettableIterator<E>]singletonIterator(E)", "[ListIterator<E>]singletonListIterator(E)", "[int]size(Iterator<?>)", "[SkippingIterator<E>]skippingIterator(Iterator<E>,long)", "[Object[]]toArray(Iterator<?>)", "[E[]]toArray(Iterator<? extends E>,Class<E>)", "[List<E>]toList(Iterator<? extends E>)", "[List<E>]toList(Iterator<? extends E>,int)", "[ListIterator<E>]toListIterator(Iterator<? extends E>)", "[String]toString(Iterator<E>)", "[String]toString(Iterator<E>,Transformer<? super E, String>)", "[String]toString(Iterator<E>,Transformer<? super E, String>,String,String,String)", "[Iterator<O>]transformedIterator(Iterator<? extends I>,Transformer<? super I, ? extends O>)", "[Iterator<E>]unmodifiableIterator(Iterator<E>)", "[ListIterator<E>]unmodifiableListIterator(ListIterator<E>)", "[MapIterator<K, V>]unmodifiableMapIterator(MapIterator<K, V>)", "[ZippingIterator<E>]zippingIterator()", "[ZippingIterator<E>]zippingIterator(Iterator<? extends E>,Iterator<? extends E>)", "[ZippingIterator<E>]zippingIterator(Iterator<? extends E>,Iterator<? extends E>,Iterator<? extends E>)", "[]IteratorUtils()"], "method_uris": ["src/main/java/org/apache/commons/collections4/IteratorUtils.java.IteratorUtils.[ResettableIterator<E>]arrayIterator()", "src/main/java/org/apache/commons/collections4/IteratorUtils.java.IteratorUtils.[ResettableIterator<E>]arrayIterator(E[],int)", "src/main/java/org/apache/commons/collections4/IteratorUtils.java.IteratorUtils.[ResettableIterator<E>]arrayIterator(E[],int,int)", "src/main/java/org/apache/commons/collections4/IteratorUtils.java.IteratorUtils.[ResettableIterator<E>]arrayIterator(Object)", "src/main/java/org/apache/commons/collections4/IteratorUtils.java.IteratorUtils.[ResettableIterator<E>]arrayIterator(Object,int)", "src/main/java/org/apache/commons/collections4/IteratorUtils.java.IteratorUtils.[ResettableIterator<E>]arrayIterator(Object,int,int)", "src/main/java/org/apache/commons/collections4/IteratorUtils.java.IteratorUtils.[ResettableListIterator<E>]arrayListIterator()", "src/main/java/org/apache/commons/collections4/IteratorUtils.java.IteratorUtils.[ResettableListIterator<E>]arrayListIterator(E[],int)", "src/main/java/org/apache/commons/collections4/IteratorUtils.java.IteratorUtils.[ResettableListIterator<E>]arrayListIterator(E[],int,int)", "src/main/java/org/apache/commons/collections4/IteratorUtils.java.IteratorUtils.[ResettableListIterator<E>]arrayListIterator(Object)", "src/main/java/org/apache/commons/collections4/IteratorUtils.java.IteratorUtils.[ResettableListIterator<E>]arrayListIterator(Object,int)", "src/main/java/org/apache/commons/collections4/IteratorUtils.java.IteratorUtils.[ResettableListIterator<E>]arrayListIterator(Object,int,int)", "src/main/java/org/apache/commons/collections4/IteratorUtils.java.IteratorUtils.[Enumeration<E>]asEnumeration(Iterator<? extends E>)", "src/main/java/org/apache/commons/collections4/IteratorUtils.java.IteratorUtils.[Iterable<E>]asIterable(Iterator<? extends E>)", "src/main/java/org/apache/commons/collections4/IteratorUtils.java.IteratorUtils.[Iterator<E>]asIterator(Enumeration<? extends E>)", "src/main/java/org/apache/commons/collections4/IteratorUtils.java.IteratorUtils.[Iterator<E>]asIterator(Enumeration<? extends E>,Collection<? super E>)", "src/main/java/org/apache/commons/collections4/IteratorUtils.java.IteratorUtils.[Iterable<E>]asMultipleUseIterable(Iterator<? extends E>)", "src/main/java/org/apache/commons/collections4/IteratorUtils.java.IteratorUtils.[BoundedIterator<E>]boundedIterator(Iterator<? extends E>,long)", "src/main/java/org/apache/commons/collections4/IteratorUtils.java.IteratorUtils.[BoundedIterator<E>]boundedIterator(Iterator<? extends E>,long,long)", "src/main/java/org/apache/commons/collections4/IteratorUtils.java.IteratorUtils.[Iterator<E>]chainedIterator(Collection<Iterator<? extends E>>)", "src/main/java/org/apache/commons/collections4/IteratorUtils.java.IteratorUtils.[Iterator<E>]chainedIterator()", "src/main/java/org/apache/commons/collections4/IteratorUtils.java.IteratorUtils.[Iterator<E>]chainedIterator(Iterator<? extends E>,Iterator<? extends E>)", "src/main/java/org/apache/commons/collections4/IteratorUtils.java.IteratorUtils.[Iterator<E>]collatedIterator(Comparator<? super E>,Collection<Iterator<? extends E>>)", "src/main/java/org/apache/commons/collections4/IteratorUtils.java.IteratorUtils.[Iterator<E>]collatedIterator(Comparator<? super E>)", "src/main/java/org/apache/commons/collections4/IteratorUtils.java.IteratorUtils.[Iterator<E>]collatedIterator(Comparator<? super E>,Iterator<? extends E>,Iterator<? extends E>)", "src/main/java/org/apache/commons/collections4/IteratorUtils.java.IteratorUtils.[boolean]contains(Iterator<E>,Object)", "src/main/java/org/apache/commons/collections4/IteratorUtils.java.IteratorUtils.[ResettableIterator<E>]emptyIterator()", "src/main/java/org/apache/commons/collections4/IteratorUtils.java.IteratorUtils.[ResettableListIterator<E>]emptyListIterator()", "src/main/java/org/apache/commons/collections4/IteratorUtils.java.IteratorUtils.[MapIterator<K, V>]emptyMapIterator()", "src/main/java/org/apache/commons/collections4/IteratorUtils.java.IteratorUtils.[OrderedIterator<E>]emptyOrderedIterator()", "src/main/java/org/apache/commons/collections4/IteratorUtils.java.IteratorUtils.[OrderedMapIterator<K, V>]emptyOrderedMapIterator()", "src/main/java/org/apache/commons/collections4/IteratorUtils.java.IteratorUtils.[Iterator<E>]filteredIterator(Iterator<? extends E>,Predicate<? super E>)", "src/main/java/org/apache/commons/collections4/IteratorUtils.java.IteratorUtils.[ListIterator<E>]filteredListIterator(ListIterator<? extends E>,Predicate<? super E>)", "src/main/java/org/apache/commons/collections4/IteratorUtils.java.IteratorUtils.[E]find(Iterator<E>,Predicate<? super E>)", "src/main/java/org/apache/commons/collections4/IteratorUtils.java.IteratorUtils.[E]first(Iterator<E>)", "src/main/java/org/apache/commons/collections4/IteratorUtils.java.IteratorUtils.[void]forEach(Iterator<E>,Closure<? super E>)", "src/main/java/org/apache/commons/collections4/IteratorUtils.java.IteratorUtils.[E]forEachButLast(Iterator<E>,Closure<? super E>)", "src/main/java/org/apache/commons/collections4/IteratorUtils.java.IteratorUtils.[E]get(Iterator<E>,int)", "src/main/java/org/apache/commons/collections4/IteratorUtils.java.IteratorUtils.[Iterator<?>]getIterator(Object)", "src/main/java/org/apache/commons/collections4/IteratorUtils.java.IteratorUtils.[int]indexOf(Iterator<E>,Predicate<? super E>)", "src/main/java/org/apache/commons/collections4/IteratorUtils.java.IteratorUtils.[boolean]isEmpty(Iterator<?>)", "src/main/java/org/apache/commons/collections4/IteratorUtils.java.IteratorUtils.[ResettableIterator<E>]loopingIterator(Collection<? extends E>)", "src/main/java/org/apache/commons/collections4/IteratorUtils.java.IteratorUtils.[ResettableListIterator<E>]loopingListIterator(List<E>)", "src/main/java/org/apache/commons/collections4/IteratorUtils.java.IteratorUtils.[boolean]matchesAll(Iterator<E>,Predicate<? super E>)", "src/main/java/org/apache/commons/collections4/IteratorUtils.java.IteratorUtils.[boolean]matchesAny(Iterator<E>,Predicate<? super E>)", "src/main/java/org/apache/commons/collections4/IteratorUtils.java.IteratorUtils.[NodeListIterator]nodeListIterator(Node)", "src/main/java/org/apache/commons/collections4/IteratorUtils.java.IteratorUtils.[NodeListIterator]nodeListIterator(NodeList)", "src/main/java/org/apache/commons/collections4/IteratorUtils.java.IteratorUtils.[Iterator<E>]objectGraphIterator(E,Transformer<? super E, ? extends E>)", "src/main/java/org/apache/commons/collections4/IteratorUtils.java.IteratorUtils.[Iterator<E>]peekingIterator(Iterator<? extends E>)", "src/main/java/org/apache/commons/collections4/IteratorUtils.java.IteratorUtils.[Iterator<E>]pushbackIterator(Iterator<? extends E>)", "src/main/java/org/apache/commons/collections4/IteratorUtils.java.IteratorUtils.[ResettableIterator<E>]singletonIterator(E)", "src/main/java/org/apache/commons/collections4/IteratorUtils.java.IteratorUtils.[ListIterator<E>]singletonListIterator(E)", "src/main/java/org/apache/commons/collections4/IteratorUtils.java.IteratorUtils.[int]size(Iterator<?>)", "src/main/java/org/apache/commons/collections4/IteratorUtils.java.IteratorUtils.[SkippingIterator<E>]skippingIterator(Iterator<E>,long)", "src/main/java/org/apache/commons/collections4/IteratorUtils.java.IteratorUtils.[Object[]]toArray(Iterator<?>)", "src/main/java/org/apache/commons/collections4/IteratorUtils.java.IteratorUtils.[E[]]toArray(Iterator<? extends E>,Class<E>)", "src/main/java/org/apache/commons/collections4/IteratorUtils.java.IteratorUtils.[List<E>]toList(Iterator<? extends E>)", "src/main/java/org/apache/commons/collections4/IteratorUtils.java.IteratorUtils.[List<E>]toList(Iterator<? extends E>,int)", "src/main/java/org/apache/commons/collections4/IteratorUtils.java.IteratorUtils.[ListIterator<E>]toListIterator(Iterator<? extends E>)", "src/main/java/org/apache/commons/collections4/IteratorUtils.java.IteratorUtils.[String]toString(Iterator<E>)", "src/main/java/org/apache/commons/collections4/IteratorUtils.java.IteratorUtils.[String]toString(Iterator<E>,Transformer<? super E, String>)", "src/main/java/org/apache/commons/collections4/IteratorUtils.java.IteratorUtils.[String]toString(Iterator<E>,Transformer<? super E, String>,String,String,String)", "src/main/java/org/apache/commons/collections4/IteratorUtils.java.IteratorUtils.[Iterator<O>]transformedIterator(Iterator<? extends I>,Transformer<? super I, ? extends O>)", "src/main/java/org/apache/commons/collections4/IteratorUtils.java.IteratorUtils.[Iterator<E>]unmodifiableIterator(Iterator<E>)", "src/main/java/org/apache/commons/collections4/IteratorUtils.java.IteratorUtils.[ListIterator<E>]unmodifiableListIterator(ListIterator<E>)", "src/main/java/org/apache/commons/collections4/IteratorUtils.java.IteratorUtils.[MapIterator<K, V>]unmodifiableMapIterator(MapIterator<K, V>)", "src/main/java/org/apache/commons/collections4/IteratorUtils.java.IteratorUtils.[ZippingIterator<E>]zippingIterator()", "src/main/java/org/apache/commons/collections4/IteratorUtils.java.IteratorUtils.[ZippingIterator<E>]zippingIterator(Iterator<? extends E>,Iterator<? extends E>)", "src/main/java/org/apache/commons/collections4/IteratorUtils.java.IteratorUtils.[ZippingIterator<E>]zippingIterator(Iterator<? extends E>,Iterator<? extends E>,Iterator<? extends E>)", "src/main/java/org/apache/commons/collections4/IteratorUtils.java.IteratorUtils.[]IteratorUtils()"], "overrides": null, "attributes": [], "class_docstring": "\nProvides static utility methods and decorators for {@link Iterator}\ninstances. The implementations are provided in the iterators subpackage.\n\n@since 2.1\n", "original_string": "public class IteratorUtils {\n    // validation is done in this class in certain cases because the\n    // public classes allow invalid states\n\n    /**\n     * An iterator over no elements.\n     */\n    @SuppressWarnings(\"rawtypes\")\n    public static final ResettableIterator EMPTY_ITERATOR = EmptyIterator.RESETTABLE_INSTANCE;\n\n    /**\n     * A list iterator over no elements.\n     */\n    @SuppressWarnings(\"rawtypes\")\n    public static final ResettableListIterator EMPTY_LIST_ITERATOR = EmptyListIterator.RESETTABLE_INSTANCE;\n\n    /**\n     * An ordered iterator over no elements.\n     */\n    @SuppressWarnings(\"rawtypes\")\n    public static final OrderedIterator EMPTY_ORDERED_ITERATOR = EmptyOrderedIterator.INSTANCE;\n\n    /**\n     * A map iterator over no elements.\n     */\n    @SuppressWarnings(\"rawtypes\")\n    public static final MapIterator EMPTY_MAP_ITERATOR = EmptyMapIterator.INSTANCE;\n\n    /**\n     * An ordered map iterator over no elements.\n     */\n    @SuppressWarnings(\"rawtypes\")\n    public static final OrderedMapIterator EMPTY_ORDERED_MAP_ITERATOR = EmptyOrderedMapIterator.INSTANCE;\n    /**\n     * Default delimiter used to delimit elements while converting an Iterator\n     * to its String representation.\n     */\n    private static final String DEFAULT_TOSTRING_DELIMITER = \", \";\n\n    // Arrays\n    /**\n     * Gets an iterator over an object array.\n     *\n     * @param <E> the element type\n     * @param array  the array over which to iterate\n     * @return an iterator over the array\n     * @throws NullPointerException if array is null\n     */\n    public static <E> ResettableIterator<E> arrayIterator(final E... array) {\n        return new ObjectArrayIterator<>(array);\n    }\n\n    /**\n     * Gets an iterator over the end part of an object array.\n     *\n     * @param <E> the element type\n     * @param array  the array over which to iterate\n     * @param start  the index to start iterating at\n     * @return an iterator over part of the array\n     * @throws IndexOutOfBoundsException if start is less than zero or greater\n     *   than the length of the array\n     * @throws NullPointerException if array is null\n     */\n    public static <E> ResettableIterator<E> arrayIterator(final E[] array, final int start) {\n        return new ObjectArrayIterator<>(array, start);\n    }\n\n    /**\n     * Gets an iterator over part of an object array.\n     *\n     * @param <E> the element type\n     * @param array  the array over which to iterate\n     * @param start  the index to start iterating at\n     * @param end  the index to finish iterating at\n     * @return an iterator over part of the array\n     * @throws IndexOutOfBoundsException if array bounds are invalid\n     * @throws IllegalArgumentException if end is before start\n     * @throws NullPointerException if array is null\n     */\n    public static <E> ResettableIterator<E> arrayIterator(final E[] array, final int start, final int end) {\n        return new ObjectArrayIterator<>(array, start, end);\n    }\n\n    /**\n     * Gets an iterator over an object or primitive array.\n     * <p>\n     * This method will handle primitive arrays as well as object arrays.\n     * The primitives will be wrapped in the appropriate wrapper class.\n     *\n     * @param <E> the element type\n     * @param array  the array over which to iterate\n     * @return an iterator over the array\n     * @throws IllegalArgumentException if the array is not an array\n     * @throws NullPointerException if array is null\n     */\n    public static <E> ResettableIterator<E> arrayIterator(final Object array) {\n        return new ArrayIterator<>(array);\n    }\n\n    /**\n     * Gets an iterator over the end part of an object or primitive array.\n     * <p>\n     * This method will handle primitive arrays as well as object arrays.\n     * The primitives will be wrapped in the appropriate wrapper class.\n     *\n     * @param <E> the element type\n     * @param array  the array over which to iterate\n     * @param start  the index to start iterating at\n     * @return an iterator over part of the array\n     * @throws IllegalArgumentException if the array is not an array\n     * @throws IndexOutOfBoundsException if start is less than zero or greater\n     *   than the length of the array\n     * @throws NullPointerException if array is null\n     */\n    public static <E> ResettableIterator<E> arrayIterator(final Object array, final int start) {\n        return new ArrayIterator<>(array, start);\n    }\n\n    /**\n     * Gets an iterator over part of an object or primitive array.\n     * <p>\n     * This method will handle primitive arrays as well as object arrays.\n     * The primitives will be wrapped in the appropriate wrapper class.\n     *\n     * @param <E> the element type\n     * @param array  the array over which to iterate\n     * @param start  the index to start iterating at\n     * @param end  the index to finish iterating at\n     * @return an iterator over part of the array\n     * @throws IllegalArgumentException if the array is not an array or end is before start\n     * @throws IndexOutOfBoundsException if array bounds are invalid\n     * @throws NullPointerException if array is null\n     */\n    public static <E> ResettableIterator<E> arrayIterator(final Object array, final int start, final int end) {\n        return new ArrayIterator<>(array, start, end);\n    }\n\n    /**\n     * Gets a list iterator over an object array.\n     *\n     * @param <E> the element type\n     * @param array  the array over which to iterate\n     * @return a list iterator over the array\n     * @throws NullPointerException if array is null\n     */\n    public static <E> ResettableListIterator<E> arrayListIterator(final E... array) {\n        return new ObjectArrayListIterator<>(array);\n    }\n\n    /**\n     * Gets a list iterator over the end part of an object array.\n     *\n     * @param <E> the element type\n     * @param array  the array over which to iterate\n     * @param start  the index to start iterating at\n     * @return a list iterator over part of the array\n     * @throws IndexOutOfBoundsException if start is less than zero\n     * @throws NullPointerException if array is null\n     */\n    public static <E> ResettableListIterator<E> arrayListIterator(final E[] array, final int start) {\n        return new ObjectArrayListIterator<>(array, start);\n    }\n\n    /**\n     * Gets a list iterator over part of an object array.\n     *\n     * @param <E> the element type\n     * @param array  the array over which to iterate\n     * @param start  the index to start iterating at\n     * @param end  the index to finish iterating at\n     * @return a list iterator over part of the array\n     * @throws IndexOutOfBoundsException if array bounds are invalid\n     * @throws IllegalArgumentException if end is before start\n     * @throws NullPointerException if array is null\n     */\n    public static <E> ResettableListIterator<E> arrayListIterator(final E[] array, final int start, final int end) {\n        return new ObjectArrayListIterator<>(array, start, end);\n    }\n\n    /**\n     * Gets a list iterator over an object or primitive array.\n     * <p>\n     * This method will handle primitive arrays as well as object arrays.\n     * The primitives will be wrapped in the appropriate wrapper class.\n     *\n     * @param <E> the element type\n     * @param array  the array over which to iterate\n     * @return a list iterator over the array\n     * @throws IllegalArgumentException if the array is not an array\n     * @throws NullPointerException if array is null\n     */\n    public static <E> ResettableListIterator<E> arrayListIterator(final Object array) {\n        return new ArrayListIterator<>(array);\n    }\n\n    /**\n     * Gets a list iterator over the end part of an object or primitive array.\n     * <p>\n     * This method will handle primitive arrays as well as object arrays.\n     * The primitives will be wrapped in the appropriate wrapper class.\n     *\n     * @param <E> the element type\n     * @param array  the array over which to iterate\n     * @param start  the index to start iterating at\n     * @return a list iterator over part of the array\n     * @throws IllegalArgumentException if the array is not an array\n     * @throws IndexOutOfBoundsException if start is less than zero\n     * @throws NullPointerException if array is null\n     */\n    public static <E> ResettableListIterator<E> arrayListIterator(final Object array, final int start) {\n        return new ArrayListIterator<>(array, start);\n    }\n\n    /**\n     * Gets a list iterator over part of an object or primitive array.\n     * <p>\n     * This method will handle primitive arrays as well as object arrays.\n     * The primitives will be wrapped in the appropriate wrapper class.\n     *\n     * @param <E> the element type\n     * @param array  the array over which to iterate\n     * @param start  the index to start iterating at\n     * @param end  the index to finish iterating at\n     * @return a list iterator over part of the array\n     * @throws IllegalArgumentException if the array is not an array or end is before start\n     * @throws IndexOutOfBoundsException if array bounds are invalid\n     * @throws NullPointerException if array is null\n     */\n    public static <E> ResettableListIterator<E> arrayListIterator(final Object array, final int start, final int end) {\n        return new ArrayListIterator<>(array, start, end);\n    }\n\n    /**\n     * Gets an enumeration that wraps an iterator.\n     *\n     * @param <E> the element type\n     * @param iterator  the iterator to use, may not be null\n     * @return a new enumeration\n     * @throws NullPointerException if iterator is null\n     */\n    public static <E> Enumeration<E> asEnumeration(final Iterator<? extends E> iterator) {\n        return new IteratorEnumeration<>(Objects.requireNonNull(iterator, \"iterator\"));\n    }\n\n    /**\n     * Gets an {@link Iterable} that wraps an iterator.  The returned {@link Iterable} can be\n     * used for a single iteration.\n     *\n     * @param <E> the element type\n     * @param iterator  the iterator to use, may not be null\n     * @return a new, single use {@link Iterable}\n     * @throws NullPointerException if iterator is null\n     */\n    public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator) {\n        Objects.requireNonNull(iterator, \"iterator\");\n        return new IteratorIterable<>(iterator, false);\n    }\n\n    // Views\n    /**\n     * Gets an iterator that provides an iterator view of the given enumeration.\n     *\n     * @param <E> the element type\n     * @param enumeration  the enumeration to use, may not be null\n     * @return a new iterator\n     * @throws NullPointerException if enumeration is null\n     */\n    public static <E> Iterator<E> asIterator(final Enumeration<? extends E> enumeration) {\n        return new EnumerationIterator<>(Objects.requireNonNull(enumeration, \"enumeration\"));\n    }\n\n    /**\n     * Gets an iterator that provides an iterator view of the given enumeration\n     * that will remove elements from the specified collection.\n     *\n     * @param <E> the element type\n     * @param enumeration  the enumeration to use, may not be null\n     * @param removeCollection  the collection to remove elements from, may not be null\n     * @return a new iterator\n     * @throws NullPointerException if enumeration or removeCollection is null\n     */\n    public static <E> Iterator<E> asIterator(final Enumeration<? extends E> enumeration,\n                                             final Collection<? super E> removeCollection) {\n        return new EnumerationIterator<>(Objects.requireNonNull(enumeration, \"enumeration\"),\n                Objects.requireNonNull(removeCollection, \"removeCollection\"));\n    }\n\n    /**\n     * Gets an iterable that wraps an iterator.  The returned iterable can be\n     * used for multiple iterations.\n     *\n     * @param <E> the element type\n     * @param iterator  the iterator to use, may not be null\n     * @return a new, multiple use iterable\n     * @throws NullPointerException if iterator is null\n     */\n    public static <E> Iterable<E> asMultipleUseIterable(final Iterator<? extends E> iterator) {\n        Objects.requireNonNull(iterator, \"iterator\");\n        return new IteratorIterable<>(iterator, true);\n    }\n\n    // Bounded\n    /**\n     * Decorates the specified iterator to return at most the given number\n     * of elements.\n     *\n     * @param <E> the element type\n     * @param iterator  the iterator to decorate\n     * @param max  the maximum number of elements returned by this iterator\n     * @return a new bounded iterator\n     * @throws NullPointerException if the iterator is null\n     * @throws IllegalArgumentException if max is negative\n     * @since 4.1\n     */\n    public static <E> BoundedIterator<E> boundedIterator(final Iterator<? extends E> iterator, final long max) {\n        return boundedIterator(iterator, 0, max);\n    }\n\n    /**\n     * Decorates the specified iterator to return at most the given number\n     * of elements, skipping all elements until the iterator reaches the\n     * position at {@code offset}.\n     * <p>\n     * The iterator is immediately advanced until it reaches the position at\n     * {@code offset}, incurring O(n) time.\n     *\n     * @param <E> the element type\n     * @param iterator  the iterator to decorate\n     * @param offset  the index of the first element of the decorated iterator to return\n     * @param max  the maximum number of elements returned by this iterator\n     * @return a new bounded iterator\n     * @throws NullPointerException if the iterator is null\n     * @throws IllegalArgumentException if either offset or max is negative\n     * @since 4.1\n     */\n    public static <E> BoundedIterator<E> boundedIterator(final Iterator<? extends E> iterator,\n                                                         final long offset, final long max) {\n        return new BoundedIterator<>(iterator, offset, max);\n    }\n\n    /**\n     * Gets an iterator that iterates through a collections of {@link Iterator}s\n     * one after another.\n     *\n     * @param <E> the element type\n     * @param iterators  the iterators to use, not null or empty or contain nulls\n     * @return a combination iterator over the iterators\n     * @throws NullPointerException if iterators collection is null or contains a null\n     * @throws ClassCastException if the iterators collection contains the wrong object type\n     */\n    public static <E> Iterator<E> chainedIterator(final Collection<Iterator<? extends E>> iterators) {\n        return new IteratorChain<>(iterators);\n    }\n\n    /**\n     * Gets an iterator that iterates through an array of {@link Iterator}s\n     * one after another.\n     *\n     * @param <E> the element type\n     * @param iterators  the iterators to use, not null or empty or contain nulls\n     * @return a combination iterator over the iterators\n     * @throws NullPointerException if iterators array is null or contains a null\n     */\n    public static <E> Iterator<E> chainedIterator(final Iterator<? extends E>... iterators) {\n        return new IteratorChain<>(iterators);\n    }\n\n    /**\n     * Gets an iterator that iterates through two {@link Iterator}s\n     * one after another.\n     *\n     * @param <E> the element type\n     * @param iterator1  the first iterator to use, not null\n     * @param iterator2  the second iterator to use, not null\n     * @return a combination iterator over the iterators\n     * @throws NullPointerException if either iterator is null\n     */\n    public static <E> Iterator<E> chainedIterator(final Iterator<? extends E> iterator1,\n                                                  final Iterator<? extends E> iterator2) {\n        // keep a version with two iterators to avoid the following warning in client code (Java 5 & 6)\n        // \"A generic array of E is created for a varargs parameter\"\n        return new IteratorChain<>(iterator1, iterator2);\n    }\n\n    /**\n     * Gets an iterator that provides an ordered iteration over the elements\n     * contained in a collection of {@link Iterator}s.\n     * <p>\n     * Given two ordered {@link Iterator}s {@code A} and {@code B},\n     * the {@link Iterator#next()} method will return the lesser of\n     * {@code A.next()} and {@code B.next()} and so on.\n     * <p>\n     * The comparator is optional. If null is specified then natural order is used.\n     *\n     * @param <E> the element type\n     * @param comparator  the comparator to use, may be null for natural order\n     * @param iterators  the iterators to use, not null or empty or contain nulls\n     * @return a combination iterator over the iterators\n     * @throws NullPointerException if iterators collection is null or contains a null\n     * @throws ClassCastException if the iterators collection contains the wrong object type\n     */\n    public static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator,\n                                                   final Collection<Iterator<? extends E>> iterators) {\n        @SuppressWarnings(\"unchecked\")\n        final Comparator<E> comp =\n            comparator == null ? ComparatorUtils.NATURAL_COMPARATOR : (Comparator<E>) comparator;\n        return new CollatingIterator<>(comp, iterators);\n    }\n\n    /**\n     * Gets an iterator that provides an ordered iteration over the elements\n     * contained in an array of {@link Iterator}s.\n     * <p>\n     * Given two ordered {@link Iterator}s {@code A} and {@code B},\n     * the {@link Iterator#next()} method will return the lesser of\n     * {@code A.next()} and {@code B.next()} and so on.\n     * <p>\n     * The comparator is optional. If null is specified then natural order is used.\n     *\n     * @param <E> the element type\n     * @param comparator  the comparator to use, may be null for natural order\n     * @param iterators  the iterators to use, not null or empty or contain nulls\n     * @return a combination iterator over the iterators\n     * @throws NullPointerException if iterators array is null or contains a null value\n     */\n    public static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator,\n                                                   final Iterator<? extends E>... iterators) {\n        @SuppressWarnings(\"unchecked\")\n        final Comparator<E> comp =\n            comparator == null ? ComparatorUtils.NATURAL_COMPARATOR : (Comparator<E>) comparator;\n        return new CollatingIterator<>(comp, iterators);\n    }\n\n    // Collated\n    /**\n     * Gets an iterator that provides an ordered iteration over the elements\n     * contained in a collection of ordered {@link Iterator}s.\n     * <p>\n     * Given two ordered {@link Iterator}s {@code A} and {@code B},\n     * the {@link Iterator#next()} method will return the lesser of\n     * {@code A.next()} and {@code B.next()}.\n     * <p>\n     * The comparator is optional. If null is specified then natural order is used.\n     *\n     * @param <E> the element type\n     * @param comparator  the comparator to use, may be null for natural order\n     * @param iterator1  the first iterators to use, not null\n     * @param iterator2  the first iterators to use, not null\n     * @return a combination iterator over the iterators\n     * @throws NullPointerException if either iterator is null\n     */\n    public static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator,\n                                                   final Iterator<? extends E> iterator1,\n                                                   final Iterator<? extends E> iterator2) {\n        @SuppressWarnings(\"unchecked\")\n        final Comparator<E> comp =\n            comparator == null ? ComparatorUtils.NATURAL_COMPARATOR : (Comparator<E>) comparator;\n        return new CollatingIterator<>(comp, iterator1, iterator2);\n    }\n\n    // Chained\n\n    /**\n     * Checks if the object is contained in the given iterator.\n     * <p>\n     * A {@code null} or empty iterator returns false.\n     *\n     * @param <E> the type of object the {@link Iterator} contains\n     * @param iterator  the iterator to check, may be null\n     * @param object  the object to check\n     * @return true if the object is contained in the iterator, false otherwise\n     * @since 4.1\n     */\n    public static <E> boolean contains(final Iterator<E> iterator, final Object object) {\n        return matchesAny(iterator, EqualPredicate.equalPredicate(object));\n    }\n\n    // Empty\n    /**\n     * Gets an empty iterator.\n     * <p>\n     * This iterator is a valid iterator object that will iterate over nothing.\n     *\n     * @param <E> the element type\n     * @return an iterator over nothing\n     */\n    public static <E> ResettableIterator<E> emptyIterator() {\n        return EmptyIterator.<E>resettableEmptyIterator();\n    }\n\n    /**\n     * Gets an empty list iterator.\n     * <p>\n     * This iterator is a valid list iterator object that will iterate\n     * over nothing.\n     *\n     * @param <E> the element type\n     * @return a list iterator over nothing\n     */\n    public static <E> ResettableListIterator<E> emptyListIterator() {\n        return EmptyListIterator.<E>resettableEmptyListIterator();\n    }\n\n    /**\n     * Gets an empty map iterator.\n     * <p>\n     * This iterator is a valid map iterator object that will iterate\n     * over nothing.\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @return a map iterator over nothing\n     */\n    public static <K, V> MapIterator<K, V> emptyMapIterator() {\n        return EmptyMapIterator.<K, V>emptyMapIterator();\n    }\n\n    /**\n     * Gets an empty ordered iterator.\n     * <p>\n     * This iterator is a valid iterator object that will iterate\n     * over nothing.\n     *\n     * @param <E> the element type\n     * @return an ordered iterator over nothing\n     */\n    public static <E> OrderedIterator<E> emptyOrderedIterator() {\n        return EmptyOrderedIterator.<E>emptyOrderedIterator();\n    }\n\n    /**\n     * Gets an empty ordered map iterator.\n     * <p>\n     * This iterator is a valid map iterator object that will iterate\n     * over nothing.\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @return a map iterator over nothing\n     */\n    public static <K, V> OrderedMapIterator<K, V> emptyOrderedMapIterator() {\n        return EmptyOrderedMapIterator.<K, V>emptyOrderedMapIterator();\n    }\n\n    // Filtered\n    /**\n     * Gets an iterator that filters another iterator.\n     * <p>\n     * The returned iterator will only return objects that match the specified\n     * filtering predicate.\n     *\n     * @param <E> the element type\n     * @param iterator  the iterator to use, not null\n     * @param predicate  the predicate to use as a filter, not null\n     * @return a new filtered iterator\n     * @throws NullPointerException if either parameter is null\n     */\n    public static <E> Iterator<E> filteredIterator(final Iterator<? extends E> iterator,\n                                                   final Predicate<? super E> predicate) {\n        Objects.requireNonNull(iterator, \"iterator\");\n        Objects.requireNonNull(predicate, \"predicate\");\n        return new FilterIterator<>(iterator, predicate);\n    }\n\n    /**\n     * Gets a list iterator that filters another list iterator.\n     * <p>\n     * The returned iterator will only return objects that match the specified\n     * filtering predicate.\n     *\n     * @param <E> the element type\n     * @param listIterator  the list iterator to use, not null\n     * @param predicate  the predicate to use as a filter, not null\n     * @return a new filtered iterator\n     * @throws NullPointerException if either parameter is null\n     */\n    public static <E> ListIterator<E> filteredListIterator(final ListIterator<? extends E> listIterator,\n            final Predicate<? super E> predicate) {\n\n        Objects.requireNonNull(listIterator, \"listIterator\");\n        Objects.requireNonNull(predicate, \"predicate\");\n        return new FilterListIterator<>(listIterator, predicate);\n    }\n\n    /**\n     * Finds the first element in the given iterator which matches the given predicate.\n     * <p>\n     * A {@code null} or empty iterator returns null.\n     *\n     * @param <E> the element type\n     * @param iterator  the iterator to search, may be null\n     * @param predicate  the predicate to use, must not be null\n     * @return the first element of the iterator which matches the predicate or null if none could be found\n     * @throws NullPointerException if predicate is null\n     * @since 4.1\n     */\n    public static <E> E find(final Iterator<E> iterator, final Predicate<? super E> predicate) {\n        Objects.requireNonNull(predicate, \"predicate\");\n\n        if (iterator != null) {\n            while (iterator.hasNext()) {\n                final E element = iterator.next();\n                if (predicate.test(element)) {\n                    return element;\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Shortcut for {@code get(iterator, 0)}.\n     * <p>\n     * Returns the {@code first} value in {@link Iterator}, throwing\n     * {@code IndexOutOfBoundsException} if there is no such element.\n     * </p>\n     * <p>\n     * The Iterator is advanced to {@code 0} (or to the end, if\n     * {@code 0} exceeds the number of entries) as a side effect of this method.\n     * </p>\n     * @param <E> the type of object in the {@link Iterator}\n     * @param iterator the iterator to get a value from\n     * @return the first object\n     * @throws IndexOutOfBoundsException if the request is invalid\n     * @since 4.2\n     */\n    public static <E> E first(final Iterator<E> iterator) {\n        return get(iterator, 0);\n    }\n\n    /**\n     * Applies the closure to each element of the provided iterator.\n     *\n     * @param <E> the element type\n     * @param iterator  the iterator to use, may be null\n     * @param closure  the closure to apply to each element, may not be null\n     * @throws NullPointerException if closure is null\n     * @since 4.1\n     */\n    public static <E> void forEach(final Iterator<E> iterator, final Closure<? super E> closure) {\n        Objects.requireNonNull(closure, \"closure\");\n        if (iterator != null) {\n            while (iterator.hasNext()) {\n                closure.accept(iterator.next());\n            }\n        }\n    }\n\n    /**\n     * Executes the given closure on each but the last element in the iterator.\n     * <p>\n     * If the input iterator is null no change is made.\n     *\n     * @param <E> the type of object the {@link Iterator} contains\n     * @param iterator  the iterator to get the input from, may be null\n     * @param closure  the closure to perform, may not be null\n     * @return the last element in the iterator, or null if iterator is null or empty\n     * @throws NullPointerException if closure is null\n     * @since 4.1\n     */\n    public static <E> E forEachButLast(final Iterator<E> iterator, final Closure<? super E> closure) {\n        Objects.requireNonNull(closure, \"closure\");\n\n        if (iterator != null) {\n            while (iterator.hasNext()) {\n                final E element = iterator.next();\n                if (!iterator.hasNext()) {\n                    return element;\n                }\n                closure.accept(element);\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Returns the {@code index}-th value in {@link Iterator}, throwing\n     * {@code IndexOutOfBoundsException} if there is no such element.\n     * <p>\n     * The Iterator is advanced to {@code index} (or to the end, if\n     * {@code index} exceeds the number of entries) as a side effect of this method.\n     *\n     * @param <E> the type of object in the {@link Iterator}\n     * @param iterator  the iterator to get a value from\n     * @param index  the index to get\n     * @return the object at the specified index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     * @since 4.1\n     */\n    public static <E> E get(final Iterator<E> iterator, final int index) {\n        int i = index;\n        CollectionUtils.checkIndexBounds(i);\n        while (iterator.hasNext()) {\n            i--;\n            if (i == -1) {\n                return iterator.next();\n            }\n            iterator.next();\n        }\n        throw new IndexOutOfBoundsException(\"Entry does not exist: \" + i);\n    }\n\n    /**\n     * Gets a suitable Iterator for the given object.\n     * <p>\n     * This method can handle objects as follows\n     * <ul>\n     * <li>null - empty iterator\n     * <li>Iterator - returned directly\n     * <li>Enumeration - wrapped\n     * <li>Collection - iterator from collection returned\n     * <li>Map - values iterator returned\n     * <li>Dictionary - values (elements) enumeration returned as iterator\n     * <li>array - iterator over array returned\n     * <li>object with iterator() public method accessed by reflection\n     * <li>object - singleton iterator\n     * <li>NodeList - iterator over the list\n     * <li>Node - iterator over the child nodes\n     * </ul>\n     *\n     * @param obj  the object to convert to an iterator\n     * @return a suitable iterator, never null\n     */\n    public static Iterator<?> getIterator(final Object obj) {\n        if (obj == null) {\n            return emptyIterator();\n        }\n        if (obj instanceof Iterator) {\n            return (Iterator<?>) obj;\n        }\n        if (obj instanceof Iterable) {\n            return ((Iterable<?>) obj).iterator();\n        }\n        if (obj instanceof Object[]) {\n            return new ObjectArrayIterator<>((Object[]) obj);\n        }\n        if (obj instanceof Enumeration) {\n            return new EnumerationIterator<>((Enumeration<?>) obj);\n        }\n        if (obj instanceof Map) {\n            return ((Map<?, ?>) obj).values().iterator();\n        }\n        if (obj instanceof NodeList) {\n            return new NodeListIterator((NodeList) obj);\n        }\n        if (obj instanceof Node) {\n            return new NodeListIterator((Node) obj);\n        }\n        if (obj instanceof Dictionary) {\n            return new EnumerationIterator<>(((Dictionary<?, ?>) obj).elements());\n        }\n        if (obj.getClass().isArray()) {\n            return new ArrayIterator<>(obj);\n        }\n        try {\n            final Method method = obj.getClass().getMethod(\"iterator\", (Class[]) null);\n            if (Iterator.class.isAssignableFrom(method.getReturnType())) {\n                final Iterator<?> it = (Iterator<?>) method.invoke(obj, (Object[]) null);\n                if (it != null) {\n                    return it;\n                }\n            }\n        } catch (final RuntimeException | ReflectiveOperationException ignore) { // NOPMD\n            // ignore\n        }\n        return singletonIterator(obj);\n    }\n\n    // Peeking\n\n    /**\n     * Returns the index of the first element in the specified iterator that\n     * matches the given predicate.\n     * <p>\n     * A {@code null} or empty iterator returns -1.\n     *\n     * @param <E> the element type\n     * @param iterator  the iterator to search, may be null\n     * @param predicate  the predicate to use, may not be null\n     * @return the index of the first element which matches the predicate or -1 if none matches\n     * @throws NullPointerException if predicate is null\n     * @since 4.1\n     */\n    public static <E> int indexOf(final Iterator<E> iterator, final Predicate<? super E> predicate) {\n        Objects.requireNonNull(predicate, \"predicate\");\n\n        if (iterator != null) {\n            for (int index = 0; iterator.hasNext(); index++) {\n                final E element = iterator.next();\n                if (predicate.test(element)) {\n                    return index;\n                }\n            }\n        }\n        return CollectionUtils.INDEX_NOT_FOUND;\n    }\n\n    // Pushback\n\n    /**\n     * Checks if the given iterator is empty.\n     * <p>\n     * A {@code null} or empty iterator returns true.\n     *\n     * @param iterator  the {@link Iterator} to use, may be null\n     * @return true if the iterator is exhausted or null, false otherwise\n     * @since 4.1\n     */\n    public static boolean isEmpty(final Iterator<?> iterator) {\n        return iterator == null || !iterator.hasNext();\n    }\n\n    // Looping\n    /**\n     * Gets an iterator that loops continuously over the supplied collection.\n     * <p>\n     * The iterator will only stop looping if the remove method is called\n     * enough times to empty the collection, or if the collection is empty\n     * to start with.\n     *\n     * @param <E> the element type\n     * @param collection  the collection to iterate over, not null\n     * @return a new looping iterator\n     * @throws NullPointerException if the collection is null\n     */\n    public static <E> ResettableIterator<E> loopingIterator(final Collection<? extends E> collection) {\n        return new LoopingIterator<>(Objects.requireNonNull(collection, \"collection\"));\n    }\n\n    /**\n     * Gets an iterator that loops continuously over the supplied list.\n     * <p>\n     * The iterator will only stop looping if the remove method is called\n     * enough times to empty the list, or if the list is empty to start with.\n     *\n     * @param <E> the element type\n     * @param list  the list to iterate over, not null\n     * @return a new looping iterator\n     * @throws NullPointerException if the list is null\n     * @since 3.2\n     */\n    public static <E> ResettableListIterator<E> loopingListIterator(final List<E> list) {\n        return new LoopingListIterator<>(Objects.requireNonNull(list, \"list\"));\n    }\n\n    /**\n     * Answers true if a predicate is true for every element of an iterator.\n     * <p>\n     * A {@code null} or empty iterator returns true.\n     *\n     * @param <E> the type of object the {@link Iterator} contains\n     * @param iterator  the {@link Iterator} to use, may be null\n     * @param predicate  the predicate to use, may not be null\n     * @return true if every element of the collection matches the predicate or if the\n     *   collection is empty, false otherwise\n     * @throws NullPointerException if predicate is null\n     * @since 4.1\n     */\n    public static <E> boolean matchesAll(final Iterator<E> iterator, final Predicate<? super E> predicate) {\n        Objects.requireNonNull(predicate, \"predicate\");\n\n        if (iterator != null) {\n            while (iterator.hasNext()) {\n                final E element = iterator.next();\n                if (!predicate.test(element)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Answers true if a predicate is true for any element of the iterator.\n     * <p>\n     * A {@code null} or empty iterator returns false.\n     *\n     * @param <E> the type of object the {@link Iterator} contains\n     * @param iterator  the {@link Iterator} to use, may be null\n     * @param predicate  the predicate to use, may not be null\n     * @return true if any element of the collection matches the predicate, false otherwise\n     * @throws NullPointerException if predicate is null\n     * @since 4.1\n     */\n    public static <E> boolean matchesAny(final Iterator<E> iterator, final Predicate<? super E> predicate) {\n        return indexOf(iterator, predicate) != -1;\n    }\n\n    /**\n     * Gets an {@link Iterator} that wraps the specified node's childNodes.\n     * The returned {@link Iterator} can be used for a single iteration.\n     * <p>\n     * Convenience method, allows easy iteration over NodeLists:\n     * <pre>\n     *   Iterator&lt;Node&gt; iterator = IteratorUtils.nodeListIterator(node);\n     *   for (Node childNode : IteratorUtils.asIterable(iterator)) {\n     *     ...\n     *   }\n     * </pre>\n     *\n     * @param node  the node to use, may not be null\n     * @return a new, single use {@link Iterator}\n     * @throws NullPointerException if node is null\n     * @since 4.0\n     */\n    public static NodeListIterator nodeListIterator(final Node node) {\n        return new NodeListIterator(Objects.requireNonNull(node, \"node\"));\n    }\n\n    // org.w3c.dom.NodeList iterators\n    /**\n     * Gets an {@link Iterator} that wraps the specified {@link NodeList}.\n     * The returned {@link Iterator} can be used for a single iteration.\n     *\n     * @param nodeList  the node list to use, may not be null\n     * @return a new, single use {@link Iterator}\n     * @throws NullPointerException if nodeList is null\n     * @since 4.0\n     */\n    public static NodeListIterator nodeListIterator(final NodeList nodeList) {\n        return new NodeListIterator(Objects.requireNonNull(nodeList, \"nodeList\"));\n    }\n\n    // Object Graph\n    /**\n     * Gets an iterator that operates over an object graph.\n     * <p>\n     * This iterator can extract multiple objects from a complex tree-like object graph.\n     * The iteration starts from a single root object.\n     * It uses a {@code Transformer} to extract the iterators and elements.\n     * Its main benefit is that no intermediate {@code List} is created.\n     * <p>\n     * For example, consider an object graph:\n     * <pre>\n     *                 |- Branch -- Leaf\n     *                 |         \\- Leaf\n     *         |- Tree |         /- Leaf\n     *         |       |- Branch -- Leaf\n     *  Forest |                 \\- Leaf\n     *         |       |- Branch -- Leaf\n     *         |       |         \\- Leaf\n     *         |- Tree |         /- Leaf\n     *                 |- Branch -- Leaf\n     *                 |- Branch -- Leaf</pre>\n     * The following {@code Transformer}, used in this class, will extract all\n     * the Leaf objects without creating a combined intermediate list:\n     * <pre>\n     * public Object transform(Object input) {\n     *   if (input instanceof Forest) {\n     *     return ((Forest) input).treeIterator();\n     *   }\n     *   if (input instanceof Tree) {\n     *     return ((Tree) input).branchIterator();\n     *   }\n     *   if (input instanceof Branch) {\n     *     return ((Branch) input).leafIterator();\n     *   }\n     *   if (input instanceof Leaf) {\n     *     return input;\n     *   }\n     *   throw new ClassCastException();\n     * }</pre>\n     * <p>\n     * Internally, iteration starts from the root object. When next is called,\n     * the transformer is called to examine the object. The transformer will return\n     * either an iterator or an object. If the object is an Iterator, the next element\n     * from that iterator is obtained and the process repeats. If the element is an object\n     * it is returned.\n     * <p>\n     * Under many circumstances, linking Iterators together in this manner is\n     * more efficient (and convenient) than using nested for loops to extract a list.\n     *\n     * @param <E> the element type\n     * @param root  the root object to start iterating from, null results in an empty iterator\n     * @param transformer  the transformer to use, see above, null uses no effect transformer\n     * @return a new object graph iterator\n     * @since 3.1\n     */\n    public static <E> Iterator<E> objectGraphIterator(final E root,\n            final Transformer<? super E, ? extends E> transformer) {\n        return new ObjectGraphIterator<>(root, transformer);\n    }\n\n    /**\n     * Gets an iterator that supports one-element lookahead.\n     *\n     * @param <E> the element type\n     * @param iterator  the iterator to decorate, not null\n     * @return a peeking iterator\n     * @throws NullPointerException if the iterator is null\n     * @since 4.0\n     */\n    public static <E> Iterator<E> peekingIterator(final Iterator<? extends E> iterator) {\n        return PeekingIterator.peekingIterator(iterator);\n    }\n\n    /**\n     * Gets an iterator that supports pushback of elements.\n     *\n     * @param <E> the element type\n     * @param iterator  the iterator to decorate, not null\n     * @return a pushback iterator\n     * @throws NullPointerException if the iterator is null\n     * @since 4.0\n     */\n    public static <E> Iterator<E> pushbackIterator(final Iterator<? extends E> iterator) {\n        return PushbackIterator.pushbackIterator(iterator);\n    }\n\n    // Singleton\n    /**\n     * Gets a singleton iterator.\n     * <p>\n     * This iterator is a valid iterator object that will iterate over\n     * the specified object.\n     *\n     * @param <E> the element type\n     * @param object  the single object over which to iterate\n     * @return a singleton iterator over the object\n     */\n    public static <E> ResettableIterator<E> singletonIterator(final E object) {\n        return new SingletonIterator<>(object);\n    }\n\n    /**\n     * Gets a singleton list iterator.\n     * <p>\n     * This iterator is a valid list iterator object that will iterate over\n     * the specified object.\n     *\n     * @param <E> the element type\n     * @param object  the single object over which to iterate\n     * @return a singleton list iterator over the object\n     */\n    public static <E> ListIterator<E> singletonListIterator(final E object) {\n        return new SingletonListIterator<>(object);\n    }\n\n    /**\n     * Returns the number of elements contained in the given iterator.\n     * <p>\n     * A {@code null} or empty iterator returns {@code 0}.\n     *\n     * @param iterator  the iterator to check, may be null\n     * @return the number of elements contained in the iterator\n     * @since 4.1\n     */\n    public static int size(final Iterator<?> iterator) {\n        int size = 0;\n        if (iterator != null) {\n            while (iterator.hasNext()) {\n                iterator.next();\n                size++;\n            }\n        }\n        return size;\n    }\n\n    // Skipping\n    /**\n     * Decorates the specified iterator to skip the first N elements.\n     *\n     * @param <E> the element type\n     * @param iterator  the iterator to decorate\n     * @param offset  the first number of elements to skip\n     * @return a new skipping iterator\n     * @throws NullPointerException if the iterator is null\n     * @throws IllegalArgumentException if offset is negative\n     * @since 4.1\n     */\n    public static <E> SkippingIterator<E> skippingIterator(final Iterator<E> iterator, final long offset) {\n        return new SkippingIterator<>(iterator, offset);\n    }\n\n    /**\n     * Gets an array based on an iterator.\n     * <p>\n     * As the wrapped Iterator is traversed, an ArrayList of its values is\n     * created. At the end, this is converted to an array.\n     *\n     * @param iterator  the iterator to use, not null\n     * @return an array of the iterator contents\n     * @throws NullPointerException if iterator parameter is null\n     */\n    public static Object[] toArray(final Iterator<?> iterator) {\n        Objects.requireNonNull(iterator, \"iterator\");\n        final List<?> list = toList(iterator, 100);\n        return list.toArray();\n    }\n\n    /**\n     * Gets an array based on an iterator.\n     * <p>\n     * As the wrapped Iterator is traversed, an ArrayList of its values is\n     * created. At the end, this is converted to an array.\n     *\n     * @param <E> the element type\n     * @param iterator  the iterator to use, not null\n     * @param arrayClass  the class of array to create\n     * @return an array of the iterator contents\n     * @throws NullPointerException if iterator parameter or arrayClass is null\n     * @throws ArrayStoreException if the arrayClass is invalid\n     */\n    public static <E> E[] toArray(final Iterator<? extends E> iterator, final Class<E> arrayClass) {\n        Objects.requireNonNull(iterator, \"iterator\");\n        Objects.requireNonNull(arrayClass, \"arrayClass\");\n        final List<E> list = toList(iterator, 100);\n        @SuppressWarnings(\"unchecked\")\n        final E[] array = (E[]) Array.newInstance(arrayClass, list.size());\n        return list.toArray(array);\n    }\n\n    // Utility methods\n\n    /**\n     * Gets a list based on an iterator.\n     * <p>\n     * As the wrapped Iterator is traversed, an ArrayList of its values is\n     * created. At the end, the list is returned.\n     *\n     * @param <E> the element type\n     * @param iterator  the iterator to use, not null\n     * @return a list of the iterator contents\n     * @throws NullPointerException if iterator parameter is null\n     */\n    public static <E> List<E> toList(final Iterator<? extends E> iterator) {\n        return toList(iterator, 10);\n    }\n\n    /**\n     * Gets a list based on an iterator.\n     * <p>\n     * As the wrapped Iterator is traversed, an ArrayList of its values is\n     * created. At the end, the list is returned.\n     *\n     * @param <E> the element type\n     * @param iterator  the iterator to use, not null\n     * @param estimatedSize  the initial size of the ArrayList\n     * @return a list of the iterator contents\n     * @throws NullPointerException if iterator parameter is null\n     * @throws IllegalArgumentException if the size is less than 1\n     */\n    public static <E> List<E> toList(final Iterator<? extends E> iterator, final int estimatedSize) {\n        Objects.requireNonNull(iterator, \"iterator\");\n        if (estimatedSize < 1) {\n            throw new IllegalArgumentException(\"Estimated size must be greater than 0\");\n        }\n        final List<E> list = new ArrayList<>(estimatedSize);\n        while (iterator.hasNext()) {\n            list.add(iterator.next());\n        }\n        return list;\n    }\n\n    /**\n     * Gets a list iterator based on a simple iterator.\n     * <p>\n     * As the wrapped Iterator is traversed, a LinkedList of its values is\n     * cached, permitting all required operations of ListIterator.\n     *\n     * @param <E> the element type\n     * @param iterator  the iterator to use, may not be null\n     * @return a new iterator\n     * @throws NullPointerException if iterator parameter is null\n     */\n    public static <E> ListIterator<E> toListIterator(final Iterator<? extends E> iterator) {\n        Objects.requireNonNull(iterator, \"iterator\");\n        return new ListIteratorWrapper<>(iterator);\n    }\n\n    /**\n     * Returns a string representation of the elements of the specified iterator.\n     * <p>\n     * The string representation consists of a list of the iterator's elements,\n     * enclosed in square brackets ({@code \"[]\"}). Adjacent elements are separated\n     * by the characters {@code \", \"} (a comma followed by a space). Elements are\n     * converted to strings as by {@code String.valueOf(Object)}.\n     *\n     * @param <E> the element type\n     * @param iterator  the iterator to convert to a string, may be null\n     * @return a string representation of {@code iterator}\n     * @since 4.1\n     */\n    public static <E> String toString(final Iterator<E> iterator) {\n        return toString(iterator, TransformerUtils.stringValueTransformer(),\n                        DEFAULT_TOSTRING_DELIMITER, CollectionUtils.DEFAULT_TOSTRING_PREFIX,\n                CollectionUtils.DEFAULT_TOSTRING_SUFFIX);\n    }\n\n    /**\n     * Returns a string representation of the elements of the specified iterator.\n     * <p>\n     * The string representation consists of a list of the iterable's elements,\n     * enclosed in square brackets ({@code \"[]\"}). Adjacent elements are separated\n     * by the characters {@code \", \"} (a comma followed by a space). Elements are\n     * converted to strings as by using the provided {@code transformer}.\n     *\n     * @param <E> the element type\n     * @param iterator  the iterator to convert to a string, may be null\n     * @param transformer  the transformer used to get a string representation of an element\n     * @return a string representation of {@code iterator}\n     * @throws NullPointerException if {@code transformer} is null\n     * @since 4.1\n     */\n    public static <E> String toString(final Iterator<E> iterator,\n                                      final Transformer<? super E, String> transformer) {\n        return toString(iterator, transformer, DEFAULT_TOSTRING_DELIMITER,\n                CollectionUtils.DEFAULT_TOSTRING_PREFIX, CollectionUtils.DEFAULT_TOSTRING_SUFFIX);\n    }\n\n    /**\n     * Returns a string representation of the elements of the specified iterator.\n     * <p>\n     * The string representation consists of a list of the iterator's elements,\n     * enclosed by the provided {@code prefix} and {@code suffix}. Adjacent elements\n     * are separated by the provided {@code delimiter}. Elements are converted to\n     * strings as by using the provided {@code transformer}.\n     *\n     * @param <E> the element type\n     * @param iterator  the iterator to convert to a string, may be null\n     * @param transformer  the transformer used to get a string representation of an element\n     * @param delimiter  the string to delimit elements\n     * @param prefix  the prefix, prepended to the string representation\n     * @param suffix  the suffix, appended to the string representation\n     * @return a string representation of {@code iterator}\n     * @throws NullPointerException if either transformer, delimiter, prefix or suffix is null\n     * @since 4.1\n     */\n    public static <E> String toString(final Iterator<E> iterator,\n                                      final Transformer<? super E, String> transformer,\n                                      final String delimiter,\n                                      final String prefix,\n                                      final String suffix) {\n        Objects.requireNonNull(transformer, \"transformer\");\n        Objects.requireNonNull(delimiter, \"delimiter\");\n        Objects.requireNonNull(prefix, \"prefix\");\n        Objects.requireNonNull(suffix, \"suffix\");\n        final StringBuilder stringBuilder = new StringBuilder(prefix);\n        if (iterator != null) {\n            while (iterator.hasNext()) {\n                final E element = iterator.next();\n                stringBuilder.append(transformer.apply(element));\n                stringBuilder.append(delimiter);\n            }\n            if (stringBuilder.length() > prefix.length()) {\n                stringBuilder.setLength(stringBuilder.length() - delimiter.length());\n            }\n        }\n        stringBuilder.append(suffix);\n        return stringBuilder.toString();\n    }\n\n    // Transformed\n    /**\n     * Gets an iterator that transforms the elements of another iterator.\n     * <p>\n     * The transformation occurs during the next() method and the underlying\n     * iterator is unaffected by the transformation.\n     *\n     * @param <I> the input type\n     * @param <O> the output type\n     * @param iterator  the iterator to use, not null\n     * @param transformer  the transform to use, not null\n     * @return a new transforming iterator\n     * @throws NullPointerException if either parameter is null\n     */\n    public static <I, O> Iterator<O> transformedIterator(final Iterator<? extends I> iterator,\n            final Transformer<? super I, ? extends O> transformer) {\n\n        Objects.requireNonNull(iterator, \"iterator\");\n        Objects.requireNonNull(transformer, \"transformer\");\n        return new TransformIterator<>(iterator, transformer);\n    }\n\n    // Unmodifiable\n    /**\n     * Gets an immutable version of an {@link Iterator}. The returned object\n     * will always throw an {@link UnsupportedOperationException} for\n     * the {@link Iterator#remove} method.\n     *\n     * @param <E> the element type\n     * @param iterator  the iterator to make immutable\n     * @return an immutable version of the iterator\n     */\n    public static <E> Iterator<E> unmodifiableIterator(final Iterator<E> iterator) {\n        return UnmodifiableIterator.unmodifiableIterator(iterator);\n    }\n\n    /**\n     * Gets an immutable version of a {@link ListIterator}. The returned object\n     * will always throw an {@link UnsupportedOperationException} for\n     * the {@link Iterator#remove}, {@link ListIterator#add} and\n     * {@link ListIterator#set} methods.\n     *\n     * @param <E> the element type\n     * @param listIterator  the iterator to make immutable\n     * @return an immutable version of the iterator\n     */\n    public static <E> ListIterator<E> unmodifiableListIterator(final ListIterator<E> listIterator) {\n        return UnmodifiableListIterator.unmodifiableListIterator(listIterator);\n    }\n\n    /**\n     * Gets an immutable version of a {@link MapIterator}. The returned object\n     * will always throw an {@link UnsupportedOperationException} for\n     * the {@link Iterator#remove}, {@link MapIterator#setValue(Object)} methods.\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param mapIterator  the iterator to make immutable\n     * @return an immutable version of the iterator\n     */\n    public static <K, V> MapIterator<K, V> unmodifiableMapIterator(final MapIterator<K, V> mapIterator) {\n        return UnmodifiableMapIterator.unmodifiableMapIterator(mapIterator);\n    }\n\n    /**\n     * Returns an iterator that interleaves elements from the decorated iterators.\n     *\n     * @param <E> the element type\n     * @param iterators  the array of iterators to interleave\n     * @return an iterator, interleaving the decorated iterators\n     * @throws NullPointerException if any iterator is null\n     * @since 4.1\n     */\n    public static <E> ZippingIterator<E> zippingIterator(final Iterator<? extends E>... iterators) {\n        return new ZippingIterator<>(iterators);\n    }\n\n    // Zipping\n    /**\n     * Returns an iterator that interleaves elements from the decorated iterators.\n     *\n     * @param <E> the element type\n     * @param a  the first iterator to interleave\n     * @param b  the second iterator to interleave\n     * @return an iterator, interleaving the decorated iterators\n     * @throws NullPointerException if any iterator is null\n     * @since 4.1\n     */\n    public static <E> ZippingIterator<E> zippingIterator(final Iterator<? extends E> a,\n                                                         final Iterator<? extends E> b) {\n        return new ZippingIterator<>(a, b);\n    }\n\n    /**\n     * Returns an iterator that interleaves elements from the decorated iterators.\n     *\n     * @param <E> the element type\n     * @param a  the first iterator to interleave\n     * @param b  the second iterator to interleave\n     * @param c  the third iterator to interleave\n     * @return an iterator, interleaving the decorated iterators\n     * @throws NullPointerException if any iterator is null\n     * @since 4.1\n     */\n    public static <E> ZippingIterator<E> zippingIterator(final Iterator<? extends E> a,\n                                                         final Iterator<? extends E> b,\n                                                         final Iterator<? extends E> c) {\n        return new ZippingIterator<>(a, b, c);\n    }\n\n    /**\n     * Don't allow instances.\n     */\n    private IteratorUtils() {\n        // empty\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "@SuppressWarnings(\"rawtypes\")\n    public static final ResettableIterator EMPTY_ITERATOR = EmptyIterator.RESETTABLE_INSTANCE;", "docstring": "\nAn iterator over no elements.\n", "modifiers": "@SuppressWarnings(\"rawtypes\")\n    public static final", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"rawtypes\")", "public", "static", "final"], "comments": [], "type": "ResettableIterator", "name": "EMPTY_ITERATOR = EmptyIterator.RESETTABLE_INSTANCE", "syntax_pass": true}, {"attribute_expression": "@SuppressWarnings(\"rawtypes\")\n    public static final ResettableListIterator EMPTY_LIST_ITERATOR = EmptyListIterator.RESETTABLE_INSTANCE;", "docstring": "\nA list iterator over no elements.\n", "modifiers": "@SuppressWarnings(\"rawtypes\")\n    public static final", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"rawtypes\")", "public", "static", "final"], "comments": [], "type": "ResettableListIterator", "name": "EMPTY_LIST_ITERATOR = EmptyListIterator.RESETTABLE_INSTANCE", "syntax_pass": true}, {"attribute_expression": "@SuppressWarnings(\"rawtypes\")\n    public static final OrderedIterator EMPTY_ORDERED_ITERATOR = EmptyOrderedIterator.INSTANCE;", "docstring": "\nAn ordered iterator over no elements.\n", "modifiers": "@SuppressWarnings(\"rawtypes\")\n    public static final", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"rawtypes\")", "public", "static", "final"], "comments": [], "type": "OrderedIterator", "name": "EMPTY_ORDERED_ITERATOR = EmptyOrderedIterator.INSTANCE", "syntax_pass": true}, {"attribute_expression": "@SuppressWarnings(\"rawtypes\")\n    public static final MapIterator EMPTY_MAP_ITERATOR = EmptyMapIterator.INSTANCE;", "docstring": "\nA map iterator over no elements.\n", "modifiers": "@SuppressWarnings(\"rawtypes\")\n    public static final", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"rawtypes\")", "public", "static", "final"], "comments": [], "type": "MapIterator", "name": "EMPTY_MAP_ITERATOR = EmptyMapIterator.INSTANCE", "syntax_pass": true}, {"attribute_expression": "@SuppressWarnings(\"rawtypes\")\n    public static final OrderedMapIterator EMPTY_ORDERED_MAP_ITERATOR = EmptyOrderedMapIterator.INSTANCE;", "docstring": "\nAn ordered map iterator over no elements.\n", "modifiers": "@SuppressWarnings(\"rawtypes\")\n    public static final", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"rawtypes\")", "public", "static", "final"], "comments": [], "type": "OrderedMapIterator", "name": "EMPTY_ORDERED_MAP_ITERATOR = EmptyOrderedMapIterator.INSTANCE", "syntax_pass": true}, {"attribute_expression": "private static final String DEFAULT_TOSTRING_DELIMITER = \", \";", "docstring": "\nDefault delimiter used to delimit elements while converting an Iterator\nto its String representation.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "DEFAULT_TOSTRING_DELIMITER = \", \"", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/PredicateUtils.java.PredicateUtils", "name": "PredicateUtils", "file_path": "src/main/java/org/apache/commons/collections4/PredicateUtils.java", "superclasses": "", "methods": ["[Predicate<T>]allPredicate(Collection<? extends Predicate<? super T>>)", "[Predicate<T>]allPredicate()", "[Predicate<T>]andPredicate(Predicate<? super T>,Predicate<? super T>)", "[Predicate<T>]anyPredicate(Collection<? extends Predicate<? super T>>)", "[Predicate<T>]anyPredicate()", "[Predicate<T>]asPredicate(Transformer<? super T, Boolean>)", "[Predicate<T>]eitherPredicate(Predicate<? super T>,Predicate<? super T>)", "[Predicate<T>]equalPredicate(T)", "[Predicate<T>]exceptionPredicate()", "[Predicate<T>]falsePredicate()", "[Predicate<T>]identityPredicate(T)", "[Predicate<Object>]instanceofPredicate(Class<?>)", "[Predicate<T>]invokerPredicate(String)", "[Predicate<T>]invokerPredicate(String,Class<?>[],Object[])", "[Predicate<T>]neitherPredicate(Predicate<? super T>,Predicate<? super T>)", "[Predicate<T>]nonePredicate(Collection<? extends Predicate<? super T>>)", "[Predicate<T>]nonePredicate()", "[Predicate<T>]notNullPredicate()", "[Predicate<T>]notPredicate(Predicate<? super T>)", "[Predicate<T>]nullIsExceptionPredicate(Predicate<? super T>)", "[Predicate<T>]nullIsFalsePredicate(Predicate<? super T>)", "[Predicate<T>]nullIsTruePredicate(Predicate<? super T>)", "[Predicate<T>]nullPredicate()", "[Predicate<T>]onePredicate(Collection<? extends Predicate<? super T>>)", "[Predicate<T>]onePredicate()", "[Predicate<T>]orPredicate(Predicate<? super T>,Predicate<? super T>)", "[Predicate<T>]transformedPredicate(Transformer<? super T, ? extends T>,Predicate<? super T>)", "[Predicate<T>]truePredicate()", "[Predicate<T>]uniquePredicate()", "[]PredicateUtils()"], "method_uris": ["src/main/java/org/apache/commons/collections4/PredicateUtils.java.PredicateUtils.[Predicate<T>]allPredicate(Collection<? extends Predicate<? super T>>)", "src/main/java/org/apache/commons/collections4/PredicateUtils.java.PredicateUtils.[Predicate<T>]allPredicate()", "src/main/java/org/apache/commons/collections4/PredicateUtils.java.PredicateUtils.[Predicate<T>]andPredicate(Predicate<? super T>,Predicate<? super T>)", "src/main/java/org/apache/commons/collections4/PredicateUtils.java.PredicateUtils.[Predicate<T>]anyPredicate(Collection<? extends Predicate<? super T>>)", "src/main/java/org/apache/commons/collections4/PredicateUtils.java.PredicateUtils.[Predicate<T>]anyPredicate()", "src/main/java/org/apache/commons/collections4/PredicateUtils.java.PredicateUtils.[Predicate<T>]asPredicate(Transformer<? super T, Boolean>)", "src/main/java/org/apache/commons/collections4/PredicateUtils.java.PredicateUtils.[Predicate<T>]eitherPredicate(Predicate<? super T>,Predicate<? super T>)", "src/main/java/org/apache/commons/collections4/PredicateUtils.java.PredicateUtils.[Predicate<T>]equalPredicate(T)", "src/main/java/org/apache/commons/collections4/PredicateUtils.java.PredicateUtils.[Predicate<T>]exceptionPredicate()", "src/main/java/org/apache/commons/collections4/PredicateUtils.java.PredicateUtils.[Predicate<T>]falsePredicate()", "src/main/java/org/apache/commons/collections4/PredicateUtils.java.PredicateUtils.[Predicate<T>]identityPredicate(T)", "src/main/java/org/apache/commons/collections4/PredicateUtils.java.PredicateUtils.[Predicate<Object>]instanceofPredicate(Class<?>)", "src/main/java/org/apache/commons/collections4/PredicateUtils.java.PredicateUtils.[Predicate<T>]invokerPredicate(String)", "src/main/java/org/apache/commons/collections4/PredicateUtils.java.PredicateUtils.[Predicate<T>]invokerPredicate(String,Class<?>[],Object[])", "src/main/java/org/apache/commons/collections4/PredicateUtils.java.PredicateUtils.[Predicate<T>]neitherPredicate(Predicate<? super T>,Predicate<? super T>)", "src/main/java/org/apache/commons/collections4/PredicateUtils.java.PredicateUtils.[Predicate<T>]nonePredicate(Collection<? extends Predicate<? super T>>)", "src/main/java/org/apache/commons/collections4/PredicateUtils.java.PredicateUtils.[Predicate<T>]nonePredicate()", "src/main/java/org/apache/commons/collections4/PredicateUtils.java.PredicateUtils.[Predicate<T>]notNullPredicate()", "src/main/java/org/apache/commons/collections4/PredicateUtils.java.PredicateUtils.[Predicate<T>]notPredicate(Predicate<? super T>)", "src/main/java/org/apache/commons/collections4/PredicateUtils.java.PredicateUtils.[Predicate<T>]nullIsExceptionPredicate(Predicate<? super T>)", "src/main/java/org/apache/commons/collections4/PredicateUtils.java.PredicateUtils.[Predicate<T>]nullIsFalsePredicate(Predicate<? super T>)", "src/main/java/org/apache/commons/collections4/PredicateUtils.java.PredicateUtils.[Predicate<T>]nullIsTruePredicate(Predicate<? super T>)", "src/main/java/org/apache/commons/collections4/PredicateUtils.java.PredicateUtils.[Predicate<T>]nullPredicate()", "src/main/java/org/apache/commons/collections4/PredicateUtils.java.PredicateUtils.[Predicate<T>]onePredicate(Collection<? extends Predicate<? super T>>)", "src/main/java/org/apache/commons/collections4/PredicateUtils.java.PredicateUtils.[Predicate<T>]onePredicate()", "src/main/java/org/apache/commons/collections4/PredicateUtils.java.PredicateUtils.[Predicate<T>]orPredicate(Predicate<? super T>,Predicate<? super T>)", "src/main/java/org/apache/commons/collections4/PredicateUtils.java.PredicateUtils.[Predicate<T>]transformedPredicate(Transformer<? super T, ? extends T>,Predicate<? super T>)", "src/main/java/org/apache/commons/collections4/PredicateUtils.java.PredicateUtils.[Predicate<T>]truePredicate()", "src/main/java/org/apache/commons/collections4/PredicateUtils.java.PredicateUtils.[Predicate<T>]uniquePredicate()", "src/main/java/org/apache/commons/collections4/PredicateUtils.java.PredicateUtils.[]PredicateUtils()"], "overrides": null, "attributes": [], "class_docstring": "\n{@code PredicateUtils} provides reference implementations and utilities\nfor the Predicate functor interface. The supplied predicates are:\n<ul>\n<li>Invoker - returns the result of a method call on the input object\n<li>InstanceOf - true if the object is an instanceof a class\n<li>Equal - true if the object equals() a specified object\n<li>Identity - true if the object == a specified object\n<li>Null - true if the object is null\n<li>NotNull - true if the object is not null\n<li>Unique - true if the object has not already been evaluated\n<li>And/All - true if all of the predicates are true\n<li>Or/Any - true if any of the predicates is true\n<li>Either/One - true if only one of the predicate is true\n<li>Neither/None - true if none of the predicates are true\n<li>Not - true if the predicate is false, and vice versa\n<li>Transformer - wraps a Transformer as a Predicate\n<li>True - always return true\n<li>False - always return false\n<li>Exception - always throws an exception\n<li>NullIsException/NullIsFalse/NullIsTrue - check for null input\n<li>Transformed - transforms the input before calling the predicate\n</ul>\nAll the supplied predicates are Serializable.\n\n@since 3.0\n", "original_string": "public class PredicateUtils {\n\n    /**\n     * Create a new Predicate that returns true only if all of the specified\n     * predicates are true. The predicates are checked in iterator order.\n     * If the collection of predicates is empty, then this predicate returns true.\n     *\n     * @param <T>  the type that the predicate queries\n     * @param predicates  a collection of predicates to check, may not be null\n     * @return the {@code all} predicate\n     * @throws NullPointerException if the predicates collection is null\n     * @throws NullPointerException if any predicate in the collection is null\n     * @see AllPredicate\n     */\n    public static <T> Predicate<T> allPredicate(final Collection<? extends Predicate<? super T>> predicates) {\n        return AllPredicate.allPredicate(predicates);\n    }\n\n    /**\n     * Create a new Predicate that returns true only if all of the specified\n     * predicates are true.\n     * If the array of predicates is empty, then this predicate returns true.\n     *\n     * @param <T>  the type that the predicate queries\n     * @param predicates  an array of predicates to check, may not be null\n     * @return the {@code all} predicate\n     * @throws NullPointerException if the predicates array is null\n     * @throws NullPointerException if any predicate in the array is null\n     * @see AllPredicate\n     */\n    public static <T> Predicate<T> allPredicate(final Predicate<? super T>... predicates) {\n        return AllPredicate.allPredicate(predicates);\n    }\n\n    /**\n     * Create a new Predicate that returns true only if both of the specified\n     * predicates are true.\n     *\n     * @param <T>  the type that the predicate queries\n     * @param predicate1  the first predicate, may not be null\n     * @param predicate2  the second predicate, may not be null\n     * @return the {@code and} predicate\n     * @throws NullPointerException if either predicate is null\n     * @see AndPredicate\n     */\n    public static <T> Predicate<T> andPredicate(final Predicate<? super T> predicate1,\n                                                final Predicate<? super T> predicate2) {\n        return AndPredicate.andPredicate(predicate1, predicate2);\n    }\n\n    /**\n     * Create a new Predicate that returns true if any of the specified\n     * predicates are true. The predicates are checked in iterator order.\n     * If the collection of predicates is empty, then this predicate returns false.\n     *\n     * @param <T>  the type that the predicate queries\n     * @param predicates  a collection of predicates to check, may not be null\n     * @return the {@code any} predicate\n     * @throws NullPointerException if the predicates collection is null\n     * @throws NullPointerException if any predicate in the collection is null\n     * @see AnyPredicate\n     */\n    public static <T> Predicate<T> anyPredicate(final Collection<? extends Predicate<? super T>> predicates) {\n        return AnyPredicate.anyPredicate(predicates);\n    }\n\n    /**\n     * Create a new Predicate that returns true if any of the specified\n     * predicates are true.\n     * If the array of predicates is empty, then this predicate returns false.\n     *\n     * @param <T>  the type that the predicate queries\n     * @param predicates  an array of predicates to check, may not be null\n     * @return the {@code any} predicate\n     * @throws NullPointerException if the predicates array is null\n     * @throws NullPointerException if any predicate in the array is null\n     * @see AnyPredicate\n     */\n    public static <T> Predicate<T> anyPredicate(final Predicate<? super T>... predicates) {\n        return AnyPredicate.anyPredicate(predicates);\n    }\n\n    /**\n     * Create a new Predicate that wraps a Transformer. The Transformer must\n     * return either {@link Boolean#TRUE} or {@link Boolean#FALSE} otherwise a\n     * PredicateException will be thrown.\n     *\n     * @param <T>  the type that the predicate queries\n     * @param transformer  the transformer to wrap, may not be null\n     * @return the transformer wrapping predicate\n     * @throws NullPointerException if the transformer is null\n     * @see TransformerPredicate\n     */\n    public static <T> Predicate<T> asPredicate(final Transformer<? super T, Boolean> transformer) {\n        return TransformerPredicate.transformerPredicate(transformer);\n    }\n\n    /**\n     * Create a new Predicate that returns true if one, but not both, of the\n     * specified predicates are true. XOR\n     *\n     * @param <T>  the type that the predicate queries\n     * @param predicate1  the first predicate, may not be null\n     * @param predicate2  the second predicate, may not be null\n     * @return the {@code either} predicate\n     * @throws NullPointerException if either predicate is null\n     * @see OnePredicate\n     */\n    public static <T> Predicate<T> eitherPredicate(final Predicate<? super T> predicate1,\n                                                   final Predicate<? super T> predicate2) {\n        @SuppressWarnings(\"unchecked\")\n        final Predicate<T> onePredicate = onePredicate(predicate1, predicate2);\n        return onePredicate;\n    }\n\n    /**\n     * Creates a Predicate that checks if the input object is equal to the\n     * specified object using equals().\n     *\n     * @param <T>  the type that the predicate queries\n     * @param value  the value to compare against\n     * @return the predicate\n     * @see EqualPredicate\n     */\n    public static <T> Predicate<T> equalPredicate(final T value) {\n        return EqualPredicate.equalPredicate(value);\n    }\n\n    /**\n     * Gets a Predicate that always throws an exception.\n     * This could be useful during testing as a placeholder.\n     *\n     * @param <T>  the type that the predicate queries\n     * @return the predicate\n     * @see ExceptionPredicate\n     */\n    public static <T> Predicate<T> exceptionPredicate() {\n        return ExceptionPredicate.exceptionPredicate();\n    }\n\n    /**\n     * Gets a Predicate that always returns false.\n     *\n     * @param <T>  the type that the predicate queries\n     * @return the predicate\n     * @see FalsePredicate\n     */\n    public static <T> Predicate<T> falsePredicate() {\n        return FalsePredicate.falsePredicate();\n    }\n\n    /**\n     * Creates a Predicate that checks if the input object is equal to the\n     * specified object by identity.\n     *\n     * @param <T>  the type that the predicate queries\n     * @param value  the value to compare against\n     * @return the predicate\n     * @see IdentityPredicate\n     */\n    public static <T> Predicate<T> identityPredicate(final T value) {\n        return IdentityPredicate.identityPredicate(value);\n    }\n\n    /**\n     * Creates a Predicate that checks if the object passed in is of\n     * a particular type, using instanceof. A {@code null} input\n     * object will return {@code false}.\n     *\n     * @param type  the type to check for, may not be null\n     * @return the predicate\n     * @throws NullPointerException if the class is null\n     * @see InstanceofPredicate\n     */\n    public static Predicate<Object> instanceofPredicate(final Class<?> type) {\n        return InstanceofPredicate.instanceOfPredicate(type);\n    }\n\n    /**\n     * Creates a Predicate that invokes a method on the input object.\n     * The method must return either a boolean or a non-null Boolean,\n     * and have no parameters. If the input object is null, a\n     * PredicateException is thrown.\n     * <p>\n     * For ePredicateUtils.invokerPredicate(\"isEmpty\");}\n     * will call the {@code isEmpty} method on the input object to\n     * determine the predicate result.\n     *\n     * @param <T>  the type that the predicate queries\n     * @param methodName  the method name to call on the input object, may not be null\n     * @return the predicate\n     * @throws NullPointerException if the methodName is null.\n     * @see InvokerTransformer\n     * @see TransformerPredicate\n     */\n    public static <T> Predicate<T> invokerPredicate(final String methodName) {\n        // reuse transformer as it has caching - this is lazy really, should have inner class here\n        return asPredicate(InvokerTransformer.<Object, Boolean>invokerTransformer(methodName));\n    }\n\n    /**\n     * Creates a Predicate that invokes a method on the input object.\n     * The method must return either a boolean or a non-null Boolean,\n     * and have no parameters. If the input object is null, a\n     * PredicateException is thrown.\n     * <p>\n     * For example, {@code PredicateUtils.invokerPredicate(\"isEmpty\");}\n     * will call the {@code isEmpty} method on the input object to\n     * determine the predicate result.\n     *\n     * @param <T>  the type that the predicate queries\n     * @param methodName  the method name to call on the input object, may not be null\n     * @param paramTypes  the parameter types\n     * @param args  the arguments\n     * @return the predicate\n     * @throws NullPointerException if the method name is null\n     * @throws IllegalArgumentException if the paramTypes and args don't match\n     * @see InvokerTransformer\n     * @see TransformerPredicate\n     */\n    public static <T> Predicate<T> invokerPredicate(final String methodName, final Class<?>[] paramTypes,\n                                                    final Object[] args) {\n        // reuse transformer as it has caching - this is lazy really, should have inner class here\n        return asPredicate(InvokerTransformer.<Object, Boolean>invokerTransformer(methodName, paramTypes, args));\n    }\n\n    /**\n     * Create a new Predicate that returns true if neither of the specified\n     * predicates are true.\n     *\n     * @param <T>  the type that the predicate queries\n     * @param predicate1  the first predicate, may not be null\n     * @param predicate2  the second predicate, may not be null\n     * @return the {@code neither} predicate\n     * @throws NullPointerException if either predicate is null\n     * @see NonePredicate\n     */\n    public static <T> Predicate<T> neitherPredicate(final Predicate<? super T> predicate1,\n                                                    final Predicate<? super T> predicate2) {\n        @SuppressWarnings(\"unchecked\")\n        final Predicate<T> nonePredicate = nonePredicate(predicate1, predicate2);\n        return nonePredicate;\n    }\n\n    /**\n     * Create a new Predicate that returns true if none of the specified\n     * predicates are true. The predicates are checked in iterator order.\n     * If the collection of predicates is empty, then this predicate returns true.\n     *\n     * @param <T>  the type that the predicate queries\n     * @param predicates  a collection of predicates to check, may not be null\n     * @return the {@code none} predicate\n     * @throws NullPointerException if the predicates collection is null\n     * @throws NullPointerException if any predicate in the collection is null\n     * @see NonePredicate\n     */\n    public static <T> Predicate<T> nonePredicate(final Collection<? extends Predicate<? super T>> predicates) {\n        return NonePredicate.nonePredicate(predicates);\n    }\n\n    /**\n     * Create a new Predicate that returns true if none of the specified\n     * predicates are true.\n     * If the array of predicates is empty, then this predicate returns true.\n     *\n     * @param <T>  the type that the predicate queries\n     * @param predicates  an array of predicates to check, may not be null\n     * @return the {@code none} predicate\n     * @throws NullPointerException if the predicates array is null\n     * @throws NullPointerException if any predicate in the array is null\n     * @see NonePredicate\n     */\n    public static <T> Predicate<T> nonePredicate(final Predicate<? super T>... predicates) {\n        return NonePredicate.nonePredicate(predicates);\n    }\n\n    /**\n     * Gets a Predicate that checks if the input object passed in is not null.\n     *\n     * @param <T>  the type that the predicate queries\n     * @return the predicate\n     * @see NotNullPredicate\n     */\n    public static <T> Predicate<T> notNullPredicate() {\n        return NotNullPredicate.notNullPredicate();\n    }\n\n    /**\n     * Create a new Predicate that returns true if the specified predicate\n     * returns false and vice versa.\n     *\n     * @param <T>  the type that the predicate queries\n     * @param predicate  the predicate to not\n     * @return the {@code not} predicate\n     * @throws NullPointerException if the predicate is null\n     * @see NotPredicate\n     */\n    public static <T> Predicate<T> notPredicate(final Predicate<? super T> predicate) {\n        return NotPredicate.notPredicate(predicate);\n    }\n\n    /**\n     * Gets a Predicate that throws an exception if the input object is null,\n     * otherwise it calls the specified Predicate. This allows null handling\n     * behavior to be added to Predicates that don't support nulls.\n     *\n     * @param <T>  the type that the predicate queries\n     * @param predicate  the predicate to wrap, may not be null\n     * @return the predicate\n     * @throws NullPointerException if the predicate is null.\n     * @see NullIsExceptionPredicate\n     */\n    public static <T> Predicate<T> nullIsExceptionPredicate(final Predicate<? super T> predicate) {\n        return NullIsExceptionPredicate.nullIsExceptionPredicate(predicate);\n    }\n\n    /**\n     * Gets a Predicate that returns false if the input object is null, otherwise\n     * it calls the specified Predicate. This allows null handling behavior to\n     * be added to Predicates that don't support nulls.\n     *\n     * @param <T>  the type that the predicate queries\n     * @param predicate  the predicate to wrap, may not be null\n     * @return the predicate\n     * @throws NullPointerException if the predicate is null.\n     * @see NullIsFalsePredicate\n     */\n    public static <T> Predicate<T> nullIsFalsePredicate(final Predicate<? super T> predicate) {\n        return NullIsFalsePredicate.nullIsFalsePredicate(predicate);\n    }\n\n    /**\n     * Gets a Predicate that returns true if the input object is null, otherwise\n     * it calls the specified Predicate. This allows null handling behavior to\n     * be added to Predicates that don't support nulls.\n     *\n     * @param <T>  the type that the predicate queries\n     * @param predicate  the predicate to wrap, may not be null\n     * @return the predicate\n     * @throws NullPointerException if the predicate is null.\n     * @see NullIsTruePredicate\n     */\n    public static <T> Predicate<T> nullIsTruePredicate(final Predicate<? super T> predicate) {\n        return NullIsTruePredicate.nullIsTruePredicate(predicate);\n    }\n\n    /**\n     * Gets a Predicate that checks if the input object passed in is null.\n     *\n     * @param <T>  the type that the predicate queries\n     * @return the predicate\n     * @see NullPredicate\n     */\n    public static <T> Predicate<T> nullPredicate() {\n        return NullPredicate.nullPredicate();\n    }\n\n    /**\n     * Create a new Predicate that returns true if only one of the specified\n     * predicates are true. The predicates are checked in iterator order.\n     * If the collection of predicates is empty, then this predicate returns false.\n     *\n     * @param <T>  the type that the predicate queries\n     * @param predicates  a collection of predicates to check, may not be null\n     * @return the {@code one} predicate\n     * @throws NullPointerException if the predicates collection is null\n     * @throws NullPointerException if any predicate in the collection is null\n     * @see OnePredicate\n     */\n    public static <T> Predicate<T> onePredicate(final Collection<? extends Predicate<? super T>> predicates) {\n        return OnePredicate.onePredicate(predicates);\n    }\n\n    /**\n     * Create a new Predicate that returns true if only one of the specified\n     * predicates are true.\n     * If the array of predicates is empty, then this predicate returns false.\n     *\n     * @param <T>  the type that the predicate queries\n     * @param predicates  an array of predicates to check, may not be null\n     * @return the {@code one} predicate\n     * @throws NullPointerException if the predicates array is null\n     * @throws NullPointerException if any predicate in the array is null\n     * @see OnePredicate\n     */\n    public static <T> Predicate<T> onePredicate(final Predicate<? super T>... predicates) {\n        return OnePredicate.onePredicate(predicates);\n    }\n\n    /**\n     * Create a new Predicate that returns true if either of the specified\n     * predicates are true.\n     *\n     * @param <T>  the type that the predicate queries\n     * @param predicate1  the first predicate, may not be null\n     * @param predicate2  the second predicate, may not be null\n     * @return the {@code or} predicate\n     * @throws NullPointerException if either predicate is null\n     * @see OrPredicate\n     */\n    public static <T> Predicate<T> orPredicate(final Predicate<? super T> predicate1,\n                                               final Predicate<? super T> predicate2) {\n        return OrPredicate.orPredicate(predicate1, predicate2);\n    }\n\n    // Transformed\n    /**\n     * Creates a predicate that transforms the input object before passing it\n     * to the predicate.\n     *\n     * @param <T>  the type that the predicate queries\n     * @param transformer  the transformer to call first\n     * @param predicate  the predicate to call with the result of the transform\n     * @return the predicate\n     * @throws NullPointerException if the transformer or the predicate is null\n     * @see TransformedPredicate\n     * @since 3.1\n     */\n    public static <T> Predicate<T> transformedPredicate(final Transformer<? super T, ? extends T> transformer, final Predicate<? super T> predicate) {\n        return TransformedPredicate.transformedPredicate(transformer, predicate);\n    }\n\n    /**\n     * Gets a Predicate that always returns true.\n     *\n     * @param <T>  the type that the predicate queries\n     * @return the predicate\n     * @see TruePredicate\n     */\n    public static <T> Predicate<T> truePredicate() {\n        return TruePredicate.truePredicate();\n    }\n\n    /**\n     * Creates a Predicate that returns true the first time an object is\n     * encountered, and false if the same object is received\n     * again. The comparison is by equals(). A {@code null} input object\n     * is accepted and will return true the first time, and false subsequently\n     * as well.\n     *\n     * @param <T>  the type that the predicate queries\n     * @return the predicate\n     * @see UniquePredicate\n     */\n    public static <T> Predicate<T> uniquePredicate() {\n        // must return new instance each time\n        return UniquePredicate.uniquePredicate();\n    }\n\n    /**\n     * Don't allow instances.\n     */\n    private PredicateUtils() {\n        // empty\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/org/apache/commons/collections4/ClosureUtils.java.ClosureUtils", "name": "ClosureUtils", "file_path": "src/main/java/org/apache/commons/collections4/ClosureUtils.java", "superclasses": "", "methods": ["[Closure<E>]asClosure(Transformer<? super E, ?>)", "[Closure<E>]chainedClosure()", "[Closure<E>]chainedClosure(Collection<? extends Closure<? super E>>)", "[Closure<E>]doWhileClosure(Closure<? super E>,Predicate<? super E>)", "[Closure<E>]exceptionClosure()", "[Closure<E>]forClosure(int,Closure<? super E>)", "[Closure<E>]ifClosure(Predicate<? super E>,Closure<? super E>)", "[Closure<E>]ifClosure(Predicate<? super E>,Closure<? super E>,Closure<? super E>)", "[Closure<E>]invokerClosure(String)", "[Closure<E>]invokerClosure(String,Class<?>[],Object[])", "[Closure<E>]nopClosure()", "[Closure<E>]switchClosure(Map<Predicate<E>, Closure<E>>)", "[Closure<E>]switchClosure(Predicate<? super E>[],Closure<? super E>[])", "[Closure<E>]switchClosure(Predicate<? super E>[],Closure<? super E>[],Closure<? super E>)", "[Closure<E>]switchMapClosure(Map<? extends E, Closure<E>>)", "[Closure<E>]whileClosure(Predicate<? super E>,Closure<? super E>)", "[]ClosureUtils()"], "method_uris": ["src/main/java/org/apache/commons/collections4/ClosureUtils.java.ClosureUtils.[Closure<E>]asClosure(Transformer<? super E, ?>)", "src/main/java/org/apache/commons/collections4/ClosureUtils.java.ClosureUtils.[Closure<E>]chainedClosure()", "src/main/java/org/apache/commons/collections4/ClosureUtils.java.ClosureUtils.[Closure<E>]chainedClosure(Collection<? extends Closure<? super E>>)", "src/main/java/org/apache/commons/collections4/ClosureUtils.java.ClosureUtils.[Closure<E>]doWhileClosure(Closure<? super E>,Predicate<? super E>)", "src/main/java/org/apache/commons/collections4/ClosureUtils.java.ClosureUtils.[Closure<E>]exceptionClosure()", "src/main/java/org/apache/commons/collections4/ClosureUtils.java.ClosureUtils.[Closure<E>]forClosure(int,Closure<? super E>)", "src/main/java/org/apache/commons/collections4/ClosureUtils.java.ClosureUtils.[Closure<E>]ifClosure(Predicate<? super E>,Closure<? super E>)", "src/main/java/org/apache/commons/collections4/ClosureUtils.java.ClosureUtils.[Closure<E>]ifClosure(Predicate<? super E>,Closure<? super E>,Closure<? super E>)", "src/main/java/org/apache/commons/collections4/ClosureUtils.java.ClosureUtils.[Closure<E>]invokerClosure(String)", "src/main/java/org/apache/commons/collections4/ClosureUtils.java.ClosureUtils.[Closure<E>]invokerClosure(String,Class<?>[],Object[])", "src/main/java/org/apache/commons/collections4/ClosureUtils.java.ClosureUtils.[Closure<E>]nopClosure()", "src/main/java/org/apache/commons/collections4/ClosureUtils.java.ClosureUtils.[Closure<E>]switchClosure(Map<Predicate<E>, Closure<E>>)", "src/main/java/org/apache/commons/collections4/ClosureUtils.java.ClosureUtils.[Closure<E>]switchClosure(Predicate<? super E>[],Closure<? super E>[])", "src/main/java/org/apache/commons/collections4/ClosureUtils.java.ClosureUtils.[Closure<E>]switchClosure(Predicate<? super E>[],Closure<? super E>[],Closure<? super E>)", "src/main/java/org/apache/commons/collections4/ClosureUtils.java.ClosureUtils.[Closure<E>]switchMapClosure(Map<? extends E, Closure<E>>)", "src/main/java/org/apache/commons/collections4/ClosureUtils.java.ClosureUtils.[Closure<E>]whileClosure(Predicate<? super E>,Closure<? super E>)", "src/main/java/org/apache/commons/collections4/ClosureUtils.java.ClosureUtils.[]ClosureUtils()"], "overrides": null, "attributes": [], "class_docstring": "\n{@code ClosureUtils} provides reference implementations and utilities\nfor the Closure functor interface. The supplied closures are:\n<ul>\n<li>Invoker - invokes a method on the input object\n<li>For - repeatedly calls a closure for a fixed number of times\n<li>While - repeatedly calls a closure while a predicate is true\n<li>Chained - chains two or more closures together\n<li>If - calls one closure or another based on a predicate\n<li>Switch - calls one closure based on one or more predicates\n<li>SwitchMap - calls one closure looked up from a Map\n<li>Transformer - wraps a Transformer as a Closure\n<li>NOP - does nothing\n<li>Exception - always throws an exception\n</ul>\n<p>\nSince v4.1 only closures which are considered to be safe are\nSerializable. Closures considered to be unsafe for serialization are:\n</p>\n<ul>\n<li>Invoker\n<li>For\n<li>While\n</ul>\n\n@since 3.0\n", "original_string": "public class ClosureUtils {\n\n    /**\n     * Creates a Closure that calls a Transformer each time it is called.\n     * The transformer will be called using the closure's input object.\n     * The transformer's result will be ignored.\n     *\n     * @see org.apache.commons.collections4.functors.TransformerClosure\n     *\n     * @param <E>  the type that the closure acts on\n     * @param transformer  the transformer to run each time in the closure, null means nop\n     * @return the closure\n     */\n    public static <E> Closure<E> asClosure(final Transformer<? super E, ?> transformer) {\n        return TransformerClosure.transformerClosure(transformer);\n    }\n\n    /**\n     * Create a new Closure that calls each closure in turn, passing the\n     * result into the next closure.\n     *\n     * @see org.apache.commons.collections4.functors.ChainedClosure\n     *\n     * @param <E>  the type that the closure acts on\n     * @param closures  an array of closures to chain\n     * @return the {@code chained} closure\n     * @throws NullPointerException if the closures array is null\n     * @throws NullPointerException if any closure in the array is null\n     */\n    public static <E> Closure<E> chainedClosure(final Closure<? super E>... closures) {\n        return ChainedClosure.chainedClosure(closures);\n    }\n\n    /**\n     * Create a new Closure that calls each closure in turn, passing the\n     * result into the next closure. The ordering is that of the iterator()\n     * method on the collection.\n     *\n     * @see org.apache.commons.collections4.functors.ChainedClosure\n     *\n     * @param <E>  the type that the closure acts on\n     * @param closures  a collection of closures to chain\n     * @return the {@code chained} closure\n     * @throws NullPointerException if the closures collection is null\n     * @throws NullPointerException if any closure in the collection is null\n     * @throws IllegalArgumentException if the closures collection is empty\n     */\n    public static <E> Closure<E> chainedClosure(final Collection<? extends Closure<? super E>> closures) {\n        return ChainedClosure.chainedClosure(closures);\n    }\n\n    /**\n     * Creates a Closure that will call the closure once and then repeatedly\n     * until the predicate returns false.\n     *\n     * @see org.apache.commons.collections4.functors.WhileClosure\n     *\n     * @param <E>  the type that the closure acts on\n     * @param closure  the closure to call repeatedly, not null\n     * @param predicate  the predicate to use as an end of loop test, not null\n     * @return the {@code do-while} closure\n     * @throws NullPointerException if either argument is null\n     */\n    public static <E> Closure<E> doWhileClosure(final Closure<? super E> closure,\n                                                final Predicate<? super E> predicate) {\n        return WhileClosure.<E>whileClosure(predicate, closure, true);\n    }\n\n    /**\n     * Gets a Closure that always throws an exception.\n     * This could be useful during testing as a placeholder.\n     *\n     * @see org.apache.commons.collections4.functors.ExceptionClosure\n     *\n     * @param <E>  the type that the closure acts on\n     * @return the closure\n     */\n    public static <E> Closure<E> exceptionClosure() {\n        return ExceptionClosure.<E>exceptionClosure();\n    }\n\n    /**\n     * Creates a Closure that will call the closure {@code count} times.\n     * <p>\n     * A null closure or zero count returns the {@code NOPClosure}.\n     *\n     * @see org.apache.commons.collections4.functors.ForClosure\n     *\n     * @param <E>  the type that the closure acts on\n     * @param count  the number of times to loop\n     * @param closure  the closure to call repeatedly\n     * @return the {@code for} closure\n     */\n    public static <E> Closure<E> forClosure(final int count, final Closure<? super E> closure) {\n        return ForClosure.forClosure(count, closure);\n    }\n\n    /**\n     * Create a new Closure that calls another closure based on the\n     * result of the specified predicate.\n     *\n     * @see org.apache.commons.collections4.functors.IfClosure\n     *\n     * @param <E>  the type that the closure acts on\n     * @param predicate  the validating predicate\n     * @param trueClosure  the closure called if the predicate is true\n     * @return the {@code if} closure\n     * @throws NullPointerException if the predicate or closure is null\n     * @since 3.2\n     */\n    public static <E> Closure<E> ifClosure(final Predicate<? super E> predicate,\n                                           final Closure<? super E> trueClosure) {\n        return IfClosure.<E>ifClosure(predicate, trueClosure);\n    }\n\n    /**\n     * Create a new Closure that calls one of two closures depending\n     * on the specified predicate.\n     *\n     * @see org.apache.commons.collections4.functors.IfClosure\n     *\n     * @param <E>  the type that the closure acts on\n     * @param predicate  the predicate to switch on\n     * @param trueClosure  the closure called if the predicate is true\n     * @param falseClosure  the closure called if the predicate is false\n     * @return the {@code switch} closure\n     * @throws NullPointerException if the predicate or either closure is null\n     */\n    public static <E> Closure<E> ifClosure(final Predicate<? super E> predicate,\n                                           final Closure<? super E> trueClosure,\n                                           final Closure<? super E> falseClosure) {\n        return IfClosure.<E>ifClosure(predicate, trueClosure, falseClosure);\n    }\n\n    /**\n     * Creates a Closure that will invoke a specific method on the closure's\n     * input object by reflection.\n     *\n     * @see org.apache.commons.collections4.functors.InvokerTransformer\n     * @see org.apache.commons.collections4.functors.TransformerClosure\n     *\n     * @param <E>  the type that the closure acts on\n     * @param methodName  the name of the method\n     * @return the {@code invoker} closure\n     * @throws NullPointerException if the method name is null\n     */\n    public static <E> Closure<E> invokerClosure(final String methodName) {\n        // reuse transformer as it has caching - this is lazy really, should have inner class here\n        return asClosure(InvokerTransformer.<E, Object>invokerTransformer(methodName));\n    }\n\n    /**\n     * Creates a Closure that will invoke a specific method on the closure's\n     * input object by reflection.\n     *\n     * @see org.apache.commons.collections4.functors.InvokerTransformer\n     * @see org.apache.commons.collections4.functors.TransformerClosure\n     *\n     * @param <E>  the type that the closure acts on\n     * @param methodName  the name of the method\n     * @param paramTypes  the parameter types\n     * @param args  the arguments\n     * @return the {@code invoker} closure\n     * @throws NullPointerException if the method name is null\n     * @throws IllegalArgumentException if the paramTypes and args don't match\n     */\n    public static <E> Closure<E> invokerClosure(final String methodName, final Class<?>[] paramTypes,\n                                                final Object[] args) {\n        // reuse transformer as it has caching - this is lazy really, should have inner class here\n        return asClosure(InvokerTransformer.<E, Object>invokerTransformer(methodName, paramTypes, args));\n    }\n\n    /**\n     * Gets a Closure that will do nothing.\n     * This could be useful during testing as a placeholder.\n     *\n     * @see org.apache.commons.collections4.functors.NOPClosure\n     *\n     * @param <E>  the type that the closure acts on\n     * @return the closure\n     */\n    public static <E> Closure<E> nopClosure() {\n        return NOPClosure.<E>nopClosure();\n    }\n\n    /**\n     * Create a new Closure that calls one of the closures depending\n     * on the predicates.\n     * <p>\n     * The Map consists of Predicate keys and Closure values. A closure\n     * is called if its matching predicate returns true. Each predicate is evaluated\n     * until one returns true. If no predicates evaluate to true, the default\n     * closure is called. The default closure is set in the map with a\n     * null key. The ordering is that of the iterator() method on the entryset\n     * collection of the map.\n     *\n     * @see org.apache.commons.collections4.functors.SwitchClosure\n     *\n     * @param <E>  the type that the closure acts on\n     * @param predicatesAndClosures  a map of predicates to closures\n     * @return the {@code switch} closure\n     * @throws NullPointerException if the map is null\n     * @throws NullPointerException if any closure in the map is null\n     * @throws IllegalArgumentException if the map is empty\n     * @throws ClassCastException  if the map elements are of the wrong type\n     */\n    public static <E> Closure<E> switchClosure(final Map<Predicate<E>, Closure<E>> predicatesAndClosures) {\n        return SwitchClosure.switchClosure(predicatesAndClosures);\n    }\n\n    /**\n     * Create a new Closure that calls one of the closures depending\n     * on the predicates.\n     * <p>\n     * The closure at array location 0 is called if the predicate at array\n     * location 0 returned true. Each predicate is evaluated\n     * until one returns true.\n     *\n     * @see org.apache.commons.collections4.functors.SwitchClosure\n     *\n     * @param <E>  the type that the closure acts on\n     * @param predicates  an array of predicates to check, not null\n     * @param closures  an array of closures to call, not null\n     * @return the {@code switch} closure\n     * @throws NullPointerException if either array is null\n     * @throws NullPointerException if any element in the arrays is null\n     * @throws IllegalArgumentException if the arrays have different sizes\n     */\n    public static <E> Closure<E> switchClosure(final Predicate<? super E>[] predicates,\n                                               final Closure<? super E>[] closures) {\n        return SwitchClosure.<E>switchClosure(predicates, closures, null);\n    }\n\n    /**\n     * Create a new Closure that calls one of the closures depending\n     * on the predicates.\n     * <p>\n     * The closure at array location 0 is called if the predicate at array\n     * location 0 returned true. Each predicate is evaluated\n     * until one returns true. If no predicates evaluate to true, the default\n     * closure is called.\n     *\n     * @see org.apache.commons.collections4.functors.SwitchClosure\n     *\n     * @param <E>  the type that the closure acts on\n     * @param predicates  an array of predicates to check, not null\n     * @param closures  an array of closures to call, not null\n     * @param defaultClosure  the default to call if no predicate matches\n     * @return the {@code switch} closure\n     * @throws NullPointerException if either array is null\n     * @throws NullPointerException if any element in the arrays is null\n     * @throws IllegalArgumentException if the arrays are different sizes\n     */\n    public static <E> Closure<E> switchClosure(final Predicate<? super E>[] predicates,\n                                               final Closure<? super E>[] closures,\n                                               final Closure<? super E> defaultClosure) {\n        return SwitchClosure.<E>switchClosure(predicates, closures, defaultClosure);\n    }\n\n    /**\n     * Create a new Closure that uses the input object as a key to find the\n     * closure to call.\n     * <p>\n     * The Map consists of object keys and Closure values. A closure\n     * is called if the input object equals the key. If there is no match, the\n     * default closure is called. The default closure is set in the map\n     * using a null key.\n     *\n     * @see org.apache.commons.collections4.functors.SwitchClosure\n     *\n     * @param <E>  the type that the closure acts on\n     * @param objectsAndClosures  a map of objects to closures\n     * @return the closure\n     * @throws NullPointerException if the map is null\n     * @throws NullPointerException if any closure in the map is null\n     * @throws IllegalArgumentException if the map is empty\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static <E> Closure<E> switchMapClosure(final Map<? extends E, Closure<E>> objectsAndClosures) {\n        Objects.requireNonNull(objectsAndClosures, \"objectsAndClosures\");\n        final Closure<? super E> def = objectsAndClosures.remove(null);\n        final int size = objectsAndClosures.size();\n        final Closure<? super E>[] trs = new Closure[size];\n        final Predicate<E>[] preds = new Predicate[size];\n        int i = 0;\n        for (final Map.Entry<? extends E, Closure<E>> entry : objectsAndClosures.entrySet()) {\n            preds[i] = EqualPredicate.<E>equalPredicate(entry.getKey());\n            trs[i] = entry.getValue();\n            i++;\n        }\n        return ClosureUtils.<E>switchClosure(preds, trs, def);\n    }\n\n    /**\n     * Creates a Closure that will call the closure repeatedly until the\n     * predicate returns false.\n     *\n     * @see org.apache.commons.collections4.functors.WhileClosure\n     *\n     * @param <E>  the type that the closure acts on\n     * @param predicate  the predicate to use as an end of loop test, not null\n     * @param closure  the closure to call repeatedly, not null\n     * @return the {@code while} closure\n     * @throws NullPointerException if either argument is null\n     */\n    public static <E> Closure<E> whileClosure(final Predicate<? super E> predicate, final Closure<? super E> closure) {\n        return WhileClosure.<E>whileClosure(predicate, closure, false);\n    }\n\n    /**\n     * Don't allow instances.\n     */\n    private ClosureUtils() {\n        // empty\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/org/apache/commons/collections4/SplitMapUtils.java.SplitMapUtils", "name": "SplitMapUtils", "file_path": "src/main/java/org/apache/commons/collections4/SplitMapUtils.java", "superclasses": "", "methods": ["[IterableMap<K, V>]readableMap(Get<K, V>)", "[Map<K, V>]writableMap(Put<K, V>)", "[]SplitMapUtils()"], "method_uris": ["src/main/java/org/apache/commons/collections4/SplitMapUtils.java.SplitMapUtils.[IterableMap<K, V>]readableMap(Get<K, V>)", "src/main/java/org/apache/commons/collections4/SplitMapUtils.java.SplitMapUtils.[Map<K, V>]writableMap(Put<K, V>)", "src/main/java/org/apache/commons/collections4/SplitMapUtils.java.SplitMapUtils.[]SplitMapUtils()"], "overrides": null, "attributes": [{"original_string": "    private static final class WrappedGet<K, V> implements IterableMap<K, V>, Unmodifiable {\n        private final Get<K, V> get;\n\n        private WrappedGet(final Get<K, V> get) {\n            this.get = get;\n        }\n\n        @Override\n        public void clear() {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public boolean containsKey(final Object key) {\n            return get.containsKey(key);\n        }\n\n        @Override\n        public boolean containsValue(final Object value) {\n            return get.containsValue(value);\n        }\n\n        @Override\n        public Set<Map.Entry<K, V>> entrySet() {\n            return UnmodifiableEntrySet.unmodifiableEntrySet(get.entrySet());\n        }\n\n        @Override\n        public boolean equals(final Object arg0) {\n            if (arg0 == this) {\n                return true;\n            }\n            return arg0 instanceof WrappedGet && ((WrappedGet<?, ?>) arg0).get.equals(get);\n        }\n\n        @Override\n        public V get(final Object key) {\n            return get.get(key);\n        }\n\n        @Override\n        public int hashCode() {\n            return \"WrappedGet\".hashCode() << 4 | get.hashCode();\n        }\n\n        @Override\n        public boolean isEmpty() {\n            return get.isEmpty();\n        }\n\n        @Override\n        public Set<K> keySet() {\n            return UnmodifiableSet.unmodifiableSet(get.keySet());\n        }\n\n        @Override\n        public MapIterator<K, V> mapIterator() {\n            final MapIterator<K, V> it;\n            if (get instanceof IterableGet) {\n                it = ((IterableGet<K, V>) get).mapIterator();\n            } else {\n                it = new EntrySetToMapIteratorAdapter<>(get.entrySet());\n            }\n            return UnmodifiableMapIterator.unmodifiableMapIterator(it);\n        }\n\n        @Override\n        public V put(final K key, final V value) {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public void putAll(final Map<? extends K, ? extends V> t) {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public V remove(final Object key) {\n            return get.remove(key);\n        }\n\n        @Override\n        public int size() {\n            return get.size();\n        }\n\n        @Override\n        public Collection<V> values() {\n            return UnmodifiableCollection.unmodifiableCollection(get.values());\n        }\n    }", "definition": "    private static final class WrappedGet<K, V> implements IterableMap<K, V>, Unmodifiable", "class_docstring": "", "name": "WrappedGet", "super_interfaces": ["IterableMap<K, V>", "Unmodifiable"], "superclasses": "", "attributes": {"modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "fields": [{"attribute_expression": "private final Get<K, V> get;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Get<K, V>", "name": "get", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        private WrappedGet(final Get<K, V> get) {\n            this.get = get;\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "WrappedGet", "params": [{"name": "get", "type": "Get<K, V>"}], "body": "                                                {\n            this.get = get;\n        }", "signature": "private WrappedGet(final Get<K, V> get)"}, {"syntax_pass": true, "original_string": "        @Override\n        public void clear() {\n            throw new UnsupportedOperationException();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "clear", "params": [], "body": "                            {\n            throw new UnsupportedOperationException();\n        }", "signature": "@Override\n        public void clear()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean containsKey(final Object key) {\n            return get.containsKey(key);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "containsKey", "params": [{"name": "key", "type": "Object"}], "body": "                                                     {\n            return get.containsKey(key);\n        }", "signature": "@Override\n        public boolean containsKey(final Object key)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean containsValue(final Object value) {\n            return get.containsValue(value);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "containsValue", "params": [{"name": "value", "type": "Object"}], "body": "                                                         {\n            return get.containsValue(value);\n        }", "signature": "@Override\n        public boolean containsValue(final Object value)"}, {"syntax_pass": true, "original_string": "        @Override\n        public Set<Map.Entry<K, V>> entrySet() {\n            return UnmodifiableEntrySet.unmodifiableEntrySet(get.entrySet());\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Set<Map.Entry<K, V>>", "classes": []}, "name": "entrySet", "params": [], "body": "                                               {\n            return UnmodifiableEntrySet.unmodifiableEntrySet(get.entrySet());\n        }", "signature": "@Override\n        public Set<Map.Entry<K, V>> entrySet()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean equals(final Object arg0) {\n            if (arg0 == this) {\n                return true;\n            }\n            return arg0 instanceof WrappedGet && ((WrappedGet<?, ?>) arg0).get.equals(get);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "arg0", "type": "Object"}], "body": "                                                 {\n            if (arg0 == this) {\n                return true;\n            }\n            return arg0 instanceof WrappedGet && ((WrappedGet<?, ?>) arg0).get.equals(get);\n        }", "signature": "@Override\n        public boolean equals(final Object arg0)"}, {"syntax_pass": true, "original_string": "        @Override\n        public V get(final Object key) {\n            return get.get(key);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "get", "params": [{"name": "key", "type": "Object"}], "body": "                                       {\n            return get.get(key);\n        }", "signature": "@Override\n        public V get(final Object key)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int hashCode() {\n            return \"WrappedGet\".hashCode() << 4 | get.hashCode();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                              {\n            return \"WrappedGet\".hashCode() << 4 | get.hashCode();\n        }", "signature": "@Override\n        public int hashCode()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isEmpty() {\n            return get.isEmpty();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isEmpty", "params": [], "body": "                                 {\n            return get.isEmpty();\n        }", "signature": "@Override\n        public boolean isEmpty()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Set<K> keySet() {\n            return UnmodifiableSet.unmodifiableSet(get.keySet());\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Set<K>", "classes": []}, "name": "keySet", "params": [], "body": "                               {\n            return UnmodifiableSet.unmodifiableSet(get.keySet());\n        }", "signature": "@Override\n        public Set<K> keySet()"}, {"syntax_pass": true, "original_string": "        @Override\n        public MapIterator<K, V> mapIterator() {\n            final MapIterator<K, V> it;\n            if (get instanceof IterableGet) {\n                it = ((IterableGet<K, V>) get).mapIterator();\n            } else {\n                it = new EntrySetToMapIteratorAdapter<>(get.entrySet());\n            }\n            return UnmodifiableMapIterator.unmodifiableMapIterator(it);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "MapIterator<K, V>", "classes": []}, "name": "mapIterator", "params": [], "body": "                                               {\n            final MapIterator<K, V> it;\n            if (get instanceof IterableGet) {\n                it = ((IterableGet<K, V>) get).mapIterator();\n            } else {\n                it = new EntrySetToMapIteratorAdapter<>(get.entrySet());\n            }\n            return UnmodifiableMapIterator.unmodifiableMapIterator(it);\n        }", "signature": "@Override\n        public MapIterator<K, V> mapIterator()"}, {"syntax_pass": true, "original_string": "        @Override\n        public V put(final K key, final V value) {\n            throw new UnsupportedOperationException();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "put", "params": [{"name": "key", "type": "K"}, {"name": "value", "type": "V"}], "body": "                                                 {\n            throw new UnsupportedOperationException();\n        }", "signature": "@Override\n        public V put(final K key, final V value)"}, {"syntax_pass": true, "original_string": "        @Override\n        public void putAll(final Map<? extends K, ? extends V> t) {\n            throw new UnsupportedOperationException();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "putAll", "params": [{"name": "t", "type": "Map<? extends K, ? extends V>"}], "body": "                                                                  {\n            throw new UnsupportedOperationException();\n        }", "signature": "@Override\n        public void putAll(final Map<? extends K, ? extends V> t)"}, {"syntax_pass": true, "original_string": "        @Override\n        public V remove(final Object key) {\n            return get.remove(key);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "remove", "params": [{"name": "key", "type": "Object"}], "body": "                                          {\n            return get.remove(key);\n        }", "signature": "@Override\n        public V remove(final Object key)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int size() {\n            return get.size();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "size", "params": [], "body": "                          {\n            return get.size();\n        }", "signature": "@Override\n        public int size()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Collection<V> values() {\n            return UnmodifiableCollection.unmodifiableCollection(get.values());\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Collection<V>", "classes": []}, "name": "values", "params": [], "body": "                                      {\n            return UnmodifiableCollection.unmodifiableCollection(get.values());\n        }", "signature": "@Override\n        public Collection<V> values()"}]}, {"original_string": "    private static final class WrappedPut<K, V> implements Map<K, V>, Put<K, V> {\n        private final Put<K, V> put;\n\n        private WrappedPut(final Put<K, V> put) {\n            this.put = put;\n        }\n\n        @Override\n        public void clear() {\n            put.clear();\n        }\n\n        @Override\n        public boolean containsKey(final Object key) {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public boolean containsValue(final Object value) {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public Set<Map.Entry<K, V>> entrySet() {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public boolean equals(final Object obj) {\n            if (obj == this) {\n                return true;\n            }\n            return obj instanceof WrappedPut && ((WrappedPut<?, ?>) obj).put.equals(put);\n        }\n\n        @Override\n        public V get(final Object key) {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public int hashCode() {\n            return \"WrappedPut\".hashCode() << 4 | put.hashCode();\n        }\n\n        @Override\n        public boolean isEmpty() {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public Set<K> keySet() {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        @SuppressWarnings(\"unchecked\")\n        public V put(final K key, final V value) {\n            return (V) put.put(key, value);\n        }\n\n        @Override\n        public void putAll(final Map<? extends K, ? extends V> t) {\n            put.putAll(t);\n        }\n\n        @Override\n        public V remove(final Object key) {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public int size() {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public Collection<V> values() {\n            throw new UnsupportedOperationException();\n        }\n    }", "definition": "    private static final class WrappedPut<K, V> implements Map<K, V>, Put<K, V>", "class_docstring": "", "name": "WrappedPut", "super_interfaces": ["Map<K, V>", "Put<K, V>"], "superclasses": "", "attributes": {"modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "fields": [{"attribute_expression": "private final Put<K, V> put;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Put<K, V>", "name": "put", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        private WrappedPut(final Put<K, V> put) {\n            this.put = put;\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "WrappedPut", "params": [{"name": "put", "type": "Put<K, V>"}], "body": "                                                {\n            this.put = put;\n        }", "signature": "private WrappedPut(final Put<K, V> put)"}, {"syntax_pass": true, "original_string": "        @Override\n        public void clear() {\n            put.clear();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "clear", "params": [], "body": "                            {\n            put.clear();\n        }", "signature": "@Override\n        public void clear()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean containsKey(final Object key) {\n            throw new UnsupportedOperationException();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "containsKey", "params": [{"name": "key", "type": "Object"}], "body": "                                                     {\n            throw new UnsupportedOperationException();\n        }", "signature": "@Override\n        public boolean containsKey(final Object key)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean containsValue(final Object value) {\n            throw new UnsupportedOperationException();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "containsValue", "params": [{"name": "value", "type": "Object"}], "body": "                                                         {\n            throw new UnsupportedOperationException();\n        }", "signature": "@Override\n        public boolean containsValue(final Object value)"}, {"syntax_pass": true, "original_string": "        @Override\n        public Set<Map.Entry<K, V>> entrySet() {\n            throw new UnsupportedOperationException();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Set<Map.Entry<K, V>>", "classes": []}, "name": "entrySet", "params": [], "body": "                                               {\n            throw new UnsupportedOperationException();\n        }", "signature": "@Override\n        public Set<Map.Entry<K, V>> entrySet()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean equals(final Object obj) {\n            if (obj == this) {\n                return true;\n            }\n            return obj instanceof WrappedPut && ((WrappedPut<?, ?>) obj).put.equals(put);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "obj", "type": "Object"}], "body": "                                                {\n            if (obj == this) {\n                return true;\n            }\n            return obj instanceof WrappedPut && ((WrappedPut<?, ?>) obj).put.equals(put);\n        }", "signature": "@Override\n        public boolean equals(final Object obj)"}, {"syntax_pass": true, "original_string": "        @Override\n        public V get(final Object key) {\n            throw new UnsupportedOperationException();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "get", "params": [{"name": "key", "type": "Object"}], "body": "                                       {\n            throw new UnsupportedOperationException();\n        }", "signature": "@Override\n        public V get(final Object key)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int hashCode() {\n            return \"WrappedPut\".hashCode() << 4 | put.hashCode();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                              {\n            return \"WrappedPut\".hashCode() << 4 | put.hashCode();\n        }", "signature": "@Override\n        public int hashCode()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isEmpty() {\n            throw new UnsupportedOperationException();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isEmpty", "params": [], "body": "                                 {\n            throw new UnsupportedOperationException();\n        }", "signature": "@Override\n        public boolean isEmpty()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Set<K> keySet() {\n            throw new UnsupportedOperationException();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Set<K>", "classes": []}, "name": "keySet", "params": [], "body": "                               {\n            throw new UnsupportedOperationException();\n        }", "signature": "@Override\n        public Set<K> keySet()"}, {"syntax_pass": true, "original_string": "        @Override\n        @SuppressWarnings(\"unchecked\")\n        public V put(final K key, final V value) {\n            return (V) put.put(key, value);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        @SuppressWarnings(\"unchecked\")\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "V", "classes": []}, "name": "put", "params": [{"name": "key", "type": "K"}, {"name": "value", "type": "V"}], "body": "                                                 {\n            return (V) put.put(key, value);\n        }", "signature": "@Override\n        @SuppressWarnings(\"unchecked\")\n        public V put(final K key, final V value)"}, {"syntax_pass": true, "original_string": "        @Override\n        public void putAll(final Map<? extends K, ? extends V> t) {\n            put.putAll(t);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "putAll", "params": [{"name": "t", "type": "Map<? extends K, ? extends V>"}], "body": "                                                                  {\n            put.putAll(t);\n        }", "signature": "@Override\n        public void putAll(final Map<? extends K, ? extends V> t)"}, {"syntax_pass": true, "original_string": "        @Override\n        public V remove(final Object key) {\n            throw new UnsupportedOperationException();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "remove", "params": [{"name": "key", "type": "Object"}], "body": "                                          {\n            throw new UnsupportedOperationException();\n        }", "signature": "@Override\n        public V remove(final Object key)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int size() {\n            throw new UnsupportedOperationException();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "size", "params": [], "body": "                          {\n            throw new UnsupportedOperationException();\n        }", "signature": "@Override\n        public int size()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Collection<V> values() {\n            throw new UnsupportedOperationException();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Collection<V>", "classes": []}, "name": "values", "params": [], "body": "                                      {\n            throw new UnsupportedOperationException();\n        }", "signature": "@Override\n        public Collection<V> values()"}]}], "class_docstring": "\nUtilities for working with \"split maps:\" objects that implement {@link Put}\nand/or {@link Get} but not {@link Map}.\n\n@since 4.0\n\n@see Get\n@see Put\n", "original_string": "public class SplitMapUtils {\n\n    private static final class WrappedGet<K, V> implements IterableMap<K, V>, Unmodifiable {\n        private final Get<K, V> get;\n\n        private WrappedGet(final Get<K, V> get) {\n            this.get = get;\n        }\n\n        @Override\n        public void clear() {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public boolean containsKey(final Object key) {\n            return get.containsKey(key);\n        }\n\n        @Override\n        public boolean containsValue(final Object value) {\n            return get.containsValue(value);\n        }\n\n        @Override\n        public Set<Map.Entry<K, V>> entrySet() {\n            return UnmodifiableEntrySet.unmodifiableEntrySet(get.entrySet());\n        }\n\n        @Override\n        public boolean equals(final Object arg0) {\n            if (arg0 == this) {\n                return true;\n            }\n            return arg0 instanceof WrappedGet && ((WrappedGet<?, ?>) arg0).get.equals(get);\n        }\n\n        @Override\n        public V get(final Object key) {\n            return get.get(key);\n        }\n\n        @Override\n        public int hashCode() {\n            return \"WrappedGet\".hashCode() << 4 | get.hashCode();\n        }\n\n        @Override\n        public boolean isEmpty() {\n            return get.isEmpty();\n        }\n\n        @Override\n        public Set<K> keySet() {\n            return UnmodifiableSet.unmodifiableSet(get.keySet());\n        }\n\n        @Override\n        public MapIterator<K, V> mapIterator() {\n            final MapIterator<K, V> it;\n            if (get instanceof IterableGet) {\n                it = ((IterableGet<K, V>) get).mapIterator();\n            } else {\n                it = new EntrySetToMapIteratorAdapter<>(get.entrySet());\n            }\n            return UnmodifiableMapIterator.unmodifiableMapIterator(it);\n        }\n\n        @Override\n        public V put(final K key, final V value) {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public void putAll(final Map<? extends K, ? extends V> t) {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public V remove(final Object key) {\n            return get.remove(key);\n        }\n\n        @Override\n        public int size() {\n            return get.size();\n        }\n\n        @Override\n        public Collection<V> values() {\n            return UnmodifiableCollection.unmodifiableCollection(get.values());\n        }\n    }\n\n    private static final class WrappedPut<K, V> implements Map<K, V>, Put<K, V> {\n        private final Put<K, V> put;\n\n        private WrappedPut(final Put<K, V> put) {\n            this.put = put;\n        }\n\n        @Override\n        public void clear() {\n            put.clear();\n        }\n\n        @Override\n        public boolean containsKey(final Object key) {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public boolean containsValue(final Object value) {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public Set<Map.Entry<K, V>> entrySet() {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public boolean equals(final Object obj) {\n            if (obj == this) {\n                return true;\n            }\n            return obj instanceof WrappedPut && ((WrappedPut<?, ?>) obj).put.equals(put);\n        }\n\n        @Override\n        public V get(final Object key) {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public int hashCode() {\n            return \"WrappedPut\".hashCode() << 4 | put.hashCode();\n        }\n\n        @Override\n        public boolean isEmpty() {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public Set<K> keySet() {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        @SuppressWarnings(\"unchecked\")\n        public V put(final K key, final V value) {\n            return (V) put.put(key, value);\n        }\n\n        @Override\n        public void putAll(final Map<? extends K, ? extends V> t) {\n            put.putAll(t);\n        }\n\n        @Override\n        public V remove(final Object key) {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public int size() {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public Collection<V> values() {\n            throw new UnsupportedOperationException();\n        }\n    }\n\n    /**\n     * Gets the specified {@link Get} as an instance of {@link IterableMap}.\n     * If {@code get} implements {@link IterableMap} directly, no conversion will take place.\n     * If {@code get} implements {@link Map} but not {@link IterableMap} it will be decorated.\n     * Otherwise, an {@link Unmodifiable} {@link IterableMap} will be returned.\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param get to wrap, must not be null\n     * @return {@link IterableMap}\n     * @throws NullPointerException if the argument is null\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static <K, V> IterableMap<K, V> readableMap(final Get<K, V> get) {\n        Objects.requireNonNull(get, \"get\");\n        if (get instanceof Map) {\n            return get instanceof IterableMap ?\n                    (IterableMap<K, V>) get :\n                    MapUtils.iterableMap((Map<K, V>) get);\n        }\n        return new WrappedGet<>(get);\n    }\n\n    /**\n     * Gets the specified {@link Put} as an instanceof {@link Map}.\n     * If {@code put} implements {@link Map} directly, no conversion will take place.\n     * Otherwise, a <em>write-only</em> {@link Map} will be returned.  On such a {@link Map}\n     * it is recommended that the result of #put(K, V) be discarded as it likely will not\n     * match {@code V} at runtime.\n     *\n     * @param <K> the key type\n     * @param <V> the element type\n     * @param put to wrap, must not be null\n     * @return {@link Map}\n     * @throws NullPointerException if the argument is null\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static <K, V> Map<K, V> writableMap(final Put<K, V> put) {\n        Objects.requireNonNull(put, \"put\");\n        if (put instanceof Map) {\n            return (Map<K, V>) put;\n        }\n        return new WrappedPut<>(put);\n    }\n\n    /**\n     * Don't allow instances.\n     */\n    private SplitMapUtils() {\n        // empty\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/org/apache/commons/collections4/IterableUtils.java.IterableUtils", "name": "IterableUtils", "file_path": "src/main/java/org/apache/commons/collections4/IterableUtils.java", "superclasses": "", "methods": ["[Iterable<E>]boundedIterable(Iterable<E>,long)", "[Iterable<E>]chainedIterable()", "[Iterable<E>]chainedIterable(Iterable<? extends E>,Iterable<? extends E>)", "[Iterable<E>]chainedIterable(Iterable<? extends E>,Iterable<? extends E>,Iterable<? extends E>)", "[Iterable<E>]chainedIterable(Iterable<? extends E>,Iterable<? extends E>,Iterable<? extends E>,Iterable<? extends E>)", "[void]checkNotNull()", "[Iterable<E>]collatedIterable(Comparator<? super E>,Iterable<? extends E>,Iterable<? extends E>)", "[Iterable<E>]collatedIterable(Iterable<? extends E>,Iterable<? extends E>)", "[boolean]contains(Iterable<? extends E>,E,Equator<? super E>)", "[boolean]contains(Iterable<E>,Object)", "[long]countMatches(Iterable<E>,Predicate<? super E>)", "[List<E>]duplicateList(Iterable<E>)", "[Set<E>]duplicateSequencedSet(Iterable<E>)", "[Set<E>]duplicateSet(Iterable<E>)", "[C]duplicateSet(Iterable<E>,C)", "[Iterable<E>]emptyIfNull(Iterable<E>)", "[Iterable<E>]emptyIterable()", "[Iterator<E>]emptyIteratorIfNull(Iterable<E>)", "[Iterable<E>]filteredIterable(Iterable<E>,Predicate<? super E>)", "[E]find(Iterable<E>,Predicate<? super E>)", "[T]first(Iterable<T>)", "[void]forEach(Iterable<E>,Closure<? super E>)", "[E]forEachButLast(Iterable<E>,Closure<? super E>)", "[int]frequency(Iterable<E>,T)", "[T]get(Iterable<T>,int)", "[int]indexOf(Iterable<E>,Predicate<? super E>)", "[boolean]isEmpty(Iterable<?>)", "[Iterable<E>]loopingIterable(Iterable<E>)", "[boolean]matchesAll(Iterable<E>,Predicate<? super E>)", "[boolean]matchesAny(Iterable<E>,Predicate<? super E>)", "[List<R>]partition(Iterable<? extends O>,Factory<R>)", "[List<List<O>>]partition(Iterable<? extends O>,Predicate<? super O>)", "[List<List<O>>]partition(Iterable<? extends O>)", "[Iterable<E>]reversedIterable(Iterable<E>)", "[int]size(Iterable<?>)", "[Iterable<E>]skippingIterable(Iterable<E>,long)", "[List<E>]toList(Iterable<E>)", "[String]toString(Iterable<E>)", "[String]toString(Iterable<E>,Transformer<? super E, String>)", "[String]toString(Iterable<E>,Transformer<? super E, String>,String,String,String)", "[Iterable<O>]transformedIterable(Iterable<I>,Transformer<? super I, ? extends O>)", "[Iterable<E>]uniqueIterable(Iterable<E>)", "[Iterable<E>]unmodifiableIterable(Iterable<E>)", "[Iterable<E>]zippingIterable(Iterable<? extends E>,Iterable<? extends E>)", "[Iterable<E>]zippingIterable(Iterable<? extends E>)", "[]IterableUtils()"], "method_uris": ["src/main/java/org/apache/commons/collections4/IterableUtils.java.IterableUtils.[Iterable<E>]boundedIterable(Iterable<E>,long)", "src/main/java/org/apache/commons/collections4/IterableUtils.java.IterableUtils.[Iterable<E>]chainedIterable()", "src/main/java/org/apache/commons/collections4/IterableUtils.java.IterableUtils.[Iterable<E>]chainedIterable(Iterable<? extends E>,Iterable<? extends E>)", "src/main/java/org/apache/commons/collections4/IterableUtils.java.IterableUtils.[Iterable<E>]chainedIterable(Iterable<? extends E>,Iterable<? extends E>,Iterable<? extends E>)", "src/main/java/org/apache/commons/collections4/IterableUtils.java.IterableUtils.[Iterable<E>]chainedIterable(Iterable<? extends E>,Iterable<? extends E>,Iterable<? extends E>,Iterable<? extends E>)", "src/main/java/org/apache/commons/collections4/IterableUtils.java.IterableUtils.[void]checkNotNull()", "src/main/java/org/apache/commons/collections4/IterableUtils.java.IterableUtils.[Iterable<E>]collatedIterable(Comparator<? super E>,Iterable<? extends E>,Iterable<? extends E>)", "src/main/java/org/apache/commons/collections4/IterableUtils.java.IterableUtils.[Iterable<E>]collatedIterable(Iterable<? extends E>,Iterable<? extends E>)", "src/main/java/org/apache/commons/collections4/IterableUtils.java.IterableUtils.[boolean]contains(Iterable<? extends E>,E,Equator<? super E>)", "src/main/java/org/apache/commons/collections4/IterableUtils.java.IterableUtils.[boolean]contains(Iterable<E>,Object)", "src/main/java/org/apache/commons/collections4/IterableUtils.java.IterableUtils.[long]countMatches(Iterable<E>,Predicate<? super E>)", "src/main/java/org/apache/commons/collections4/IterableUtils.java.IterableUtils.[List<E>]duplicateList(Iterable<E>)", "src/main/java/org/apache/commons/collections4/IterableUtils.java.IterableUtils.[Set<E>]duplicateSequencedSet(Iterable<E>)", "src/main/java/org/apache/commons/collections4/IterableUtils.java.IterableUtils.[Set<E>]duplicateSet(Iterable<E>)", "src/main/java/org/apache/commons/collections4/IterableUtils.java.IterableUtils.[C]duplicateSet(Iterable<E>,C)", "src/main/java/org/apache/commons/collections4/IterableUtils.java.IterableUtils.[Iterable<E>]emptyIfNull(Iterable<E>)", "src/main/java/org/apache/commons/collections4/IterableUtils.java.IterableUtils.[Iterable<E>]emptyIterable()", "src/main/java/org/apache/commons/collections4/IterableUtils.java.IterableUtils.[Iterator<E>]emptyIteratorIfNull(Iterable<E>)", "src/main/java/org/apache/commons/collections4/IterableUtils.java.IterableUtils.[Iterable<E>]filteredIterable(Iterable<E>,Predicate<? super E>)", "src/main/java/org/apache/commons/collections4/IterableUtils.java.IterableUtils.[E]find(Iterable<E>,Predicate<? super E>)", "src/main/java/org/apache/commons/collections4/IterableUtils.java.IterableUtils.[T]first(Iterable<T>)", "src/main/java/org/apache/commons/collections4/IterableUtils.java.IterableUtils.[void]forEach(Iterable<E>,Closure<? super E>)", "src/main/java/org/apache/commons/collections4/IterableUtils.java.IterableUtils.[E]forEachButLast(Iterable<E>,Closure<? super E>)", "src/main/java/org/apache/commons/collections4/IterableUtils.java.IterableUtils.[int]frequency(Iterable<E>,T)", "src/main/java/org/apache/commons/collections4/IterableUtils.java.IterableUtils.[T]get(Iterable<T>,int)", "src/main/java/org/apache/commons/collections4/IterableUtils.java.IterableUtils.[int]indexOf(Iterable<E>,Predicate<? super E>)", "src/main/java/org/apache/commons/collections4/IterableUtils.java.IterableUtils.[boolean]isEmpty(Iterable<?>)", "src/main/java/org/apache/commons/collections4/IterableUtils.java.IterableUtils.[Iterable<E>]loopingIterable(Iterable<E>)", "src/main/java/org/apache/commons/collections4/IterableUtils.java.IterableUtils.[boolean]matchesAll(Iterable<E>,Predicate<? super E>)", "src/main/java/org/apache/commons/collections4/IterableUtils.java.IterableUtils.[boolean]matchesAny(Iterable<E>,Predicate<? super E>)", "src/main/java/org/apache/commons/collections4/IterableUtils.java.IterableUtils.[List<R>]partition(Iterable<? extends O>,Factory<R>)", "src/main/java/org/apache/commons/collections4/IterableUtils.java.IterableUtils.[List<List<O>>]partition(Iterable<? extends O>,Predicate<? super O>)", "src/main/java/org/apache/commons/collections4/IterableUtils.java.IterableUtils.[List<List<O>>]partition(Iterable<? extends O>)", "src/main/java/org/apache/commons/collections4/IterableUtils.java.IterableUtils.[Iterable<E>]reversedIterable(Iterable<E>)", "src/main/java/org/apache/commons/collections4/IterableUtils.java.IterableUtils.[int]size(Iterable<?>)", "src/main/java/org/apache/commons/collections4/IterableUtils.java.IterableUtils.[Iterable<E>]skippingIterable(Iterable<E>,long)", "src/main/java/org/apache/commons/collections4/IterableUtils.java.IterableUtils.[List<E>]toList(Iterable<E>)", "src/main/java/org/apache/commons/collections4/IterableUtils.java.IterableUtils.[String]toString(Iterable<E>)", "src/main/java/org/apache/commons/collections4/IterableUtils.java.IterableUtils.[String]toString(Iterable<E>,Transformer<? super E, String>)", "src/main/java/org/apache/commons/collections4/IterableUtils.java.IterableUtils.[String]toString(Iterable<E>,Transformer<? super E, String>,String,String,String)", "src/main/java/org/apache/commons/collections4/IterableUtils.java.IterableUtils.[Iterable<O>]transformedIterable(Iterable<I>,Transformer<? super I, ? extends O>)", "src/main/java/org/apache/commons/collections4/IterableUtils.java.IterableUtils.[Iterable<E>]uniqueIterable(Iterable<E>)", "src/main/java/org/apache/commons/collections4/IterableUtils.java.IterableUtils.[Iterable<E>]unmodifiableIterable(Iterable<E>)", "src/main/java/org/apache/commons/collections4/IterableUtils.java.IterableUtils.[Iterable<E>]zippingIterable(Iterable<? extends E>,Iterable<? extends E>)", "src/main/java/org/apache/commons/collections4/IterableUtils.java.IterableUtils.[Iterable<E>]zippingIterable(Iterable<? extends E>)", "src/main/java/org/apache/commons/collections4/IterableUtils.java.IterableUtils.[]IterableUtils()"], "overrides": null, "attributes": [{"original_string": "    private static final class UnmodifiableIterable<E> extends FluentIterable<E> {\n        private final Iterable<E> iterable;\n\n        UnmodifiableIterable(final Iterable<E> iterable) {\n            this.iterable = iterable;\n        }\n\n        @Override\n        public Iterator<E> iterator() {\n            return IteratorUtils.unmodifiableIterator(iterable.iterator());\n        }\n    }", "definition": "    private static final class UnmodifiableIterable<E> extends FluentIterable<E>", "class_docstring": "\nInner class to distinguish unmodifiable instances.\n", "name": "UnmodifiableIterable", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "fields": [{"attribute_expression": "private final Iterable<E> iterable;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Iterable<E>", "name": "iterable", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        UnmodifiableIterable(final Iterable<E> iterable) {\n            this.iterable = iterable;\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "UnmodifiableIterable", "params": [{"name": "iterable", "type": "Iterable<E>"}], "body": "                                                         {\n            this.iterable = iterable;\n        }", "signature": "UnmodifiableIterable(final Iterable<E> iterable)"}, {"syntax_pass": true, "original_string": "        @Override\n        public Iterator<E> iterator() {\n            return IteratorUtils.unmodifiableIterator(iterable.iterator());\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Iterator<E>", "classes": []}, "name": "iterator", "params": [], "body": "                                      {\n            return IteratorUtils.unmodifiableIterator(iterable.iterator());\n        }", "signature": "@Override\n        public Iterator<E> iterator()"}]}], "class_docstring": "\nProvides utility methods and decorators for {@link Iterable} instances.\n<p>\n<b>Note</b>: this util class has been designed for fail-fast argument checking.\n</p>\n<ul>\n<li>\nall decorator methods are <b>NOT</b> null-safe wrt the provided Iterable argument, i.e.\nthey will throw a {@link NullPointerException} if a null Iterable is passed as argument.\n<li>\nall other utility methods are null-safe wrt the provided Iterable argument, i.e. they will\ntreat a null Iterable the same way as an empty one. Other arguments which are null,\ne.g. a {@link Predicate}, will result in a {@link NullPointerException}. Exception: passing\na null {@link Comparator} is equivalent to a Comparator with natural ordering.\n</ul>\n\n@since 4.1\n", "original_string": "public class IterableUtils {\n\n    /**\n     * Inner class to distinguish unmodifiable instances.\n     */\n    private static final class UnmodifiableIterable<E> extends FluentIterable<E> {\n        private final Iterable<E> iterable;\n\n        UnmodifiableIterable(final Iterable<E> iterable) {\n            this.iterable = iterable;\n        }\n\n        @Override\n        public Iterator<E> iterator() {\n            return IteratorUtils.unmodifiableIterator(iterable.iterator());\n        }\n    }\n\n    /**\n     * An empty iterable.\n     */\n    @SuppressWarnings(\"rawtypes\")\n    static final FluentIterable EMPTY_ITERABLE = new FluentIterable<Object>() {\n        @Override\n        public Iterator<Object> iterator() {\n            return IteratorUtils.emptyIterator();\n        }\n    };\n\n    /**\n     * Returns a view of the given iterable that contains at most the given number\n     * of elements.\n     * <p>\n     * The returned iterable's iterator supports {@code remove()} when the corresponding\n     * input iterator supports it.\n     * </p>\n     *\n     * @param <E> the element type\n     * @param iterable  the iterable to limit, may not be null\n     * @param maxSize  the maximum number of elements, must not be negative\n     * @return a bounded view on the specified iterable\n     * @throws IllegalArgumentException if maxSize is negative\n     * @throws NullPointerException if iterable is null\n     */\n    public static <E> Iterable<E> boundedIterable(final Iterable<E> iterable, final long maxSize) {\n        Objects.requireNonNull(iterable, \"iterable\");\n        if (maxSize < 0) {\n            throw new IllegalArgumentException(\"MaxSize parameter must not be negative.\");\n        }\n\n        return new FluentIterable<E>() {\n            @Override\n            public Iterator<E> iterator() {\n                return IteratorUtils.boundedIterator(iterable.iterator(), maxSize);\n            }\n        };\n    }\n\n    /**\n     * Combines the provided iterables into a single iterable.\n     * <p>\n     * The returned iterable has an iterator that traverses the elements in the order\n     * of the arguments, i.e. iterables[0], iterables[1], .... The source iterators\n     * are not polled until necessary.\n     * </p>\n     * <p>\n     * The returned iterable's iterator supports {@code remove()} when the corresponding\n     * input iterator supports it.\n     * </p>\n     *\n     * @param <E> the element type\n     * @param iterables  the iterables to combine, may not be null\n     * @return a new iterable, combining the provided iterables\n     * @throws NullPointerException if either of the provided iterables is null\n     */\n    public static <E> Iterable<E> chainedIterable(final Iterable<? extends E>... iterables) {\n        checkNotNull(iterables);\n        return new FluentIterable<E>() {\n            @Override\n            public Iterator<E> iterator() {\n                return new LazyIteratorChain<E>() {\n                    @Override\n                    protected Iterator<? extends E> nextIterator(final int count) {\n                        if (count > iterables.length) {\n                            return null;\n                        }\n                        return iterables[count - 1].iterator();\n                    }\n                };\n            }\n        };\n    }\n\n    /**\n     * Combines two iterables into a single iterable.\n     * <p>\n     * The returned iterable has an iterator that traverses the elements in {@code a},\n     * followed by the elements in {@code b}. The source iterators are not polled until\n     * necessary.\n     * </p>\n     * <p>\n     * The returned iterable's iterator supports {@code remove()} when the corresponding\n     * input iterator supports it.\n     * </p>\n     *\n     * @param <E> the element type\n     * @param a  the first iterable, may not be null\n     * @param b  the second iterable, may not be null\n     * @return a new iterable, combining the provided iterables\n     * @throws NullPointerException if either a or b is null\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static <E> Iterable<E> chainedIterable(final Iterable<? extends E> a,\n                                                  final Iterable<? extends E> b) {\n        return chainedIterable(new Iterable[] {a, b});\n    }\n\n    /**\n     * Combines three iterables into a single iterable.\n     * <p>\n     * The returned iterable has an iterator that traverses the elements in {@code a},\n     * followed by the elements in {@code b} and {@code c}. The source iterators are\n     * not polled until necessary.\n     * </p>\n     * <p>\n     * The returned iterable's iterator supports {@code remove()} when the corresponding\n     * input iterator supports it.\n     * </p>\n     *\n     * @param <E> the element type\n     * @param a  the first iterable, may not be null\n     * @param b  the second iterable, may not be null\n     * @param c  the third iterable, may not be null\n     * @return a new iterable, combining the provided iterables\n     * @throws NullPointerException if either of the provided iterables is null\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static <E> Iterable<E> chainedIterable(final Iterable<? extends E> a,\n                                                  final Iterable<? extends E> b,\n                                                  final Iterable<? extends E> c) {\n        return chainedIterable(new Iterable[] {a, b, c});\n    }\n\n    /**\n     * Combines four iterables into a single iterable.\n     * <p>\n     * The returned iterable has an iterator that traverses the elements in {@code a},\n     * followed by the elements in {@code b}, {@code c} and {@code d}. The source\n     * iterators are not polled until necessary.\n     * </p>\n     * <p>\n     * The returned iterable's iterator supports {@code remove()} when the corresponding\n     * input iterator supports it.\n     * </p>\n     *\n     * @param <E> the element type\n     * @param a  the first iterable, may not be null\n     * @param b  the second iterable, may not be null\n     * @param c  the third iterable, may not be null\n     * @param d  the fourth iterable, may not be null\n     * @return a new iterable, combining the provided iterables\n     * @throws NullPointerException if either of the provided iterables is null\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static <E> Iterable<E> chainedIterable(final Iterable<? extends E> a,\n                                                  final Iterable<? extends E> b,\n                                                  final Iterable<? extends E> c,\n                                                  final Iterable<? extends E> d) {\n        return chainedIterable(new Iterable[] {a, b, c, d});\n    }\n\n    /**\n     * Fail-fast check for null arguments.\n     *\n     * @param iterables  the iterables to check\n     * @throws NullPointerException if the argument or any of its contents is null\n     */\n    static void checkNotNull(final Iterable<?>... iterables) {\n        Objects.requireNonNull(iterables, \"iterables\");\n        for (final Iterable<?> iterable : iterables) {\n            Objects.requireNonNull(iterable, \"iterable\");\n        }\n    }\n\n    /**\n     * Combines the two provided iterables into an ordered iterable using the\n     * provided comparator. If the comparator is null, natural ordering will be\n     * used.\n     * <p>\n     * The returned iterable's iterator supports {@code remove()} when the\n     * corresponding input iterator supports it.\n     * </p>\n     *\n     * @param <E> the element type\n     * @param comparator  the comparator defining an ordering over the elements,\n     *   may be null, in which case natural ordering will be used\n     * @param a  the first iterable, may not be null\n     * @param b  the second iterable, may not be null\n     * @return a filtered view on the specified iterable\n     * @throws NullPointerException if either of the provided iterables is null\n     */\n    public static <E> Iterable<E> collatedIterable(final Comparator<? super E> comparator,\n                                                   final Iterable<? extends E> a,\n                                                   final Iterable<? extends E> b) {\n        checkNotNull(a, b);\n        return new FluentIterable<E>() {\n            @Override\n            public Iterator<E> iterator() {\n                return IteratorUtils.collatedIterator(comparator, a.iterator(), b.iterator());\n            }\n        };\n    }\n\n    /**\n     * Combines the two provided iterables into an ordered iterable using\n     * natural ordering.\n     * <p>\n     * The returned iterable's iterator supports {@code remove()} when the\n     * corresponding input iterator supports it.\n     * </p>\n     *\n     * @param <E> the element type\n     * @param a  the first iterable, must not be null\n     * @param b  the second iterable, must not be null\n     * @return a filtered view on the specified iterable\n     * @throws NullPointerException if either of the provided iterables is null\n     */\n    public static <E> Iterable<E> collatedIterable(final Iterable<? extends E> a,\n                                                   final Iterable<? extends E> b) {\n        checkNotNull(a, b);\n        return new FluentIterable<E>() {\n            @Override\n            public Iterator<E> iterator() {\n                return IteratorUtils.collatedIterator(null, a.iterator(), b.iterator());\n            }\n        };\n    }\n\n    /**\n     * Checks if the object is contained in the given iterable. Object equality\n     * is tested with an {@code equator} unlike {@link #contains(Iterable, Object)}\n     * which uses {@link Object#equals(Object)}.\n     * <p>\n     * A {@code null} or empty iterable returns false.\n     * A {@code null} object will not be passed to the equator, instead a\n     * {@link org.apache.commons.collections4.functors.NullPredicate NullPredicate}\n     * will be used.\n     * </p>\n     *\n     * @param <E> the type of object the {@link Iterable} contains\n     * @param iterable  the iterable to check, may be null\n     * @param object  the object to check\n     * @param equator  the equator to use to check, may not be null\n     * @return true if the object is contained in the iterable, false otherwise\n     * @throws NullPointerException if equator is null\n     */\n    public static <E> boolean contains(final Iterable<? extends E> iterable, final E object,\n                                       final Equator<? super E> equator) {\n        Objects.requireNonNull(equator, \"equator\");\n        return matchesAny(iterable, EqualPredicate.equalPredicate(object, equator));\n    }\n\n    /**\n     * Checks if the object is contained in the given iterable.\n     * <p>\n     * A {@code null} or empty iterable returns false.\n     * </p>\n     *\n     * @param <E> the type of object the {@link Iterable} contains\n     * @param iterable  the iterable to check, may be null\n     * @param object  the object to check\n     * @return true if the object is contained in the iterable, false otherwise\n     */\n    public static <E> boolean contains(final Iterable<E> iterable, final Object object) {\n        if (iterable instanceof Collection<?>) {\n            return ((Collection<E>) iterable).contains(object);\n        }\n        return IteratorUtils.contains(emptyIteratorIfNull(iterable), object);\n    }\n\n    /**\n     * Counts the number of elements in the input iterable that match the predicate.\n     * <p>\n     * A {@code null} iterable matches no elements.\n     * </p>\n     *\n     * @param <E> the type of object the {@link Iterable} contains\n     * @param input  the {@link Iterable} to get the input from, may be null\n     * @param predicate  the predicate to use, may not be null\n     * @return the number of matches for the predicate in the collection\n     * @throws NullPointerException if predicate is null\n     */\n    public static <E> long countMatches(final Iterable<E> input, final Predicate<? super E> predicate) {\n        Objects.requireNonNull(predicate, \"predicate\");\n        return size(filteredIterable(emptyIfNull(input), predicate));\n    }\n\n    /**\n     * Finds and returns the List of duplicate elements in the given collection.\n     *\n     * @param <E> the type of elements in the collection.\n     * @param iterable the list to test, must not be null.\n     * @return the set of duplicate elements, may be empty.\n     * @since 4.5.0-M3\n     */\n    public static <E> List<E> duplicateList(final Iterable<E> iterable) {\n        return new ArrayList<>(duplicateSequencedSet(iterable));\n    }\n\n    /**\n     * Finds and returns the sequenced Set of duplicate elements in the given collection.\n     * <p>\n     * Once we are on Java 21 and a new major version, the return type should be SequencedSet.\n     * </p>\n     *\n     * @param <E> the type of elements in the collection.\n     * @param iterable the list to test, must not be null.\n     * @return the set of duplicate elements, may be empty.\n     * @since 4.5.0-M3\n     */\n    public static <E> Set<E> duplicateSequencedSet(final Iterable<E> iterable) {\n        return duplicateSet(iterable, new LinkedHashSet<>());\n    }\n\n    /**\n     * Finds and returns the set of duplicate elements in the given collection.\n     *\n     * @param <E> the type of elements in the collection.\n     * @param iterable the list to test, must not be null.\n     * @return the set of duplicate elements, may be empty.\n     * @since 4.5.0-M3\n     */\n    public static <E> Set<E> duplicateSet(final Iterable<E> iterable) {\n        return duplicateSet(iterable, new HashSet<>());\n    }\n\n    /**\n     * Worker method for {@link #duplicateSet(Collection)} and friends.\n     *\n     * @param <C> the type of Collection.\n     * @param <E> the type of elements in the Collection.\n     * @param iterable the list to test, must not be null.\n     * @param duplicates the list to test, must not be null.\n     * @return the set of duplicate elements, may be empty.\n     */\n    static <C extends Collection<E>, E> C duplicateSet(final Iterable<E> iterable, final C duplicates) {\n        final Set<E> set = new HashSet<>();\n        for (final E e : iterable) {\n            (set.contains(e) ? duplicates : set).add(e);\n        }\n        return duplicates;\n    }\n\n    /**\n     * Returns an immutable empty iterable if the argument is null,\n     * or the argument itself otherwise.\n     *\n     * @param <E> the element type\n     * @param iterable  the iterable, may be null\n     * @return an empty iterable if the argument is null\n     */\n    public static <E> Iterable<E> emptyIfNull(final Iterable<E> iterable) {\n        return iterable == null ? IterableUtils.<E>emptyIterable() : iterable;\n    }\n\n    /**\n     * Gets an empty iterable.\n     * <p>\n     * This iterable does not contain any elements.\n     * </p>\n     *\n     * @param <E> the element type\n     * @return an empty iterable\n     */\n    @SuppressWarnings(\"unchecked\") // OK, empty collection is compatible with any type\n    public static <E> Iterable<E> emptyIterable() {\n        return EMPTY_ITERABLE;\n    }\n\n    /**\n     * Returns an empty iterator if the argument is {@code null},\n     * or {@code iterable.iterator()} otherwise.\n     *\n     * @param <E> the element type\n     * @param iterable  the iterable, possibly {@code null}\n     * @return an empty iterator if the argument is {@code null}\n     */\n    private static <E> Iterator<E> emptyIteratorIfNull(final Iterable<E> iterable) {\n        return iterable != null ? iterable.iterator() : IteratorUtils.<E>emptyIterator();\n    }\n\n    /**\n     * Returns a view of the given iterable that only contains elements matching\n     * the provided predicate.\n     * <p>\n     * The returned iterable's iterator supports {@code remove()} when the\n     * corresponding input iterator supports it.\n     * </p>\n     *\n     * @param <E> the element type\n     * @param iterable  the iterable to filter, may not be null\n     * @param predicate  the predicate used to filter elements, may not be null\n     * @return a filtered view on the specified iterable\n     * @throws NullPointerException if either iterable or predicate is null\n     */\n    public static <E> Iterable<E> filteredIterable(final Iterable<E> iterable,\n                                                   final Predicate<? super E> predicate) {\n        Objects.requireNonNull(iterable, \"iterable\");\n        Objects.requireNonNull(predicate, \"predicate\");\n        return new FluentIterable<E>() {\n            @Override\n            public Iterator<E> iterator() {\n                return IteratorUtils.filteredIterator(emptyIteratorIfNull(iterable), predicate);\n            }\n        };\n    }\n\n    /**\n     * Finds the first element in the given iterable which matches the given predicate.\n     * <p>\n     * A {@code null} or empty iterator returns null.\n     * </p>\n     *\n     * @param <E> the element type\n     * @param iterable  the iterable to search, may be null\n     * @param predicate  the predicate to use, must not be null\n     * @return the first element of the iterable which matches the predicate or null if none could be found\n     * @throws NullPointerException if predicate is null\n     */\n    public static <E> E find(final Iterable<E> iterable, final Predicate<? super E> predicate) {\n        return IteratorUtils.find(emptyIteratorIfNull(iterable), predicate);\n    }\n\n    /**\n     * Shortcut for {@code get(iterator, 0)}.\n     * <p>\n     * Returns the {@code first} value in the {@code iterable}'s {@link Iterator}, throwing\n     * {@code IndexOutOfBoundsException} if there is no such element.\n     * </p>\n     * <p>\n     * If the {@link Iterable} is a {@link List}, then it will use {@link List#get(int)}.\n     * </p>\n     *\n     * @param <T> the type of object in the {@link Iterable}.\n     * @param iterable  the {@link Iterable} to get a value from, may be null\n     * @return the first object\n     * @throws IndexOutOfBoundsException if the request  is invalid\n     * @since 4.2\n     */\n    public static <T> T first(final Iterable<T> iterable) {\n        return get(iterable, 0);\n    }\n\n    /**\n     * Applies the closure to each element of the provided iterable.\n     *\n     * @param <E> the element type\n     * @param iterable  the iterator to use, may be null\n     * @param closure  the closure to apply to each element, may not be null\n     * @throws NullPointerException if closure is null\n     */\n    public static <E> void forEach(final Iterable<E> iterable, final Closure<? super E> closure) {\n        IteratorUtils.forEach(emptyIteratorIfNull(iterable), closure);\n    }\n\n    /**\n     * Executes the given closure on each but the last element in the iterable.\n     * <p>\n     * If the input iterable is null no change is made.\n     * </p>\n     *\n     * @param <E> the type of object the {@link Iterable} contains\n     * @param iterable  the iterable to get the input from, may be null\n     * @param closure  the closure to perform, may not be null\n     * @return the last element in the iterable, or null if iterable is null or empty\n     */\n    public static <E> E forEachButLast(final Iterable<E> iterable, final Closure<? super E> closure) {\n        return IteratorUtils.forEachButLast(emptyIteratorIfNull(iterable), closure);\n    }\n\n    /**\n     * Returns the number of occurrences of the provided object in the iterable.\n     *\n     * @param <E> the element type that the {@link Iterable} may contain\n     * @param <T> the element type of the object to find\n     * @param iterable  the {@link Iterable} to search\n     * @param obj  the object to find the cardinality of\n     * @return the number of occurrences of obj in iterable\n     */\n    public static <E, T extends E> int frequency(final Iterable<E> iterable, final T obj) {\n        if (iterable instanceof Set<?>) {\n            return ((Set<E>) iterable).contains(obj) ? 1 : 0;\n        }\n        if (iterable instanceof Bag<?>) {\n            return ((Bag<E>) iterable).getCount(obj);\n        }\n        return size(filteredIterable(emptyIfNull(iterable), EqualPredicate.<E>equalPredicate(obj)));\n    }\n\n    /**\n     * Returns the {@code index}-th value in the {@code iterable}'s {@link Iterator}, throwing\n     * {@code IndexOutOfBoundsException} if there is no such element.\n     * <p>\n     * If the {@link Iterable} is a {@link List}, then it will use {@link List#get(int)}.\n     * </p>\n     *\n     * @param <T> the type of object in the {@link Iterable}.\n     * @param iterable  the {@link Iterable} to get a value from, may be null\n     * @param index  the index to get\n     * @return the object at the specified index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public static <T> T get(final Iterable<T> iterable, final int index) {\n        CollectionUtils.checkIndexBounds(index);\n        if (iterable instanceof List<?>) {\n            return ((List<T>) iterable).get(index);\n        }\n        return IteratorUtils.get(emptyIteratorIfNull(iterable), index);\n    }\n\n    /**\n     * Returns the index of the first element in the specified iterable that\n     * matches the given predicate.\n     * <p>\n     * A {@code null} or empty iterable returns -1.\n     * </p>\n     *\n     * @param <E> the element type\n     * @param iterable  the iterable to search, may be null\n     * @param predicate  the predicate to use, must not be null\n     * @return the index of the first element which matches the predicate or -1 if none matches\n     * @throws NullPointerException if predicate is null\n     */\n    public static <E> int indexOf(final Iterable<E> iterable, final Predicate<? super E> predicate) {\n        return IteratorUtils.indexOf(emptyIteratorIfNull(iterable), predicate);\n    }\n\n    /**\n     * Answers true if the provided iterable is empty.\n     * <p>\n     * A {@code null} iterable returns true.\n     * </p>\n     *\n     * @param iterable  the {@link Iterable to use}, may be null\n     * @return true if the iterable is null or empty, false otherwise\n     */\n    public static boolean isEmpty(final Iterable<?> iterable) {\n        if (iterable instanceof Collection<?>) {\n            return ((Collection<?>) iterable).isEmpty();\n        }\n        return IteratorUtils.isEmpty(emptyIteratorIfNull(iterable));\n    }\n\n    /**\n     * Returns a view of the given iterable which will cycle infinitely over\n     * its elements.\n     * <p>\n     * The returned iterable's iterator supports {@code remove()} if\n     * {@code iterable.iterator()} does. After {@code remove()} is called, subsequent\n     * cycles omit the removed element, which is no longer in {@code iterable}. The\n     * iterator's {@code hasNext()} method returns {@code true} until {@code iterable}\n     * is empty.\n     * </p>\n     *\n     * @param <E> the element type\n     * @param iterable  the iterable to loop, may not be null\n     * @return a view of the iterable, providing an infinite loop over its elements\n     * @throws NullPointerException if iterable is null\n     */\n    public static <E> Iterable<E> loopingIterable(final Iterable<E> iterable) {\n        Objects.requireNonNull(iterable, \"iterable\");\n        return new FluentIterable<E>() {\n            @Override\n            public Iterator<E> iterator() {\n                return new LazyIteratorChain<E>() {\n                    @Override\n                    protected Iterator<? extends E> nextIterator(final int count) {\n                        if (IterableUtils.isEmpty(iterable)) {\n                            return null;\n                        }\n                        return iterable.iterator();\n                    }\n                };\n            }\n        };\n    }\n\n    /**\n     * Answers true if a predicate is true for every element of an iterable.\n     * <p>\n     * A {@code null} or empty iterable returns true.\n     * </p>\n     *\n     * @param <E> the type of object the {@link Iterable} contains\n     * @param iterable  the {@link Iterable} to use, may be null\n     * @param predicate  the predicate to use, may not be null\n     * @return true if every element of the collection matches the predicate or if the\n     *   collection is empty, false otherwise\n     * @throws NullPointerException if predicate is null\n     */\n    public static <E> boolean matchesAll(final Iterable<E> iterable, final Predicate<? super E> predicate) {\n        return IteratorUtils.matchesAll(emptyIteratorIfNull(iterable), predicate);\n    }\n\n    /**\n     * Answers true if a predicate is true for any element of the iterable.\n     * <p>\n     * A {@code null} or empty iterable returns false.\n     * </p>\n     *\n     * @param <E> the type of object the {@link Iterable} contains\n     * @param iterable  the {@link Iterable} to use, may be null\n     * @param predicate  the predicate to use, may not be null\n     * @return true if any element of the collection matches the predicate, false otherwise\n     * @throws NullPointerException if predicate is null\n     */\n    public static <E> boolean matchesAny(final Iterable<E> iterable, final Predicate<? super E> predicate) {\n        return IteratorUtils.matchesAny(emptyIteratorIfNull(iterable), predicate);\n    }\n\n    /**\n     * Partitions all elements from iterable into separate output collections,\n     * based on the evaluation of the given predicates.\n     * <p>\n     * For each predicate, the returned list will contain a collection holding\n     * all elements of the input iterable matching the predicate. The last collection\n     * contained in the list will hold all elements which didn't match any predicate:\n     * </p>\n     * <pre>\n     *  [C1, C2, R] = partition(I, P1, P2) with\n     *  I = input\n     *  P1 = first predicate\n     *  P2 = second predicate\n     *  C1 = collection of elements matching P1\n     *  C2 = collection of elements matching P2\n     *  R = collection of elements rejected by all predicates\n     * </pre>\n     * <p>\n     * <b>Note</b>: elements are only added to the output collection of the first matching\n     * predicate, determined by the order of arguments.\n     * </p>\n     * <p>\n     * If the input iterable is {@code null}, the same is returned as for an\n     * empty iterable.\n     * If no predicates have been provided, all elements of the input collection\n     * will be added to the rejected collection.\n     * </p>\n     * <p>\n     * Example: for an input list [1, 2, 3, 4, 5] calling partition with predicates [x &lt; 3]\n     * and [x &lt; 5] will result in the following output: [[1, 2], [3, 4], [5]].\n     * </p>\n     *\n     * @param <O>  the type of object the {@link Iterable} contains\n     * @param <R>  the type of the output {@link Collection}\n     * @param iterable  the collection to get the input from, may be null\n     * @param partitionFactory  the factory used to create the output collections\n     * @param predicates  the predicates to use, may not be null\n     * @return a list containing the output collections\n     * @throws NullPointerException if any predicate is null\n     */\n    public static <O, R extends Collection<O>> List<R> partition(final Iterable<? extends O> iterable,\n            final Factory<R> partitionFactory, final Predicate<? super O>... predicates) {\n\n        if (iterable == null) {\n            final Iterable<O> empty = emptyIterable();\n            return partition(empty, partitionFactory, predicates);\n        }\n\n        Objects.requireNonNull(predicates, \"predicates\");\n\n        for (final Predicate<?> predicate : predicates) {\n            Objects.requireNonNull(predicate, \"predicate\");\n        }\n\n        if (predicates.length < 1) {\n            // return the entire input collection as a single partition\n            final R singlePartition = partitionFactory.get();\n            CollectionUtils.addAll(singlePartition, iterable);\n            return Collections.singletonList(singlePartition);\n        }\n\n        // create the empty partitions\n        final int numberOfPredicates = predicates.length;\n        final int numberOfPartitions = numberOfPredicates + 1;\n        final List<R> partitions = new ArrayList<>(numberOfPartitions);\n        for (int i = 0; i < numberOfPartitions; ++i) {\n            partitions.add(partitionFactory.get());\n        }\n\n        // for each element in inputCollection:\n        // find the first predicate that evaluates to true.\n        // if there is a predicate, add the element to the corresponding partition.\n        // if there is no predicate, add it to the last, catch-all partition.\n        for (final O element : iterable) {\n            boolean elementAssigned = false;\n            for (int i = 0; i < numberOfPredicates; ++i) {\n                if (predicates[i].test(element)) {\n                    partitions.get(i).add(element);\n                    elementAssigned = true;\n                    break;\n                }\n            }\n\n            if (!elementAssigned) {\n                // no predicates evaluated to true\n                // add element to last partition\n                partitions.get(numberOfPredicates).add(element);\n            }\n        }\n\n        return partitions;\n    }\n\n    /**\n     * Partitions all elements from iterable into separate output collections,\n     * based on the evaluation of the given predicate.\n     * <p>\n     * For each predicate, the result will contain a list holding all elements of the\n     * input iterable matching the predicate. The last list will hold all elements\n     * which didn't match any predicate:\n     * </p>\n     * <pre>\n     *  [C1, R] = partition(I, P1) with\n     *  I = input\n     *  P1 = first predicate\n     *  C1 = collection of elements matching P1\n     *  R = collection of elements rejected by all predicates\n     * </pre>\n     * <p>\n     * If the input iterable is {@code null}, the same is returned as for an\n     * empty iterable.\n     * </p>\n     * <p>\n     * Example: for an input list [1, 2, 3, 4, 5] calling partition with a predicate [x &lt; 3]\n     * will result in the following output: [[1, 2], [3, 4, 5]].\n     * </p>\n     *\n     * @param <O>  the type of object the {@link Iterable} contains\n     * @param iterable  the iterable to partition, may be null\n     * @param predicate  the predicate to use, may not be null\n     * @return a list containing the output collections\n     * @throws NullPointerException if predicate is null\n     */\n    public static <O> List<List<O>> partition(final Iterable<? extends O> iterable,\n                                              final Predicate<? super O> predicate) {\n        Objects.requireNonNull(predicate, \"predicate\");\n        @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) // safe\n        final Factory<List<O>> factory = FactoryUtils.instantiateFactory((Class) ArrayList.class);\n        @SuppressWarnings(\"unchecked\") // safe\n        final Predicate<? super O>[] predicates = new Predicate[] { predicate };\n        return partition(iterable, factory, predicates);\n    }\n\n    /**\n     * Partitions all elements from iterable into separate output collections,\n     * based on the evaluation of the given predicates.\n     * <p>\n     * For each predicate, the result will contain a list holding all elements of the\n     * input iterable matching the predicate. The last list will hold all elements\n     * which didn't match any predicate:\n     * </p>\n     * <pre>\n     *  [C1, C2, R] = partition(I, P1, P2) with\n     *  I = input\n     *  P1 = first predicate\n     *  P2 = second predicate\n     *  C1 = collection of elements matching P1\n     *  C2 = collection of elements matching P2\n     *  R = collection of elements rejected by all predicates\n     * </pre>\n     * <p>\n     * <b>Note</b>: elements are only added to the output collection of the first matching\n     * predicate, determined by the order of arguments.\n     * </p>\n     * <p>\n     * If the input iterable is {@code null}, the same is returned as for an\n     * empty iterable.\n     * </p>\n     * <p>\n     * Example: for an input list [1, 2, 3, 4, 5] calling partition with predicates [x &lt; 3]\n     * and [x &lt; 5] will result in the following output: [[1, 2], [3, 4], [5]].\n     * </p>\n     *\n     * @param <O>  the type of object the {@link Iterable} contains\n     * @param iterable  the collection to get the input from, may be null\n     * @param predicates  the predicates to use, may not be null\n     * @return a list containing the output collections\n     * @throws NullPointerException if any predicate is null\n     */\n    public static <O> List<List<O>> partition(final Iterable<? extends O> iterable,\n                                              final Predicate<? super O>... predicates) {\n\n        @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) // safe\n        final Factory<List<O>> factory = FactoryUtils.instantiateFactory((Class) ArrayList.class);\n        return partition(iterable, factory, predicates);\n    }\n\n    /**\n     * Returns a reversed view of the given iterable.\n     * <p>\n     * In case the provided iterable is a {@link List} instance, a\n     * {@link ReverseListIterator} will be used to reverse the traversal\n     * order, otherwise an intermediate {@link List} needs to be created.\n     * </p>\n     * <p>\n     * The returned iterable's iterator supports {@code remove()} if the\n     * provided iterable is a {@link List} instance.\n     * </p>\n     *\n     * @param <E> the element type\n     * @param iterable  the iterable to use, may not be null\n     * @return a reversed view of the specified iterable\n     * @throws NullPointerException if iterable is null\n     * @see ReverseListIterator\n     */\n    public static <E> Iterable<E> reversedIterable(final Iterable<E> iterable) {\n        Objects.requireNonNull(iterable, \"iterable\");\n        return new FluentIterable<E>() {\n            @Override\n            public Iterator<E> iterator() {\n                final List<E> list = iterable instanceof List<?> ?\n                        (List<E>) iterable :\n                        IteratorUtils.toList(iterable.iterator());\n                return new ReverseListIterator<>(list);\n            }\n        };\n    }\n\n    /**\n     * Returns the number of elements contained in the given iterator.\n     * <p>\n     * A {@code null} or empty iterator returns {@code 0}.\n     * </p>\n     *\n     * @param iterable  the iterable to check, may be null\n     * @return the number of elements contained in the iterable\n     */\n    public static int size(final Iterable<?> iterable) {\n        if (iterable == null) {\n            return 0;\n        }\n        if (iterable instanceof Collection<?>) {\n            return ((Collection<?>) iterable).size();\n        }\n        return IteratorUtils.size(emptyIteratorIfNull(iterable));\n    }\n\n    /**\n     * Returns a view of the given iterable that skips the first N elements.\n     * <p>\n     * The returned iterable's iterator supports {@code remove()} when the corresponding\n     * input iterator supports it.\n     * </p>\n     *\n     * @param <E> the element type\n     * @param iterable  the iterable to use, may not be null\n     * @param elementsToSkip  the number of elements to skip from the start, must not be negative\n     * @return a view of the specified iterable, skipping the first N elements\n     * @throws IllegalArgumentException if elementsToSkip is negative\n     * @throws NullPointerException if iterable is null\n     */\n    public static <E> Iterable<E> skippingIterable(final Iterable<E> iterable, final long elementsToSkip) {\n        Objects.requireNonNull(iterable, \"iterable\");\n        if (elementsToSkip < 0) {\n            throw new IllegalArgumentException(\"ElementsToSkip parameter must not be negative.\");\n        }\n\n        return new FluentIterable<E>() {\n            @Override\n            public Iterator<E> iterator() {\n                return IteratorUtils.skippingIterator(iterable.iterator(), elementsToSkip);\n            }\n        };\n    }\n\n    /**\n     * Gets a new list with the contents of the provided iterable.\n     *\n     * @param <E> the element type\n     * @param iterable  the iterable to use, may be null\n     * @return a list of the iterator contents\n     */\n    public static <E> List<E> toList(final Iterable<E> iterable) {\n        return IteratorUtils.toList(emptyIteratorIfNull(iterable));\n    }\n\n    /**\n     * Returns a string representation of the elements of the specified iterable.\n     * <p>\n     * The string representation consists of a list of the iterable's elements,\n     * enclosed in square brackets ({@code \"[]\"}). Adjacent elements are separated\n     * by the characters {@code \", \"} (a comma followed by a space). Elements are\n     * converted to strings as by {@code String.valueOf(Object)}.\n     * </p>\n     *\n     * @param <E> the element type\n     * @param iterable  the iterable to convert to a string, may be null\n     * @return a string representation of {@code iterable}\n     */\n    public static <E> String toString(final Iterable<E> iterable) {\n        return IteratorUtils.toString(emptyIteratorIfNull(iterable));\n    }\n\n    /**\n     * Returns a string representation of the elements of the specified iterable.\n     * <p>\n     * The string representation consists of a list of the iterable's elements,\n     * enclosed in square brackets ({@code \"[]\"}). Adjacent elements are separated\n     * by the characters {@code \", \"} (a comma followed by a space). Elements are\n     * converted to strings as by using the provided {@code transformer}.\n     * </p>\n     *\n     * @param <E> the element type\n     * @param iterable  the iterable to convert to a string, may be null\n     * @param transformer  the transformer used to get a string representation of an element\n     * @return a string representation of {@code iterable}\n     * @throws NullPointerException if {@code transformer} is null\n     */\n    public static <E> String toString(final Iterable<E> iterable,\n                                      final Transformer<? super E, String> transformer) {\n        Objects.requireNonNull(transformer, \"transformer\");\n        return IteratorUtils.toString(emptyIteratorIfNull(iterable), transformer);\n    }\n\n    /**\n     * Returns a string representation of the elements of the specified iterable.\n     * <p>\n     * The string representation consists of a list of the iterable's elements,\n     * enclosed by the provided {@code prefix} and {@code suffix}. Adjacent elements\n     * are separated by the provided {@code delimiter}. Elements are converted to\n     * strings as by using the provided {@code transformer}.\n     * </p>\n     *\n     * @param <E> the element type\n     * @param iterable  the iterable to convert to a string, may be null\n     * @param transformer  the transformer used to get a string representation of an element\n     * @param delimiter  the string to delimit elements\n     * @param prefix  the prefix, prepended to the string representation\n     * @param suffix  the suffix, appended to the string representation\n     * @return a string representation of {@code iterable}\n     * @throws NullPointerException if either transformer, delimiter, prefix or suffix is null\n     */\n    public static <E> String toString(final Iterable<E> iterable,\n                                      final Transformer<? super E, String> transformer,\n                                      final String delimiter,\n                                      final String prefix,\n                                      final String suffix) {\n        return IteratorUtils.toString(emptyIteratorIfNull(iterable),\n                                      transformer, delimiter, prefix, suffix);\n    }\n\n    /**\n     * Returns a transformed view of the given iterable where all of its elements\n     * have been transformed by the provided transformer.\n     * <p>\n     * The returned iterable's iterator supports {@code remove()} when the corresponding\n     * input iterator supports it.\n     * </p>\n     *\n     * @param <I>  the input element type\n     * @param <O>  the output element type\n     * @param iterable  the iterable to transform, may not be null\n     * @param transformer  the transformer, must not be null\n     * @return a transformed view of the specified iterable\n     * @throws NullPointerException if either iterable or transformer is null\n     */\n    public static <I, O> Iterable<O> transformedIterable(final Iterable<I> iterable,\n                                                         final Transformer<? super I, ? extends O> transformer) {\n        Objects.requireNonNull(iterable, \"iterable\");\n        Objects.requireNonNull(transformer, \"transformer\");\n        return new FluentIterable<O>() {\n            @Override\n            public Iterator<O> iterator() {\n                return IteratorUtils.transformedIterator(iterable.iterator(), transformer);\n            }\n        };\n    }\n\n    /**\n     * Returns a unique view of the given iterable.\n     * <p>\n     * The returned iterable's iterator supports {@code remove()} when the\n     * corresponding input iterator supports it. Calling {@code remove()}\n     * will only remove a single element from the underlying iterator.\n     * </p>\n     *\n     * @param <E> the element type\n     * @param iterable  the iterable to use, may not be null\n     * @return a unique view of the specified iterable\n     * @throws NullPointerException if iterable is null\n     */\n    public static <E> Iterable<E> uniqueIterable(final Iterable<E> iterable) {\n        Objects.requireNonNull(iterable, \"iterable\");\n        return new FluentIterable<E>() {\n            @Override\n            public Iterator<E> iterator() {\n                return new UniqueFilterIterator<>(iterable.iterator());\n            }\n        };\n    }\n\n    /**\n     * Returns an unmodifiable view of the given iterable.\n     * <p>\n     * The returned iterable's iterator does not support {@code remove()}.\n     * </p>\n     *\n     * @param <E> the element type\n     * @param iterable  the iterable to use, may not be null\n     * @return an unmodifiable view of the specified iterable\n     * @throws NullPointerException if iterable is null\n     */\n    public static <E> Iterable<E> unmodifiableIterable(final Iterable<E> iterable) {\n        Objects.requireNonNull(iterable, \"iterable\");\n        if (iterable instanceof UnmodifiableIterable<?>) {\n            return iterable;\n        }\n        return new UnmodifiableIterable<>(iterable);\n    }\n\n    /**\n     * Interleaves two iterables into a single iterable.\n     * <p>\n     * The returned iterable has an iterator that traverses the elements in {@code a}\n     * and {@code b} in alternating order. The source iterators are not polled until\n     * necessary.\n     * </p>\n     * <p>\n     * The returned iterable's iterator supports {@code remove()} when the corresponding\n     * input iterator supports it.\n     * </p>\n     *\n     * @param <E> the element type\n     * @param a  the first iterable, may not be null\n     * @param b  the second iterable, may not be null\n     * @return a new iterable, interleaving the provided iterables\n     * @throws NullPointerException if either a or b is null\n     */\n    public static <E> Iterable<E> zippingIterable(final Iterable<? extends E> a,\n                                                  final Iterable<? extends E> b) {\n        Objects.requireNonNull(a, \"iterable\");\n        Objects.requireNonNull(b, \"iterable\");\n        return new FluentIterable<E>() {\n            @Override\n            public Iterator<E> iterator() {\n                return IteratorUtils.zippingIterator(a.iterator(), b.iterator());\n            }\n        };\n    }\n\n    /**\n     * Interleaves two iterables into a single iterable.\n     * <p>\n     * The returned iterable has an iterator that traverses the elements in {@code a} and {@code b} in alternating order. The source iterators are not polled\n     * until necessary.\n     * </p>\n     * <p>\n     * The returned iterable's iterator supports {@code remove()} when the corresponding input iterator supports it.\n     * </p>\n     *\n     * @param <E>    the element type\n     * @param first  the first iterable, may not be null\n     * @param others the array of iterables to interleave, may not be null\n     * @return a new iterable, interleaving the provided iterables\n     * @throws NullPointerException if either of the provided iterables is null\n     */\n    public static <E> Iterable<E> zippingIterable(final Iterable<? extends E> first, final Iterable<? extends E>... others) {\n        Objects.requireNonNull(first, \"iterable\");\n        checkNotNull(others);\n        return new FluentIterable<E>() {\n            @Override\n            public Iterator<E> iterator() {\n                @SuppressWarnings(\"unchecked\") // safe\n                final Iterator<? extends E>[] iterators = new Iterator[others.length + 1];\n                iterators[0] = first.iterator();\n                for (int i = 0; i < others.length; i++) {\n                    iterators[i + 1] = others[i].iterator();\n                }\n                return IteratorUtils.zippingIterator(iterators);\n            }\n        };\n    }\n\n    /**\n     * Make private in 5.0.\n     *\n     * @deprecated TODO Make private in 5.0.\n     */\n    @Deprecated\n    public IterableUtils() {\n        // empty\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "@SuppressWarnings(\"rawtypes\")\n    static final FluentIterable EMPTY_ITERABLE = new FluentIterable<Object>() {\n        @Override\n        public Iterator<Object> iterator() {\n            return IteratorUtils.emptyIterator();\n        }\n    };", "docstring": "\nAn empty iterable.\n", "modifiers": "@SuppressWarnings(\"rawtypes\")\n    static final", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"rawtypes\")", "static", "final"], "comments": [], "type": "FluentIterable", "name": "EMPTY_ITERABLE = new FluentIterable<Object>() {\n        @Override\n        public Iterator<Object> iterator() {\n            return IteratorUtils.emptyIterator();\n        }\n    }", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/queue/SynchronizedQueue.java.SynchronizedQueue", "name": "SynchronizedQueue", "file_path": "src/main/java/org/apache/commons/collections4/queue/SynchronizedQueue.java", "superclasses": "", "methods": ["[SynchronizedQueue<E>]synchronizedQueue(Queue<E>)", "[]SynchronizedQueue(Queue<E>)", "[]SynchronizedQueue(Queue<E>,Object)", "[Queue<E>]decorated()", "[E]element()", "[boolean]equals(Object)", "[int]hashCode()", "[boolean]offer(E)", "[E]peek()", "[E]poll()", "[E]remove()"], "method_uris": ["src/main/java/org/apache/commons/collections4/queue/SynchronizedQueue.java.SynchronizedQueue.[SynchronizedQueue<E>]synchronizedQueue(Queue<E>)", "src/main/java/org/apache/commons/collections4/queue/SynchronizedQueue.java.SynchronizedQueue.[]SynchronizedQueue(Queue<E>)", "src/main/java/org/apache/commons/collections4/queue/SynchronizedQueue.java.SynchronizedQueue.[]SynchronizedQueue(Queue<E>,Object)", "src/main/java/org/apache/commons/collections4/queue/SynchronizedQueue.java.SynchronizedQueue.[Queue<E>]decorated()", "src/main/java/org/apache/commons/collections4/queue/SynchronizedQueue.java.SynchronizedQueue.[E]element()", "src/main/java/org/apache/commons/collections4/queue/SynchronizedQueue.java.SynchronizedQueue.[boolean]equals(Object)", "src/main/java/org/apache/commons/collections4/queue/SynchronizedQueue.java.SynchronizedQueue.[int]hashCode()", "src/main/java/org/apache/commons/collections4/queue/SynchronizedQueue.java.SynchronizedQueue.[boolean]offer(E)", "src/main/java/org/apache/commons/collections4/queue/SynchronizedQueue.java.SynchronizedQueue.[E]peek()", "src/main/java/org/apache/commons/collections4/queue/SynchronizedQueue.java.SynchronizedQueue.[E]poll()", "src/main/java/org/apache/commons/collections4/queue/SynchronizedQueue.java.SynchronizedQueue.[E]remove()"], "overrides": null, "attributes": [], "class_docstring": "\nDecorates another {@link Queue} to synchronize its behavior for a multithreaded environment.\n<p>\nMethods are synchronized, then forwarded to the decorated queue. Iterators must be separately synchronized around the\nloop.\n</p>\n\n@param <E> the type of the elements in the collection\n@since 4.2\n", "original_string": "public class SynchronizedQueue<E> extends SynchronizedCollection<E> implements Queue<E> {\n\n    /** Serialization version */\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * Factory method to create a synchronized queue.\n     *\n     * @param <E>\n     *            the type of the elements in the queue\n     * @param queue\n     *            the queue to decorate, must not be null\n     * @return a new synchronized Queue\n     * @throws NullPointerException\n     *             if queue is null\n     */\n    public static <E> SynchronizedQueue<E> synchronizedQueue(final Queue<E> queue) {\n        return new SynchronizedQueue<>(queue);\n    }\n\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param queue\n     *            the queue to decorate, must not be null\n     * @throws NullPointerException\n     *             if queue is null\n     */\n    protected SynchronizedQueue(final Queue<E> queue) {\n        super(queue);\n    }\n\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param queue\n     *            the queue to decorate, must not be null\n     * @param lock\n     *            the lock to use, must not be null\n     * @throws NullPointerException\n     *             if queue or lock is null\n     */\n    protected SynchronizedQueue(final Queue<E> queue, final Object lock) {\n        super(queue, lock);\n    }\n\n    /**\n     * Gets the queue being decorated.\n     *\n     * @return the decorated queue\n     */\n    @Override\n    protected Queue<E> decorated() {\n        return (Queue<E>) super.decorated();\n    }\n\n    @Override\n    public E element() {\n        synchronized (lock) {\n            return decorated().element();\n        }\n    }\n\n    @Override\n    public boolean equals(final Object object) {\n        if (object == this) {\n            return true;\n        }\n        synchronized (lock) {\n            return decorated().equals(object);\n        }\n    }\n\n    @Override\n    public int hashCode() {\n        synchronized (lock) {\n            return decorated().hashCode();\n        }\n    }\n\n    @Override\n    public boolean offer(final E e) {\n        synchronized (lock) {\n            return decorated().offer(e);\n        }\n    }\n\n    @Override\n    public E peek() {\n        synchronized (lock) {\n            return decorated().peek();\n        }\n    }\n\n    @Override\n    public E poll() {\n        synchronized (lock) {\n            return decorated().poll();\n        }\n    }\n\n    @Override\n    public E remove() {\n        synchronized (lock) {\n            return decorated().remove();\n        }\n    }\n\n}", "super_interfaces": ["Queue<E>"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 1L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 1L", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/queue/TransformedQueue.java.TransformedQueue", "name": "TransformedQueue", "file_path": "src/main/java/org/apache/commons/collections4/queue/TransformedQueue.java", "superclasses": "", "methods": ["[TransformedQueue<E>]transformedQueue(Queue<E>,Transformer<? super E, ? extends E>)", "[TransformedQueue<E>]transformingQueue(Queue<E>,Transformer<? super E, ? extends E>)", "[]TransformedQueue(Queue<E>,Transformer<? super E, ? extends E>)", "[E]element()", "[Queue<E>]getQueue()", "[boolean]offer(E)", "[E]peek()", "[E]poll()", "[E]remove()"], "method_uris": ["src/main/java/org/apache/commons/collections4/queue/TransformedQueue.java.TransformedQueue.[TransformedQueue<E>]transformedQueue(Queue<E>,Transformer<? super E, ? extends E>)", "src/main/java/org/apache/commons/collections4/queue/TransformedQueue.java.TransformedQueue.[TransformedQueue<E>]transformingQueue(Queue<E>,Transformer<? super E, ? extends E>)", "src/main/java/org/apache/commons/collections4/queue/TransformedQueue.java.TransformedQueue.[]TransformedQueue(Queue<E>,Transformer<? super E, ? extends E>)", "src/main/java/org/apache/commons/collections4/queue/TransformedQueue.java.TransformedQueue.[E]element()", "src/main/java/org/apache/commons/collections4/queue/TransformedQueue.java.TransformedQueue.[Queue<E>]getQueue()", "src/main/java/org/apache/commons/collections4/queue/TransformedQueue.java.TransformedQueue.[boolean]offer(E)", "src/main/java/org/apache/commons/collections4/queue/TransformedQueue.java.TransformedQueue.[E]peek()", "src/main/java/org/apache/commons/collections4/queue/TransformedQueue.java.TransformedQueue.[E]poll()", "src/main/java/org/apache/commons/collections4/queue/TransformedQueue.java.TransformedQueue.[E]remove()"], "overrides": null, "attributes": [], "class_docstring": "\nDecorates another {@link Queue} to transform objects that are added.\n<p>\nThe add/offer methods are affected by this class.\nThus objects must be removed or searched for using their transformed form.\nFor example, if the transformation converts Strings to Integers, you must\nuse the Integer form to remove objects.\n</p>\n\n@param <E> the type of elements held in this queue\n@since 4.0\n", "original_string": "public class TransformedQueue<E> extends TransformedCollection<E> implements Queue<E> {\n\n    /** Serialization version */\n    private static final long serialVersionUID = -7901091318986132033L;\n\n    /**\n     * Factory method to create a transforming queue that will transform\n     * existing contents of the specified queue.\n     * <p>\n     * If there are any elements already in the queue being decorated, they\n     * will be transformed by this method.\n     * Contrast this with {@link #transformingQueue(Queue, Transformer)}.\n     *\n     * @param <E> the type of the elements in the queue\n     * @param queue  the queue to decorate, must not be null\n     * @param transformer  the transformer to use for conversion, must not be null\n     * @return a new transformed Queue\n     * @throws NullPointerException if queue or transformer is null\n     * @since 4.0\n     */\n    public static <E> TransformedQueue<E> transformedQueue(final Queue<E> queue,\n                                                           final Transformer<? super E, ? extends E> transformer) {\n        // throws IAE if queue or transformer is null\n        final TransformedQueue<E> decorated = new TransformedQueue<>(queue, transformer);\n        if (!queue.isEmpty()) {\n            @SuppressWarnings(\"unchecked\") // queue is type <E>\n            final E[] values = (E[]) queue.toArray(); // NOPMD - false positive for generics\n            queue.clear();\n            for (final E value : values) {\n                decorated.decorated().add(transformer.apply(value));\n            }\n        }\n        return decorated;\n    }\n\n    /**\n     * Factory method to create a transforming queue.\n     * <p>\n     * If there are any elements already in the queue being decorated, they\n     * are NOT transformed.\n     * Contrast this with {@link #transformedQueue(Queue, Transformer)}.\n     *\n     * @param <E> the type of the elements in the queue\n     * @param queue  the queue to decorate, must not be null\n     * @param transformer  the transformer to use for conversion, must not be null\n     * @return a new transformed Queue\n     * @throws NullPointerException if queue or transformer is null\n     */\n    public static <E> TransformedQueue<E> transformingQueue(final Queue<E> queue,\n                                                            final Transformer<? super E, ? extends E> transformer) {\n        return new TransformedQueue<>(queue, transformer);\n    }\n\n    /**\n     * Constructor that wraps (not copies).\n     * <p>\n     * If there are any elements already in the queue being decorated, they\n     * are NOT transformed.\n     *\n     * @param queue  the queue to decorate, must not be null\n     * @param transformer  the transformer to use for conversion, must not be null\n     * @throws NullPointerException if queue or transformer is null\n     */\n    protected TransformedQueue(final Queue<E> queue, final Transformer<? super E, ? extends E> transformer) {\n        super(queue, transformer);\n    }\n\n    @Override\n    public E element() {\n        return getQueue().element();\n    }\n\n    /**\n     * Gets the decorated queue.\n     *\n     * @return the decorated queue\n     */\n    protected Queue<E> getQueue() {\n        return (Queue<E>) decorated();\n    }\n\n    @Override\n    public boolean offer(final E obj) {\n        return getQueue().offer(transform(obj));\n    }\n\n    @Override\n    public E peek() {\n        return getQueue().peek();\n    }\n\n    @Override\n    public E poll() {\n        return getQueue().poll();\n    }\n\n    @Override\n    public E remove() {\n        return getQueue().remove();\n    }\n\n}", "super_interfaces": ["Queue<E>"], "fields": [{"attribute_expression": "private static final long serialVersionUID = -7901091318986132033L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -7901091318986132033L", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/queue/PredicatedQueue.java.PredicatedQueue", "name": "PredicatedQueue", "file_path": "src/main/java/org/apache/commons/collections4/queue/PredicatedQueue.java", "superclasses": "", "methods": ["[PredicatedQueue<E>]predicatedQueue(Queue<E>,Predicate<? super E>)", "[]PredicatedQueue(Queue<E>,Predicate<? super E>)", "[Queue<E>]decorated()", "[E]element()", "[boolean]offer(E)", "[E]peek()", "[E]poll()", "[E]remove()"], "method_uris": ["src/main/java/org/apache/commons/collections4/queue/PredicatedQueue.java.PredicatedQueue.[PredicatedQueue<E>]predicatedQueue(Queue<E>,Predicate<? super E>)", "src/main/java/org/apache/commons/collections4/queue/PredicatedQueue.java.PredicatedQueue.[]PredicatedQueue(Queue<E>,Predicate<? super E>)", "src/main/java/org/apache/commons/collections4/queue/PredicatedQueue.java.PredicatedQueue.[Queue<E>]decorated()", "src/main/java/org/apache/commons/collections4/queue/PredicatedQueue.java.PredicatedQueue.[E]element()", "src/main/java/org/apache/commons/collections4/queue/PredicatedQueue.java.PredicatedQueue.[boolean]offer(E)", "src/main/java/org/apache/commons/collections4/queue/PredicatedQueue.java.PredicatedQueue.[E]peek()", "src/main/java/org/apache/commons/collections4/queue/PredicatedQueue.java.PredicatedQueue.[E]poll()", "src/main/java/org/apache/commons/collections4/queue/PredicatedQueue.java.PredicatedQueue.[E]remove()"], "overrides": null, "attributes": [], "class_docstring": "\nDecorates another {@link Queue} to validate that additions\nmatch a specified predicate.\n<p>\nThis queue exists to provide validation for the decorated queue.\nIt is normally created to decorate an empty queue.\nIf an object cannot be added to the queue, an IllegalArgumentException is thrown.\n</p>\n<p>\nOne usage would be to ensure that no null entries are added to the queue.\n</p>\n<pre>Queue queue = PredicatedQueue.predicatedQueue(new UnboundedFifoQueue(), NotNullPredicate.INSTANCE);</pre>\n\n@param <E> the type of elements held in this queue\n@since 4.0\n", "original_string": "public class PredicatedQueue<E> extends PredicatedCollection<E> implements Queue<E> {\n\n    /** Serialization version */\n    private static final long serialVersionUID = 2307609000539943581L;\n\n    /**\n     * Factory method to create a predicated (validating) queue.\n     * <p>\n     * If there are any elements already in the queue being decorated, they\n     * are validated.\n     *\n     * @param <E> the type of the elements in the queue\n     * @param Queue  the queue to decorate, must not be null\n     * @param predicate  the predicate to use for validation, must not be null\n     * @return a new predicated queue\n     * @throws NullPointerException if queue or predicate is null\n     * @throws IllegalArgumentException if the queue contains invalid elements\n     */\n    public static <E> PredicatedQueue<E> predicatedQueue(final Queue<E> Queue,\n                                                          final Predicate<? super E> predicate) {\n        return new PredicatedQueue<>(Queue, predicate);\n    }\n\n    /**\n     * Constructor that wraps (not copies).\n     * <p>\n     * If there are any elements already in the collection being decorated, they\n     * are validated.\n     *\n     * @param queue  the queue to decorate, must not be null\n     * @param predicate  the predicate to use for validation, must not be null\n     * @throws NullPointerException if queue or predicate is null\n     * @throws IllegalArgumentException if the Queue contains invalid elements\n     */\n    protected PredicatedQueue(final Queue<E> queue, final Predicate<? super E> predicate) {\n        super(queue, predicate);\n    }\n\n    /**\n     * Gets the queue being decorated.\n     *\n     * @return the decorated queue\n     */\n    @Override\n    protected Queue<E> decorated() {\n        return (Queue<E>) super.decorated();\n    }\n\n    @Override\n    public E element() {\n        return decorated().element();\n    }\n\n    /**\n     * Override to validate the object being added to ensure it matches\n     * the predicate.\n     *\n     * @param object  the object being added\n     * @return the result of adding to the underlying queue\n     * @throws IllegalArgumentException if the add is invalid\n     */\n    @Override\n    public boolean offer(final E object) {\n        validate(object);\n        return decorated().offer(object);\n    }\n\n    @Override\n    public E peek() {\n        return decorated().peek();\n    }\n\n    @Override\n    public E poll() {\n        return decorated().poll();\n    }\n\n    @Override\n    public E remove() {\n        return decorated().remove();\n    }\n\n}", "super_interfaces": ["Queue<E>"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 2307609000539943581L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 2307609000539943581L", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/queue/UnmodifiableQueue.java.UnmodifiableQueue", "name": "UnmodifiableQueue", "file_path": "src/main/java/org/apache/commons/collections4/queue/UnmodifiableQueue.java", "superclasses": "", "methods": ["[Queue<E>]unmodifiableQueue(Queue<? extends E>)", "[]UnmodifiableQueue(Queue<? extends E>)", "[boolean]add(Object)", "[boolean]addAll(Collection<? extends E>)", "[void]clear()", "[Iterator<E>]iterator()", "[boolean]offer(E)", "[E]poll()", "[void]readObject(ObjectInputStream)", "[E]remove()", "[boolean]remove(Object)", "[boolean]removeAll(Collection<?>)", "[boolean]removeIf(Predicate<? super E>)", "[boolean]retainAll(Collection<?>)", "[void]writeObject(ObjectOutputStream)"], "method_uris": ["src/main/java/org/apache/commons/collections4/queue/UnmodifiableQueue.java.UnmodifiableQueue.[Queue<E>]unmodifiableQueue(Queue<? extends E>)", "src/main/java/org/apache/commons/collections4/queue/UnmodifiableQueue.java.UnmodifiableQueue.[]UnmodifiableQueue(Queue<? extends E>)", "src/main/java/org/apache/commons/collections4/queue/UnmodifiableQueue.java.UnmodifiableQueue.[boolean]add(Object)", "src/main/java/org/apache/commons/collections4/queue/UnmodifiableQueue.java.UnmodifiableQueue.[boolean]addAll(Collection<? extends E>)", "src/main/java/org/apache/commons/collections4/queue/UnmodifiableQueue.java.UnmodifiableQueue.[void]clear()", "src/main/java/org/apache/commons/collections4/queue/UnmodifiableQueue.java.UnmodifiableQueue.[Iterator<E>]iterator()", "src/main/java/org/apache/commons/collections4/queue/UnmodifiableQueue.java.UnmodifiableQueue.[boolean]offer(E)", "src/main/java/org/apache/commons/collections4/queue/UnmodifiableQueue.java.UnmodifiableQueue.[E]poll()", "src/main/java/org/apache/commons/collections4/queue/UnmodifiableQueue.java.UnmodifiableQueue.[void]readObject(ObjectInputStream)", "src/main/java/org/apache/commons/collections4/queue/UnmodifiableQueue.java.UnmodifiableQueue.[E]remove()", "src/main/java/org/apache/commons/collections4/queue/UnmodifiableQueue.java.UnmodifiableQueue.[boolean]remove(Object)", "src/main/java/org/apache/commons/collections4/queue/UnmodifiableQueue.java.UnmodifiableQueue.[boolean]removeAll(Collection<?>)", "src/main/java/org/apache/commons/collections4/queue/UnmodifiableQueue.java.UnmodifiableQueue.[boolean]removeIf(Predicate<? super E>)", "src/main/java/org/apache/commons/collections4/queue/UnmodifiableQueue.java.UnmodifiableQueue.[boolean]retainAll(Collection<?>)", "src/main/java/org/apache/commons/collections4/queue/UnmodifiableQueue.java.UnmodifiableQueue.[void]writeObject(ObjectOutputStream)"], "overrides": null, "attributes": [], "class_docstring": "\nDecorates another {@link Queue} to ensure it can't be altered.\n<p>\nAttempts to modify it will result in an UnsupportedOperationException.\n</p>\n\n@param <E> the type of elements held in this queue\n@since 4.0\n", "original_string": "public final class UnmodifiableQueue<E>\n        extends AbstractQueueDecorator<E>\n        implements Unmodifiable {\n\n    /** Serialization version */\n    private static final long serialVersionUID = 1832948656215393357L;\n\n    /**\n     * Factory method to create an unmodifiable queue.\n     * <p>\n     * If the queue passed in is already unmodifiable, it is returned.\n     *\n     * @param <E> the type of the elements in the queue\n     * @param queue  the queue to decorate, must not be null\n     * @return an unmodifiable Queue\n     * @throws NullPointerException if queue is null\n     */\n    public static <E> Queue<E> unmodifiableQueue(final Queue<? extends E> queue) {\n        if (queue instanceof Unmodifiable) {\n            @SuppressWarnings(\"unchecked\") // safe to upcast\n            final Queue<E> tmpQueue = (Queue<E>) queue;\n            return tmpQueue;\n        }\n        return new UnmodifiableQueue<>(queue);\n    }\n\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param queue  the queue to decorate, must not be null\n     * @throws NullPointerException if queue is null\n     */\n    @SuppressWarnings(\"unchecked\") // safe to upcast\n    private UnmodifiableQueue(final Queue<? extends E> queue) {\n        super((Queue<E>) queue);\n    }\n\n    @Override\n    public boolean add(final Object object) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public boolean addAll(final Collection<? extends E> coll) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public void clear() {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public Iterator<E> iterator() {\n        return UnmodifiableIterator.unmodifiableIterator(decorated().iterator());\n    }\n\n    @Override\n    public boolean offer(final E obj) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public E poll() {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * Deserializes the collection in using a custom routine.\n     *\n     * @param in  the input stream\n     * @throws IOException if an I/O error occurs while reading from the input stream\n     * @throws ClassNotFoundException if the class of a serialized object can not be found\n     */\n    @SuppressWarnings(\"unchecked\")\n    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        setCollection((Collection<E>) in.readObject());\n    }\n\n    @Override\n    public E remove() {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public boolean remove(final Object object) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public boolean removeAll(final Collection<?> coll) {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * @since 4.4\n     */\n    @Override\n    public boolean removeIf(final Predicate<? super E> filter) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public boolean retainAll(final Collection<?> coll) {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * Serializes this object to an ObjectOutputStream.\n     *\n     * @param out the target ObjectOutputStream.\n     * @throws IOException thrown when an I/O errors occur writing to the target stream.\n     */\n    private void writeObject(final ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        out.writeObject(decorated());\n    }\n\n}", "super_interfaces": ["Unmodifiable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 1832948656215393357L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 1832948656215393357L", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/queue/CircularFifoQueue.java.CircularFifoQueue", "name": "CircularFifoQueue", "file_path": "src/main/java/org/apache/commons/collections4/queue/CircularFifoQueue.java", "superclasses": "", "methods": ["[]CircularFifoQueue()", "[]CircularFifoQueue(Collection<? extends E>)", "[]CircularFifoQueue(int)", "[boolean]add(E)", "[void]clear()", "[int]decrement(int)", "[E]element()", "[E]get(int)", "[int]increment(int)", "[boolean]isAtFullCapacity()", "[boolean]isEmpty()", "[boolean]isFull()", "[Iterator<E>]iterator()", "[int]maxSize()", "[boolean]offer(E)", "[E]peek()", "[E]poll()", "[void]readObject(ObjectInputStream)", "[E]remove()", "[int]size()", "[void]writeObject(ObjectOutputStream)"], "method_uris": ["src/main/java/org/apache/commons/collections4/queue/CircularFifoQueue.java.CircularFifoQueue.[]CircularFifoQueue()", "src/main/java/org/apache/commons/collections4/queue/CircularFifoQueue.java.CircularFifoQueue.[]CircularFifoQueue(Collection<? extends E>)", "src/main/java/org/apache/commons/collections4/queue/CircularFifoQueue.java.CircularFifoQueue.[]CircularFifoQueue(int)", "src/main/java/org/apache/commons/collections4/queue/CircularFifoQueue.java.CircularFifoQueue.[boolean]add(E)", "src/main/java/org/apache/commons/collections4/queue/CircularFifoQueue.java.CircularFifoQueue.[void]clear()", "src/main/java/org/apache/commons/collections4/queue/CircularFifoQueue.java.CircularFifoQueue.[int]decrement(int)", "src/main/java/org/apache/commons/collections4/queue/CircularFifoQueue.java.CircularFifoQueue.[E]element()", "src/main/java/org/apache/commons/collections4/queue/CircularFifoQueue.java.CircularFifoQueue.[E]get(int)", "src/main/java/org/apache/commons/collections4/queue/CircularFifoQueue.java.CircularFifoQueue.[int]increment(int)", "src/main/java/org/apache/commons/collections4/queue/CircularFifoQueue.java.CircularFifoQueue.[boolean]isAtFullCapacity()", "src/main/java/org/apache/commons/collections4/queue/CircularFifoQueue.java.CircularFifoQueue.[boolean]isEmpty()", "src/main/java/org/apache/commons/collections4/queue/CircularFifoQueue.java.CircularFifoQueue.[boolean]isFull()", "src/main/java/org/apache/commons/collections4/queue/CircularFifoQueue.java.CircularFifoQueue.[Iterator<E>]iterator()", "src/main/java/org/apache/commons/collections4/queue/CircularFifoQueue.java.CircularFifoQueue.[int]maxSize()", "src/main/java/org/apache/commons/collections4/queue/CircularFifoQueue.java.CircularFifoQueue.[boolean]offer(E)", "src/main/java/org/apache/commons/collections4/queue/CircularFifoQueue.java.CircularFifoQueue.[E]peek()", "src/main/java/org/apache/commons/collections4/queue/CircularFifoQueue.java.CircularFifoQueue.[E]poll()", "src/main/java/org/apache/commons/collections4/queue/CircularFifoQueue.java.CircularFifoQueue.[void]readObject(ObjectInputStream)", "src/main/java/org/apache/commons/collections4/queue/CircularFifoQueue.java.CircularFifoQueue.[E]remove()", "src/main/java/org/apache/commons/collections4/queue/CircularFifoQueue.java.CircularFifoQueue.[int]size()", "src/main/java/org/apache/commons/collections4/queue/CircularFifoQueue.java.CircularFifoQueue.[void]writeObject(ObjectOutputStream)"], "overrides": null, "attributes": [], "class_docstring": "\nCircularFifoQueue is a first-in first-out queue with a fixed size that\nreplaces its oldest element if full.\n<p>\nThe removal order of a {@link CircularFifoQueue} is based on the\ninsertion order; elements are removed in the same order in which they\nwere added.  The iteration order is the same as the removal order.\n</p>\n<p>\nThe {@link #add(Object)}, {@link #remove()}, {@link #peek()}, {@link #poll()},\n{@link #offer(Object)} operations all perform in constant time.\nAll other operations perform in linear time or worse.\n</p>\n<p>\nThis queue prevents null objects from being added.\n</p>\n\n@param <E> the type of elements in this collection\n@since 4.0\n", "original_string": "public class CircularFifoQueue<E> extends AbstractCollection<E>\n    implements Queue<E>, BoundedCollection<E>, Serializable {\n\n    /** Serialization version. */\n    private static final long serialVersionUID = -8423413834657610406L;\n\n    /** Underlying storage array. */\n    private transient E[] elements;\n\n    /** Array index of first (oldest) queue element. */\n    private transient int start;\n\n    /**\n     * Index mod maxElements of the array position following the last queue\n     * element.  Queue elements start at elements[start] and \"wrap around\"\n     * elements[maxElements-1], ending at elements[decrement(end)].\n     * For example, elements = {c,a,b}, start=1, end=1 corresponds to\n     * the queue [a,b,c].\n     */\n    private transient int end;\n\n    /** Flag to indicate if the queue is currently full. */\n    private transient boolean full;\n\n    /** Capacity of the queue. */\n    private final int maxElements;\n\n    /**\n     * Constructor that creates a queue with the default size of 32.\n     */\n    public CircularFifoQueue() {\n        this(32);\n    }\n\n    /**\n     * Constructor that creates a queue from the specified collection.\n     * The collection size also sets the queue size.\n     *\n     * @param coll  the collection to copy into the queue, may not be null\n     * @throws NullPointerException if the collection is null\n     */\n    public CircularFifoQueue(final Collection<? extends E> coll) {\n        this(coll.size());\n        addAll(coll);\n    }\n\n    /**\n     * Constructor that creates a queue with the specified size.\n     *\n     * @param size  the size of the queue (cannot be changed)\n     * @throws IllegalArgumentException  if the size is &lt; 1\n     */\n    @SuppressWarnings(\"unchecked\")\n    public CircularFifoQueue(final int size) {\n        if (size <= 0) {\n            throw new IllegalArgumentException(\"The size must be greater than 0\");\n        }\n        elements = (E[]) new Object[size];\n        maxElements = elements.length;\n    }\n\n    /**\n     * Adds the given element to this queue. If the queue is full, the least recently added\n     * element is discarded so that a new element can be inserted.\n     *\n     * @param element  the element to add\n     * @return true, always\n     * @throws NullPointerException  if the given element is null\n     */\n    @Override\n    public boolean add(final E element) {\n        Objects.requireNonNull(element, \"element\");\n\n        if (isAtFullCapacity()) {\n            remove();\n        }\n\n        elements[end++] = element;\n\n        if (end >= maxElements) {\n            end = 0;\n        }\n\n        if (end == start) {\n            full = true;\n        }\n\n        return true;\n    }\n\n    /**\n     * Clears this queue.\n     */\n    @Override\n    public void clear() {\n        full = false;\n        start = 0;\n        end = 0;\n        Arrays.fill(elements, null);\n    }\n\n    /**\n     * Decrements the internal index.\n     *\n     * @param index  the index to decrement\n     * @return the updated index\n     */\n    private int decrement(int index) {\n        index--;\n        if (index < 0) {\n            index = maxElements - 1;\n        }\n        return index;\n    }\n\n    @Override\n    public E element() {\n        if (isEmpty()) {\n            throw new NoSuchElementException(\"queue is empty\");\n        }\n        return peek();\n    }\n\n    /**\n     * Returns the element at the specified position in this queue.\n     *\n     * @param index the position of the element in the queue\n     * @return the element at position {@code index}\n     * @throws NoSuchElementException if the requested position is outside the range [0, size)\n     */\n    public E get(final int index) {\n        final int sz = size();\n        if (index < 0 || index >= sz) {\n            throw new NoSuchElementException(\n                    String.format(\"The specified index %1$d is outside the available range [0, %2$d)\",\n                                  Integer.valueOf(index), Integer.valueOf(sz)));\n        }\n\n        final int idx = (start + index) % maxElements;\n        return elements[idx];\n    }\n\n    /**\n     * Increments the internal index.\n     *\n     * @param index  the index to increment\n     * @return the updated index\n     */\n    private int increment(int index) {\n        index++;\n        if (index >= maxElements) {\n            index = 0;\n        }\n        return index;\n    }\n\n    /**\n     * Returns {@code true} if the capacity limit of this queue has been reached,\n     * i.e. the number of elements stored in the queue equals its maximum size.\n     *\n     * @return {@code true} if the capacity limit has been reached, {@code false} otherwise\n     * @since 4.1\n     */\n    public boolean isAtFullCapacity() {\n        return size() == maxElements;\n    }\n\n    /**\n     * Returns true if this queue is empty; false otherwise.\n     *\n     * @return true if this queue is empty\n     */\n    @Override\n    public boolean isEmpty() {\n        return size() == 0;\n    }\n\n    /**\n     * {@inheritDoc}\n     * <p>\n     * A {@code CircularFifoQueue} can never be full, thus this returns always\n     * {@code false}.\n     *\n     * @return always returns {@code false}\n     */\n    @Override\n    public boolean isFull() {\n        return false;\n    }\n\n    /**\n     * Returns an iterator over this queue's elements.\n     *\n     * @return an iterator over this queue's elements\n     */\n    @Override\n    public Iterator<E> iterator() {\n        return new Iterator<E>() {\n\n            private int index = start;\n            private int lastReturnedIndex = -1;\n            private boolean isFirst = full;\n\n            @Override\n            public boolean hasNext() {\n                return isFirst || index != end;\n            }\n\n            @Override\n            public E next() {\n                if (!hasNext()) {\n                    throw new NoSuchElementException();\n                }\n                isFirst = false;\n                lastReturnedIndex = index;\n                index = increment(index);\n                return elements[lastReturnedIndex];\n            }\n\n            @Override\n            public void remove() {\n                if (lastReturnedIndex == -1) {\n                    throw new IllegalStateException();\n                }\n\n                // First element can be removed quickly\n                if (lastReturnedIndex == start) {\n                    CircularFifoQueue.this.remove();\n                    lastReturnedIndex = -1;\n                    return;\n                }\n\n                int pos = lastReturnedIndex + 1;\n                if (start < lastReturnedIndex && pos < end) {\n                    // shift in one part\n                    System.arraycopy(elements, pos, elements, lastReturnedIndex, end - pos);\n                } else {\n                    // Other elements require us to shift the subsequent elements\n                    while (pos != end) {\n                        if (pos >= maxElements) {\n                            elements[pos - 1] = elements[0];\n                            pos = 0;\n                        } else {\n                            elements[decrement(pos)] = elements[pos];\n                            pos = increment(pos);\n                        }\n                    }\n                }\n\n                lastReturnedIndex = -1;\n                end = decrement(end);\n                elements[end] = null;\n                full = false;\n                index = decrement(index);\n            }\n\n        };\n    }\n\n    /**\n     * Gets the maximum size of the collection (the bound).\n     *\n     * @return the maximum number of elements the collection can hold\n     */\n    @Override\n    public int maxSize() {\n        return maxElements;\n    }\n\n    /**\n     * Adds the given element to this queue. If the queue is full, the least recently added\n     * element is discarded so that a new element can be inserted.\n     *\n     * @param element  the element to add\n     * @return true, always\n     * @throws NullPointerException  if the given element is null\n     */\n    @Override\n    public boolean offer(final E element) {\n        return add(element);\n    }\n\n    @Override\n    public E peek() {\n        if (isEmpty()) {\n            return null;\n        }\n        return elements[start];\n    }\n\n    @Override\n    public E poll() {\n        if (isEmpty()) {\n            return null;\n        }\n        return remove();\n    }\n\n    /**\n     * Deserializes the queue in using a custom routine.\n     *\n     * @param in  the input stream\n     * @throws IOException if an I/O error occurs while writing to the output stream\n     * @throws ClassNotFoundException if the class of a serialized object can not be found\n     */\n    @SuppressWarnings(\"unchecked\")\n    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        elements = (E[]) new Object[maxElements];\n        final int size = in.readInt();\n        for (int i = 0; i < size; i++) {\n            elements[i] = (E) in.readObject();\n        }\n        start = 0;\n        full = size == maxElements;\n        if (full) {\n            end = 0;\n        } else {\n            end = size;\n        }\n    }\n\n    @Override\n    public E remove() {\n        if (isEmpty()) {\n            throw new NoSuchElementException(\"queue is empty\");\n        }\n\n        final E element = elements[start];\n        if (null != element) {\n            elements[start++] = null;\n\n            if (start >= maxElements) {\n                start = 0;\n            }\n            full = false;\n        }\n        return element;\n    }\n\n    /**\n     * Returns the number of elements stored in the queue.\n     *\n     * @return this queue's size\n     */\n    @Override\n    public int size() {\n        int size = 0;\n\n        if (end < start) {\n            size = maxElements - start + end;\n        } else if (end == start) {\n            size = full ? maxElements : 0;\n        } else {\n            size = end - start;\n        }\n\n        return size;\n    }\n\n    /**\n     * Serializes this object to an ObjectOutputStream.\n     *\n     * @param out the target ObjectOutputStream.\n     * @throws IOException thrown when an I/O errors occur writing to the target stream.\n     */\n    private void writeObject(final ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        out.writeInt(size());\n        for (final E e : this) {\n            out.writeObject(e);\n        }\n    }\n\n}", "super_interfaces": ["Queue<E>", "BoundedCollection<E>", "Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = -8423413834657610406L;", "docstring": " Serialization version.", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -8423413834657610406L", "syntax_pass": true}, {"attribute_expression": "private transient E[] elements;", "docstring": " Underlying storage array.", "modifiers": "private transient", "marker_annotations": [], "non_marker_annotations": ["private", "transient"], "comments": [], "type": "E[]", "name": "elements", "syntax_pass": true}, {"attribute_expression": "private transient int start;", "docstring": " Array index of first (oldest) queue element.", "modifiers": "private transient", "marker_annotations": [], "non_marker_annotations": ["private", "transient"], "comments": [], "type": "int", "name": "start", "syntax_pass": true}, {"attribute_expression": "private transient int end;", "docstring": "\nIndex mod maxElements of the array position following the last queue\nelement.  Queue elements start at elements[start] and \"wrap around\"\nelements[maxElements-1], ending at elements[decrement(end)].\nFor example, elements = {c,a,b}, start=1, end=1 corresponds to\nthe queue [a,b,c].\n", "modifiers": "private transient", "marker_annotations": [], "non_marker_annotations": ["private", "transient"], "comments": [], "type": "int", "name": "end", "syntax_pass": true}, {"attribute_expression": "private transient boolean full;", "docstring": " Flag to indicate if the queue is currently full.", "modifiers": "private transient", "marker_annotations": [], "non_marker_annotations": ["private", "transient"], "comments": [], "type": "boolean", "name": "full", "syntax_pass": true}, {"attribute_expression": "private final int maxElements;", "docstring": " Capacity of the queue.", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "maxElements", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/bag/TransformedBag.java.TransformedBag", "name": "TransformedBag", "file_path": "src/main/java/org/apache/commons/collections4/bag/TransformedBag.java", "superclasses": "", "methods": ["[Bag<E>]transformedBag(Bag<E>,Transformer<? super E, ? extends E>)", "[Bag<E>]transformingBag(Bag<E>,Transformer<? super E, ? extends E>)", "[]TransformedBag(Bag<E>,Transformer<? super E, ? extends E>)", "[boolean]add(E,int)", "[boolean]equals(Object)", "[Bag<E>]getBag()", "[int]getCount(Object)", "[int]hashCode()", "[boolean]remove(Object,int)", "[Set<E>]uniqueSet()"], "method_uris": ["src/main/java/org/apache/commons/collections4/bag/TransformedBag.java.TransformedBag.[Bag<E>]transformedBag(Bag<E>,Transformer<? super E, ? extends E>)", "src/main/java/org/apache/commons/collections4/bag/TransformedBag.java.TransformedBag.[Bag<E>]transformingBag(Bag<E>,Transformer<? super E, ? extends E>)", "src/main/java/org/apache/commons/collections4/bag/TransformedBag.java.TransformedBag.[]TransformedBag(Bag<E>,Transformer<? super E, ? extends E>)", "src/main/java/org/apache/commons/collections4/bag/TransformedBag.java.TransformedBag.[boolean]add(E,int)", "src/main/java/org/apache/commons/collections4/bag/TransformedBag.java.TransformedBag.[boolean]equals(Object)", "src/main/java/org/apache/commons/collections4/bag/TransformedBag.java.TransformedBag.[Bag<E>]getBag()", "src/main/java/org/apache/commons/collections4/bag/TransformedBag.java.TransformedBag.[int]getCount(Object)", "src/main/java/org/apache/commons/collections4/bag/TransformedBag.java.TransformedBag.[int]hashCode()", "src/main/java/org/apache/commons/collections4/bag/TransformedBag.java.TransformedBag.[boolean]remove(Object,int)", "src/main/java/org/apache/commons/collections4/bag/TransformedBag.java.TransformedBag.[Set<E>]uniqueSet()"], "overrides": null, "attributes": [], "class_docstring": "\nDecorates another {@link Bag} to transform objects that are added.\n<p>\nThe add methods are affected by this class.\nThus objects must be removed or searched for using their transformed form.\nFor example, if the transformation converts Strings to Integers, you must\nuse the Integer form to remove objects.\n</p>\n<p>\nThis class is Serializable from Commons Collections 3.1.\n</p>\n\n@param <E> the type of elements in this bag\n@since 3.0\n", "original_string": "public class TransformedBag<E> extends TransformedCollection<E> implements Bag<E> {\n\n    /** Serialization version */\n    private static final long serialVersionUID = 5421170911299074185L;\n\n    /**\n     * Factory method to create a transforming bag that will transform\n     * existing contents of the specified bag.\n     * <p>\n     * If there are any elements already in the bag being decorated, they\n     * will be transformed by this method.\n     * Contrast this with {@link #transformingBag(Bag, Transformer)}.\n     *\n     * @param <E> the type of the elements in the bag\n     * @param bag  the bag to decorate, must not be null\n     * @param transformer  the transformer to use for conversion, must not be null\n     * @return a new transformed Bag\n     * @throws NullPointerException if bag or transformer is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> transformedBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        final TransformedBag<E> decorated = new TransformedBag<>(bag, transformer);\n        if (!bag.isEmpty()) {\n            @SuppressWarnings(\"unchecked\") // Bag is of type E\n            final E[] values = (E[]) bag.toArray(); // NOPMD - false positive for generics\n            bag.clear();\n            for (final E value : values) {\n                decorated.decorated().add(transformer.apply(value));\n            }\n        }\n        return decorated;\n    }\n\n    /**\n     * Factory method to create a transforming bag.\n     * <p>\n     * If there are any elements already in the bag being decorated, they\n     * are NOT transformed. Contrast this with {@link #transformedBag(Bag, Transformer)}.\n     *\n     * @param <E> the type of the elements in the bag\n     * @param bag  the bag to decorate, must not be null\n     * @param transformer  the transformer to use for conversion, must not be null\n     * @return a new transformed Bag\n     * @throws NullPointerException if bag or transformer is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        return new TransformedBag<>(bag, transformer);\n    }\n\n    /**\n     * Constructor that wraps (not copies).\n     * <p>\n     * If there are any elements already in the bag being decorated, they\n     * are NOT transformed.\n     *\n     * @param bag  the bag to decorate, must not be null\n     * @param transformer  the transformer to use for conversion, must not be null\n     * @throws NullPointerException if bag or transformer is null\n     */\n    protected TransformedBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        super(bag, transformer);\n    }\n\n    @Override\n    public boolean add(final E object, final int nCopies) {\n        return getBag().add(transform(object), nCopies);\n    }\n\n    @Override\n    public boolean equals(final Object object) {\n        return object == this || decorated().equals(object);\n    }\n\n    /**\n     * Gets the decorated bag.\n     *\n     * @return the decorated bag\n     */\n    protected Bag<E> getBag() {\n        return (Bag<E>) decorated();\n    }\n\n    @Override\n    public int getCount(final Object object) {\n        return getBag().getCount(object);\n    }\n\n    @Override\n    public int hashCode() {\n        return decorated().hashCode();\n    }\n\n    @Override\n    public boolean remove(final Object object, final int nCopies) {\n        return getBag().remove(object, nCopies);\n    }\n\n    @Override\n    public Set<E> uniqueSet() {\n        final Set<E> set = getBag().uniqueSet();\n        return TransformedSet.<E>transformingSet(set, transformer);\n    }\n\n}", "super_interfaces": ["Bag<E>"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 5421170911299074185L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 5421170911299074185L", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/bag/TreeBag.java.TreeBag", "name": "TreeBag", "file_path": "src/main/java/org/apache/commons/collections4/bag/TreeBag.java", "superclasses": "", "methods": ["[]TreeBag()", "[]TreeBag(Collection<? extends E>)", "[]TreeBag(Iterable<? extends E>)", "[]TreeBag(Comparator<? super E>)", "[boolean]add(E)", "[Comparator<? super E>]comparator()", "[E]first()", "[SortedMap<E, AbstractMapBag.MutableInteger>]getMap()", "[E]last()", "[void]readObject(ObjectInputStream)", "[void]writeObject(ObjectOutputStream)"], "method_uris": ["src/main/java/org/apache/commons/collections4/bag/TreeBag.java.TreeBag.[]TreeBag()", "src/main/java/org/apache/commons/collections4/bag/TreeBag.java.TreeBag.[]TreeBag(Collection<? extends E>)", "src/main/java/org/apache/commons/collections4/bag/TreeBag.java.TreeBag.[]TreeBag(Iterable<? extends E>)", "src/main/java/org/apache/commons/collections4/bag/TreeBag.java.TreeBag.[]TreeBag(Comparator<? super E>)", "src/main/java/org/apache/commons/collections4/bag/TreeBag.java.TreeBag.[boolean]add(E)", "src/main/java/org/apache/commons/collections4/bag/TreeBag.java.TreeBag.[Comparator<? super E>]comparator()", "src/main/java/org/apache/commons/collections4/bag/TreeBag.java.TreeBag.[E]first()", "src/main/java/org/apache/commons/collections4/bag/TreeBag.java.TreeBag.[SortedMap<E, AbstractMapBag.MutableInteger>]getMap()", "src/main/java/org/apache/commons/collections4/bag/TreeBag.java.TreeBag.[E]last()", "src/main/java/org/apache/commons/collections4/bag/TreeBag.java.TreeBag.[void]readObject(ObjectInputStream)", "src/main/java/org/apache/commons/collections4/bag/TreeBag.java.TreeBag.[void]writeObject(ObjectOutputStream)"], "overrides": null, "attributes": [], "class_docstring": "\nImplements {@link SortedBag}, using a {@link TreeMap} to provide the data storage.\nThis is the standard implementation of a sorted bag.\n<p>\nOrder will be maintained among the bag members and can be viewed through the iterator.\n</p>\n<p>\nA {@link org.apache.commons.collections4.Bag Bag} stores each object in the collection\ntogether with a count of occurrences. Extra methods on the interface allow multiple\ncopies of an object to be added or removed at once. It is important to read the interface\nJavadoc carefully as several methods violate the {@link Collection} interface specification.\n</p>\n\n@param <E> the type of elements in this bag\n@since 3.0 (previously in main package v2.0)\n", "original_string": "public class TreeBag<E> extends AbstractMapBag<E> implements SortedBag<E>, Serializable {\n\n    /** Serial version lock */\n    private static final long serialVersionUID = -7740146511091606676L;\n\n    /**\n     * Constructs an empty {@link TreeBag}.\n     */\n    public TreeBag() {\n        super(new TreeMap<>());\n    }\n\n    /**\n     * Constructs a {@link TreeBag} containing all the members of the\n     * specified collection.\n     *\n     * @param coll the collection to copy into the bag\n     */\n    public TreeBag(final Collection<? extends E> coll) {\n        this();\n        addAll(coll);\n    }\n\n    /**\n     * Constructs a bag containing all the members of the given Iterable.\n     *\n     * @param iterable an iterable to copy into this bag.\n     * @since 4.5.0-M3\n     */\n    public TreeBag(final Iterable<? extends E> iterable) {\n        super(new TreeMap<>(), iterable);\n    }\n\n    /**\n     * Constructs an empty bag that maintains order on its unique representative\n     * members according to the given {@link Comparator}.\n     *\n     * @param comparator the comparator to use\n     */\n    public TreeBag(final Comparator<? super E> comparator) {\n        super(new TreeMap<>(comparator));\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * @throws IllegalArgumentException if the object to be added does not implement\n     * {@link Comparable} and the {@link TreeBag} is using natural ordering\n     * @throws NullPointerException if the specified key is null and this bag uses\n     * natural ordering, or its comparator does not permit null keys\n     */\n    @Override\n    public boolean add(final E object) {\n        if (comparator() == null && !(object instanceof Comparable)) {\n            Objects.requireNonNull(object, \"object\");\n            throw new IllegalArgumentException(\"Objects of type \" + object.getClass() + \" cannot be added to \" +\n                                               \"a naturally ordered TreeBag as it does not implement Comparable\");\n        }\n        return super.add(object);\n    }\n\n    @Override\n    public Comparator<? super E> comparator() {\n        return getMap().comparator();\n    }\n\n    @Override\n    public E first() {\n        return getMap().firstKey();\n    }\n\n    @Override\n    protected SortedMap<E, AbstractMapBag.MutableInteger> getMap() {\n        return (SortedMap<E, AbstractMapBag.MutableInteger>) super.getMap();\n    }\n\n    @Override\n    public E last() {\n        return getMap().lastKey();\n    }\n\n    /**\n     * Deserializes the bag in using a custom routine.\n     *\n     * @param in  the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded\n     */\n    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        @SuppressWarnings(\"unchecked\")  // This will fail at runtime if the stream is incorrect\n        final Comparator<? super E> comp = (Comparator<? super E>) in.readObject();\n        super.doReadObject(new TreeMap<>(comp), in);\n    }\n\n    /**\n     * Serializes this object to an ObjectOutputStream.\n     *\n     * @param out the target ObjectOutputStream.\n     * @throws IOException thrown when an I/O errors occur writing to the target stream.\n     */\n    private void writeObject(final ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        out.writeObject(comparator());\n        super.doWriteObject(out);\n    }\n\n}", "super_interfaces": ["SortedBag<E>", "Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = -7740146511091606676L;", "docstring": " Serial version lock", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -7740146511091606676L", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/bag/UnmodifiableSortedBag.java.UnmodifiableSortedBag", "name": "UnmodifiableSortedBag", "file_path": "src/main/java/org/apache/commons/collections4/bag/UnmodifiableSortedBag.java", "superclasses": "", "methods": ["[SortedBag<E>]unmodifiableSortedBag(SortedBag<E>)", "[]UnmodifiableSortedBag(SortedBag<E>)", "[boolean]add(E)", "[boolean]add(E,int)", "[boolean]addAll(Collection<? extends E>)", "[void]clear()", "[Iterator<E>]iterator()", "[void]readObject(ObjectInputStream)", "[boolean]remove(Object)", "[boolean]remove(Object,int)", "[boolean]removeAll(Collection<?>)", "[boolean]removeIf(Predicate<? super E>)", "[boolean]retainAll(Collection<?>)", "[Set<E>]uniqueSet()", "[void]writeObject(ObjectOutputStream)"], "method_uris": ["src/main/java/org/apache/commons/collections4/bag/UnmodifiableSortedBag.java.UnmodifiableSortedBag.[SortedBag<E>]unmodifiableSortedBag(SortedBag<E>)", "src/main/java/org/apache/commons/collections4/bag/UnmodifiableSortedBag.java.UnmodifiableSortedBag.[]UnmodifiableSortedBag(SortedBag<E>)", "src/main/java/org/apache/commons/collections4/bag/UnmodifiableSortedBag.java.UnmodifiableSortedBag.[boolean]add(E)", "src/main/java/org/apache/commons/collections4/bag/UnmodifiableSortedBag.java.UnmodifiableSortedBag.[boolean]add(E,int)", "src/main/java/org/apache/commons/collections4/bag/UnmodifiableSortedBag.java.UnmodifiableSortedBag.[boolean]addAll(Collection<? extends E>)", "src/main/java/org/apache/commons/collections4/bag/UnmodifiableSortedBag.java.UnmodifiableSortedBag.[void]clear()", "src/main/java/org/apache/commons/collections4/bag/UnmodifiableSortedBag.java.UnmodifiableSortedBag.[Iterator<E>]iterator()", "src/main/java/org/apache/commons/collections4/bag/UnmodifiableSortedBag.java.UnmodifiableSortedBag.[void]readObject(ObjectInputStream)", "src/main/java/org/apache/commons/collections4/bag/UnmodifiableSortedBag.java.UnmodifiableSortedBag.[boolean]remove(Object)", "src/main/java/org/apache/commons/collections4/bag/UnmodifiableSortedBag.java.UnmodifiableSortedBag.[boolean]remove(Object,int)", "src/main/java/org/apache/commons/collections4/bag/UnmodifiableSortedBag.java.UnmodifiableSortedBag.[boolean]removeAll(Collection<?>)", "src/main/java/org/apache/commons/collections4/bag/UnmodifiableSortedBag.java.UnmodifiableSortedBag.[boolean]removeIf(Predicate<? super E>)", "src/main/java/org/apache/commons/collections4/bag/UnmodifiableSortedBag.java.UnmodifiableSortedBag.[boolean]retainAll(Collection<?>)", "src/main/java/org/apache/commons/collections4/bag/UnmodifiableSortedBag.java.UnmodifiableSortedBag.[Set<E>]uniqueSet()", "src/main/java/org/apache/commons/collections4/bag/UnmodifiableSortedBag.java.UnmodifiableSortedBag.[void]writeObject(ObjectOutputStream)"], "overrides": null, "attributes": [], "class_docstring": "\nDecorates another {@link SortedBag} to ensure it can't be altered.\n<p>\nThis class is Serializable from Commons Collections 3.1.\n</p>\n<p>\nAttempts to modify it will result in an UnsupportedOperationException.\n</p>\n\n@param <E> the type of elements in this bag\n@since 3.0\n", "original_string": "public final class UnmodifiableSortedBag<E>\n        extends AbstractSortedBagDecorator<E> implements Unmodifiable {\n\n    /** Serialization version */\n    private static final long serialVersionUID = -3190437252665717841L;\n\n    /**\n     * Factory method to create an unmodifiable bag.\n     * <p>\n     * If the bag passed in is already unmodifiable, it is returned.\n     *\n     * @param <E> the type of the elements in the bag\n     * @param bag  the bag to decorate, must not be null\n     * @return an unmodifiable SortedBag\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n        if (bag instanceof Unmodifiable) {\n            return bag;\n        }\n        return new UnmodifiableSortedBag<>(bag);\n    }\n\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param bag  the bag to decorate, must not be null\n     * @throws NullPointerException if bag is null\n     */\n    private UnmodifiableSortedBag(final SortedBag<E> bag) {\n        super(bag);\n    }\n\n    @Override\n    public boolean add(final E object) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public boolean add(final E object, final int count) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public boolean addAll(final Collection<? extends E> coll) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public void clear() {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public Iterator<E> iterator() {\n        return UnmodifiableIterator.unmodifiableIterator(decorated().iterator());\n    }\n\n    /**\n     * Deserializes the collection in using a custom routine.\n     *\n     * @param in  the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded\n     * @throws ClassCastException if deserialized object has wrong type\n     */\n    @SuppressWarnings(\"unchecked\") // will throw CCE, see Javadoc\n    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        setCollection((Collection<E>) in.readObject());\n    }\n\n    @Override\n    public boolean remove(final Object object) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public boolean remove(final Object object, final int count) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public boolean removeAll(final Collection<?> coll) {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * @since 4.4\n     */\n    @Override\n    public boolean removeIf(final Predicate<? super E> filter) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public boolean retainAll(final Collection<?> coll) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public Set<E> uniqueSet() {\n        final Set<E> set = decorated().uniqueSet();\n        return UnmodifiableSet.unmodifiableSet(set);\n    }\n\n    /**\n     * Serializes this object to an ObjectOutputStream.\n     *\n     * @param out the target ObjectOutputStream.\n     * @throws IOException thrown when an I/O errors occur writing to the target stream.\n     */\n    private void writeObject(final ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        out.writeObject(decorated());\n    }\n\n}", "super_interfaces": ["Unmodifiable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = -3190437252665717841L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -3190437252665717841L", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/bag/PredicatedSortedBag.java.PredicatedSortedBag", "name": "PredicatedSortedBag", "file_path": "src/main/java/org/apache/commons/collections4/bag/PredicatedSortedBag.java", "superclasses": "", "methods": ["[PredicatedSortedBag<E>]predicatedSortedBag(SortedBag<E>,Predicate<? super E>)", "[]PredicatedSortedBag(SortedBag<E>,Predicate<? super E>)", "[Comparator<? super E>]comparator()", "[SortedBag<E>]decorated()", "[E]first()", "[E]last()"], "method_uris": ["src/main/java/org/apache/commons/collections4/bag/PredicatedSortedBag.java.PredicatedSortedBag.[PredicatedSortedBag<E>]predicatedSortedBag(SortedBag<E>,Predicate<? super E>)", "src/main/java/org/apache/commons/collections4/bag/PredicatedSortedBag.java.PredicatedSortedBag.[]PredicatedSortedBag(SortedBag<E>,Predicate<? super E>)", "src/main/java/org/apache/commons/collections4/bag/PredicatedSortedBag.java.PredicatedSortedBag.[Comparator<? super E>]comparator()", "src/main/java/org/apache/commons/collections4/bag/PredicatedSortedBag.java.PredicatedSortedBag.[SortedBag<E>]decorated()", "src/main/java/org/apache/commons/collections4/bag/PredicatedSortedBag.java.PredicatedSortedBag.[E]first()", "src/main/java/org/apache/commons/collections4/bag/PredicatedSortedBag.java.PredicatedSortedBag.[E]last()"], "overrides": null, "attributes": [], "class_docstring": "\nDecorates another {@link SortedBag} to validate that additions\nmatch a specified predicate.\n<p>\nThis bag exists to provide validation for the decorated bag.\nIt is normally created to decorate an empty bag.\nIf an object cannot be added to the bag, an {@link IllegalArgumentException} is thrown.\n</p>\n<p>\nOne usage would be to ensure that no null entries are added to the bag.\n<pre>\nSortedBag bag = PredicatedSortedBag.predicatedSortedBag(new TreeBag(), NotNullPredicate.INSTANCE);\n</pre>\n<p>\nThis class is Serializable from Commons Collections 3.1.\n</p>\n\n@param <E> the type of elements in this bag\n@since 3.0\n", "original_string": "public class PredicatedSortedBag<E> extends PredicatedBag<E> implements SortedBag<E> {\n\n    /** Serialization version */\n    private static final long serialVersionUID = 3448581314086406616L;\n\n    /**\n     * Factory method to create a predicated (validating) bag.\n     * <p>\n     * If there are any elements already in the bag being decorated, they\n     * are validated.\n     *\n     * @param <E> the type of the elements in the bag\n     * @param bag  the bag to decorate, must not be null\n     * @param predicate  the predicate to use for validation, must not be null\n     * @return a new predicated SortedBag\n     * @throws NullPointerException if bag or predicate is null\n     * @throws IllegalArgumentException if the bag contains invalid elements\n     * @since 4.0\n     */\n    public static <E> PredicatedSortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n                                                                 final Predicate<? super E> predicate) {\n        return new PredicatedSortedBag<>(bag, predicate);\n    }\n\n    /**\n     * Constructor that wraps (not copies).\n     * <p>If there are any elements already in the bag being decorated, they\n     * are validated.\n     *\n     * @param bag  the bag to decorate, must not be null\n     * @param predicate  the predicate to use for validation, must not be null\n     * @throws NullPointerException if bag or predicate is null\n     * @throws IllegalArgumentException if the bag contains invalid elements\n     */\n    protected PredicatedSortedBag(final SortedBag<E> bag, final Predicate<? super E> predicate) {\n        super(bag, predicate);\n    }\n\n    @Override\n    public Comparator<? super E> comparator() {\n        return decorated().comparator();\n    }\n\n    /**\n     * Gets the decorated sorted bag.\n     *\n     * @return the decorated bag\n     */\n    @Override\n    protected SortedBag<E> decorated() {\n        return (SortedBag<E>) super.decorated();\n    }\n\n    @Override\n    public E first() {\n        return decorated().first();\n    }\n\n    @Override\n    public E last() {\n        return decorated().last();\n    }\n\n}", "super_interfaces": ["SortedBag<E>"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 3448581314086406616L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 3448581314086406616L", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/bag/UnmodifiableBag.java.UnmodifiableBag", "name": "UnmodifiableBag", "file_path": "src/main/java/org/apache/commons/collections4/bag/UnmodifiableBag.java", "superclasses": "", "methods": ["[Bag<E>]unmodifiableBag(Bag<? extends E>)", "[]UnmodifiableBag(Bag<? extends E>)", "[boolean]add(E)", "[boolean]add(E,int)", "[boolean]addAll(Collection<? extends E>)", "[void]clear()", "[Iterator<E>]iterator()", "[void]readObject(ObjectInputStream)", "[boolean]remove(Object)", "[boolean]remove(Object,int)", "[boolean]removeAll(Collection<?>)", "[boolean]removeIf(Predicate<? super E>)", "[boolean]retainAll(Collection<?>)", "[Set<E>]uniqueSet()", "[void]writeObject(ObjectOutputStream)"], "method_uris": ["src/main/java/org/apache/commons/collections4/bag/UnmodifiableBag.java.UnmodifiableBag.[Bag<E>]unmodifiableBag(Bag<? extends E>)", "src/main/java/org/apache/commons/collections4/bag/UnmodifiableBag.java.UnmodifiableBag.[]UnmodifiableBag(Bag<? extends E>)", "src/main/java/org/apache/commons/collections4/bag/UnmodifiableBag.java.UnmodifiableBag.[boolean]add(E)", "src/main/java/org/apache/commons/collections4/bag/UnmodifiableBag.java.UnmodifiableBag.[boolean]add(E,int)", "src/main/java/org/apache/commons/collections4/bag/UnmodifiableBag.java.UnmodifiableBag.[boolean]addAll(Collection<? extends E>)", "src/main/java/org/apache/commons/collections4/bag/UnmodifiableBag.java.UnmodifiableBag.[void]clear()", "src/main/java/org/apache/commons/collections4/bag/UnmodifiableBag.java.UnmodifiableBag.[Iterator<E>]iterator()", "src/main/java/org/apache/commons/collections4/bag/UnmodifiableBag.java.UnmodifiableBag.[void]readObject(ObjectInputStream)", "src/main/java/org/apache/commons/collections4/bag/UnmodifiableBag.java.UnmodifiableBag.[boolean]remove(Object)", "src/main/java/org/apache/commons/collections4/bag/UnmodifiableBag.java.UnmodifiableBag.[boolean]remove(Object,int)", "src/main/java/org/apache/commons/collections4/bag/UnmodifiableBag.java.UnmodifiableBag.[boolean]removeAll(Collection<?>)", "src/main/java/org/apache/commons/collections4/bag/UnmodifiableBag.java.UnmodifiableBag.[boolean]removeIf(Predicate<? super E>)", "src/main/java/org/apache/commons/collections4/bag/UnmodifiableBag.java.UnmodifiableBag.[boolean]retainAll(Collection<?>)", "src/main/java/org/apache/commons/collections4/bag/UnmodifiableBag.java.UnmodifiableBag.[Set<E>]uniqueSet()", "src/main/java/org/apache/commons/collections4/bag/UnmodifiableBag.java.UnmodifiableBag.[void]writeObject(ObjectOutputStream)"], "overrides": null, "attributes": [], "class_docstring": "\nDecorates another {@link Bag} to ensure it can't be altered.\n<p>\nThis class is Serializable from Commons Collections 3.1.\n</p>\n<p>\nAttempts to modify it will result in an UnsupportedOperationException.\n</p>\n\n@param <E> the type of elements in this bag\n@since 3.0\n", "original_string": "public final class UnmodifiableBag<E>\n        extends AbstractBagDecorator<E> implements Unmodifiable {\n\n    /** Serialization version */\n    private static final long serialVersionUID = -1873799975157099624L;\n\n    /**\n     * Factory method to create an unmodifiable bag.\n     * <p>\n     * If the bag passed in is already unmodifiable, it is returned.\n     *\n     * @param <E> the type of the elements in the bag\n     * @param bag  the bag to decorate, must not be null\n     * @return an unmodifiable Bag\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n        if (bag instanceof Unmodifiable) {\n            @SuppressWarnings(\"unchecked\") // safe to upcast\n            final Bag<E> tmpBag = (Bag<E>) bag;\n            return tmpBag;\n        }\n        return new UnmodifiableBag<>(bag);\n    }\n\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param bag  the bag to decorate, must not be null\n     * @throws NullPointerException if bag is null\n     */\n    @SuppressWarnings(\"unchecked\") // safe to upcast\n    private UnmodifiableBag(final Bag<? extends E> bag) {\n        super((Bag<E>) bag);\n    }\n\n    @Override\n    public boolean add(final E object) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public boolean add(final E object, final int count) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public boolean addAll(final Collection<? extends E> coll) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public void clear() {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public Iterator<E> iterator() {\n        return UnmodifiableIterator.<E>unmodifiableIterator(decorated().iterator());\n    }\n\n    /**\n     * Deserializes the collection in using a custom routine.\n     *\n     * @param in  the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded\n     * @throws ClassCastException if deserialized object has wrong type\n     */\n    @SuppressWarnings(\"unchecked\") // will throw CCE, see Javadoc\n    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        setCollection((Collection<E>) in.readObject());\n    }\n\n    @Override\n    public boolean remove(final Object object) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public boolean remove(final Object object, final int count) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public boolean removeAll(final Collection<?> coll) {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * @since 4.4\n     */\n    @Override\n    public boolean removeIf(final Predicate<? super E> filter) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public boolean retainAll(final Collection<?> coll) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public Set<E> uniqueSet() {\n        final Set<E> set = decorated().uniqueSet();\n        return UnmodifiableSet.<E>unmodifiableSet(set);\n    }\n\n    /**\n     * Serializes this object to an ObjectOutputStream.\n     *\n     * @param out the target ObjectOutputStream.\n     * @throws IOException thrown when an I/O errors occur writing to the target stream.\n     */\n    private void writeObject(final ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        out.writeObject(decorated());\n    }\n\n}", "super_interfaces": ["Unmodifiable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = -1873799975157099624L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -1873799975157099624L", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/bag/CollectionSortedBag.java.CollectionSortedBag", "name": "CollectionSortedBag", "file_path": "src/main/java/org/apache/commons/collections4/bag/CollectionSortedBag.java", "superclasses": "", "methods": ["[SortedBag<E>]collectionSortedBag(SortedBag<E>)", "[]CollectionSortedBag(SortedBag<E>)", "[boolean]add(E)", "[boolean]add(E,int)", "[boolean]addAll(Collection<? extends E>)", "[boolean]containsAll(Collection<?>)", "[void]readObject(ObjectInputStream)", "[boolean]remove(Object)", "[boolean]removeAll(Collection<?>)", "[boolean]retainAll(Collection<?>)", "[void]writeObject(ObjectOutputStream)"], "method_uris": ["src/main/java/org/apache/commons/collections4/bag/CollectionSortedBag.java.CollectionSortedBag.[SortedBag<E>]collectionSortedBag(SortedBag<E>)", "src/main/java/org/apache/commons/collections4/bag/CollectionSortedBag.java.CollectionSortedBag.[]CollectionSortedBag(SortedBag<E>)", "src/main/java/org/apache/commons/collections4/bag/CollectionSortedBag.java.CollectionSortedBag.[boolean]add(E)", "src/main/java/org/apache/commons/collections4/bag/CollectionSortedBag.java.CollectionSortedBag.[boolean]add(E,int)", "src/main/java/org/apache/commons/collections4/bag/CollectionSortedBag.java.CollectionSortedBag.[boolean]addAll(Collection<? extends E>)", "src/main/java/org/apache/commons/collections4/bag/CollectionSortedBag.java.CollectionSortedBag.[boolean]containsAll(Collection<?>)", "src/main/java/org/apache/commons/collections4/bag/CollectionSortedBag.java.CollectionSortedBag.[void]readObject(ObjectInputStream)", "src/main/java/org/apache/commons/collections4/bag/CollectionSortedBag.java.CollectionSortedBag.[boolean]remove(Object)", "src/main/java/org/apache/commons/collections4/bag/CollectionSortedBag.java.CollectionSortedBag.[boolean]removeAll(Collection<?>)", "src/main/java/org/apache/commons/collections4/bag/CollectionSortedBag.java.CollectionSortedBag.[boolean]retainAll(Collection<?>)", "src/main/java/org/apache/commons/collections4/bag/CollectionSortedBag.java.CollectionSortedBag.[void]writeObject(ObjectOutputStream)"], "overrides": null, "attributes": [], "class_docstring": "\nDecorates another {@link SortedBag} to comply with the Collection contract.\n\n@param <E> the type of elements in this bag\n@since 4.0\n", "original_string": "public final class CollectionSortedBag<E> extends AbstractSortedBagDecorator<E> {\n\n    /** Serialization version */\n    private static final long serialVersionUID = -2560033712679053143L;\n\n    /**\n     * Factory method to create a sorted bag that complies to the Collection contract.\n     *\n     * @param <E> the type of the elements in the bag\n     * @param bag  the sorted bag to decorate, must not be null\n     * @return a SortedBag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     */\n    public static <E> SortedBag<E> collectionSortedBag(final SortedBag<E> bag) {\n        return new CollectionSortedBag<>(bag);\n    }\n\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param bag  the sorted bag to decorate, must not be null\n     * @throws NullPointerException if bag is null\n     */\n    public CollectionSortedBag(final SortedBag<E> bag) {\n        super(bag);\n    }\n\n    @Override\n    public boolean add(final E object) {\n        return add(object, 1);\n    }\n\n    @Override\n    public boolean add(final E object, final int count) {\n        decorated().add(object, count);\n        return true;\n    }\n\n    // Collection interface\n\n    @Override\n    public boolean addAll(final Collection<? extends E> coll) {\n        boolean changed = false;\n        for (final E current : coll) {\n            final boolean added = add(current, 1);\n            changed = changed || added;\n        }\n        return changed;\n    }\n\n    @Override\n    public boolean containsAll(final Collection<?> coll) {\n        return coll.stream().allMatch(this::contains);\n    }\n\n    /**\n     * Deserializes the collection in using a custom routine.\n     *\n     * @param in  the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded\n     * @throws ClassCastException if deserialized object has wrong type\n     */\n    @SuppressWarnings(\"unchecked\") // will throw CCE, see Javadoc\n    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        setCollection((Collection<E>) in.readObject());\n    }\n\n    @Override\n    public boolean remove(final Object object) {\n        return remove(object, 1);\n    }\n\n    @Override\n    public boolean removeAll(final Collection<?> coll) {\n        if (coll != null) {\n            boolean result = false;\n            for (final Object obj : coll) {\n                final boolean changed = remove(obj, getCount(obj));\n                result = result || changed;\n            }\n            return result;\n        }\n        // let the decorated bag handle the case of null argument\n        return decorated().removeAll(null);\n    }\n\n    @Override\n    public boolean retainAll(final Collection<?> coll) {\n        if (coll != null) {\n            boolean modified = false;\n            final Iterator<E> e = iterator();\n            while (e.hasNext()) {\n                if (!coll.contains(e.next())) {\n                    e.remove();\n                    modified = true;\n                }\n            }\n            return modified;\n        }\n        // let the decorated bag handle the case of null argument\n        return decorated().retainAll(null);\n    }\n\n    /**\n     * Serializes this object to an ObjectOutputStream.\n     *\n     * @param out the target ObjectOutputStream.\n     * @throws IOException thrown when an I/O errors occur writing to the target stream.\n     */\n    private void writeObject(final ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        out.writeObject(decorated());\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = -2560033712679053143L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -2560033712679053143L", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/bag/SynchronizedSortedBag.java.SynchronizedSortedBag", "name": "SynchronizedSortedBag", "file_path": "src/main/java/org/apache/commons/collections4/bag/SynchronizedSortedBag.java", "superclasses": "", "methods": ["[SynchronizedSortedBag<E>]synchronizedSortedBag(SortedBag<E>)", "[]SynchronizedSortedBag(Bag<E>,Object)", "[]SynchronizedSortedBag(SortedBag<E>)", "[Comparator<? super E>]comparator()", "[E]first()", "[SortedBag<E>]getSortedBag()", "[E]last()"], "method_uris": ["src/main/java/org/apache/commons/collections4/bag/SynchronizedSortedBag.java.SynchronizedSortedBag.[SynchronizedSortedBag<E>]synchronizedSortedBag(SortedBag<E>)", "src/main/java/org/apache/commons/collections4/bag/SynchronizedSortedBag.java.SynchronizedSortedBag.[]SynchronizedSortedBag(Bag<E>,Object)", "src/main/java/org/apache/commons/collections4/bag/SynchronizedSortedBag.java.SynchronizedSortedBag.[]SynchronizedSortedBag(SortedBag<E>)", "src/main/java/org/apache/commons/collections4/bag/SynchronizedSortedBag.java.SynchronizedSortedBag.[Comparator<? super E>]comparator()", "src/main/java/org/apache/commons/collections4/bag/SynchronizedSortedBag.java.SynchronizedSortedBag.[E]first()", "src/main/java/org/apache/commons/collections4/bag/SynchronizedSortedBag.java.SynchronizedSortedBag.[SortedBag<E>]getSortedBag()", "src/main/java/org/apache/commons/collections4/bag/SynchronizedSortedBag.java.SynchronizedSortedBag.[E]last()"], "overrides": null, "attributes": [], "class_docstring": "\nDecorates another {@link SortedBag} to synchronize its behavior\nfor a multithreaded environment.\n<p>\nMethods are synchronized, then forwarded to the decorated bag.\nIterators must be separately synchronized around the loop.\n</p>\n<p>\nThis class is Serializable from Commons Collections 3.1.\n</p>\n\n@param <E> the type of elements in this bag\n@since 3.0\n", "original_string": "public class SynchronizedSortedBag<E> extends SynchronizedBag<E> implements SortedBag<E> {\n\n    /** Serialization version */\n    private static final long serialVersionUID = 722374056718497858L;\n\n    /**\n     * Factory method to create a synchronized sorted bag.\n     *\n     * @param <E> the type of the elements in the bag\n     * @param bag  the bag to decorate, must not be null\n     * @return a new synchronized SortedBag\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> SynchronizedSortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n        return new SynchronizedSortedBag<>(bag);\n    }\n\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param bag  the bag to decorate, must not be null\n     * @param lock  the lock to use, must not be null\n     * @throws NullPointerException if bag or lock is null\n     */\n    protected SynchronizedSortedBag(final Bag<E> bag, final Object lock) {\n        super(bag, lock);\n    }\n\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param bag  the bag to decorate, must not be null\n     * @throws NullPointerException if bag is null\n     */\n    protected SynchronizedSortedBag(final SortedBag<E> bag) {\n        super(bag);\n    }\n\n    @Override\n    public synchronized Comparator<? super E> comparator() {\n        synchronized (lock) {\n            return getSortedBag().comparator();\n        }\n    }\n\n    @Override\n    public synchronized E first() {\n        synchronized (lock) {\n            return getSortedBag().first();\n        }\n    }\n\n    /**\n     * Gets the bag being decorated.\n     *\n     * @return the decorated bag\n     */\n    protected SortedBag<E> getSortedBag() {\n        return (SortedBag<E>) decorated();\n    }\n\n    @Override\n    public synchronized E last() {\n        synchronized (lock) {\n            return getSortedBag().last();\n        }\n    }\n\n}", "super_interfaces": ["SortedBag<E>"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 722374056718497858L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 722374056718497858L", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/bag/TransformedSortedBag.java.TransformedSortedBag", "name": "TransformedSortedBag", "file_path": "src/main/java/org/apache/commons/collections4/bag/TransformedSortedBag.java", "superclasses": "", "methods": ["[TransformedSortedBag<E>]transformedSortedBag(SortedBag<E>,Transformer<? super E, ? extends E>)", "[TransformedSortedBag<E>]transformingSortedBag(SortedBag<E>,Transformer<? super E, ? extends E>)", "[]TransformedSortedBag(SortedBag<E>,Transformer<? super E, ? extends E>)", "[Comparator<? super E>]comparator()", "[E]first()", "[SortedBag<E>]getSortedBag()", "[E]last()"], "method_uris": ["src/main/java/org/apache/commons/collections4/bag/TransformedSortedBag.java.TransformedSortedBag.[TransformedSortedBag<E>]transformedSortedBag(SortedBag<E>,Transformer<? super E, ? extends E>)", "src/main/java/org/apache/commons/collections4/bag/TransformedSortedBag.java.TransformedSortedBag.[TransformedSortedBag<E>]transformingSortedBag(SortedBag<E>,Transformer<? super E, ? extends E>)", "src/main/java/org/apache/commons/collections4/bag/TransformedSortedBag.java.TransformedSortedBag.[]TransformedSortedBag(SortedBag<E>,Transformer<? super E, ? extends E>)", "src/main/java/org/apache/commons/collections4/bag/TransformedSortedBag.java.TransformedSortedBag.[Comparator<? super E>]comparator()", "src/main/java/org/apache/commons/collections4/bag/TransformedSortedBag.java.TransformedSortedBag.[E]first()", "src/main/java/org/apache/commons/collections4/bag/TransformedSortedBag.java.TransformedSortedBag.[SortedBag<E>]getSortedBag()", "src/main/java/org/apache/commons/collections4/bag/TransformedSortedBag.java.TransformedSortedBag.[E]last()"], "overrides": null, "attributes": [], "class_docstring": "\nDecorates another {@link SortedBag} to transform objects that are added.\n<p>\nThe add methods are affected by this class.\nThus objects must be removed or searched for using their transformed form.\nFor example, if the transformation converts Strings to Integers, you must\nuse the Integer form to remove objects.\n</p>\n<p>\nThis class is Serializable from Commons Collections 3.1.\n</p>\n\n@param <E> the type of elements in this bag\n@since 3.0\n", "original_string": "public class TransformedSortedBag<E> extends TransformedBag<E> implements SortedBag<E> {\n\n    /** Serialization version */\n    private static final long serialVersionUID = -251737742649401930L;\n\n    /**\n     * Factory method to create a transforming sorted bag that will transform\n     * existing contents of the specified sorted bag.\n     * <p>\n     * If there are any elements already in the bag being decorated, they\n     * will be transformed by this method.\n     * Contrast this with {@link #transformingSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the type of the elements in the bag\n     * @param bag  the bag to decorate, must not be null\n     * @param transformer  the transformer to use for conversion, must not be null\n     * @return a new transformed SortedBag\n     * @throws NullPointerException if bag or transformer is null\n     * @since 4.0\n     */\n    public static <E> TransformedSortedBag<E> transformedSortedBag(final SortedBag<E> bag,\n            final Transformer<? super E, ? extends E> transformer) {\n\n        final TransformedSortedBag<E>  decorated = new TransformedSortedBag<>(bag, transformer);\n        if (!bag.isEmpty()) {\n            @SuppressWarnings(\"unchecked\") // bag is type E\n            final E[] values = (E[]) bag.toArray(); // NOPMD - false positive for generics\n            bag.clear();\n            for (final E value : values) {\n                decorated.decorated().add(transformer.apply(value));\n            }\n        }\n        return decorated;\n    }\n\n    /**\n     * Factory method to create a transforming sorted bag.\n     * <p>\n     * If there are any elements already in the bag being decorated, they\n     * are NOT transformed. Contrast this with {@link #transformedSortedBag(SortedBag, Transformer)}.\n     *\n     * @param <E> the type of the elements in the bag\n     * @param bag  the bag to decorate, must not be null\n     * @param transformer  the transformer to use for conversion, must not be null\n     * @return a new transformed SortedBag\n     * @throws NullPointerException if bag or transformer is null\n     * @since 4.0\n     */\n    public static <E> TransformedSortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n            final Transformer<? super E, ? extends E> transformer) {\n        return new TransformedSortedBag<>(bag, transformer);\n    }\n\n    /**\n     * Constructor that wraps (not copies).\n     * <p>\n     * If there are any elements already in the bag being decorated, they\n     * are NOT transformed.\n     *\n     * @param bag  the bag to decorate, must not be null\n     * @param transformer  the transformer to use for conversion, must not be null\n     * @throws NullPointerException if bag or transformer is null\n     */\n    protected TransformedSortedBag(final SortedBag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n        super(bag, transformer);\n    }\n\n    @Override\n    public Comparator<? super E> comparator() {\n        return getSortedBag().comparator();\n    }\n\n    @Override\n    public E first() {\n        return getSortedBag().first();\n    }\n\n    /**\n     * Gets the decorated bag.\n     *\n     * @return the decorated bag\n     */\n    protected SortedBag<E> getSortedBag() {\n        return (SortedBag<E>) decorated();\n    }\n\n    @Override\n    public E last() {\n        return getSortedBag().last();\n    }\n\n}", "super_interfaces": ["SortedBag<E>"], "fields": [{"attribute_expression": "private static final long serialVersionUID = -251737742649401930L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -251737742649401930L", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/bag/HashBag.java.HashBag", "name": "HashBag", "file_path": "src/main/java/org/apache/commons/collections4/bag/HashBag.java", "superclasses": "", "methods": ["[]HashBag()", "[]HashBag(Collection<? extends E>)", "[]HashBag(Iterable<? extends E>)", "[void]readObject(ObjectInputStream)", "[void]writeObject(ObjectOutputStream)"], "method_uris": ["src/main/java/org/apache/commons/collections4/bag/HashBag.java.HashBag.[]HashBag()", "src/main/java/org/apache/commons/collections4/bag/HashBag.java.HashBag.[]HashBag(Collection<? extends E>)", "src/main/java/org/apache/commons/collections4/bag/HashBag.java.HashBag.[]HashBag(Iterable<? extends E>)", "src/main/java/org/apache/commons/collections4/bag/HashBag.java.HashBag.[void]readObject(ObjectInputStream)", "src/main/java/org/apache/commons/collections4/bag/HashBag.java.HashBag.[void]writeObject(ObjectOutputStream)"], "overrides": null, "attributes": [], "class_docstring": "\nImplements {@code Bag}, using a {@link HashMap} to provide the\ndata storage. This is the standard implementation of a bag.\n<p>\nA {@code Bag} stores each object in the collection together with a\ncount of occurrences. Extra methods on the interface allow multiple copies\nof an object to be added or removed at once. It is important to read the\ninterface Javadoc carefully as several methods violate the\n{@link Collection} interface specification.\n</p>\n\n@param <E> the type of elements in this bag\n@since 3.0 (previously in main package v2.0)\n", "original_string": "public class HashBag<E> extends AbstractMapBag<E> implements Serializable {\n\n    /** Serial version lock */\n    private static final long serialVersionUID = -6561115435802554013L;\n\n    /**\n     * Constructs an empty {@link HashBag}.\n     */\n    public HashBag() {\n        super(new HashMap<>());\n    }\n\n    /**\n     * Constructs a bag containing all the members of the given Collection.\n     *\n     * @param collection a collection to copy into this bag.\n     */\n    public HashBag(final Collection<? extends E> collection) {\n        this();\n        addAll(collection);\n    }\n\n    /**\n     * Constructs a bag containing all the members of the given Iterable.\n     *\n     * @param iterable an iterable to copy into this bag.\n     * @since 4.5.0-M3\n     */\n    public HashBag(final Iterable<? extends E> iterable) {\n        super(new HashMap<>(), iterable);\n    }\n\n    /**\n     * Deserializes the bag in using a custom routine.\n     *\n     * @param in  the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded\n     */\n    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        super.doReadObject(new HashMap<>(), in);\n    }\n\n    /**\n     * Serializes this object to an ObjectOutputStream.\n     *\n     * @param out the target ObjectOutputStream.\n     * @throws IOException thrown when an I/O errors occur writing to the target stream.\n     */\n    private void writeObject(final ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        super.doWriteObject(out);\n    }\n\n}", "super_interfaces": ["Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = -6561115435802554013L;", "docstring": " Serial version lock", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -6561115435802554013L", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/bag/CollectionBag.java.CollectionBag", "name": "CollectionBag", "file_path": "src/main/java/org/apache/commons/collections4/bag/CollectionBag.java", "superclasses": "", "methods": ["[Bag<E>]collectionBag(Bag<E>)", "[]CollectionBag(Bag<E>)", "[boolean]add(E)", "[boolean]add(E,int)", "[boolean]addAll(Collection<? extends E>)", "[boolean]containsAll(Collection<?>)", "[void]readObject(ObjectInputStream)", "[boolean]remove(Object)", "[boolean]removeAll(Collection<?>)", "[boolean]retainAll(Collection<?>)", "[void]writeObject(ObjectOutputStream)"], "method_uris": ["src/main/java/org/apache/commons/collections4/bag/CollectionBag.java.CollectionBag.[Bag<E>]collectionBag(Bag<E>)", "src/main/java/org/apache/commons/collections4/bag/CollectionBag.java.CollectionBag.[]CollectionBag(Bag<E>)", "src/main/java/org/apache/commons/collections4/bag/CollectionBag.java.CollectionBag.[boolean]add(E)", "src/main/java/org/apache/commons/collections4/bag/CollectionBag.java.CollectionBag.[boolean]add(E,int)", "src/main/java/org/apache/commons/collections4/bag/CollectionBag.java.CollectionBag.[boolean]addAll(Collection<? extends E>)", "src/main/java/org/apache/commons/collections4/bag/CollectionBag.java.CollectionBag.[boolean]containsAll(Collection<?>)", "src/main/java/org/apache/commons/collections4/bag/CollectionBag.java.CollectionBag.[void]readObject(ObjectInputStream)", "src/main/java/org/apache/commons/collections4/bag/CollectionBag.java.CollectionBag.[boolean]remove(Object)", "src/main/java/org/apache/commons/collections4/bag/CollectionBag.java.CollectionBag.[boolean]removeAll(Collection<?>)", "src/main/java/org/apache/commons/collections4/bag/CollectionBag.java.CollectionBag.[boolean]retainAll(Collection<?>)", "src/main/java/org/apache/commons/collections4/bag/CollectionBag.java.CollectionBag.[void]writeObject(ObjectOutputStream)"], "overrides": null, "attributes": [], "class_docstring": "\nDecorates another {@link Bag} to comply with the Collection contract.\n<p>\nBy decorating an existing {@link Bag} instance with a {@link CollectionBag},\nit can be safely passed on to methods that require Collection types that\nare fully compliant with the Collection contract.\n</p>\n<p>\nThe method Javadoc highlights the differences compared to the original Bag interface.\n</p>\n\n@see Bag\n@param <E> the type of elements in this bag\n@since 4.0\n", "original_string": "public final class CollectionBag<E> extends AbstractBagDecorator<E> {\n\n    /** Serialization version */\n    private static final long serialVersionUID = -2560033712679053143L;\n\n    /**\n     * Factory method to create a bag that complies to the Collection contract.\n     *\n     * @param <E> the type of the elements in the bag\n     * @param bag  the bag to decorate, must not be null\n     * @return a Bag that complies to the Collection contract\n     * @throws NullPointerException if bag is null\n     */\n    public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n        return new CollectionBag<>(bag);\n    }\n\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param bag  the bag to decorate, must not be null\n     * @throws NullPointerException if bag is null\n     */\n    public CollectionBag(final Bag<E> bag) {\n        super(bag);\n    }\n\n    /**\n     * <em>(Change)</em>\n     * Adds one copy of the specified object to the Bag.\n     * <p>\n     * Since this method always increases the size of the bag, it\n     * will always return {@code true}.\n     *\n     * @param object  the object to add\n     * @return {@code true}, always\n     */\n    @Override\n    public boolean add(final E object) {\n        return add(object, 1);\n    }\n\n    /**\n     * <em>(Change)</em>\n     * Adds {@code count} copies of the specified object to the Bag.\n     * <p>\n     * Since this method always increases the size of the bag, it\n     * will always return {@code true}.\n     *\n     * @param object  the object to add\n     * @param count  the number of copies to add\n     * @return {@code true}, always\n     */\n    @Override\n    public boolean add(final E object, final int count) {\n        decorated().add(object, count);\n        return true;\n    }\n\n    // Collection interface\n\n    @Override\n    public boolean addAll(final Collection<? extends E> coll) {\n        boolean changed = false;\n        for (final E current : coll) {\n            final boolean added = add(current, 1);\n            changed = changed || added;\n        }\n        return changed;\n    }\n\n    /**\n     * <em>(Change)</em>\n     * Returns {@code true} if the bag contains all elements in\n     * the given collection, <b>not</b> respecting cardinality. That is,\n     * if the given collection {@code coll} contains at least one of\n     * every object contained in this object.\n     *\n     * @param coll  the collection to check against\n     * @return {@code true} if the Bag contains at least one of every object in the collection\n     */\n    @Override\n    public boolean containsAll(final Collection<?> coll) {\n        return coll.stream().allMatch(this::contains);\n    }\n\n    /**\n     * Read the collection in using a custom routine.\n     *\n     * @param in  the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded\n     * @throws ClassCastException if deserialized object has wrong type\n     */\n    @SuppressWarnings(\"unchecked\") // will throw CCE, see Javadoc\n    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        setCollection((Collection<E>) in.readObject());\n    }\n\n    /**\n     * <em>(Change)</em>\n     * Removes the first occurrence of the given object from the bag.\n     * <p>\n     * This will also remove the object from the {@link #uniqueSet()} if the\n     * bag contains no occurrence anymore of the object after this operation.\n     *\n     * @param object  the object to remove\n     * @return {@code true} if this call changed the collection\n     */\n    @Override\n    public boolean remove(final Object object) {\n        return remove(object, 1);\n    }\n\n    /**\n     * <em>(Change)</em>\n     * Remove all elements represented in the given collection,\n     * <b>not</b> respecting cardinality. That is, remove <em>all</em>\n     * occurrences of every object contained in the given collection.\n     *\n     * @param coll  the collection to remove\n     * @return {@code true} if this call changed the collection\n     */\n    @Override\n    public boolean removeAll(final Collection<?> coll) {\n        if (coll != null) {\n            boolean result = false;\n            for (final Object obj : coll) {\n                final boolean changed = remove(obj, getCount(obj));\n                result = result || changed;\n            }\n            return result;\n        }\n        // let the decorated bag handle the case of null argument\n        return decorated().removeAll(null);\n    }\n\n    /**\n     * <em>(Change)</em>\n     * Remove any members of the bag that are not in the given collection,\n     * <em>not</em> respecting cardinality. That is, any object in the given\n     * collection {@code coll} will be retained in the bag with the same\n     * number of copies prior to this operation. All other objects will be\n     * completely removed from this bag.\n     * <p>\n     * This implementation iterates over the elements of this bag, checking\n     * each element in turn to see if it's contained in {@code coll}.\n     * If it's not contained, it's removed from this bag. As a consequence,\n     * it is advised to use a collection type for {@code coll} that provides\n     * a fast (e.g. O(1)) implementation of {@link Collection#contains(Object)}.\n     *\n     * @param coll  the collection to retain\n     * @return {@code true} if this call changed the collection\n     */\n    @Override\n    public boolean retainAll(final Collection<?> coll) {\n        if (coll != null) {\n            boolean modified = false;\n            final Iterator<E> e = iterator();\n            while (e.hasNext()) {\n                if (!coll.contains(e.next())) {\n                    e.remove();\n                    modified = true;\n                }\n            }\n            return modified;\n        }\n        // let the decorated bag handle the case of null argument\n        return decorated().retainAll(null);\n    }\n\n    // Bag interface\n\n    /**\n     * Write the collection out using a custom routine.\n     *\n     * @param out  the output stream\n     * @throws IOException if an error occurs while writing to the stream\n     */\n    private void writeObject(final ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        out.writeObject(decorated());\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = -2560033712679053143L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -2560033712679053143L", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/bag/PredicatedBag.java.PredicatedBag", "name": "PredicatedBag", "file_path": "src/main/java/org/apache/commons/collections4/bag/PredicatedBag.java", "superclasses": "", "methods": ["[PredicatedBag<E>]predicatedBag(Bag<E>,Predicate<? super E>)", "[]PredicatedBag(Bag<E>,Predicate<? super E>)", "[boolean]add(E,int)", "[Bag<E>]decorated()", "[boolean]equals(Object)", "[int]getCount(Object)", "[int]hashCode()", "[boolean]remove(Object,int)", "[Set<E>]uniqueSet()"], "method_uris": ["src/main/java/org/apache/commons/collections4/bag/PredicatedBag.java.PredicatedBag.[PredicatedBag<E>]predicatedBag(Bag<E>,Predicate<? super E>)", "src/main/java/org/apache/commons/collections4/bag/PredicatedBag.java.PredicatedBag.[]PredicatedBag(Bag<E>,Predicate<? super E>)", "src/main/java/org/apache/commons/collections4/bag/PredicatedBag.java.PredicatedBag.[boolean]add(E,int)", "src/main/java/org/apache/commons/collections4/bag/PredicatedBag.java.PredicatedBag.[Bag<E>]decorated()", "src/main/java/org/apache/commons/collections4/bag/PredicatedBag.java.PredicatedBag.[boolean]equals(Object)", "src/main/java/org/apache/commons/collections4/bag/PredicatedBag.java.PredicatedBag.[int]getCount(Object)", "src/main/java/org/apache/commons/collections4/bag/PredicatedBag.java.PredicatedBag.[int]hashCode()", "src/main/java/org/apache/commons/collections4/bag/PredicatedBag.java.PredicatedBag.[boolean]remove(Object,int)", "src/main/java/org/apache/commons/collections4/bag/PredicatedBag.java.PredicatedBag.[Set<E>]uniqueSet()"], "overrides": null, "attributes": [], "class_docstring": "\nDecorates another {@link Bag} to validate that additions\nmatch a specified predicate.\n<p>\nThis bag exists to provide validation for the decorated bag.\nIt is normally created to decorate an empty bag.\nIf an object cannot be added to the bag, an {@link IllegalArgumentException} is thrown.\n</p>\n<p>\nOne usage would be to ensure that no null entries are added to the bag.\n</p>\n<pre>\nBag bag = PredicatedBag.predicatedBag(new HashBag(), NotNullPredicate.INSTANCE);\n</pre>\n<p>\nThis class is Serializable from Commons Collections 3.1.\n</p>\n\n@param <E> the type of elements in this bag\n@since 3.0\n", "original_string": "public class PredicatedBag<E> extends PredicatedCollection<E> implements Bag<E> {\n\n    /** Serialization version */\n    private static final long serialVersionUID = -2575833140344736876L;\n\n    /**\n     * Factory method to create a predicated (validating) bag.\n     * <p>\n     * If there are any elements already in the bag being decorated, they\n     * are validated.\n     *\n     * @param <E> the type of the elements in the bag\n     * @param bag  the bag to decorate, must not be null\n     * @param predicate  the predicate to use for validation, must not be null\n     * @return a new predicated Bag\n     * @throws NullPointerException if bag or predicate is null\n     * @throws IllegalArgumentException if the bag contains invalid elements\n     * @since 4.0\n     */\n    public static <E> PredicatedBag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        return new PredicatedBag<>(bag, predicate);\n    }\n\n    /**\n     * Constructor that wraps (not copies).\n     * <p>\n     * If there are any elements already in the bag being decorated, they\n     * are validated.\n     *\n     * @param bag  the bag to decorate, must not be null\n     * @param predicate  the predicate to use for validation, must not be null\n     * @throws NullPointerException if bag or predicate is null\n     * @throws IllegalArgumentException if the bag contains invalid elements\n     */\n    protected PredicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n        super(bag, predicate);\n    }\n\n    @Override\n    public boolean add(final E object, final int count) {\n        validate(object);\n        return decorated().add(object, count);\n    }\n\n    /**\n     * Gets the decorated bag.\n     *\n     * @return the decorated bag\n     */\n    @Override\n    protected Bag<E> decorated() {\n        return (Bag<E>) super.decorated();\n    }\n\n    @Override\n    public boolean equals(final Object object) {\n        return object == this || decorated().equals(object);\n    }\n\n    @Override\n    public int getCount(final Object object) {\n        return decorated().getCount(object);\n    }\n\n    @Override\n    public int hashCode() {\n        return decorated().hashCode();\n    }\n\n    @Override\n    public boolean remove(final Object object, final int count) {\n        return decorated().remove(object, count);\n    }\n\n    @Override\n    public Set<E> uniqueSet() {\n        return decorated().uniqueSet();\n    }\n\n}", "super_interfaces": ["Bag<E>"], "fields": [{"attribute_expression": "private static final long serialVersionUID = -2575833140344736876L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -2575833140344736876L", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/bag/SynchronizedBag.java.SynchronizedBag", "name": "SynchronizedBag", "file_path": "src/main/java/org/apache/commons/collections4/bag/SynchronizedBag.java", "superclasses": "", "methods": ["[SynchronizedBag<E>]synchronizedBag(Bag<E>)", "[]SynchronizedBag(Bag<E>)", "[]SynchronizedBag(Bag<E>,Object)", "[boolean]add(E,int)", "[boolean]equals(Object)", "[Bag<E>]getBag()", "[int]getCount(Object)", "[int]hashCode()", "[boolean]remove(Object,int)", "[Set<E>]uniqueSet()"], "method_uris": ["src/main/java/org/apache/commons/collections4/bag/SynchronizedBag.java.SynchronizedBag.[SynchronizedBag<E>]synchronizedBag(Bag<E>)", "src/main/java/org/apache/commons/collections4/bag/SynchronizedBag.java.SynchronizedBag.[]SynchronizedBag(Bag<E>)", "src/main/java/org/apache/commons/collections4/bag/SynchronizedBag.java.SynchronizedBag.[]SynchronizedBag(Bag<E>,Object)", "src/main/java/org/apache/commons/collections4/bag/SynchronizedBag.java.SynchronizedBag.[boolean]add(E,int)", "src/main/java/org/apache/commons/collections4/bag/SynchronizedBag.java.SynchronizedBag.[boolean]equals(Object)", "src/main/java/org/apache/commons/collections4/bag/SynchronizedBag.java.SynchronizedBag.[Bag<E>]getBag()", "src/main/java/org/apache/commons/collections4/bag/SynchronizedBag.java.SynchronizedBag.[int]getCount(Object)", "src/main/java/org/apache/commons/collections4/bag/SynchronizedBag.java.SynchronizedBag.[int]hashCode()", "src/main/java/org/apache/commons/collections4/bag/SynchronizedBag.java.SynchronizedBag.[boolean]remove(Object,int)", "src/main/java/org/apache/commons/collections4/bag/SynchronizedBag.java.SynchronizedBag.[Set<E>]uniqueSet()"], "overrides": null, "attributes": [{"original_string": "    final class SynchronizedBagSet extends SynchronizedCollection<E> implements Set<E> {\n        /** Serialization version */\n        private static final long serialVersionUID = 2990565892366827855L;\n\n        /**\n         * Constructs a new instance.\n         * @param set  the set to decorate\n         * @param lock  the lock to use, shared with the bag\n         */\n        SynchronizedBagSet(final Set<E> set, final Object lock) {\n            super(set, lock);\n        }\n    }", "definition": "    final class SynchronizedBagSet extends SynchronizedCollection<E> implements Set<E>", "class_docstring": "\nSynchronized Set for the Bag class.\n", "name": "SynchronizedBagSet", "super_interfaces": ["Set<E>"], "superclasses": "", "attributes": {"modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = 2990565892366827855L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 2990565892366827855L", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        SynchronizedBagSet(final Set<E> set, final Object lock) {\n            super(set, lock);\n        }", "docstring": "\nConstructs a new instance.\n@param set  the set to decorate\n@param lock  the lock to use, shared with the bag\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "SynchronizedBagSet", "params": [{"name": "set", "type": "Set<E>"}, {"name": "lock", "type": "Object"}], "body": "                                                                {\n            super(set, lock);\n        }", "signature": "SynchronizedBagSet(final Set<E> set, final Object lock)"}]}], "class_docstring": "\nDecorates another {@link Bag} to synchronize its behavior\nfor a multithreaded environment.\n<p>\nMethods are synchronized, then forwarded to the decorated bag.\nIterators must be separately synchronized around the loop.\n</p>\n<p>\nThis class is Serializable from Commons Collections 3.1.\n</p>\n\n@param <E> the type of elements in this bag\n@since 3.0\n", "original_string": "public class SynchronizedBag<E> extends SynchronizedCollection<E> implements Bag<E> {\n\n    /**\n     * Synchronized Set for the Bag class.\n     */\n    final class SynchronizedBagSet extends SynchronizedCollection<E> implements Set<E> {\n        /** Serialization version */\n        private static final long serialVersionUID = 2990565892366827855L;\n\n        /**\n         * Constructs a new instance.\n         * @param set  the set to decorate\n         * @param lock  the lock to use, shared with the bag\n         */\n        SynchronizedBagSet(final Set<E> set, final Object lock) {\n            super(set, lock);\n        }\n    }\n\n    /** Serialization version */\n    private static final long serialVersionUID = 8084674570753837109L;\n\n    /**\n     * Factory method to create a synchronized bag.\n     *\n     * @param <E> the type of the elements in the bag\n     * @param bag  the bag to decorate, must not be null\n     * @return a new synchronized Bag\n     * @throws NullPointerException if bag is null\n     * @since 4.0\n     */\n    public static <E> SynchronizedBag<E> synchronizedBag(final Bag<E> bag) {\n        return new SynchronizedBag<>(bag);\n    }\n\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param bag  the bag to decorate, must not be null\n     * @throws NullPointerException if bag is null\n     */\n    protected SynchronizedBag(final Bag<E> bag) {\n        super(bag);\n    }\n\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param bag  the bag to decorate, must not be null\n     * @param lock  the lock to use, must not be null\n     * @throws NullPointerException if bag or lock is null\n     */\n    protected SynchronizedBag(final Bag<E> bag, final Object lock) {\n        super(bag, lock);\n    }\n\n    @Override\n    public boolean add(final E object, final int count) {\n        synchronized (lock) {\n            return getBag().add(object, count);\n        }\n    }\n\n    @Override\n    public boolean equals(final Object object) {\n        if (object == this) {\n            return true;\n        }\n        synchronized (lock) {\n            return getBag().equals(object);\n        }\n    }\n\n    /**\n     * Gets the bag being decorated.\n     *\n     * @return the decorated bag\n     */\n    protected Bag<E> getBag() {\n        return (Bag<E>) decorated();\n    }\n\n    @Override\n    public int getCount(final Object object) {\n        synchronized (lock) {\n            return getBag().getCount(object);\n        }\n    }\n\n    @Override\n    public int hashCode() {\n        synchronized (lock) {\n            return getBag().hashCode();\n        }\n    }\n\n    @Override\n    public boolean remove(final Object object, final int count) {\n        synchronized (lock) {\n            return getBag().remove(object, count);\n        }\n    }\n\n    @Override\n    public Set<E> uniqueSet() {\n        synchronized (lock) {\n            final Set<E> set = getBag().uniqueSet();\n            return new SynchronizedBagSet(set, lock);\n        }\n    }\n\n}", "super_interfaces": ["Bag<E>"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 8084674570753837109L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 8084674570753837109L", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/collection/UnmodifiableCollection.java.UnmodifiableCollection", "name": "UnmodifiableCollection", "file_path": "src/main/java/org/apache/commons/collections4/collection/UnmodifiableCollection.java", "superclasses": "", "methods": ["[Collection<T>]unmodifiableCollection(Collection<? extends T>)", "[]UnmodifiableCollection(Collection<? extends E>)", "[boolean]add(E)", "[boolean]addAll(Collection<? extends E>)", "[void]clear()", "[Iterator<E>]iterator()", "[boolean]remove(Object)", "[boolean]removeAll(Collection<?>)", "[boolean]removeIf(Predicate<? super E>)", "[boolean]retainAll(Collection<?>)"], "method_uris": ["src/main/java/org/apache/commons/collections4/collection/UnmodifiableCollection.java.UnmodifiableCollection.[Collection<T>]unmodifiableCollection(Collection<? extends T>)", "src/main/java/org/apache/commons/collections4/collection/UnmodifiableCollection.java.UnmodifiableCollection.[]UnmodifiableCollection(Collection<? extends E>)", "src/main/java/org/apache/commons/collections4/collection/UnmodifiableCollection.java.UnmodifiableCollection.[boolean]add(E)", "src/main/java/org/apache/commons/collections4/collection/UnmodifiableCollection.java.UnmodifiableCollection.[boolean]addAll(Collection<? extends E>)", "src/main/java/org/apache/commons/collections4/collection/UnmodifiableCollection.java.UnmodifiableCollection.[void]clear()", "src/main/java/org/apache/commons/collections4/collection/UnmodifiableCollection.java.UnmodifiableCollection.[Iterator<E>]iterator()", "src/main/java/org/apache/commons/collections4/collection/UnmodifiableCollection.java.UnmodifiableCollection.[boolean]remove(Object)", "src/main/java/org/apache/commons/collections4/collection/UnmodifiableCollection.java.UnmodifiableCollection.[boolean]removeAll(Collection<?>)", "src/main/java/org/apache/commons/collections4/collection/UnmodifiableCollection.java.UnmodifiableCollection.[boolean]removeIf(Predicate<? super E>)", "src/main/java/org/apache/commons/collections4/collection/UnmodifiableCollection.java.UnmodifiableCollection.[boolean]retainAll(Collection<?>)"], "overrides": null, "attributes": [], "class_docstring": "\nDecorates another {@link Collection} to ensure it can't be altered.\n<p>\nThis class is Serializable from Commons Collections 3.1.\n</p>\n<p>\nAttempts to modify it will result in an UnsupportedOperationException.\n</p>\n\n@param <E> the type of the elements in the collection\n@since 3.0\n", "original_string": "public final class UnmodifiableCollection<E>\n        extends AbstractCollectionDecorator<E>\n        implements Unmodifiable {\n\n    /** Serialization version */\n    private static final long serialVersionUID = -239892006883819945L;\n\n    /**\n     * Factory method to create an unmodifiable collection.\n     * <p>\n     * If the collection passed in is already unmodifiable, it is returned.\n     *\n     * @param <T> the type of the elements in the collection\n     * @param coll  the collection to decorate, must not be null\n     * @return an unmodifiable collection\n     * @throws NullPointerException if collection is null\n     * @since 4.0\n     */\n    public static <T> Collection<T> unmodifiableCollection(final Collection<? extends T> coll) {\n        if (coll instanceof Unmodifiable) {\n            @SuppressWarnings(\"unchecked\") // safe to upcast\n            final Collection<T> tmpColl = (Collection<T>) coll;\n            return tmpColl;\n        }\n        return new UnmodifiableCollection<>(coll);\n    }\n\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param coll  the collection to decorate, must not be null\n     * @throws NullPointerException if collection is null\n     */\n    @SuppressWarnings(\"unchecked\") // safe to upcast\n    private UnmodifiableCollection(final Collection<? extends E> coll) {\n        super((Collection<E>) coll);\n    }\n\n    @Override\n    public boolean add(final E object) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public boolean addAll(final Collection<? extends E> coll) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public void clear() {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public Iterator<E> iterator() {\n        return UnmodifiableIterator.unmodifiableIterator(decorated().iterator());\n    }\n\n    @Override\n    public boolean remove(final Object object) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public boolean removeAll(final Collection<?> coll) {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * @since 4.4\n     */\n    @Override\n    public boolean removeIf(final Predicate<? super E> filter) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public boolean retainAll(final Collection<?> coll) {\n        throw new UnsupportedOperationException();\n    }\n\n}", "super_interfaces": ["Unmodifiable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = -239892006883819945L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -239892006883819945L", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/collection/SynchronizedCollection.java.SynchronizedCollection", "name": "SynchronizedCollection", "file_path": "src/main/java/org/apache/commons/collections4/collection/SynchronizedCollection.java", "superclasses": "", "methods": ["[SynchronizedCollection<T>]synchronizedCollection(Collection<T>)", "[]SynchronizedCollection(Collection<E>)", "[]SynchronizedCollection(Collection<E>,Object)", "[boolean]add(E)", "[boolean]addAll(Collection<? extends E>)", "[void]clear()", "[boolean]contains(Object)", "[boolean]containsAll(Collection<?>)", "[Collection<E>]decorated()", "[boolean]equals(Object)", "[int]hashCode()", "[boolean]isEmpty()", "[Iterator<E>]iterator()", "[boolean]remove(Object)", "[boolean]removeAll(Collection<?>)", "[boolean]removeIf(Predicate<? super E>)", "[boolean]retainAll(Collection<?>)", "[int]size()", "[Object[]]toArray()", "[T[]]toArray(T[])", "[String]toString()"], "method_uris": ["src/main/java/org/apache/commons/collections4/collection/SynchronizedCollection.java.SynchronizedCollection.[SynchronizedCollection<T>]synchronizedCollection(Collection<T>)", "src/main/java/org/apache/commons/collections4/collection/SynchronizedCollection.java.SynchronizedCollection.[]SynchronizedCollection(Collection<E>)", "src/main/java/org/apache/commons/collections4/collection/SynchronizedCollection.java.SynchronizedCollection.[]SynchronizedCollection(Collection<E>,Object)", "src/main/java/org/apache/commons/collections4/collection/SynchronizedCollection.java.SynchronizedCollection.[boolean]add(E)", "src/main/java/org/apache/commons/collections4/collection/SynchronizedCollection.java.SynchronizedCollection.[boolean]addAll(Collection<? extends E>)", "src/main/java/org/apache/commons/collections4/collection/SynchronizedCollection.java.SynchronizedCollection.[void]clear()", "src/main/java/org/apache/commons/collections4/collection/SynchronizedCollection.java.SynchronizedCollection.[boolean]contains(Object)", "src/main/java/org/apache/commons/collections4/collection/SynchronizedCollection.java.SynchronizedCollection.[boolean]containsAll(Collection<?>)", "src/main/java/org/apache/commons/collections4/collection/SynchronizedCollection.java.SynchronizedCollection.[Collection<E>]decorated()", "src/main/java/org/apache/commons/collections4/collection/SynchronizedCollection.java.SynchronizedCollection.[boolean]equals(Object)", "src/main/java/org/apache/commons/collections4/collection/SynchronizedCollection.java.SynchronizedCollection.[int]hashCode()", "src/main/java/org/apache/commons/collections4/collection/SynchronizedCollection.java.SynchronizedCollection.[boolean]isEmpty()", "src/main/java/org/apache/commons/collections4/collection/SynchronizedCollection.java.SynchronizedCollection.[Iterator<E>]iterator()", "src/main/java/org/apache/commons/collections4/collection/SynchronizedCollection.java.SynchronizedCollection.[boolean]remove(Object)", "src/main/java/org/apache/commons/collections4/collection/SynchronizedCollection.java.SynchronizedCollection.[boolean]removeAll(Collection<?>)", "src/main/java/org/apache/commons/collections4/collection/SynchronizedCollection.java.SynchronizedCollection.[boolean]removeIf(Predicate<? super E>)", "src/main/java/org/apache/commons/collections4/collection/SynchronizedCollection.java.SynchronizedCollection.[boolean]retainAll(Collection<?>)", "src/main/java/org/apache/commons/collections4/collection/SynchronizedCollection.java.SynchronizedCollection.[int]size()", "src/main/java/org/apache/commons/collections4/collection/SynchronizedCollection.java.SynchronizedCollection.[Object[]]toArray()", "src/main/java/org/apache/commons/collections4/collection/SynchronizedCollection.java.SynchronizedCollection.[T[]]toArray(T[])", "src/main/java/org/apache/commons/collections4/collection/SynchronizedCollection.java.SynchronizedCollection.[String]toString()"], "overrides": null, "attributes": [], "class_docstring": "\nDecorates another {@link Collection} to synchronize its behavior\nfor a multithreaded environment.\n<p>\nIterators must be manually synchronized:\n</p>\n<pre>\nsynchronized (coll) {\n  Iterator it = coll.iterator();\n  // do stuff with iterator\n}\n</pre>\n<p>\nThis class is Serializable from Commons Collections 3.1.\n</p>\n\n@param <E> the type of the elements in the collection\n@since 3.0\n", "original_string": "public class SynchronizedCollection<E> implements Collection<E>, Serializable {\n\n    /** Serialization version */\n    private static final long serialVersionUID = 2412805092710877986L;\n\n    /**\n     * Factory method to create a synchronized collection.\n     *\n     * @param <T> the type of the elements in the collection\n     * @param coll  the collection to decorate, must not be null\n     * @return a new synchronized collection\n     * @throws NullPointerException if collection is null\n     * @since 4.0\n     */\n    public static <T> SynchronizedCollection<T> synchronizedCollection(final Collection<T> coll) {\n        return new SynchronizedCollection<>(coll);\n    }\n    /** The collection to decorate */\n    private final Collection<E> collection;\n\n    /** The object to lock on, needed for List/SortedSet views */\n    protected final Object lock;\n\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param collection  the collection to decorate, must not be null\n     * @throws NullPointerException if the collection is null\n     */\n    protected SynchronizedCollection(final Collection<E> collection) {\n        this.collection = Objects.requireNonNull(collection, \"collection\");\n        this.lock = this;\n    }\n\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param collection  the collection to decorate, must not be null\n     * @param lock  the lock object to use, must not be null\n     * @throws NullPointerException if the collection or lock is null\n     */\n    protected SynchronizedCollection(final Collection<E> collection, final Object lock) {\n        this.collection = Objects.requireNonNull(collection, \"collection\");\n        this.lock = Objects.requireNonNull(lock, \"lock\");\n    }\n\n    @Override\n    public boolean add(final E object) {\n        synchronized (lock) {\n            return decorated().add(object);\n        }\n    }\n\n    @Override\n    public boolean addAll(final Collection<? extends E> coll) {\n        synchronized (lock) {\n            return decorated().addAll(coll);\n        }\n    }\n\n    @Override\n    public void clear() {\n        synchronized (lock) {\n            decorated().clear();\n        }\n    }\n\n    @Override\n    public boolean contains(final Object object) {\n        synchronized (lock) {\n            return decorated().contains(object);\n        }\n    }\n\n    @Override\n    public boolean containsAll(final Collection<?> coll) {\n        synchronized (lock) {\n            return decorated().containsAll(coll);\n        }\n    }\n\n    /**\n     * Gets the collection being decorated.\n     *\n     * @return the decorated collection\n     */\n    protected Collection<E> decorated() {\n        return collection;\n    }\n\n    @Override\n    public boolean equals(final Object object) {\n        synchronized (lock) {\n            if (object == this) {\n                return true;\n            }\n            return object == this || decorated().equals(object);\n        }\n    }\n\n    @Override\n    public int hashCode() {\n        synchronized (lock) {\n            return decorated().hashCode();\n        }\n    }\n\n    @Override\n    public boolean isEmpty() {\n        synchronized (lock) {\n            return decorated().isEmpty();\n        }\n    }\n\n    /**\n     * Iterators must be manually synchronized.\n     * <pre>\n     * synchronized (coll) {\n     *   Iterator it = coll.iterator();\n     *   // do stuff with iterator\n     * }\n     * </pre>\n     *\n     * @return an iterator that must be manually synchronized on the collection\n     */\n    @Override\n    public Iterator<E> iterator() {\n        return decorated().iterator();\n    }\n\n    @Override\n    public boolean remove(final Object object) {\n        synchronized (lock) {\n            return decorated().remove(object);\n        }\n    }\n\n    @Override\n    public boolean removeAll(final Collection<?> coll) {\n        synchronized (lock) {\n            return decorated().removeAll(coll);\n        }\n    }\n\n    /**\n     * @since 4.4\n     */\n    @Override\n    public boolean removeIf(final Predicate<? super E> filter) {\n        synchronized (lock) {\n            return decorated().removeIf(filter);\n        }\n    }\n\n    @Override\n    public boolean retainAll(final Collection<?> coll) {\n        synchronized (lock) {\n            return decorated().retainAll(coll);\n        }\n    }\n\n    @Override\n    public int size() {\n        synchronized (lock) {\n            return decorated().size();\n        }\n    }\n\n    @Override\n    public Object[] toArray() {\n        synchronized (lock) {\n            return decorated().toArray();\n        }\n    }\n\n    @Override\n    public <T> T[] toArray(final T[] object) {\n        synchronized (lock) {\n            return decorated().toArray(object);\n        }\n    }\n\n    @Override\n    public String toString() {\n        synchronized (lock) {\n            return decorated().toString();\n        }\n    }\n\n}", "super_interfaces": ["Collection<E>", "Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 2412805092710877986L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 2412805092710877986L", "syntax_pass": true}, {"attribute_expression": "private final Collection<E> collection;", "docstring": " The collection to decorate", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Collection<E>", "name": "collection", "syntax_pass": true}, {"attribute_expression": "protected final Object lock;", "docstring": " The object to lock on, needed for List/SortedSet views", "modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "type": "Object", "name": "lock", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/collection/CompositeCollection.java.CompositeCollection", "name": "CompositeCollection", "file_path": "src/main/java/org/apache/commons/collections4/collection/CompositeCollection.java", "superclasses": "", "methods": ["[]CompositeCollection()", "[]CompositeCollection(Collection<E>)", "[]CompositeCollection()", "[]CompositeCollection(Collection<E>,Collection<E>)", "[boolean]add(E)", "[boolean]addAll(Collection<? extends E>)", "[void]addComposited(Collection<E>)", "[void]addComposited()", "[void]addComposited(Collection<E>,Collection<E>)", "[void]clear()", "[boolean]contains(Object)", "[boolean]containsAll(Collection<?>)", "[List<Collection<E>>]getCollections()", "[CollectionMutator<E>]getMutator()", "[boolean]isEmpty()", "[Iterator<E>]iterator()", "[boolean]remove(Object)", "[boolean]removeAll(Collection<?>)", "[void]removeComposited(Collection<E>)", "[boolean]removeIf(Predicate<? super E>)", "[boolean]retainAll(Collection<?>)", "[void]setMutator(CollectionMutator<E>)", "[int]size()", "[Object[]]toArray()", "[T[]]toArray(T[])", "[Collection<E>]toCollection()"], "method_uris": ["src/main/java/org/apache/commons/collections4/collection/CompositeCollection.java.CompositeCollection.[]CompositeCollection()", "src/main/java/org/apache/commons/collections4/collection/CompositeCollection.java.CompositeCollection.[]CompositeCollection(Collection<E>)", "src/main/java/org/apache/commons/collections4/collection/CompositeCollection.java.CompositeCollection.[]CompositeCollection()", "src/main/java/org/apache/commons/collections4/collection/CompositeCollection.java.CompositeCollection.[]CompositeCollection(Collection<E>,Collection<E>)", "src/main/java/org/apache/commons/collections4/collection/CompositeCollection.java.CompositeCollection.[boolean]add(E)", "src/main/java/org/apache/commons/collections4/collection/CompositeCollection.java.CompositeCollection.[boolean]addAll(Collection<? extends E>)", "src/main/java/org/apache/commons/collections4/collection/CompositeCollection.java.CompositeCollection.[void]addComposited(Collection<E>)", "src/main/java/org/apache/commons/collections4/collection/CompositeCollection.java.CompositeCollection.[void]addComposited()", "src/main/java/org/apache/commons/collections4/collection/CompositeCollection.java.CompositeCollection.[void]addComposited(Collection<E>,Collection<E>)", "src/main/java/org/apache/commons/collections4/collection/CompositeCollection.java.CompositeCollection.[void]clear()", "src/main/java/org/apache/commons/collections4/collection/CompositeCollection.java.CompositeCollection.[boolean]contains(Object)", "src/main/java/org/apache/commons/collections4/collection/CompositeCollection.java.CompositeCollection.[boolean]containsAll(Collection<?>)", "src/main/java/org/apache/commons/collections4/collection/CompositeCollection.java.CompositeCollection.[List<Collection<E>>]getCollections()", "src/main/java/org/apache/commons/collections4/collection/CompositeCollection.java.CompositeCollection.[CollectionMutator<E>]getMutator()", "src/main/java/org/apache/commons/collections4/collection/CompositeCollection.java.CompositeCollection.[boolean]isEmpty()", "src/main/java/org/apache/commons/collections4/collection/CompositeCollection.java.CompositeCollection.[Iterator<E>]iterator()", "src/main/java/org/apache/commons/collections4/collection/CompositeCollection.java.CompositeCollection.[boolean]remove(Object)", "src/main/java/org/apache/commons/collections4/collection/CompositeCollection.java.CompositeCollection.[boolean]removeAll(Collection<?>)", "src/main/java/org/apache/commons/collections4/collection/CompositeCollection.java.CompositeCollection.[void]removeComposited(Collection<E>)", "src/main/java/org/apache/commons/collections4/collection/CompositeCollection.java.CompositeCollection.[boolean]removeIf(Predicate<? super E>)", "src/main/java/org/apache/commons/collections4/collection/CompositeCollection.java.CompositeCollection.[boolean]retainAll(Collection<?>)", "src/main/java/org/apache/commons/collections4/collection/CompositeCollection.java.CompositeCollection.[void]setMutator(CollectionMutator<E>)", "src/main/java/org/apache/commons/collections4/collection/CompositeCollection.java.CompositeCollection.[int]size()", "src/main/java/org/apache/commons/collections4/collection/CompositeCollection.java.CompositeCollection.[Object[]]toArray()", "src/main/java/org/apache/commons/collections4/collection/CompositeCollection.java.CompositeCollection.[T[]]toArray(T[])", "src/main/java/org/apache/commons/collections4/collection/CompositeCollection.java.CompositeCollection.[Collection<E>]toCollection()"], "overrides": null, "attributes": [], "class_docstring": "\nDecorates a collection of other collections to provide a single unified view.\n<p>\nChanges made to this collection will actually be made on the decorated collection.\nAdd and remove operations require the use of a pluggable strategy. If no\nstrategy is provided then add and remove are unsupported.\n</p>\n@param <E> the type of the elements in the collection\n@since 3.0\n", "original_string": "public class CompositeCollection<E> implements Collection<E>, Serializable {\n\n    /**\n     * Pluggable strategy to handle changes to the composite.\n     *\n     * @param <E> the element being held in the collection\n     */\n    public interface CollectionMutator<E> extends Serializable {\n\n        /**\n         * Called when an object is to be added to the composite.\n         *\n         * @param composite  the CompositeCollection being changed\n         * @param collections  all of the Collection instances in this CompositeCollection\n         * @param obj  the object being added\n         * @return true if the collection is changed\n         * @throws UnsupportedOperationException if add is unsupported\n         * @throws ClassCastException if the object cannot be added due to its type\n         * @throws NullPointerException if the object cannot be added because its null\n         * @throws IllegalArgumentException if the object cannot be added\n         */\n        boolean add(CompositeCollection<E> composite, List<Collection<E>> collections, E obj);\n\n        /**\n         * Called when a collection is to be added to the composite.\n         *\n         * @param composite  the CompositeCollection being changed\n         * @param collections  all of the Collection instances in this CompositeCollection\n         * @param coll  the collection being added\n         * @return true if the collection is changed\n         * @throws UnsupportedOperationException if add is unsupported\n         * @throws ClassCastException if the object cannot be added due to its type\n         * @throws NullPointerException if the object cannot be added because its null\n         * @throws IllegalArgumentException if the object cannot be added\n         */\n        boolean addAll(CompositeCollection<E> composite,\n                              List<Collection<E>> collections,\n                              Collection<? extends E> coll);\n\n        /**\n         * Called when an object is to be removed to the composite.\n         *\n         * @param composite  the CompositeCollection being changed\n         * @param collections  all of the Collection instances in this CompositeCollection\n         * @param obj  the object being removed\n         * @return true if the collection is changed\n         * @throws UnsupportedOperationException if removed is unsupported\n         * @throws ClassCastException if the object cannot be removed due to its type\n         * @throws NullPointerException if the object cannot be removed because its null\n         * @throws IllegalArgumentException if the object cannot be removed\n         */\n        boolean remove(CompositeCollection<E> composite,\n                              List<Collection<E>> collections,\n                              Object obj);\n\n    }\n\n    /** Serialization version */\n    private static final long serialVersionUID = 8417515734108306801L;\n\n    /** CollectionMutator to handle changes to the collection */\n    private CollectionMutator<E> mutator;\n\n    /** Collections in the composite */\n    private final List<Collection<E>> all = new ArrayList<>();\n\n    /**\n     * Create an empty CompositeCollection.\n     */\n    public CompositeCollection() {\n    }\n\n    /**\n     * Create a Composite Collection with one collection.\n     *\n     * @param compositeCollection  the Collection to be appended to the composite\n     */\n    public CompositeCollection(final Collection<E> compositeCollection) {\n        addComposited(compositeCollection);\n    }\n\n    /**\n     * Create a Composite Collection with an array of collections.\n     *\n     * @param compositeCollections  the collections to composite\n     */\n    public CompositeCollection(final Collection<E>... compositeCollections) {\n        addComposited(compositeCollections);\n    }\n\n    /**\n     * Create a Composite Collection with two collections.\n     *\n     * @param compositeCollection1  the Collection to be appended to the composite\n     * @param compositeCollection2  the Collection to be appended to the composite\n     */\n    public CompositeCollection(final Collection<E> compositeCollection1,\n                               final Collection<E> compositeCollection2) {\n        addComposited(compositeCollection1, compositeCollection2);\n    }\n\n    /**\n     * Adds an object to the collection, throwing UnsupportedOperationException\n     * unless a CollectionMutator strategy is specified.\n     *\n     * @param obj  the object to add\n     * @return {@code true} if the collection was modified\n     * @throws UnsupportedOperationException if CollectionMutator hasn't been set\n     * @throws UnsupportedOperationException if add is unsupported\n     * @throws ClassCastException if the object cannot be added due to its type\n     * @throws NullPointerException if the object cannot be added because its null\n     * @throws IllegalArgumentException if the object cannot be added\n     */\n    @Override\n    public boolean add(final E obj) {\n        if (mutator == null) {\n            throw new UnsupportedOperationException(\n                \"add() is not supported on CompositeCollection without a CollectionMutator strategy\");\n        }\n        return mutator.add(this, all, obj);\n    }\n\n    /**\n     * Adds a collection of elements to this collection, throwing\n     * UnsupportedOperationException unless a CollectionMutator strategy is specified.\n     *\n     * @param coll  the collection to add\n     * @return true if the collection was modified\n     * @throws UnsupportedOperationException if CollectionMutator hasn't been set\n     * @throws UnsupportedOperationException if add is unsupported\n     * @throws ClassCastException if the object cannot be added due to its type\n     * @throws NullPointerException if the object cannot be added because its null\n     * @throws IllegalArgumentException if the object cannot be added\n     */\n    @Override\n    public boolean addAll(final Collection<? extends E> coll) {\n        if (mutator == null) {\n            throw new UnsupportedOperationException(\n                \"addAll() is not supported on CompositeCollection without a CollectionMutator strategy\");\n        }\n        return mutator.addAll(this, all, coll);\n    }\n\n    /**\n     * Add these Collections to the list of collections in this composite\n     *\n     * @param compositeCollection  the Collection to be appended to the composite\n     */\n    public void addComposited(final Collection<E> compositeCollection) {\n        if (compositeCollection != null) {\n            all.add(compositeCollection);\n        }\n    }\n\n    /**\n     * Add these Collections to the list of collections in this composite\n     *\n     * @param compositeCollections  the Collections to be appended to the composite\n     */\n    public void addComposited(final Collection<E>... compositeCollections) {\n        for (final Collection<E> compositeCollection : compositeCollections) {\n            if (compositeCollection != null) {\n                all.add(compositeCollection);\n            }\n        }\n    }\n\n    /**\n     * Add these Collections to the list of collections in this composite\n     *\n     * @param compositeCollection1  the Collection to be appended to the composite\n     * @param compositeCollection2  the Collection to be appended to the composite\n     */\n    public void addComposited(final Collection<E> compositeCollection1,\n                              final Collection<E> compositeCollection2) {\n        if (compositeCollection1 != null) {\n            all.add(compositeCollection1);\n        }\n        if (compositeCollection2 != null) {\n            all.add(compositeCollection2);\n        }\n    }\n\n    /**\n     * Removes all of the elements from this collection .\n     * <p>\n     * This implementation calls {@code clear()} on each collection.\n     * </p>\n     * @throws UnsupportedOperationException if clear is unsupported\n     */\n    @Override\n    public void clear() {\n        for (final Collection<E> coll : all) {\n            coll.clear();\n        }\n    }\n\n    /**\n     * Checks whether this composite collection contains the object.\n     * <p>\n     * This implementation calls {@code contains()} on each collection.\n     * </p>\n     * @param obj  the object to search for\n     * @return true if obj is contained in any of the contained collections\n     */\n    @Override\n    public boolean contains(final Object obj) {\n        for (final Collection<E> item : all) {\n            if (item.contains(obj)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Checks whether this composite contains all the elements in the specified collection.\n     * <p>\n     * This implementation calls {@code contains()} for each element in the\n     * specified collection.\n     * </p>\n     * @param coll  the collection to check for\n     * @return true if all elements contained\n     */\n    @Override\n    public boolean containsAll(final Collection<?> coll) {\n        if (coll == null) {\n            return false;\n        }\n        for (final Object item : coll) {\n            if (!contains(item)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Gets the collections being decorated.\n     *\n     * @return Unmodifiable list of all collections in this composite.\n     */\n    public List<Collection<E>> getCollections() {\n        return UnmodifiableList.unmodifiableList(all);\n    }\n\n    /**\n     * Gets the collection mutator to be used for this CompositeCollection.\n     * @return CollectionMutator&lt;E&gt;\n     */\n    protected CollectionMutator<E> getMutator() {\n        return mutator;\n    }\n\n    /**\n     * Checks whether this composite collection is empty.\n     * <p>\n     * This implementation calls {@code isEmpty()} on each collection.\n     * </p>\n     * @return true if all of the contained collections are empty\n     */\n    @Override\n    public boolean isEmpty() {\n        for (final Collection<E> item : all) {\n            if (!item.isEmpty()) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Gets an iterator over all the collections in this composite.\n     * <p>\n     * This implementation uses an {@code IteratorChain}.\n     * </p>\n     * @return an {@code IteratorChain} instance which supports\n     *  {@code remove()}. Iteration occurs over contained collections in\n     *  the order they were added, but this behavior should not be relied upon.\n     * @see IteratorChain\n     */\n    @Override\n    public Iterator<E> iterator() {\n        if (all.isEmpty()) {\n            return EmptyIterator.<E>emptyIterator();\n        }\n        final IteratorChain<E> chain = new IteratorChain<>();\n        all.forEach(item -> chain.addIterator(item.iterator()));\n        return chain;\n    }\n\n    /**\n     * Removes an object from the collection, throwing UnsupportedOperationException\n     * unless a CollectionMutator strategy is specified.\n     *\n     * @param obj  the object being removed\n     * @return true if the collection is changed\n     * @throws UnsupportedOperationException if removed is unsupported\n     * @throws ClassCastException if the object cannot be removed due to its type\n     * @throws NullPointerException if the object cannot be removed because its null\n     * @throws IllegalArgumentException if the object cannot be removed\n     */\n    @Override\n    public boolean remove(final Object obj) {\n        if (mutator == null) {\n            throw new UnsupportedOperationException(\n                \"remove() is not supported on CompositeCollection without a CollectionMutator strategy\");\n        }\n        return mutator.remove(this, all, obj);\n    }\n\n    /**\n     * Removes the elements in the specified collection from this composite collection.\n     * <p>\n     * This implementation calls {@code removeAll} on each collection.\n     * </p>\n     * @param coll  the collection to remove\n     * @return true if the collection was modified\n     * @throws UnsupportedOperationException if removeAll is unsupported\n     */\n    @Override\n    public boolean removeAll(final Collection<?> coll) {\n        if (CollectionUtils.isEmpty(coll)) {\n            return false;\n        }\n        boolean changed = false;\n        for (final Collection<E> item : all) {\n            changed |= item.removeAll(coll);\n        }\n        return changed;\n    }\n\n    /**\n     * Removes a collection from the those being decorated in this composite.\n     *\n     * @param coll  collection to be removed\n     */\n    public void removeComposited(final Collection<E> coll) {\n        all.remove(coll);\n    }\n\n    /**\n     * Removes all of the elements of this collection that satisfy the given predicate from this composite collection.\n     * <p>\n     * This implementation calls {@code removeIf} on each collection.\n     * </p>\n     * @param filter  a predicate which returns true for elements to be removed\n     * @return true if the collection was modified\n     * @throws UnsupportedOperationException if removeIf is unsupported\n     * @since 4.4\n     */\n    @Override\n    public boolean removeIf(final Predicate<? super E> filter) {\n        if (Objects.isNull(filter)) {\n            return false;\n        }\n        boolean changed = false;\n        for (final Collection<E> item : all) {\n            changed |= item.removeIf(filter);\n        }\n        return changed;\n    }\n\n    /**\n     * Retains all the elements in the specified collection in this composite collection,\n     * removing all others.\n     * <p>\n     * This implementation calls {@code retainAll()} on each collection.\n     * </p>\n     * @param coll  the collection to remove\n     * @return true if the collection was modified\n     * @throws UnsupportedOperationException if retainAll is unsupported\n     */\n    @Override\n    public boolean retainAll(final Collection<?> coll) {\n        boolean changed = false;\n        if (coll != null) {\n            for (final Collection<E> item : all) {\n                changed |= item.retainAll(coll);\n            }\n        }\n        return changed;\n    }\n\n    /**\n     * Specify a CollectionMutator strategy instance to handle changes.\n     *\n     * @param mutator  the mutator to use\n     */\n    public void setMutator(final CollectionMutator<E> mutator) {\n        this.mutator = mutator;\n    }\n\n    /**\n     * Gets the size of this composite collection.\n     * <p>\n     * This implementation calls {@code size()} on each collection.\n     * </p>\n     * @return total number of elements in all contained containers\n     */\n    @Override\n    public int size() {\n        int size = 0;\n        for (final Collection<E> item : all) {\n            size += item.size();\n        }\n        return size;\n    }\n\n    /**\n     * Returns an array containing all of the elements in this composite.\n     *\n     * @return an object array of all the elements in the collection\n     */\n    @Override\n    public Object[] toArray() {\n        final Object[] result = new Object[size()];\n        int i = 0;\n        for (final Iterator<E> it = iterator(); it.hasNext(); i++) {\n            result[i] = it.next();\n        }\n        return result;\n    }\n\n    /**\n     * Returns an object array, populating the supplied array if possible.\n     * See {@code Collection} interface for full details.\n     *\n     * @param <T>  the type of the elements in the collection\n     * @param array  the array to use, populating if possible\n     * @return an array of all the elements in the collection\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public <T> T[] toArray(final T[] array) {\n        final int size = size();\n        Object[] result = null;\n        if (array.length >= size) {\n            result = array;\n        } else {\n            result = (Object[]) Array.newInstance(array.getClass().getComponentType(), size);\n        }\n\n        int offset = 0;\n        for (final Collection<E> item : all) {\n            for (final E e : item) {\n                result[offset++] = e;\n            }\n        }\n        if (result.length > size) {\n            result[size] = null;\n        }\n        return (T[]) result;\n    }\n\n    /**\n     * Returns a new collection containing all of the elements\n     *\n     * @return A new ArrayList containing all of the elements in this composite.\n     *         The new collection is <em>not</em> backed by this composite.\n     */\n    public Collection<E> toCollection() {\n        return new ArrayList<>(this);\n    }\n\n}", "super_interfaces": ["Collection<E>", "Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 8417515734108306801L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 8417515734108306801L", "syntax_pass": true}, {"attribute_expression": "private CollectionMutator<E> mutator;", "docstring": " CollectionMutator to handle changes to the collection", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "CollectionMutator<E>", "name": "mutator", "syntax_pass": true}, {"attribute_expression": "private final List<Collection<E>> all = new ArrayList<>();", "docstring": " Collections in the composite", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<Collection<E>>", "name": "all = new ArrayList<>()", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/collection/UnmodifiableBoundedCollection.java.UnmodifiableBoundedCollection", "name": "UnmodifiableBoundedCollection", "file_path": "src/main/java/org/apache/commons/collections4/collection/UnmodifiableBoundedCollection.java", "superclasses": "", "methods": ["[BoundedCollection<E>]unmodifiableBoundedCollection(BoundedCollection<? extends E>)", "[BoundedCollection<E>]unmodifiableBoundedCollection(Collection<? extends E>)", "[]UnmodifiableBoundedCollection(BoundedCollection<? extends E>)", "[boolean]add(E)", "[boolean]addAll(Collection<? extends E>)", "[void]clear()", "[BoundedCollection<E>]decorated()", "[boolean]isFull()", "[Iterator<E>]iterator()", "[int]maxSize()", "[boolean]remove(Object)", "[boolean]removeAll(Collection<?>)", "[boolean]removeIf(Predicate<? super E>)", "[boolean]retainAll(Collection<?>)"], "method_uris": ["src/main/java/org/apache/commons/collections4/collection/UnmodifiableBoundedCollection.java.UnmodifiableBoundedCollection.[BoundedCollection<E>]unmodifiableBoundedCollection(BoundedCollection<? extends E>)", "src/main/java/org/apache/commons/collections4/collection/UnmodifiableBoundedCollection.java.UnmodifiableBoundedCollection.[BoundedCollection<E>]unmodifiableBoundedCollection(Collection<? extends E>)", "src/main/java/org/apache/commons/collections4/collection/UnmodifiableBoundedCollection.java.UnmodifiableBoundedCollection.[]UnmodifiableBoundedCollection(BoundedCollection<? extends E>)", "src/main/java/org/apache/commons/collections4/collection/UnmodifiableBoundedCollection.java.UnmodifiableBoundedCollection.[boolean]add(E)", "src/main/java/org/apache/commons/collections4/collection/UnmodifiableBoundedCollection.java.UnmodifiableBoundedCollection.[boolean]addAll(Collection<? extends E>)", "src/main/java/org/apache/commons/collections4/collection/UnmodifiableBoundedCollection.java.UnmodifiableBoundedCollection.[void]clear()", "src/main/java/org/apache/commons/collections4/collection/UnmodifiableBoundedCollection.java.UnmodifiableBoundedCollection.[BoundedCollection<E>]decorated()", "src/main/java/org/apache/commons/collections4/collection/UnmodifiableBoundedCollection.java.UnmodifiableBoundedCollection.[boolean]isFull()", "src/main/java/org/apache/commons/collections4/collection/UnmodifiableBoundedCollection.java.UnmodifiableBoundedCollection.[Iterator<E>]iterator()", "src/main/java/org/apache/commons/collections4/collection/UnmodifiableBoundedCollection.java.UnmodifiableBoundedCollection.[int]maxSize()", "src/main/java/org/apache/commons/collections4/collection/UnmodifiableBoundedCollection.java.UnmodifiableBoundedCollection.[boolean]remove(Object)", "src/main/java/org/apache/commons/collections4/collection/UnmodifiableBoundedCollection.java.UnmodifiableBoundedCollection.[boolean]removeAll(Collection<?>)", "src/main/java/org/apache/commons/collections4/collection/UnmodifiableBoundedCollection.java.UnmodifiableBoundedCollection.[boolean]removeIf(Predicate<? super E>)", "src/main/java/org/apache/commons/collections4/collection/UnmodifiableBoundedCollection.java.UnmodifiableBoundedCollection.[boolean]retainAll(Collection<?>)"], "overrides": null, "attributes": [], "class_docstring": "\n{@link UnmodifiableBoundedCollection} decorates another\n{@link BoundedCollection} to ensure it can't be altered.\n<p>\nIf a BoundedCollection is first wrapped in some other collection decorator,\nsuch as synchronized or predicated, the BoundedCollection methods are no\nlonger accessible.\nThe factory on this class will attempt to retrieve the bounded nature by\nexamining the package scope variables.\n</p>\n<p>\nThis class is Serializable from Commons Collections 3.1.\n</p>\n<p>\nAttempts to modify it will result in an UnsupportedOperationException.\n</p>\n\n@param <E> the type of elements in this collection\n@since 3.0\n", "original_string": "public final class UnmodifiableBoundedCollection<E> extends AbstractCollectionDecorator<E>\n        implements BoundedCollection<E>, Unmodifiable {\n\n    /** Serialization version */\n    private static final long serialVersionUID = -7112672385450340330L;\n\n    /**\n     * Factory method to create an unmodifiable bounded collection.\n     *\n     * @param <E> the type of the elements in the collection\n     * @param coll  the {@code BoundedCollection} to decorate, must not be null\n     * @return a new unmodifiable bounded collection\n     * @throws NullPointerException if {@code coll} is {@code null}\n     * @since 4.0\n     */\n    public static <E> BoundedCollection<E> unmodifiableBoundedCollection(final BoundedCollection<? extends E> coll) {\n        if (coll instanceof Unmodifiable) {\n            @SuppressWarnings(\"unchecked\") // safe to upcast\n            final BoundedCollection<E> tmpColl = (BoundedCollection<E>) coll;\n            return tmpColl;\n        }\n        return new UnmodifiableBoundedCollection<>(coll);\n    }\n\n    /**\n     * Factory method to create an unmodifiable bounded collection.\n     * <p>\n     * This method is capable of drilling down through up to 1000 other decorators\n     * to find a suitable BoundedCollection.\n     *\n     * @param <E> the type of the elements in the collection\n     * @param collection  the {@code BoundedCollection} to decorate, must not be null\n     * @return a new unmodifiable bounded collection\n     * @throws NullPointerException if coll is null\n     * @throws IllegalArgumentException if coll is not a {@code BoundedCollection}\n     * @since 4.0\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static <E> BoundedCollection<E> unmodifiableBoundedCollection(Collection<? extends E> collection) {\n        Objects.requireNonNull(collection, \"collection\");\n\n        // handle decorators\n        for (int i = 0; i < 1000; i++) {  // counter to prevent infinite looping\n            if (collection instanceof BoundedCollection) {\n                break;  // normal loop exit\n            }\n            if (collection instanceof AbstractCollectionDecorator) {\n                collection = ((AbstractCollectionDecorator<E>) collection).decorated();\n            } else if (collection instanceof SynchronizedCollection) {\n                collection = ((SynchronizedCollection<E>) collection).decorated();\n            }\n        }\n\n        if (!(collection instanceof BoundedCollection)) {\n            throw new IllegalArgumentException(\"Collection is not a bounded collection.\");\n        }\n        return new UnmodifiableBoundedCollection<>((BoundedCollection<E>) collection);\n    }\n\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param coll  the collection to decorate, must not be null\n     * @throws NullPointerException if coll is null\n     */\n    @SuppressWarnings(\"unchecked\") // safe to upcast\n    private UnmodifiableBoundedCollection(final BoundedCollection<? extends E> coll) {\n        super((BoundedCollection<E>) coll);\n    }\n\n    @Override\n    public boolean add(final E object) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public boolean addAll(final Collection<? extends E> coll) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public void clear() {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    protected BoundedCollection<E> decorated() {\n        return (BoundedCollection<E>) super.decorated();\n    }\n\n    @Override\n    public boolean isFull() {\n        return decorated().isFull();\n    }\n\n    @Override\n    public Iterator<E> iterator() {\n        return UnmodifiableIterator.unmodifiableIterator(decorated().iterator());\n    }\n\n    @Override\n    public int maxSize() {\n        return decorated().maxSize();\n    }\n\n    @Override\n    public boolean remove(final Object object) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public boolean removeAll(final Collection<?> coll) {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * @since 4.4\n     */\n    @Override\n    public boolean removeIf(final Predicate<? super E> filter) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public boolean retainAll(final Collection<?> coll) {\n        throw new UnsupportedOperationException();\n    }\n}", "super_interfaces": ["BoundedCollection<E>", "Unmodifiable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = -7112672385450340330L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -7112672385450340330L", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/collection/PredicatedCollection.java.PredicatedCollection", "name": "PredicatedCollection", "file_path": "src/main/java/org/apache/commons/collections4/collection/PredicatedCollection.java", "superclasses": "", "methods": ["[Builder<E>]builder(Predicate<? super E>)", "[Builder<E>]notNullBuilder()", "[PredicatedCollection<T>]predicatedCollection(Collection<T>,Predicate<? super T>)", "[]PredicatedCollection(Collection<E>,Predicate<? super E>)", "[boolean]add(E)", "[boolean]addAll(Collection<? extends E>)", "[void]validate(E)"], "method_uris": ["src/main/java/org/apache/commons/collections4/collection/PredicatedCollection.java.PredicatedCollection.[Builder<E>]builder(Predicate<? super E>)", "src/main/java/org/apache/commons/collections4/collection/PredicatedCollection.java.PredicatedCollection.[Builder<E>]notNullBuilder()", "src/main/java/org/apache/commons/collections4/collection/PredicatedCollection.java.PredicatedCollection.[PredicatedCollection<T>]predicatedCollection(Collection<T>,Predicate<? super T>)", "src/main/java/org/apache/commons/collections4/collection/PredicatedCollection.java.PredicatedCollection.[]PredicatedCollection(Collection<E>,Predicate<? super E>)", "src/main/java/org/apache/commons/collections4/collection/PredicatedCollection.java.PredicatedCollection.[boolean]add(E)", "src/main/java/org/apache/commons/collections4/collection/PredicatedCollection.java.PredicatedCollection.[boolean]addAll(Collection<? extends E>)", "src/main/java/org/apache/commons/collections4/collection/PredicatedCollection.java.PredicatedCollection.[void]validate(E)"], "overrides": null, "attributes": [{"original_string": "    public static class Builder<E> {\n\n        /** The predicate to use. */\n        private final Predicate<? super E> predicate;\n\n        /** The buffer containing valid elements. */\n        private final List<E> accepted = new ArrayList<>();\n\n        /** The buffer containing rejected elements. */\n        private final List<E> rejected = new ArrayList<>();\n\n        /**\n         * Constructs a PredicatedCollectionBuilder with the specified Predicate.\n         *\n         * @param predicate  the predicate to use\n         * @throws NullPointerException if predicate is null\n         */\n        public Builder(final Predicate<? super E> predicate) {\n            this.predicate = Objects.requireNonNull(predicate, \"predicate\");\n        }\n\n        /**\n         * Adds the item to the builder.\n         * <p>\n         * If the predicate is true, it is added to the list of accepted elements,\n         * otherwise it is added to the rejected list.\n         *\n         * @param item  the element to add\n         * @return the PredicatedCollectionBuilder.\n         */\n        public Builder<E> add(final E item) {\n            if (predicate.test(item)) {\n                accepted.add(item);\n            } else {\n                rejected.add(item);\n            }\n            return this;\n        }\n\n        /**\n         * Adds all elements from the given collection to the builder.\n         * <p>\n         * All elements for which the predicate evaluates to true will be added to the\n         * list of accepted elements, otherwise they are added to the rejected list.\n         *\n         * @param items  the elements to add to the builder\n         * @return the PredicatedCollectionBuilder.\n         */\n        public Builder<E> addAll(final Collection<? extends E> items) {\n            if (items != null) {\n                for (final E item : items) {\n                    add(item);\n                }\n            }\n            return this;\n        }\n\n        /**\n         * Create a new predicated bag filled with the accepted elements.\n         * <p>\n         * The builder is not modified by this method, so it is possible to create more collections\n         * or add more elements afterwards. Further changes will not propagate to the returned bag.\n         *\n         * @return a new predicated bag.\n         */\n        public Bag<E> createPredicatedBag() {\n            return createPredicatedBag(new HashBag<>());\n        }\n\n        /**\n         * Decorates the given bag with validating behavior using the predicate. All accepted elements\n         * are appended to the bag. If the bag already contains elements, they are validated.\n         * <p>\n         * The builder is not modified by this method, so it is possible to create more collections\n         * or add more elements afterwards. Further changes will not propagate to the returned bag.\n         *\n         * @param bag  the bag to decorate, must not be null\n         * @return the decorated bag.\n         * @throws NullPointerException if bag is null\n         * @throws IllegalArgumentException if bag contains invalid elements\n         */\n        public Bag<E> createPredicatedBag(final Bag<E> bag) {\n            Objects.requireNonNull(bag, \"bag\");\n            final PredicatedBag<E> predicatedBag = PredicatedBag.predicatedBag(bag, predicate);\n            predicatedBag.addAll(accepted);\n            return predicatedBag;\n        }\n\n        /**\n         * Create a new predicated list filled with the accepted elements.\n         * <p>\n         * The builder is not modified by this method, so it is possible to create more collections\n         * or add more elements afterwards. Further changes will not propagate to the returned list.\n         *\n         * @return a new predicated list.\n         */\n        public List<E> createPredicatedList() {\n            return createPredicatedList(new ArrayList<>());\n        }\n\n        /**\n         * Decorates the given list with validating behavior using the predicate. All accepted elements\n         * are appended to the list. If the list already contains elements, they are validated.\n         * <p>\n         * The builder is not modified by this method, so it is possible to create more collections\n         * or add more elements afterwards. Further changes will not propagate to the returned list.\n         *\n         * @param list  the List to decorate, must not be null\n         * @return the decorated list.\n         * @throws NullPointerException if list is null\n         * @throws IllegalArgumentException if list contains invalid elements\n         */\n        public List<E> createPredicatedList(final List<E> list) {\n            Objects.requireNonNull(list, \"list\");\n            final List<E> predicatedList = PredicatedList.predicatedList(list, predicate);\n            predicatedList.addAll(accepted);\n            return predicatedList;\n        }\n\n        /**\n         * Create a new predicated multiset filled with the accepted elements.\n         * <p>\n         * The builder is not modified by this method, so it is possible to create more collections\n         * or add more elements afterwards. Further changes will not propagate to the returned multiset.\n         *\n         * @return a new predicated multiset.\n         */\n        public MultiSet<E> createPredicatedMultiSet() {\n            return createPredicatedMultiSet(new HashMultiSet<>());\n        }\n\n        /**\n         * Decorates the given multiset with validating behavior using the predicate. All accepted elements\n         * are appended to the multiset. If the multiset already contains elements, they are validated.\n         * <p>\n         * The builder is not modified by this method, so it is possible to create more collections\n         * or add more elements afterwards. Further changes will not propagate to the returned multiset.\n         *\n         * @param multiset  the multiset to decorate, must not be null\n         * @return the decorated multiset.\n         * @throws NullPointerException if multiset is null\n         * @throws IllegalArgumentException if multiset contains invalid elements\n         */\n        public MultiSet<E> createPredicatedMultiSet(final MultiSet<E> multiset) {\n            Objects.requireNonNull(multiset, \"multiset\");\n            final PredicatedMultiSet<E> predicatedMultiSet =\n                    PredicatedMultiSet.predicatedMultiSet(multiset, predicate);\n            predicatedMultiSet.addAll(accepted);\n            return predicatedMultiSet;\n        }\n\n        /**\n         * Create a new predicated queue filled with the accepted elements.\n         * <p>\n         * The builder is not modified by this method, so it is possible to create more collections\n         * or add more elements afterwards. Further changes will not propagate to the returned queue.\n         *\n         * @return a new predicated queue.\n         */\n        public Queue<E> createPredicatedQueue() {\n            return createPredicatedQueue(new LinkedList<>());\n        }\n\n        /**\n         * Decorates the given queue with validating behavior using the predicate. All accepted elements\n         * are appended to the queue. If the queue already contains elements, they are validated.\n         * <p>\n         * The builder is not modified by this method, so it is possible to create more collections\n         * or add more elements afterwards. Further changes will not propagate to the returned queue.\n         *\n         * @param queue  the queue to decorate, must not be null\n         * @return the decorated queue.\n         * @throws NullPointerException if queue is null\n         * @throws IllegalArgumentException if queue contains invalid elements\n         */\n        public Queue<E> createPredicatedQueue(final Queue<E> queue) {\n            Objects.requireNonNull(queue, \"queue\");\n            final PredicatedQueue<E> predicatedQueue = PredicatedQueue.predicatedQueue(queue, predicate);\n            predicatedQueue.addAll(accepted);\n            return predicatedQueue;\n        }\n\n        /**\n         * Create a new predicated set filled with the accepted elements.\n         * <p>\n         * The builder is not modified by this method, so it is possible to create more collections\n         * or add more elements afterwards. Further changes will not propagate to the returned set.\n         *\n         * @return a new predicated set.\n         */\n        public Set<E> createPredicatedSet() {\n            return createPredicatedSet(new HashSet<>());\n        }\n\n        /**\n         * Decorates the given list with validating behavior using the predicate. All accepted elements\n         * are appended to the set. If the set already contains elements, they are validated.\n         * <p>\n         * The builder is not modified by this method, so it is possible to create more collections\n         * or add more elements afterwards. Further changes will not propagate to the returned set.\n         *\n         * @param set  the set to decorate, must not be null\n         * @return the decorated set.\n         * @throws NullPointerException if set is null\n         * @throws IllegalArgumentException if set contains invalid elements\n         */\n        public Set<E> createPredicatedSet(final Set<E> set) {\n            Objects.requireNonNull(set, \"set\");\n            final PredicatedSet<E> predicatedSet = PredicatedSet.predicatedSet(set, predicate);\n            predicatedSet.addAll(accepted);\n            return predicatedSet;\n        }\n\n        /**\n         * Returns an unmodifiable collection containing all rejected elements.\n         *\n         * @return an unmodifiable collection\n         */\n        public Collection<E> rejectedElements() {\n            return Collections.unmodifiableCollection(rejected);\n        }\n\n    }", "definition": "    public static class Builder<E>", "class_docstring": "\nBuilder for creating predicated collections.\n<p>\nCreate a Builder with a predicate to validate elements against, then add any elements\nto the builder. Elements that fail the predicate will be added to a rejected list.\nFinally, create or decorate a collection using the createPredicated[List,Set,Bag,Queue] methods.\n<p>\nAn example:\n<pre>\n  Predicate&lt;String&gt; predicate = NotNullPredicate.notNullPredicate();\n  PredicatedCollectionBuilder&lt;String&gt; builder = PredicatedCollection.builder(predicate);\n  builder.add(\"item1\");\n  builder.add(null);\n  builder.add(\"item2\");\n  List&lt;String&gt; predicatedList = builder.createPredicatedList();\n</pre>\n<p>\nAt the end of the code fragment above predicatedList is protected by the predicate supplied\nto the builder, and it contains item1 and item2.\n<p>\nMore elements can be added to the builder once a predicated collection has been created,\nbut these elements will not be reflected in already created collections.\n\n@param <E>  the element type\n@since 4.1\n", "name": "Builder", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "private final Predicate<? super E> predicate;", "docstring": " The predicate to use.", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Predicate<? super E>", "name": "predicate", "syntax_pass": true}, {"attribute_expression": "private final List<E> accepted = new ArrayList<>();", "docstring": " The buffer containing valid elements.", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<E>", "name": "accepted = new ArrayList<>()", "syntax_pass": true}, {"attribute_expression": "private final List<E> rejected = new ArrayList<>();", "docstring": " The buffer containing rejected elements.", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<E>", "name": "rejected = new ArrayList<>()", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public Builder(final Predicate<? super E> predicate) {\n            this.predicate = Objects.requireNonNull(predicate, \"predicate\");\n        }", "docstring": "\nConstructs a PredicatedCollectionBuilder with the specified Predicate.\n\n@param predicate  the predicate to use\n@throws NullPointerException if predicate is null\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "Builder", "params": [{"name": "predicate", "type": "Predicate<? super E>"}], "body": "                                                             {\n            this.predicate = Objects.requireNonNull(predicate, \"predicate\");\n        }", "signature": "public Builder(final Predicate<? super E> predicate)"}, {"syntax_pass": true, "original_string": "        public Builder<E> add(final E item) {\n            if (predicate.test(item)) {\n                accepted.add(item);\n            } else {\n                rejected.add(item);\n            }\n            return this;\n        }", "docstring": "\nAdds the item to the builder.\n<p>\nIf the predicate is true, it is added to the list of accepted elements,\notherwise it is added to the rejected list.\n\n@param item  the element to add\n@return the PredicatedCollectionBuilder.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder<E>", "classes": []}, "name": "add", "params": [{"name": "item", "type": "E"}], "body": "                                            {\n            if (predicate.test(item)) {\n                accepted.add(item);\n            } else {\n                rejected.add(item);\n            }\n            return this;\n        }", "signature": "public Builder<E> add(final E item)"}, {"syntax_pass": true, "original_string": "        public Builder<E> addAll(final Collection<? extends E> items) {\n            if (items != null) {\n                for (final E item : items) {\n                    add(item);\n                }\n            }\n            return this;\n        }", "docstring": "\nAdds all elements from the given collection to the builder.\n<p>\nAll elements for which the predicate evaluates to true will be added to the\nlist of accepted elements, otherwise they are added to the rejected list.\n\n@param items  the elements to add to the builder\n@return the PredicatedCollectionBuilder.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder<E>", "classes": []}, "name": "addAll", "params": [{"name": "items", "type": "Collection<? extends E>"}], "body": "                                                                      {\n            if (items != null) {\n                for (final E item : items) {\n                    add(item);\n                }\n            }\n            return this;\n        }", "signature": "public Builder<E> addAll(final Collection<? extends E> items)"}, {"syntax_pass": true, "original_string": "        public Bag<E> createPredicatedBag() {\n            return createPredicatedBag(new HashBag<>());\n        }", "docstring": "\nCreate a new predicated bag filled with the accepted elements.\n<p>\nThe builder is not modified by this method, so it is possible to create more collections\nor add more elements afterwards. Further changes will not propagate to the returned bag.\n\n@return a new predicated bag.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Bag<E>", "classes": []}, "name": "createPredicatedBag", "params": [], "body": "                                            {\n            return createPredicatedBag(new HashBag<>());\n        }", "signature": "public Bag<E> createPredicatedBag()"}, {"syntax_pass": true, "original_string": "        public Bag<E> createPredicatedBag(final Bag<E> bag) {\n            Objects.requireNonNull(bag, \"bag\");\n            final PredicatedBag<E> predicatedBag = PredicatedBag.predicatedBag(bag, predicate);\n            predicatedBag.addAll(accepted);\n            return predicatedBag;\n        }", "docstring": "\nDecorates the given bag with validating behavior using the predicate. All accepted elements\nare appended to the bag. If the bag already contains elements, they are validated.\n<p>\nThe builder is not modified by this method, so it is possible to create more collections\nor add more elements afterwards. Further changes will not propagate to the returned bag.\n\n@param bag  the bag to decorate, must not be null\n@return the decorated bag.\n@throws NullPointerException if bag is null\n@throws IllegalArgumentException if bag contains invalid elements\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Bag<E>", "classes": []}, "name": "createPredicatedBag", "params": [{"name": "bag", "type": "Bag<E>"}], "body": "                                                            {\n            Objects.requireNonNull(bag, \"bag\");\n            final PredicatedBag<E> predicatedBag = PredicatedBag.predicatedBag(bag, predicate);\n            predicatedBag.addAll(accepted);\n            return predicatedBag;\n        }", "signature": "public Bag<E> createPredicatedBag(final Bag<E> bag)"}, {"syntax_pass": true, "original_string": "        public List<E> createPredicatedList() {\n            return createPredicatedList(new ArrayList<>());\n        }", "docstring": "\nCreate a new predicated list filled with the accepted elements.\n<p>\nThe builder is not modified by this method, so it is possible to create more collections\nor add more elements afterwards. Further changes will not propagate to the returned list.\n\n@return a new predicated list.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<E>", "classes": []}, "name": "createPredicatedList", "params": [], "body": "                                              {\n            return createPredicatedList(new ArrayList<>());\n        }", "signature": "public List<E> createPredicatedList()"}, {"syntax_pass": true, "original_string": "        public List<E> createPredicatedList(final List<E> list) {\n            Objects.requireNonNull(list, \"list\");\n            final List<E> predicatedList = PredicatedList.predicatedList(list, predicate);\n            predicatedList.addAll(accepted);\n            return predicatedList;\n        }", "docstring": "\nDecorates the given list with validating behavior using the predicate. All accepted elements\nare appended to the list. If the list already contains elements, they are validated.\n<p>\nThe builder is not modified by this method, so it is possible to create more collections\nor add more elements afterwards. Further changes will not propagate to the returned list.\n\n@param list  the List to decorate, must not be null\n@return the decorated list.\n@throws NullPointerException if list is null\n@throws IllegalArgumentException if list contains invalid elements\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<E>", "classes": []}, "name": "createPredicatedList", "params": [{"name": "list", "type": "List<E>"}], "body": "                                                                {\n            Objects.requireNonNull(list, \"list\");\n            final List<E> predicatedList = PredicatedList.predicatedList(list, predicate);\n            predicatedList.addAll(accepted);\n            return predicatedList;\n        }", "signature": "public List<E> createPredicatedList(final List<E> list)"}, {"syntax_pass": true, "original_string": "        public MultiSet<E> createPredicatedMultiSet() {\n            return createPredicatedMultiSet(new HashMultiSet<>());\n        }", "docstring": "\nCreate a new predicated multiset filled with the accepted elements.\n<p>\nThe builder is not modified by this method, so it is possible to create more collections\nor add more elements afterwards. Further changes will not propagate to the returned multiset.\n\n@return a new predicated multiset.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "MultiSet<E>", "classes": []}, "name": "createPredicatedMultiSet", "params": [], "body": "                                                      {\n            return createPredicatedMultiSet(new HashMultiSet<>());\n        }", "signature": "public MultiSet<E> createPredicatedMultiSet()"}, {"syntax_pass": true, "original_string": "        public MultiSet<E> createPredicatedMultiSet(final MultiSet<E> multiset) {\n            Objects.requireNonNull(multiset, \"multiset\");\n            final PredicatedMultiSet<E> predicatedMultiSet =\n                    PredicatedMultiSet.predicatedMultiSet(multiset, predicate);\n            predicatedMultiSet.addAll(accepted);\n            return predicatedMultiSet;\n        }", "docstring": "\nDecorates the given multiset with validating behavior using the predicate. All accepted elements\nare appended to the multiset. If the multiset already contains elements, they are validated.\n<p>\nThe builder is not modified by this method, so it is possible to create more collections\nor add more elements afterwards. Further changes will not propagate to the returned multiset.\n\n@param multiset  the multiset to decorate, must not be null\n@return the decorated multiset.\n@throws NullPointerException if multiset is null\n@throws IllegalArgumentException if multiset contains invalid elements\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "MultiSet<E>", "classes": []}, "name": "createPredicatedMultiSet", "params": [{"name": "multiset", "type": "MultiSet<E>"}], "body": "                                                                                {\n            Objects.requireNonNull(multiset, \"multiset\");\n            final PredicatedMultiSet<E> predicatedMultiSet =\n                    PredicatedMultiSet.predicatedMultiSet(multiset, predicate);\n            predicatedMultiSet.addAll(accepted);\n            return predicatedMultiSet;\n        }", "signature": "public MultiSet<E> createPredicatedMultiSet(final MultiSet<E> multiset)"}, {"syntax_pass": true, "original_string": "        public Queue<E> createPredicatedQueue() {\n            return createPredicatedQueue(new LinkedList<>());\n        }", "docstring": "\nCreate a new predicated queue filled with the accepted elements.\n<p>\nThe builder is not modified by this method, so it is possible to create more collections\nor add more elements afterwards. Further changes will not propagate to the returned queue.\n\n@return a new predicated queue.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Queue<E>", "classes": []}, "name": "createPredicatedQueue", "params": [], "body": "                                                {\n            return createPredicatedQueue(new LinkedList<>());\n        }", "signature": "public Queue<E> createPredicatedQueue()"}, {"syntax_pass": true, "original_string": "        public Queue<E> createPredicatedQueue(final Queue<E> queue) {\n            Objects.requireNonNull(queue, \"queue\");\n            final PredicatedQueue<E> predicatedQueue = PredicatedQueue.predicatedQueue(queue, predicate);\n            predicatedQueue.addAll(accepted);\n            return predicatedQueue;\n        }", "docstring": "\nDecorates the given queue with validating behavior using the predicate. All accepted elements\nare appended to the queue. If the queue already contains elements, they are validated.\n<p>\nThe builder is not modified by this method, so it is possible to create more collections\nor add more elements afterwards. Further changes will not propagate to the returned queue.\n\n@param queue  the queue to decorate, must not be null\n@return the decorated queue.\n@throws NullPointerException if queue is null\n@throws IllegalArgumentException if queue contains invalid elements\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Queue<E>", "classes": []}, "name": "createPredicatedQueue", "params": [{"name": "queue", "type": "Queue<E>"}], "body": "                                                                    {\n            Objects.requireNonNull(queue, \"queue\");\n            final PredicatedQueue<E> predicatedQueue = PredicatedQueue.predicatedQueue(queue, predicate);\n            predicatedQueue.addAll(accepted);\n            return predicatedQueue;\n        }", "signature": "public Queue<E> createPredicatedQueue(final Queue<E> queue)"}, {"syntax_pass": true, "original_string": "        public Set<E> createPredicatedSet() {\n            return createPredicatedSet(new HashSet<>());\n        }", "docstring": "\nCreate a new predicated set filled with the accepted elements.\n<p>\nThe builder is not modified by this method, so it is possible to create more collections\nor add more elements afterwards. Further changes will not propagate to the returned set.\n\n@return a new predicated set.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Set<E>", "classes": []}, "name": "createPredicatedSet", "params": [], "body": "                                            {\n            return createPredicatedSet(new HashSet<>());\n        }", "signature": "public Set<E> createPredicatedSet()"}, {"syntax_pass": true, "original_string": "        public Set<E> createPredicatedSet(final Set<E> set) {\n            Objects.requireNonNull(set, \"set\");\n            final PredicatedSet<E> predicatedSet = PredicatedSet.predicatedSet(set, predicate);\n            predicatedSet.addAll(accepted);\n            return predicatedSet;\n        }", "docstring": "\nDecorates the given list with validating behavior using the predicate. All accepted elements\nare appended to the set. If the set already contains elements, they are validated.\n<p>\nThe builder is not modified by this method, so it is possible to create more collections\nor add more elements afterwards. Further changes will not propagate to the returned set.\n\n@param set  the set to decorate, must not be null\n@return the decorated set.\n@throws NullPointerException if set is null\n@throws IllegalArgumentException if set contains invalid elements\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Set<E>", "classes": []}, "name": "createPredicatedSet", "params": [{"name": "set", "type": "Set<E>"}], "body": "                                                            {\n            Objects.requireNonNull(set, \"set\");\n            final PredicatedSet<E> predicatedSet = PredicatedSet.predicatedSet(set, predicate);\n            predicatedSet.addAll(accepted);\n            return predicatedSet;\n        }", "signature": "public Set<E> createPredicatedSet(final Set<E> set)"}, {"syntax_pass": true, "original_string": "        public Collection<E> rejectedElements() {\n            return Collections.unmodifiableCollection(rejected);\n        }", "docstring": "\nReturns an unmodifiable collection containing all rejected elements.\n\n@return an unmodifiable collection\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Collection<E>", "classes": []}, "name": "rejectedElements", "params": [], "body": "                                                {\n            return Collections.unmodifiableCollection(rejected);\n        }", "signature": "public Collection<E> rejectedElements()"}]}], "class_docstring": "\nDecorates another {@link Collection} to validate that additions\nmatch a specified predicate.\n<p>\nThis collection exists to provide validation for the decorated collection.\nIt is normally created to decorate an empty collection.\nIf an object cannot be added to the collection, an IllegalArgumentException is thrown.\n</p>\n<p>\nOne usage would be to ensure that no null entries are added to the collection:\n</p>\n<pre>\nCollection coll = PredicatedCollection.predicatedCollection(new ArrayList(), NotNullPredicate.INSTANCE);\n</pre>\n<p>\nThis class is Serializable from Commons Collections 3.1.\n</p>\n\n@param <E> the type of the elements in the collection\n@since 3.0\n", "original_string": "public class PredicatedCollection<E> extends AbstractCollectionDecorator<E> {\n\n    /**\n     * Builder for creating predicated collections.\n     * <p>\n     * Create a Builder with a predicate to validate elements against, then add any elements\n     * to the builder. Elements that fail the predicate will be added to a rejected list.\n     * Finally, create or decorate a collection using the createPredicated[List,Set,Bag,Queue] methods.\n     * <p>\n     * An example:\n     * <pre>\n     *   Predicate&lt;String&gt; predicate = NotNullPredicate.notNullPredicate();\n     *   PredicatedCollectionBuilder&lt;String&gt; builder = PredicatedCollection.builder(predicate);\n     *   builder.add(\"item1\");\n     *   builder.add(null);\n     *   builder.add(\"item2\");\n     *   List&lt;String&gt; predicatedList = builder.createPredicatedList();\n     * </pre>\n     * <p>\n     * At the end of the code fragment above predicatedList is protected by the predicate supplied\n     * to the builder, and it contains item1 and item2.\n     * <p>\n     * More elements can be added to the builder once a predicated collection has been created,\n     * but these elements will not be reflected in already created collections.\n     *\n     * @param <E>  the element type\n     * @since 4.1\n     */\n    public static class Builder<E> {\n\n        /** The predicate to use. */\n        private final Predicate<? super E> predicate;\n\n        /** The buffer containing valid elements. */\n        private final List<E> accepted = new ArrayList<>();\n\n        /** The buffer containing rejected elements. */\n        private final List<E> rejected = new ArrayList<>();\n\n        /**\n         * Constructs a PredicatedCollectionBuilder with the specified Predicate.\n         *\n         * @param predicate  the predicate to use\n         * @throws NullPointerException if predicate is null\n         */\n        public Builder(final Predicate<? super E> predicate) {\n            this.predicate = Objects.requireNonNull(predicate, \"predicate\");\n        }\n\n        /**\n         * Adds the item to the builder.\n         * <p>\n         * If the predicate is true, it is added to the list of accepted elements,\n         * otherwise it is added to the rejected list.\n         *\n         * @param item  the element to add\n         * @return the PredicatedCollectionBuilder.\n         */\n        public Builder<E> add(final E item) {\n            if (predicate.test(item)) {\n                accepted.add(item);\n            } else {\n                rejected.add(item);\n            }\n            return this;\n        }\n\n        /**\n         * Adds all elements from the given collection to the builder.\n         * <p>\n         * All elements for which the predicate evaluates to true will be added to the\n         * list of accepted elements, otherwise they are added to the rejected list.\n         *\n         * @param items  the elements to add to the builder\n         * @return the PredicatedCollectionBuilder.\n         */\n        public Builder<E> addAll(final Collection<? extends E> items) {\n            if (items != null) {\n                for (final E item : items) {\n                    add(item);\n                }\n            }\n            return this;\n        }\n\n        /**\n         * Create a new predicated bag filled with the accepted elements.\n         * <p>\n         * The builder is not modified by this method, so it is possible to create more collections\n         * or add more elements afterwards. Further changes will not propagate to the returned bag.\n         *\n         * @return a new predicated bag.\n         */\n        public Bag<E> createPredicatedBag() {\n            return createPredicatedBag(new HashBag<>());\n        }\n\n        /**\n         * Decorates the given bag with validating behavior using the predicate. All accepted elements\n         * are appended to the bag. If the bag already contains elements, they are validated.\n         * <p>\n         * The builder is not modified by this method, so it is possible to create more collections\n         * or add more elements afterwards. Further changes will not propagate to the returned bag.\n         *\n         * @param bag  the bag to decorate, must not be null\n         * @return the decorated bag.\n         * @throws NullPointerException if bag is null\n         * @throws IllegalArgumentException if bag contains invalid elements\n         */\n        public Bag<E> createPredicatedBag(final Bag<E> bag) {\n            Objects.requireNonNull(bag, \"bag\");\n            final PredicatedBag<E> predicatedBag = PredicatedBag.predicatedBag(bag, predicate);\n            predicatedBag.addAll(accepted);\n            return predicatedBag;\n        }\n\n        /**\n         * Create a new predicated list filled with the accepted elements.\n         * <p>\n         * The builder is not modified by this method, so it is possible to create more collections\n         * or add more elements afterwards. Further changes will not propagate to the returned list.\n         *\n         * @return a new predicated list.\n         */\n        public List<E> createPredicatedList() {\n            return createPredicatedList(new ArrayList<>());\n        }\n\n        /**\n         * Decorates the given list with validating behavior using the predicate. All accepted elements\n         * are appended to the list. If the list already contains elements, they are validated.\n         * <p>\n         * The builder is not modified by this method, so it is possible to create more collections\n         * or add more elements afterwards. Further changes will not propagate to the returned list.\n         *\n         * @param list  the List to decorate, must not be null\n         * @return the decorated list.\n         * @throws NullPointerException if list is null\n         * @throws IllegalArgumentException if list contains invalid elements\n         */\n        public List<E> createPredicatedList(final List<E> list) {\n            Objects.requireNonNull(list, \"list\");\n            final List<E> predicatedList = PredicatedList.predicatedList(list, predicate);\n            predicatedList.addAll(accepted);\n            return predicatedList;\n        }\n\n        /**\n         * Create a new predicated multiset filled with the accepted elements.\n         * <p>\n         * The builder is not modified by this method, so it is possible to create more collections\n         * or add more elements afterwards. Further changes will not propagate to the returned multiset.\n         *\n         * @return a new predicated multiset.\n         */\n        public MultiSet<E> createPredicatedMultiSet() {\n            return createPredicatedMultiSet(new HashMultiSet<>());\n        }\n\n        /**\n         * Decorates the given multiset with validating behavior using the predicate. All accepted elements\n         * are appended to the multiset. If the multiset already contains elements, they are validated.\n         * <p>\n         * The builder is not modified by this method, so it is possible to create more collections\n         * or add more elements afterwards. Further changes will not propagate to the returned multiset.\n         *\n         * @param multiset  the multiset to decorate, must not be null\n         * @return the decorated multiset.\n         * @throws NullPointerException if multiset is null\n         * @throws IllegalArgumentException if multiset contains invalid elements\n         */\n        public MultiSet<E> createPredicatedMultiSet(final MultiSet<E> multiset) {\n            Objects.requireNonNull(multiset, \"multiset\");\n            final PredicatedMultiSet<E> predicatedMultiSet =\n                    PredicatedMultiSet.predicatedMultiSet(multiset, predicate);\n            predicatedMultiSet.addAll(accepted);\n            return predicatedMultiSet;\n        }\n\n        /**\n         * Create a new predicated queue filled with the accepted elements.\n         * <p>\n         * The builder is not modified by this method, so it is possible to create more collections\n         * or add more elements afterwards. Further changes will not propagate to the returned queue.\n         *\n         * @return a new predicated queue.\n         */\n        public Queue<E> createPredicatedQueue() {\n            return createPredicatedQueue(new LinkedList<>());\n        }\n\n        /**\n         * Decorates the given queue with validating behavior using the predicate. All accepted elements\n         * are appended to the queue. If the queue already contains elements, they are validated.\n         * <p>\n         * The builder is not modified by this method, so it is possible to create more collections\n         * or add more elements afterwards. Further changes will not propagate to the returned queue.\n         *\n         * @param queue  the queue to decorate, must not be null\n         * @return the decorated queue.\n         * @throws NullPointerException if queue is null\n         * @throws IllegalArgumentException if queue contains invalid elements\n         */\n        public Queue<E> createPredicatedQueue(final Queue<E> queue) {\n            Objects.requireNonNull(queue, \"queue\");\n            final PredicatedQueue<E> predicatedQueue = PredicatedQueue.predicatedQueue(queue, predicate);\n            predicatedQueue.addAll(accepted);\n            return predicatedQueue;\n        }\n\n        /**\n         * Create a new predicated set filled with the accepted elements.\n         * <p>\n         * The builder is not modified by this method, so it is possible to create more collections\n         * or add more elements afterwards. Further changes will not propagate to the returned set.\n         *\n         * @return a new predicated set.\n         */\n        public Set<E> createPredicatedSet() {\n            return createPredicatedSet(new HashSet<>());\n        }\n\n        /**\n         * Decorates the given list with validating behavior using the predicate. All accepted elements\n         * are appended to the set. If the set already contains elements, they are validated.\n         * <p>\n         * The builder is not modified by this method, so it is possible to create more collections\n         * or add more elements afterwards. Further changes will not propagate to the returned set.\n         *\n         * @param set  the set to decorate, must not be null\n         * @return the decorated set.\n         * @throws NullPointerException if set is null\n         * @throws IllegalArgumentException if set contains invalid elements\n         */\n        public Set<E> createPredicatedSet(final Set<E> set) {\n            Objects.requireNonNull(set, \"set\");\n            final PredicatedSet<E> predicatedSet = PredicatedSet.predicatedSet(set, predicate);\n            predicatedSet.addAll(accepted);\n            return predicatedSet;\n        }\n\n        /**\n         * Returns an unmodifiable collection containing all rejected elements.\n         *\n         * @return an unmodifiable collection\n         */\n        public Collection<E> rejectedElements() {\n            return Collections.unmodifiableCollection(rejected);\n        }\n\n    }\n\n    /** Serialization version */\n    private static final long serialVersionUID = -5259182142076705162L;\n\n    /**\n     * Returns a Builder with the given predicate.\n     *\n     * @param <E>  the element type\n     * @param predicate  the predicate to use\n     * @return a new Builder for predicated collections\n     * @since 4.1\n     */\n    public static <E> Builder<E> builder(final Predicate<? super E> predicate) {\n        return new Builder<>(predicate);\n    }\n\n    /**\n     * Returns a Builder with a NotNullPredicate.\n     *\n     * @param <E>  the element type\n     * @return a new Builder for predicated collections that ignores null values.\n     * @since 4.1\n     */\n    public static <E> Builder<E> notNullBuilder() {\n        return new Builder<>(NotNullPredicate.<E>notNullPredicate());\n    }\n\n    /**\n     * Factory method to create a predicated (validating) collection.\n     * <p>\n     * If there are any elements already in the collection being decorated, they\n     * are validated.\n     *\n     * @param <T> the type of the elements in the collection\n     * @param coll  the collection to decorate, must not be null\n     * @param predicate  the predicate to use for validation, must not be null\n     * @return a new predicated collection\n     * @throws NullPointerException if collection or predicate is null\n     * @throws IllegalArgumentException if the collection contains invalid elements\n     * @since 4.0\n     */\n    public static <T> PredicatedCollection<T> predicatedCollection(final Collection<T> coll,\n                                                                   final Predicate<? super T> predicate) {\n        return new PredicatedCollection<>(coll, predicate);\n    }\n\n    /** The predicate to use */\n    protected final Predicate<? super E> predicate;\n\n    /**\n     * Constructor that wraps (not copies).\n     * <p>\n     * If there are any elements already in the collection being decorated, they\n     * are validated.\n     *\n     * @param collection  the collection to decorate, must not be null\n     * @param predicate  the predicate to use for validation, must not be null\n     * @throws NullPointerException if collection or predicate is null\n     * @throws IllegalArgumentException if the collection contains invalid elements\n     */\n    protected PredicatedCollection(final Collection<E> collection, final Predicate<? super E> predicate) {\n        super(collection);\n        this.predicate = Objects.requireNonNull(predicate, \"predicate\");\n        for (final E item : collection) {\n            validate(item);\n        }\n    }\n\n    /**\n     * Override to validate the object being added to ensure it matches\n     * the predicate.\n     *\n     * @param object  the object being added\n     * @return the result of adding to the underlying collection\n     * @throws IllegalArgumentException if the add is invalid\n     */\n    @Override\n    public boolean add(final E object) {\n        validate(object);\n        return decorated().add(object);\n    }\n\n    /**\n     * Override to validate the objects being added to ensure they match\n     * the predicate. If anyone fails, no update is made to the underlying\n     * collection.\n     *\n     * @param coll  the collection being added\n     * @return the result of adding to the underlying collection\n     * @throws IllegalArgumentException if the add is invalid\n     */\n    @Override\n    public boolean addAll(final Collection<? extends E> coll) {\n        for (final E item : coll) {\n            validate(item);\n        }\n        return decorated().addAll(coll);\n    }\n\n    /**\n     * Validates the object being added to ensure it matches the predicate.\n     * <p>\n     * The predicate itself should not throw an exception, but return false to\n     * indicate that the object cannot be added.\n     *\n     * @param object  the object being added\n     * @throws IllegalArgumentException if the add is invalid\n     */\n    protected void validate(final E object) {\n        if (!predicate.test(object)) {\n            throw new IllegalArgumentException(\"Cannot add Object '\" + object + \"' - Predicate '\" +\n                                               predicate + \"' rejected it\");\n        }\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = -5259182142076705162L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -5259182142076705162L", "syntax_pass": true}, {"attribute_expression": "protected final Predicate<? super E> predicate;", "docstring": " The predicate to use", "modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "type": "Predicate<? super E>", "name": "predicate", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/collection/TransformedCollection.java.TransformedCollection", "name": "TransformedCollection", "file_path": "src/main/java/org/apache/commons/collections4/collection/TransformedCollection.java", "superclasses": "", "methods": ["[TransformedCollection<E>]transformedCollection(Collection<E>,Transformer<? super E, ? extends E>)", "[TransformedCollection<E>]transformingCollection(Collection<E>,Transformer<? super E, ? extends E>)", "[]TransformedCollection(Collection<E>,Transformer<? super E, ? extends E>)", "[boolean]add(E)", "[boolean]addAll(Collection<? extends E>)", "[Collection<E>]transform(Collection<? extends E>)", "[E]transform(E)"], "method_uris": ["src/main/java/org/apache/commons/collections4/collection/TransformedCollection.java.TransformedCollection.[TransformedCollection<E>]transformedCollection(Collection<E>,Transformer<? super E, ? extends E>)", "src/main/java/org/apache/commons/collections4/collection/TransformedCollection.java.TransformedCollection.[TransformedCollection<E>]transformingCollection(Collection<E>,Transformer<? super E, ? extends E>)", "src/main/java/org/apache/commons/collections4/collection/TransformedCollection.java.TransformedCollection.[]TransformedCollection(Collection<E>,Transformer<? super E, ? extends E>)", "src/main/java/org/apache/commons/collections4/collection/TransformedCollection.java.TransformedCollection.[boolean]add(E)", "src/main/java/org/apache/commons/collections4/collection/TransformedCollection.java.TransformedCollection.[boolean]addAll(Collection<? extends E>)", "src/main/java/org/apache/commons/collections4/collection/TransformedCollection.java.TransformedCollection.[Collection<E>]transform(Collection<? extends E>)", "src/main/java/org/apache/commons/collections4/collection/TransformedCollection.java.TransformedCollection.[E]transform(E)"], "overrides": null, "attributes": [], "class_docstring": "\nDecorates another {@link Collection} to transform objects that are added.\n<p>\nThe add methods are affected by this class.\nThus objects must be removed or searched for using their transformed form.\nFor example, if the transformation converts Strings to Integers, you must\nuse the Integer form to remove objects.\n</p>\n<p>\nThis class is Serializable from Commons Collections 3.1.\n</p>\n\n@param <E> the type of the elements in the collection\n@since 3.0\n", "original_string": "public class TransformedCollection<E> extends AbstractCollectionDecorator<E> {\n\n    /** Serialization version */\n    private static final long serialVersionUID = 8692300188161871514L;\n\n    /**\n     * Factory method to create a transforming collection that will transform\n     * existing contents of the specified collection.\n     * <p>\n     * If there are any elements already in the collection being decorated, they\n     * will be transformed by this method.\n     * Contrast this with {@link #transformingCollection(Collection, Transformer)}.\n     *\n     * @param <E> the type of the elements in the collection\n     * @param collection  the collection to decorate, must not be null\n     * @param transformer  the transformer to use for conversion, must not be null\n     * @return a new transformed Collection\n     * @throws NullPointerException if collection or transformer is null\n     * @since 4.0\n     */\n    public static <E> TransformedCollection<E> transformedCollection(final Collection<E> collection,\n            final Transformer<? super E, ? extends E> transformer) {\n\n        final TransformedCollection<E> decorated = new TransformedCollection<>(collection, transformer);\n        // null collection & transformer are disallowed by the constructor call above\n        if (!collection.isEmpty()) {\n            @SuppressWarnings(\"unchecked\") // collection is of type E\n            final E[] values = (E[]) collection.toArray(); // NOPMD - false positive for generics\n            collection.clear();\n            for (final E value : values) {\n                decorated.decorated().add(transformer.apply(value));\n            }\n        }\n        return decorated;\n    }\n\n    /**\n     * Factory method to create a transforming collection.\n     * <p>\n     * If there are any elements already in the collection being decorated, they\n     * are NOT transformed.\n     * Contrast this with {@link #transformedCollection(Collection, Transformer)}.\n     *\n     * @param <E> the type of the elements in the collection\n     * @param coll  the collection to decorate, must not be null\n     * @param transformer  the transformer to use for conversion, must not be null\n     * @return a new transformed collection\n     * @throws NullPointerException if collection or transformer is null\n     * @since 4.0\n     */\n    public static <E> TransformedCollection<E> transformingCollection(final Collection<E> coll,\n            final Transformer<? super E, ? extends E> transformer) {\n        return new TransformedCollection<>(coll, transformer);\n    }\n\n    /** The transformer to use */\n    protected final Transformer<? super E, ? extends E> transformer;\n\n    /**\n     * Constructor that wraps (not copies).\n     * <p>\n     * If there are any elements already in the collection being decorated, they\n     * are NOT transformed.\n     *\n     * @param collection  the collection to decorate, must not be null\n     * @param transformer  the transformer to use for conversion, must not be null\n     * @throws NullPointerException if collection or transformer is null\n     */\n    protected TransformedCollection(final Collection<E> collection, final Transformer<? super E, ? extends E> transformer) {\n        super(collection);\n        this.transformer = Objects.requireNonNull(transformer, \"transformer\");\n    }\n\n    @Override\n    public boolean add(final E object) {\n        return decorated().add(transform(object));\n    }\n\n    @Override\n    public boolean addAll(final Collection<? extends E> coll) {\n        return decorated().addAll(transform(coll));\n    }\n\n    /**\n     * Transforms a collection.\n     * <p>\n     * The transformer itself may throw an exception if necessary.\n     *\n     * @param coll  the collection to transform\n     * @return a transformed object\n     */\n    protected Collection<E> transform(final Collection<? extends E> coll) {\n        final List<E> list = new ArrayList<>(coll.size());\n        for (final E item : coll) {\n            list.add(transform(item));\n        }\n        return list;\n    }\n\n    /**\n     * Transforms an object.\n     * <p>\n     * The transformer itself may throw an exception if necessary.\n     *\n     * @param object  the object to transform\n     * @return a transformed object\n     */\n    protected E transform(final E object) {\n        return transformer.apply(object);\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = 8692300188161871514L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 8692300188161871514L", "syntax_pass": true}, {"attribute_expression": "protected final Transformer<? super E, ? extends E> transformer;", "docstring": " The transformer to use", "modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "type": "Transformer<? super E, ? extends E>", "name": "transformer", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/collection/IndexedCollection.java.IndexedCollection", "name": "IndexedCollection", "file_path": "src/main/java/org/apache/commons/collections4/collection/IndexedCollection.java", "superclasses": "", "methods": ["[IndexedCollection<K, C>]nonUniqueIndexedCollection(Collection<C>,Transformer<C, K>)", "[IndexedCollection<K, C>]uniqueIndexedCollection(Collection<C>,Transformer<C, K>)", "[]IndexedCollection(Collection<C>,Transformer<C, K>,MultiMap<K, C>,boolean)", "[boolean]add(C)", "[boolean]addAll(Collection<? extends C>)", "[void]addToIndex(C)", "[void]clear()", "[boolean]contains(Object)", "[boolean]containsAll(Collection<?>)", "[C]get(K)", "[void]reindex()", "[boolean]remove(Object)", "[boolean]removeAll(Collection<?>)", "[void]removeFromIndex(C)", "[boolean]removeIf(Predicate<? super C>)", "[boolean]retainAll(Collection<?>)", "[Collection<C>]values(K)"], "method_uris": ["src/main/java/org/apache/commons/collections4/collection/IndexedCollection.java.IndexedCollection.[IndexedCollection<K, C>]nonUniqueIndexedCollection(Collection<C>,Transformer<C, K>)", "src/main/java/org/apache/commons/collections4/collection/IndexedCollection.java.IndexedCollection.[IndexedCollection<K, C>]uniqueIndexedCollection(Collection<C>,Transformer<C, K>)", "src/main/java/org/apache/commons/collections4/collection/IndexedCollection.java.IndexedCollection.[]IndexedCollection(Collection<C>,Transformer<C, K>,MultiMap<K, C>,boolean)", "src/main/java/org/apache/commons/collections4/collection/IndexedCollection.java.IndexedCollection.[boolean]add(C)", "src/main/java/org/apache/commons/collections4/collection/IndexedCollection.java.IndexedCollection.[boolean]addAll(Collection<? extends C>)", "src/main/java/org/apache/commons/collections4/collection/IndexedCollection.java.IndexedCollection.[void]addToIndex(C)", "src/main/java/org/apache/commons/collections4/collection/IndexedCollection.java.IndexedCollection.[void]clear()", "src/main/java/org/apache/commons/collections4/collection/IndexedCollection.java.IndexedCollection.[boolean]contains(Object)", "src/main/java/org/apache/commons/collections4/collection/IndexedCollection.java.IndexedCollection.[boolean]containsAll(Collection<?>)", "src/main/java/org/apache/commons/collections4/collection/IndexedCollection.java.IndexedCollection.[C]get(K)", "src/main/java/org/apache/commons/collections4/collection/IndexedCollection.java.IndexedCollection.[void]reindex()", "src/main/java/org/apache/commons/collections4/collection/IndexedCollection.java.IndexedCollection.[boolean]remove(Object)", "src/main/java/org/apache/commons/collections4/collection/IndexedCollection.java.IndexedCollection.[boolean]removeAll(Collection<?>)", "src/main/java/org/apache/commons/collections4/collection/IndexedCollection.java.IndexedCollection.[void]removeFromIndex(C)", "src/main/java/org/apache/commons/collections4/collection/IndexedCollection.java.IndexedCollection.[boolean]removeIf(Predicate<? super C>)", "src/main/java/org/apache/commons/collections4/collection/IndexedCollection.java.IndexedCollection.[boolean]retainAll(Collection<?>)", "src/main/java/org/apache/commons/collections4/collection/IndexedCollection.java.IndexedCollection.[Collection<C>]values(K)"], "overrides": null, "attributes": [], "class_docstring": "\nAn IndexedCollection is a Map-like view onto a Collection. It accepts a\nkeyTransformer to define how the keys are converted from the values.\n<p>\nModifications made to this decorator modify the index as well as the\ndecorated {@link Collection}. However, modifications to the underlying\n{@link Collection} will not update the index and it will get out of sync.\n</p>\n<p>\nIf modification of the decorated {@link Collection} is unavoidable, then a\ncall to {@link #reindex()} will update the index to the current contents of\nthe {@link Collection}.\n</p>\n\n@param <K> the type of object in the index.\n@param <C> the type of object in the collection.\n\n@since 4.0\n", "original_string": "public class IndexedCollection<K, C> extends AbstractCollectionDecorator<C> {\n\n    // TODO: replace with MultiValuedMap\n\n    /** Serialization version */\n    private static final long serialVersionUID = -5512610452568370038L;\n\n    /**\n     * Create an {@link IndexedCollection} for a non-unique index.\n     *\n     * @param <K> the index object type.\n     * @param <C> the collection type.\n     * @param coll the decorated {@link Collection}.\n     * @param keyTransformer the {@link Transformer} for generating index keys.\n     * @return the created {@link IndexedCollection}.\n     */\n    public static <K, C> IndexedCollection<K, C> nonUniqueIndexedCollection(final Collection<C> coll,\n                                                                            final Transformer<C, K> keyTransformer) {\n        return new IndexedCollection<>(coll, keyTransformer,\n                                           MultiValueMap.<K, C>multiValueMap(new HashMap<>()),\n                                           false);\n    }\n\n    /**\n     * Create an {@link IndexedCollection} for a unique index.\n     * <p>\n     * If an element is added, which maps to an existing key, an {@link IllegalArgumentException}\n     * will be thrown.\n     *\n     * @param <K> the index object type.\n     * @param <C> the collection type.\n     * @param coll the decorated {@link Collection}.\n     * @param keyTransformer the {@link Transformer} for generating index keys.\n     * @return the created {@link IndexedCollection}.\n     */\n    public static <K, C> IndexedCollection<K, C> uniqueIndexedCollection(final Collection<C> coll,\n                                                                         final Transformer<C, K> keyTransformer) {\n        return new IndexedCollection<>(coll, keyTransformer,\n                                           MultiValueMap.<K, C>multiValueMap(new HashMap<>()),\n                                           true);\n    }\n\n    /** The {@link Transformer} for generating index keys. */\n    private final Transformer<C, K> keyTransformer;\n\n    /** The map of indexes to collected objects. */\n    private final MultiMap<K, C> index;\n\n    /** The uniqueness constraint for the index. */\n    private final boolean uniqueIndex;\n\n    /**\n     * Create a {@link IndexedCollection}.\n     *\n     * @param coll  decorated {@link Collection}\n     * @param keyTransformer  {@link Transformer} for generating index keys\n     * @param map  map to use as index\n     * @param uniqueIndex  if the index shall enforce uniqueness of index keys\n     */\n    public IndexedCollection(final Collection<C> coll, final Transformer<C, K> keyTransformer,\n                             final MultiMap<K, C> map, final boolean uniqueIndex) {\n        super(coll);\n        this.keyTransformer = keyTransformer;\n        this.index = map;\n        this.uniqueIndex = uniqueIndex;\n        reindex();\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * @throws IllegalArgumentException if the object maps to an existing key and the index\n     *   enforces a uniqueness constraint\n     */\n    @Override\n    public boolean add(final C object) {\n        final boolean added = super.add(object);\n        if (added) {\n            addToIndex(object);\n        }\n        return added;\n    }\n\n    @Override\n    public boolean addAll(final Collection<? extends C> coll) {\n        boolean changed = false;\n        for (final C c: coll) {\n            changed |= add(c);\n        }\n        return changed;\n    }\n\n    /**\n     * Provides checking for adding the index.\n     *\n     * @param object the object to index\n     * @throws IllegalArgumentException if the object maps to an existing key and the index\n     *   enforces a uniqueness constraint\n     */\n    private void addToIndex(final C object) {\n        final K key = keyTransformer.apply(object);\n        if (uniqueIndex && index.containsKey(key)) {\n            throw new IllegalArgumentException(\"Duplicate key in uniquely indexed collection.\");\n        }\n        index.put(key, object);\n    }\n\n    @Override\n    public void clear() {\n        super.clear();\n        index.clear();\n    }\n\n    /**\n     * {@inheritDoc}\n     * <p>\n     * Note: uses the index for fast lookup\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public boolean contains(final Object object) {\n        return index.containsKey(keyTransformer.apply((C) object));\n    }\n\n    /**\n     * {@inheritDoc}\n     * <p>\n     * Note: uses the index for fast lookup\n     */\n    @Override\n    public boolean containsAll(final Collection<?> coll) {\n        for (final Object o : coll) {\n            if (!contains(o)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Gets the element associated with the given key.\n     * <p>\n     * In case of a non-unique index, this method will return the first\n     * value associated with the given key. To retrieve all elements associated\n     * with a key, use {@link #values(Object)}.\n     *\n     * @param key  key to look up\n     * @return element found\n     * @see #values(Object)\n     */\n    public C get(final K key) {\n        @SuppressWarnings(\"unchecked\") // index is a MultiMap which returns a Collection\n        final Collection<C> coll = (Collection<C>) index.get(key);\n        return coll == null ? null : coll.iterator().next();\n    }\n\n    /**\n     * Clears the index and re-indexes the entire decorated {@link Collection}.\n     */\n    public void reindex() {\n        index.clear();\n        for (final C c : decorated()) {\n            addToIndex(c);\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public boolean remove(final Object object) {\n        final boolean removed = super.remove(object);\n        if (removed) {\n            removeFromIndex((C) object);\n        }\n        return removed;\n    }\n\n    @Override\n    public boolean removeAll(final Collection<?> coll) {\n        boolean changed = false;\n        for (final Object o : coll) {\n            changed |= remove(o);\n        }\n        return changed;\n    }\n\n    /**\n     * Removes an object from the index.\n     *\n     * @param object the object to remove\n     */\n    private void removeFromIndex(final C object) {\n        index.remove(keyTransformer.apply(object));\n    }\n\n    /**\n     * @since 4.4\n     */\n    @Override\n    public boolean removeIf(final Predicate<? super C> filter) {\n        if (Objects.isNull(filter)) {\n            return false;\n        }\n        boolean changed = false;\n        final Iterator<C> it = iterator();\n        while (it.hasNext()) {\n            if (filter.test(it.next())) {\n                it.remove();\n                changed = true;\n            }\n        }\n        if (changed) {\n            reindex();\n        }\n        return changed;\n    }\n\n    @Override\n    public boolean retainAll(final Collection<?> coll) {\n        final boolean changed = super.retainAll(coll);\n        if (changed) {\n            reindex();\n        }\n        return changed;\n    }\n\n    /**\n     * Gets all elements associated with the given key.\n     *\n     * @param key  key to look up\n     * @return a collection of elements found, or null if {@code contains(key) == false}\n     */\n    @SuppressWarnings(\"unchecked\") // index is a MultiMap which returns a Collection\n    public Collection<C> values(final K key) {\n        return (Collection<C>) index.get(key);\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = -5512610452568370038L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -5512610452568370038L", "syntax_pass": true}, {"attribute_expression": "private final Transformer<C, K> keyTransformer;", "docstring": " The {@link Transformer} for generating index keys.", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Transformer<C, K>", "name": "keyTransformer", "syntax_pass": true}, {"attribute_expression": "private final MultiMap<K, C> index;", "docstring": " The map of indexes to collected objects.", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "MultiMap<K, C>", "name": "index", "syntax_pass": true}, {"attribute_expression": "private final boolean uniqueIndex;", "docstring": " The uniqueness constraint for the index.", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "boolean", "name": "uniqueIndex", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/map/UnmodifiableEntrySet.java.UnmodifiableEntrySet", "name": "UnmodifiableEntrySet", "file_path": "src/main/java/org/apache/commons/collections4/map/UnmodifiableEntrySet.java", "superclasses": "", "methods": ["[Set<Map.Entry<K, V>>]unmodifiableEntrySet(Set<Map.Entry<K, V>>)", "[]UnmodifiableEntrySet(Set<Map.Entry<K, V>>)", "[boolean]add(Map.Entry<K, V>)", "[boolean]addAll(Collection<? extends Map.Entry<K, V>>)", "[void]clear()", "[Iterator<Map.Entry<K, V>>]iterator()", "[boolean]remove(Object)", "[boolean]removeAll(Collection<?>)", "[boolean]removeIf(Predicate<? super Map.Entry<K, V>>)", "[boolean]retainAll(Collection<?>)", "[Object[]]toArray()", "[T[]]toArray(T[])"], "method_uris": ["src/main/java/org/apache/commons/collections4/map/UnmodifiableEntrySet.java.UnmodifiableEntrySet.[Set<Map.Entry<K, V>>]unmodifiableEntrySet(Set<Map.Entry<K, V>>)", "src/main/java/org/apache/commons/collections4/map/UnmodifiableEntrySet.java.UnmodifiableEntrySet.[]UnmodifiableEntrySet(Set<Map.Entry<K, V>>)", "src/main/java/org/apache/commons/collections4/map/UnmodifiableEntrySet.java.UnmodifiableEntrySet.[boolean]add(Map.Entry<K, V>)", "src/main/java/org/apache/commons/collections4/map/UnmodifiableEntrySet.java.UnmodifiableEntrySet.[boolean]addAll(Collection<? extends Map.Entry<K, V>>)", "src/main/java/org/apache/commons/collections4/map/UnmodifiableEntrySet.java.UnmodifiableEntrySet.[void]clear()", "src/main/java/org/apache/commons/collections4/map/UnmodifiableEntrySet.java.UnmodifiableEntrySet.[Iterator<Map.Entry<K, V>>]iterator()", "src/main/java/org/apache/commons/collections4/map/UnmodifiableEntrySet.java.UnmodifiableEntrySet.[boolean]remove(Object)", "src/main/java/org/apache/commons/collections4/map/UnmodifiableEntrySet.java.UnmodifiableEntrySet.[boolean]removeAll(Collection<?>)", "src/main/java/org/apache/commons/collections4/map/UnmodifiableEntrySet.java.UnmodifiableEntrySet.[boolean]removeIf(Predicate<? super Map.Entry<K, V>>)", "src/main/java/org/apache/commons/collections4/map/UnmodifiableEntrySet.java.UnmodifiableEntrySet.[boolean]retainAll(Collection<?>)", "src/main/java/org/apache/commons/collections4/map/UnmodifiableEntrySet.java.UnmodifiableEntrySet.[Object[]]toArray()", "src/main/java/org/apache/commons/collections4/map/UnmodifiableEntrySet.java.UnmodifiableEntrySet.[T[]]toArray(T[])"], "overrides": null, "attributes": [{"original_string": "    private final class UnmodifiableEntry extends AbstractMapEntryDecorator<K, V> {\n\n        protected UnmodifiableEntry(final Map.Entry<K, V> entry) {\n            super(entry);\n        }\n\n        @Override\n        public V setValue(final V value) {\n            throw new UnsupportedOperationException();\n        }\n    }", "definition": "    private final class UnmodifiableEntry extends AbstractMapEntryDecorator<K, V>", "class_docstring": "\nImplements a map entry that is unmodifiable.\n", "name": "UnmodifiableEntry", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        protected UnmodifiableEntry(final Map.Entry<K, V> entry) {\n            super(entry);\n        }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "name": "UnmodifiableEntry", "params": [{"name": "entry", "type": "Map.Entry<K, V>"}], "body": "                                                                 {\n            super(entry);\n        }", "signature": "protected UnmodifiableEntry(final Map.Entry<K, V> entry)"}, {"syntax_pass": true, "original_string": "        @Override\n        public V setValue(final V value) {\n            throw new UnsupportedOperationException();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "setValue", "params": [{"name": "value", "type": "V"}], "body": "                                         {\n            throw new UnsupportedOperationException();\n        }", "signature": "@Override\n        public V setValue(final V value)"}]}, {"original_string": "    private final class UnmodifiableEntrySetIterator extends AbstractIteratorDecorator<Map.Entry<K, V>> {\n\n        protected UnmodifiableEntrySetIterator(final Iterator<Map.Entry<K, V>> iterator) {\n            super(iterator);\n        }\n\n        @Override\n        public Map.Entry<K, V> next() {\n            return new UnmodifiableEntry(getIterator().next());\n        }\n\n        @Override\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n    }", "definition": "    private final class UnmodifiableEntrySetIterator extends AbstractIteratorDecorator<Map.Entry<K, V>>", "class_docstring": "\nImplements an entry set iterator.\n", "name": "UnmodifiableEntrySetIterator", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        protected UnmodifiableEntrySetIterator(final Iterator<Map.Entry<K, V>> iterator) {\n            super(iterator);\n        }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "name": "UnmodifiableEntrySetIterator", "params": [{"name": "iterator", "type": "Iterator<Map.Entry<K, V>>"}], "body": "                                                                                         {\n            super(iterator);\n        }", "signature": "protected UnmodifiableEntrySetIterator(final Iterator<Map.Entry<K, V>> iterator)"}, {"syntax_pass": true, "original_string": "        @Override\n        public Map.Entry<K, V> next() {\n            return new UnmodifiableEntry(getIterator().next());\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map.Entry<K, V>", "classes": []}, "name": "next", "params": [], "body": "                                      {\n            return new UnmodifiableEntry(getIterator().next());\n        }", "signature": "@Override\n        public Map.Entry<K, V> next()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "remove", "params": [], "body": "                             {\n            throw new UnsupportedOperationException();\n        }", "signature": "@Override\n        public void remove()"}]}], "class_docstring": "\nDecorates a map entry {@code Set} to ensure it can't be altered.\n<p>\nAttempts to modify it will result in an UnsupportedOperationException.\n</p>\n\n@param <K> the type of the keys in the map\n@param <V> the type of the values in the map\n\n@since 3.0\n", "original_string": "public final class UnmodifiableEntrySet<K, V>\n        extends AbstractSetDecorator<Map.Entry<K, V>> implements Unmodifiable {\n\n    /**\n     * Implements a map entry that is unmodifiable.\n     */\n    private final class UnmodifiableEntry extends AbstractMapEntryDecorator<K, V> {\n\n        protected UnmodifiableEntry(final Map.Entry<K, V> entry) {\n            super(entry);\n        }\n\n        @Override\n        public V setValue(final V value) {\n            throw new UnsupportedOperationException();\n        }\n    }\n\n    /**\n     * Implements an entry set iterator.\n     */\n    private final class UnmodifiableEntrySetIterator extends AbstractIteratorDecorator<Map.Entry<K, V>> {\n\n        protected UnmodifiableEntrySetIterator(final Iterator<Map.Entry<K, V>> iterator) {\n            super(iterator);\n        }\n\n        @Override\n        public Map.Entry<K, V> next() {\n            return new UnmodifiableEntry(getIterator().next());\n        }\n\n        @Override\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n    }\n\n    /** Serialization version */\n    private static final long serialVersionUID = 1678353579659253473L;\n\n    /**\n     * Factory method to create an unmodifiable set of Map Entry objects.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param set  the set to decorate, must not be null\n     * @return a new unmodifiable entry set\n     * @throws NullPointerException if set is null\n     * @since 4.0\n     */\n    public static <K, V> Set<Map.Entry<K, V>> unmodifiableEntrySet(final Set<Map.Entry<K, V>> set) {\n        if (set instanceof Unmodifiable) {\n            return set;\n        }\n        return new UnmodifiableEntrySet<>(set);\n    }\n\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param set  the set to decorate, must not be null\n     * @throws NullPointerException if set is null\n     */\n    private UnmodifiableEntrySet(final Set<Map.Entry<K, V>> set) {\n        super(set);\n    }\n\n    @Override\n    public boolean add(final Map.Entry<K, V> object) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public boolean addAll(final Collection<? extends Map.Entry<K, V>> coll) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public void clear() {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public Iterator<Map.Entry<K, V>> iterator() {\n        return new UnmodifiableEntrySetIterator(decorated().iterator());\n    }\n\n    @Override\n    public boolean remove(final Object object) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public boolean removeAll(final Collection<?> coll) {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * @since 4.4\n     */\n    @Override\n    public boolean removeIf(final Predicate<? super Map.Entry<K, V>> filter) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public boolean retainAll(final Collection<?> coll) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public Object[] toArray() {\n        final Object[] array = decorated().toArray();\n        for (int i = 0; i < array.length; i++) {\n            array[i] = new UnmodifiableEntry((Map.Entry<K, V>) array[i]);\n        }\n        return array;\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public <T> T[] toArray(final T[] array) {\n        Object[] result = array;\n        if (array.length > 0) {\n            // we must create a new array to handle multithreaded situations\n            // where another thread could access data before we decorate it\n            result = (Object[]) Array.newInstance(array.getClass().getComponentType(), 0);\n        }\n        result = decorated().toArray(result);\n        for (int i = 0; i < result.length; i++) {\n            result[i] = new UnmodifiableEntry((Map.Entry<K, V>) result[i]);\n        }\n\n        // check to see if result should be returned straight\n        if (result.length > array.length) {\n            return (T[]) result;\n        }\n\n        // copy back into input array to fulfill the method contract\n        System.arraycopy(result, 0, array, 0, result.length);\n        if (array.length > result.length) {\n            array[result.length] = null;\n        }\n        return array;\n    }\n\n}", "super_interfaces": ["Unmodifiable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 1678353579659253473L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 1678353579659253473L", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/map/CaseInsensitiveMap.java.CaseInsensitiveMap", "name": "CaseInsensitiveMap", "file_path": "src/main/java/org/apache/commons/collections4/map/CaseInsensitiveMap.java", "superclasses": "", "methods": ["[]CaseInsensitiveMap()", "[]CaseInsensitiveMap(int)", "[]CaseInsensitiveMap(int,float)", "[]CaseInsensitiveMap(Map<? extends K, ? extends V>)", "[CaseInsensitiveMap<K, V>]clone()", "[Object]convertKey(Object)", "[void]readObject(ObjectInputStream)", "[void]writeObject(ObjectOutputStream)"], "method_uris": ["src/main/java/org/apache/commons/collections4/map/CaseInsensitiveMap.java.CaseInsensitiveMap.[]CaseInsensitiveMap()", "src/main/java/org/apache/commons/collections4/map/CaseInsensitiveMap.java.CaseInsensitiveMap.[]CaseInsensitiveMap(int)", "src/main/java/org/apache/commons/collections4/map/CaseInsensitiveMap.java.CaseInsensitiveMap.[]CaseInsensitiveMap(int,float)", "src/main/java/org/apache/commons/collections4/map/CaseInsensitiveMap.java.CaseInsensitiveMap.[]CaseInsensitiveMap(Map<? extends K, ? extends V>)", "src/main/java/org/apache/commons/collections4/map/CaseInsensitiveMap.java.CaseInsensitiveMap.[CaseInsensitiveMap<K, V>]clone()", "src/main/java/org/apache/commons/collections4/map/CaseInsensitiveMap.java.CaseInsensitiveMap.[Object]convertKey(Object)", "src/main/java/org/apache/commons/collections4/map/CaseInsensitiveMap.java.CaseInsensitiveMap.[void]readObject(ObjectInputStream)", "src/main/java/org/apache/commons/collections4/map/CaseInsensitiveMap.java.CaseInsensitiveMap.[void]writeObject(ObjectOutputStream)"], "overrides": null, "attributes": [], "class_docstring": "\nA case-insensitive {@code Map}.\n<p>\nBefore keys are added to the map or compared to other existing keys, they are converted\nto all lowercase in a locale-independent fashion by using information from the Unicode\ndata file.\n</p>\n<p>\nNull keys are supported.\n</p>\n<p>\nThe {@code keySet()} method returns all lowercase keys, or nulls.\n</p>\n<p>\nExample:\n</p>\n<pre><code>\n Map&lt;String, String&gt; map = new CaseInsensitiveMap&lt;String, String&gt;();\n map.put(\"One\", \"One\");\n map.put(\"Two\", \"Two\");\n map.put(null, \"Three\");\n map.put(\"one\", \"Four\");\n</code></pre>\n<p>\nThe example above creates a {@code CaseInsensitiveMap} with three entries.\n</p>\n<p>\n{@code map.get(null)} returns {@code \"Three\"} and {@code map.get(\"ONE\")}\nreturns {@code \"Four\".}  The {@code Set} returned by {@code keySet()}\nequals {@code {\"one\", \"two\", null}.}\n</p>\n<p>\n<strong>This map will violate the detail of various Map and map view contracts.</strong>\nAs a general rule, don't compare this map to other maps. In particular, you can't\nuse decorators like {@link ListOrderedMap} on it, which silently assume that these\ncontracts are fulfilled.\n</p>\n<p>\n<strong>Note that CaseInsensitiveMap is not synchronized and is not thread-safe.</strong>\nIf you wish to use this map from multiple threads concurrently, you must use\nappropriate synchronization. The simplest approach is to wrap this map\nusing {@link java.util.Collections#synchronizedMap(Map)}. This class may throw\nexceptions when accessed by concurrent threads without synchronization.\n</p>\n\n@param <K> the type of the keys in this map\n@param <V> the type of the values in this map\n@since 3.0\n", "original_string": "public class CaseInsensitiveMap<K, V> extends AbstractHashedMap<K, V> implements Serializable, Cloneable {\n\n    /** Serialisation version */\n    private static final long serialVersionUID = -7074655917369299456L;\n\n    /**\n     * Constructs a new empty map with default size and load factor.\n     */\n    public CaseInsensitiveMap() {\n        super(DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_THRESHOLD);\n    }\n\n    /**\n     * Constructs a new, empty map with the specified initial capacity.\n     *\n     * @param initialCapacity  the initial capacity\n     * @throws IllegalArgumentException if the initial capacity is negative\n     */\n    public CaseInsensitiveMap(final int initialCapacity) {\n        super(initialCapacity);\n    }\n\n    /**\n     * Constructs a new, empty map with the specified initial capacity and\n     * load factor.\n     *\n     * @param initialCapacity  the initial capacity\n     * @param loadFactor  the load factor\n     * @throws IllegalArgumentException if the initial capacity is negative\n     * @throws IllegalArgumentException if the load factor is less than zero\n     */\n    public CaseInsensitiveMap(final int initialCapacity, final float loadFactor) {\n        super(initialCapacity, loadFactor);\n    }\n\n    /**\n     * Constructor copying elements from another map.\n     * <p>\n     * Keys will be converted to lower case strings, which may cause\n     * some entries to be removed (if string representation of keys differ\n     * only by character case).\n     *\n     * @param map  the map to copy\n     * @throws NullPointerException if the map is null\n     */\n    public CaseInsensitiveMap(final Map<? extends K, ? extends V> map) {\n        super(map);\n    }\n\n    /**\n     * Clones the map without cloning the keys or values.\n     *\n     * @return a shallow clone\n     */\n    @Override\n    public CaseInsensitiveMap<K, V> clone() {\n        return (CaseInsensitiveMap<K, V>) super.clone();\n    }\n\n    /**\n     * Overrides convertKey() from {@link AbstractHashedMap} to convert keys to\n     * lower case.\n     * <p>\n     * Returns {@link AbstractHashedMap#NULL} if key is null.\n     *\n     * @param key  the key convert\n     * @return the converted key\n     */\n    @Override\n    protected Object convertKey(final Object key) {\n        if (key != null) {\n            final char[] chars = key.toString().toCharArray();\n            for (int i = chars.length - 1; i >= 0; i--) {\n                chars[i] = Character.toLowerCase(Character.toUpperCase(chars[i]));\n            }\n            return new String(chars);\n        }\n        return NULL;\n    }\n\n    /**\n     * Deserializes the map in using a custom routine.\n     *\n     * @param in the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded\n     */\n    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        doReadObject(in);\n    }\n\n    /**\n     * Serializes this object to an ObjectOutputStream.\n     *\n     * @param out the target ObjectOutputStream.\n     * @throws IOException thrown when an I/O errors occur writing to the target stream.\n     */\n    private void writeObject(final ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        doWriteObject(out);\n    }\n\n}", "super_interfaces": ["Serializable", "Cloneable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = -7074655917369299456L;", "docstring": " Serialisation version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -7074655917369299456L", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/map/LazyMap.java.LazyMap", "name": "LazyMap", "file_path": "src/main/java/org/apache/commons/collections4/map/LazyMap.java", "superclasses": "", "methods": ["[LazyMap<K, V>]lazyMap(Map<K, V>,Factory<? extends V>)", "[LazyMap<K, V>]lazyMap(Map<K, V>,Transformer<? super K, ? extends V>)", "[]LazyMap(Map<K, V>,Factory<? extends V>)", "[]LazyMap(Map<K, V>,Transformer<? super K, ? extends V>)", "[V]get(Object)", "[void]readObject(ObjectInputStream)", "[void]writeObject(ObjectOutputStream)"], "method_uris": ["src/main/java/org/apache/commons/collections4/map/LazyMap.java.LazyMap.[LazyMap<K, V>]lazyMap(Map<K, V>,Factory<? extends V>)", "src/main/java/org/apache/commons/collections4/map/LazyMap.java.LazyMap.[LazyMap<K, V>]lazyMap(Map<K, V>,Transformer<? super K, ? extends V>)", "src/main/java/org/apache/commons/collections4/map/LazyMap.java.LazyMap.[]LazyMap(Map<K, V>,Factory<? extends V>)", "src/main/java/org/apache/commons/collections4/map/LazyMap.java.LazyMap.[]LazyMap(Map<K, V>,Transformer<? super K, ? extends V>)", "src/main/java/org/apache/commons/collections4/map/LazyMap.java.LazyMap.[V]get(Object)", "src/main/java/org/apache/commons/collections4/map/LazyMap.java.LazyMap.[void]readObject(ObjectInputStream)", "src/main/java/org/apache/commons/collections4/map/LazyMap.java.LazyMap.[void]writeObject(ObjectOutputStream)"], "overrides": null, "attributes": [], "class_docstring": "\nDecorates another {@code Map} to create objects in the map on demand.\n<p>\nWhen the {@link #get(Object)} method is called with a key that does not\nexist in the map, the factory is used to create the object. The created\nobject will be added to the map using the requested key.\n</p>\n<p>\nFor instance:\n</p>\n<pre>\nFactory&lt;Date&gt; factory = new Factory&lt;Date&gt;() {\n    public Date create() {\n        return new Date();\n    }\n}\nMap&lt;String, Date&gt; lazy = LazyMap.lazyMap(new HashMap&lt;String, Date&gt;(), factory);\nDate date = lazy.get(\"NOW\");\n</pre>\n\n<p>\nAfter the above code is executed, {@code date} will refer to\na new {@code Date} instance. Furthermore, that {@code Date}\ninstance is mapped to the \"NOW\" key in the map.\n</p>\n<p>\n<strong>Note that LazyMap is not synchronized and is not thread-safe.</strong>\nIf you wish to use this map from multiple threads concurrently, you must use\nappropriate synchronization. The simplest approach is to wrap this map\nusing {@link java.util.Collections#synchronizedMap(Map)}. This class may throw\nexceptions when accessed by concurrent threads without synchronization.\n</p>\n<p>\nThis class is Serializable from Commons Collections 3.1.\n</p>\n\n@param <K> the type of the keys in this map\n@param <V> the type of the values in this map\n@since 3.0\n", "original_string": "public class LazyMap<K, V> extends AbstractMapDecorator<K, V> implements Serializable {\n\n    /** Serialization version */\n    private static final long serialVersionUID = 7990956402564206740L;\n\n    /**\n     * Factory method to create a lazily instantiated map.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param map  the map to decorate, must not be null\n     * @param factory  the factory to use, must not be null\n     * @return a new lazy map\n     * @throws NullPointerException if map or factory is null\n     * @since 4.0\n     */\n    public static <K, V> LazyMap<K, V> lazyMap(final Map<K, V> map, final Factory<? extends V> factory) {\n        return new LazyMap<>(map, factory);\n    }\n\n    /**\n     * Factory method to create a lazily instantiated map.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param map  the map to decorate, must not be null\n     * @param factory  the factory to use, must not be null\n     * @return a new lazy map\n     * @throws NullPointerException if map or factory is null\n     * @since 4.0\n     */\n    public static <V, K> LazyMap<K, V> lazyMap(final Map<K, V> map, final Transformer<? super K, ? extends V> factory) {\n        return new LazyMap<>(map, factory);\n    }\n\n    /** The factory to use to construct elements */\n    protected final Transformer<? super K, ? extends V> factory;\n\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param map  the map to decorate, must not be null\n     * @param factory  the factory to use, must not be null\n     * @throws NullPointerException if map or factory is null\n     */\n    protected LazyMap(final Map<K, V> map, final Factory<? extends V> factory) {\n        super(map);\n        this.factory = FactoryTransformer.factoryTransformer(Objects.requireNonNull(factory, \"factory\"));\n    }\n\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param map  the map to decorate, must not be null\n     * @param factory  the factory to use, must not be null\n     * @throws NullPointerException if map or factory is null\n     */\n    protected LazyMap(final Map<K, V> map, final Transformer<? super K, ? extends V> factory) {\n        super(map);\n        this.factory = Objects.requireNonNull(factory, \"factory\");\n    }\n\n    @Override\n    public V get(final Object key) {\n        // create value for key if key is not currently in the map\n        if (!map.containsKey(key)) {\n            @SuppressWarnings(\"unchecked\")\n            final K castKey = (K) key;\n            final V value = factory.apply(castKey);\n            map.put(castKey, value);\n            return value;\n        }\n        return map.get(key);\n    }\n\n    /**\n     * Deserializes the map in using a custom routine.\n     *\n     * @param in  the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded\n     * @since 3.1\n     */\n    @SuppressWarnings(\"unchecked\")\n    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        map = (Map<K, V>) in.readObject();\n    }\n\n    /**\n     * Serializes this object to an ObjectOutputStream.\n     *\n     * @param out the target ObjectOutputStream.\n     * @throws IOException thrown when an I/O errors occur writing to the target stream.\n     * @since 3.1\n     */\n    private void writeObject(final ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        out.writeObject(map);\n    }\n\n    // no need to wrap keySet, entrySet or values as they are views of\n    // existing map entries - you can't do a map-style get on them.\n}", "super_interfaces": ["Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 7990956402564206740L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 7990956402564206740L", "syntax_pass": true}, {"attribute_expression": "protected final Transformer<? super K, ? extends V> factory;", "docstring": " The factory to use to construct elements", "modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "type": "Transformer<? super K, ? extends V>", "name": "factory", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/map/LazySortedMap.java.LazySortedMap", "name": "LazySortedMap", "file_path": "src/main/java/org/apache/commons/collections4/map/LazySortedMap.java", "superclasses": "", "methods": ["[LazySortedMap<K, V>]lazySortedMap(SortedMap<K, V>,Factory<? extends V>)", "[LazySortedMap<K, V>]lazySortedMap(SortedMap<K, V>,Transformer<? super K, ? extends V>)", "[]LazySortedMap(SortedMap<K, V>,Factory<? extends V>)", "[]LazySortedMap(SortedMap<K, V>,Transformer<? super K, ? extends V>)", "[Comparator<? super K>]comparator()", "[K]firstKey()", "[SortedMap<K, V>]getSortedMap()", "[SortedMap<K, V>]headMap(K)", "[K]lastKey()", "[SortedMap<K, V>]subMap(K,K)", "[SortedMap<K, V>]tailMap(K)"], "method_uris": ["src/main/java/org/apache/commons/collections4/map/LazySortedMap.java.LazySortedMap.[LazySortedMap<K, V>]lazySortedMap(SortedMap<K, V>,Factory<? extends V>)", "src/main/java/org/apache/commons/collections4/map/LazySortedMap.java.LazySortedMap.[LazySortedMap<K, V>]lazySortedMap(SortedMap<K, V>,Transformer<? super K, ? extends V>)", "src/main/java/org/apache/commons/collections4/map/LazySortedMap.java.LazySortedMap.[]LazySortedMap(SortedMap<K, V>,Factory<? extends V>)", "src/main/java/org/apache/commons/collections4/map/LazySortedMap.java.LazySortedMap.[]LazySortedMap(SortedMap<K, V>,Transformer<? super K, ? extends V>)", "src/main/java/org/apache/commons/collections4/map/LazySortedMap.java.LazySortedMap.[Comparator<? super K>]comparator()", "src/main/java/org/apache/commons/collections4/map/LazySortedMap.java.LazySortedMap.[K]firstKey()", "src/main/java/org/apache/commons/collections4/map/LazySortedMap.java.LazySortedMap.[SortedMap<K, V>]getSortedMap()", "src/main/java/org/apache/commons/collections4/map/LazySortedMap.java.LazySortedMap.[SortedMap<K, V>]headMap(K)", "src/main/java/org/apache/commons/collections4/map/LazySortedMap.java.LazySortedMap.[K]lastKey()", "src/main/java/org/apache/commons/collections4/map/LazySortedMap.java.LazySortedMap.[SortedMap<K, V>]subMap(K,K)", "src/main/java/org/apache/commons/collections4/map/LazySortedMap.java.LazySortedMap.[SortedMap<K, V>]tailMap(K)"], "overrides": null, "attributes": [], "class_docstring": "\nDecorates another {@code SortedMap} to create objects in the map on demand.\n<p>\nWhen the {@link #get(Object)} method is called with a key that does not\nexist in the map, the factory is used to create the object. The created\nobject will be added to the map using the requested key.\n</p>\n<p>\nFor instance:\n</p>\n<pre>\nFactory&lt;Date&gt; factory = new Factory&lt;Date&gt;() {\n    public Date create() {\n        return new Date();\n    }\n}\nSortedMap&lt;String, Date&gt; lazy =\n    LazySortedMap.lazySortedMap(new HashMap&lt;String, Date&gt;(), factory);\nDate date = lazy.get(\"NOW\");\n</pre>\n\n<p>\nAfter the above code is executed, {@code date} will refer to\na new {@code Date} instance. Furthermore, that {@code Date}\ninstance is mapped to the \"NOW\" key in the map.\n</p>\n<p>\n<strong>Note that LazySortedMap is not synchronized and is not thread-safe.</strong>\nIf you wish to use this map from multiple threads concurrently, you must use\nappropriate synchronization. The simplest approach is to wrap this map\nusing {@link java.util.Collections#synchronizedSortedMap}. This class may throw\nexceptions when accessed by concurrent threads without synchronization.\n</p>\n<p>\nThis class is Serializable from Commons Collections 3.1.\n</p>\n\n@param <K> the type of the keys in this map\n@param <V> the type of the values in this map\n@since 3.0\n", "original_string": "public class LazySortedMap<K, V> extends LazyMap<K, V> implements SortedMap<K, V> {\n\n    /** Serialization version */\n    private static final long serialVersionUID = 2715322183617658933L;\n\n    /**\n     * Factory method to create a lazily instantiated sorted map.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param map  the map to decorate, must not be null\n     * @param factory  the factory to use, must not be null\n     * @return a new lazy sorted map\n     * @throws NullPointerException if map or factory is null\n     * @since 4.0\n     */\n    public static <K, V> LazySortedMap<K, V> lazySortedMap(final SortedMap<K, V> map,\n                                                           final Factory<? extends V> factory) {\n        return new LazySortedMap<>(map, factory);\n    }\n\n    /**\n     * Factory method to create a lazily instantiated sorted map.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param map  the map to decorate, must not be null\n     * @param factory  the factory to use, must not be null\n     * @return a new lazy sorted map\n     * @throws NullPointerException if map or factory is null\n     * @since 4.0\n     */\n    public static <K, V> LazySortedMap<K, V> lazySortedMap(final SortedMap<K, V> map,\n                                                           final Transformer<? super K, ? extends V> factory) {\n        return new LazySortedMap<>(map, factory);\n    }\n\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param map  the map to decorate, must not be null\n     * @param factory  the factory to use, must not be null\n     * @throws NullPointerException if map or factory is null\n     */\n    protected LazySortedMap(final SortedMap<K, V> map, final Factory<? extends V> factory) {\n        super(map, factory);\n    }\n\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param map  the map to decorate, must not be null\n     * @param factory  the factory to use, must not be null\n     * @throws NullPointerException if map or factory is null\n     */\n    protected LazySortedMap(final SortedMap<K, V> map, final Transformer<? super K, ? extends V> factory) {\n        super(map, factory);\n    }\n\n    @Override\n    public Comparator<? super K> comparator() {\n        return getSortedMap().comparator();\n    }\n\n    @Override\n    public K firstKey() {\n        return getSortedMap().firstKey();\n    }\n\n    /**\n     * Gets the map being decorated.\n     *\n     * @return the decorated map\n     */\n    protected SortedMap<K, V> getSortedMap() {\n        return (SortedMap<K, V>) map;\n    }\n\n    @Override\n    public SortedMap<K, V> headMap(final K toKey) {\n        final SortedMap<K, V> map = getSortedMap().headMap(toKey);\n        return new LazySortedMap<>(map, factory);\n    }\n\n    @Override\n    public K lastKey() {\n        return getSortedMap().lastKey();\n    }\n\n    @Override\n    public SortedMap<K, V> subMap(final K fromKey, final K toKey) {\n        final SortedMap<K, V> map = getSortedMap().subMap(fromKey, toKey);\n        return new LazySortedMap<>(map, factory);\n    }\n\n    @Override\n    public SortedMap<K, V> tailMap(final K fromKey) {\n        final SortedMap<K, V> map = getSortedMap().tailMap(fromKey);\n        return new LazySortedMap<>(map, factory);\n    }\n\n}", "super_interfaces": ["SortedMap<K, V>"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 2715322183617658933L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 2715322183617658933L", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/map/TransformedMap.java.TransformedMap", "name": "TransformedMap", "file_path": "src/main/java/org/apache/commons/collections4/map/TransformedMap.java", "superclasses": "", "methods": ["[TransformedMap<K, V>]transformedMap(Map<K, V>,Transformer<? super K, ? extends K>,Transformer<? super V, ? extends V>)", "[TransformedMap<K, V>]transformingMap(Map<K, V>,Transformer<? super K, ? extends K>,Transformer<? super V, ? extends V>)", "[]TransformedMap(Map<K, V>,Transformer<? super K, ? extends K>,Transformer<? super V, ? extends V>)", "[V]checkSetValue(V)", "[boolean]isSetValueChecking()", "[V]put(K,V)", "[void]putAll(Map<? extends K, ? extends V>)", "[void]readObject(ObjectInputStream)", "[K]transformKey(K)", "[Map<K, V>]transformMap(Map<? extends K, ? extends V>)", "[V]transformValue(V)", "[void]writeObject(ObjectOutputStream)"], "method_uris": ["src/main/java/org/apache/commons/collections4/map/TransformedMap.java.TransformedMap.[TransformedMap<K, V>]transformedMap(Map<K, V>,Transformer<? super K, ? extends K>,Transformer<? super V, ? extends V>)", "src/main/java/org/apache/commons/collections4/map/TransformedMap.java.TransformedMap.[TransformedMap<K, V>]transformingMap(Map<K, V>,Transformer<? super K, ? extends K>,Transformer<? super V, ? extends V>)", "src/main/java/org/apache/commons/collections4/map/TransformedMap.java.TransformedMap.[]TransformedMap(Map<K, V>,Transformer<? super K, ? extends K>,Transformer<? super V, ? extends V>)", "src/main/java/org/apache/commons/collections4/map/TransformedMap.java.TransformedMap.[V]checkSetValue(V)", "src/main/java/org/apache/commons/collections4/map/TransformedMap.java.TransformedMap.[boolean]isSetValueChecking()", "src/main/java/org/apache/commons/collections4/map/TransformedMap.java.TransformedMap.[V]put(K,V)", "src/main/java/org/apache/commons/collections4/map/TransformedMap.java.TransformedMap.[void]putAll(Map<? extends K, ? extends V>)", "src/main/java/org/apache/commons/collections4/map/TransformedMap.java.TransformedMap.[void]readObject(ObjectInputStream)", "src/main/java/org/apache/commons/collections4/map/TransformedMap.java.TransformedMap.[K]transformKey(K)", "src/main/java/org/apache/commons/collections4/map/TransformedMap.java.TransformedMap.[Map<K, V>]transformMap(Map<? extends K, ? extends V>)", "src/main/java/org/apache/commons/collections4/map/TransformedMap.java.TransformedMap.[V]transformValue(V)", "src/main/java/org/apache/commons/collections4/map/TransformedMap.java.TransformedMap.[void]writeObject(ObjectOutputStream)"], "overrides": null, "attributes": [], "class_docstring": "\nDecorates another {@code Map} to transform objects that are added.\n<p>\nThe Map put methods and Map.Entry setValue method are affected by this class.\nThus objects must be removed or searched for using their transformed form.\nFor example, if the transformation converts Strings to Integers, you must\nuse the Integer form to remove objects.\n</p>\n<p>\n<strong>Note that TransformedMap is not synchronized and is not thread-safe.</strong>\nIf you wish to use this map from multiple threads concurrently, you must use\nappropriate synchronization. The simplest approach is to wrap this map\nusing {@link java.util.Collections#synchronizedMap(Map)}. This class may throw\nexceptions when accessed by concurrent threads without synchronization.\n</p>\n<p>\nThis class is Serializable from Commons Collections 3.1.\n</p>\n\n@param <K> the type of the keys in this map\n@param <V> the type of the values in this map\n\n@see org.apache.commons.collections4.splitmap.TransformedSplitMap\n@since 3.0\n", "original_string": "public class TransformedMap<K, V>\n        extends AbstractInputCheckedMapDecorator<K, V>\n        implements Serializable {\n\n    /** Serialization version */\n    private static final long serialVersionUID = 7023152376788900464L;\n\n    /**\n     * Factory method to create a transforming map that will transform\n     * existing contents of the specified map.\n     * <p>\n     * If there are any elements already in the map being decorated, they\n     * will be transformed by this method.\n     * Contrast this with {@link #transformingMap(Map, Transformer, Transformer)}.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param map  the map to decorate, must not be null\n     * @param keyTransformer  the transformer to use for key conversion, null means no transformation\n     * @param valueTransformer  the transformer to use for value conversion, null means no transformation\n     * @return a new transformed map\n     * @throws NullPointerException if map is null\n     * @since 4.0\n     */\n    public static <K, V> TransformedMap<K, V> transformedMap(final Map<K, V> map,\n            final Transformer<? super K, ? extends K> keyTransformer,\n            final Transformer<? super V, ? extends V> valueTransformer) {\n        final TransformedMap<K, V> decorated = new TransformedMap<>(map, keyTransformer, valueTransformer);\n        if (!map.isEmpty()) {\n            final Map<K, V> transformed = decorated.transformMap(map);\n            decorated.clear();\n            decorated.decorated().putAll(transformed);  // avoids double transformation\n        }\n        return decorated;\n    }\n    /**\n     * Factory method to create a transforming map.\n     * <p>\n     * If there are any elements already in the map being decorated, they\n     * are NOT transformed.\n     * Contrast this with {@link #transformedMap(Map, Transformer, Transformer)}.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param map  the map to decorate, must not be null\n     * @param keyTransformer  the transformer to use for key conversion, null means no transformation\n     * @param valueTransformer  the transformer to use for value conversion, null means no transformation\n     * @return a new transformed map\n     * @throws NullPointerException if map is null\n     * @since 4.0\n     */\n    public static <K, V> TransformedMap<K, V> transformingMap(final Map<K, V> map,\n            final Transformer<? super K, ? extends K> keyTransformer,\n            final Transformer<? super V, ? extends V> valueTransformer) {\n        return new TransformedMap<>(map, keyTransformer, valueTransformer);\n    }\n\n    /** The transformer to use for the key */\n    protected final Transformer<? super K, ? extends K> keyTransformer;\n\n    /** The transformer to use for the value */\n    protected final Transformer<? super V, ? extends V> valueTransformer;\n\n    /**\n     * Constructor that wraps (not copies).\n     * <p>\n     * If there are any elements already in the collection being decorated, they\n     * are NOT transformed.\n     *\n     * @param map  the map to decorate, must not be null\n     * @param keyTransformer  the transformer to use for key conversion, null means no conversion\n     * @param valueTransformer  the transformer to use for value conversion, null means no conversion\n     * @throws NullPointerException if map is null\n     */\n    protected TransformedMap(final Map<K, V> map, final Transformer<? super K, ? extends K> keyTransformer,\n            final Transformer<? super V, ? extends V> valueTransformer) {\n        super(map);\n        this.keyTransformer = keyTransformer;\n        this.valueTransformer = valueTransformer;\n    }\n\n    /**\n     * Override to transform the value when using {@code setValue}.\n     *\n     * @param value  the value to transform\n     * @return the transformed value\n     * @since 3.1\n     */\n    @Override\n    protected V checkSetValue(final V value) {\n        return valueTransformer.apply(value);\n    }\n\n    /**\n     * Override to only return true when there is a value transformer.\n     *\n     * @return true if a value transformer is in use\n     * @since 3.1\n     */\n    @Override\n    protected boolean isSetValueChecking() {\n        return valueTransformer != null;\n    }\n\n    @Override\n    public V put(K key, V value) {\n        key = transformKey(key);\n        value = transformValue(value);\n        return decorated().put(key, value);\n    }\n\n    @Override\n    public void putAll(Map<? extends K, ? extends V> mapToCopy) {\n        mapToCopy = transformMap(mapToCopy);\n        decorated().putAll(mapToCopy);\n    }\n\n    /**\n     * Deserializes the map in using a custom routine.\n     *\n     * @param in  the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded\n     * @since 3.1\n     */\n    @SuppressWarnings(\"unchecked\") // (1) should only fail if input stream is incorrect\n    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        map = (Map<K, V>) in.readObject(); // (1)\n    }\n\n    /**\n     * Transforms a key.\n     * <p>\n     * The transformer itself may throw an exception if necessary.\n     *\n     * @param object  the object to transform\n     * @return the transformed object\n     */\n    protected K transformKey(final K object) {\n        if (keyTransformer == null) {\n            return object;\n        }\n        return keyTransformer.apply(object);\n    }\n\n    /**\n     * Transforms a map.\n     * <p>\n     * The transformer itself may throw an exception if necessary.\n     *\n     * @param map  the map to transform\n     * @return the transformed object\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map) {\n        if (map.isEmpty()) {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }\n\n    /**\n     * Transforms a value.\n     * <p>\n     * The transformer itself may throw an exception if necessary.\n     *\n     * @param object  the object to transform\n     * @return the transformed object\n     */\n    protected V transformValue(final V object) {\n        if (valueTransformer == null) {\n            return object;\n        }\n        return valueTransformer.apply(object);\n    }\n\n    /**\n     * Serializes this object to an ObjectOutputStream.\n     *\n     * @param out the target ObjectOutputStream.\n     * @throws IOException thrown when an I/O errors occur writing to the target stream.\n     * @since 3.1\n     */\n    private void writeObject(final ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        out.writeObject(map);\n    }\n\n}", "super_interfaces": ["Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 7023152376788900464L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 7023152376788900464L", "syntax_pass": true}, {"attribute_expression": "protected final Transformer<? super K, ? extends K> keyTransformer;", "docstring": " The transformer to use for the key", "modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "type": "Transformer<? super K, ? extends K>", "name": "keyTransformer", "syntax_pass": true}, {"attribute_expression": "protected final Transformer<? super V, ? extends V> valueTransformer;", "docstring": " The transformer to use for the value", "modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "type": "Transformer<? super V, ? extends V>", "name": "valueTransformer", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/map/LinkedMap.java.LinkedMap", "name": "LinkedMap", "file_path": "src/main/java/org/apache/commons/collections4/map/LinkedMap.java", "superclasses": "", "methods": ["[]LinkedMap()", "[]LinkedMap(int)", "[]LinkedMap(int,float)", "[]LinkedMap(Map<? extends K, ? extends V>)", "[List<K>]asList()", "[LinkedMap<K, V>]clone()", "[K]get(int)", "[V]getValue(int)", "[int]indexOf(Object)", "[void]readObject(ObjectInputStream)", "[V]remove(int)", "[void]writeObject(ObjectOutputStream)"], "method_uris": ["src/main/java/org/apache/commons/collections4/map/LinkedMap.java.LinkedMap.[]LinkedMap()", "src/main/java/org/apache/commons/collections4/map/LinkedMap.java.LinkedMap.[]LinkedMap(int)", "src/main/java/org/apache/commons/collections4/map/LinkedMap.java.LinkedMap.[]LinkedMap(int,float)", "src/main/java/org/apache/commons/collections4/map/LinkedMap.java.LinkedMap.[]LinkedMap(Map<? extends K, ? extends V>)", "src/main/java/org/apache/commons/collections4/map/LinkedMap.java.LinkedMap.[List<K>]asList()", "src/main/java/org/apache/commons/collections4/map/LinkedMap.java.LinkedMap.[LinkedMap<K, V>]clone()", "src/main/java/org/apache/commons/collections4/map/LinkedMap.java.LinkedMap.[K]get(int)", "src/main/java/org/apache/commons/collections4/map/LinkedMap.java.LinkedMap.[V]getValue(int)", "src/main/java/org/apache/commons/collections4/map/LinkedMap.java.LinkedMap.[int]indexOf(Object)", "src/main/java/org/apache/commons/collections4/map/LinkedMap.java.LinkedMap.[void]readObject(ObjectInputStream)", "src/main/java/org/apache/commons/collections4/map/LinkedMap.java.LinkedMap.[V]remove(int)", "src/main/java/org/apache/commons/collections4/map/LinkedMap.java.LinkedMap.[void]writeObject(ObjectOutputStream)"], "overrides": null, "attributes": [{"original_string": "    static class LinkedMapList<K> extends AbstractList<K> {\n\n        private final LinkedMap<K, ?> parent;\n\n        LinkedMapList(final LinkedMap<K, ?> parent) {\n            this.parent = parent;\n        }\n\n        @Override\n        public void clear() {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public boolean contains(final Object obj) {\n            return parent.containsKey(obj);\n        }\n\n        @Override\n        public boolean containsAll(final Collection<?> coll) {\n            return parent.keySet().containsAll(coll);\n        }\n\n        @Override\n        public K get(final int index) {\n            return parent.get(index);\n        }\n\n        @Override\n        public int indexOf(final Object obj) {\n            return parent.indexOf(obj);\n        }\n\n        @Override\n        public Iterator<K> iterator() {\n            return UnmodifiableIterator.unmodifiableIterator(parent.keySet().iterator());\n        }\n\n        @Override\n        public int lastIndexOf(final Object obj) {\n            return parent.indexOf(obj);\n        }\n\n        @Override\n        public ListIterator<K> listIterator() {\n            return UnmodifiableListIterator.unmodifiableListIterator(super.listIterator());\n        }\n\n        @Override\n        public ListIterator<K> listIterator(final int fromIndex) {\n            return UnmodifiableListIterator.unmodifiableListIterator(super.listIterator(fromIndex));\n        }\n\n        @Override\n        public K remove(final int index) {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public boolean remove(final Object obj) {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public boolean removeAll(final Collection<?> coll) {\n            throw new UnsupportedOperationException();\n        }\n\n        /**\n         * @since 4.4\n         */\n        @Override\n        public boolean removeIf(final Predicate<? super K> filter) {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public boolean retainAll(final Collection<?> coll) {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public int size() {\n            return parent.size();\n        }\n\n        @Override\n        public List<K> subList(final int fromIndexInclusive, final int toIndexExclusive) {\n            return UnmodifiableList.unmodifiableList(super.subList(fromIndexInclusive, toIndexExclusive));\n        }\n\n        @Override\n        public Object[] toArray() {\n            return parent.keySet().toArray();\n        }\n\n        @Override\n        public <T> T[] toArray(final T[] array) {\n            return parent.keySet().toArray(array);\n        }\n    }", "definition": "    static class LinkedMapList<K> extends AbstractList<K>", "class_docstring": "\nList view of map.\n", "name": "LinkedMapList", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "private final LinkedMap<K, ?> parent;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "LinkedMap<K, ?>", "name": "parent", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        LinkedMapList(final LinkedMap<K, ?> parent) {\n            this.parent = parent;\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "LinkedMapList", "params": [{"name": "parent", "type": "LinkedMap<K, ?>"}], "body": "                                                    {\n            this.parent = parent;\n        }", "signature": "LinkedMapList(final LinkedMap<K, ?> parent)"}, {"syntax_pass": true, "original_string": "        @Override\n        public void clear() {\n            throw new UnsupportedOperationException();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "clear", "params": [], "body": "                            {\n            throw new UnsupportedOperationException();\n        }", "signature": "@Override\n        public void clear()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean contains(final Object obj) {\n            return parent.containsKey(obj);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "contains", "params": [{"name": "obj", "type": "Object"}], "body": "                                                  {\n            return parent.containsKey(obj);\n        }", "signature": "@Override\n        public boolean contains(final Object obj)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean containsAll(final Collection<?> coll) {\n            return parent.keySet().containsAll(coll);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "containsAll", "params": [{"name": "coll", "type": "Collection<?>"}], "body": "                                                             {\n            return parent.keySet().containsAll(coll);\n        }", "signature": "@Override\n        public boolean containsAll(final Collection<?> coll)"}, {"syntax_pass": true, "original_string": "        @Override\n        public K get(final int index) {\n            return parent.get(index);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "K", "classes": []}, "name": "get", "params": [{"name": "index", "type": "int"}], "body": "                                      {\n            return parent.get(index);\n        }", "signature": "@Override\n        public K get(final int index)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int indexOf(final Object obj) {\n            return parent.indexOf(obj);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "indexOf", "params": [{"name": "obj", "type": "Object"}], "body": "                                             {\n            return parent.indexOf(obj);\n        }", "signature": "@Override\n        public int indexOf(final Object obj)"}, {"syntax_pass": true, "original_string": "        @Override\n        public Iterator<K> iterator() {\n            return UnmodifiableIterator.unmodifiableIterator(parent.keySet().iterator());\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Iterator<K>", "classes": []}, "name": "iterator", "params": [], "body": "                                      {\n            return UnmodifiableIterator.unmodifiableIterator(parent.keySet().iterator());\n        }", "signature": "@Override\n        public Iterator<K> iterator()"}, {"syntax_pass": true, "original_string": "        @Override\n        public int lastIndexOf(final Object obj) {\n            return parent.indexOf(obj);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "lastIndexOf", "params": [{"name": "obj", "type": "Object"}], "body": "                                                 {\n            return parent.indexOf(obj);\n        }", "signature": "@Override\n        public int lastIndexOf(final Object obj)"}, {"syntax_pass": true, "original_string": "        @Override\n        public ListIterator<K> listIterator() {\n            return UnmodifiableListIterator.unmodifiableListIterator(super.listIterator());\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "ListIterator<K>", "classes": []}, "name": "listIterator", "params": [], "body": "                                              {\n            return UnmodifiableListIterator.unmodifiableListIterator(super.listIterator());\n        }", "signature": "@Override\n        public ListIterator<K> listIterator()"}, {"syntax_pass": true, "original_string": "        @Override\n        public ListIterator<K> listIterator(final int fromIndex) {\n            return UnmodifiableListIterator.unmodifiableListIterator(super.listIterator(fromIndex));\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "ListIterator<K>", "classes": []}, "name": "listIterator", "params": [{"name": "fromIndex", "type": "int"}], "body": "                                                                 {\n            return UnmodifiableListIterator.unmodifiableListIterator(super.listIterator(fromIndex));\n        }", "signature": "@Override\n        public ListIterator<K> listIterator(final int fromIndex)"}, {"syntax_pass": true, "original_string": "        @Override\n        public K remove(final int index) {\n            throw new UnsupportedOperationException();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "K", "classes": []}, "name": "remove", "params": [{"name": "index", "type": "int"}], "body": "                                         {\n            throw new UnsupportedOperationException();\n        }", "signature": "@Override\n        public K remove(final int index)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean remove(final Object obj) {\n            throw new UnsupportedOperationException();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "remove", "params": [{"name": "obj", "type": "Object"}], "body": "                                                {\n            throw new UnsupportedOperationException();\n        }", "signature": "@Override\n        public boolean remove(final Object obj)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean removeAll(final Collection<?> coll) {\n            throw new UnsupportedOperationException();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "removeAll", "params": [{"name": "coll", "type": "Collection<?>"}], "body": "                                                           {\n            throw new UnsupportedOperationException();\n        }", "signature": "@Override\n        public boolean removeAll(final Collection<?> coll)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean removeIf(final Predicate<? super K> filter) {\n            throw new UnsupportedOperationException();\n        }", "docstring": "\n@since 4.4\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "removeIf", "params": [{"name": "filter", "type": "Predicate<? super K>"}], "body": "                                                                   {\n            throw new UnsupportedOperationException();\n        }", "signature": "@Override\n        public boolean removeIf(final Predicate<? super K> filter)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean retainAll(final Collection<?> coll) {\n            throw new UnsupportedOperationException();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "retainAll", "params": [{"name": "coll", "type": "Collection<?>"}], "body": "                                                           {\n            throw new UnsupportedOperationException();\n        }", "signature": "@Override\n        public boolean retainAll(final Collection<?> coll)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int size() {\n            return parent.size();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "size", "params": [], "body": "                          {\n            return parent.size();\n        }", "signature": "@Override\n        public int size()"}, {"syntax_pass": true, "original_string": "        @Override\n        public List<K> subList(final int fromIndexInclusive, final int toIndexExclusive) {\n            return UnmodifiableList.unmodifiableList(super.subList(fromIndexInclusive, toIndexExclusive));\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<K>", "classes": []}, "name": "subList", "params": [{"name": "fromIndexInclusive", "type": "int"}, {"name": "toIndexExclusive", "type": "int"}], "body": "                                                                                         {\n            return UnmodifiableList.unmodifiableList(super.subList(fromIndexInclusive, toIndexExclusive));\n        }", "signature": "@Override\n        public List<K> subList(final int fromIndexInclusive, final int toIndexExclusive)"}, {"syntax_pass": true, "original_string": "        @Override\n        public Object[] toArray() {\n            return parent.keySet().toArray();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object[]", "classes": []}, "name": "toArray", "params": [], "body": "                                  {\n            return parent.keySet().toArray();\n        }", "signature": "@Override\n        public Object[] toArray()"}, {"syntax_pass": true, "original_string": "        @Override\n        public <T> T[] toArray(final T[] array) {\n            return parent.keySet().toArray(array);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "T[]", "classes": []}, "name": "toArray", "params": [{"name": "array", "type": "T[]"}], "body": "                                                {\n            return parent.keySet().toArray(array);\n        }", "signature": "@Override\n        public <T> T[] toArray(final T[] array)"}]}], "class_docstring": "\nA {@code Map} implementation that maintains the order of the entries.\nIn this implementation order is maintained by original insertion.\n<p>\nThis implementation improves on the JDK1.4 LinkedHashMap by adding the\n{@link org.apache.commons.collections4.MapIterator MapIterator}\nfunctionality, additional convenience methods and allowing\nbidirectional iteration. It also implements {@code OrderedMap}.\nIn addition, non-interface methods are provided to access the map by index.\n</p>\n<p>\nThe {@code orderedMapIterator()} method provides direct access to a\nbidirectional iterator. The iterators from the other views can also be cast\nto {@code OrderedIterator} if required.\n</p>\n<p>\nAll the available iterators can be reset back to the start by casting to\n{@code ResettableIterator} and calling {@code reset()}.\n</p>\n<p>\nThe implementation is also designed to be subclassed, with lots of useful\nmethods exposed.\n</p>\n<p>\n<strong>Note that LinkedMap is not synchronized and is not thread-safe.</strong>\nIf you wish to use this map from multiple threads concurrently, you must use\nappropriate synchronization. The simplest approach is to wrap this map\nusing {@link java.util.Collections#synchronizedMap(Map)}. This class may throw\nexceptions when accessed by concurrent threads without synchronization.\n</p>\n\n@param <K> the type of the keys in this map\n@param <V> the type of the values in this map\n@since 3.0\n", "original_string": "public class LinkedMap<K, V> extends AbstractLinkedMap<K, V> implements Serializable, Cloneable {\n\n    /**\n     * List view of map.\n     */\n    static class LinkedMapList<K> extends AbstractList<K> {\n\n        private final LinkedMap<K, ?> parent;\n\n        LinkedMapList(final LinkedMap<K, ?> parent) {\n            this.parent = parent;\n        }\n\n        @Override\n        public void clear() {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public boolean contains(final Object obj) {\n            return parent.containsKey(obj);\n        }\n\n        @Override\n        public boolean containsAll(final Collection<?> coll) {\n            return parent.keySet().containsAll(coll);\n        }\n\n        @Override\n        public K get(final int index) {\n            return parent.get(index);\n        }\n\n        @Override\n        public int indexOf(final Object obj) {\n            return parent.indexOf(obj);\n        }\n\n        @Override\n        public Iterator<K> iterator() {\n            return UnmodifiableIterator.unmodifiableIterator(parent.keySet().iterator());\n        }\n\n        @Override\n        public int lastIndexOf(final Object obj) {\n            return parent.indexOf(obj);\n        }\n\n        @Override\n        public ListIterator<K> listIterator() {\n            return UnmodifiableListIterator.unmodifiableListIterator(super.listIterator());\n        }\n\n        @Override\n        public ListIterator<K> listIterator(final int fromIndex) {\n            return UnmodifiableListIterator.unmodifiableListIterator(super.listIterator(fromIndex));\n        }\n\n        @Override\n        public K remove(final int index) {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public boolean remove(final Object obj) {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public boolean removeAll(final Collection<?> coll) {\n            throw new UnsupportedOperationException();\n        }\n\n        /**\n         * @since 4.4\n         */\n        @Override\n        public boolean removeIf(final Predicate<? super K> filter) {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public boolean retainAll(final Collection<?> coll) {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public int size() {\n            return parent.size();\n        }\n\n        @Override\n        public List<K> subList(final int fromIndexInclusive, final int toIndexExclusive) {\n            return UnmodifiableList.unmodifiableList(super.subList(fromIndexInclusive, toIndexExclusive));\n        }\n\n        @Override\n        public Object[] toArray() {\n            return parent.keySet().toArray();\n        }\n\n        @Override\n        public <T> T[] toArray(final T[] array) {\n            return parent.keySet().toArray(array);\n        }\n    }\n\n    /** Serialisation version */\n    private static final long serialVersionUID = 9077234323521161066L;\n\n    /**\n     * Constructs a new empty map with default size and load factor.\n     */\n    public LinkedMap() {\n        super(DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_THRESHOLD);\n    }\n\n    /**\n     * Constructs a new, empty map with the specified initial capacity.\n     *\n     * @param initialCapacity  the initial capacity\n     * @throws IllegalArgumentException if the initial capacity is negative\n     */\n    public LinkedMap(final int initialCapacity) {\n        super(initialCapacity);\n    }\n\n    /**\n     * Constructs a new, empty map with the specified initial capacity and\n     * load factor.\n     *\n     * @param initialCapacity  the initial capacity\n     * @param loadFactor  the load factor\n     * @throws IllegalArgumentException if the initial capacity is negative\n     * @throws IllegalArgumentException if the load factor is less than zero\n     */\n    public LinkedMap(final int initialCapacity, final float loadFactor) {\n        super(initialCapacity, loadFactor);\n    }\n\n    /**\n     * Constructor copying elements from another map.\n     *\n     * @param map  the map to copy\n     * @throws NullPointerException if the map is null\n     */\n    public LinkedMap(final Map<? extends K, ? extends V> map) {\n        super(map);\n    }\n\n    /**\n     * Gets an unmodifiable List view of the keys.\n     * <p>\n     * The returned list is unmodifiable because changes to the values of\n     * the list (using {@link java.util.ListIterator#set(Object)}) will\n     * effectively remove the value from the list and reinsert that value at\n     * the end of the list, which is an unexpected side effect of changing the\n     * value of a list.  This occurs because changing the key, changes when the\n     * mapping is added to the map and thus where it appears in the list.\n     * <p>\n     * An alternative to this method is to use {@link #keySet()}.\n     *\n     * @see #keySet()\n     * @return The ordered list of keys.\n     */\n    public List<K> asList() {\n        return new LinkedMapList<>(this);\n    }\n\n    /**\n     * Clones the map without cloning the keys or values.\n     *\n     * @return a shallow clone\n     */\n    @Override\n    public LinkedMap<K, V> clone() {\n        return (LinkedMap<K, V>) super.clone();\n    }\n\n    /**\n     * Gets the key at the specified index.\n     *\n     * @param index  the index to retrieve\n     * @return the key at the specified index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public K get(final int index) {\n        return getEntry(index).getKey();\n    }\n\n    /**\n     * Gets the value at the specified index.\n     *\n     * @param index  the index to retrieve\n     * @return the value at the specified index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public V getValue(final int index) {\n        return getEntry(index).getValue();\n    }\n\n    /**\n     * Gets the index of the specified key.\n     *\n     * @param key  the key to find the index of\n     * @return the index, or -1 if not found\n     */\n    public int indexOf(Object key) {\n        key = convertKey(key);\n        int i = 0;\n        for (LinkEntry<K, V> entry = header.after; entry != header; entry = entry.after, i++) {\n            if (isEqualKey(key, entry.key)) {\n                return i;\n            }\n        }\n        return CollectionUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * Deserializes the map in using a custom routine.\n     *\n     * @param in the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded\n     */\n    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        doReadObject(in);\n    }\n\n    /**\n     * Removes the element at the specified index.\n     *\n     * @param index  the index of the object to remove\n     * @return the previous value corresponding the {@code key},\n     *  or {@code null} if none existed\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public V remove(final int index) {\n        return remove(get(index));\n    }\n\n    /**\n     * Serializes this object to an ObjectOutputStream.\n     *\n     * @param out the target ObjectOutputStream.\n     * @throws IOException thrown when an I/O errors occur writing to the target stream.\n     */\n    private void writeObject(final ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        doWriteObject(out);\n    }\n\n}", "super_interfaces": ["Serializable", "Cloneable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 9077234323521161066L;", "docstring": " Serialisation version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 9077234323521161066L", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/map/ReferenceMap.java.ReferenceMap", "name": "ReferenceMap", "file_path": "src/main/java/org/apache/commons/collections4/map/ReferenceMap.java", "superclasses": "", "methods": ["[]ReferenceMap()", "[]ReferenceMap(ReferenceStrength,ReferenceStrength)", "[]ReferenceMap(ReferenceStrength,ReferenceStrength,boolean)", "[]ReferenceMap(ReferenceStrength,ReferenceStrength,int,float)", "[]ReferenceMap(ReferenceStrength,ReferenceStrength,int,float,boolean)", "[void]readObject(ObjectInputStream)", "[void]writeObject(ObjectOutputStream)"], "method_uris": ["src/main/java/org/apache/commons/collections4/map/ReferenceMap.java.ReferenceMap.[]ReferenceMap()", "src/main/java/org/apache/commons/collections4/map/ReferenceMap.java.ReferenceMap.[]ReferenceMap(ReferenceStrength,ReferenceStrength)", "src/main/java/org/apache/commons/collections4/map/ReferenceMap.java.ReferenceMap.[]ReferenceMap(ReferenceStrength,ReferenceStrength,boolean)", "src/main/java/org/apache/commons/collections4/map/ReferenceMap.java.ReferenceMap.[]ReferenceMap(ReferenceStrength,ReferenceStrength,int,float)", "src/main/java/org/apache/commons/collections4/map/ReferenceMap.java.ReferenceMap.[]ReferenceMap(ReferenceStrength,ReferenceStrength,int,float,boolean)", "src/main/java/org/apache/commons/collections4/map/ReferenceMap.java.ReferenceMap.[void]readObject(ObjectInputStream)", "src/main/java/org/apache/commons/collections4/map/ReferenceMap.java.ReferenceMap.[void]writeObject(ObjectOutputStream)"], "overrides": null, "attributes": [], "class_docstring": "\nA {@code Map} implementation that allows mappings to be\nremoved by the garbage collector.\n<p>\nWhen you construct a {@code ReferenceMap}, you can specify what kind\nof references are used to store the map's keys and values.\nIf non-hard references are used, then the garbage collector can remove\nmappings if a key or value becomes unreachable, or if the JVM's memory is\nrunning low. For information on how the different reference types behave,\nsee {@link java.lang.ref.Reference Reference}.\n</p>\n<p>\nDifferent types of references can be specified for keys and values.\nThe keys can be configured to be weak but the values hard,\nin which case this class will behave like a\n<a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/WeakHashMap.html\">\n{@code WeakHashMap}</a>. However, you can also specify hard keys and\nweak values, or any other combination. The default constructor uses\nhard keys and soft values, providing a memory-sensitive cache.\n</p>\n<p>\nThis map is similar to\n{@link org.apache.commons.collections4.map.ReferenceIdentityMap ReferenceIdentityMap}.\nIt differs in that keys and values in this class are compared using {@code equals()}.\n</p>\n<p>\nThis {@link java.util.Map Map} implementation does <em>not</em> allow null elements.\nAttempting to add a null key or value to the map will raise a {@code NullPointerException}.\n</p>\n<p>\nThis implementation is not synchronized.\nYou can use {@link java.util.Collections#synchronizedMap} to\nprovide synchronized access to a {@code ReferenceMap}.\nRemember that synchronization will not stop the garbage collector removing entries.\n</p>\n<p>\nAll the available iterators can be reset back to the start by casting to\n{@code ResettableIterator} and calling {@code reset()}.\n</p>\n<p>\n<strong>Note that ReferenceMap is not synchronized and is not thread-safe.</strong>\nIf you wish to use this map from multiple threads concurrently, you must use\nappropriate synchronization. The simplest approach is to wrap this map\nusing {@link java.util.Collections#synchronizedMap}. This class may throw\nexceptions when accessed by concurrent threads without synchronization.\n</p>\n<p>\nNOTE: As from Commons Collections 3.1 this map extends {@code AbstractReferenceMap}\n(previously it extended AbstractMap). As a result, the implementation is now\nextensible and provides a {@code MapIterator}.\n</p>\n\n@param <K> the type of the keys in the map\n@param <V> the type of the values in the map\n\n@see java.lang.ref.Reference\n@since 3.0 (previously in main package v2.1)\n", "original_string": "public class ReferenceMap<K, V> extends AbstractReferenceMap<K, V> implements Serializable {\n\n    /** Serialization version */\n    private static final long serialVersionUID = 1555089888138299607L;\n\n    /**\n     * Constructs a new {@code ReferenceMap} that will\n     * use hard references to keys and soft references to values.\n     */\n    public ReferenceMap() {\n        super(ReferenceStrength.HARD, ReferenceStrength.SOFT, DEFAULT_CAPACITY,\n                DEFAULT_LOAD_FACTOR, false);\n    }\n\n    /**\n     * Constructs a new {@code ReferenceMap} that will\n     * use the specified types of references.\n     *\n     * @param keyType  the type of reference to use for keys;\n     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\n     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\n     *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n     * @param valueType  the type of reference to use for values;\n     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\n     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\n     *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n     */\n    public ReferenceMap(final ReferenceStrength keyType, final ReferenceStrength valueType) {\n        super(keyType, valueType, DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR, false);\n    }\n\n    /**\n     * Constructs a new {@code ReferenceMap} that will\n     * use the specified types of references.\n     *\n     * @param keyType  the type of reference to use for keys;\n     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\n     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\n     *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n     * @param valueType  the type of reference to use for values;\n     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\n     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\n     *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n     * @param purgeValues should the value be automatically purged when the\n     *   key is garbage collected\n     */\n    public ReferenceMap(final ReferenceStrength keyType, final ReferenceStrength valueType, final boolean purgeValues) {\n        super(keyType, valueType, DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR, purgeValues);\n    }\n\n    /**\n     * Constructs a new {@code ReferenceMap} with the\n     * specified reference types, load factor and initial\n     * capacity.\n     *\n     * @param keyType  the type of reference to use for keys;\n     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\n     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\n     *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n     * @param valueType  the type of reference to use for values;\n     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\n     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\n     *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n     * @param capacity  the initial capacity for the map\n     * @param loadFactor  the load factor for the map\n     */\n    public ReferenceMap(final ReferenceStrength keyType, final ReferenceStrength valueType, final int capacity,\n            final float loadFactor) {\n        super(keyType, valueType, capacity, loadFactor, false);\n    }\n\n    /**\n     * Constructs a new {@code ReferenceMap} with the\n     * specified reference types, load factor and initial\n     * capacity.\n     *\n     * @param keyType  the type of reference to use for keys;\n     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\n     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\n     *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n     * @param valueType  the type of reference to use for values;\n     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\n     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\n     *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n     * @param capacity  the initial capacity for the map\n     * @param loadFactor  the load factor for the map\n     * @param purgeValues  should the value be automatically purged when the\n     *   key is garbage collected\n     */\n    public ReferenceMap(final ReferenceStrength keyType, final ReferenceStrength valueType, final int capacity,\n            final float loadFactor, final boolean purgeValues) {\n        super(keyType, valueType, capacity, loadFactor, purgeValues);\n    }\n\n    /**\n     * Deserializes the map in using a custom routine.\n     *\n     * @param in the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded\n     */\n    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        doReadObject(in);\n    }\n\n    /**\n     * Serializes this object to an ObjectOutputStream.\n     *\n     * @param out the target ObjectOutputStream.\n     * @throws IOException thrown when an I/O errors occur writing to the target stream.\n     */\n    private void writeObject(final ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        doWriteObject(out);\n    }\n\n}", "super_interfaces": ["Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 1555089888138299607L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 1555089888138299607L", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/map/MultiValueMap.java.MultiValueMap", "name": "MultiValueMap", "file_path": "src/main/java/org/apache/commons/collections4/map/MultiValueMap.java", "superclasses": "", "methods": ["[MultiValueMap<K, V>]multiValueMap(Map<K, ? super C>,Class<C>)", "[MultiValueMap<K, V>]multiValueMap(Map<K, ? super C>,Factory<C>)", "[MultiValueMap<K, V>]multiValueMap(Map<K, ? super Collection<V>>)", "[]MultiValueMap()", "[]MultiValueMap(Map<K, ? super C>,Factory<C>)", "[void]clear()", "[boolean]containsValue(Object)", "[boolean]containsValue(Object,Object)", "[Collection<V>]createCollection(int)", "[Set<Entry<K, Object>>]entrySet()", "[Collection<V>]getCollection(Object)", "[Iterator<Entry<K, V>>]iterator()", "[Iterator<V>]iterator(Object)", "[Object]put(K,Object)", "[boolean]putAll(K,Collection<V>)", "[void]putAll(Map<? extends K, ?>)", "[void]readObject(ObjectInputStream)", "[boolean]removeMapping(Object,Object)", "[int]size(Object)", "[int]totalSize()", "[Collection<Object>]values()", "[void]writeObject(ObjectOutputStream)"], "method_uris": ["src/main/java/org/apache/commons/collections4/map/MultiValueMap.java.MultiValueMap.[MultiValueMap<K, V>]multiValueMap(Map<K, ? super C>,Class<C>)", "src/main/java/org/apache/commons/collections4/map/MultiValueMap.java.MultiValueMap.[MultiValueMap<K, V>]multiValueMap(Map<K, ? super C>,Factory<C>)", "src/main/java/org/apache/commons/collections4/map/MultiValueMap.java.MultiValueMap.[MultiValueMap<K, V>]multiValueMap(Map<K, ? super Collection<V>>)", "src/main/java/org/apache/commons/collections4/map/MultiValueMap.java.MultiValueMap.[]MultiValueMap()", "src/main/java/org/apache/commons/collections4/map/MultiValueMap.java.MultiValueMap.[]MultiValueMap(Map<K, ? super C>,Factory<C>)", "src/main/java/org/apache/commons/collections4/map/MultiValueMap.java.MultiValueMap.[void]clear()", "src/main/java/org/apache/commons/collections4/map/MultiValueMap.java.MultiValueMap.[boolean]containsValue(Object)", "src/main/java/org/apache/commons/collections4/map/MultiValueMap.java.MultiValueMap.[boolean]containsValue(Object,Object)", "src/main/java/org/apache/commons/collections4/map/MultiValueMap.java.MultiValueMap.[Collection<V>]createCollection(int)", "src/main/java/org/apache/commons/collections4/map/MultiValueMap.java.MultiValueMap.[Set<Entry<K, Object>>]entrySet()", "src/main/java/org/apache/commons/collections4/map/MultiValueMap.java.MultiValueMap.[Collection<V>]getCollection(Object)", "src/main/java/org/apache/commons/collections4/map/MultiValueMap.java.MultiValueMap.[Iterator<Entry<K, V>>]iterator()", "src/main/java/org/apache/commons/collections4/map/MultiValueMap.java.MultiValueMap.[Iterator<V>]iterator(Object)", "src/main/java/org/apache/commons/collections4/map/MultiValueMap.java.MultiValueMap.[Object]put(K,Object)", "src/main/java/org/apache/commons/collections4/map/MultiValueMap.java.MultiValueMap.[boolean]putAll(K,Collection<V>)", "src/main/java/org/apache/commons/collections4/map/MultiValueMap.java.MultiValueMap.[void]putAll(Map<? extends K, ?>)", "src/main/java/org/apache/commons/collections4/map/MultiValueMap.java.MultiValueMap.[void]readObject(ObjectInputStream)", "src/main/java/org/apache/commons/collections4/map/MultiValueMap.java.MultiValueMap.[boolean]removeMapping(Object,Object)", "src/main/java/org/apache/commons/collections4/map/MultiValueMap.java.MultiValueMap.[int]size(Object)", "src/main/java/org/apache/commons/collections4/map/MultiValueMap.java.MultiValueMap.[int]totalSize()", "src/main/java/org/apache/commons/collections4/map/MultiValueMap.java.MultiValueMap.[Collection<Object>]values()", "src/main/java/org/apache/commons/collections4/map/MultiValueMap.java.MultiValueMap.[void]writeObject(ObjectOutputStream)"], "overrides": null, "attributes": [{"original_string": "    private static final class ReflectionFactory<T extends Collection<?>> implements Factory<T>, Serializable {\n\n        /** Serialization version */\n        private static final long serialVersionUID = 2986114157496788874L;\n\n        private final Class<T> clazz;\n\n        ReflectionFactory(final Class<T> clazz) {\n            this.clazz = clazz;\n        }\n\n        @Override\n        public T create() {\n            try {\n                return clazz.getDeclaredConstructor().newInstance();\n            } catch (final Exception ex) {\n                throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex);\n            }\n        }\n\n        /**\n         * Deserializes an instance from an ObjectInputStream.\n         *\n         * @param in The source ObjectInputStream.\n         * @throws IOException            Any of the usual Input/Output related exceptions.\n         * @throws ClassNotFoundException A class of a serialized object cannot be found.\n         */\n        private void readObject(final ObjectInputStream is) throws IOException, ClassNotFoundException {\n            is.defaultReadObject();\n            // ensure that the de-serialized class is a Collection, COLLECTIONS-580\n            if (clazz != null && !Collection.class.isAssignableFrom(clazz)) {\n                throw new UnsupportedOperationException();\n            }\n        }\n    }", "definition": "    private static final class ReflectionFactory<T extends Collection<?>> implements Factory<T>, Serializable", "class_docstring": "\nInner class that provides a simple reflection factory.\n\n@param <T> the type of results supplied by this supplier.\n", "name": "ReflectionFactory", "super_interfaces": ["Factory<T>", "Serializable"], "superclasses": "", "attributes": {"modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = 2986114157496788874L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 2986114157496788874L", "syntax_pass": true}, {"attribute_expression": "private final Class<T> clazz;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Class<T>", "name": "clazz", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        ReflectionFactory(final Class<T> clazz) {\n            this.clazz = clazz;\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "ReflectionFactory", "params": [{"name": "clazz", "type": "Class<T>"}], "body": "                                                {\n            this.clazz = clazz;\n        }", "signature": "ReflectionFactory(final Class<T> clazz)"}, {"syntax_pass": true, "original_string": "        @Override\n        public T create() {\n            try {\n                return clazz.getDeclaredConstructor().newInstance();\n            } catch (final Exception ex) {\n                throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex);\n            }\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "T", "classes": []}, "name": "create", "params": [], "body": "                          {\n            try {\n                return clazz.getDeclaredConstructor().newInstance();\n            } catch (final Exception ex) {\n                throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex);\n            }\n        }", "signature": "@Override\n        public T create()"}, {"syntax_pass": true, "original_string": "        private void readObject(final ObjectInputStream is) throws IOException, ClassNotFoundException {\n            is.defaultReadObject();\n            // ensure that the de-serialized class is a Collection, COLLECTIONS-580\n            if (clazz != null && !Collection.class.isAssignableFrom(clazz)) {\n                throw new UnsupportedOperationException();\n            }\n        }", "docstring": "\nDeserializes an instance from an ObjectInputStream.\n\n@param in The source ObjectInputStream.\n@throws IOException            Any of the usual Input/Output related exceptions.\n@throws ClassNotFoundException A class of a serialized object cannot be found.\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "readObject", "params": [{"name": "is", "type": "ObjectInputStream"}], "body": "                                                                                                       {\n            is.defaultReadObject();\n            // ensure that the de-serialized class is a Collection, COLLECTIONS-580\n            if (clazz != null && !Collection.class.isAssignableFrom(clazz)) {\n                throw new UnsupportedOperationException();\n            }\n        }", "signature": "private void readObject(final ObjectInputStream is)"}]}, {"original_string": "    private final class Values extends AbstractCollection<V> {\n        @Override\n        public void clear() {\n            MultiValueMap.this.clear();\n        }\n\n        @Override\n        public Iterator<V> iterator() {\n            final IteratorChain<V> chain = new IteratorChain<>();\n            for (final K k : keySet()) {\n                chain.addIterator(new ValuesIterator(k));\n            }\n            return chain;\n        }\n\n        @Override\n        public int size() {\n            return totalSize();\n        }\n    }", "definition": "    private final class Values extends AbstractCollection<V>", "class_docstring": "\nInner class that provides the values view.\n", "name": "Values", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @Override\n        public void clear() {\n            MultiValueMap.this.clear();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "clear", "params": [], "body": "                            {\n            MultiValueMap.this.clear();\n        }", "signature": "@Override\n        public void clear()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Iterator<V> iterator() {\n            final IteratorChain<V> chain = new IteratorChain<>();\n            for (final K k : keySet()) {\n                chain.addIterator(new ValuesIterator(k));\n            }\n            return chain;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Iterator<V>", "classes": []}, "name": "iterator", "params": [], "body": "                                      {\n            final IteratorChain<V> chain = new IteratorChain<>();\n            for (final K k : keySet()) {\n                chain.addIterator(new ValuesIterator(k));\n            }\n            return chain;\n        }", "signature": "@Override\n        public Iterator<V> iterator()"}, {"syntax_pass": true, "original_string": "        @Override\n        public int size() {\n            return totalSize();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "size", "params": [], "body": "                          {\n            return totalSize();\n        }", "signature": "@Override\n        public int size()"}]}, {"original_string": "    private final class ValuesIterator implements Iterator<V> {\n        private final Object key;\n        private final Collection<V> values;\n        private final Iterator<V> iterator;\n\n        ValuesIterator(final Object key) {\n            this.key = key;\n            this.values = getCollection(key);\n            this.iterator = values.iterator();\n        }\n\n        @Override\n        public boolean hasNext() {\n            return iterator.hasNext();\n        }\n\n        @Override\n        public V next() {\n            return iterator.next();\n        }\n\n        @Override\n        public void remove() {\n            iterator.remove();\n            if (values.isEmpty()) {\n                MultiValueMap.this.remove(key);\n            }\n        }\n    }", "definition": "    private final class ValuesIterator implements Iterator<V>", "class_docstring": "\nInner class that provides the values iterator.\n", "name": "ValuesIterator", "super_interfaces": ["Iterator<V>"], "superclasses": "", "attributes": {"modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "fields": [{"attribute_expression": "private final Object key;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Object", "name": "key", "syntax_pass": true}, {"attribute_expression": "private final Collection<V> values;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Collection<V>", "name": "values", "syntax_pass": true}, {"attribute_expression": "private final Iterator<V> iterator;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Iterator<V>", "name": "iterator", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        ValuesIterator(final Object key) {\n            this.key = key;\n            this.values = getCollection(key);\n            this.iterator = values.iterator();\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "ValuesIterator", "params": [{"name": "key", "type": "Object"}], "body": "                                         {\n            this.key = key;\n            this.values = getCollection(key);\n            this.iterator = values.iterator();\n        }", "signature": "ValuesIterator(final Object key)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean hasNext() {\n            return iterator.hasNext();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasNext", "params": [], "body": "                                 {\n            return iterator.hasNext();\n        }", "signature": "@Override\n        public boolean hasNext()"}, {"syntax_pass": true, "original_string": "        @Override\n        public V next() {\n            return iterator.next();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "next", "params": [], "body": "                        {\n            return iterator.next();\n        }", "signature": "@Override\n        public V next()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void remove() {\n            iterator.remove();\n            if (values.isEmpty()) {\n                MultiValueMap.this.remove(key);\n            }\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "remove", "params": [], "body": "                             {\n            iterator.remove();\n            if (values.isEmpty()) {\n                MultiValueMap.this.remove(key);\n            }\n        }", "signature": "@Override\n        public void remove()"}]}], "class_docstring": "\nA MultiValueMap decorates another map, allowing it to have\nmore than one value for a key.\n<p>\nA {@code MultiMap} is a Map with slightly different semantics.\nPutting a value into the map will add the value to a Collection at that key.\nGetting a value will return a Collection, holding all the values put to that key.\n</p>\n<p>\nThis implementation is a decorator, allowing any Map implementation\nto be used as the base.\n</p>\n<p>\nIn addition, this implementation allows the type of collection used\nfor the values to be controlled. By default, an {@code ArrayList}\nis used, however a {@code Class} to instantiate may be specified,\nor a factory that returns a {@code Collection} instance.\n</p>\n<p>\n<strong>Note that MultiValueMap is not synchronized and is not thread-safe.</strong>\nIf you wish to use this map from multiple threads concurrently, you must use\nappropriate synchronization. This class may throw exceptions when accessed\nby concurrent threads without synchronization.\n</p>\n\n@param <K> the type of the keys in this map\n@param <V> the type of the values in this map\n@since 3.2\n@deprecated since 4.1, use {@link org.apache.commons.collections4.MultiValuedMap MultiValuedMap} instead\n", "original_string": "@Deprecated\npublic class MultiValueMap<K, V> extends AbstractMapDecorator<K, Object> implements MultiMap<K, V>, Serializable {\n\n    /**\n     * Inner class that provides a simple reflection factory.\n     *\n     * @param <T> the type of results supplied by this supplier.\n     */\n    private static final class ReflectionFactory<T extends Collection<?>> implements Factory<T>, Serializable {\n\n        /** Serialization version */\n        private static final long serialVersionUID = 2986114157496788874L;\n\n        private final Class<T> clazz;\n\n        ReflectionFactory(final Class<T> clazz) {\n            this.clazz = clazz;\n        }\n\n        @Override\n        public T create() {\n            try {\n                return clazz.getDeclaredConstructor().newInstance();\n            } catch (final Exception ex) {\n                throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex);\n            }\n        }\n\n        /**\n         * Deserializes an instance from an ObjectInputStream.\n         *\n         * @param in The source ObjectInputStream.\n         * @throws IOException            Any of the usual Input/Output related exceptions.\n         * @throws ClassNotFoundException A class of a serialized object cannot be found.\n         */\n        private void readObject(final ObjectInputStream is) throws IOException, ClassNotFoundException {\n            is.defaultReadObject();\n            // ensure that the de-serialized class is a Collection, COLLECTIONS-580\n            if (clazz != null && !Collection.class.isAssignableFrom(clazz)) {\n                throw new UnsupportedOperationException();\n            }\n        }\n    }\n\n    /**\n     * Inner class that provides the values view.\n     */\n    private final class Values extends AbstractCollection<V> {\n        @Override\n        public void clear() {\n            MultiValueMap.this.clear();\n        }\n\n        @Override\n        public Iterator<V> iterator() {\n            final IteratorChain<V> chain = new IteratorChain<>();\n            for (final K k : keySet()) {\n                chain.addIterator(new ValuesIterator(k));\n            }\n            return chain;\n        }\n\n        @Override\n        public int size() {\n            return totalSize();\n        }\n    }\n    /**\n     * Inner class that provides the values iterator.\n     */\n    private final class ValuesIterator implements Iterator<V> {\n        private final Object key;\n        private final Collection<V> values;\n        private final Iterator<V> iterator;\n\n        ValuesIterator(final Object key) {\n            this.key = key;\n            this.values = getCollection(key);\n            this.iterator = values.iterator();\n        }\n\n        @Override\n        public boolean hasNext() {\n            return iterator.hasNext();\n        }\n\n        @Override\n        public V next() {\n            return iterator.next();\n        }\n\n        @Override\n        public void remove() {\n            iterator.remove();\n            if (values.isEmpty()) {\n                MultiValueMap.this.remove(key);\n            }\n        }\n    }\n\n    /** Serialization version */\n    private static final long serialVersionUID = -2214159910087182007L;\n\n    /**\n     * Creates a map which decorates the given {@code map} and\n     * maps keys to collections of type {@code collectionClass}.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param <C>  the collection class type\n     * @param map  the map to wrap\n     * @param collectionClass  the type of the collection class\n     * @return a new multi-value map\n     * @since 4.0\n     */\n    public static <K, V, C extends Collection<V>> MultiValueMap<K, V> multiValueMap(final Map<K, ? super C> map,\n                                                                                    final Class<C> collectionClass) {\n        return new MultiValueMap<>(map, new ReflectionFactory<>(collectionClass));\n    }\n\n    /**\n     * Creates a map which decorates the given {@code map} and\n     * creates the value collections using the supplied {@code collectionFactory}.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param <C>  the collection class type\n     * @param map  the map to decorate\n     * @param collectionFactory  the collection factory (must return a Collection object).\n     * @return a new multi-value map\n     * @since 4.0\n     */\n    public static <K, V, C extends Collection<V>> MultiValueMap<K, V> multiValueMap(final Map<K, ? super C> map,\n            final Factory<C> collectionFactory) {\n        return new MultiValueMap<>(map, collectionFactory);\n    }\n\n    /**\n     * Creates a map which wraps the given map and\n     * maps keys to ArrayLists.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param map  the map to wrap\n     * @return a new multi-value map\n     * @since 4.0\n     */\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public static <K, V> MultiValueMap<K, V> multiValueMap(final Map<K, ? super Collection<V>> map) {\n        return MultiValueMap.<K, V, ArrayList>multiValueMap((Map<K, ? super Collection>) map, ArrayList.class);\n    }\n\n    /** The factory for creating value collections. */\n    private final Factory<? extends Collection<V>> collectionFactory;\n\n    /** The cached values. */\n    private transient Collection<V> valuesView;\n\n    /**\n     * Creates a MultiValueMap based on a {@code HashMap} and\n     * storing the multiple values in an {@code ArrayList}.\n     */\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public MultiValueMap() {\n        this(new HashMap<>(), new ReflectionFactory(ArrayList.class));\n    }\n\n    /**\n     * Creates a MultiValueMap which decorates the given {@code map} and\n     * creates the value collections using the supplied {@code collectionFactory}.\n     *\n     * @param <C>  the collection class type\n     * @param map  the map to decorate\n     * @param collectionFactory  the collection factory which must return a Collection instance\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected <C extends Collection<V>> MultiValueMap(final Map<K, ? super C> map,\n                                                      final Factory<C> collectionFactory) {\n        super((Map<K, Object>) map);\n        if (collectionFactory == null) {\n            throw new IllegalArgumentException(\"The factory must not be null\");\n        }\n        this.collectionFactory = collectionFactory;\n    }\n\n    /**\n     * Clear the map.\n     */\n    @Override\n    public void clear() {\n        // If you believe that you have GC issues here, try uncommenting this code\n//        Set pairs = getMap().entrySet();\n//        Iterator pairsIterator = pairs.iterator();\n//        while (pairsIterator.hasNext()) {\n//            Map.Entry keyValuePair = (Map.Entry) pairsIterator.next();\n//            Collection coll = (Collection) keyValuePair.getValue();\n//            coll.clear();\n//        }\n        decorated().clear();\n    }\n\n    /**\n     * Checks whether the map contains the value specified.\n     * <p>\n     * This checks all collections against all keys for the value, and thus could be slow.\n     *\n     * @param value  the value to search for\n     * @return true if the map contains the value\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public boolean containsValue(final Object value) {\n        final Set<Map.Entry<K, Object>> pairs = decorated().entrySet();\n        if (pairs != null) {\n            for (final Map.Entry<K, Object> entry : pairs) {\n                if (((Collection<V>) entry.getValue()).contains(value)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Checks whether the collection at the specified key contains the value.\n     *\n     * @param key  the key to search for\n     * @param value  the value to search for\n     * @return true if the map contains the value\n     */\n    public boolean containsValue(final Object key, final Object value) {\n        final Collection<V> coll = getCollection(key);\n        if (coll == null) {\n            return false;\n        }\n        return coll.contains(value);\n    }\n\n    /**\n     * Creates a new instance of the map value Collection container\n     * using the factory.\n     * <p>\n     * This method can be overridden to perform your own processing\n     * instead of using the factory.\n     *\n     * @param size  the collection size that is about to be added\n     * @return the new collection\n     */\n    protected Collection<V> createCollection(final int size) {\n        return collectionFactory.get();\n    }\n\n    /**\n     * {@inheritDoc}\n     * <p>\n     * NOTE: the returned Entry objects will contain as value a {@link Collection}\n     * of all values that are mapped to the given key. To get a \"flattened\" version\n     * of all mappings contained in this map, use {@link #iterator()}.\n     *\n     * @see #iterator()\n     */\n    @Override\n    public Set<Entry<K, Object>> entrySet() { // NOPMD\n        return super.entrySet();\n    }\n\n    /**\n     * Gets the collection mapped to the specified key.\n     * This method is a convenience method to typecast the result of {@code get(key)}.\n     *\n     * @param key  the key to retrieve\n     * @return the collection mapped to the key, null if no mapping\n     */\n    @SuppressWarnings(\"unchecked\")\n    public Collection<V> getCollection(final Object key) {\n        return (Collection<V>) decorated().get(key);\n    }\n\n    /**\n     * Gets an iterator for all mappings stored in this {@link MultiValueMap}.\n     * <p>\n     * The iterator will return multiple Entry objects with the same key\n     * if there are multiple values mapped to this key.\n     * <p>\n     * NOTE: calling {@link java.util.Map.Entry#setValue(Object)} on any of the returned\n     * elements will result in a {@link UnsupportedOperationException}.\n     *\n     * @return the iterator of all mappings in this map\n     * @since 4.0\n     */\n    public Iterator<Entry<K, V>> iterator() {\n        final Collection<K> allKeys = new ArrayList<>(keySet());\n        final Iterator<K> keyIterator = allKeys.iterator();\n\n        return new LazyIteratorChain<Entry<K, V>>() {\n            @Override\n            protected Iterator<? extends Entry<K, V>> nextIterator(final int count) {\n                if ( ! keyIterator.hasNext() ) {\n                    return null;\n                }\n                final K key = keyIterator.next();\n                final Transformer<V, Entry<K, V>> transformer = input -> new Entry<K, V>() {\n                    @Override\n                    public K getKey() {\n                        return key;\n                    }\n                    @Override\n                    public V getValue() {\n                        return input;\n                    }\n                    @Override\n                    public V setValue(final V value) {\n                        throw new UnsupportedOperationException();\n                    }\n                };\n                return new TransformIterator<>(new ValuesIterator(key), transformer);\n            }\n        };\n    }\n\n    /**\n     * Gets an iterator for the collection mapped to the specified key.\n     *\n     * @param key  the key to get an iterator for\n     * @return the iterator of the collection at the key, empty iterator if key not in map\n     */\n    public Iterator<V> iterator(final Object key) {\n        if (!containsKey(key)) {\n            return EmptyIterator.<V>emptyIterator();\n        }\n        return new ValuesIterator(key);\n    }\n\n    /**\n     * Adds the value to the collection associated with the specified key.\n     * <p>\n     * Unlike a normal {@code Map} the previous value is not replaced.\n     * Instead, the new value is added to the collection stored against the key.\n     *\n     * @param key  the key to store against\n     * @param value  the value to add to the collection at the key\n     * @return the value added if the map changed and null if the map did not change\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public Object put(final K key, final Object value) {\n        boolean result = false;\n        Collection<V> coll = getCollection(key);\n        if (coll == null) {\n            coll = createCollection(1);  // might produce a non-empty collection\n            coll.add((V) value);\n            if (!coll.isEmpty()) {\n                // only add if non-zero size to maintain class state\n                decorated().put(key, coll);\n                result = true;  // map definitely changed\n            }\n        } else {\n            result = coll.add((V) value);\n        }\n        return result ? value : null;\n    }\n\n    /**\n     * Adds a collection of values to the collection associated with\n     * the specified key.\n     *\n     * @param key  the key to store against\n     * @param values  the values to add to the collection at the key, null ignored\n     * @return true if this map changed\n     */\n    public boolean putAll(final K key, final Collection<V> values) {\n        if (values == null || values.isEmpty()) {\n            return false;\n        }\n        boolean result = false;\n        Collection<V> coll = getCollection(key);\n        if (coll == null) {\n            coll = createCollection(values.size());  // might produce a non-empty collection\n            coll.addAll(values);\n            if (!coll.isEmpty()) {\n                // only add if non-zero size to maintain class state\n                decorated().put(key, coll);\n                result = true;  // map definitely changed\n            }\n        } else {\n            result = coll.addAll(values);\n        }\n        return result;\n    }\n\n    /**\n     * Override superclass to ensure that MultiMap instances are\n     * correctly handled.\n     * <p>\n     * If you call this method with a normal map, each entry is\n     * added using {@code put(Object,Object)}.\n     * If you call this method with a multi map, each entry is\n     * added using {@code putAll(Object,Collection)}.\n     *\n     * @param map  the map to copy (either a normal or multi map)\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public void putAll(final Map<? extends K, ?> map) {\n        if (map instanceof MultiMap) {\n            for (final Map.Entry<? extends K, Object> entry : ((MultiMap<? extends K, V>) map).entrySet()) {\n                putAll(entry.getKey(), (Collection<V>) entry.getValue());\n            }\n        } else {\n            for (final Map.Entry<? extends K, ?> entry : map.entrySet()) {\n                put(entry.getKey(), entry.getValue());\n            }\n        }\n    }\n\n    /**\n     * Deserializes the map in using a custom routine.\n     *\n     * @param in  the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded\n     * @since 4.0\n     */\n    @SuppressWarnings(\"unchecked\") // (1) should only fail if input stream is incorrect\n    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        map = (Map<K, Object>) in.readObject(); // (1)\n    }\n\n    /**\n     * Removes a specific value from map.\n     * <p>\n     * The item is removed from the collection mapped to the specified key.\n     * Other values attached to that key are unaffected.\n     * <p>\n     * If the last value for a key is removed, {@code null} will be returned\n     * from a subsequent {@code get(key)}.\n     *\n     * @param key  the key to remove from\n     * @param value the value to remove\n     * @return {@code true} if the mapping was removed, {@code false} otherwise\n     */\n    @Override\n    public boolean removeMapping(final Object key, final Object value) {\n        final Collection<V> valuesForKey = getCollection(key);\n        if (valuesForKey == null) {\n            return false;\n        }\n        final boolean removed = valuesForKey.remove(value);\n        if (!removed) {\n            return false;\n        }\n        if (valuesForKey.isEmpty()) {\n            remove(key);\n        }\n        return true;\n    }\n\n    /**\n     * Gets the size of the collection mapped to the specified key.\n     *\n     * @param key  the key to get size for\n     * @return the size of the collection at the key, zero if key not in map\n     */\n    public int size(final Object key) {\n        final Collection<V> coll = getCollection(key);\n        if (coll == null) {\n            return 0;\n        }\n        return coll.size();\n    }\n\n    /**\n     * Gets the total size of the map by counting all the values.\n     *\n     * @return the total size of the map counting all values\n     */\n    public int totalSize() {\n        int total = 0;\n        for (final Object v : decorated().values()) {\n            total += CollectionUtils.size(v);\n        }\n        return total;\n    }\n\n    /**\n     * Gets a collection containing all the values in the map.\n     * <p>\n     * This returns a collection containing the combination of values from all keys.\n     *\n     * @return a collection view of the values contained in this map\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public Collection<Object> values() {\n        final Collection<V> vs = valuesView;\n        return (Collection<Object>) (vs != null ? vs : (valuesView = new Values()));\n    }\n\n    /**\n     * Serializes this object to an ObjectOutputStream.\n     *\n     * @param out the target ObjectOutputStream.\n     * @throws IOException thrown when an I/O errors occur writing to the target stream.\n     * @since 4.0\n     */\n    private void writeObject(final ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        out.writeObject(map);\n    }\n\n}", "super_interfaces": ["MultiMap<K, V>", "Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = -2214159910087182007L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -2214159910087182007L", "syntax_pass": true}, {"attribute_expression": "private final Factory<? extends Collection<V>> collectionFactory;", "docstring": " The factory for creating value collections.", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Factory<? extends Collection<V>>", "name": "collectionFactory", "syntax_pass": true}, {"attribute_expression": "private transient Collection<V> valuesView;", "docstring": " The cached values.", "modifiers": "private transient", "marker_annotations": [], "non_marker_annotations": ["private", "transient"], "comments": [], "type": "Collection<V>", "name": "valuesView", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/map/UnmodifiableSortedMap.java.UnmodifiableSortedMap", "name": "UnmodifiableSortedMap", "file_path": "src/main/java/org/apache/commons/collections4/map/UnmodifiableSortedMap.java", "superclasses": "", "methods": ["[SortedMap<K, V>]unmodifiableSortedMap(SortedMap<K, ? extends V>)", "[]UnmodifiableSortedMap(SortedMap<K, ? extends V>)", "[void]clear()", "[Comparator<? super K>]comparator()", "[Set<Map.Entry<K, V>>]entrySet()", "[K]firstKey()", "[SortedMap<K, V>]headMap(K)", "[Set<K>]keySet()", "[K]lastKey()", "[V]put(K,V)", "[void]putAll(Map<? extends K, ? extends V>)", "[void]readObject(ObjectInputStream)", "[V]remove(Object)", "[SortedMap<K, V>]subMap(K,K)", "[SortedMap<K, V>]tailMap(K)", "[Collection<V>]values()", "[void]writeObject(ObjectOutputStream)"], "method_uris": ["src/main/java/org/apache/commons/collections4/map/UnmodifiableSortedMap.java.UnmodifiableSortedMap.[SortedMap<K, V>]unmodifiableSortedMap(SortedMap<K, ? extends V>)", "src/main/java/org/apache/commons/collections4/map/UnmodifiableSortedMap.java.UnmodifiableSortedMap.[]UnmodifiableSortedMap(SortedMap<K, ? extends V>)", "src/main/java/org/apache/commons/collections4/map/UnmodifiableSortedMap.java.UnmodifiableSortedMap.[void]clear()", "src/main/java/org/apache/commons/collections4/map/UnmodifiableSortedMap.java.UnmodifiableSortedMap.[Comparator<? super K>]comparator()", "src/main/java/org/apache/commons/collections4/map/UnmodifiableSortedMap.java.UnmodifiableSortedMap.[Set<Map.Entry<K, V>>]entrySet()", "src/main/java/org/apache/commons/collections4/map/UnmodifiableSortedMap.java.UnmodifiableSortedMap.[K]firstKey()", "src/main/java/org/apache/commons/collections4/map/UnmodifiableSortedMap.java.UnmodifiableSortedMap.[SortedMap<K, V>]headMap(K)", "src/main/java/org/apache/commons/collections4/map/UnmodifiableSortedMap.java.UnmodifiableSortedMap.[Set<K>]keySet()", "src/main/java/org/apache/commons/collections4/map/UnmodifiableSortedMap.java.UnmodifiableSortedMap.[K]lastKey()", "src/main/java/org/apache/commons/collections4/map/UnmodifiableSortedMap.java.UnmodifiableSortedMap.[V]put(K,V)", "src/main/java/org/apache/commons/collections4/map/UnmodifiableSortedMap.java.UnmodifiableSortedMap.[void]putAll(Map<? extends K, ? extends V>)", "src/main/java/org/apache/commons/collections4/map/UnmodifiableSortedMap.java.UnmodifiableSortedMap.[void]readObject(ObjectInputStream)", "src/main/java/org/apache/commons/collections4/map/UnmodifiableSortedMap.java.UnmodifiableSortedMap.[V]remove(Object)", "src/main/java/org/apache/commons/collections4/map/UnmodifiableSortedMap.java.UnmodifiableSortedMap.[SortedMap<K, V>]subMap(K,K)", "src/main/java/org/apache/commons/collections4/map/UnmodifiableSortedMap.java.UnmodifiableSortedMap.[SortedMap<K, V>]tailMap(K)", "src/main/java/org/apache/commons/collections4/map/UnmodifiableSortedMap.java.UnmodifiableSortedMap.[Collection<V>]values()", "src/main/java/org/apache/commons/collections4/map/UnmodifiableSortedMap.java.UnmodifiableSortedMap.[void]writeObject(ObjectOutputStream)"], "overrides": null, "attributes": [], "class_docstring": "\nDecorates another {@code SortedMap} to ensure it can't be altered.\n<p>\nThis class is Serializable from Commons Collections 3.1.\n</p>\n<p>\nAttempts to modify it will result in an UnsupportedOperationException.\n</p>\n\n@param <K> the type of the keys in this map\n@param <V> the type of the values in this map\n@since 3.0\n", "original_string": "public final class UnmodifiableSortedMap<K, V>\n        extends AbstractSortedMapDecorator<K, V>\n        implements Unmodifiable, Serializable {\n\n    /** Serialization version */\n    private static final long serialVersionUID = 5805344239827376360L;\n\n    /**\n     * Factory method to create an unmodifiable sorted map.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param map  the map to decorate, must not be null\n     * @return a new unmodifiable sorted map\n     * @throws NullPointerException if map is null\n     * @since 4.0\n     */\n    public static <K, V> SortedMap<K, V> unmodifiableSortedMap(final SortedMap<K, ? extends V> map) {\n        if (map instanceof Unmodifiable) {\n            @SuppressWarnings(\"unchecked\") // safe to upcast\n            final SortedMap<K, V> tmpMap = (SortedMap<K, V>) map;\n            return tmpMap;\n        }\n        return new UnmodifiableSortedMap<>(map);\n    }\n\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param map  the map to decorate, must not be null\n     * @throws NullPointerException if map is null\n     */\n    @SuppressWarnings(\"unchecked\") // safe to upcast\n    private UnmodifiableSortedMap(final SortedMap<K, ? extends V> map) {\n        super((SortedMap<K, V>) map);\n    }\n\n    @Override\n    public void clear() {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public Comparator<? super K> comparator() {\n        return decorated().comparator();\n    }\n\n    @Override\n    public Set<Map.Entry<K, V>> entrySet() {\n        return UnmodifiableEntrySet.unmodifiableEntrySet(super.entrySet());\n    }\n\n    @Override\n    public K firstKey() {\n        return decorated().firstKey();\n    }\n\n    @Override\n    public SortedMap<K, V> headMap(final K toKey) {\n        return new UnmodifiableSortedMap<>(decorated().headMap(toKey));\n    }\n\n    @Override\n    public Set<K> keySet() {\n        return UnmodifiableSet.unmodifiableSet(super.keySet());\n    }\n\n    @Override\n    public K lastKey() {\n        return decorated().lastKey();\n    }\n\n    @Override\n    public V put(final K key, final V value) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public void putAll(final Map<? extends K, ? extends V> mapToCopy) {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * Deserializes the map in using a custom routine.\n     *\n     * @param in  the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded\n     * @since 3.1\n     */\n    @SuppressWarnings(\"unchecked\")\n    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        map = (Map<K, V>) in.readObject();\n    }\n\n    @Override\n    public V remove(final Object key) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public SortedMap<K, V> subMap(final K fromKey, final K toKey) {\n        return new UnmodifiableSortedMap<>(decorated().subMap(fromKey, toKey));\n    }\n\n    @Override\n    public SortedMap<K, V> tailMap(final K fromKey) {\n        return new UnmodifiableSortedMap<>(decorated().tailMap(fromKey));\n    }\n\n    @Override\n    public Collection<V> values() {\n        return UnmodifiableCollection.unmodifiableCollection(super.values());\n    }\n\n    /**\n     * Serializes this object to an ObjectOutputStream.\n     *\n     * @param out the target ObjectOutputStream.\n     * @throws IOException thrown when an I/O errors occur writing to the target stream.\n     * @since 3.1\n     */\n    private void writeObject(final ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        out.writeObject(map);\n    }\n\n}", "super_interfaces": ["Unmodifiable", "Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 5805344239827376360L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 5805344239827376360L", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/map/AbstractHashedMap.java.AbstractHashedMap", "name": "AbstractHashedMap", "file_path": "src/main/java/org/apache/commons/collections4/map/AbstractHashedMap.java", "superclasses": "", "methods": ["[]AbstractHashedMap()", "[]AbstractHashedMap(int)", "[]AbstractHashedMap(int,float)", "[]AbstractHashedMap(int,float,int)", "[]AbstractHashedMap(Map<? extends K, ? extends V>)", "[void]addEntry(HashEntry<K, V>,int)", "[void]addMapping(int,int,K,V)", "[int]calculateNewCapacity(int)", "[int]calculateThreshold(int,float)", "[void]checkCapacity()", "[void]clear()", "[AbstractHashedMap<K, V>]clone()", "[boolean]containsKey(Object)", "[boolean]containsValue(Object)", "[Object]convertKey(Object)", "[HashEntry<K, V>]createEntry(HashEntry<K, V>,int,K,V)", "[Iterator<Map.Entry<K, V>>]createEntrySetIterator()", "[Iterator<K>]createKeySetIterator()", "[Iterator<V>]createValuesIterator()", "[void]destroyEntry(HashEntry<K, V>)", "[void]doReadObject(ObjectInputStream)", "[void]doWriteObject(ObjectOutputStream)", "[void]ensureCapacity(int)", "[int]entryHashCode(HashEntry<K, V>)", "[K]entryKey(HashEntry<K, V>)", "[HashEntry<K, V>]entryNext(HashEntry<K, V>)", "[Set<Map.Entry<K, V>>]entrySet()", "[V]entryValue(HashEntry<K, V>)", "[boolean]equals(Object)", "[V]get(Object)", "[HashEntry<K, V>]getEntry(Object)", "[int]hash(Object)", "[int]hashCode()", "[int]hashIndex(int,int)", "[void]init()", "[boolean]isEmpty()", "[boolean]isEqualKey(Object,Object)", "[boolean]isEqualValue(Object,Object)", "[Set<K>]keySet()", "[MapIterator<K, V>]mapIterator()", "[V]put(K,V)", "[void]putAll(Map<? extends K, ? extends V>)", "[V]remove(Object)", "[void]removeEntry(HashEntry<K, V>,int,HashEntry<K, V>)", "[void]removeMapping(HashEntry<K, V>,int,HashEntry<K, V>)", "[void]reuseEntry(HashEntry<K, V>,int,int,K,V)", "[int]size()", "[String]toString()", "[void]updateEntry(HashEntry<K, V>,V)", "[Collection<V>]values()"], "method_uris": ["src/main/java/org/apache/commons/collections4/map/AbstractHashedMap.java.AbstractHashedMap.[]AbstractHashedMap()", "src/main/java/org/apache/commons/collections4/map/AbstractHashedMap.java.AbstractHashedMap.[]AbstractHashedMap(int)", "src/main/java/org/apache/commons/collections4/map/AbstractHashedMap.java.AbstractHashedMap.[]AbstractHashedMap(int,float)", "src/main/java/org/apache/commons/collections4/map/AbstractHashedMap.java.AbstractHashedMap.[]AbstractHashedMap(int,float,int)", "src/main/java/org/apache/commons/collections4/map/AbstractHashedMap.java.AbstractHashedMap.[]AbstractHashedMap(Map<? extends K, ? extends V>)", "src/main/java/org/apache/commons/collections4/map/AbstractHashedMap.java.AbstractHashedMap.[void]addEntry(HashEntry<K, V>,int)", "src/main/java/org/apache/commons/collections4/map/AbstractHashedMap.java.AbstractHashedMap.[void]addMapping(int,int,K,V)", "src/main/java/org/apache/commons/collections4/map/AbstractHashedMap.java.AbstractHashedMap.[int]calculateNewCapacity(int)", "src/main/java/org/apache/commons/collections4/map/AbstractHashedMap.java.AbstractHashedMap.[int]calculateThreshold(int,float)", "src/main/java/org/apache/commons/collections4/map/AbstractHashedMap.java.AbstractHashedMap.[void]checkCapacity()", "src/main/java/org/apache/commons/collections4/map/AbstractHashedMap.java.AbstractHashedMap.[void]clear()", "src/main/java/org/apache/commons/collections4/map/AbstractHashedMap.java.AbstractHashedMap.[AbstractHashedMap<K, V>]clone()", "src/main/java/org/apache/commons/collections4/map/AbstractHashedMap.java.AbstractHashedMap.[boolean]containsKey(Object)", "src/main/java/org/apache/commons/collections4/map/AbstractHashedMap.java.AbstractHashedMap.[boolean]containsValue(Object)", "src/main/java/org/apache/commons/collections4/map/AbstractHashedMap.java.AbstractHashedMap.[Object]convertKey(Object)", "src/main/java/org/apache/commons/collections4/map/AbstractHashedMap.java.AbstractHashedMap.[HashEntry<K, V>]createEntry(HashEntry<K, V>,int,K,V)", "src/main/java/org/apache/commons/collections4/map/AbstractHashedMap.java.AbstractHashedMap.[Iterator<Map.Entry<K, V>>]createEntrySetIterator()", "src/main/java/org/apache/commons/collections4/map/AbstractHashedMap.java.AbstractHashedMap.[Iterator<K>]createKeySetIterator()", "src/main/java/org/apache/commons/collections4/map/AbstractHashedMap.java.AbstractHashedMap.[Iterator<V>]createValuesIterator()", "src/main/java/org/apache/commons/collections4/map/AbstractHashedMap.java.AbstractHashedMap.[void]destroyEntry(HashEntry<K, V>)", "src/main/java/org/apache/commons/collections4/map/AbstractHashedMap.java.AbstractHashedMap.[void]doReadObject(ObjectInputStream)", "src/main/java/org/apache/commons/collections4/map/AbstractHashedMap.java.AbstractHashedMap.[void]doWriteObject(ObjectOutputStream)", "src/main/java/org/apache/commons/collections4/map/AbstractHashedMap.java.AbstractHashedMap.[void]ensureCapacity(int)", "src/main/java/org/apache/commons/collections4/map/AbstractHashedMap.java.AbstractHashedMap.[int]entryHashCode(HashEntry<K, V>)", "src/main/java/org/apache/commons/collections4/map/AbstractHashedMap.java.AbstractHashedMap.[K]entryKey(HashEntry<K, V>)", "src/main/java/org/apache/commons/collections4/map/AbstractHashedMap.java.AbstractHashedMap.[HashEntry<K, V>]entryNext(HashEntry<K, V>)", "src/main/java/org/apache/commons/collections4/map/AbstractHashedMap.java.AbstractHashedMap.[Set<Map.Entry<K, V>>]entrySet()", "src/main/java/org/apache/commons/collections4/map/AbstractHashedMap.java.AbstractHashedMap.[V]entryValue(HashEntry<K, V>)", "src/main/java/org/apache/commons/collections4/map/AbstractHashedMap.java.AbstractHashedMap.[boolean]equals(Object)", "src/main/java/org/apache/commons/collections4/map/AbstractHashedMap.java.AbstractHashedMap.[V]get(Object)", "src/main/java/org/apache/commons/collections4/map/AbstractHashedMap.java.AbstractHashedMap.[HashEntry<K, V>]getEntry(Object)", "src/main/java/org/apache/commons/collections4/map/AbstractHashedMap.java.AbstractHashedMap.[int]hash(Object)", "src/main/java/org/apache/commons/collections4/map/AbstractHashedMap.java.AbstractHashedMap.[int]hashCode()", "src/main/java/org/apache/commons/collections4/map/AbstractHashedMap.java.AbstractHashedMap.[int]hashIndex(int,int)", "src/main/java/org/apache/commons/collections4/map/AbstractHashedMap.java.AbstractHashedMap.[void]init()", "src/main/java/org/apache/commons/collections4/map/AbstractHashedMap.java.AbstractHashedMap.[boolean]isEmpty()", "src/main/java/org/apache/commons/collections4/map/AbstractHashedMap.java.AbstractHashedMap.[boolean]isEqualKey(Object,Object)", "src/main/java/org/apache/commons/collections4/map/AbstractHashedMap.java.AbstractHashedMap.[boolean]isEqualValue(Object,Object)", "src/main/java/org/apache/commons/collections4/map/AbstractHashedMap.java.AbstractHashedMap.[Set<K>]keySet()", "src/main/java/org/apache/commons/collections4/map/AbstractHashedMap.java.AbstractHashedMap.[MapIterator<K, V>]mapIterator()", "src/main/java/org/apache/commons/collections4/map/AbstractHashedMap.java.AbstractHashedMap.[V]put(K,V)", "src/main/java/org/apache/commons/collections4/map/AbstractHashedMap.java.AbstractHashedMap.[void]putAll(Map<? extends K, ? extends V>)", "src/main/java/org/apache/commons/collections4/map/AbstractHashedMap.java.AbstractHashedMap.[V]remove(Object)", "src/main/java/org/apache/commons/collections4/map/AbstractHashedMap.java.AbstractHashedMap.[void]removeEntry(HashEntry<K, V>,int,HashEntry<K, V>)", "src/main/java/org/apache/commons/collections4/map/AbstractHashedMap.java.AbstractHashedMap.[void]removeMapping(HashEntry<K, V>,int,HashEntry<K, V>)", "src/main/java/org/apache/commons/collections4/map/AbstractHashedMap.java.AbstractHashedMap.[void]reuseEntry(HashEntry<K, V>,int,int,K,V)", "src/main/java/org/apache/commons/collections4/map/AbstractHashedMap.java.AbstractHashedMap.[int]size()", "src/main/java/org/apache/commons/collections4/map/AbstractHashedMap.java.AbstractHashedMap.[String]toString()", "src/main/java/org/apache/commons/collections4/map/AbstractHashedMap.java.AbstractHashedMap.[void]updateEntry(HashEntry<K, V>,V)", "src/main/java/org/apache/commons/collections4/map/AbstractHashedMap.java.AbstractHashedMap.[Collection<V>]values()"], "overrides": null, "attributes": [{"original_string": "    protected static class EntrySet<K, V> extends AbstractSet<Map.Entry<K, V>> {\n\n        /** The parent map */\n        private final AbstractHashedMap<K, V> parent;\n\n        /**\n         * Constructs a new instance.\n         *\n         * @param parent The parent map.\n         */\n        protected EntrySet(final AbstractHashedMap<K, V> parent) {\n            this.parent = parent;\n        }\n\n        @Override\n        public void clear() {\n            parent.clear();\n        }\n\n        @Override\n        public boolean contains(final Object entry) {\n            if (entry instanceof Map.Entry) {\n                final Map.Entry<?, ?> e = (Map.Entry<?, ?>) entry;\n                final Entry<K, V> match = parent.getEntry(e.getKey());\n                return match != null && match.equals(e);\n            }\n            return false;\n        }\n\n        @Override\n        public Iterator<Map.Entry<K, V>> iterator() {\n            return parent.createEntrySetIterator();\n        }\n\n        @Override\n        public boolean remove(final Object obj) {\n            if (!(obj instanceof Map.Entry)) {\n                return false;\n            }\n            if (!contains(obj)) {\n                return false;\n            }\n            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n            parent.remove(entry.getKey());\n            return true;\n        }\n\n        @Override\n        public int size() {\n            return parent.size();\n        }\n    }", "definition": "    protected static class EntrySet<K, V> extends AbstractSet<Map.Entry<K, V>>", "class_docstring": "\nEntrySet implementation.\n\n@param <K> the type of the keys in the map\n@param <V> the type of the values in the map\n", "name": "EntrySet", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "protected static", "marker_annotations": [], "non_marker_annotations": ["protected", "static"], "comments": [], "fields": [{"attribute_expression": "private final AbstractHashedMap<K, V> parent;", "docstring": " The parent map", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "AbstractHashedMap<K, V>", "name": "parent", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        protected EntrySet(final AbstractHashedMap<K, V> parent) {\n            this.parent = parent;\n        }", "docstring": "\nConstructs a new instance.\n\n@param parent The parent map.\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "name": "EntrySet", "params": [{"name": "parent", "type": "AbstractHashedMap<K, V>"}], "body": "                                                                 {\n            this.parent = parent;\n        }", "signature": "protected EntrySet(final AbstractHashedMap<K, V> parent)"}, {"syntax_pass": true, "original_string": "        @Override\n        public void clear() {\n            parent.clear();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "clear", "params": [], "body": "                            {\n            parent.clear();\n        }", "signature": "@Override\n        public void clear()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean contains(final Object entry) {\n            if (entry instanceof Map.Entry) {\n                final Map.Entry<?, ?> e = (Map.Entry<?, ?>) entry;\n                final Entry<K, V> match = parent.getEntry(e.getKey());\n                return match != null && match.equals(e);\n            }\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "contains", "params": [{"name": "entry", "type": "Object"}], "body": "                                                    {\n            if (entry instanceof Map.Entry) {\n                final Map.Entry<?, ?> e = (Map.Entry<?, ?>) entry;\n                final Entry<K, V> match = parent.getEntry(e.getKey());\n                return match != null && match.equals(e);\n            }\n            return false;\n        }", "signature": "@Override\n        public boolean contains(final Object entry)"}, {"syntax_pass": true, "original_string": "        @Override\n        public Iterator<Map.Entry<K, V>> iterator() {\n            return parent.createEntrySetIterator();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Iterator<Map.Entry<K, V>>", "classes": []}, "name": "iterator", "params": [], "body": "                                                    {\n            return parent.createEntrySetIterator();\n        }", "signature": "@Override\n        public Iterator<Map.Entry<K, V>> iterator()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean remove(final Object obj) {\n            if (!(obj instanceof Map.Entry)) {\n                return false;\n            }\n            if (!contains(obj)) {\n                return false;\n            }\n            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n            parent.remove(entry.getKey());\n            return true;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "remove", "params": [{"name": "obj", "type": "Object"}], "body": "                                                {\n            if (!(obj instanceof Map.Entry)) {\n                return false;\n            }\n            if (!contains(obj)) {\n                return false;\n            }\n            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n            parent.remove(entry.getKey());\n            return true;\n        }", "signature": "@Override\n        public boolean remove(final Object obj)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int size() {\n            return parent.size();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "size", "params": [], "body": "                          {\n            return parent.size();\n        }", "signature": "@Override\n        public int size()"}]}, {"original_string": "    protected static class EntrySetIterator<K, V> extends HashIterator<K, V> implements Iterator<Map.Entry<K, V>> {\n\n        /**\n         * Constructs a new instance.\n         *\n         * @param parent The parent map.\n         */\n        protected EntrySetIterator(final AbstractHashedMap<K, V> parent) {\n            super(parent);\n        }\n\n        @Override\n        public Map.Entry<K, V> next() {\n            return super.nextEntry();\n        }\n    }", "definition": "    protected static class EntrySetIterator<K, V> extends HashIterator<K, V> implements Iterator<Map.Entry<K, V>>", "class_docstring": "\nEntrySet iterator.\n\n@param <K> the type of the keys in the map\n@param <V> the type of the values in the map\n", "name": "EntrySetIterator", "super_interfaces": ["Iterator<Map.Entry<K, V>>"], "superclasses": "", "attributes": {"modifiers": "protected static", "marker_annotations": [], "non_marker_annotations": ["protected", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        protected EntrySetIterator(final AbstractHashedMap<K, V> parent) {\n            super(parent);\n        }", "docstring": "\nConstructs a new instance.\n\n@param parent The parent map.\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "name": "EntrySetIterator", "params": [{"name": "parent", "type": "AbstractHashedMap<K, V>"}], "body": "                                                                         {\n            super(parent);\n        }", "signature": "protected EntrySetIterator(final AbstractHashedMap<K, V> parent)"}, {"syntax_pass": true, "original_string": "        @Override\n        public Map.Entry<K, V> next() {\n            return super.nextEntry();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map.Entry<K, V>", "classes": []}, "name": "next", "params": [], "body": "                                      {\n            return super.nextEntry();\n        }", "signature": "@Override\n        public Map.Entry<K, V> next()"}]}, {"original_string": "    protected static class HashEntry<K, V> implements Map.Entry<K, V>, KeyValue<K, V> {\n\n        /** The next entry in the hash chain */\n        protected HashEntry<K, V> next;\n\n        /** The hash code of the key */\n        protected int hashCode;\n\n        /** The key */\n        protected Object key;\n\n        /** The value */\n        protected Object value;\n\n        /**\n         * Constructs a new instance.\n         *\n         * @param next next.\n         * @param hashCode hash code.\n         * @param key key.\n         * @param value value.\n         */\n        protected HashEntry(final HashEntry<K, V> next, final int hashCode, final Object key, final V value) {\n            this.next = next;\n            this.hashCode = hashCode;\n            this.key = key;\n            this.value = value;\n        }\n\n        @Override\n        public boolean equals(final Object obj) {\n            if (obj == this) {\n                return true;\n            }\n            if (!(obj instanceof Map.Entry)) {\n                return false;\n            }\n            final Map.Entry<?, ?> other = (Map.Entry<?, ?>) obj;\n            return\n                (getKey() == null ? other.getKey() == null : getKey().equals(other.getKey())) &&\n                (getValue() == null ? other.getValue() == null : getValue().equals(other.getValue()));\n        }\n\n        @Override\n        @SuppressWarnings(\"unchecked\")\n        public K getKey() {\n            if (key == NULL) {\n                return null;\n            }\n            return (K) key;\n        }\n\n        @Override\n        @SuppressWarnings(\"unchecked\")\n        public V getValue() {\n            return (V) value;\n        }\n\n        @Override\n        public int hashCode() {\n            return (getKey() == null ? 0 : getKey().hashCode()) ^\n                   (getValue() == null ? 0 : getValue().hashCode());\n        }\n\n        @Override\n        @SuppressWarnings(\"unchecked\")\n        public V setValue(final V value) {\n            final Object old = this.value;\n            this.value = value;\n            return (V) old;\n        }\n\n        @Override\n        public String toString() {\n            return new StringBuilder().append(getKey()).append('=').append(getValue()).toString();\n        }\n    }", "definition": "    protected static class HashEntry<K, V> implements Map.Entry<K, V>, KeyValue<K, V>", "class_docstring": "\nHashEntry used to store the data.\n<p>\nIf you subclass {@code AbstractHashedMap} but not {@code HashEntry}\nthen you will not be able to access the protected fields.\nThe {@code entryXxx()} methods on {@code AbstractHashedMap} exist\nto provide the necessary access.\n</p>\n\n@param <K> the type of the keys\n@param <V> the type of the values\n", "name": "HashEntry", "super_interfaces": ["Map.Entry<K, V>", "KeyValue<K, V>"], "superclasses": "", "attributes": {"modifiers": "protected static", "marker_annotations": [], "non_marker_annotations": ["protected", "static"], "comments": [], "fields": [{"attribute_expression": "protected HashEntry<K, V> next;", "docstring": " The next entry in the hash chain", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "HashEntry<K, V>", "name": "next", "syntax_pass": true}, {"attribute_expression": "protected int hashCode;", "docstring": " The hash code of the key", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "int", "name": "hashCode", "syntax_pass": true}, {"attribute_expression": "protected Object key;", "docstring": " The key", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Object", "name": "key", "syntax_pass": true}, {"attribute_expression": "protected Object value;", "docstring": " The value", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Object", "name": "value", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        protected HashEntry(final HashEntry<K, V> next, final int hashCode, final Object key, final V value) {\n            this.next = next;\n            this.hashCode = hashCode;\n            this.key = key;\n            this.value = value;\n        }", "docstring": "\nConstructs a new instance.\n\n@param next next.\n@param hashCode hash code.\n@param key key.\n@param value value.\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "name": "HashEntry", "params": [{"name": "next", "type": "HashEntry<K, V>"}, {"name": "hashCode", "type": "int"}, {"name": "key", "type": "Object"}, {"name": "value", "type": "V"}], "body": "                                                                                                             {\n            this.next = next;\n            this.hashCode = hashCode;\n            this.key = key;\n            this.value = value;\n        }", "signature": "protected HashEntry(final HashEntry<K, V> next, final int hashCode, final Object key, final V value)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean equals(final Object obj) {\n            if (obj == this) {\n                return true;\n            }\n            if (!(obj instanceof Map.Entry)) {\n                return false;\n            }\n            final Map.Entry<?, ?> other = (Map.Entry<?, ?>) obj;\n            return\n                (getKey() == null ? other.getKey() == null : getKey().equals(other.getKey())) &&\n                (getValue() == null ? other.getValue() == null : getValue().equals(other.getValue()));\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "obj", "type": "Object"}], "body": "                                                {\n            if (obj == this) {\n                return true;\n            }\n            if (!(obj instanceof Map.Entry)) {\n                return false;\n            }\n            final Map.Entry<?, ?> other = (Map.Entry<?, ?>) obj;\n            return\n                (getKey() == null ? other.getKey() == null : getKey().equals(other.getKey())) &&\n                (getValue() == null ? other.getValue() == null : getValue().equals(other.getValue()));\n        }", "signature": "@Override\n        public boolean equals(final Object obj)"}, {"syntax_pass": true, "original_string": "        @Override\n        @SuppressWarnings(\"unchecked\")\n        public K getKey() {\n            if (key == NULL) {\n                return null;\n            }\n            return (K) key;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        @SuppressWarnings(\"unchecked\")\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "K", "classes": []}, "name": "getKey", "params": [], "body": "                          {\n            if (key == NULL) {\n                return null;\n            }\n            return (K) key;\n        }", "signature": "@Override\n        @SuppressWarnings(\"unchecked\")\n        public K getKey()"}, {"syntax_pass": true, "original_string": "        @Override\n        @SuppressWarnings(\"unchecked\")\n        public V getValue() {\n            return (V) value;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        @SuppressWarnings(\"unchecked\")\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "V", "classes": []}, "name": "getValue", "params": [], "body": "                            {\n            return (V) value;\n        }", "signature": "@Override\n        @SuppressWarnings(\"unchecked\")\n        public V getValue()"}, {"syntax_pass": true, "original_string": "        @Override\n        public int hashCode() {\n            return (getKey() == null ? 0 : getKey().hashCode()) ^\n                   (getValue() == null ? 0 : getValue().hashCode());\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                              {\n            return (getKey() == null ? 0 : getKey().hashCode()) ^\n                   (getValue() == null ? 0 : getValue().hashCode());\n        }", "signature": "@Override\n        public int hashCode()"}, {"syntax_pass": true, "original_string": "        @Override\n        @SuppressWarnings(\"unchecked\")\n        public V setValue(final V value) {\n            final Object old = this.value;\n            this.value = value;\n            return (V) old;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        @SuppressWarnings(\"unchecked\")\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "V", "classes": []}, "name": "setValue", "params": [{"name": "value", "type": "V"}], "body": "                                         {\n            final Object old = this.value;\n            this.value = value;\n            return (V) old;\n        }", "signature": "@Override\n        @SuppressWarnings(\"unchecked\")\n        public V setValue(final V value)"}, {"syntax_pass": true, "original_string": "        @Override\n        public String toString() {\n            return new StringBuilder().append(getKey()).append('=').append(getValue()).toString();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                 {\n            return new StringBuilder().append(getKey()).append('=').append(getValue()).toString();\n        }", "signature": "@Override\n        public String toString()"}]}, {"original_string": "    protected abstract static class HashIterator<K, V> {\n\n        /** The parent map */\n        private final AbstractHashedMap<K, V> parent;\n\n        /** The current index into the array of buckets */\n        private int hashIndex;\n\n        /** The last returned entry */\n        private HashEntry<K, V> last;\n\n        /** The next entry */\n        private HashEntry<K, V> next;\n\n        /** The modification count expected */\n        private int expectedModCount;\n\n        /**\n         * Constructs a new instance.\n         *\n         * @param parent The parent AbstractHashedMap.\n         */\n        protected HashIterator(final AbstractHashedMap<K, V> parent) {\n            this.parent = parent;\n            final HashEntry<K, V>[] data = parent.data;\n            int i = data.length;\n            HashEntry<K, V> next = null;\n            while (i > 0 && next == null) {\n                next = data[--i];\n            }\n            this.next = next;\n            this.hashIndex = i;\n            this.expectedModCount = parent.modCount;\n        }\n\n        /**\n         * Gets the current entry.\n         *\n         * @return the current entry.\n         */\n        protected HashEntry<K, V> currentEntry() {\n            return last;\n        }\n\n        /**\n         * Tests whether there is a next entry.\n         *\n         * @return whether there is a next entry.\n         */\n        public boolean hasNext() {\n            return next != null;\n        }\n\n        /**\n         * Gets the next entry.\n         *\n         * @return the next entry.\n         */\n        protected HashEntry<K, V> nextEntry() {\n            if (parent.modCount != expectedModCount) {\n                throw new ConcurrentModificationException();\n            }\n            final HashEntry<K, V> newCurrent = next;\n            if (newCurrent == null)  {\n                throw new NoSuchElementException(NO_NEXT_ENTRY);\n            }\n            final HashEntry<K, V>[] data = parent.data;\n            int i = hashIndex;\n            HashEntry<K, V> n = newCurrent.next;\n            while (n == null && i > 0) {\n                n = data[--i];\n            }\n            next = n;\n            hashIndex = i;\n            last = newCurrent;\n            return newCurrent;\n        }\n\n        /**\n         * Removes the current element.\n         */\n        public void remove() {\n            if (last == null) {\n                throw new IllegalStateException(REMOVE_INVALID);\n            }\n            if (parent.modCount != expectedModCount) {\n                throw new ConcurrentModificationException();\n            }\n            parent.remove(last.getKey());\n            last = null;\n            expectedModCount = parent.modCount;\n        }\n\n        @Override\n        public String toString() {\n            if (last != null) {\n                return \"Iterator[\" + last.getKey() + \"=\" + last.getValue() + \"]\";\n            }\n            return \"Iterator[]\";\n        }\n    }", "definition": "    protected abstract static class HashIterator<K, V>", "class_docstring": "\nBase Iterator.\n\n@param <K> the type of the keys in the map\n@param <V> the type of the values in the map\n", "name": "HashIterator", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "protected abstract static", "marker_annotations": [], "non_marker_annotations": ["protected", "abstract", "static"], "comments": [], "fields": [{"attribute_expression": "private final AbstractHashedMap<K, V> parent;", "docstring": " The parent map", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "AbstractHashedMap<K, V>", "name": "parent", "syntax_pass": true}, {"attribute_expression": "private int hashIndex;", "docstring": " The current index into the array of buckets", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "hashIndex", "syntax_pass": true}, {"attribute_expression": "private HashEntry<K, V> last;", "docstring": " The last returned entry", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "HashEntry<K, V>", "name": "last", "syntax_pass": true}, {"attribute_expression": "private HashEntry<K, V> next;", "docstring": " The next entry", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "HashEntry<K, V>", "name": "next", "syntax_pass": true}, {"attribute_expression": "private int expectedModCount;", "docstring": " The modification count expected", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "expectedModCount", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        protected HashIterator(final AbstractHashedMap<K, V> parent) {\n            this.parent = parent;\n            final HashEntry<K, V>[] data = parent.data;\n            int i = data.length;\n            HashEntry<K, V> next = null;\n            while (i > 0 && next == null) {\n                next = data[--i];\n            }\n            this.next = next;\n            this.hashIndex = i;\n            this.expectedModCount = parent.modCount;\n        }", "docstring": "\nConstructs a new instance.\n\n@param parent The parent AbstractHashedMap.\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "name": "HashIterator", "params": [{"name": "parent", "type": "AbstractHashedMap<K, V>"}], "body": "                                                                     {\n            this.parent = parent;\n            final HashEntry<K, V>[] data = parent.data;\n            int i = data.length;\n            HashEntry<K, V> next = null;\n            while (i > 0 && next == null) {\n                next = data[--i];\n            }\n            this.next = next;\n            this.hashIndex = i;\n            this.expectedModCount = parent.modCount;\n        }", "signature": "protected HashIterator(final AbstractHashedMap<K, V> parent)"}, {"syntax_pass": true, "original_string": "        protected HashEntry<K, V> currentEntry() {\n            return last;\n        }", "docstring": "\nGets the current entry.\n\n@return the current entry.\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "HashEntry<K, V>", "classes": []}, "name": "currentEntry", "params": [], "body": "                                                 {\n            return last;\n        }", "signature": "protected HashEntry<K, V> currentEntry()"}, {"syntax_pass": true, "original_string": "        public boolean hasNext() {\n            return next != null;\n        }", "docstring": "\nTests whether there is a next entry.\n\n@return whether there is a next entry.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasNext", "params": [], "body": "                                 {\n            return next != null;\n        }", "signature": "public boolean hasNext()"}, {"syntax_pass": true, "original_string": "        protected HashEntry<K, V> nextEntry() {\n            if (parent.modCount != expectedModCount) {\n                throw new ConcurrentModificationException();\n            }\n            final HashEntry<K, V> newCurrent = next;\n            if (newCurrent == null)  {\n                throw new NoSuchElementException(NO_NEXT_ENTRY);\n            }\n            final HashEntry<K, V>[] data = parent.data;\n            int i = hashIndex;\n            HashEntry<K, V> n = newCurrent.next;\n            while (n == null && i > 0) {\n                n = data[--i];\n            }\n            next = n;\n            hashIndex = i;\n            last = newCurrent;\n            return newCurrent;\n        }", "docstring": "\nGets the next entry.\n\n@return the next entry.\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "HashEntry<K, V>", "classes": []}, "name": "nextEntry", "params": [], "body": "                                              {\n            if (parent.modCount != expectedModCount) {\n                throw new ConcurrentModificationException();\n            }\n            final HashEntry<K, V> newCurrent = next;\n            if (newCurrent == null)  {\n                throw new NoSuchElementException(NO_NEXT_ENTRY);\n            }\n            final HashEntry<K, V>[] data = parent.data;\n            int i = hashIndex;\n            HashEntry<K, V> n = newCurrent.next;\n            while (n == null && i > 0) {\n                n = data[--i];\n            }\n            next = n;\n            hashIndex = i;\n            last = newCurrent;\n            return newCurrent;\n        }", "signature": "protected HashEntry<K, V> nextEntry()"}, {"syntax_pass": true, "original_string": "        public void remove() {\n            if (last == null) {\n                throw new IllegalStateException(REMOVE_INVALID);\n            }\n            if (parent.modCount != expectedModCount) {\n                throw new ConcurrentModificationException();\n            }\n            parent.remove(last.getKey());\n            last = null;\n            expectedModCount = parent.modCount;\n        }", "docstring": "\nRemoves the current element.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "remove", "params": [], "body": "                             {\n            if (last == null) {\n                throw new IllegalStateException(REMOVE_INVALID);\n            }\n            if (parent.modCount != expectedModCount) {\n                throw new ConcurrentModificationException();\n            }\n            parent.remove(last.getKey());\n            last = null;\n            expectedModCount = parent.modCount;\n        }", "signature": "public void remove()"}, {"syntax_pass": true, "original_string": "        @Override\n        public String toString() {\n            if (last != null) {\n                return \"Iterator[\" + last.getKey() + \"=\" + last.getValue() + \"]\";\n            }\n            return \"Iterator[]\";\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                 {\n            if (last != null) {\n                return \"Iterator[\" + last.getKey() + \"=\" + last.getValue() + \"]\";\n            }\n            return \"Iterator[]\";\n        }", "signature": "@Override\n        public String toString()"}]}, {"original_string": "    protected static class HashMapIterator<K, V> extends HashIterator<K, V> implements MapIterator<K, V> {\n\n        /**\n         * Constructs a new instance.\n         *\n         * @param parent The parent AbstractHashedMap.\n         */\n        protected HashMapIterator(final AbstractHashedMap<K, V> parent) {\n            super(parent);\n        }\n\n        @Override\n        public K getKey() {\n            final HashEntry<K, V> current = currentEntry();\n            if (current == null) {\n                throw new IllegalStateException(GETKEY_INVALID);\n            }\n            return current.getKey();\n        }\n\n        @Override\n        public V getValue() {\n            final HashEntry<K, V> current = currentEntry();\n            if (current == null) {\n                throw new IllegalStateException(GETVALUE_INVALID);\n            }\n            return current.getValue();\n        }\n\n        @Override\n        public K next() {\n            return super.nextEntry().getKey();\n        }\n\n        @Override\n        public V setValue(final V value) {\n            final HashEntry<K, V> current = currentEntry();\n            if (current == null) {\n                throw new IllegalStateException(SETVALUE_INVALID);\n            }\n            return current.setValue(value);\n        }\n    }", "definition": "    protected static class HashMapIterator<K, V> extends HashIterator<K, V> implements MapIterator<K, V>", "class_docstring": "\nMapIterator implementation.\n\n@param <K> the type of the keys in the map\n@param <V> the type of the values in the map\n", "name": "HashMapIterator", "super_interfaces": ["MapIterator<K, V>"], "superclasses": "", "attributes": {"modifiers": "protected static", "marker_annotations": [], "non_marker_annotations": ["protected", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        protected HashMapIterator(final AbstractHashedMap<K, V> parent) {\n            super(parent);\n        }", "docstring": "\nConstructs a new instance.\n\n@param parent The parent AbstractHashedMap.\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "name": "HashMapIterator", "params": [{"name": "parent", "type": "AbstractHashedMap<K, V>"}], "body": "                                                                        {\n            super(parent);\n        }", "signature": "protected HashMapIterator(final AbstractHashedMap<K, V> parent)"}, {"syntax_pass": true, "original_string": "        @Override\n        public K getKey() {\n            final HashEntry<K, V> current = currentEntry();\n            if (current == null) {\n                throw new IllegalStateException(GETKEY_INVALID);\n            }\n            return current.getKey();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "K", "classes": []}, "name": "getKey", "params": [], "body": "                          {\n            final HashEntry<K, V> current = currentEntry();\n            if (current == null) {\n                throw new IllegalStateException(GETKEY_INVALID);\n            }\n            return current.getKey();\n        }", "signature": "@Override\n        public K getKey()"}, {"syntax_pass": true, "original_string": "        @Override\n        public V getValue() {\n            final HashEntry<K, V> current = currentEntry();\n            if (current == null) {\n                throw new IllegalStateException(GETVALUE_INVALID);\n            }\n            return current.getValue();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "getValue", "params": [], "body": "                            {\n            final HashEntry<K, V> current = currentEntry();\n            if (current == null) {\n                throw new IllegalStateException(GETVALUE_INVALID);\n            }\n            return current.getValue();\n        }", "signature": "@Override\n        public V getValue()"}, {"syntax_pass": true, "original_string": "        @Override\n        public K next() {\n            return super.nextEntry().getKey();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "K", "classes": []}, "name": "next", "params": [], "body": "                        {\n            return super.nextEntry().getKey();\n        }", "signature": "@Override\n        public K next()"}, {"syntax_pass": true, "original_string": "        @Override\n        public V setValue(final V value) {\n            final HashEntry<K, V> current = currentEntry();\n            if (current == null) {\n                throw new IllegalStateException(SETVALUE_INVALID);\n            }\n            return current.setValue(value);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "setValue", "params": [{"name": "value", "type": "V"}], "body": "                                         {\n            final HashEntry<K, V> current = currentEntry();\n            if (current == null) {\n                throw new IllegalStateException(SETVALUE_INVALID);\n            }\n            return current.setValue(value);\n        }", "signature": "@Override\n        public V setValue(final V value)"}]}, {"original_string": "    protected static class KeySet<K> extends AbstractSet<K> {\n\n        /** The parent map */\n        private final AbstractHashedMap<K, ?> parent;\n\n        /**\n         * Constructs a new instance.\n         *\n         * @param parent The parent AbstractHashedMap.\n         */\n        protected KeySet(final AbstractHashedMap<K, ?> parent) {\n            this.parent = parent;\n        }\n\n        @Override\n        public void clear() {\n            parent.clear();\n        }\n\n        @Override\n        public boolean contains(final Object key) {\n            return parent.containsKey(key);\n        }\n\n        @Override\n        public Iterator<K> iterator() {\n            return parent.createKeySetIterator();\n        }\n\n        @Override\n        public boolean remove(final Object key) {\n            final boolean result = parent.containsKey(key);\n            parent.remove(key);\n            return result;\n        }\n\n        @Override\n        public int size() {\n            return parent.size();\n        }\n    }", "definition": "    protected static class KeySet<K> extends AbstractSet<K>", "class_docstring": "\nKeySet implementation.\n\n@param <K> the type of elements maintained by this set\n", "name": "KeySet", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "protected static", "marker_annotations": [], "non_marker_annotations": ["protected", "static"], "comments": [], "fields": [{"attribute_expression": "private final AbstractHashedMap<K, ?> parent;", "docstring": " The parent map", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "AbstractHashedMap<K, ?>", "name": "parent", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        protected KeySet(final AbstractHashedMap<K, ?> parent) {\n            this.parent = parent;\n        }", "docstring": "\nConstructs a new instance.\n\n@param parent The parent AbstractHashedMap.\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "name": "KeySet", "params": [{"name": "parent", "type": "AbstractHashedMap<K, ?>"}], "body": "                                                               {\n            this.parent = parent;\n        }", "signature": "protected KeySet(final AbstractHashedMap<K, ?> parent)"}, {"syntax_pass": true, "original_string": "        @Override\n        public void clear() {\n            parent.clear();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "clear", "params": [], "body": "                            {\n            parent.clear();\n        }", "signature": "@Override\n        public void clear()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean contains(final Object key) {\n            return parent.containsKey(key);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "contains", "params": [{"name": "key", "type": "Object"}], "body": "                                                  {\n            return parent.containsKey(key);\n        }", "signature": "@Override\n        public boolean contains(final Object key)"}, {"syntax_pass": true, "original_string": "        @Override\n        public Iterator<K> iterator() {\n            return parent.createKeySetIterator();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Iterator<K>", "classes": []}, "name": "iterator", "params": [], "body": "                                      {\n            return parent.createKeySetIterator();\n        }", "signature": "@Override\n        public Iterator<K> iterator()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean remove(final Object key) {\n            final boolean result = parent.containsKey(key);\n            parent.remove(key);\n            return result;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "remove", "params": [{"name": "key", "type": "Object"}], "body": "                                                {\n            final boolean result = parent.containsKey(key);\n            parent.remove(key);\n            return result;\n        }", "signature": "@Override\n        public boolean remove(final Object key)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int size() {\n            return parent.size();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "size", "params": [], "body": "                          {\n            return parent.size();\n        }", "signature": "@Override\n        public int size()"}]}, {"original_string": "    protected static class KeySetIterator<K> extends HashIterator<K, Object> implements Iterator<K> {\n\n        /**\n         * Constructs a new instance.\n         *\n         * @param parent The parent AbstractHashedMap.\n         */\n        @SuppressWarnings(\"unchecked\")\n        protected KeySetIterator(final AbstractHashedMap<K, ?> parent) {\n            super((AbstractHashedMap<K, Object>) parent);\n        }\n\n        @Override\n        public K next() {\n            return super.nextEntry().getKey();\n        }\n    }", "definition": "    protected static class KeySetIterator<K> extends HashIterator<K, Object> implements Iterator<K>", "class_docstring": "\nKeySet iterator.\n\n@param <K> the type of elements maintained by this set\n", "name": "KeySetIterator", "super_interfaces": ["Iterator<K>"], "superclasses": "", "attributes": {"modifiers": "protected static", "marker_annotations": [], "non_marker_annotations": ["protected", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @SuppressWarnings(\"unchecked\")\n        protected KeySetIterator(final AbstractHashedMap<K, ?> parent) {\n            super((AbstractHashedMap<K, Object>) parent);\n        }", "docstring": "\nConstructs a new instance.\n\n@param parent The parent AbstractHashedMap.\n", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n        protected", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "protected"], "comments": [], "return_type": "", "classes": []}, "name": "KeySetIterator", "params": [{"name": "parent", "type": "AbstractHashedMap<K, ?>"}], "body": "                                                                       {\n            super((AbstractHashedMap<K, Object>) parent);\n        }", "signature": "@SuppressWarnings(\"unchecked\")\n        protected KeySetIterator(final AbstractHashedMap<K, ?> parent)"}, {"syntax_pass": true, "original_string": "        @Override\n        public K next() {\n            return super.nextEntry().getKey();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "K", "classes": []}, "name": "next", "params": [], "body": "                        {\n            return super.nextEntry().getKey();\n        }", "signature": "@Override\n        public K next()"}]}, {"original_string": "    protected static class Values<V> extends AbstractCollection<V> {\n\n        /** The parent map */\n        private final AbstractHashedMap<?, V> parent;\n\n        /**\n         * Constructs a new instance.\n         *\n         * @param parent The parent AbstractHashedMap.\n         */\n        protected Values(final AbstractHashedMap<?, V> parent) {\n            this.parent = parent;\n        }\n\n        @Override\n        public void clear() {\n            parent.clear();\n        }\n\n        @Override\n        public boolean contains(final Object value) {\n            return parent.containsValue(value);\n        }\n\n        @Override\n        public Iterator<V> iterator() {\n            return parent.createValuesIterator();\n        }\n\n        @Override\n        public int size() {\n            return parent.size();\n        }\n    }", "definition": "    protected static class Values<V> extends AbstractCollection<V>", "class_docstring": "\nValues implementation.\n\n@param <V> the type of elements maintained by this collection\n", "name": "Values", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "protected static", "marker_annotations": [], "non_marker_annotations": ["protected", "static"], "comments": [], "fields": [{"attribute_expression": "private final AbstractHashedMap<?, V> parent;", "docstring": " The parent map", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "AbstractHashedMap<?, V>", "name": "parent", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        protected Values(final AbstractHashedMap<?, V> parent) {\n            this.parent = parent;\n        }", "docstring": "\nConstructs a new instance.\n\n@param parent The parent AbstractHashedMap.\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "name": "Values", "params": [{"name": "parent", "type": "AbstractHashedMap<?, V>"}], "body": "                                                               {\n            this.parent = parent;\n        }", "signature": "protected Values(final AbstractHashedMap<?, V> parent)"}, {"syntax_pass": true, "original_string": "        @Override\n        public void clear() {\n            parent.clear();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "clear", "params": [], "body": "                            {\n            parent.clear();\n        }", "signature": "@Override\n        public void clear()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean contains(final Object value) {\n            return parent.containsValue(value);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "contains", "params": [{"name": "value", "type": "Object"}], "body": "                                                    {\n            return parent.containsValue(value);\n        }", "signature": "@Override\n        public boolean contains(final Object value)"}, {"syntax_pass": true, "original_string": "        @Override\n        public Iterator<V> iterator() {\n            return parent.createValuesIterator();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Iterator<V>", "classes": []}, "name": "iterator", "params": [], "body": "                                      {\n            return parent.createValuesIterator();\n        }", "signature": "@Override\n        public Iterator<V> iterator()"}, {"syntax_pass": true, "original_string": "        @Override\n        public int size() {\n            return parent.size();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "size", "params": [], "body": "                          {\n            return parent.size();\n        }", "signature": "@Override\n        public int size()"}]}, {"original_string": "    protected static class ValuesIterator<V> extends HashIterator<Object, V> implements Iterator<V> {\n\n        /**\n         * Constructs a new instance.\n         *\n         * @param parent The parent AbstractHashedMap.\n         */\n        @SuppressWarnings(\"unchecked\")\n        protected ValuesIterator(final AbstractHashedMap<?, V> parent) {\n            super((AbstractHashedMap<Object, V>) parent);\n        }\n\n        @Override\n        public V next() {\n            return super.nextEntry().getValue();\n        }\n    }", "definition": "    protected static class ValuesIterator<V> extends HashIterator<Object, V> implements Iterator<V>", "class_docstring": "\nValues iterator.\n\n@param <V> the type of elements maintained by this collection\n", "name": "ValuesIterator", "super_interfaces": ["Iterator<V>"], "superclasses": "", "attributes": {"modifiers": "protected static", "marker_annotations": [], "non_marker_annotations": ["protected", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @SuppressWarnings(\"unchecked\")\n        protected ValuesIterator(final AbstractHashedMap<?, V> parent) {\n            super((AbstractHashedMap<Object, V>) parent);\n        }", "docstring": "\nConstructs a new instance.\n\n@param parent The parent AbstractHashedMap.\n", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n        protected", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "protected"], "comments": [], "return_type": "", "classes": []}, "name": "ValuesIterator", "params": [{"name": "parent", "type": "AbstractHashedMap<?, V>"}], "body": "                                                                       {\n            super((AbstractHashedMap<Object, V>) parent);\n        }", "signature": "@SuppressWarnings(\"unchecked\")\n        protected ValuesIterator(final AbstractHashedMap<?, V> parent)"}, {"syntax_pass": true, "original_string": "        @Override\n        public V next() {\n            return super.nextEntry().getValue();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "next", "params": [], "body": "                        {\n            return super.nextEntry().getValue();\n        }", "signature": "@Override\n        public V next()"}]}], "class_docstring": "\nAn abstract implementation of a hash-based map which provides numerous points for\nsubclasses to override.\n<p>\nThis class implements all the features necessary for a subclass hash-based map.\nKey-value entries are stored in instances of the {@code HashEntry} class,\nwhich can be overridden and replaced. The iterators can similarly be replaced,\nwithout the need to replace the KeySet, EntrySet and Values view classes.\n<p>\nOverridable methods are provided to change the default hashing behavior, and\nto change how entries are added to and removed from the map. Hopefully, all you\nneed for unusual subclasses is here.\n<p>\nNOTE: From Commons Collections 3.1 this class extends AbstractMap.\nThis is to provide backwards compatibility for ReferenceMap between v3.0 and v3.1.\nThis extends clause will be removed in v5.0.\n\n@param <K> the type of the keys in this map\n@param <V> the type of the values in this map\n@since 3.0\n", "original_string": "public class AbstractHashedMap<K, V> extends AbstractMap<K, V> implements IterableMap<K, V> {\n\n    /**\n     * EntrySet implementation.\n     *\n     * @param <K> the type of the keys in the map\n     * @param <V> the type of the values in the map\n     */\n    protected static class EntrySet<K, V> extends AbstractSet<Map.Entry<K, V>> {\n\n        /** The parent map */\n        private final AbstractHashedMap<K, V> parent;\n\n        /**\n         * Constructs a new instance.\n         *\n         * @param parent The parent map.\n         */\n        protected EntrySet(final AbstractHashedMap<K, V> parent) {\n            this.parent = parent;\n        }\n\n        @Override\n        public void clear() {\n            parent.clear();\n        }\n\n        @Override\n        public boolean contains(final Object entry) {\n            if (entry instanceof Map.Entry) {\n                final Map.Entry<?, ?> e = (Map.Entry<?, ?>) entry;\n                final Entry<K, V> match = parent.getEntry(e.getKey());\n                return match != null && match.equals(e);\n            }\n            return false;\n        }\n\n        @Override\n        public Iterator<Map.Entry<K, V>> iterator() {\n            return parent.createEntrySetIterator();\n        }\n\n        @Override\n        public boolean remove(final Object obj) {\n            if (!(obj instanceof Map.Entry)) {\n                return false;\n            }\n            if (!contains(obj)) {\n                return false;\n            }\n            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n            parent.remove(entry.getKey());\n            return true;\n        }\n\n        @Override\n        public int size() {\n            return parent.size();\n        }\n    }\n\n    /**\n     * EntrySet iterator.\n     *\n     * @param <K> the type of the keys in the map\n     * @param <V> the type of the values in the map\n     */\n    protected static class EntrySetIterator<K, V> extends HashIterator<K, V> implements Iterator<Map.Entry<K, V>> {\n\n        /**\n         * Constructs a new instance.\n         *\n         * @param parent The parent map.\n         */\n        protected EntrySetIterator(final AbstractHashedMap<K, V> parent) {\n            super(parent);\n        }\n\n        @Override\n        public Map.Entry<K, V> next() {\n            return super.nextEntry();\n        }\n    }\n\n    /**\n     * HashEntry used to store the data.\n     * <p>\n     * If you subclass {@code AbstractHashedMap} but not {@code HashEntry}\n     * then you will not be able to access the protected fields.\n     * The {@code entryXxx()} methods on {@code AbstractHashedMap} exist\n     * to provide the necessary access.\n     * </p>\n     *\n     * @param <K> the type of the keys\n     * @param <V> the type of the values\n     */\n    protected static class HashEntry<K, V> implements Map.Entry<K, V>, KeyValue<K, V> {\n\n        /** The next entry in the hash chain */\n        protected HashEntry<K, V> next;\n\n        /** The hash code of the key */\n        protected int hashCode;\n\n        /** The key */\n        protected Object key;\n\n        /** The value */\n        protected Object value;\n\n        /**\n         * Constructs a new instance.\n         *\n         * @param next next.\n         * @param hashCode hash code.\n         * @param key key.\n         * @param value value.\n         */\n        protected HashEntry(final HashEntry<K, V> next, final int hashCode, final Object key, final V value) {\n            this.next = next;\n            this.hashCode = hashCode;\n            this.key = key;\n            this.value = value;\n        }\n\n        @Override\n        public boolean equals(final Object obj) {\n            if (obj == this) {\n                return true;\n            }\n            if (!(obj instanceof Map.Entry)) {\n                return false;\n            }\n            final Map.Entry<?, ?> other = (Map.Entry<?, ?>) obj;\n            return\n                (getKey() == null ? other.getKey() == null : getKey().equals(other.getKey())) &&\n                (getValue() == null ? other.getValue() == null : getValue().equals(other.getValue()));\n        }\n\n        @Override\n        @SuppressWarnings(\"unchecked\")\n        public K getKey() {\n            if (key == NULL) {\n                return null;\n            }\n            return (K) key;\n        }\n\n        @Override\n        @SuppressWarnings(\"unchecked\")\n        public V getValue() {\n            return (V) value;\n        }\n\n        @Override\n        public int hashCode() {\n            return (getKey() == null ? 0 : getKey().hashCode()) ^\n                   (getValue() == null ? 0 : getValue().hashCode());\n        }\n\n        @Override\n        @SuppressWarnings(\"unchecked\")\n        public V setValue(final V value) {\n            final Object old = this.value;\n            this.value = value;\n            return (V) old;\n        }\n\n        @Override\n        public String toString() {\n            return new StringBuilder().append(getKey()).append('=').append(getValue()).toString();\n        }\n    }\n    /**\n     * Base Iterator.\n     *\n     * @param <K> the type of the keys in the map\n     * @param <V> the type of the values in the map\n     */\n    protected abstract static class HashIterator<K, V> {\n\n        /** The parent map */\n        private final AbstractHashedMap<K, V> parent;\n\n        /** The current index into the array of buckets */\n        private int hashIndex;\n\n        /** The last returned entry */\n        private HashEntry<K, V> last;\n\n        /** The next entry */\n        private HashEntry<K, V> next;\n\n        /** The modification count expected */\n        private int expectedModCount;\n\n        /**\n         * Constructs a new instance.\n         *\n         * @param parent The parent AbstractHashedMap.\n         */\n        protected HashIterator(final AbstractHashedMap<K, V> parent) {\n            this.parent = parent;\n            final HashEntry<K, V>[] data = parent.data;\n            int i = data.length;\n            HashEntry<K, V> next = null;\n            while (i > 0 && next == null) {\n                next = data[--i];\n            }\n            this.next = next;\n            this.hashIndex = i;\n            this.expectedModCount = parent.modCount;\n        }\n\n        /**\n         * Gets the current entry.\n         *\n         * @return the current entry.\n         */\n        protected HashEntry<K, V> currentEntry() {\n            return last;\n        }\n\n        /**\n         * Tests whether there is a next entry.\n         *\n         * @return whether there is a next entry.\n         */\n        public boolean hasNext() {\n            return next != null;\n        }\n\n        /**\n         * Gets the next entry.\n         *\n         * @return the next entry.\n         */\n        protected HashEntry<K, V> nextEntry() {\n            if (parent.modCount != expectedModCount) {\n                throw new ConcurrentModificationException();\n            }\n            final HashEntry<K, V> newCurrent = next;\n            if (newCurrent == null)  {\n                throw new NoSuchElementException(NO_NEXT_ENTRY);\n            }\n            final HashEntry<K, V>[] data = parent.data;\n            int i = hashIndex;\n            HashEntry<K, V> n = newCurrent.next;\n            while (n == null && i > 0) {\n                n = data[--i];\n            }\n            next = n;\n            hashIndex = i;\n            last = newCurrent;\n            return newCurrent;\n        }\n\n        /**\n         * Removes the current element.\n         */\n        public void remove() {\n            if (last == null) {\n                throw new IllegalStateException(REMOVE_INVALID);\n            }\n            if (parent.modCount != expectedModCount) {\n                throw new ConcurrentModificationException();\n            }\n            parent.remove(last.getKey());\n            last = null;\n            expectedModCount = parent.modCount;\n        }\n\n        @Override\n        public String toString() {\n            if (last != null) {\n                return \"Iterator[\" + last.getKey() + \"=\" + last.getValue() + \"]\";\n            }\n            return \"Iterator[]\";\n        }\n    }\n\n    /**\n     * MapIterator implementation.\n     *\n     * @param <K> the type of the keys in the map\n     * @param <V> the type of the values in the map\n     */\n    protected static class HashMapIterator<K, V> extends HashIterator<K, V> implements MapIterator<K, V> {\n\n        /**\n         * Constructs a new instance.\n         *\n         * @param parent The parent AbstractHashedMap.\n         */\n        protected HashMapIterator(final AbstractHashedMap<K, V> parent) {\n            super(parent);\n        }\n\n        @Override\n        public K getKey() {\n            final HashEntry<K, V> current = currentEntry();\n            if (current == null) {\n                throw new IllegalStateException(GETKEY_INVALID);\n            }\n            return current.getKey();\n        }\n\n        @Override\n        public V getValue() {\n            final HashEntry<K, V> current = currentEntry();\n            if (current == null) {\n                throw new IllegalStateException(GETVALUE_INVALID);\n            }\n            return current.getValue();\n        }\n\n        @Override\n        public K next() {\n            return super.nextEntry().getKey();\n        }\n\n        @Override\n        public V setValue(final V value) {\n            final HashEntry<K, V> current = currentEntry();\n            if (current == null) {\n                throw new IllegalStateException(SETVALUE_INVALID);\n            }\n            return current.setValue(value);\n        }\n    }\n\n    /**\n     * KeySet implementation.\n     *\n     * @param <K> the type of elements maintained by this set\n     */\n    protected static class KeySet<K> extends AbstractSet<K> {\n\n        /** The parent map */\n        private final AbstractHashedMap<K, ?> parent;\n\n        /**\n         * Constructs a new instance.\n         *\n         * @param parent The parent AbstractHashedMap.\n         */\n        protected KeySet(final AbstractHashedMap<K, ?> parent) {\n            this.parent = parent;\n        }\n\n        @Override\n        public void clear() {\n            parent.clear();\n        }\n\n        @Override\n        public boolean contains(final Object key) {\n            return parent.containsKey(key);\n        }\n\n        @Override\n        public Iterator<K> iterator() {\n            return parent.createKeySetIterator();\n        }\n\n        @Override\n        public boolean remove(final Object key) {\n            final boolean result = parent.containsKey(key);\n            parent.remove(key);\n            return result;\n        }\n\n        @Override\n        public int size() {\n            return parent.size();\n        }\n    }\n\n    /**\n     * KeySet iterator.\n     *\n     * @param <K> the type of elements maintained by this set\n     */\n    protected static class KeySetIterator<K> extends HashIterator<K, Object> implements Iterator<K> {\n\n        /**\n         * Constructs a new instance.\n         *\n         * @param parent The parent AbstractHashedMap.\n         */\n        @SuppressWarnings(\"unchecked\")\n        protected KeySetIterator(final AbstractHashedMap<K, ?> parent) {\n            super((AbstractHashedMap<K, Object>) parent);\n        }\n\n        @Override\n        public K next() {\n            return super.nextEntry().getKey();\n        }\n    }\n\n    /**\n     * Values implementation.\n     *\n     * @param <V> the type of elements maintained by this collection\n     */\n    protected static class Values<V> extends AbstractCollection<V> {\n\n        /** The parent map */\n        private final AbstractHashedMap<?, V> parent;\n\n        /**\n         * Constructs a new instance.\n         *\n         * @param parent The parent AbstractHashedMap.\n         */\n        protected Values(final AbstractHashedMap<?, V> parent) {\n            this.parent = parent;\n        }\n\n        @Override\n        public void clear() {\n            parent.clear();\n        }\n\n        @Override\n        public boolean contains(final Object value) {\n            return parent.containsValue(value);\n        }\n\n        @Override\n        public Iterator<V> iterator() {\n            return parent.createValuesIterator();\n        }\n\n        @Override\n        public int size() {\n            return parent.size();\n        }\n    }\n\n    /**\n     * Values iterator.\n     *\n     * @param <V> the type of elements maintained by this collection\n     */\n    protected static class ValuesIterator<V> extends HashIterator<Object, V> implements Iterator<V> {\n\n        /**\n         * Constructs a new instance.\n         *\n         * @param parent The parent AbstractHashedMap.\n         */\n        @SuppressWarnings(\"unchecked\")\n        protected ValuesIterator(final AbstractHashedMap<?, V> parent) {\n            super((AbstractHashedMap<Object, V>) parent);\n        }\n\n        @Override\n        public V next() {\n            return super.nextEntry().getValue();\n        }\n    }\n\n    /** Exception message. */\n    protected static final String NO_NEXT_ENTRY = \"No next() entry in the iteration\";\n\n    /** Exception message. */\n    protected static final String NO_PREVIOUS_ENTRY = \"No previous() entry in the iteration\";\n\n    /** Exception message. */\n    protected static final String REMOVE_INVALID = \"remove() can only be called once after next()\";\n\n    /** Exception message. */\n    protected static final String GETKEY_INVALID = \"getKey() can only be called after next() and before remove()\";\n\n    /** Exception message. */\n    protected static final String GETVALUE_INVALID = \"getValue() can only be called after next() and before remove()\";\n\n    /** Exception message. */\n    protected static final String SETVALUE_INVALID = \"setValue() can only be called after next() and before remove()\";\n\n    /** The default capacity to use */\n    protected static final int DEFAULT_CAPACITY = 16;\n\n    /** The default threshold to use */\n    protected static final int DEFAULT_THRESHOLD = 12;\n\n    /** The default load factor to use */\n    protected static final float DEFAULT_LOAD_FACTOR = 0.75f;\n\n    /** The maximum capacity allowed */\n    protected static final int MAXIMUM_CAPACITY = 1 << 30;\n\n    /** An object for masking null */\n    protected static final Object NULL = new Object();\n\n    /** Load factor, normally 0.75 */\n    transient float loadFactor;\n\n    /** The size of the map */\n    transient int size;\n\n    /** Map entries */\n    transient HashEntry<K, V>[] data;\n\n    /** Size at which to rehash */\n    transient int threshold;\n\n    /** Modification count for iterators */\n    transient int modCount;\n\n    /** Entry set */\n    transient EntrySet<K, V> entrySet;\n\n    /** Key set */\n    transient KeySet<K> keySet;\n\n    /** Values */\n    transient Values<V> values;\n\n    /**\n     * Constructor only used in deserialization, do not use otherwise.\n     */\n    protected AbstractHashedMap() {\n    }\n\n    /**\n     * Constructs a new, empty map with the specified initial capacity and\n     * default load factor.\n     *\n     * @param initialCapacity  the initial capacity\n     * @throws IllegalArgumentException if the initial capacity is negative\n     */\n    protected AbstractHashedMap(final int initialCapacity) {\n        this(initialCapacity, DEFAULT_LOAD_FACTOR);\n    }\n\n    /**\n     * Constructs a new, empty map with the specified initial capacity and\n     * load factor.\n     *\n     * @param initialCapacity  the initial capacity\n     * @param loadFactor  the load factor\n     * @throws IllegalArgumentException if the initial capacity is negative\n     * @throws IllegalArgumentException if the load factor is less than or equal to zero\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected AbstractHashedMap(int initialCapacity, final float loadFactor) {\n        if (initialCapacity < 0) {\n            throw new IllegalArgumentException(\"Initial capacity must be a non negative number\");\n        }\n        if (loadFactor <= 0.0f || Float.isNaN(loadFactor)) {\n            throw new IllegalArgumentException(\"Load factor must be greater than 0\");\n        }\n        this.loadFactor = loadFactor;\n        initialCapacity = calculateNewCapacity(initialCapacity);\n        this.threshold = calculateThreshold(initialCapacity, loadFactor);\n        this.data = new HashEntry[initialCapacity];\n        init();\n    }\n\n    /**\n     * Constructor which performs no validation on the passed in parameters.\n     *\n     * @param initialCapacity  the initial capacity, must be a power of two\n     * @param loadFactor  the load factor, must be &gt; 0.0f and generally &lt; 1.0f\n     * @param threshold  the threshold, must be sensible\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected AbstractHashedMap(final int initialCapacity, final float loadFactor, final int threshold) {\n        this.loadFactor = loadFactor;\n        this.data = new HashEntry[initialCapacity];\n        this.threshold = threshold;\n        init();\n    }\n\n    /**\n     * Constructor copying elements from another map.\n     *\n     * @param map  the map to copy\n     * @throws NullPointerException if the map is null\n     */\n    protected AbstractHashedMap(final Map<? extends K, ? extends V> map) {\n        this(Math.max(2 * map.size(), DEFAULT_CAPACITY), DEFAULT_LOAD_FACTOR);\n        putAll(map);\n    }\n\n    /**\n     * Adds an entry into this map.\n     * <p>\n     * This implementation adds the entry to the data storage table.\n     * Subclasses could override to handle changes to the map.\n     *\n     * @param entry  the entry to add\n     * @param hashIndex  the index into the data array to store at\n     */\n    protected void addEntry(final HashEntry<K, V> entry, final int hashIndex) {\n        data[hashIndex] = entry;\n    }\n\n    /**\n     * Adds a new key-value mapping into this map.\n     * <p>\n     * This implementation calls {@code createEntry()}, {@code addEntry()}\n     * and {@code checkCapacity()}.\n     * It also handles changes to {@code modCount} and {@code size}.\n     * Subclasses could override to fully control adds to the map.\n     *\n     * @param hashIndex  the index into the data array to store at\n     * @param hashCode  the hash code of the key to add\n     * @param key  the key to add\n     * @param value  the value to add\n     */\n    protected void addMapping(final int hashIndex, final int hashCode, final K key, final V value) {\n        modCount++;\n        final HashEntry<K, V> entry = createEntry(data[hashIndex], hashCode, key, value);\n        addEntry(entry, hashIndex);\n        size++;\n        checkCapacity();\n    }\n\n    /**\n     * Calculates the new capacity of the map.\n     * This implementation normalizes the capacity to a power of two.\n     *\n     * @param proposedCapacity  the proposed capacity\n     * @return the normalized new capacity\n     */\n    protected int calculateNewCapacity(final int proposedCapacity) {\n        int newCapacity = 1;\n        if (proposedCapacity > MAXIMUM_CAPACITY) {\n            newCapacity = MAXIMUM_CAPACITY;\n        } else {\n            while (newCapacity < proposedCapacity) {\n                newCapacity <<= 1;  // multiply by two\n            }\n            if (newCapacity > MAXIMUM_CAPACITY) {\n                newCapacity = MAXIMUM_CAPACITY;\n            }\n        }\n        return newCapacity;\n    }\n\n    /**\n     * Calculates the new threshold of the map, where it will be resized.\n     * This implementation uses the load factor.\n     *\n     * @param newCapacity  the new capacity\n     * @param factor  the load factor\n     * @return the new resize threshold\n     */\n    protected int calculateThreshold(final int newCapacity, final float factor) {\n        return (int) (newCapacity * factor);\n    }\n\n    /**\n     * Checks the capacity of the map and enlarges it if necessary.\n     * <p>\n     * This implementation uses the threshold to check if the map needs enlarging\n     */\n    protected void checkCapacity() {\n        if (size >= threshold) {\n            final int newCapacity = data.length * 2;\n            if (newCapacity <= MAXIMUM_CAPACITY) {\n                ensureCapacity(newCapacity);\n            }\n        }\n    }\n\n    /**\n     * Clears the map, resetting the size to zero and nullifying references\n     * to avoid garbage collection issues.\n     */\n    @Override\n    public void clear() {\n        modCount++;\n        final HashEntry<K, V>[] data = this.data;\n        Arrays.fill(data, null);\n        size = 0;\n    }\n\n    /**\n     * Clones the map without cloning the keys or values.\n     * <p>\n     * To implement {@code clone()}, a subclass must implement the\n     * {@code Cloneable} interface and make this method public.\n     *\n     * @return a shallow clone\n     * @throws InternalError if {@link AbstractMap#clone()} failed\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    protected AbstractHashedMap<K, V> clone() {\n        try {\n            final AbstractHashedMap<K, V> cloned = (AbstractHashedMap<K, V>) super.clone();\n            cloned.data = new HashEntry[data.length];\n            cloned.entrySet = null;\n            cloned.keySet = null;\n            cloned.values = null;\n            cloned.modCount = 0;\n            cloned.size = 0;\n            cloned.init();\n            cloned.putAll(this);\n            return cloned;\n        } catch (final CloneNotSupportedException ex) {\n            throw new UnsupportedOperationException(ex);\n        }\n    }\n\n    /**\n     * Checks whether the map contains the specified key.\n     *\n     * @param key  the key to search for\n     * @return true if the map contains the key\n     */\n    @Override\n    public boolean containsKey(Object key) {\n        key = convertKey(key);\n        final int hashCode = hash(key);\n        HashEntry<K, V> entry = data[hashIndex(hashCode, data.length)]; // no local for hash index\n        while (entry != null) {\n            if (entry.hashCode == hashCode && isEqualKey(key, entry.key)) {\n                return true;\n            }\n            entry = entry.next;\n        }\n        return false;\n    }\n\n    /**\n     * Checks whether the map contains the specified value.\n     *\n     * @param value  the value to search for\n     * @return true if the map contains the value\n     */\n    @Override\n    public boolean containsValue(final Object value) {\n        if (value == null) {\n            for (final HashEntry<K, V> element : data) {\n                HashEntry<K, V> entry = element;\n                while (entry != null) {\n                    if (entry.getValue() == null) {\n                        return true;\n                    }\n                    entry = entry.next;\n                }\n            }\n        } else {\n            for (final HashEntry<K, V> element : data) {\n                HashEntry<K, V> entry = element;\n                while (entry != null) {\n                    if (isEqualValue(value, entry.getValue())) {\n                        return true;\n                    }\n                    entry = entry.next;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Converts input keys to another object for storage in the map.\n     * This implementation masks nulls.\n     * Subclasses can override this to perform alternate key conversions.\n     * <p>\n     * The reverse conversion can be changed, if required, by overriding the\n     * getKey() method in the hash entry.\n     *\n     * @param key  the key convert\n     * @return the converted key\n     */\n    protected Object convertKey(final Object key) {\n        return key == null ? NULL : key;\n    }\n\n    /**\n     * Creates an entry to store the key-value data.\n     * <p>\n     * This implementation creates a new HashEntry instance.\n     * Subclasses can override this to return a different storage class,\n     * or implement caching.\n     *\n     * @param next  the next entry in sequence\n     * @param hashCode  the hash code to use\n     * @param key  the key to store\n     * @param value  the value to store\n     * @return the newly created entry\n     */\n    protected HashEntry<K, V> createEntry(final HashEntry<K, V> next, final int hashCode, final K key, final V value) {\n        return new HashEntry<>(next, hashCode, convertKey(key), value);\n    }\n\n    /**\n     * Creates an entry set iterator.\n     * Subclasses can override this to return iterators with different properties.\n     *\n     * @return the entrySet iterator\n     */\n    protected Iterator<Map.Entry<K, V>> createEntrySetIterator() {\n        if (isEmpty()) {\n            return EmptyIterator.<Map.Entry<K, V>>emptyIterator();\n        }\n        return new EntrySetIterator<>(this);\n    }\n\n    /**\n     * Creates a key set iterator.\n     * Subclasses can override this to return iterators with different properties.\n     *\n     * @return the keySet iterator\n     */\n    protected Iterator<K> createKeySetIterator() {\n        if (isEmpty()) {\n            return EmptyIterator.<K>emptyIterator();\n        }\n        return new KeySetIterator<>(this);\n    }\n\n    /**\n     * Creates a values iterator.\n     * Subclasses can override this to return iterators with different properties.\n     *\n     * @return the values iterator\n     */\n    protected Iterator<V> createValuesIterator() {\n        if (isEmpty()) {\n            return EmptyIterator.<V>emptyIterator();\n        }\n        return new ValuesIterator<>(this);\n    }\n\n    /**\n     * Kills an entry ready for the garbage collector.\n     * <p>\n     * This implementation prepares the HashEntry for garbage collection.\n     * Subclasses can override this to implement caching (override clear as well).\n     *\n     * @param entry  the entry to destroy\n     */\n    protected void destroyEntry(final HashEntry<K, V> entry) {\n        entry.next = null;\n        entry.key = null;\n        entry.value = null;\n    }\n\n    /**\n     * Reads the map data from the stream. This method must be overridden if a\n     * subclass must be setup before {@code put()} is used.\n     * <p>\n     * Serialization is not one of the JDK's nicest topics. Normal serialization will\n     * initialize the superclass before the subclass. Sometimes however, this isn't\n     * what you want, as in this case the {@code put()} method on read can be\n     * affected by subclass state.\n     * <p>\n     * The solution adopted here is to deserialize the state data of this class in\n     * this protected method. This method must be called by the\n     * {@code readObject()} of the first serializable subclass.\n     * <p>\n     * Subclasses may override if the subclass has a specific field that must be present\n     * before {@code put()} or {@code calculateThreshold()} will work correctly.\n     *\n     * @param in  the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected void doReadObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n        loadFactor = in.readFloat();\n        final int capacity = in.readInt();\n        final int size = in.readInt();\n        init();\n        threshold = calculateThreshold(capacity, loadFactor);\n        data = new HashEntry[capacity];\n        for (int i = 0; i < size; i++) {\n            final K key = (K) in.readObject();\n            final V value = (V) in.readObject();\n            put(key, value);\n        }\n    }\n\n    /**\n     * Writes the map data to the stream. This method must be overridden if a\n     * subclass must be setup before {@code put()} is used.\n     * <p>\n     * Serialization is not one of the JDK's nicest topics. Normal serialization will\n     * initialize the superclass before the subclass. Sometimes however, this isn't\n     * what you want, as in this case the {@code put()} method on read can be\n     * affected by subclass state.\n     * <p>\n     * The solution adopted here is to serialize the state data of this class in\n     * this protected method. This method must be called by the\n     * {@code writeObject()} of the first serializable subclass.\n     * <p>\n     * Subclasses may override if they have a specific field that must be present\n     * on read before this implementation will work. Generally, the read determines\n     * what must be serialized here, if anything.\n     *\n     * @param out  the output stream\n     * @throws IOException if an error occurs while writing to the stream\n     */\n    protected void doWriteObject(final ObjectOutputStream out) throws IOException {\n        out.writeFloat(loadFactor);\n        out.writeInt(data.length);\n        out.writeInt(size);\n        for (final MapIterator<K, V> it = mapIterator(); it.hasNext();) {\n            out.writeObject(it.next());\n            out.writeObject(it.getValue());\n        }\n    }\n\n    /**\n     * Changes the size of the data structure to the capacity proposed.\n     *\n     * @param newCapacity  the new capacity of the array (a power of two, less or equal to max)\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected void ensureCapacity(final int newCapacity) {\n        final int oldCapacity = data.length;\n        if (newCapacity <= oldCapacity) {\n            return;\n        }\n        if (size == 0) {\n            threshold = calculateThreshold(newCapacity, loadFactor);\n            data = new HashEntry[newCapacity];\n        } else {\n            final HashEntry<K, V>[] oldEntries = data;\n            final HashEntry<K, V>[] newEntries = new HashEntry[newCapacity];\n\n            modCount++;\n            for (int i = oldCapacity - 1; i >= 0; i--) {\n                HashEntry<K, V> entry = oldEntries[i];\n                if (entry != null) {\n                    oldEntries[i] = null;  // gc\n                    do {\n                        final HashEntry<K, V> next = entry.next;\n                        final int index = hashIndex(entry.hashCode, newCapacity);\n                        entry.next = newEntries[index];\n                        newEntries[index] = entry;\n                        entry = next;\n                    } while (entry != null);\n                }\n            }\n            threshold = calculateThreshold(newCapacity, loadFactor);\n            data = newEntries;\n        }\n    }\n\n    /**\n     * Gets the {@code hashCode} field from a {@code HashEntry}.\n     * Used in subclasses that have no visibility of the field.\n     *\n     * @param entry  the entry to query, must not be null\n     * @return the {@code hashCode} field of the entry\n     * @throws NullPointerException if the entry is null\n     * @since 3.1\n     */\n    protected int entryHashCode(final HashEntry<K, V> entry) {\n        return entry.hashCode;\n    }\n\n    /**\n     * Gets the {@code key} field from a {@code HashEntry}.\n     * Used in subclasses that have no visibility of the field.\n     *\n     * @param entry  the entry to query, must not be null\n     * @return the {@code key} field of the entry\n     * @throws NullPointerException if the entry is null\n     * @since 3.1\n     */\n    protected K entryKey(final HashEntry<K, V> entry) {\n        return entry.getKey();\n    }\n\n    /**\n     * Gets the {@code next} field from a {@code HashEntry}.\n     * Used in subclasses that have no visibility of the field.\n     *\n     * @param entry  the entry to query, must not be null\n     * @return the {@code next} field of the entry\n     * @throws NullPointerException if the entry is null\n     * @since 3.1\n     */\n    protected HashEntry<K, V> entryNext(final HashEntry<K, V> entry) {\n        return entry.next;\n    }\n\n    /**\n     * Gets the entrySet view of the map.\n     * Changes made to the view affect this map.\n     * To simply iterate through the entries, use {@link #mapIterator()}.\n     *\n     * @return the entrySet view\n     */\n    @Override\n    public Set<Map.Entry<K, V>> entrySet() {\n        if (entrySet == null) {\n            entrySet = new EntrySet<>(this);\n        }\n        return entrySet;\n    }\n\n    /**\n     * Gets the {@code value} field from a {@code HashEntry}.\n     * Used in subclasses that have no visibility of the field.\n     *\n     * @param entry  the entry to query, must not be null\n     * @return the {@code value} field of the entry\n     * @throws NullPointerException if the entry is null\n     * @since 3.1\n     */\n    protected V entryValue(final HashEntry<K, V> entry) {\n        return entry.getValue();\n    }\n\n    /**\n     * Compares this map with another.\n     *\n     * @param obj  the object to compare to\n     * @return true if equal\n     */\n    @Override\n    public boolean equals(final Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof Map)) {\n            return false;\n        }\n        final Map<?, ?> map = (Map<?, ?>) obj;\n        if (map.size() != size()) {\n            return false;\n        }\n        final MapIterator<?, ?> it = mapIterator();\n        try {\n            while (it.hasNext()) {\n                final Object key = it.next();\n                final Object value = it.getValue();\n                if (value == null) {\n                    if (map.get(key) != null || !map.containsKey(key)) {\n                        return false;\n                    }\n                } else if (!value.equals(map.get(key))) {\n                    return false;\n                }\n            }\n        } catch (final ClassCastException | NullPointerException ignored) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Gets the value mapped to the key specified.\n     *\n     * @param key  the key\n     * @return the mapped value, null if no match\n     */\n    @Override\n    public V get(Object key) {\n        key = convertKey(key);\n        final int hashCode = hash(key);\n        HashEntry<K, V> entry = data[hashIndex(hashCode, data.length)]; // no local for hash index\n        while (entry != null) {\n            if (entry.hashCode == hashCode && isEqualKey(key, entry.key)) {\n                return entry.getValue();\n            }\n            entry = entry.next;\n        }\n        return null;\n    }\n\n    /**\n     * Gets the entry mapped to the key specified.\n     * <p>\n     * This method exists for subclasses that may need to perform a multi-step\n     * process accessing the entry. The public methods in this class don't use this\n     * method to gain a small performance boost.\n     *\n     * @param key  the key\n     * @return the entry, null if no match\n     */\n    protected HashEntry<K, V> getEntry(Object key) {\n        key = convertKey(key);\n        final int hashCode = hash(key);\n        HashEntry<K, V> entry = data[hashIndex(hashCode, data.length)]; // no local for hash index\n        while (entry != null) {\n            if (entry.hashCode == hashCode && isEqualKey(key, entry.key)) {\n                return entry;\n            }\n            entry = entry.next;\n        }\n        return null;\n    }\n\n    /**\n     * Gets the hash code for the key specified.\n     * This implementation uses the additional hashing routine from JDK1.4.\n     * Subclasses can override this to return alternate hash codes.\n     *\n     * @param key  the key to get a hash code for\n     * @return the hash code\n     */\n    protected int hash(final Object key) {\n        // same as JDK 1.4\n        int h = key.hashCode();\n        h += ~(h << 9);\n        h ^=  h >>> 14;\n        h +=  h << 4;\n        h ^=  h >>> 10;\n        return h;\n    }\n\n    /**\n     * Gets the standard Map hashCode.\n     *\n     * @return the hash code defined in the Map interface\n     */\n    @Override\n    public int hashCode() {\n        int total = 0;\n        final Iterator<Map.Entry<K, V>> it = createEntrySetIterator();\n        while (it.hasNext()) {\n            total += it.next().hashCode();\n        }\n        return total;\n    }\n\n    /**\n     * Gets the index into the data storage for the hashCode specified.\n     * This implementation uses the least significant bits of the hashCode.\n     * Subclasses can override this to return alternate bucketing.\n     *\n     * @param hashCode  the hash code to use\n     * @param dataSize  the size of the data to pick a bucket from\n     * @return the bucket index\n     */\n    protected int hashIndex(final int hashCode, final int dataSize) {\n        return hashCode & dataSize - 1;\n    }\n\n    /**\n     * Initialize subclasses during construction, cloning or deserialization.\n     */\n    protected void init() {\n        // noop\n    }\n\n    /**\n     * Checks whether the map is currently empty.\n     *\n     * @return true if the map is currently size zero\n     */\n    @Override\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    /**\n     * Compares two keys, in internal converted form, to see if they are equal.\n     * This implementation uses the equals method and assumes neither key is null.\n     * Subclasses can override this to match differently.\n     *\n     * @param key1  the first key to compare passed in from outside\n     * @param key2  the second key extracted from the entry via {@code entry.key}\n     * @return true if equal\n     */\n    protected boolean isEqualKey(final Object key1, final Object key2) {\n        return key1 == key2 || key1.equals(key2);\n    }\n\n    /**\n     * Compares two values, in external form, to see if they are equal.\n     * This implementation uses the equals method and assumes neither value is null.\n     * Subclasses can override this to match differently.\n     *\n     * @param value1  the first value to compare passed in from outside\n     * @param value2  the second value extracted from the entry via {@code getValue()}\n     * @return true if equal\n     */\n    protected boolean isEqualValue(final Object value1, final Object value2) {\n        return value1 == value2 || value1.equals(value2);\n    }\n\n    /**\n     * Gets the keySet view of the map.\n     * Changes made to the view affect this map.\n     * To simply iterate through the keys, use {@link #mapIterator()}.\n     *\n     * @return the keySet view\n     */\n    @Override\n    public Set<K> keySet() {\n        if (keySet == null) {\n            keySet = new KeySet<>(this);\n        }\n        return keySet;\n    }\n\n    /**\n     * Gets an iterator over the map.\n     * Changes made to the iterator affect this map.\n     * <p>\n     * A MapIterator returns the keys in the map. It also provides convenient\n     * methods to get the key and value, and set the value.\n     * It avoids the need to create an entrySet/keySet/values object.\n     * It also avoids creating the Map.Entry object.\n     *\n     * @return the map iterator\n     */\n    @Override\n    public MapIterator<K, V> mapIterator() {\n        if (size == 0) {\n            return EmptyMapIterator.<K, V>emptyMapIterator();\n        }\n        return new HashMapIterator<>(this);\n    }\n\n    /**\n     * Puts a key-value mapping into this map.\n     *\n     * @param key  the key to add\n     * @param value  the value to add\n     * @return the value previously mapped to this key, null if none\n     */\n    @Override\n    public V put(final K key, final V value) {\n        final Object convertedKey = convertKey(key);\n        final int hashCode = hash(convertedKey);\n        final int index = hashIndex(hashCode, data.length);\n        HashEntry<K, V> entry = data[index];\n        while (entry != null) {\n            if (entry.hashCode == hashCode && isEqualKey(convertedKey, entry.key)) {\n                final V oldValue = entry.getValue();\n                updateEntry(entry, value);\n                return oldValue;\n            }\n            entry = entry.next;\n        }\n\n        addMapping(index, hashCode, key, value);\n        return null;\n    }\n\n    /**\n     * Puts all the values from the specified map into this map.\n     * <p>\n     * This implementation iterates around the specified map and\n     * uses {@link #put(Object, Object)}.\n     *\n     * @param map  the map to add\n     * @throws NullPointerException if the map is null\n     */\n    @Override\n    public void putAll(final Map<? extends K, ? extends V> map) {\n        final int mapSize = map.size();\n        if (mapSize == 0) {\n            return;\n        }\n        final int newSize = (int) ((size + mapSize) / loadFactor + 1);\n        ensureCapacity(calculateNewCapacity(newSize));\n        for (final Map.Entry<? extends K, ? extends V> entry: map.entrySet()) {\n            put(entry.getKey(), entry.getValue());\n        }\n    }\n\n    /**\n     * Removes the specified mapping from this map.\n     *\n     * @param key  the mapping to remove\n     * @return the value mapped to the removed key, null if key not in map\n     */\n    @Override\n    public V remove(Object key) {\n        key = convertKey(key);\n        final int hashCode = hash(key);\n        final int index = hashIndex(hashCode, data.length);\n        HashEntry<K, V> entry = data[index];\n        HashEntry<K, V> previous = null;\n        while (entry != null) {\n            if (entry.hashCode == hashCode && isEqualKey(key, entry.key)) {\n                final V oldValue = entry.getValue();\n                removeMapping(entry, index, previous);\n                return oldValue;\n            }\n            previous = entry;\n            entry = entry.next;\n        }\n        return null;\n    }\n\n    /**\n     * Removes an entry from the chain stored in a particular index.\n     * <p>\n     * This implementation removes the entry from the data storage table.\n     * The size is not updated.\n     * Subclasses could override to handle changes to the map.\n     *\n     * @param entry  the entry to remove\n     * @param hashIndex  the index into the data structure\n     * @param previous  the previous entry in the chain\n     */\n    protected void removeEntry(final HashEntry<K, V> entry, final int hashIndex, final HashEntry<K, V> previous) {\n        if (previous == null) {\n            data[hashIndex] = entry.next;\n        } else {\n            previous.next = entry.next;\n        }\n    }\n\n    /**\n     * Removes a mapping from the map.\n     * <p>\n     * This implementation calls {@code removeEntry()} and {@code destroyEntry()}.\n     * It also handles changes to {@code modCount} and {@code size}.\n     * Subclasses could override to fully control removals from the map.\n     *\n     * @param entry  the entry to remove\n     * @param hashIndex  the index into the data structure\n     * @param previous  the previous entry in the chain\n     */\n    protected void removeMapping(final HashEntry<K, V> entry, final int hashIndex, final HashEntry<K, V> previous) {\n        modCount++;\n        removeEntry(entry, hashIndex, previous);\n        size--;\n        destroyEntry(entry);\n    }\n\n    /**\n     * Reuses an existing key-value mapping, storing completely new data.\n     * <p>\n     * This implementation sets all the data fields on the entry.\n     * Subclasses could populate additional entry fields.\n     *\n     * @param entry  the entry to update, not null\n     * @param hashIndex  the index in the data array\n     * @param hashCode  the hash code of the key to add\n     * @param key  the key to add\n     * @param value  the value to add\n     */\n    protected void reuseEntry(final HashEntry<K, V> entry, final int hashIndex, final int hashCode,\n                              final K key, final V value) {\n        entry.next = data[hashIndex];\n        entry.hashCode = hashCode;\n        entry.key = key;\n        entry.value = value;\n    }\n\n    /**\n     * Gets the size of the map.\n     *\n     * @return the size\n     */\n    @Override\n    public int size() {\n        return size;\n    }\n\n    /**\n     * Gets the map as a String.\n     *\n     * @return a string version of the map\n     */\n    @Override\n    public String toString() {\n        if (isEmpty()) {\n            return \"{}\";\n        }\n        final StringBuilder buf = new StringBuilder(32 * size());\n        buf.append('{');\n\n        final MapIterator<K, V> it = mapIterator();\n        boolean hasNext = it.hasNext();\n        while (hasNext) {\n            final K key = it.next();\n            final V value = it.getValue();\n            buf.append(key == this ? \"(this Map)\" : key)\n                .append('=')\n                .append(value == this ? \"(this Map)\" : value);\n\n            hasNext = it.hasNext();\n            if (hasNext) {\n                buf.append(CollectionUtils.COMMA).append(' ');\n            }\n        }\n\n        buf.append('}');\n        return buf.toString();\n    }\n\n    /**\n     * Updates an existing key-value mapping to change the value.\n     * <p>\n     * This implementation calls {@code setValue()} on the entry.\n     * Subclasses could override to handle changes to the map.\n     *\n     * @param entry  the entry to update\n     * @param newValue  the new value to store\n     */\n    protected void updateEntry(final HashEntry<K, V> entry, final V newValue) {\n        entry.setValue(newValue);\n    }\n\n    /**\n     * Gets the values view of the map.\n     * Changes made to the view affect this map.\n     * To simply iterate through the values, use {@link #mapIterator()}.\n     *\n     * @return the values view\n     */\n    @Override\n    public Collection<V> values() {\n        if (values == null) {\n            values = new Values<>(this);\n        }\n        return values;\n    }\n}", "super_interfaces": ["IterableMap<K, V>"], "fields": [{"attribute_expression": "protected static final String NO_NEXT_ENTRY = \"No next() entry in the iteration\";", "docstring": " Exception message.", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "String", "name": "NO_NEXT_ENTRY = \"No next() entry in the iteration\"", "syntax_pass": true}, {"attribute_expression": "protected static final String NO_PREVIOUS_ENTRY = \"No previous() entry in the iteration\";", "docstring": " Exception message.", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "String", "name": "NO_PREVIOUS_ENTRY = \"No previous() entry in the iteration\"", "syntax_pass": true}, {"attribute_expression": "protected static final String REMOVE_INVALID = \"remove() can only be called once after next()\";", "docstring": " Exception message.", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "String", "name": "REMOVE_INVALID = \"remove() can only be called once after next()\"", "syntax_pass": true}, {"attribute_expression": "protected static final String GETKEY_INVALID = \"getKey() can only be called after next() and before remove()\";", "docstring": " Exception message.", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "String", "name": "GETKEY_INVALID = \"getKey() can only be called after next() and before remove()\"", "syntax_pass": true}, {"attribute_expression": "protected static final String GETVALUE_INVALID = \"getValue() can only be called after next() and before remove()\";", "docstring": " Exception message.", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "String", "name": "GETVALUE_INVALID = \"getValue() can only be called after next() and before remove()\"", "syntax_pass": true}, {"attribute_expression": "protected static final String SETVALUE_INVALID = \"setValue() can only be called after next() and before remove()\";", "docstring": " Exception message.", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "String", "name": "SETVALUE_INVALID = \"setValue() can only be called after next() and before remove()\"", "syntax_pass": true}, {"attribute_expression": "protected static final int DEFAULT_CAPACITY = 16;", "docstring": " The default capacity to use", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "int", "name": "DEFAULT_CAPACITY = 16", "syntax_pass": true}, {"attribute_expression": "protected static final int DEFAULT_THRESHOLD = 12;", "docstring": " The default threshold to use", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "int", "name": "DEFAULT_THRESHOLD = 12", "syntax_pass": true}, {"attribute_expression": "protected static final float DEFAULT_LOAD_FACTOR = 0.75f;", "docstring": " The default load factor to use", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "float", "name": "DEFAULT_LOAD_FACTOR = 0.75f", "syntax_pass": true}, {"attribute_expression": "protected static final int MAXIMUM_CAPACITY = 1 << 30;", "docstring": " The maximum capacity allowed", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "int", "name": "MAXIMUM_CAPACITY = 1 << 30", "syntax_pass": true}, {"attribute_expression": "protected static final Object NULL = new Object();", "docstring": " An object for masking null", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "Object", "name": "NULL = new Object()", "syntax_pass": true}, {"attribute_expression": "transient float loadFactor;", "docstring": " Load factor, normally 0.75", "modifiers": "transient", "marker_annotations": [], "non_marker_annotations": ["transient"], "comments": [], "type": "float", "name": "loadFactor", "syntax_pass": true}, {"attribute_expression": "transient int size;", "docstring": " The size of the map", "modifiers": "transient", "marker_annotations": [], "non_marker_annotations": ["transient"], "comments": [], "type": "int", "name": "size", "syntax_pass": true}, {"attribute_expression": "transient HashEntry<K, V>[] data;", "docstring": " Map entries", "modifiers": "transient", "marker_annotations": [], "non_marker_annotations": ["transient"], "comments": [], "type": "HashEntry<K, V>[]", "name": "data", "syntax_pass": true}, {"attribute_expression": "transient int threshold;", "docstring": " Size at which to rehash", "modifiers": "transient", "marker_annotations": [], "non_marker_annotations": ["transient"], "comments": [], "type": "int", "name": "threshold", "syntax_pass": true}, {"attribute_expression": "transient int modCount;", "docstring": " Modification count for iterators", "modifiers": "transient", "marker_annotations": [], "non_marker_annotations": ["transient"], "comments": [], "type": "int", "name": "modCount", "syntax_pass": true}, {"attribute_expression": "transient EntrySet<K, V> entrySet;", "docstring": " Entry set", "modifiers": "transient", "marker_annotations": [], "non_marker_annotations": ["transient"], "comments": [], "type": "EntrySet<K, V>", "name": "entrySet", "syntax_pass": true}, {"attribute_expression": "transient KeySet<K> keySet;", "docstring": " Key set", "modifiers": "transient", "marker_annotations": [], "non_marker_annotations": ["transient"], "comments": [], "type": "KeySet<K>", "name": "keySet", "syntax_pass": true}, {"attribute_expression": "transient Values<V> values;", "docstring": " Values", "modifiers": "transient", "marker_annotations": [], "non_marker_annotations": ["transient"], "comments": [], "type": "Values<V>", "name": "values", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/map/DefaultedMap.java.DefaultedMap", "name": "DefaultedMap", "file_path": "src/main/java/org/apache/commons/collections4/map/DefaultedMap.java", "superclasses": "", "methods": ["[DefaultedMap<K, V>]defaultedMap(Map<K, V>,Factory<? extends V>)", "[Map<K, V>]defaultedMap(Map<K, V>,Transformer<? super K, ? extends V>)", "[DefaultedMap<K, V>]defaultedMap(Map<K, V>,V)", "[]DefaultedMap(Map<K, V>,Transformer<? super K, ? extends V>)", "[]DefaultedMap(Transformer<? super K, ? extends V>)", "[]DefaultedMap(V)", "[V]get(Object)", "[void]readObject(ObjectInputStream)", "[void]writeObject(ObjectOutputStream)"], "method_uris": ["src/main/java/org/apache/commons/collections4/map/DefaultedMap.java.DefaultedMap.[DefaultedMap<K, V>]defaultedMap(Map<K, V>,Factory<? extends V>)", "src/main/java/org/apache/commons/collections4/map/DefaultedMap.java.DefaultedMap.[Map<K, V>]defaultedMap(Map<K, V>,Transformer<? super K, ? extends V>)", "src/main/java/org/apache/commons/collections4/map/DefaultedMap.java.DefaultedMap.[DefaultedMap<K, V>]defaultedMap(Map<K, V>,V)", "src/main/java/org/apache/commons/collections4/map/DefaultedMap.java.DefaultedMap.[]DefaultedMap(Map<K, V>,Transformer<? super K, ? extends V>)", "src/main/java/org/apache/commons/collections4/map/DefaultedMap.java.DefaultedMap.[]DefaultedMap(Transformer<? super K, ? extends V>)", "src/main/java/org/apache/commons/collections4/map/DefaultedMap.java.DefaultedMap.[]DefaultedMap(V)", "src/main/java/org/apache/commons/collections4/map/DefaultedMap.java.DefaultedMap.[V]get(Object)", "src/main/java/org/apache/commons/collections4/map/DefaultedMap.java.DefaultedMap.[void]readObject(ObjectInputStream)", "src/main/java/org/apache/commons/collections4/map/DefaultedMap.java.DefaultedMap.[void]writeObject(ObjectOutputStream)"], "overrides": null, "attributes": [], "class_docstring": "\nDecorates another {@code Map} returning a default value if the map\ndoes not contain the requested key.\n<p>\nWhen the {@link #get(Object)} method is called with a key that does not\nexist in the map, this map will return the default value specified in\nthe constructor/factory. Only the get method is altered, so the\n{@link Map#containsKey(Object)} can be used to determine if a key really\nis in the map or not.\n</p>\n<p>\nThe defaulted value is not added to the map.\nCompare this behavior with {@link LazyMap}, which does add the value\nto the map (via a Transformer).\n</p>\n<p>\nFor instance:\n</p>\n<pre>\nMap map = new DefaultedMap(\"NULL\");\nObject obj = map.get(\"Surname\");\n// obj == \"NULL\"\n</pre>\n<p>\nAfter the above code is executed the map is still empty.\n</p>\n<p>\n<strong>Note that DefaultedMap is not synchronized and is not thread-safe.</strong>\nIf you wish to use this map from multiple threads concurrently, you must use\nappropriate synchronization. The simplest approach is to wrap this map\nusing {@link java.util.Collections#synchronizedMap(Map)}. This class may throw\nexceptions when accessed by concurrent threads without synchronization.\n</p>\n\n@param <K> the type of the keys in this map\n@param <V> the type of the values in this map\n\n@since 3.2\n@see LazyMap\n", "original_string": "public class DefaultedMap<K, V> extends AbstractMapDecorator<K, V> implements Serializable {\n\n    /** Serialization version */\n    private static final long serialVersionUID = 19698628745827L;\n\n    /**\n     * Factory method to create a defaulting map.\n     * <p>\n     * The factory specified is called when a missing key is found.\n     * The result will be returned as the result of the map get(key) method.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param map  the map to decorate, must not be null\n     * @param factory  the factory to use to create entries, must not be null\n     * @return a new defaulting map\n     * @throws NullPointerException if map or factory is null\n     * @since 4.0\n     */\n    public static <K, V> DefaultedMap<K, V> defaultedMap(final Map<K, V> map, final Factory<? extends V> factory) {\n        return new DefaultedMap<>(map, FactoryTransformer.factoryTransformer(\n                Objects.requireNonNull(factory, \"Factory must not be null\")));\n    }\n\n    /**\n     * Factory method to create a defaulting map.\n     * <p>\n     * The transformer specified is called when a missing key is found.\n     * The key is passed to the transformer as the input, and the result\n     * will be returned as the result of the map get(key) method.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param map  the map to decorate, must not be null\n     * @param transformer  the transformer to use as a factory to create entries, must not be null\n     * @return a new defaulting map\n     * @throws NullPointerException if map or transformer is null\n     * @since 4.0\n     */\n    public static <K, V> Map<K, V> defaultedMap(final Map<K, V> map,\n                                                final Transformer<? super K, ? extends V> transformer) {\n        return new DefaultedMap<>(map, Objects.requireNonNull(transformer, \"Transformer must not be null\"));\n    }\n\n    /**\n     * Factory method to create a defaulting map.\n     * <p>\n     * The value specified is returned when a missing key is found.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param map  the map to decorate, must not be null\n     * @param defaultValue  the default value to return when the key is not found\n     * @return a new defaulting map\n     * @throws NullPointerException if map is null\n     * @since 4.0\n     */\n    public static <K, V> DefaultedMap<K, V> defaultedMap(final Map<K, V> map, final V defaultValue) {\n        return new DefaultedMap<>(map, ConstantTransformer.constantTransformer(defaultValue));\n    }\n\n    /** The transformer to use if the map does not contain a key */\n    private final Transformer<? super K, ? extends V> value;\n\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param map  the map to decorate, must not be null\n     * @param defaultValueTransformer  the value transformer to use\n     * @throws NullPointerException if map or transformer is null\n     */\n    protected DefaultedMap(final Map<K, V> map, final Transformer<? super K, ? extends V> defaultValueTransformer) {\n        super(map);\n        this.value = Objects.requireNonNull(defaultValueTransformer, \"defaultValueTransformer\");\n    }\n\n    /**\n     * Constructs a new empty {@code DefaultedMap} that decorates a {@code HashMap}.\n     *\n     * @param defaultValueTransformer transformer to use to generate missing values.\n     */\n    public DefaultedMap(final Transformer<? super K, ? extends V> defaultValueTransformer) {\n        this(new HashMap<>(), defaultValueTransformer);\n    }\n\n    /**\n     * Constructs a new empty {@code DefaultedMap} that decorates\n     * a {@code HashMap}.\n     * <p>\n     * The object passed in will be returned by the map whenever an\n     * unknown key is requested.\n     *\n     * @param defaultValue  the default value to return when the key is not found\n     */\n    public DefaultedMap(final V defaultValue) {\n        this(ConstantTransformer.constantTransformer(defaultValue));\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public V get(final Object key) {\n        final V v;\n        return (v = map.get(key)) != null || map.containsKey(key)\n            ? v\n            : value.apply((K) key);\n    }\n\n    /**\n     * Deserializes the map in using a custom routine.\n     *\n     * @param in  the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded\n     */\n    @SuppressWarnings(\"unchecked\")\n    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        map = (Map<K, V>) in.readObject();\n    }\n\n    /**\n     * Serializes this object to an ObjectOutputStream.\n     *\n     * @param out the target ObjectOutputStream.\n     * @throws IOException thrown when an I/O errors occur writing to the target stream.\n     */\n    private void writeObject(final ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        out.writeObject(map);\n    }\n\n    // no need to wrap keySet, entrySet or values as they are views of\n    // existing map entries - you can't do a map-style get on them.\n}", "super_interfaces": ["Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 19698628745827L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 19698628745827L", "syntax_pass": true}, {"attribute_expression": "private final Transformer<? super K, ? extends V> value;", "docstring": " The transformer to use if the map does not contain a key", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Transformer<? super K, ? extends V>", "name": "value", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/map/PredicatedSortedMap.java.PredicatedSortedMap", "name": "PredicatedSortedMap", "file_path": "src/main/java/org/apache/commons/collections4/map/PredicatedSortedMap.java", "superclasses": "", "methods": ["[PredicatedSortedMap<K, V>]predicatedSortedMap(SortedMap<K, V>,Predicate<? super K>,Predicate<? super V>)", "[]PredicatedSortedMap(SortedMap<K, V>,Predicate<? super K>,Predicate<? super V>)", "[Comparator<? super K>]comparator()", "[K]firstKey()", "[SortedMap<K, V>]getSortedMap()", "[SortedMap<K, V>]headMap(K)", "[K]lastKey()", "[SortedMap<K, V>]subMap(K,K)", "[SortedMap<K, V>]tailMap(K)"], "method_uris": ["src/main/java/org/apache/commons/collections4/map/PredicatedSortedMap.java.PredicatedSortedMap.[PredicatedSortedMap<K, V>]predicatedSortedMap(SortedMap<K, V>,Predicate<? super K>,Predicate<? super V>)", "src/main/java/org/apache/commons/collections4/map/PredicatedSortedMap.java.PredicatedSortedMap.[]PredicatedSortedMap(SortedMap<K, V>,Predicate<? super K>,Predicate<? super V>)", "src/main/java/org/apache/commons/collections4/map/PredicatedSortedMap.java.PredicatedSortedMap.[Comparator<? super K>]comparator()", "src/main/java/org/apache/commons/collections4/map/PredicatedSortedMap.java.PredicatedSortedMap.[K]firstKey()", "src/main/java/org/apache/commons/collections4/map/PredicatedSortedMap.java.PredicatedSortedMap.[SortedMap<K, V>]getSortedMap()", "src/main/java/org/apache/commons/collections4/map/PredicatedSortedMap.java.PredicatedSortedMap.[SortedMap<K, V>]headMap(K)", "src/main/java/org/apache/commons/collections4/map/PredicatedSortedMap.java.PredicatedSortedMap.[K]lastKey()", "src/main/java/org/apache/commons/collections4/map/PredicatedSortedMap.java.PredicatedSortedMap.[SortedMap<K, V>]subMap(K,K)", "src/main/java/org/apache/commons/collections4/map/PredicatedSortedMap.java.PredicatedSortedMap.[SortedMap<K, V>]tailMap(K)"], "overrides": null, "attributes": [], "class_docstring": "\nDecorates another {@code SortedMap} to validate that additions\nmatch a specified predicate.\n<p>\nThis map exists to provide validation for the decorated map.\nIt is normally created to decorate an empty map.\nIf an object cannot be added to the map, an IllegalArgumentException is thrown.\n</p>\n<p>\nOne usage would be to ensure that no null keys are added to the map.\n</p>\n<pre>\n  SortedMap map =\n    PredicatedSortedMap.predicatedSortedMap(new TreeMap(),\n                                            NotNullPredicate.notNullPredicate(),\n                                            null);\n</pre>\n<p>\n<strong>Note that PredicatedSortedMap is not synchronized and is not thread-safe.</strong>\nIf you wish to use this map from multiple threads concurrently, you must use\nappropriate synchronization. The simplest approach is to wrap this map\nusing {@link java.util.Collections#synchronizedSortedMap}. This class may throw\nexceptions when accessed by concurrent threads without synchronization.\n</p>\n<p>\nThis class is Serializable from Commons Collections 3.1.\n</p>\n\n@param <K> the type of the keys in this map\n@param <V> the type of the values in this map\n@since 3.0\n", "original_string": "public class PredicatedSortedMap<K, V> extends PredicatedMap<K, V> implements SortedMap<K, V> {\n\n    /** Serialization version */\n    private static final long serialVersionUID = 3359846175935304332L;\n\n    /**\n     * Factory method to create a predicated (validating) sorted map.\n     * <p>\n     * If there are any elements already in the list being decorated, they\n     * are validated.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param map  the map to decorate, must not be null\n     * @param keyPredicate  the predicate to validate the keys, null means no check\n     * @param valuePredicate  the predicate to validate to values, null means no check\n     * @return a new predicated sorted map\n     * @throws NullPointerException if the map is null\n     * @since 4.0\n     */\n    public static <K, V> PredicatedSortedMap<K, V> predicatedSortedMap(final SortedMap<K, V> map,\n            final Predicate<? super K> keyPredicate, final Predicate<? super V> valuePredicate) {\n        return new PredicatedSortedMap<>(map, keyPredicate, valuePredicate);\n    }\n\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param map  the map to decorate, must not be null\n     * @param keyPredicate  the predicate to validate the keys, null means no check\n     * @param valuePredicate  the predicate to validate to values, null means no check\n     * @throws NullPointerException if the map is null\n     */\n    protected PredicatedSortedMap(final SortedMap<K, V> map, final Predicate<? super K> keyPredicate,\n            final Predicate<? super V> valuePredicate) {\n        super(map, keyPredicate, valuePredicate);\n    }\n\n    @Override\n    public Comparator<? super K> comparator() {\n        return getSortedMap().comparator();\n    }\n\n    @Override\n    public K firstKey() {\n        return getSortedMap().firstKey();\n    }\n\n    /**\n     * Gets the map being decorated.\n     *\n     * @return the decorated map\n     */\n    protected SortedMap<K, V> getSortedMap() {\n        return (SortedMap<K, V>) map;\n    }\n\n    @Override\n    public SortedMap<K, V> headMap(final K toKey) {\n        final SortedMap<K, V> map = getSortedMap().headMap(toKey);\n        return new PredicatedSortedMap<>(map, keyPredicate, valuePredicate);\n    }\n\n    @Override\n    public K lastKey() {\n        return getSortedMap().lastKey();\n    }\n\n    @Override\n    public SortedMap<K, V> subMap(final K fromKey, final K toKey) {\n        final SortedMap<K, V> map = getSortedMap().subMap(fromKey, toKey);\n        return new PredicatedSortedMap<>(map, keyPredicate, valuePredicate);\n    }\n\n    @Override\n    public SortedMap<K, V> tailMap(final K fromKey) {\n        final SortedMap<K, V> map = getSortedMap().tailMap(fromKey);\n        return new PredicatedSortedMap<>(map, keyPredicate, valuePredicate);\n    }\n\n}", "super_interfaces": ["SortedMap<K, V>"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 3359846175935304332L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 3359846175935304332L", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/map/CompositeMap.java.CompositeMap", "name": "CompositeMap", "file_path": "src/main/java/org/apache/commons/collections4/map/CompositeMap.java", "superclasses": "", "methods": ["[]CompositeMap()", "[]CompositeMap()", "[]CompositeMap(Map<K, V>,Map<K, V>)", "[]CompositeMap(Map<K, V>,Map<K, V>,MapMutator<K, V>)", "[]CompositeMap(Map<K, V>[],MapMutator<K, V>)", "[void]addComposited(Map<K, V>)", "[void]clear()", "[boolean]containsKey(Object)", "[boolean]containsValue(Object)", "[Set<Map.Entry<K, V>>]entrySet()", "[boolean]equals(Object)", "[V]get(Object)", "[int]hashCode()", "[boolean]isEmpty()", "[Set<K>]keySet()", "[V]put(K,V)", "[void]putAll(Map<? extends K, ? extends V>)", "[V]remove(Object)", "[Map<K, V>]removeComposited(Map<K, V>)", "[void]setMutator(MapMutator<K, V>)", "[int]size()", "[Collection<V>]values()"], "method_uris": ["src/main/java/org/apache/commons/collections4/map/CompositeMap.java.CompositeMap.[]CompositeMap()", "src/main/java/org/apache/commons/collections4/map/CompositeMap.java.CompositeMap.[]CompositeMap()", "src/main/java/org/apache/commons/collections4/map/CompositeMap.java.CompositeMap.[]CompositeMap(Map<K, V>,Map<K, V>)", "src/main/java/org/apache/commons/collections4/map/CompositeMap.java.CompositeMap.[]CompositeMap(Map<K, V>,Map<K, V>,MapMutator<K, V>)", "src/main/java/org/apache/commons/collections4/map/CompositeMap.java.CompositeMap.[]CompositeMap(Map<K, V>[],MapMutator<K, V>)", "src/main/java/org/apache/commons/collections4/map/CompositeMap.java.CompositeMap.[void]addComposited(Map<K, V>)", "src/main/java/org/apache/commons/collections4/map/CompositeMap.java.CompositeMap.[void]clear()", "src/main/java/org/apache/commons/collections4/map/CompositeMap.java.CompositeMap.[boolean]containsKey(Object)", "src/main/java/org/apache/commons/collections4/map/CompositeMap.java.CompositeMap.[boolean]containsValue(Object)", "src/main/java/org/apache/commons/collections4/map/CompositeMap.java.CompositeMap.[Set<Map.Entry<K, V>>]entrySet()", "src/main/java/org/apache/commons/collections4/map/CompositeMap.java.CompositeMap.[boolean]equals(Object)", "src/main/java/org/apache/commons/collections4/map/CompositeMap.java.CompositeMap.[V]get(Object)", "src/main/java/org/apache/commons/collections4/map/CompositeMap.java.CompositeMap.[int]hashCode()", "src/main/java/org/apache/commons/collections4/map/CompositeMap.java.CompositeMap.[boolean]isEmpty()", "src/main/java/org/apache/commons/collections4/map/CompositeMap.java.CompositeMap.[Set<K>]keySet()", "src/main/java/org/apache/commons/collections4/map/CompositeMap.java.CompositeMap.[V]put(K,V)", "src/main/java/org/apache/commons/collections4/map/CompositeMap.java.CompositeMap.[void]putAll(Map<? extends K, ? extends V>)", "src/main/java/org/apache/commons/collections4/map/CompositeMap.java.CompositeMap.[V]remove(Object)", "src/main/java/org/apache/commons/collections4/map/CompositeMap.java.CompositeMap.[Map<K, V>]removeComposited(Map<K, V>)", "src/main/java/org/apache/commons/collections4/map/CompositeMap.java.CompositeMap.[void]setMutator(MapMutator<K, V>)", "src/main/java/org/apache/commons/collections4/map/CompositeMap.java.CompositeMap.[int]size()", "src/main/java/org/apache/commons/collections4/map/CompositeMap.java.CompositeMap.[Collection<V>]values()"], "overrides": null, "attributes": [], "class_docstring": "\nDecorates a map of other maps to provide a single unified view.\n<p>\nChanges made to this map will actually be made on the decorated map.\nAdd and remove operations require the use of a pluggable strategy. If no\nstrategy is provided then add and remove are unsupported.\n</p>\n<p>\n<strong>Note that CompositeMap is not synchronized and is not thread-safe.</strong>\nIf you wish to use this map from multiple threads concurrently, you must use\nappropriate synchronization. The simplest approach is to wrap this map\nusing {@link java.util.Collections#synchronizedMap(Map)}. This class may throw\nexceptions when accessed by concurrent threads without synchronization.\n</p>\n\n@param <K> the type of the keys in this map\n@param <V> the type of the values in this map\n@since 3.0\n", "original_string": "public class CompositeMap<K, V> extends AbstractIterableMap<K, V> implements Serializable {\n\n    /**\n     * This interface allows definition for all of the indeterminate\n     * mutators in a CompositeMap, as well as providing a hook for\n     * callbacks on key collisions.\n     *\n     * @param <K> the type of the keys in the map\n     * @param <V> the type of the values in the map\n     */\n    public interface MapMutator<K, V> extends Serializable {\n        /**\n         * Called when the CompositeMap.put() method is invoked.\n         *\n         * @param map  the CompositeMap which is being modified\n         * @param composited  array of Maps in the CompositeMap being modified\n         * @param key  key with which the specified value is to be associated.\n         * @param value  value to be associated with the specified key.\n         * @return previous value associated with specified key, or {@code null}\n         *         if there was no mapping for key.  A {@code null} return can\n         *         also indicate that the map previously associated {@code null}\n         *         with the specified key, if the implementation supports\n         *         {@code null} values.\n         *\n         * @throws UnsupportedOperationException if not defined\n         * @throws ClassCastException if the class of the specified key or value\n         *            prevents it from being stored in this map.\n         * @throws IllegalArgumentException if some aspect of this key or value\n         *            prevents it from being stored in this map.\n         * @throws NullPointerException this map does not permit {@code null}\n         *            keys or values, and the specified key or value is\n         *            {@code null}.\n         */\n        V put(CompositeMap<K, V> map, Map<K, V>[] composited, K key, V value);\n\n        /**\n         * Called when the CompositeMap.putAll() method is invoked.\n         *\n         * @param map  the CompositeMap which is being modified\n         * @param composited  array of Maps in the CompositeMap being modified\n         * @param mapToAdd  Mappings to be stored in this CompositeMap\n         *\n         * @throws UnsupportedOperationException if not defined\n         * @throws ClassCastException if the class of the specified key or value\n         *            prevents it from being stored in this map.\n         * @throws IllegalArgumentException if some aspect of this key or value\n         *            prevents it from being stored in this map.\n         * @throws NullPointerException this map does not permit {@code null}\n         *            keys or values, and the specified key or value is\n         *            {@code null}.\n         */\n        void putAll(CompositeMap<K, V> map, Map<K, V>[] composited,\n                Map<? extends K, ? extends V> mapToAdd);\n\n        /**\n         * Called when adding a new Composited Map results in a\n         * key collision.\n         *\n         * @param composite  the CompositeMap with the collision\n         * @param existing  the Map already in the composite which contains the\n         *        offending key\n         * @param added  the Map being added\n         * @param intersect  the intersection of the keysets of the existing and added maps\n         */\n        void resolveCollision(CompositeMap<K, V> composite, Map<K, V> existing,\n                Map<K, V> added, Collection<K> intersect);\n    }\n\n    private static final Map[] EMPTY_MAP_ARRAY = {};\n\n    /** Serialization version */\n    private static final long serialVersionUID = -6096931280583808322L;\n\n    /** Array of all maps in the composite */\n    private Map<K, V>[] composite;\n\n    /** Handle mutation operations */\n    private MapMutator<K, V> mutator;\n\n    /**\n     * Create a new, empty, CompositeMap.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public CompositeMap() {\n        this(new Map[] {}, null);\n    }\n\n    /**\n     * Create a new CompositeMap which composites all of the Map instances in the\n     * argument. It copies the argument array, it does not use it directly.\n     *\n     * @param composite  the Maps to be composited\n     * @throws IllegalArgumentException if there is a key collision\n     */\n    public CompositeMap(final Map<K, V>... composite) {\n        this(composite, null);\n    }\n\n    /**\n     * Create a new CompositeMap with two composited Map instances.\n     *\n     * @param one  the first Map to be composited\n     * @param two  the second Map to be composited\n     * @throws IllegalArgumentException if there is a key collision\n     */\n    @SuppressWarnings(\"unchecked\")\n    public CompositeMap(final Map<K, V> one, final Map<K, V> two) {\n        this(new Map[] { one, two }, null);\n    }\n\n    /**\n     * Create a new CompositeMap with two composited Map instances.\n     *\n     * @param one  the first Map to be composited\n     * @param two  the second Map to be composited\n     * @param mutator  MapMutator to be used for mutation operations\n     */\n    @SuppressWarnings(\"unchecked\")\n    public CompositeMap(final Map<K, V> one, final Map<K, V> two, final MapMutator<K, V> mutator) {\n        this(new Map[] { one, two }, mutator);\n    }\n\n    /**\n     * Create a new CompositeMap which composites all of the Map instances in the\n     * argument. It copies the argument array, it does not use it directly.\n     *\n     * @param composite  Maps to be composited\n     * @param mutator  MapMutator to be used for mutation operations\n     */\n    @SuppressWarnings(\"unchecked\")\n    public CompositeMap(final Map<K, V>[] composite, final MapMutator<K, V> mutator) {\n        this.mutator = mutator;\n        this.composite = EMPTY_MAP_ARRAY;\n        for (int i = composite.length - 1; i >= 0; --i) {\n            this.addComposited(composite[i]);\n        }\n    }\n\n    /**\n     * Add an additional Map to the composite.\n     *\n     * @param map  the Map to be added to the composite\n     * @throws IllegalArgumentException if there is a key collision and there is no\n     *         MapMutator set to handle it.\n     */\n    public synchronized void addComposited(final Map<K, V> map) throws IllegalArgumentException {\n        if (map != null) {\n            for (int i = composite.length - 1; i >= 0; --i) {\n                final Collection<K> intersect = CollectionUtils.intersection(composite[i].keySet(), map.keySet());\n                if (!intersect.isEmpty()) {\n                    if (mutator == null) {\n                        throw new IllegalArgumentException(\"Key collision adding Map to CompositeMap\");\n                    }\n                    mutator.resolveCollision(this, composite[i], map, intersect);\n                }\n            }\n            final Map<K, V>[] temp = Arrays.copyOf(composite, composite.length + 1);\n            temp[temp.length - 1] = map;\n            composite = temp;\n        }\n    }\n\n    /**\n     * Calls {@code clear()} on all composited Maps.\n     *\n     * @throws UnsupportedOperationException if any of the composited Maps do not support clear()\n     */\n    @Override\n    public void clear() {\n        for (int i = composite.length - 1; i >= 0; --i) {\n            composite[i].clear();\n        }\n    }\n\n    /**\n     * Returns {@code true} if this map contains a mapping for the specified\n     * key.  More formally, returns {@code true} if and only if\n     * this map contains at a mapping for a key {@code k} such that\n     * {@code (key==null ? k==null : key.equals(k))}.  (There can be\n     * at most one such mapping.)\n     *\n     * @param key  key whose presence in this map is to be tested.\n     * @return {@code true} if this map contains a mapping for the specified\n     *         key.\n     *\n     * @throws ClassCastException if the key is of an inappropriate type for\n     *         this map (optional).\n     * @throws NullPointerException if the key is {@code null} and this map\n     *            does not permit {@code null} keys (optional).\n     */\n    @Override\n    public boolean containsKey(final Object key) {\n        for (int i = composite.length - 1; i >= 0; --i) {\n            if (composite[i].containsKey(key)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Returns {@code true} if this map maps one or more keys to the\n     * specified value.  More formally, returns {@code true} if and only if\n     * this map contains at least one mapping to a value {@code v} such that\n     * {@code (value==null ? v==null : value.equals(v))}.  This operation\n     * will probably require time linear in the map size for most\n     * implementations of the {@code Map} interface.\n     *\n     * @param value value whose presence in this map is to be tested.\n     * @return {@code true} if this map maps one or more keys to the\n     *         specified value.\n     * @throws ClassCastException if the value is of an inappropriate type for\n     *         this map (optional).\n     * @throws NullPointerException if the value is {@code null} and this map\n     *            does not permit {@code null} values (optional).\n     */\n    @Override\n    public boolean containsValue(final Object value) {\n        for (int i = composite.length - 1; i >= 0; --i) {\n            if (composite[i].containsValue(value)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Returns a set view of the mappings contained in this map.  Each element\n     * in the returned set is a {@code Map.Entry}.  The set is backed by the\n     * map, so changes to the map are reflected in the set, and vice-versa.\n     * If the map is modified while an iteration over the set is in progress,\n     * the results of the iteration are undefined.  The set supports element\n     * removal, which removes the corresponding mapping from the map, via the\n     * {@code Iterator.remove}, {@code Set.remove}, {@code removeAll},\n     * {@code retainAll} and {@code clear} operations.  It does not support\n     * the {@code add} or {@code addAll} operations.\n     * <p>\n     * This implementation returns a {@code CompositeSet} which\n     * composites the entry sets from all of the composited maps.\n     *\n     * @see CompositeSet\n     * @return a set view of the mappings contained in this map.\n     */\n    @Override\n    public Set<Map.Entry<K, V>> entrySet() {\n        final CompositeSet<Map.Entry<K, V>> entries = new CompositeSet<>();\n        for (int i = composite.length - 1; i >= 0; --i) {\n            entries.addComposited(composite[i].entrySet());\n        }\n        return entries;\n    }\n\n    /**\n     * Checks if this Map equals another as per the Map specification.\n     *\n     * @param obj  the object to compare to\n     * @return true if the maps are equal\n     */\n    @Override\n    public boolean equals(final Object obj) {\n        if (obj instanceof Map) {\n            final Map<?, ?> map = (Map<?, ?>) obj;\n            return this.entrySet().equals(map.entrySet());\n        }\n        return false;\n    }\n\n    /**\n     * Returns the value to which this map maps the specified key.  Returns\n     * {@code null} if the map contains no mapping for this key.  A return\n     * value of {@code null} does not <em>necessarily</em> indicate that the\n     * map contains no mapping for the key; it's also possible that the map\n     * explicitly maps the key to {@code null}.  The {@code containsKey}\n     * operation may be used to distinguish these two cases.\n     *\n     * <p>More formally, if this map contains a mapping from a key\n     * {@code k} to a value {@code v} such that {@code (key==null ? k==null :\n     * key.equals(k))}, then this method returns {@code v}; otherwise\n     * it returns {@code null}.  (There can be at most one such mapping.)\n     *\n     * @param key key whose associated value is to be returned.\n     * @return the value to which this map maps the specified key, or\n     *         {@code null} if the map contains no mapping for this key.\n     *\n     * @throws ClassCastException if the key is of an inappropriate type for\n     *         this map (optional).\n     * @throws NullPointerException key is {@code null} and this map does\n     *         not permit {@code null} keys (optional).\n     *\n     * @see #containsKey(Object)\n     */\n    @Override\n    public V get(final Object key) {\n        for (int i = composite.length - 1; i >= 0; --i) {\n            if (composite[i].containsKey(key)) {\n                return composite[i].get(key);\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Gets a hash code for the Map as per the Map specification.\n     * {@inheritDoc}\n     */\n    @Override\n    public int hashCode() {\n        int code = 0;\n        for (final Map.Entry<K, V> entry : entrySet()) {\n            code += entry.hashCode();\n        }\n        return code;\n    }\n\n    /**\n     * Returns {@code true} if this map contains no key-value mappings.\n     *\n     * @return {@code true} if this map contains no key-value mappings.\n     */\n    @Override\n    public boolean isEmpty() {\n        for (int i = composite.length - 1; i >= 0; --i) {\n            if (!composite[i].isEmpty()) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns a set view of the keys contained in this map.  The set is\n     * backed by the map, so changes to the map are reflected in the set, and\n     * vice-versa.  If the map is modified while an iteration over the set is\n     * in progress, the results of the iteration are undefined.  The set\n     * supports element removal, which removes the corresponding mapping from\n     * the map, via the {@code Iterator.remove}, {@code Set.remove},\n     * {@code removeAll} {@code retainAll}, and {@code clear} operations.\n     * It does not support the add or {@code addAll} operations.\n     * <p>\n     * This implementation returns a {@code CompositeSet} which\n     * composites the key sets from all of the composited maps.\n     *\n     * @return a set view of the keys contained in this map.\n     */\n    @Override\n    public Set<K> keySet() {\n        final CompositeSet<K> keys = new CompositeSet<>();\n        for (int i = composite.length - 1; i >= 0; --i) {\n            keys.addComposited(composite[i].keySet());\n        }\n        return keys;\n    }\n\n    /**\n     * Associates the specified value with the specified key in this map\n     * (optional operation).  If the map previously contained a mapping for\n     * this key, the old value is replaced by the specified value.  (A map\n     * {@code m} is said to contain a mapping for a key {@code k} if and only\n     * if {@link #containsKey(Object) m.containsKey(k)} would return\n     * {@code true}.))\n     *\n     * @param key key with which the specified value is to be associated.\n     * @param value value to be associated with the specified key.\n     * @return previous value associated with specified key, or {@code null}\n     *         if there was no mapping for key.  A {@code null} return can\n     *         also indicate that the map previously associated {@code null}\n     *         with the specified key, if the implementation supports\n     *         {@code null} values.\n     *\n     * @throws UnsupportedOperationException if no MapMutator has been specified\n     * @throws ClassCastException if the class of the specified key or value\n     *            prevents it from being stored in this map.\n     * @throws IllegalArgumentException if some aspect of this key or value\n     *            prevents it from being stored in this map.\n     * @throws NullPointerException this map does not permit {@code null}\n     *            keys or values, and the specified key or value is\n     *            {@code null}.\n     */\n    @Override\n    public V put(final K key, final V value) {\n        if (mutator == null) {\n            throw new UnsupportedOperationException(\"No mutator specified\");\n        }\n        return mutator.put(this, composite, key, value);\n    }\n\n    /**\n     * Copies all of the mappings from the specified map to this map\n     * (optional operation).  The effect of this call is equivalent to that\n     * of calling {@link #put(Object,Object) put(k, v)} on this map once\n     * for each mapping from key {@code k} to value {@code v} in the\n     * specified map.  The behavior of this operation is unspecified if the\n     * specified map is modified while the operation is in progress.\n     *\n     * @param map Mappings to be stored in this map.\n     *\n     * @throws UnsupportedOperationException if the {@code putAll} method is\n     *         not supported by this map.\n     *\n     * @throws ClassCastException if the class of a key or value in the\n     *         specified map prevents it from being stored in this map.\n     *\n     * @throws IllegalArgumentException some aspect of a key or value in the\n     *         specified map prevents it from being stored in this map.\n     * @throws NullPointerException the specified map is {@code null}, or if\n     *         this map does not permit {@code null} keys or values, and the\n     *         specified map contains {@code null} keys or values.\n     */\n    @Override\n    public void putAll(final Map<? extends K, ? extends V> map) {\n        if (mutator == null) {\n            throw new UnsupportedOperationException(\"No mutator specified\");\n        }\n        mutator.putAll(this, composite, map);\n    }\n\n    /**\n     * Removes the mapping for this key from this map if it is present\n     * (optional operation).   More formally, if this map contains a mapping\n     * from key {@code k} to value {@code v} such that\n     * {@code (key==null ?  k==null : key.equals(k))}, that mapping\n     * is removed.  (The map can contain at most one such mapping.)\n     *\n     * <p>Returns the value to which the map previously associated the key, or\n     * {@code null} if the map contained no mapping for this key.  (A\n     * {@code null} return can also indicate that the map previously\n     * associated {@code null} with the specified key if the implementation\n     * supports {@code null} values.)  The map will not contain a mapping for\n     * the specified  key once the call returns.\n     *\n     * @param key key whose mapping is to be removed from the map.\n     * @return previous value associated with specified key, or {@code null}\n     *         if there was no mapping for key.\n     *\n     * @throws ClassCastException if the key is of an inappropriate type for\n     *         the composited map (optional).\n     * @throws NullPointerException if the key is {@code null} and the composited map\n     *            does not permit {@code null} keys (optional).\n     * @throws UnsupportedOperationException if the {@code remove} method is\n     *         not supported by the composited map containing the key\n     */\n    @Override\n    public V remove(final Object key) {\n        for (int i = composite.length - 1; i >= 0; --i) {\n            if (composite[i].containsKey(key)) {\n                return composite[i].remove(key);\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Remove a Map from the composite.\n     *\n     * @param map  the Map to be removed from the composite\n     * @return The removed Map or {@code null} if map is not in the composite\n     */\n    @SuppressWarnings(\"unchecked\")\n    public synchronized Map<K, V> removeComposited(final Map<K, V> map) {\n        final int size = composite.length;\n        for (int i = 0; i < size; ++i) {\n            if (composite[i].equals(map)) {\n                final Map<K, V>[] temp = new Map[size - 1];\n                System.arraycopy(composite, 0, temp, 0, i);\n                System.arraycopy(composite, i + 1, temp, i, size - i - 1);\n                composite = temp;\n                return map;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Specify the MapMutator to be used by mutation operations.\n     *\n     * @param mutator  the MapMutator to be used for mutation delegation\n     */\n    public void setMutator(final MapMutator<K, V> mutator) {\n        this.mutator = mutator;\n    }\n\n    /**\n     * Returns the number of key-value mappings in this map.  If the\n     * map contains more than {@code Integer.MAX_VALUE} elements, returns\n     * {@code Integer.MAX_VALUE}.\n     *\n     * @return the number of key-value mappings in this map.\n     */\n    @Override\n    public int size() {\n        int size = 0;\n        for (int i = composite.length - 1; i >= 0; --i) {\n            size += composite[i].size();\n        }\n        return size;\n    }\n\n    /**\n     * Returns a collection view of the values contained in this map.  The\n     * collection is backed by the map, so changes to the map are reflected in\n     * the collection, and vice-versa.  If the map is modified while an\n     * iteration over the collection is in progress, the results of the\n     * iteration are undefined.  The collection supports element removal,\n     * which removes the corresponding mapping from the map, via the\n     * {@code Iterator.remove}, {@code Collection.remove},\n     * {@code removeAll}, {@code retainAll} and {@code clear} operations.\n     * It does not support the add or {@code addAll} operations.\n     *\n     * @return a collection view of the values contained in this map.\n     */\n    @Override\n    public Collection<V> values() {\n        final CompositeCollection<V> values = new CompositeCollection<>();\n        for (int i = composite.length - 1; i >= 0; --i) {\n            values.addComposited(composite[i].values());\n        }\n        return values;\n    }\n}", "super_interfaces": ["Serializable"], "fields": [{"attribute_expression": "private static final Map[] EMPTY_MAP_ARRAY = {};", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Map[]", "name": "EMPTY_MAP_ARRAY = {}", "syntax_pass": true}, {"attribute_expression": "private static final long serialVersionUID = -6096931280583808322L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -6096931280583808322L", "syntax_pass": true}, {"attribute_expression": "private Map<K, V>[] composite;", "docstring": " Array of all maps in the composite", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Map<K, V>[]", "name": "composite", "syntax_pass": true}, {"attribute_expression": "private MapMutator<K, V> mutator;", "docstring": " Handle mutation operations", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "MapMutator<K, V>", "name": "mutator", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/map/MultiKeyMap.java.MultiKeyMap", "name": "MultiKeyMap", "file_path": "src/main/java/org/apache/commons/collections4/map/MultiKeyMap.java", "superclasses": "", "methods": ["[MultiKeyMap<K, V>]multiKeyMap(AbstractHashedMap<MultiKey<? extends K>, V>)", "[]MultiKeyMap()", "[]MultiKeyMap(AbstractHashedMap<MultiKey<? extends K>, V>)", "[void]checkKey(MultiKey<?>)", "[MultiKeyMap<K, V>]clone()", "[boolean]containsKey(Object,Object)", "[boolean]containsKey(Object,Object,Object)", "[boolean]containsKey(Object,Object,Object,Object)", "[boolean]containsKey(Object,Object,Object,Object,Object)", "[AbstractHashedMap<MultiKey<? extends K>, V>]decorated()", "[V]get(Object,Object)", "[V]get(Object,Object,Object)", "[V]get(Object,Object,Object,Object)", "[V]get(Object,Object,Object,Object,Object)", "[int]hash(Object,Object)", "[int]hash(Object,Object,Object)", "[int]hash(Object,Object,Object,Object)", "[int]hash(Object,Object,Object,Object,Object)", "[boolean]isEqualKey(AbstractHashedMap.HashEntry<MultiKey<? extends K>, V>,Object,Object)", "[boolean]isEqualKey(AbstractHashedMap.HashEntry<MultiKey<? extends K>, V>,Object,Object,Object)", "[boolean]isEqualKey(AbstractHashedMap.HashEntry<MultiKey<? extends K>, V>,Object,Object,Object,Object)", "[boolean]isEqualKey(AbstractHashedMap.HashEntry<MultiKey<? extends K>, V>,Object,Object,Object,Object,Object)", "[MapIterator<MultiKey<? extends K>, V>]mapIterator()", "[V]put(K,K,K,K,K,V)", "[V]put(K,K,K,K,V)", "[V]put(K,K,K,V)", "[V]put(K,K,V)", "[V]put(MultiKey<? extends K>,V)", "[void]putAll(Map<? extends MultiKey<? extends K>, ? extends V>)", "[void]readObject(ObjectInputStream)", "[boolean]removeAll(Object)", "[boolean]removeAll(Object,Object)", "[boolean]removeAll(Object,Object,Object)", "[boolean]removeAll(Object,Object,Object,Object)", "[V]removeMultiKey(Object,Object)", "[V]removeMultiKey(Object,Object,Object)", "[V]removeMultiKey(Object,Object,Object,Object)", "[V]removeMultiKey(Object,Object,Object,Object,Object)", "[void]writeObject(ObjectOutputStream)"], "method_uris": ["src/main/java/org/apache/commons/collections4/map/MultiKeyMap.java.MultiKeyMap.[MultiKeyMap<K, V>]multiKeyMap(AbstractHashedMap<MultiKey<? extends K>, V>)", "src/main/java/org/apache/commons/collections4/map/MultiKeyMap.java.MultiKeyMap.[]MultiKeyMap()", "src/main/java/org/apache/commons/collections4/map/MultiKeyMap.java.MultiKeyMap.[]MultiKeyMap(AbstractHashedMap<MultiKey<? extends K>, V>)", "src/main/java/org/apache/commons/collections4/map/MultiKeyMap.java.MultiKeyMap.[void]checkKey(MultiKey<?>)", "src/main/java/org/apache/commons/collections4/map/MultiKeyMap.java.MultiKeyMap.[MultiKeyMap<K, V>]clone()", "src/main/java/org/apache/commons/collections4/map/MultiKeyMap.java.MultiKeyMap.[boolean]containsKey(Object,Object)", "src/main/java/org/apache/commons/collections4/map/MultiKeyMap.java.MultiKeyMap.[boolean]containsKey(Object,Object,Object)", "src/main/java/org/apache/commons/collections4/map/MultiKeyMap.java.MultiKeyMap.[boolean]containsKey(Object,Object,Object,Object)", "src/main/java/org/apache/commons/collections4/map/MultiKeyMap.java.MultiKeyMap.[boolean]containsKey(Object,Object,Object,Object,Object)", "src/main/java/org/apache/commons/collections4/map/MultiKeyMap.java.MultiKeyMap.[AbstractHashedMap<MultiKey<? extends K>, V>]decorated()", "src/main/java/org/apache/commons/collections4/map/MultiKeyMap.java.MultiKeyMap.[V]get(Object,Object)", "src/main/java/org/apache/commons/collections4/map/MultiKeyMap.java.MultiKeyMap.[V]get(Object,Object,Object)", "src/main/java/org/apache/commons/collections4/map/MultiKeyMap.java.MultiKeyMap.[V]get(Object,Object,Object,Object)", "src/main/java/org/apache/commons/collections4/map/MultiKeyMap.java.MultiKeyMap.[V]get(Object,Object,Object,Object,Object)", "src/main/java/org/apache/commons/collections4/map/MultiKeyMap.java.MultiKeyMap.[int]hash(Object,Object)", "src/main/java/org/apache/commons/collections4/map/MultiKeyMap.java.MultiKeyMap.[int]hash(Object,Object,Object)", "src/main/java/org/apache/commons/collections4/map/MultiKeyMap.java.MultiKeyMap.[int]hash(Object,Object,Object,Object)", "src/main/java/org/apache/commons/collections4/map/MultiKeyMap.java.MultiKeyMap.[int]hash(Object,Object,Object,Object,Object)", "src/main/java/org/apache/commons/collections4/map/MultiKeyMap.java.MultiKeyMap.[boolean]isEqualKey(AbstractHashedMap.HashEntry<MultiKey<? extends K>, V>,Object,Object)", "src/main/java/org/apache/commons/collections4/map/MultiKeyMap.java.MultiKeyMap.[boolean]isEqualKey(AbstractHashedMap.HashEntry<MultiKey<? extends K>, V>,Object,Object,Object)", "src/main/java/org/apache/commons/collections4/map/MultiKeyMap.java.MultiKeyMap.[boolean]isEqualKey(AbstractHashedMap.HashEntry<MultiKey<? extends K>, V>,Object,Object,Object,Object)", "src/main/java/org/apache/commons/collections4/map/MultiKeyMap.java.MultiKeyMap.[boolean]isEqualKey(AbstractHashedMap.HashEntry<MultiKey<? extends K>, V>,Object,Object,Object,Object,Object)", "src/main/java/org/apache/commons/collections4/map/MultiKeyMap.java.MultiKeyMap.[MapIterator<MultiKey<? extends K>, V>]mapIterator()", "src/main/java/org/apache/commons/collections4/map/MultiKeyMap.java.MultiKeyMap.[V]put(K,K,K,K,K,V)", "src/main/java/org/apache/commons/collections4/map/MultiKeyMap.java.MultiKeyMap.[V]put(K,K,K,K,V)", "src/main/java/org/apache/commons/collections4/map/MultiKeyMap.java.MultiKeyMap.[V]put(K,K,K,V)", "src/main/java/org/apache/commons/collections4/map/MultiKeyMap.java.MultiKeyMap.[V]put(K,K,V)", "src/main/java/org/apache/commons/collections4/map/MultiKeyMap.java.MultiKeyMap.[V]put(MultiKey<? extends K>,V)", "src/main/java/org/apache/commons/collections4/map/MultiKeyMap.java.MultiKeyMap.[void]putAll(Map<? extends MultiKey<? extends K>, ? extends V>)", "src/main/java/org/apache/commons/collections4/map/MultiKeyMap.java.MultiKeyMap.[void]readObject(ObjectInputStream)", "src/main/java/org/apache/commons/collections4/map/MultiKeyMap.java.MultiKeyMap.[boolean]removeAll(Object)", "src/main/java/org/apache/commons/collections4/map/MultiKeyMap.java.MultiKeyMap.[boolean]removeAll(Object,Object)", "src/main/java/org/apache/commons/collections4/map/MultiKeyMap.java.MultiKeyMap.[boolean]removeAll(Object,Object,Object)", "src/main/java/org/apache/commons/collections4/map/MultiKeyMap.java.MultiKeyMap.[boolean]removeAll(Object,Object,Object,Object)", "src/main/java/org/apache/commons/collections4/map/MultiKeyMap.java.MultiKeyMap.[V]removeMultiKey(Object,Object)", "src/main/java/org/apache/commons/collections4/map/MultiKeyMap.java.MultiKeyMap.[V]removeMultiKey(Object,Object,Object)", "src/main/java/org/apache/commons/collections4/map/MultiKeyMap.java.MultiKeyMap.[V]removeMultiKey(Object,Object,Object,Object)", "src/main/java/org/apache/commons/collections4/map/MultiKeyMap.java.MultiKeyMap.[V]removeMultiKey(Object,Object,Object,Object,Object)", "src/main/java/org/apache/commons/collections4/map/MultiKeyMap.java.MultiKeyMap.[void]writeObject(ObjectOutputStream)"], "overrides": null, "attributes": [], "class_docstring": "\nA {@code Map} implementation that uses multiple keys to map the value.\n<p>\nThis class is the most efficient way to uses multiple keys to map to a value.\nThe best way to use this class is via the additional map-style methods.\nThese provide {@code get}, {@code containsKey}, {@code put} and\n{@code remove} for individual keys which operate without extra object creation.\n</p>\n<p>\nThe additional methods are the main interface of this map.\nAs such, you will not normally hold this map in a variable of type {@code Map}.\n</p>\n<p>\nThe normal map methods take in and return a {@link MultiKey}.\nIf you try to use {@code put()} with any other object type a\n{@code ClassCastException} is thrown. If you try to use {@code null} as\nthe key in {@code put()} a {@code NullPointerException} is thrown.\n</p>\n<p>\nThis map is implemented as a decorator of a {@code AbstractHashedMap} which\nenables extra behavior to be added easily.\n</p>\n<ul>\n<li>{@code MultiKeyMap.decorate(new LinkedMap())} creates an ordered map.\n<li>{@code MultiKeyMap.decorate(new LRUMap())} creates an least recently used map.\n<li>{@code MultiKeyMap.decorate(new ReferenceMap())} creates a garbage collector sensitive map.\n</ul>\n<p>\nNote that {@code IdentityMap} and {@code ReferenceIdentityMap} are unsuitable\nfor use as the key comparison would work on the whole MultiKey, not the elements within.\n</p>\n<p>\nAs an example, consider a least recently used cache that uses a String airline code\nand a Locale to lookup the airline's name:\n</p>\n<pre>\nprivate MultiKeyMap cache = MultiKeyMap.multiKeyMap(new LRUMap(50));\n\npublic String getAirlineName(String code, String locale) {\n  String name = (String) cache.get(code, locale);\n  if (name == null) {\n    name = getAirlineNameFromDB(code, locale);\n    cache.put(code, locale, name);\n  }\n  return name;\n}\n</pre>\n<p>\n<strong>Note that MultiKeyMap is not synchronized and is not thread-safe.</strong>\nIf you wish to use this map from multiple threads concurrently, you must use\nappropriate synchronization. This class may throw exceptions when accessed\nby concurrent threads without synchronization.\n</p>\n\n@param <K> the type of the keys in this map\n@param <V> the type of the values in this map\n@since 3.1\n", "original_string": "public class MultiKeyMap<K, V> extends AbstractMapDecorator<MultiKey<? extends K>, V>\n        implements Serializable, Cloneable {\n\n    /** Serialisation version */\n    private static final long serialVersionUID = -1788199231038721040L;\n\n    /**\n     * Decorates the specified map to add the MultiKeyMap API and fast query.\n     * The map must not be null and must be empty.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param map  the map to decorate, not null\n     * @return a new multi key map\n     * @throws NullPointerException if map is null\n     * @throws IllegalArgumentException if the map is not empty\n     * @since 4.0\n     */\n    public static <K, V> MultiKeyMap<K, V> multiKeyMap(final AbstractHashedMap<MultiKey<? extends K>, V> map) {\n        Objects.requireNonNull(map, \"map\");\n        if (map.isEmpty()) {\n            return new MultiKeyMap<>(map);\n        }\n        throw new IllegalArgumentException(\"Map must be empty\");\n    }\n\n    /**\n     * Constructs a new MultiKeyMap that decorates a {@code HashedMap}.\n     */\n    public MultiKeyMap() {\n        this(new HashedMap<>());\n    }\n\n    /**\n     * Constructor that decorates the specified map and is called from\n     * {@link #multiKeyMap(AbstractHashedMap)}.\n     * The map must not be null and should be empty or only contain valid keys.\n     * This constructor performs no validation.\n     *\n     * @param map  the map to decorate\n     */\n    protected MultiKeyMap(final AbstractHashedMap<MultiKey<? extends K>, V> map) {\n        super(map);\n        this.map = map;\n    }\n\n    /**\n     * Check to ensure that input keys are valid MultiKey objects.\n     *\n     * @param key  the key to check\n     */\n    protected void checkKey(final MultiKey<?> key) {\n        Objects.requireNonNull(key, \"key\");\n    }\n\n    /**\n     * Clones the map without cloning the keys or values.\n     *\n     * @return a shallow clone\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public MultiKeyMap<K, V> clone() {\n        try {\n            return (MultiKeyMap<K, V>) super.clone();\n        } catch (final CloneNotSupportedException e) {\n            throw new UnsupportedOperationException(e);\n        }\n    }\n\n    /**\n     * Checks whether the map contains the specified multi-key.\n     *\n     * @param key1  the first key\n     * @param key2  the second key\n     * @return true if the map contains the key\n     */\n    public boolean containsKey(final Object key1, final Object key2) {\n        final int hashCode = hash(key1, key2);\n        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry =\n                decorated().data[decorated().hashIndex(hashCode, decorated().data.length)];\n        while (entry != null) {\n            if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2)) {\n                return true;\n            }\n            entry = entry.next;\n        }\n        return false;\n    }\n\n    /**\n     * Checks whether the map contains the specified multi-key.\n     *\n     * @param key1  the first key\n     * @param key2  the second key\n     * @param key3  the third key\n     * @return true if the map contains the key\n     */\n    public boolean containsKey(final Object key1, final Object key2, final Object key3) {\n        final int hashCode = hash(key1, key2, key3);\n        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry =\n                decorated().data[decorated().hashIndex(hashCode, decorated().data.length)];\n        while (entry != null) {\n            if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3)) {\n                return true;\n            }\n            entry = entry.next;\n        }\n        return false;\n    }\n\n    /**\n     * Checks whether the map contains the specified multi-key.\n     *\n     * @param key1  the first key\n     * @param key2  the second key\n     * @param key3  the third key\n     * @param key4  the fourth key\n     * @return true if the map contains the key\n     */\n    public boolean containsKey(final Object key1, final Object key2, final Object key3, final Object key4) {\n        final int hashCode = hash(key1, key2, key3, key4);\n        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry =\n                decorated().data[decorated().hashIndex(hashCode, decorated().data.length)];\n        while (entry != null) {\n            if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3, key4)) {\n                return true;\n            }\n            entry = entry.next;\n        }\n        return false;\n    }\n\n    /**\n     * Checks whether the map contains the specified multi-key.\n     *\n     * @param key1  the first key\n     * @param key2  the second key\n     * @param key3  the third key\n     * @param key4  the fourth key\n     * @param key5  the fifth key\n     * @return true if the map contains the key\n     */\n    public boolean containsKey(final Object key1, final Object key2, final Object key3,\n                               final Object key4, final Object key5) {\n        final int hashCode = hash(key1, key2, key3, key4, key5);\n        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry =\n                decorated().data[decorated().hashIndex(hashCode, decorated().data.length)];\n        while (entry != null) {\n            if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3, key4, key5)) {\n                return true;\n            }\n            entry = entry.next;\n        }\n        return false;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    protected AbstractHashedMap<MultiKey<? extends K>, V> decorated() {\n        return (AbstractHashedMap<MultiKey<? extends K>, V>) super.decorated();\n    }\n\n    /**\n     * Gets the value mapped to the specified multi-key.\n     *\n     * @param key1  the first key\n     * @param key2  the second key\n     * @return the mapped value, null if no match\n     */\n    public V get(final Object key1, final Object key2) {\n        final int hashCode = hash(key1, key2);\n        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry =\n                decorated().data[decorated().hashIndex(hashCode, decorated().data.length)];\n        while (entry != null) {\n            if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2)) {\n                return entry.getValue();\n            }\n            entry = entry.next;\n        }\n        return null;\n    }\n\n    /**\n     * Gets the value mapped to the specified multi-key.\n     *\n     * @param key1  the first key\n     * @param key2  the second key\n     * @param key3  the third key\n     * @return the mapped value, null if no match\n     */\n    public V get(final Object key1, final Object key2, final Object key3) {\n        final int hashCode = hash(key1, key2, key3);\n        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry =\n                decorated().data[decorated().hashIndex(hashCode, decorated().data.length)];\n        while (entry != null) {\n            if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3)) {\n                return entry.getValue();\n            }\n            entry = entry.next;\n        }\n        return null;\n    }\n\n    /**\n     * Gets the value mapped to the specified multi-key.\n     *\n     * @param key1  the first key\n     * @param key2  the second key\n     * @param key3  the third key\n     * @param key4  the fourth key\n     * @return the mapped value, null if no match\n     */\n    public V get(final Object key1, final Object key2, final Object key3, final Object key4) {\n        final int hashCode = hash(key1, key2, key3, key4);\n        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry =\n                decorated().data[decorated().hashIndex(hashCode, decorated().data.length)];\n        while (entry != null) {\n            if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3, key4)) {\n                return entry.getValue();\n            }\n            entry = entry.next;\n        }\n        return null;\n    }\n\n    /**\n     * Gets the value mapped to the specified multi-key.\n     *\n     * @param key1  the first key\n     * @param key2  the second key\n     * @param key3  the third key\n     * @param key4  the fourth key\n     * @param key5  the fifth key\n     * @return the mapped value, null if no match\n     */\n    public V get(final Object key1, final Object key2, final Object key3, final Object key4, final Object key5) {\n        final int hashCode = hash(key1, key2, key3, key4, key5);\n        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry =\n                decorated().data[decorated().hashIndex(hashCode, decorated().data.length)];\n        while (entry != null) {\n            if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3, key4, key5)) {\n                return entry.getValue();\n            }\n            entry = entry.next;\n        }\n        return null;\n    }\n\n    /**\n     * Gets the hash code for the specified multi-key.\n     *\n     * @param key1  the first key\n     * @param key2  the second key\n     * @return the hash code\n     */\n    protected int hash(final Object key1, final Object key2) {\n        int h = 0;\n        if (key1 != null) {\n            h ^= key1.hashCode();\n        }\n        if (key2 != null) {\n            h ^= key2.hashCode();\n        }\n        h += ~(h << 9);\n        h ^=  h >>> 14;\n        h +=  h << 4;\n        h ^=  h >>> 10;\n        return h;\n    }\n\n    /**\n     * Gets the hash code for the specified multi-key.\n     *\n     * @param key1  the first key\n     * @param key2  the second key\n     * @param key3  the third key\n     * @return the hash code\n     */\n    protected int hash(final Object key1, final Object key2, final Object key3) {\n        int h = 0;\n        if (key1 != null) {\n            h ^= key1.hashCode();\n        }\n        if (key2 != null) {\n            h ^= key2.hashCode();\n        }\n        if (key3 != null) {\n            h ^= key3.hashCode();\n        }\n        h += ~(h << 9);\n        h ^=  h >>> 14;\n        h +=  h << 4;\n        h ^=  h >>> 10;\n        return h;\n    }\n\n    /**\n     * Gets the hash code for the specified multi-key.\n     *\n     * @param key1  the first key\n     * @param key2  the second key\n     * @param key3  the third key\n     * @param key4  the fourth key\n     * @return the hash code\n     */\n    protected int hash(final Object key1, final Object key2, final Object key3, final Object key4) {\n        int h = 0;\n        if (key1 != null) {\n            h ^= key1.hashCode();\n        }\n        if (key2 != null) {\n            h ^= key2.hashCode();\n        }\n        if (key3 != null) {\n            h ^= key3.hashCode();\n        }\n        if (key4 != null) {\n            h ^= key4.hashCode();\n        }\n        h += ~(h << 9);\n        h ^=  h >>> 14;\n        h +=  h << 4;\n        h ^=  h >>> 10;\n        return h;\n    }\n\n    /**\n     * Gets the hash code for the specified multi-key.\n     *\n     * @param key1  the first key\n     * @param key2  the second key\n     * @param key3  the third key\n     * @param key4  the fourth key\n     * @param key5  the fifth key\n     * @return the hash code\n     */\n    protected int hash(final Object key1, final Object key2, final Object key3, final Object key4, final Object key5) {\n        int h = 0;\n        if (key1 != null) {\n            h ^= key1.hashCode();\n        }\n        if (key2 != null) {\n            h ^= key2.hashCode();\n        }\n        if (key3 != null) {\n            h ^= key3.hashCode();\n        }\n        if (key4 != null) {\n            h ^= key4.hashCode();\n        }\n        if (key5 != null) {\n            h ^= key5.hashCode();\n        }\n        h += ~(h << 9);\n        h ^=  h >>> 14;\n        h +=  h << 4;\n        h ^=  h >>> 10;\n        return h;\n    }\n\n    /**\n     * Is the key equal to the combined key.\n     *\n     * @param entry  the entry to compare to\n     * @param key1  the first key\n     * @param key2  the second key\n     * @return true if the key matches\n     */\n    protected boolean isEqualKey(final AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry,\n            final Object key1, final Object key2) {\n        final MultiKey<? extends K> multi = entry.getKey();\n        return\n            multi.size() == 2 &&\n            (key1 == multi.getKey(0) || key1 != null && key1.equals(multi.getKey(0))) &&\n            (key2 == multi.getKey(1) || key2 != null && key2.equals(multi.getKey(1)));\n    }\n\n    /**\n     * Is the key equal to the combined key.\n     *\n     * @param entry  the entry to compare to\n     * @param key1  the first key\n     * @param key2  the second key\n     * @param key3  the third key\n     * @return true if the key matches\n     */\n    protected boolean isEqualKey(final AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry,\n                                 final Object key1, final Object key2, final Object key3) {\n        final MultiKey<? extends K> multi = entry.getKey();\n        return\n            multi.size() == 3 &&\n            (key1 == multi.getKey(0) || key1 != null && key1.equals(multi.getKey(0))) &&\n            (key2 == multi.getKey(1) || key2 != null && key2.equals(multi.getKey(1))) &&\n            (key3 == multi.getKey(2) || key3 != null && key3.equals(multi.getKey(2)));\n    }\n\n    /**\n     * Is the key equal to the combined key.\n     *\n     * @param entry  the entry to compare to\n     * @param key1  the first key\n     * @param key2  the second key\n     * @param key3  the third key\n     * @param key4  the fourth key\n     * @return true if the key matches\n     */\n    protected boolean isEqualKey(final AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry,\n                                 final Object key1, final Object key2, final Object key3, final Object key4) {\n        final MultiKey<? extends K> multi = entry.getKey();\n        return\n            multi.size() == 4 &&\n            (key1 == multi.getKey(0) || key1 != null && key1.equals(multi.getKey(0))) &&\n            (key2 == multi.getKey(1) || key2 != null && key2.equals(multi.getKey(1))) &&\n            (key3 == multi.getKey(2) || key3 != null && key3.equals(multi.getKey(2))) &&\n            (key4 == multi.getKey(3) || key4 != null && key4.equals(multi.getKey(3)));\n    }\n\n    /**\n     * Is the key equal to the combined key.\n     *\n     * @param entry  the entry to compare to\n     * @param key1  the first key\n     * @param key2  the second key\n     * @param key3  the third key\n     * @param key4  the fourth key\n     * @param key5  the fifth key\n     * @return true if the key matches\n     */\n    protected boolean isEqualKey(final AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry,\n            final Object key1, final Object key2, final Object key3, final Object key4, final Object key5) {\n        final MultiKey<? extends K> multi = entry.getKey();\n        return\n            multi.size() == 5 &&\n            (key1 == multi.getKey(0) || key1 != null && key1.equals(multi.getKey(0))) &&\n            (key2 == multi.getKey(1) || key2 != null && key2.equals(multi.getKey(1))) &&\n            (key3 == multi.getKey(2) || key3 != null && key3.equals(multi.getKey(2))) &&\n            (key4 == multi.getKey(3) || key4 != null && key4.equals(multi.getKey(3))) &&\n            (key5 == multi.getKey(4) || key5 != null && key5.equals(multi.getKey(4)));\n    }\n\n    @Override\n    public MapIterator<MultiKey<? extends K>, V> mapIterator() {\n        return decorated().mapIterator();\n    }\n\n    /**\n     * Stores the value against the specified multi-key.\n     *\n     * @param key1  the first key\n     * @param key2  the second key\n     * @param key3  the third key\n     * @param key4  the fourth key\n     * @param key5  the fifth key\n     * @param value  the value to store\n     * @return the value previously mapped to this combined key, null if none\n     */\n    public V put(final K key1, final K key2, final K key3, final K key4, final K key5, final V value) {\n        final int hashCode = hash(key1, key2, key3, key4, key5);\n        final int index = decorated().hashIndex(hashCode, decorated().data.length);\n        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry = decorated().data[index];\n        while (entry != null) {\n            if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3, key4, key5)) {\n                final V oldValue = entry.getValue();\n                decorated().updateEntry(entry, value);\n                return oldValue;\n            }\n            entry = entry.next;\n        }\n        decorated().addMapping(index, hashCode, new MultiKey<>(key1, key2, key3, key4, key5), value);\n        return null;\n    }\n\n    /**\n     * Stores the value against the specified multi-key.\n     *\n     * @param key1  the first key\n     * @param key2  the second key\n     * @param key3  the third key\n     * @param key4  the fourth key\n     * @param value  the value to store\n     * @return the value previously mapped to this combined key, null if none\n     */\n    public V put(final K key1, final K key2, final K key3, final K key4, final V value) {\n        final int hashCode = hash(key1, key2, key3, key4);\n        final int index = decorated().hashIndex(hashCode, decorated().data.length);\n        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry = decorated().data[index];\n        while (entry != null) {\n            if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3, key4)) {\n                final V oldValue = entry.getValue();\n                decorated().updateEntry(entry, value);\n                return oldValue;\n            }\n            entry = entry.next;\n        }\n        decorated().addMapping(index, hashCode, new MultiKey<>(key1, key2, key3, key4), value);\n        return null;\n    }\n\n    /**\n     * Stores the value against the specified multi-key.\n     *\n     * @param key1  the first key\n     * @param key2  the second key\n     * @param key3  the third key\n     * @param value  the value to store\n     * @return the value previously mapped to this combined key, null if none\n     */\n    public V put(final K key1, final K key2, final K key3, final V value) {\n        final int hashCode = hash(key1, key2, key3);\n        final int index = decorated().hashIndex(hashCode, decorated().data.length);\n        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry = decorated().data[index];\n        while (entry != null) {\n            if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3)) {\n                final V oldValue = entry.getValue();\n                decorated().updateEntry(entry, value);\n                return oldValue;\n            }\n            entry = entry.next;\n        }\n        decorated().addMapping(index, hashCode, new MultiKey<>(key1, key2, key3), value);\n        return null;\n    }\n\n    /**\n     * Stores the value against the specified multi-key.\n     *\n     * @param key1  the first key\n     * @param key2  the second key\n     * @param value  the value to store\n     * @return the value previously mapped to this combined key, null if none\n     */\n    public V put(final K key1, final K key2, final V value) {\n        final int hashCode = hash(key1, key2);\n        final int index = decorated().hashIndex(hashCode, decorated().data.length);\n        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry = decorated().data[index];\n        while (entry != null) {\n            if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2)) {\n                final V oldValue = entry.getValue();\n                decorated().updateEntry(entry, value);\n                return oldValue;\n            }\n            entry = entry.next;\n        }\n        decorated().addMapping(index, hashCode, new MultiKey<>(key1, key2), value);\n        return null;\n    }\n\n    /**\n     * Puts the key and value into the map, where the key must be a non-null\n     * MultiKey object.\n     *\n     * @param key  the non-null MultiKey object\n     * @param value  the value to store\n     * @return the previous value for the key\n     * @throws NullPointerException if the key is null\n     * @throws ClassCastException if the key is not a MultiKey\n     */\n    @Override\n    public V put(final MultiKey<? extends K> key, final V value) {\n        checkKey(key);\n        return super.put(key, value);\n    }\n\n    /**\n     * Copies all of the keys and values from the specified map to this map.\n     * Each key must be non-null and a MultiKey object.\n     *\n     * @param mapToCopy  to this map\n     * @throws NullPointerException if the mapToCopy or any key within is null\n     * @throws ClassCastException if any key in mapToCopy is not a MultiKey\n     */\n    @Override\n    public void putAll(final Map<? extends MultiKey<? extends K>, ? extends V> mapToCopy) {\n        for (final MultiKey<? extends K> key : mapToCopy.keySet()) {\n            checkKey(key);\n        }\n        super.putAll(mapToCopy);\n    }\n\n    /**\n     * Deserializes the map in using a custom routine.\n     *\n     * @param in  the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded\n     */\n    @SuppressWarnings(\"unchecked\")\n    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        map = (Map<MultiKey<? extends K>, V>) in.readObject();\n    }\n\n    /**\n     * Removes all mappings where the first key is that specified.\n     * <p>\n     * This method removes all the mappings where the {@code MultiKey}\n     * has one or more keys, and the first matches that specified.\n     *\n     * @param key1  the first key\n     * @return true if any elements were removed\n     */\n    public boolean removeAll(final Object key1) {\n        boolean modified = false;\n        final MapIterator<MultiKey<? extends K>, V> it = mapIterator();\n        while (it.hasNext()) {\n            final MultiKey<? extends K> multi = it.next();\n            if (multi.size() >= 1 &&\n                (key1 == null ? multi.getKey(0) == null : key1.equals(multi.getKey(0)))) {\n                it.remove();\n                modified = true;\n            }\n        }\n        return modified;\n    }\n\n    /**\n     * Removes all mappings where the first two keys are those specified.\n     * <p>\n     * This method removes all the mappings where the {@code MultiKey}\n     * has two or more keys, and the first two match those specified.\n     *\n     * @param key1  the first key\n     * @param key2  the second key\n     * @return true if any elements were removed\n     */\n    public boolean removeAll(final Object key1, final Object key2) {\n        boolean modified = false;\n        final MapIterator<MultiKey<? extends K>, V> it = mapIterator();\n        while (it.hasNext()) {\n            final MultiKey<? extends K> multi = it.next();\n            if (multi.size() >= 2 &&\n                (key1 == null ? multi.getKey(0) == null : key1.equals(multi.getKey(0))) &&\n                (key2 == null ? multi.getKey(1) == null : key2.equals(multi.getKey(1)))) {\n                it.remove();\n                modified = true;\n            }\n        }\n        return modified;\n    }\n\n    /**\n     * Removes all mappings where the first three keys are those specified.\n     * <p>\n     * This method removes all the mappings where the {@code MultiKey}\n     * has three or more keys, and the first three match those specified.\n     *\n     * @param key1  the first key\n     * @param key2  the second key\n     * @param key3  the third key\n     * @return true if any elements were removed\n     */\n    public boolean removeAll(final Object key1, final Object key2, final Object key3) {\n        boolean modified = false;\n        final MapIterator<MultiKey<? extends K>, V> it = mapIterator();\n        while (it.hasNext()) {\n            final MultiKey<? extends K> multi = it.next();\n            if (multi.size() >= 3 &&\n                (key1 == null ? multi.getKey(0) == null : key1.equals(multi.getKey(0))) &&\n                (key2 == null ? multi.getKey(1) == null : key2.equals(multi.getKey(1))) &&\n                (key3 == null ? multi.getKey(2) == null : key3.equals(multi.getKey(2)))) {\n                it.remove();\n                modified = true;\n            }\n        }\n        return modified;\n    }\n\n    /**\n     * Removes all mappings where the first four keys are those specified.\n     * <p>\n     * This method removes all the mappings where the {@code MultiKey}\n     * has four or more keys, and the first four match those specified.\n     *\n     * @param key1  the first key\n     * @param key2  the second key\n     * @param key3  the third key\n     * @param key4  the fourth key\n     * @return true if any elements were removed\n     */\n    public boolean removeAll(final Object key1, final Object key2, final Object key3, final Object key4) {\n        boolean modified = false;\n        final MapIterator<MultiKey<? extends K>, V> it = mapIterator();\n        while (it.hasNext()) {\n            final MultiKey<? extends K> multi = it.next();\n            if (multi.size() >= 4 &&\n                (key1 == null ? multi.getKey(0) == null : key1.equals(multi.getKey(0))) &&\n                (key2 == null ? multi.getKey(1) == null : key2.equals(multi.getKey(1))) &&\n                (key3 == null ? multi.getKey(2) == null : key3.equals(multi.getKey(2))) &&\n                (key4 == null ? multi.getKey(3) == null : key4.equals(multi.getKey(3)))) {\n                it.remove();\n                modified = true;\n            }\n        }\n        return modified;\n    }\n\n    /**\n     * Removes the specified multi-key from this map.\n     *\n     * @param key1  the first key\n     * @param key2  the second key\n     * @return the value mapped to the removed key, null if key not in map\n     * @since 4.0 (previous name: remove(Object, Object))\n     */\n    public V removeMultiKey(final Object key1, final Object key2) {\n        final int hashCode = hash(key1, key2);\n        final int index = decorated().hashIndex(hashCode, decorated().data.length);\n        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry = decorated().data[index];\n        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> previous = null;\n        while (entry != null) {\n            if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2)) {\n                final V oldValue = entry.getValue();\n                decorated().removeMapping(entry, index, previous);\n                return oldValue;\n            }\n            previous = entry;\n            entry = entry.next;\n        }\n        return null;\n    }\n\n    /**\n     * Removes the specified multi-key from this map.\n     *\n     * @param key1  the first key\n     * @param key2  the second key\n     * @param key3  the third key\n     * @return the value mapped to the removed key, null if key not in map\n     * @since 4.0 (previous name: remove(Object, Object, Object))\n     */\n    public V removeMultiKey(final Object key1, final Object key2, final Object key3) {\n        final int hashCode = hash(key1, key2, key3);\n        final int index = decorated().hashIndex(hashCode, decorated().data.length);\n        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry = decorated().data[index];\n        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> previous = null;\n        while (entry != null) {\n            if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3)) {\n                final V oldValue = entry.getValue();\n                decorated().removeMapping(entry, index, previous);\n                return oldValue;\n            }\n            previous = entry;\n            entry = entry.next;\n        }\n        return null;\n    }\n\n    /**\n     * Removes the specified multi-key from this map.\n     *\n     * @param key1  the first key\n     * @param key2  the second key\n     * @param key3  the third key\n     * @param key4  the fourth key\n     * @return the value mapped to the removed key, null if key not in map\n     * @since 4.0 (previous name: remove(Object, Object, Object, Object))\n     */\n    public V removeMultiKey(final Object key1, final Object key2, final Object key3, final Object key4) {\n        final int hashCode = hash(key1, key2, key3, key4);\n        final int index = decorated().hashIndex(hashCode, decorated().data.length);\n        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry = decorated().data[index];\n        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> previous = null;\n        while (entry != null) {\n            if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3, key4)) {\n                final V oldValue = entry.getValue();\n                decorated().removeMapping(entry, index, previous);\n                return oldValue;\n            }\n            previous = entry;\n            entry = entry.next;\n        }\n        return null;\n    }\n\n    /**\n     * Removes the specified multi-key from this map.\n     *\n     * @param key1  the first key\n     * @param key2  the second key\n     * @param key3  the third key\n     * @param key4  the fourth key\n     * @param key5  the fifth key\n     * @return the value mapped to the removed key, null if key not in map\n     * @since 4.0 (previous name: remove(Object, Object, Object, Object, Object))\n     */\n    public V removeMultiKey(final Object key1, final Object key2, final Object key3,\n                            final Object key4, final Object key5) {\n        final int hashCode = hash(key1, key2, key3, key4, key5);\n        final int index = decorated().hashIndex(hashCode, decorated().data.length);\n        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry = decorated().data[index];\n        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> previous = null;\n        while (entry != null) {\n            if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3, key4, key5)) {\n                final V oldValue = entry.getValue();\n                decorated().removeMapping(entry, index, previous);\n                return oldValue;\n            }\n            previous = entry;\n            entry = entry.next;\n        }\n        return null;\n    }\n\n    /**\n     * Serializes this object to an ObjectOutputStream.\n     *\n     * @param out the target ObjectOutputStream.\n     * @throws IOException thrown when an I/O errors occur writing to the target stream.\n     */\n    private void writeObject(final ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        out.writeObject(map);\n    }\n\n}", "super_interfaces": ["Serializable", "Cloneable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = -1788199231038721040L;", "docstring": " Serialisation version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -1788199231038721040L", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/map/FixedSizeSortedMap.java.FixedSizeSortedMap", "name": "FixedSizeSortedMap", "file_path": "src/main/java/org/apache/commons/collections4/map/FixedSizeSortedMap.java", "superclasses": "", "methods": ["[FixedSizeSortedMap<K, V>]fixedSizeSortedMap(SortedMap<K, V>)", "[]FixedSizeSortedMap(SortedMap<K, V>)", "[void]clear()", "[Set<Map.Entry<K, V>>]entrySet()", "[SortedMap<K, V>]getSortedMap()", "[SortedMap<K, V>]headMap(K)", "[boolean]isFull()", "[Set<K>]keySet()", "[int]maxSize()", "[V]put(K,V)", "[void]putAll(Map<? extends K, ? extends V>)", "[void]readObject(ObjectInputStream)", "[V]remove(Object)", "[SortedMap<K, V>]subMap(K,K)", "[SortedMap<K, V>]tailMap(K)", "[Collection<V>]values()", "[void]writeObject(ObjectOutputStream)"], "method_uris": ["src/main/java/org/apache/commons/collections4/map/FixedSizeSortedMap.java.FixedSizeSortedMap.[FixedSizeSortedMap<K, V>]fixedSizeSortedMap(SortedMap<K, V>)", "src/main/java/org/apache/commons/collections4/map/FixedSizeSortedMap.java.FixedSizeSortedMap.[]FixedSizeSortedMap(SortedMap<K, V>)", "src/main/java/org/apache/commons/collections4/map/FixedSizeSortedMap.java.FixedSizeSortedMap.[void]clear()", "src/main/java/org/apache/commons/collections4/map/FixedSizeSortedMap.java.FixedSizeSortedMap.[Set<Map.Entry<K, V>>]entrySet()", "src/main/java/org/apache/commons/collections4/map/FixedSizeSortedMap.java.FixedSizeSortedMap.[SortedMap<K, V>]getSortedMap()", "src/main/java/org/apache/commons/collections4/map/FixedSizeSortedMap.java.FixedSizeSortedMap.[SortedMap<K, V>]headMap(K)", "src/main/java/org/apache/commons/collections4/map/FixedSizeSortedMap.java.FixedSizeSortedMap.[boolean]isFull()", "src/main/java/org/apache/commons/collections4/map/FixedSizeSortedMap.java.FixedSizeSortedMap.[Set<K>]keySet()", "src/main/java/org/apache/commons/collections4/map/FixedSizeSortedMap.java.FixedSizeSortedMap.[int]maxSize()", "src/main/java/org/apache/commons/collections4/map/FixedSizeSortedMap.java.FixedSizeSortedMap.[V]put(K,V)", "src/main/java/org/apache/commons/collections4/map/FixedSizeSortedMap.java.FixedSizeSortedMap.[void]putAll(Map<? extends K, ? extends V>)", "src/main/java/org/apache/commons/collections4/map/FixedSizeSortedMap.java.FixedSizeSortedMap.[void]readObject(ObjectInputStream)", "src/main/java/org/apache/commons/collections4/map/FixedSizeSortedMap.java.FixedSizeSortedMap.[V]remove(Object)", "src/main/java/org/apache/commons/collections4/map/FixedSizeSortedMap.java.FixedSizeSortedMap.[SortedMap<K, V>]subMap(K,K)", "src/main/java/org/apache/commons/collections4/map/FixedSizeSortedMap.java.FixedSizeSortedMap.[SortedMap<K, V>]tailMap(K)", "src/main/java/org/apache/commons/collections4/map/FixedSizeSortedMap.java.FixedSizeSortedMap.[Collection<V>]values()", "src/main/java/org/apache/commons/collections4/map/FixedSizeSortedMap.java.FixedSizeSortedMap.[void]writeObject(ObjectOutputStream)"], "overrides": null, "attributes": [], "class_docstring": "\nDecorates another {@code SortedMap} to fix the size blocking add/remove.\n<p>\nAny action that would change the size of the map is disallowed.\nThe put method is allowed to change the value associated with an existing\nkey however.\n</p>\n<p>\nIf trying to remove or clear the map, an UnsupportedOperationException is\nthrown. If trying to put a new mapping into the map, an\nIllegalArgumentException is thrown. This is because the put method can\nsucceed if the mapping's key already exists in the map, so the put method\nis not always unsupported.\n</p>\n<p>\n<strong>Note that FixedSizeSortedMap is not synchronized and is not thread-safe.</strong>\nIf you wish to use this map from multiple threads concurrently, you must use\nappropriate synchronization. The simplest approach is to wrap this map\nusing {@link java.util.Collections#synchronizedSortedMap}. This class may throw\nexceptions when accessed by concurrent threads without synchronization.\n</p>\n<p>\nThis class is Serializable from Commons Collections 3.1.\n</p>\n\n@param <K> the type of the keys in this map\n@param <V> the type of the values in this map\n@since 3.0\n", "original_string": "public class FixedSizeSortedMap<K, V>\n        extends AbstractSortedMapDecorator<K, V>\n        implements BoundedMap<K, V>, Serializable {\n\n    /** Serialization version */\n    private static final long serialVersionUID = 3126019624511683653L;\n\n    /**\n     * Factory method to create a fixed size sorted map.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param map  the map to decorate, must not be null\n     * @return a new fixed size sorted map\n     * @throws NullPointerException if map is null\n     * @since 4.0\n     */\n    public static <K, V> FixedSizeSortedMap<K, V> fixedSizeSortedMap(final SortedMap<K, V> map) {\n        return new FixedSizeSortedMap<>(map);\n    }\n\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param map  the map to decorate, must not be null\n     * @throws NullPointerException if map is null\n     */\n    protected FixedSizeSortedMap(final SortedMap<K, V> map) {\n        super(map);\n    }\n\n    @Override\n    public void clear() {\n        throw new UnsupportedOperationException(\"Map is fixed size\");\n    }\n\n    @Override\n    public Set<Map.Entry<K, V>> entrySet() {\n        return UnmodifiableSet.unmodifiableSet(map.entrySet());\n    }\n\n    /**\n     * Gets the map being decorated.\n     *\n     * @return the decorated map\n     */\n    protected SortedMap<K, V> getSortedMap() {\n        return (SortedMap<K, V>) map;\n    }\n\n    @Override\n    public SortedMap<K, V> headMap(final K toKey) {\n        return new FixedSizeSortedMap<>(getSortedMap().headMap(toKey));\n    }\n\n    @Override\n    public boolean isFull() {\n        return true;\n    }\n\n    @Override\n    public Set<K> keySet() {\n        return UnmodifiableSet.unmodifiableSet(map.keySet());\n    }\n\n    @Override\n    public int maxSize() {\n        return size();\n    }\n\n    @Override\n    public V put(final K key, final V value) {\n        if (!map.containsKey(key)) {\n            throw new IllegalArgumentException(\"Cannot put new key/value pair - Map is fixed size\");\n        }\n        return map.put(key, value);\n    }\n\n    @Override\n    public void putAll(final Map<? extends K, ? extends V> mapToCopy) {\n        if (CollectionUtils.isSubCollection(mapToCopy.keySet(), keySet())) {\n            throw new IllegalArgumentException(\"Cannot put new key/value pair - Map is fixed size\");\n        }\n        map.putAll(mapToCopy);\n    }\n\n    /**\n     * Deserializes the map in using a custom routine.\n     *\n     * @param in the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded\n     */\n    @SuppressWarnings(\"unchecked\") // (1) should only fail if input stream is incorrect\n    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        map = (Map<K, V>) in.readObject(); // (1)\n    }\n\n    @Override\n    public V remove(final Object key) {\n        throw new UnsupportedOperationException(\"Map is fixed size\");\n    }\n\n    @Override\n    public SortedMap<K, V> subMap(final K fromKey, final K toKey) {\n        return new FixedSizeSortedMap<>(getSortedMap().subMap(fromKey, toKey));\n    }\n\n    @Override\n    public SortedMap<K, V> tailMap(final K fromKey) {\n        return new FixedSizeSortedMap<>(getSortedMap().tailMap(fromKey));\n    }\n\n    @Override\n    public Collection<V> values() {\n        return UnmodifiableCollection.unmodifiableCollection(map.values());\n    }\n\n    /**\n     * Write the map out using a custom routine.\n     *\n     * @param out  the output stream\n     * @throws IOException if an error occurs while writing to the stream\n     */\n    private void writeObject(final ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        out.writeObject(map);\n    }\n\n}", "super_interfaces": ["BoundedMap<K, V>", "Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 3126019624511683653L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 3126019624511683653L", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/map/UnmodifiableOrderedMap.java.UnmodifiableOrderedMap", "name": "UnmodifiableOrderedMap", "file_path": "src/main/java/org/apache/commons/collections4/map/UnmodifiableOrderedMap.java", "superclasses": "", "methods": ["[OrderedMap<K, V>]unmodifiableOrderedMap(OrderedMap<? extends K, ? extends V>)", "[]UnmodifiableOrderedMap(OrderedMap<? extends K, ? extends V>)", "[void]clear()", "[Set<Map.Entry<K, V>>]entrySet()", "[Set<K>]keySet()", "[OrderedMapIterator<K, V>]mapIterator()", "[V]put(K,V)", "[void]putAll(Map<? extends K, ? extends V>)", "[void]readObject(ObjectInputStream)", "[V]remove(Object)", "[Collection<V>]values()", "[void]writeObject(ObjectOutputStream)"], "method_uris": ["src/main/java/org/apache/commons/collections4/map/UnmodifiableOrderedMap.java.UnmodifiableOrderedMap.[OrderedMap<K, V>]unmodifiableOrderedMap(OrderedMap<? extends K, ? extends V>)", "src/main/java/org/apache/commons/collections4/map/UnmodifiableOrderedMap.java.UnmodifiableOrderedMap.[]UnmodifiableOrderedMap(OrderedMap<? extends K, ? extends V>)", "src/main/java/org/apache/commons/collections4/map/UnmodifiableOrderedMap.java.UnmodifiableOrderedMap.[void]clear()", "src/main/java/org/apache/commons/collections4/map/UnmodifiableOrderedMap.java.UnmodifiableOrderedMap.[Set<Map.Entry<K, V>>]entrySet()", "src/main/java/org/apache/commons/collections4/map/UnmodifiableOrderedMap.java.UnmodifiableOrderedMap.[Set<K>]keySet()", "src/main/java/org/apache/commons/collections4/map/UnmodifiableOrderedMap.java.UnmodifiableOrderedMap.[OrderedMapIterator<K, V>]mapIterator()", "src/main/java/org/apache/commons/collections4/map/UnmodifiableOrderedMap.java.UnmodifiableOrderedMap.[V]put(K,V)", "src/main/java/org/apache/commons/collections4/map/UnmodifiableOrderedMap.java.UnmodifiableOrderedMap.[void]putAll(Map<? extends K, ? extends V>)", "src/main/java/org/apache/commons/collections4/map/UnmodifiableOrderedMap.java.UnmodifiableOrderedMap.[void]readObject(ObjectInputStream)", "src/main/java/org/apache/commons/collections4/map/UnmodifiableOrderedMap.java.UnmodifiableOrderedMap.[V]remove(Object)", "src/main/java/org/apache/commons/collections4/map/UnmodifiableOrderedMap.java.UnmodifiableOrderedMap.[Collection<V>]values()", "src/main/java/org/apache/commons/collections4/map/UnmodifiableOrderedMap.java.UnmodifiableOrderedMap.[void]writeObject(ObjectOutputStream)"], "overrides": null, "attributes": [], "class_docstring": "\nDecorates another {@code OrderedMap} to ensure it can't be altered.\n<p>\nThis class is Serializable from Commons Collections 3.1.\n</p>\n<p>\nAttempts to modify it will result in an UnsupportedOperationException.\n</p>\n\n@param <K> the type of the keys in this map\n@param <V> the type of the values in this map\n@since 3.0\n", "original_string": "public final class UnmodifiableOrderedMap<K, V> extends AbstractOrderedMapDecorator<K, V> implements\n        Unmodifiable, Serializable {\n\n    /** Serialization version */\n    private static final long serialVersionUID = 8136428161720526266L;\n\n    /**\n     * Factory method to create an unmodifiable sorted map.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param map  the map to decorate, must not be null\n     * @return a new ordered map\n     * @throws NullPointerException if map is null\n     * @since 4.0\n     */\n    public static <K, V> OrderedMap<K, V> unmodifiableOrderedMap(final OrderedMap<? extends K, ? extends V> map) {\n        if (map instanceof Unmodifiable) {\n            @SuppressWarnings(\"unchecked\") // safe to upcast\n            final OrderedMap<K, V> tmpMap = (OrderedMap<K, V>) map;\n            return tmpMap;\n        }\n        return new UnmodifiableOrderedMap<>(map);\n    }\n\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param map  the map to decorate, must not be null\n     * @throws NullPointerException if map is null\n     */\n    @SuppressWarnings(\"unchecked\") // safe to upcast\n    private UnmodifiableOrderedMap(final OrderedMap<? extends K, ? extends V> map) {\n        super((OrderedMap<K, V>) map);\n    }\n\n    @Override\n    public void clear() {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public Set<Map.Entry<K, V>> entrySet() {\n        final Set<Map.Entry<K, V>> set = super.entrySet();\n        return UnmodifiableEntrySet.unmodifiableEntrySet(set);\n    }\n\n    @Override\n    public Set<K> keySet() {\n        final Set<K> set = super.keySet();\n        return UnmodifiableSet.unmodifiableSet(set);\n    }\n\n    @Override\n    public OrderedMapIterator<K, V> mapIterator() {\n        final OrderedMapIterator<K, V> it = decorated().mapIterator();\n        return UnmodifiableOrderedMapIterator.unmodifiableOrderedMapIterator(it);\n    }\n\n    @Override\n    public V put(final K key, final V value) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public void putAll(final Map<? extends K, ? extends V> mapToCopy) {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * Deseializes the map in using a custom routine.\n     *\n     * @param in  the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded\n     * @since 3.1\n     */\n    @SuppressWarnings(\"unchecked\") // (1) should only fail if input stream is incorrect\n    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        map = (Map<K, V>) in.readObject(); // (1)\n    }\n\n    @Override\n    public V remove(final Object key) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public Collection<V> values() {\n        final Collection<V> coll = super.values();\n        return UnmodifiableCollection.unmodifiableCollection(coll);\n    }\n\n    /**\n     * Serializes this object to an ObjectOutputStream.\n     *\n     * @param out the target ObjectOutputStream.\n     * @throws IOException thrown when an I/O errors occur writing to the target stream.\n     * @since 3.1\n     */\n    private void writeObject(final ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        out.writeObject(map);\n    }\n\n}", "super_interfaces": ["Unmodifiable", "Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 8136428161720526266L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 8136428161720526266L", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/map/SingletonMap.java.SingletonMap", "name": "SingletonMap", "file_path": "src/main/java/org/apache/commons/collections4/map/SingletonMap.java", "superclasses": "", "methods": ["[]SingletonMap()", "[]SingletonMap(K,V)", "[]SingletonMap(KeyValue<K, V>)", "[]SingletonMap(Map.Entry<? extends K, ? extends V>)", "[]SingletonMap(Map<? extends K, ? extends V>)", "[void]clear()", "[SingletonMap<K, V>]clone()", "[boolean]containsKey(Object)", "[boolean]containsValue(Object)", "[Set<Map.Entry<K, V>>]entrySet()", "[boolean]equals(Object)", "[K]firstKey()", "[V]get(Object)", "[K]getKey()", "[V]getValue()", "[int]hashCode()", "[boolean]isEmpty()", "[boolean]isEqualKey(Object)", "[boolean]isEqualValue(Object)", "[boolean]isFull()", "[Set<K>]keySet()", "[K]lastKey()", "[OrderedMapIterator<K, V>]mapIterator()", "[int]maxSize()", "[K]nextKey(K)", "[K]previousKey(K)", "[V]put(K,V)", "[void]putAll(Map<? extends K, ? extends V>)", "[V]remove(Object)", "[V]setValue(V)", "[int]size()", "[String]toString()", "[Collection<V>]values()"], "method_uris": ["src/main/java/org/apache/commons/collections4/map/SingletonMap.java.SingletonMap.[]SingletonMap()", "src/main/java/org/apache/commons/collections4/map/SingletonMap.java.SingletonMap.[]SingletonMap(K,V)", "src/main/java/org/apache/commons/collections4/map/SingletonMap.java.SingletonMap.[]SingletonMap(KeyValue<K, V>)", "src/main/java/org/apache/commons/collections4/map/SingletonMap.java.SingletonMap.[]SingletonMap(Map.Entry<? extends K, ? extends V>)", "src/main/java/org/apache/commons/collections4/map/SingletonMap.java.SingletonMap.[]SingletonMap(Map<? extends K, ? extends V>)", "src/main/java/org/apache/commons/collections4/map/SingletonMap.java.SingletonMap.[void]clear()", "src/main/java/org/apache/commons/collections4/map/SingletonMap.java.SingletonMap.[SingletonMap<K, V>]clone()", "src/main/java/org/apache/commons/collections4/map/SingletonMap.java.SingletonMap.[boolean]containsKey(Object)", "src/main/java/org/apache/commons/collections4/map/SingletonMap.java.SingletonMap.[boolean]containsValue(Object)", "src/main/java/org/apache/commons/collections4/map/SingletonMap.java.SingletonMap.[Set<Map.Entry<K, V>>]entrySet()", "src/main/java/org/apache/commons/collections4/map/SingletonMap.java.SingletonMap.[boolean]equals(Object)", "src/main/java/org/apache/commons/collections4/map/SingletonMap.java.SingletonMap.[K]firstKey()", "src/main/java/org/apache/commons/collections4/map/SingletonMap.java.SingletonMap.[V]get(Object)", "src/main/java/org/apache/commons/collections4/map/SingletonMap.java.SingletonMap.[K]getKey()", "src/main/java/org/apache/commons/collections4/map/SingletonMap.java.SingletonMap.[V]getValue()", "src/main/java/org/apache/commons/collections4/map/SingletonMap.java.SingletonMap.[int]hashCode()", "src/main/java/org/apache/commons/collections4/map/SingletonMap.java.SingletonMap.[boolean]isEmpty()", "src/main/java/org/apache/commons/collections4/map/SingletonMap.java.SingletonMap.[boolean]isEqualKey(Object)", "src/main/java/org/apache/commons/collections4/map/SingletonMap.java.SingletonMap.[boolean]isEqualValue(Object)", "src/main/java/org/apache/commons/collections4/map/SingletonMap.java.SingletonMap.[boolean]isFull()", "src/main/java/org/apache/commons/collections4/map/SingletonMap.java.SingletonMap.[Set<K>]keySet()", "src/main/java/org/apache/commons/collections4/map/SingletonMap.java.SingletonMap.[K]lastKey()", "src/main/java/org/apache/commons/collections4/map/SingletonMap.java.SingletonMap.[OrderedMapIterator<K, V>]mapIterator()", "src/main/java/org/apache/commons/collections4/map/SingletonMap.java.SingletonMap.[int]maxSize()", "src/main/java/org/apache/commons/collections4/map/SingletonMap.java.SingletonMap.[K]nextKey(K)", "src/main/java/org/apache/commons/collections4/map/SingletonMap.java.SingletonMap.[K]previousKey(K)", "src/main/java/org/apache/commons/collections4/map/SingletonMap.java.SingletonMap.[V]put(K,V)", "src/main/java/org/apache/commons/collections4/map/SingletonMap.java.SingletonMap.[void]putAll(Map<? extends K, ? extends V>)", "src/main/java/org/apache/commons/collections4/map/SingletonMap.java.SingletonMap.[V]remove(Object)", "src/main/java/org/apache/commons/collections4/map/SingletonMap.java.SingletonMap.[V]setValue(V)", "src/main/java/org/apache/commons/collections4/map/SingletonMap.java.SingletonMap.[int]size()", "src/main/java/org/apache/commons/collections4/map/SingletonMap.java.SingletonMap.[String]toString()", "src/main/java/org/apache/commons/collections4/map/SingletonMap.java.SingletonMap.[Collection<V>]values()"], "overrides": null, "attributes": [{"original_string": "    static class SingletonMapIterator<K, V> implements OrderedMapIterator<K, V>, ResettableIterator<K> {\n        private final SingletonMap<K, V> parent;\n        private boolean hasNext = true;\n        private boolean canGetSet;\n\n        SingletonMapIterator(final SingletonMap<K, V> parent) {\n            this.parent = parent;\n        }\n\n        @Override\n        public K getKey() {\n            if (!canGetSet) {\n                throw new IllegalStateException(AbstractHashedMap.GETKEY_INVALID);\n            }\n            return parent.getKey();\n        }\n\n        @Override\n        public V getValue() {\n            if (!canGetSet) {\n                throw new IllegalStateException(AbstractHashedMap.GETVALUE_INVALID);\n            }\n            return parent.getValue();\n        }\n\n        @Override\n        public boolean hasNext() {\n            return hasNext;\n        }\n\n        @Override\n        public boolean hasPrevious() {\n            return !hasNext;\n        }\n\n        @Override\n        public K next() {\n            if (!hasNext) {\n                throw new NoSuchElementException(AbstractHashedMap.NO_NEXT_ENTRY);\n            }\n            hasNext = false;\n            canGetSet = true;\n            return parent.getKey();\n        }\n\n        @Override\n        public K previous() {\n            if (hasNext) {\n                throw new NoSuchElementException(AbstractHashedMap.NO_PREVIOUS_ENTRY);\n            }\n            hasNext = true;\n            return parent.getKey();\n        }\n\n        @Override\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public void reset() {\n            hasNext = true;\n        }\n\n        @Override\n        public V setValue(final V value) {\n            if (!canGetSet) {\n                throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);\n            }\n            return parent.setValue(value);\n        }\n\n        @Override\n        public String toString() {\n            if (hasNext) {\n                return \"Iterator[]\";\n            }\n            return \"Iterator[\" + getKey() + \"=\" + getValue() + \"]\";\n        }\n    }", "definition": "    static class SingletonMapIterator<K, V> implements OrderedMapIterator<K, V>, ResettableIterator<K>", "class_docstring": "\nSingletonMapIterator.\n", "name": "SingletonMapIterator", "super_interfaces": ["OrderedMapIterator<K, V>", "ResettableIterator<K>"], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "private final SingletonMap<K, V> parent;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "SingletonMap<K, V>", "name": "parent", "syntax_pass": true}, {"attribute_expression": "private boolean hasNext = true;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "hasNext = true", "syntax_pass": true}, {"attribute_expression": "private boolean canGetSet;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "canGetSet", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        SingletonMapIterator(final SingletonMap<K, V> parent) {\n            this.parent = parent;\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "SingletonMapIterator", "params": [{"name": "parent", "type": "SingletonMap<K, V>"}], "body": "                                                              {\n            this.parent = parent;\n        }", "signature": "SingletonMapIterator(final SingletonMap<K, V> parent)"}, {"syntax_pass": true, "original_string": "        @Override\n        public K getKey() {\n            if (!canGetSet) {\n                throw new IllegalStateException(AbstractHashedMap.GETKEY_INVALID);\n            }\n            return parent.getKey();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "K", "classes": []}, "name": "getKey", "params": [], "body": "                          {\n            if (!canGetSet) {\n                throw new IllegalStateException(AbstractHashedMap.GETKEY_INVALID);\n            }\n            return parent.getKey();\n        }", "signature": "@Override\n        public K getKey()"}, {"syntax_pass": true, "original_string": "        @Override\n        public V getValue() {\n            if (!canGetSet) {\n                throw new IllegalStateException(AbstractHashedMap.GETVALUE_INVALID);\n            }\n            return parent.getValue();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "getValue", "params": [], "body": "                            {\n            if (!canGetSet) {\n                throw new IllegalStateException(AbstractHashedMap.GETVALUE_INVALID);\n            }\n            return parent.getValue();\n        }", "signature": "@Override\n        public V getValue()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean hasNext() {\n            return hasNext;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasNext", "params": [], "body": "                                 {\n            return hasNext;\n        }", "signature": "@Override\n        public boolean hasNext()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean hasPrevious() {\n            return !hasNext;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasPrevious", "params": [], "body": "                                     {\n            return !hasNext;\n        }", "signature": "@Override\n        public boolean hasPrevious()"}, {"syntax_pass": true, "original_string": "        @Override\n        public K next() {\n            if (!hasNext) {\n                throw new NoSuchElementException(AbstractHashedMap.NO_NEXT_ENTRY);\n            }\n            hasNext = false;\n            canGetSet = true;\n            return parent.getKey();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "K", "classes": []}, "name": "next", "params": [], "body": "                        {\n            if (!hasNext) {\n                throw new NoSuchElementException(AbstractHashedMap.NO_NEXT_ENTRY);\n            }\n            hasNext = false;\n            canGetSet = true;\n            return parent.getKey();\n        }", "signature": "@Override\n        public K next()"}, {"syntax_pass": true, "original_string": "        @Override\n        public K previous() {\n            if (hasNext) {\n                throw new NoSuchElementException(AbstractHashedMap.NO_PREVIOUS_ENTRY);\n            }\n            hasNext = true;\n            return parent.getKey();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "K", "classes": []}, "name": "previous", "params": [], "body": "                            {\n            if (hasNext) {\n                throw new NoSuchElementException(AbstractHashedMap.NO_PREVIOUS_ENTRY);\n            }\n            hasNext = true;\n            return parent.getKey();\n        }", "signature": "@Override\n        public K previous()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "remove", "params": [], "body": "                             {\n            throw new UnsupportedOperationException();\n        }", "signature": "@Override\n        public void remove()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void reset() {\n            hasNext = true;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "reset", "params": [], "body": "                            {\n            hasNext = true;\n        }", "signature": "@Override\n        public void reset()"}, {"syntax_pass": true, "original_string": "        @Override\n        public V setValue(final V value) {\n            if (!canGetSet) {\n                throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);\n            }\n            return parent.setValue(value);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "setValue", "params": [{"name": "value", "type": "V"}], "body": "                                         {\n            if (!canGetSet) {\n                throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);\n            }\n            return parent.setValue(value);\n        }", "signature": "@Override\n        public V setValue(final V value)"}, {"syntax_pass": true, "original_string": "        @Override\n        public String toString() {\n            if (hasNext) {\n                return \"Iterator[]\";\n            }\n            return \"Iterator[\" + getKey() + \"=\" + getValue() + \"]\";\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                 {\n            if (hasNext) {\n                return \"Iterator[]\";\n            }\n            return \"Iterator[\" + getKey() + \"=\" + getValue() + \"]\";\n        }", "signature": "@Override\n        public String toString()"}]}, {"original_string": "    static class SingletonValues<V> extends AbstractSet<V> implements Serializable {\n        private static final long serialVersionUID = -3689524741863047872L;\n        private final SingletonMap<?, V> parent;\n\n        SingletonValues(final SingletonMap<?, V> parent) {\n            this.parent = parent;\n        }\n\n        @Override\n        public void clear() {\n            throw new UnsupportedOperationException();\n        }\n        @Override\n        public boolean contains(final Object object) {\n            return parent.containsValue(object);\n        }\n        @Override\n        public boolean isEmpty() {\n            return false;\n        }\n        @Override\n        public Iterator<V> iterator() {\n            return new SingletonIterator<>(parent.getValue(), false);\n        }\n        @Override\n        public int size() {\n            return 1;\n        }\n    }", "definition": "    static class SingletonValues<V> extends AbstractSet<V> implements Serializable", "class_docstring": "\nValues implementation for the SingletonMap.\nThis class is needed as values is a view that must update as the map updates.\n", "name": "SingletonValues", "super_interfaces": ["Serializable"], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = -3689524741863047872L;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -3689524741863047872L", "syntax_pass": true}, {"attribute_expression": "private final SingletonMap<?, V> parent;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "SingletonMap<?, V>", "name": "parent", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        SingletonValues(final SingletonMap<?, V> parent) {\n            this.parent = parent;\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "SingletonValues", "params": [{"name": "parent", "type": "SingletonMap<?, V>"}], "body": "                                                         {\n            this.parent = parent;\n        }", "signature": "SingletonValues(final SingletonMap<?, V> parent)"}, {"syntax_pass": true, "original_string": "        @Override\n        public void clear() {\n            throw new UnsupportedOperationException();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "clear", "params": [], "body": "                            {\n            throw new UnsupportedOperationException();\n        }", "signature": "@Override\n        public void clear()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean contains(final Object object) {\n            return parent.containsValue(object);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "contains", "params": [{"name": "object", "type": "Object"}], "body": "                                                     {\n            return parent.containsValue(object);\n        }", "signature": "@Override\n        public boolean contains(final Object object)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isEmpty() {\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isEmpty", "params": [], "body": "                                 {\n            return false;\n        }", "signature": "@Override\n        public boolean isEmpty()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Iterator<V> iterator() {\n            return new SingletonIterator<>(parent.getValue(), false);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Iterator<V>", "classes": []}, "name": "iterator", "params": [], "body": "                                      {\n            return new SingletonIterator<>(parent.getValue(), false);\n        }", "signature": "@Override\n        public Iterator<V> iterator()"}, {"syntax_pass": true, "original_string": "        @Override\n        public int size() {\n            return 1;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "size", "params": [], "body": "                          {\n            return 1;\n        }", "signature": "@Override\n        public int size()"}]}], "class_docstring": "\nA {@code Map} implementation that holds a single item and is fixed size.\n<p>\nThe single key/value pair is specified at creation.\nThe map is fixed size so any action that would change the size is disallowed.\nHowever, the {@code put} or {@code setValue} methods can <em>change</em>\nthe value associated with the key.\n</p>\n<p>\nIf trying to remove or clear the map, an UnsupportedOperationException is thrown.\nIf trying to put a new mapping into the map, an  IllegalArgumentException is thrown.\nThe put method will only succeed if the key specified is the same as the\nsingleton key.\n</p>\n<p>\nThe key and value can be obtained by:\n</p>\n<ul>\n<li>normal Map methods and views\n<li>the {@code MapIterator}, see {@link #mapIterator()}\n<li>the {@code KeyValue} interface (just cast - no object creation)\n</ul>\n\n@param <K> the type of the keys in this map\n@param <V> the type of the values in this map\n@since 3.1\n", "original_string": "public class SingletonMap<K, V>\n        implements OrderedMap<K, V>, BoundedMap<K, V>, KeyValue<K, V>, Serializable, Cloneable {\n\n    /**\n     * SingletonMapIterator.\n     */\n    static class SingletonMapIterator<K, V> implements OrderedMapIterator<K, V>, ResettableIterator<K> {\n        private final SingletonMap<K, V> parent;\n        private boolean hasNext = true;\n        private boolean canGetSet;\n\n        SingletonMapIterator(final SingletonMap<K, V> parent) {\n            this.parent = parent;\n        }\n\n        @Override\n        public K getKey() {\n            if (!canGetSet) {\n                throw new IllegalStateException(AbstractHashedMap.GETKEY_INVALID);\n            }\n            return parent.getKey();\n        }\n\n        @Override\n        public V getValue() {\n            if (!canGetSet) {\n                throw new IllegalStateException(AbstractHashedMap.GETVALUE_INVALID);\n            }\n            return parent.getValue();\n        }\n\n        @Override\n        public boolean hasNext() {\n            return hasNext;\n        }\n\n        @Override\n        public boolean hasPrevious() {\n            return !hasNext;\n        }\n\n        @Override\n        public K next() {\n            if (!hasNext) {\n                throw new NoSuchElementException(AbstractHashedMap.NO_NEXT_ENTRY);\n            }\n            hasNext = false;\n            canGetSet = true;\n            return parent.getKey();\n        }\n\n        @Override\n        public K previous() {\n            if (hasNext) {\n                throw new NoSuchElementException(AbstractHashedMap.NO_PREVIOUS_ENTRY);\n            }\n            hasNext = true;\n            return parent.getKey();\n        }\n\n        @Override\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public void reset() {\n            hasNext = true;\n        }\n\n        @Override\n        public V setValue(final V value) {\n            if (!canGetSet) {\n                throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);\n            }\n            return parent.setValue(value);\n        }\n\n        @Override\n        public String toString() {\n            if (hasNext) {\n                return \"Iterator[]\";\n            }\n            return \"Iterator[\" + getKey() + \"=\" + getValue() + \"]\";\n        }\n    }\n\n    /**\n     * Values implementation for the SingletonMap.\n     * This class is needed as values is a view that must update as the map updates.\n     */\n    static class SingletonValues<V> extends AbstractSet<V> implements Serializable {\n        private static final long serialVersionUID = -3689524741863047872L;\n        private final SingletonMap<?, V> parent;\n\n        SingletonValues(final SingletonMap<?, V> parent) {\n            this.parent = parent;\n        }\n\n        @Override\n        public void clear() {\n            throw new UnsupportedOperationException();\n        }\n        @Override\n        public boolean contains(final Object object) {\n            return parent.containsValue(object);\n        }\n        @Override\n        public boolean isEmpty() {\n            return false;\n        }\n        @Override\n        public Iterator<V> iterator() {\n            return new SingletonIterator<>(parent.getValue(), false);\n        }\n        @Override\n        public int size() {\n            return 1;\n        }\n    }\n    /** Serialization version */\n    private static final long serialVersionUID = -8931271118676803261L;\n\n    /** Singleton key */\n    private final K key;\n\n    /** Singleton value */\n    private V value;\n\n    /**\n     * Constructor that creates a map of {@code null} to {@code null}.\n     */\n    public SingletonMap() {\n        this.key = null;\n    }\n\n    /**\n     * Constructor specifying the key and value.\n     *\n     * @param key  the key to use\n     * @param value  the value to use\n     */\n    public SingletonMap(final K key, final V value) {\n        this.key = key;\n        this.value = value;\n    }\n\n    /**\n     * Constructor specifying the key and value as a {@code KeyValue}.\n     *\n     * @param keyValue  the key value pair to use\n     */\n    public SingletonMap(final KeyValue<K, V> keyValue) {\n        this.key = keyValue.getKey();\n        this.value = keyValue.getValue();\n    }\n\n    /**\n     * Constructor specifying the key and value as a {@code MapEntry}.\n     *\n     * @param mapEntry  the mapEntry to use\n     */\n    public SingletonMap(final Map.Entry<? extends K, ? extends V> mapEntry) {\n        this.key = mapEntry.getKey();\n        this.value = mapEntry.getValue();\n    }\n\n    /**\n     * Constructor copying elements from another map.\n     *\n     * @param map  the map to copy, must be size 1\n     * @throws NullPointerException if the map is null\n     * @throws IllegalArgumentException if the size is not 1\n     */\n    public SingletonMap(final Map<? extends K, ? extends V> map) {\n        if (map.size() != 1) {\n            throw new IllegalArgumentException(\"The map size must be 1\");\n        }\n        final Map.Entry<? extends K, ? extends V> entry = map.entrySet().iterator().next();\n        this.key = entry.getKey();\n        this.value = entry.getValue();\n    }\n\n    /**\n     * Unsupported operation.\n     */\n    @Override\n    public void clear() {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * Clones the map without cloning the key or value.\n     *\n     * @return a shallow clone\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public SingletonMap<K, V> clone() {\n        try {\n            return (SingletonMap<K, V>) super.clone();\n        } catch (final CloneNotSupportedException ex) {\n            throw new UnsupportedOperationException(ex);\n        }\n    }\n\n    /**\n     * Checks whether the map contains the specified key.\n     *\n     * @param key  the key to search for\n     * @return true if the map contains the key\n     */\n    @Override\n    public boolean containsKey(final Object key) {\n        return isEqualKey(key);\n    }\n\n    /**\n     * Checks whether the map contains the specified value.\n     *\n     * @param value  the value to search for\n     * @return true if the map contains the key\n     */\n    @Override\n    public boolean containsValue(final Object value) {\n        return isEqualValue(value);\n    }\n\n    /**\n     * Gets the entrySet view of the map.\n     * Changes made via {@code setValue} affect this map.\n     * To simply iterate through the entries, use {@link #mapIterator()}.\n     *\n     * @return the entrySet view\n     */\n    @Override\n    public Set<Map.Entry<K, V>> entrySet() {\n        final Map.Entry<K, V> entry = new TiedMapEntry<>(this, getKey());\n        return Collections.singleton(entry);\n    }\n\n    /**\n     * Compares this map with another.\n     *\n     * @param obj  the object to compare to\n     * @return true if equal\n     */\n    @Override\n    public boolean equals(final Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof Map)) {\n            return false;\n        }\n        final Map<?, ?> other = (Map<?, ?>) obj;\n        if (other.size() != 1) {\n            return false;\n        }\n        final Map.Entry<?, ?> entry = other.entrySet().iterator().next();\n        return isEqualKey(entry.getKey()) && isEqualValue(entry.getValue());\n    }\n\n    /**\n     * Gets the first (and only) key in the map.\n     *\n     * @return the key\n     */\n    @Override\n    public K firstKey() {\n        return getKey();\n    }\n\n    // Map\n    /**\n     * Gets the value mapped to the key specified.\n     *\n     * @param key  the key\n     * @return the mapped value, null if no match\n     */\n    @Override\n    public V get(final Object key) {\n        if (isEqualKey(key)) {\n            return value;\n        }\n        return null;\n    }\n\n    // KeyValue\n    /**\n     * Gets the key.\n     *\n     * @return the key\n     */\n    @Override\n    public K getKey() {\n        return key;\n    }\n\n    /**\n     * Gets the value.\n     *\n     * @return the value\n     */\n    @Override\n    public V getValue() {\n        return value;\n    }\n\n    /**\n     * Gets the standard Map hashCode.\n     *\n     * @return the hash code defined in the Map interface\n     */\n    @Override\n    public int hashCode() {\n        return (getKey() == null ? 0 : getKey().hashCode()) ^\n               (getValue() == null ? 0 : getValue().hashCode());\n    }\n\n    /**\n     * Checks whether the map is currently empty, which it never is.\n     *\n     * @return false always\n     */\n    @Override\n    public boolean isEmpty() {\n        return false;\n    }\n\n    /**\n     * Compares the specified key to the stored key.\n     *\n     * @param key  the key to compare\n     * @return true if equal\n     */\n    protected boolean isEqualKey(final Object key) {\n        return key == null ? getKey() == null : key.equals(getKey());\n    }\n\n    /**\n     * Compares the specified value to the stored value.\n     *\n     * @param value  the value to compare\n     * @return true if equal\n     */\n    protected boolean isEqualValue(final Object value) {\n        return value == null ? getValue() == null : value.equals(getValue());\n    }\n\n    // BoundedMap\n    /**\n     * Is the map currently full, always true.\n     *\n     * @return true always\n     */\n    @Override\n    public boolean isFull() {\n        return true;\n    }\n\n    /**\n     * Gets the unmodifiable keySet view of the map.\n     * Changes made to the view affect this map.\n     * To simply iterate through the keys, use {@link #mapIterator()}.\n     *\n     * @return the keySet view\n     */\n    @Override\n    public Set<K> keySet() {\n        return Collections.singleton(key);\n    }\n\n    /**\n     * Gets the last (and only) key in the map.\n     *\n     * @return the key\n     */\n    @Override\n    public K lastKey() {\n        return getKey();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public OrderedMapIterator<K, V> mapIterator() {\n        return new SingletonMapIterator<>(this);\n    }\n\n    /**\n     * Gets the maximum size of the map, always 1.\n     *\n     * @return 1 always\n     */\n    @Override\n    public int maxSize() {\n        return 1;\n    }\n\n    /**\n     * Gets the next key after the key specified, always null.\n     *\n     * @param key  the next key\n     * @return null always\n     */\n    @Override\n    public K nextKey(final K key) {\n        return null;\n    }\n\n    /**\n     * Gets the previous key before the key specified, always null.\n     *\n     * @param key  the next key\n     * @return null always\n     */\n    @Override\n    public K previousKey(final K key) {\n        return null;\n    }\n\n    /**\n     * Puts a key-value mapping into this map where the key must match the existing key.\n     * <p>\n     * An IllegalArgumentException is thrown if the key does not match as the map\n     * is fixed size.\n     *\n     * @param key  the key to set, must be the key of the map\n     * @param value  the value to set\n     * @return the value previously mapped to this key, null if none\n     * @throws IllegalArgumentException if the key does not match\n     */\n    @Override\n    public V put(final K key, final V value) {\n        if (isEqualKey(key)) {\n            return setValue(value);\n        }\n        throw new IllegalArgumentException(\"Cannot put new key/value pair - Map is fixed size singleton\");\n    }\n\n    /**\n     * Puts the values from the specified map into this map.\n     * <p>\n     * The map must be of size 0 or size 1.\n     * If it is size 1, the key must match the key of this map otherwise an\n     * IllegalArgumentException is thrown.\n     *\n     * @param map  the map to add, must be size 0 or 1, and the key must match\n     * @throws NullPointerException if the map is null\n     * @throws IllegalArgumentException if the key does not match\n     */\n    @Override\n    public void putAll(final Map<? extends K, ? extends V> map) {\n        switch (map.size()) {\n        case 0:\n            return;\n\n        case 1:\n            final Map.Entry<? extends K, ? extends V> entry = map.entrySet().iterator().next();\n            put(entry.getKey(), entry.getValue());\n            return;\n\n        default:\n            throw new IllegalArgumentException(\"The map size must be 0 or 1\");\n        }\n    }\n\n    /**\n     * Unsupported operation.\n     *\n     * @param key  the mapping to remove\n     * @return the value mapped to the removed key, null if key not in map\n     * @throws UnsupportedOperationException always\n     */\n    @Override\n    public V remove(final Object key) {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * Sets the value.\n     *\n     * @param value  the new value to set\n     * @return the old value\n     */\n    public V setValue(final V value) {\n        final V old = this.value;\n        this.value = value;\n        return old;\n    }\n\n    /**\n     * Gets the size of the map, always 1.\n     *\n     * @return the size of 1\n     */\n    @Override\n    public int size() {\n        return 1;\n    }\n\n    /**\n     * Gets the map as a String.\n     *\n     * @return a string version of the map\n     */\n    @Override\n    public String toString() {\n        return new StringBuilder(128)\n            .append('{')\n            .append(getKey() == this ? \"(this Map)\" : getKey())\n            .append('=')\n            .append(getValue() == this ? \"(this Map)\" : getValue())\n            .append('}')\n            .toString();\n    }\n\n    /**\n     * Gets the unmodifiable values view of the map.\n     * Changes made to the view affect this map.\n     * To simply iterate through the values, use {@link #mapIterator()}.\n     *\n     * @return the values view\n     */\n    @Override\n    public Collection<V> values() {\n        return new SingletonValues<>(this);\n    }\n\n}", "super_interfaces": ["OrderedMap<K, V>", "BoundedMap<K, V>", "KeyValue<K, V>", "Serializable", "Cloneable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = -8931271118676803261L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -8931271118676803261L", "syntax_pass": true}, {"attribute_expression": "private final K key;", "docstring": " Singleton key", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "K", "name": "key", "syntax_pass": true}, {"attribute_expression": "private V value;", "docstring": " Singleton value", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "V", "name": "value", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/map/HashedMap.java.HashedMap", "name": "HashedMap", "file_path": "src/main/java/org/apache/commons/collections4/map/HashedMap.java", "superclasses": "", "methods": ["[]HashedMap()", "[]HashedMap(int)", "[]HashedMap(int,float)", "[]HashedMap(Map<? extends K, ? extends V>)", "[HashedMap<K, V>]clone()", "[void]readObject(ObjectInputStream)", "[void]writeObject(ObjectOutputStream)"], "method_uris": ["src/main/java/org/apache/commons/collections4/map/HashedMap.java.HashedMap.[]HashedMap()", "src/main/java/org/apache/commons/collections4/map/HashedMap.java.HashedMap.[]HashedMap(int)", "src/main/java/org/apache/commons/collections4/map/HashedMap.java.HashedMap.[]HashedMap(int,float)", "src/main/java/org/apache/commons/collections4/map/HashedMap.java.HashedMap.[]HashedMap(Map<? extends K, ? extends V>)", "src/main/java/org/apache/commons/collections4/map/HashedMap.java.HashedMap.[HashedMap<K, V>]clone()", "src/main/java/org/apache/commons/collections4/map/HashedMap.java.HashedMap.[void]readObject(ObjectInputStream)", "src/main/java/org/apache/commons/collections4/map/HashedMap.java.HashedMap.[void]writeObject(ObjectOutputStream)"], "overrides": null, "attributes": [], "class_docstring": "\nA {@code Map} implementation that is a general purpose alternative\nto {@code HashMap}.\n<p>\nThis implementation improves on the JDK1.4 HashMap by adding the\n{@link org.apache.commons.collections4.MapIterator MapIterator}\nfunctionality and many methods for subclassing.\n</p>\n<p>\n<strong>Note that HashedMap is not synchronized and is not thread-safe.</strong>\nIf you wish to use this map from multiple threads concurrently, you must use\nappropriate synchronization. The simplest approach is to wrap this map\nusing {@link java.util.Collections#synchronizedMap(Map)}. This class may throw\nexceptions when accessed by concurrent threads without synchronization.\n</p>\n\n@param <K> the type of the keys in this map\n@param <V> the type of the values in this map\n@since 3.0\n", "original_string": "public class HashedMap<K, V>\n        extends AbstractHashedMap<K, V> implements Serializable, Cloneable {\n\n    /** Serialisation version */\n    private static final long serialVersionUID = -1788199231038721040L;\n\n    /**\n     * Constructs a new empty map with default size and load factor.\n     */\n    public HashedMap() {\n        super(DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_THRESHOLD);\n    }\n\n    /**\n     * Constructs a new, empty map with the specified initial capacity.\n     *\n     * @param initialCapacity  the initial capacity\n     * @throws IllegalArgumentException if the initial capacity is negative\n     */\n    public HashedMap(final int initialCapacity) {\n        super(initialCapacity);\n    }\n\n    /**\n     * Constructs a new, empty map with the specified initial capacity and\n     * load factor.\n     *\n     * @param initialCapacity  the initial capacity\n     * @param loadFactor  the load factor\n     * @throws IllegalArgumentException if the initial capacity is negative\n     * @throws IllegalArgumentException if the load factor is less than zero\n     */\n    public HashedMap(final int initialCapacity, final float loadFactor) {\n        super(initialCapacity, loadFactor);\n    }\n\n    /**\n     * Constructor copying elements from another map.\n     *\n     * @param map  the map to copy\n     * @throws NullPointerException if the map is null\n     */\n    public HashedMap(final Map<? extends K, ? extends V> map) {\n        super(map);\n    }\n\n    /**\n     * Clones the map without cloning the keys or values.\n     *\n     * @return a shallow clone\n     */\n    @Override\n    public HashedMap<K, V> clone() {\n        return (HashedMap<K, V>) super.clone();\n    }\n\n    /**\n     * Deserializes the map in using a custom routine.\n     *\n     * @param in the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded\n     */\n    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        doReadObject(in);\n    }\n\n    /**\n     * Serializes this object to an ObjectOutputStream.\n     *\n     * @param out the target ObjectOutputStream.\n     * @throws IOException thrown when an I/O errors occur writing to the target stream.\n     */\n    private void writeObject(final ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        doWriteObject(out);\n    }\n\n}", "super_interfaces": ["Serializable", "Cloneable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = -1788199231038721040L;", "docstring": " Serialisation version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -1788199231038721040L", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/map/FixedSizeMap.java.FixedSizeMap", "name": "FixedSizeMap", "file_path": "src/main/java/org/apache/commons/collections4/map/FixedSizeMap.java", "superclasses": "", "methods": ["[FixedSizeMap<K, V>]fixedSizeMap(Map<K, V>)", "[]FixedSizeMap(Map<K, V>)", "[void]clear()", "[Set<Map.Entry<K, V>>]entrySet()", "[boolean]isFull()", "[Set<K>]keySet()", "[int]maxSize()", "[V]put(K,V)", "[void]putAll(Map<? extends K, ? extends V>)", "[void]readObject(ObjectInputStream)", "[V]remove(Object)", "[Collection<V>]values()", "[void]writeObject(ObjectOutputStream)"], "method_uris": ["src/main/java/org/apache/commons/collections4/map/FixedSizeMap.java.FixedSizeMap.[FixedSizeMap<K, V>]fixedSizeMap(Map<K, V>)", "src/main/java/org/apache/commons/collections4/map/FixedSizeMap.java.FixedSizeMap.[]FixedSizeMap(Map<K, V>)", "src/main/java/org/apache/commons/collections4/map/FixedSizeMap.java.FixedSizeMap.[void]clear()", "src/main/java/org/apache/commons/collections4/map/FixedSizeMap.java.FixedSizeMap.[Set<Map.Entry<K, V>>]entrySet()", "src/main/java/org/apache/commons/collections4/map/FixedSizeMap.java.FixedSizeMap.[boolean]isFull()", "src/main/java/org/apache/commons/collections4/map/FixedSizeMap.java.FixedSizeMap.[Set<K>]keySet()", "src/main/java/org/apache/commons/collections4/map/FixedSizeMap.java.FixedSizeMap.[int]maxSize()", "src/main/java/org/apache/commons/collections4/map/FixedSizeMap.java.FixedSizeMap.[V]put(K,V)", "src/main/java/org/apache/commons/collections4/map/FixedSizeMap.java.FixedSizeMap.[void]putAll(Map<? extends K, ? extends V>)", "src/main/java/org/apache/commons/collections4/map/FixedSizeMap.java.FixedSizeMap.[void]readObject(ObjectInputStream)", "src/main/java/org/apache/commons/collections4/map/FixedSizeMap.java.FixedSizeMap.[V]remove(Object)", "src/main/java/org/apache/commons/collections4/map/FixedSizeMap.java.FixedSizeMap.[Collection<V>]values()", "src/main/java/org/apache/commons/collections4/map/FixedSizeMap.java.FixedSizeMap.[void]writeObject(ObjectOutputStream)"], "overrides": null, "attributes": [], "class_docstring": "\nDecorates another {@code Map} to fix the size, preventing add/remove.\n<p>\nAny action that would change the size of the map is disallowed.\nThe put method is allowed to change the value associated with an existing\nkey however.\n</p>\n<p>\nIf trying to remove or clear the map, an UnsupportedOperationException is\nthrown. If trying to put a new mapping into the map, an\nIllegalArgumentException is thrown. This is because the put method can\nsucceed if the mapping's key already exists in the map, so the put method\nis not always unsupported.\n</p>\n<p>\n<strong>Note that FixedSizeMap is not synchronized and is not thread-safe.</strong>\nIf you wish to use this map from multiple threads concurrently, you must use\nappropriate synchronization. The simplest approach is to wrap this map\nusing {@link java.util.Collections#synchronizedMap(Map)}. This class may throw\nexceptions when accessed by concurrent threads without synchronization.\n</p>\n<p>\nThis class is Serializable from Commons Collections 3.1.\n</p>\n\n@param <K> the type of the keys in this map\n@param <V> the type of the values in this map\n@since 3.0\n", "original_string": "public class FixedSizeMap<K, V>\n        extends AbstractMapDecorator<K, V>\n        implements BoundedMap<K, V>, Serializable {\n\n    /** Serialization version */\n    private static final long serialVersionUID = 7450927208116179316L;\n\n    /**\n     * Factory method to create a fixed size map.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param map  the map to decorate, must not be null\n     * @return a new fixed size map\n     * @throws NullPointerException if map is null\n     * @since 4.0\n     */\n    public static <K, V> FixedSizeMap<K, V> fixedSizeMap(final Map<K, V> map) {\n        return new FixedSizeMap<>(map);\n    }\n\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param map  the map to decorate, must not be null\n     * @throws NullPointerException if map is null\n     */\n    protected FixedSizeMap(final Map<K, V> map) {\n        super(map);\n    }\n\n    @Override\n    public void clear() {\n        throw new UnsupportedOperationException(\"Map is fixed size\");\n    }\n\n    @Override\n    public Set<Map.Entry<K, V>> entrySet() {\n        final Set<Map.Entry<K, V>> set = map.entrySet();\n        // unmodifiable set will still allow modification via Map.Entry objects\n        return UnmodifiableSet.unmodifiableSet(set);\n    }\n\n    @Override\n    public boolean isFull() {\n        return true;\n    }\n\n    @Override\n    public Set<K> keySet() {\n        final Set<K> set = map.keySet();\n        return UnmodifiableSet.unmodifiableSet(set);\n    }\n\n    @Override\n    public int maxSize() {\n        return size();\n    }\n\n    @Override\n    public V put(final K key, final V value) {\n        if (!map.containsKey(key)) {\n            throw new IllegalArgumentException(\"Cannot put new key/value pair - Map is fixed size\");\n        }\n        return map.put(key, value);\n    }\n\n    @Override\n    public void putAll(final Map<? extends K, ? extends V> mapToCopy) {\n        for (final K key : mapToCopy.keySet()) {\n            if (!containsKey(key)) {\n                throw new IllegalArgumentException(\"Cannot put new key/value pair - Map is fixed size\");\n            }\n        }\n        map.putAll(mapToCopy);\n    }\n\n    /**\n     * Deserializes the map in using a custom routine.\n     *\n     * @param in  the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded\n     * @since 3.1\n     */\n    @SuppressWarnings(\"unchecked\") // (1) should only fail if input stream is incorrect\n    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        map = (Map<K, V>) in.readObject(); // (1)\n    }\n\n    @Override\n    public V remove(final Object key) {\n        throw new UnsupportedOperationException(\"Map is fixed size\");\n    }\n\n    @Override\n    public Collection<V> values() {\n        final Collection<V> coll = map.values();\n        return UnmodifiableCollection.unmodifiableCollection(coll);\n    }\n\n    /**\n     * Serializes this object to an ObjectOutputStream.\n     *\n     * @param out the target ObjectOutputStream.\n     * @throws IOException thrown when an I/O errors occur writing to the target stream.\n     * @since 3.1\n     */\n    private void writeObject(final ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        out.writeObject(map);\n    }\n\n}", "super_interfaces": ["BoundedMap<K, V>", "Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 7450927208116179316L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 7450927208116179316L", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/map/StaticBucketMap.java.StaticBucketMap", "name": "StaticBucketMap", "file_path": "src/main/java/org/apache/commons/collections4/map/StaticBucketMap.java", "superclasses": "", "methods": ["[]StaticBucketMap()", "[]StaticBucketMap(int)", "[void]atomic(Runnable)", "[void]atomic(Runnable,int)", "[void]clear()", "[boolean]containsKey(Object)", "[boolean]containsValue(Object)", "[Set<Map.Entry<K, V>>]entrySet()", "[boolean]equals(Object)", "[V]get(Object)", "[int]getHash(Object)", "[int]hashCode()", "[boolean]isEmpty()", "[Set<K>]keySet()", "[V]put(K,V)", "[void]putAll(Map<? extends K, ? extends V>)", "[V]remove(Object)", "[int]size()", "[Collection<V>]values()"], "method_uris": ["src/main/java/org/apache/commons/collections4/map/StaticBucketMap.java.StaticBucketMap.[]StaticBucketMap()", "src/main/java/org/apache/commons/collections4/map/StaticBucketMap.java.StaticBucketMap.[]StaticBucketMap(int)", "src/main/java/org/apache/commons/collections4/map/StaticBucketMap.java.StaticBucketMap.[void]atomic(Runnable)", "src/main/java/org/apache/commons/collections4/map/StaticBucketMap.java.StaticBucketMap.[void]atomic(Runnable,int)", "src/main/java/org/apache/commons/collections4/map/StaticBucketMap.java.StaticBucketMap.[void]clear()", "src/main/java/org/apache/commons/collections4/map/StaticBucketMap.java.StaticBucketMap.[boolean]containsKey(Object)", "src/main/java/org/apache/commons/collections4/map/StaticBucketMap.java.StaticBucketMap.[boolean]containsValue(Object)", "src/main/java/org/apache/commons/collections4/map/StaticBucketMap.java.StaticBucketMap.[Set<Map.Entry<K, V>>]entrySet()", "src/main/java/org/apache/commons/collections4/map/StaticBucketMap.java.StaticBucketMap.[boolean]equals(Object)", "src/main/java/org/apache/commons/collections4/map/StaticBucketMap.java.StaticBucketMap.[V]get(Object)", "src/main/java/org/apache/commons/collections4/map/StaticBucketMap.java.StaticBucketMap.[int]getHash(Object)", "src/main/java/org/apache/commons/collections4/map/StaticBucketMap.java.StaticBucketMap.[int]hashCode()", "src/main/java/org/apache/commons/collections4/map/StaticBucketMap.java.StaticBucketMap.[boolean]isEmpty()", "src/main/java/org/apache/commons/collections4/map/StaticBucketMap.java.StaticBucketMap.[Set<K>]keySet()", "src/main/java/org/apache/commons/collections4/map/StaticBucketMap.java.StaticBucketMap.[V]put(K,V)", "src/main/java/org/apache/commons/collections4/map/StaticBucketMap.java.StaticBucketMap.[void]putAll(Map<? extends K, ? extends V>)", "src/main/java/org/apache/commons/collections4/map/StaticBucketMap.java.StaticBucketMap.[V]remove(Object)", "src/main/java/org/apache/commons/collections4/map/StaticBucketMap.java.StaticBucketMap.[int]size()", "src/main/java/org/apache/commons/collections4/map/StaticBucketMap.java.StaticBucketMap.[Collection<V>]values()"], "overrides": null, "attributes": [{"original_string": "    class BaseIterator {\n        private final ArrayList<Map.Entry<K, V>> current = new ArrayList<>();\n        private int bucket;\n        private Map.Entry<K, V> last;\n\n        public boolean hasNext() {\n            if (!current.isEmpty()) {\n                return true;\n            }\n            while (bucket < buckets.length) {\n                synchronized (locks[bucket]) {\n                    Node<K, V> n = buckets[bucket];\n                    while (n != null) {\n                        current.add(n);\n                        n = n.next;\n                    }\n                    bucket++;\n                    if (!current.isEmpty()) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        protected Map.Entry<K, V> nextEntry() {\n            if (!hasNext()) {\n                throw new NoSuchElementException();\n            }\n            last = current.remove(current.size() - 1);\n            return last;\n        }\n\n        public void remove() {\n            if (last == null) {\n                throw new IllegalStateException();\n            }\n            StaticBucketMap.this.remove(last.getKey());\n            last = null;\n        }\n    }", "definition": "    class BaseIterator", "class_docstring": "", "name": "BaseIterator", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "fields": [{"attribute_expression": "private final ArrayList<Map.Entry<K, V>> current = new ArrayList<>();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ArrayList<Map.Entry<K, V>>", "name": "current = new ArrayList<>()", "syntax_pass": true}, {"attribute_expression": "private int bucket;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "bucket", "syntax_pass": true}, {"attribute_expression": "private Map.Entry<K, V> last;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Map.Entry<K, V>", "name": "last", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public boolean hasNext() {\n            if (!current.isEmpty()) {\n                return true;\n            }\n            while (bucket < buckets.length) {\n                synchronized (locks[bucket]) {\n                    Node<K, V> n = buckets[bucket];\n                    while (n != null) {\n                        current.add(n);\n                        n = n.next;\n                    }\n                    bucket++;\n                    if (!current.isEmpty()) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasNext", "params": [], "body": "                                 {\n            if (!current.isEmpty()) {\n                return true;\n            }\n            while (bucket < buckets.length) {\n                synchronized (locks[bucket]) {\n                    Node<K, V> n = buckets[bucket];\n                    while (n != null) {\n                        current.add(n);\n                        n = n.next;\n                    }\n                    bucket++;\n                    if (!current.isEmpty()) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }", "signature": "public boolean hasNext()"}, {"syntax_pass": true, "original_string": "        protected Map.Entry<K, V> nextEntry() {\n            if (!hasNext()) {\n                throw new NoSuchElementException();\n            }\n            last = current.remove(current.size() - 1);\n            return last;\n        }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Map.Entry<K, V>", "classes": []}, "name": "nextEntry", "params": [], "body": "                                              {\n            if (!hasNext()) {\n                throw new NoSuchElementException();\n            }\n            last = current.remove(current.size() - 1);\n            return last;\n        }", "signature": "protected Map.Entry<K, V> nextEntry()"}, {"syntax_pass": true, "original_string": "        public void remove() {\n            if (last == null) {\n                throw new IllegalStateException();\n            }\n            StaticBucketMap.this.remove(last.getKey());\n            last = null;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "remove", "params": [], "body": "                             {\n            if (last == null) {\n                throw new IllegalStateException();\n            }\n            StaticBucketMap.this.remove(last.getKey());\n            last = null;\n        }", "signature": "public void remove()"}]}, {"original_string": "    private final class EntryIterator extends BaseIterator implements Iterator<Map.Entry<K, V>> {\n\n        @Override\n        public Map.Entry<K, V> next() {\n            return nextEntry();\n        }\n\n    }", "definition": "    private final class EntryIterator extends BaseIterator implements Iterator<Map.Entry<K, V>>", "class_docstring": "", "name": "EntryIterator", "super_interfaces": ["Iterator<Map.Entry<K, V>>"], "superclasses": "BaseIterator", "attributes": {"modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @Override\n        public Map.Entry<K, V> next() {\n            return nextEntry();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map.Entry<K, V>", "classes": []}, "name": "next", "params": [], "body": "                                      {\n            return nextEntry();\n        }", "signature": "@Override\n        public Map.Entry<K, V> next()"}]}, {"original_string": "    private final class EntrySet extends AbstractSet<Map.Entry<K, V>> {\n\n        @Override\n        public void clear() {\n            StaticBucketMap.this.clear();\n        }\n\n        @Override\n        public boolean contains(final Object obj) {\n            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n            final int hash = getHash(entry.getKey());\n            synchronized (locks[hash]) {\n                for (Node<K, V> n = buckets[hash]; n != null; n = n.next) {\n                    if (n.equals(entry)) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        @Override\n        public Iterator<Map.Entry<K, V>> iterator() {\n            return new EntryIterator();\n        }\n\n        @Override\n        public boolean remove(final Object obj) {\n            if (!(obj instanceof Map.Entry<?, ?>)) {\n                return false;\n            }\n            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n            final int hash = getHash(entry.getKey());\n            synchronized (locks[hash]) {\n                for (Node<K, V> n = buckets[hash]; n != null; n = n.next) {\n                    if (n.equals(entry)) {\n                        StaticBucketMap.this.remove(n.getKey());\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        @Override\n        public int size() {\n            return StaticBucketMap.this.size();\n        }\n\n    }", "definition": "    private final class EntrySet extends AbstractSet<Map.Entry<K, V>>", "class_docstring": "", "name": "EntrySet", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @Override\n        public void clear() {\n            StaticBucketMap.this.clear();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "clear", "params": [], "body": "                            {\n            StaticBucketMap.this.clear();\n        }", "signature": "@Override\n        public void clear()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean contains(final Object obj) {\n            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n            final int hash = getHash(entry.getKey());\n            synchronized (locks[hash]) {\n                for (Node<K, V> n = buckets[hash]; n != null; n = n.next) {\n                    if (n.equals(entry)) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "contains", "params": [{"name": "obj", "type": "Object"}], "body": "                                                  {\n            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n            final int hash = getHash(entry.getKey());\n            synchronized (locks[hash]) {\n                for (Node<K, V> n = buckets[hash]; n != null; n = n.next) {\n                    if (n.equals(entry)) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }", "signature": "@Override\n        public boolean contains(final Object obj)"}, {"syntax_pass": true, "original_string": "        @Override\n        public Iterator<Map.Entry<K, V>> iterator() {\n            return new EntryIterator();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Iterator<Map.Entry<K, V>>", "classes": []}, "name": "iterator", "params": [], "body": "                                                    {\n            return new EntryIterator();\n        }", "signature": "@Override\n        public Iterator<Map.Entry<K, V>> iterator()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean remove(final Object obj) {\n            if (!(obj instanceof Map.Entry<?, ?>)) {\n                return false;\n            }\n            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n            final int hash = getHash(entry.getKey());\n            synchronized (locks[hash]) {\n                for (Node<K, V> n = buckets[hash]; n != null; n = n.next) {\n                    if (n.equals(entry)) {\n                        StaticBucketMap.this.remove(n.getKey());\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "remove", "params": [{"name": "obj", "type": "Object"}], "body": "                                                {\n            if (!(obj instanceof Map.Entry<?, ?>)) {\n                return false;\n            }\n            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n            final int hash = getHash(entry.getKey());\n            synchronized (locks[hash]) {\n                for (Node<K, V> n = buckets[hash]; n != null; n = n.next) {\n                    if (n.equals(entry)) {\n                        StaticBucketMap.this.remove(n.getKey());\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }", "signature": "@Override\n        public boolean remove(final Object obj)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int size() {\n            return StaticBucketMap.this.size();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "size", "params": [], "body": "                          {\n            return StaticBucketMap.this.size();\n        }", "signature": "@Override\n        public int size()"}]}, {"original_string": "    private final class KeyIterator extends BaseIterator implements Iterator<K> {\n\n        @Override\n        public K next() {\n            return nextEntry().getKey();\n        }\n\n    }", "definition": "    private final class KeyIterator extends BaseIterator implements Iterator<K>", "class_docstring": "", "name": "KeyIterator", "super_interfaces": ["Iterator<K>"], "superclasses": "BaseIterator", "attributes": {"modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @Override\n        public K next() {\n            return nextEntry().getKey();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "K", "classes": []}, "name": "next", "params": [], "body": "                        {\n            return nextEntry().getKey();\n        }", "signature": "@Override\n        public K next()"}]}, {"original_string": "    private final class KeySet extends AbstractSet<K> {\n\n        @Override\n        public void clear() {\n            StaticBucketMap.this.clear();\n        }\n\n        @Override\n        public boolean contains(final Object obj) {\n            return StaticBucketMap.this.containsKey(obj);\n        }\n\n        @Override\n        public Iterator<K> iterator() {\n            return new KeyIterator();\n        }\n\n        @Override\n        public boolean remove(final Object obj) {\n            final int hash = getHash(obj);\n            synchronized (locks[hash]) {\n                for (Node<K, V> n = buckets[hash]; n != null; n = n.next) {\n                    final Object k = n.getKey();\n                    if (Objects.equals(k, obj)) {\n                        StaticBucketMap.this.remove(k);\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        @Override\n        public int size() {\n            return StaticBucketMap.this.size();\n        }\n\n    }", "definition": "    private final class KeySet extends AbstractSet<K>", "class_docstring": "", "name": "KeySet", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @Override\n        public void clear() {\n            StaticBucketMap.this.clear();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "clear", "params": [], "body": "                            {\n            StaticBucketMap.this.clear();\n        }", "signature": "@Override\n        public void clear()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean contains(final Object obj) {\n            return StaticBucketMap.this.containsKey(obj);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "contains", "params": [{"name": "obj", "type": "Object"}], "body": "                                                  {\n            return StaticBucketMap.this.containsKey(obj);\n        }", "signature": "@Override\n        public boolean contains(final Object obj)"}, {"syntax_pass": true, "original_string": "        @Override\n        public Iterator<K> iterator() {\n            return new KeyIterator();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Iterator<K>", "classes": []}, "name": "iterator", "params": [], "body": "                                      {\n            return new KeyIterator();\n        }", "signature": "@Override\n        public Iterator<K> iterator()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean remove(final Object obj) {\n            final int hash = getHash(obj);\n            synchronized (locks[hash]) {\n                for (Node<K, V> n = buckets[hash]; n != null; n = n.next) {\n                    final Object k = n.getKey();\n                    if (Objects.equals(k, obj)) {\n                        StaticBucketMap.this.remove(k);\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "remove", "params": [{"name": "obj", "type": "Object"}], "body": "                                                {\n            final int hash = getHash(obj);\n            synchronized (locks[hash]) {\n                for (Node<K, V> n = buckets[hash]; n != null; n = n.next) {\n                    final Object k = n.getKey();\n                    if (Objects.equals(k, obj)) {\n                        StaticBucketMap.this.remove(k);\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }", "signature": "@Override\n        public boolean remove(final Object obj)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int size() {\n            return StaticBucketMap.this.size();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "size", "params": [], "body": "                          {\n            return StaticBucketMap.this.size();\n        }", "signature": "@Override\n        public int size()"}]}, {"original_string": "    private static final class Lock {\n        public int size;\n    }", "definition": "    private static final class Lock", "class_docstring": "\nThe lock object, which also includes a count of the nodes in this lock.\n", "name": "Lock", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "fields": [{"attribute_expression": "public int size;", "docstring": "", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "int", "name": "size", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": []}, {"original_string": "    private static final class Node<K, V> implements Map.Entry<K, V>, KeyValue<K, V> {\n        protected K key;\n        protected V value;\n        protected Node<K, V> next;\n\n        @Override\n        public boolean equals(final Object obj) {\n            if (obj == this) {\n                return true;\n            }\n            if (!(obj instanceof Map.Entry<?, ?>)) {\n                return false;\n            }\n\n            final Map.Entry<?, ?> e2 = (Map.Entry<?, ?>) obj;\n            return (key == null ? e2.getKey() == null : key.equals(e2.getKey())) &&\n                (value == null ? e2.getValue() == null : value.equals(e2.getValue()));\n        }\n\n        @Override\n        public K getKey() {\n            return key;\n        }\n\n        @Override\n        public V getValue() {\n            return value;\n        }\n\n        @Override\n        public int hashCode() {\n            return (key == null ? 0 : key.hashCode()) ^\n                    (value == null ? 0 : value.hashCode());\n        }\n\n        @Override\n        public V setValue(final V value) {\n            final V old = this.value;\n            this.value = value;\n            return old;\n        }\n    }", "definition": "    private static final class Node<K, V> implements Map.Entry<K, V>, KeyValue<K, V>", "class_docstring": "\nThe Map.Entry for the StaticBucketMap.\n", "name": "Node", "super_interfaces": ["Map.Entry<K, V>", "KeyValue<K, V>"], "superclasses": "", "attributes": {"modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "fields": [{"attribute_expression": "protected K key;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "K", "name": "key", "syntax_pass": true}, {"attribute_expression": "protected V value;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "V", "name": "value", "syntax_pass": true}, {"attribute_expression": "protected Node<K, V> next;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Node<K, V>", "name": "next", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @Override\n        public boolean equals(final Object obj) {\n            if (obj == this) {\n                return true;\n            }\n            if (!(obj instanceof Map.Entry<?, ?>)) {\n                return false;\n            }\n\n            final Map.Entry<?, ?> e2 = (Map.Entry<?, ?>) obj;\n            return (key == null ? e2.getKey() == null : key.equals(e2.getKey())) &&\n                (value == null ? e2.getValue() == null : value.equals(e2.getValue()));\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "obj", "type": "Object"}], "body": "                                                {\n            if (obj == this) {\n                return true;\n            }\n            if (!(obj instanceof Map.Entry<?, ?>)) {\n                return false;\n            }\n\n            final Map.Entry<?, ?> e2 = (Map.Entry<?, ?>) obj;\n            return (key == null ? e2.getKey() == null : key.equals(e2.getKey())) &&\n                (value == null ? e2.getValue() == null : value.equals(e2.getValue()));\n        }", "signature": "@Override\n        public boolean equals(final Object obj)"}, {"syntax_pass": true, "original_string": "        @Override\n        public K getKey() {\n            return key;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "K", "classes": []}, "name": "getKey", "params": [], "body": "                          {\n            return key;\n        }", "signature": "@Override\n        public K getKey()"}, {"syntax_pass": true, "original_string": "        @Override\n        public V getValue() {\n            return value;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "getValue", "params": [], "body": "                            {\n            return value;\n        }", "signature": "@Override\n        public V getValue()"}, {"syntax_pass": true, "original_string": "        @Override\n        public int hashCode() {\n            return (key == null ? 0 : key.hashCode()) ^\n                    (value == null ? 0 : value.hashCode());\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                              {\n            return (key == null ? 0 : key.hashCode()) ^\n                    (value == null ? 0 : value.hashCode());\n        }", "signature": "@Override\n        public int hashCode()"}, {"syntax_pass": true, "original_string": "        @Override\n        public V setValue(final V value) {\n            final V old = this.value;\n            this.value = value;\n            return old;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "setValue", "params": [{"name": "value", "type": "V"}], "body": "                                         {\n            final V old = this.value;\n            this.value = value;\n            return old;\n        }", "signature": "@Override\n        public V setValue(final V value)"}]}, {"original_string": "    private final class ValueIterator extends BaseIterator implements Iterator<V> {\n\n        @Override\n        public V next() {\n            return nextEntry().getValue();\n        }\n\n    }", "definition": "    private final class ValueIterator extends BaseIterator implements Iterator<V>", "class_docstring": "", "name": "ValueIterator", "super_interfaces": ["Iterator<V>"], "superclasses": "BaseIterator", "attributes": {"modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @Override\n        public V next() {\n            return nextEntry().getValue();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "next", "params": [], "body": "                        {\n            return nextEntry().getValue();\n        }", "signature": "@Override\n        public V next()"}]}, {"original_string": "    private final class Values extends AbstractCollection<V> {\n\n        @Override\n        public void clear() {\n            StaticBucketMap.this.clear();\n        }\n\n        @Override\n        public Iterator<V> iterator() {\n            return new ValueIterator();\n        }\n\n        @Override\n        public int size() {\n            return StaticBucketMap.this.size();\n        }\n\n    }", "definition": "    private final class Values extends AbstractCollection<V>", "class_docstring": "", "name": "Values", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @Override\n        public void clear() {\n            StaticBucketMap.this.clear();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "clear", "params": [], "body": "                            {\n            StaticBucketMap.this.clear();\n        }", "signature": "@Override\n        public void clear()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Iterator<V> iterator() {\n            return new ValueIterator();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Iterator<V>", "classes": []}, "name": "iterator", "params": [], "body": "                                      {\n            return new ValueIterator();\n        }", "signature": "@Override\n        public Iterator<V> iterator()"}, {"syntax_pass": true, "original_string": "        @Override\n        public int size() {\n            return StaticBucketMap.this.size();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "size", "params": [], "body": "                          {\n            return StaticBucketMap.this.size();\n        }", "signature": "@Override\n        public int size()"}]}], "class_docstring": "\nA StaticBucketMap is an efficient, thread-safe implementation of\n{@link java.util.Map} that performs well in a highly\nthread-contentious environment.\n<p>\nThe map supports very efficient\n{@link #get(Object) get}, {@link #put(Object,Object) put},\n{@link #remove(Object) remove} and {@link #containsKey(Object) containsKey}\noperations, assuming (approximate) uniform hashing and\nthat the number of entries does not exceed the number of buckets.  If the\nnumber of entries exceeds the number of buckets or if the hash codes of the\nobjects are not uniformly distributed, these operations have a worst case\nscenario that is proportional to the number of elements in the map\n(<em>O(n)</em>).\n</p>\n<p>\nEach bucket in the hash table has its own monitor, so two threads can\nsafely operate on the map at the same time, often without incurring any\nmonitor contention.  This means that you don't have to wrap instances\nof this class with {@link java.util.Collections#synchronizedMap(Map)};\ninstances are already thread-safe.  Unfortunately, however, this means\nthat this map implementation behaves in ways you may find disconcerting.\nBulk operations, such as {@link #putAll(Map) putAll} or the\n{@link Collection#retainAll(Collection) retainAll} operation in collection\nviews, are <em>not</em> atomic.  If two threads are simultaneously\nexecuting\n</p>\n\n<pre>\n  staticBucketMapInstance.putAll(map);\n</pre>\n\nand\n\n<pre>\n  staticBucketMapInstance.entrySet().removeAll(map.entrySet());\n</pre>\n\n<p>\nthen the results are generally random.  Those two statement could cancel\neach other out, leaving {@code staticBucketMapInstance} essentially\nunchanged, or they could leave some random subset of {@code map} in\n{@code staticBucketMapInstance}.\n</p>\n<p>\nAlso, much like an encyclopedia, the results of {@link #size()} and\n{@link #isEmpty()} are out-of-date as soon as they are produced.\n</p>\n<p>\nThe iterators returned by the collection views of this class are <em>not</em>\nfail-fast.  They will <em>never</em> raise a\n{@link java.util.ConcurrentModificationException}.  Keys and values\nadded to the map after the iterator is created do not necessarily appear\nduring iteration.  Similarly, the iterator does not necessarily fail to\nreturn keys and values that were removed after the iterator was created.\n</p>\n<p>\nFinally, unlike {@link java.util.HashMap}-style implementations, this\nclass <em>never</em> rehashes the map.  The number of buckets is fixed\nat construction time and never altered.  Performance may degrade if\nyou do not allocate enough buckets upfront.\n</p>\n<p>\nThe {@link #atomic(Runnable)} method is provided to allow atomic iterations\nand bulk operations; however, overuse of {@link #atomic(Runnable) atomic}\nwill basically result in a map that's slower than an ordinary synchronized\n{@link java.util.HashMap}.\n</p>\n<p>\nUse this class if you do not require reliable bulk operations and\niterations, or if you can make your own guarantees about how bulk\noperations will affect the map.\n</p>\n\n@param <K> the type of the keys in this map\n@param <V> the type of the values in this map\n@since 3.0 (previously in main package v2.1)\n", "original_string": "public final class StaticBucketMap<K, V> extends AbstractIterableMap<K, V> {\n\n    class BaseIterator {\n        private final ArrayList<Map.Entry<K, V>> current = new ArrayList<>();\n        private int bucket;\n        private Map.Entry<K, V> last;\n\n        public boolean hasNext() {\n            if (!current.isEmpty()) {\n                return true;\n            }\n            while (bucket < buckets.length) {\n                synchronized (locks[bucket]) {\n                    Node<K, V> n = buckets[bucket];\n                    while (n != null) {\n                        current.add(n);\n                        n = n.next;\n                    }\n                    bucket++;\n                    if (!current.isEmpty()) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        protected Map.Entry<K, V> nextEntry() {\n            if (!hasNext()) {\n                throw new NoSuchElementException();\n            }\n            last = current.remove(current.size() - 1);\n            return last;\n        }\n\n        public void remove() {\n            if (last == null) {\n                throw new IllegalStateException();\n            }\n            StaticBucketMap.this.remove(last.getKey());\n            last = null;\n        }\n    }\n\n    private final class EntryIterator extends BaseIterator implements Iterator<Map.Entry<K, V>> {\n\n        @Override\n        public Map.Entry<K, V> next() {\n            return nextEntry();\n        }\n\n    }\n\n    private final class EntrySet extends AbstractSet<Map.Entry<K, V>> {\n\n        @Override\n        public void clear() {\n            StaticBucketMap.this.clear();\n        }\n\n        @Override\n        public boolean contains(final Object obj) {\n            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n            final int hash = getHash(entry.getKey());\n            synchronized (locks[hash]) {\n                for (Node<K, V> n = buckets[hash]; n != null; n = n.next) {\n                    if (n.equals(entry)) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        @Override\n        public Iterator<Map.Entry<K, V>> iterator() {\n            return new EntryIterator();\n        }\n\n        @Override\n        public boolean remove(final Object obj) {\n            if (!(obj instanceof Map.Entry<?, ?>)) {\n                return false;\n            }\n            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n            final int hash = getHash(entry.getKey());\n            synchronized (locks[hash]) {\n                for (Node<K, V> n = buckets[hash]; n != null; n = n.next) {\n                    if (n.equals(entry)) {\n                        StaticBucketMap.this.remove(n.getKey());\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        @Override\n        public int size() {\n            return StaticBucketMap.this.size();\n        }\n\n    }\n\n    private final class KeyIterator extends BaseIterator implements Iterator<K> {\n\n        @Override\n        public K next() {\n            return nextEntry().getKey();\n        }\n\n    }\n\n    private final class KeySet extends AbstractSet<K> {\n\n        @Override\n        public void clear() {\n            StaticBucketMap.this.clear();\n        }\n\n        @Override\n        public boolean contains(final Object obj) {\n            return StaticBucketMap.this.containsKey(obj);\n        }\n\n        @Override\n        public Iterator<K> iterator() {\n            return new KeyIterator();\n        }\n\n        @Override\n        public boolean remove(final Object obj) {\n            final int hash = getHash(obj);\n            synchronized (locks[hash]) {\n                for (Node<K, V> n = buckets[hash]; n != null; n = n.next) {\n                    final Object k = n.getKey();\n                    if (Objects.equals(k, obj)) {\n                        StaticBucketMap.this.remove(k);\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        @Override\n        public int size() {\n            return StaticBucketMap.this.size();\n        }\n\n    }\n\n    /**\n     * The lock object, which also includes a count of the nodes in this lock.\n     */\n    private static final class Lock {\n        public int size;\n    }\n\n    /**\n     * The Map.Entry for the StaticBucketMap.\n     */\n    private static final class Node<K, V> implements Map.Entry<K, V>, KeyValue<K, V> {\n        protected K key;\n        protected V value;\n        protected Node<K, V> next;\n\n        @Override\n        public boolean equals(final Object obj) {\n            if (obj == this) {\n                return true;\n            }\n            if (!(obj instanceof Map.Entry<?, ?>)) {\n                return false;\n            }\n\n            final Map.Entry<?, ?> e2 = (Map.Entry<?, ?>) obj;\n            return (key == null ? e2.getKey() == null : key.equals(e2.getKey())) &&\n                (value == null ? e2.getValue() == null : value.equals(e2.getValue()));\n        }\n\n        @Override\n        public K getKey() {\n            return key;\n        }\n\n        @Override\n        public V getValue() {\n            return value;\n        }\n\n        @Override\n        public int hashCode() {\n            return (key == null ? 0 : key.hashCode()) ^\n                    (value == null ? 0 : value.hashCode());\n        }\n\n        @Override\n        public V setValue(final V value) {\n            final V old = this.value;\n            this.value = value;\n            return old;\n        }\n    }\n\n    private final class ValueIterator extends BaseIterator implements Iterator<V> {\n\n        @Override\n        public V next() {\n            return nextEntry().getValue();\n        }\n\n    }\n\n    private final class Values extends AbstractCollection<V> {\n\n        @Override\n        public void clear() {\n            StaticBucketMap.this.clear();\n        }\n\n        @Override\n        public Iterator<V> iterator() {\n            return new ValueIterator();\n        }\n\n        @Override\n        public int size() {\n            return StaticBucketMap.this.size();\n        }\n\n    }\n\n    /** The default number of buckets to use */\n    private static final int DEFAULT_BUCKETS = 255;\n\n    /** The array of buckets, where the actual data is held */\n    private final Node<K, V>[] buckets;\n\n    /** The matching array of locks */\n    private final Lock[] locks;\n\n    /**\n     * Initializes the map with the default number of buckets (255).\n     */\n    public StaticBucketMap() {\n        this(DEFAULT_BUCKETS);\n    }\n\n    /**\n     * Initializes the map with a specified number of buckets.  The number\n     * of buckets is never below 17, and is always an odd number (StaticBucketMap\n     * ensures this). The number of buckets is inversely proportional to the\n     * chances for thread contention.  The fewer buckets, the more chances for\n     * thread contention.  The more buckets the fewer chances for thread\n     * contention.\n     *\n     * @param numBuckets  the number of buckets for this map\n     */\n    @SuppressWarnings(\"unchecked\")\n    public StaticBucketMap(final int numBuckets) {\n        int size = Math.max(17, numBuckets);\n\n        // Ensure that bucketSize is never a power of 2 (to ensure maximal distribution)\n        if (size % 2 == 0) {\n            size--;\n        }\n\n        buckets = new Node[size];\n        locks = new Lock[size];\n\n        for (int i = 0; i < size; i++) {\n            locks[i] = new Lock();\n        }\n    }\n\n    /**\n     *  Prevents any operations from occurring on this map while the\n     *  given {@link Runnable} executes.  This method can be used, for\n     *  instance, to execute a bulk operation atomically:\n     *\n     *  <pre>\n     *    staticBucketMapInstance.atomic(new Runnable() {\n     *        public void run() {\n     *            staticBucketMapInstance.putAll(map);\n     *        }\n     *    });\n     *  </pre>\n     *\n     *  It can also be used if you need a reliable iterator:\n     *\n     *  <pre>\n     *    staticBucketMapInstance.atomic(new Runnable() {\n     *        public void run() {\n     *            Iterator iterator = staticBucketMapInstance.iterator();\n     *            while (iterator.hasNext()) {\n     *                foo(iterator.next();\n     *            }\n     *        }\n     *    });\n     *  </pre>\n     *\n     *  <b>Implementation note:</b> This method requires a lot of time\n     *  and a ton of stack space.  Essentially a recursive algorithm is used\n     *  to enter each bucket's monitor.  If you have twenty thousand buckets\n     *  in your map, then the recursive method will be invoked twenty thousand\n     *  times.  You have been warned.\n     *\n     *  @param runnable  the code to execute atomically\n     */\n    public void atomic(final Runnable runnable) {\n        atomic(Objects.requireNonNull(runnable, \"runnable\"), 0);\n    }\n\n    private void atomic(final Runnable r, final int bucket) {\n        if (bucket >= buckets.length) {\n            r.run();\n            return;\n        }\n        synchronized (locks[bucket]) {\n            atomic(r, bucket + 1);\n        }\n    }\n\n    /**\n     * Clears the map of all entries.\n     */\n    @Override\n    public void clear() {\n        for (int i = 0; i < buckets.length; i++) {\n            final Lock lock = locks[i];\n            synchronized (lock) {\n                buckets[i] = null;\n                lock.size = 0;\n            }\n        }\n    }\n\n    /**\n     * Checks if the map contains the specified key.\n     *\n     * @param key  the key to check\n     * @return true if found\n     */\n    @Override\n    public boolean containsKey(final Object key) {\n        final int hash = getHash(key);\n\n        synchronized (locks[hash]) {\n            Node<K, V> n = buckets[hash];\n\n            while (n != null) {\n                if (Objects.equals(n.key, key)) {\n                    return true;\n                }\n\n                n = n.next;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Checks if the map contains the specified value.\n     *\n     * @param value  the value to check\n     * @return true if found\n     */\n    @Override\n    public boolean containsValue(final Object value) {\n        for (int i = 0; i < buckets.length; i++) {\n            synchronized (locks[i]) {\n                Node<K, V> n = buckets[i];\n\n                while (n != null) {\n                    if (Objects.equals(n.value, value)) {\n                        return true;\n                    }\n\n                    n = n.next;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Gets the entry set.\n     *\n     * @return the entry set\n     */\n    @Override\n    public Set<Map.Entry<K, V>> entrySet() {\n        return new EntrySet();\n    }\n\n    /**\n     * Compares this map to another, as per the Map specification.\n     *\n     * @param obj  the object to compare to\n     * @return true if equal\n     */\n    @Override\n    public boolean equals(final Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof Map<?, ?>)) {\n            return false;\n        }\n        final Map<?, ?> other = (Map<?, ?>) obj;\n        return entrySet().equals(other.entrySet());\n    }\n\n    /**\n     * Gets the value associated with the key.\n     *\n     * @param key  the key to retrieve\n     * @return the associated value\n     */\n    @Override\n    public V get(final Object key) {\n        final int hash = getHash(key);\n\n        synchronized (locks[hash]) {\n            Node<K, V> n = buckets[hash];\n\n            while (n != null) {\n                if (Objects.equals(n.key, key)) {\n                    return n.value;\n                }\n\n                n = n.next;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Determine the exact hash entry for the key.  The hash algorithm\n     * is rather simplistic, but it does the job:\n     *\n     * <pre>\n     *   He = |Hk mod n|\n     * </pre>\n     *\n     * <p>\n     *   He is the entry's hashCode, Hk is the key's hashCode, and n is\n     *   the number of buckets.\n     * </p>\n     */\n    private int getHash(final Object key) {\n        if (key == null) {\n            return 0;\n        }\n        int hash = key.hashCode();\n        hash += ~(hash << 15);\n        hash ^= hash >>> 10;\n        hash += hash << 3;\n        hash ^= hash >>> 6;\n        hash += ~(hash << 11);\n        hash ^= hash >>> 16;\n        hash %= buckets.length;\n        return hash < 0 ? hash * -1 : hash;\n    }\n\n    /**\n     * Gets the hash code, as per the Map specification.\n     *\n     * @return the hash code\n     */\n    @Override\n    public int hashCode() {\n        int hashCode = 0;\n\n        for (int i = 0; i < buckets.length; i++) {\n            synchronized (locks[i]) {\n                Node<K, V> n = buckets[i];\n\n                while (n != null) {\n                    hashCode += n.hashCode();\n                    n = n.next;\n                }\n            }\n        }\n        return hashCode;\n    }\n\n    /**\n     * Checks if the size is currently zero.\n     *\n     * @return true if empty\n     */\n    @Override\n    public boolean isEmpty() {\n        return size() == 0;\n    }\n\n    /**\n     * Gets the key set.\n     *\n     * @return the key set\n     */\n    @Override\n    public Set<K> keySet() {\n        return new KeySet();\n    }\n\n    /**\n     * Puts a new key value mapping into the map.\n     *\n     * @param key  the key to use\n     * @param value  the value to use\n     * @return the previous mapping for the key\n     */\n    @Override\n    public V put(final K key, final V value) {\n        final int hash = getHash(key);\n\n        synchronized (locks[hash]) {\n            Node<K, V> n = buckets[hash];\n\n            if (n == null) {\n                n = new Node<>();\n                n.key = key;\n                n.value = value;\n                buckets[hash] = n;\n                locks[hash].size++;\n                return null;\n            }\n\n            // Set n to the last node in the linked list.  Check each key along the way\n            //  If the key is found, then change the value of that node and return\n            //  the old value.\n            for (Node<K, V> next = n; next != null; next = next.next) {\n                n = next;\n\n                if (Objects.equals(n.key, key)) {\n                    final V returnVal = n.value;\n                    n.value = value;\n                    return returnVal;\n                }\n            }\n\n            // The key was not found in the current list of nodes, add it to the end\n            //  in a new node.\n            final Node<K, V> newNode = new Node<>();\n            newNode.key = key;\n            newNode.value = value;\n            n.next = newNode;\n            locks[hash].size++;\n        }\n        return null;\n    }\n\n    /**\n     * Puts all the entries from the specified map into this map.\n     * This operation is <b>not atomic</b> and may have undesired effects.\n     *\n     * @param map  the map of entries to add\n     */\n    @Override\n    public void putAll(final Map<? extends K, ? extends V> map) {\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            put(entry.getKey(), entry.getValue());\n        }\n    }\n\n    /**\n     * Removes the specified key from the map.\n     *\n     * @param key  the key to remove\n     * @return the previous value at this key\n     */\n    @Override\n    public V remove(final Object key) {\n        final int hash = getHash(key);\n\n        synchronized (locks[hash]) {\n            Node<K, V> n = buckets[hash];\n            Node<K, V> prev = null;\n\n            while (n != null) {\n                if (Objects.equals(n.key, key)) {\n                    // Remove this node from the linked list of nodes.\n                    if (null == prev) {\n                        // This node was the head, set the next node to be the new head.\n                        buckets[hash] = n.next;\n                    } else {\n                        // Set the next node of the previous node to be the node after this one.\n                        prev.next = n.next;\n                    }\n                    locks[hash].size--;\n                    return n.value;\n                }\n\n                prev = n;\n                n = n.next;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Gets the current size of the map.\n     * The value is computed fresh each time the method is called.\n     *\n     * @return the current size\n     */\n    @Override\n    public int size() {\n        int cnt = 0;\n\n        for (int i = 0; i < buckets.length; i++) {\n            synchronized (locks[i]) {\n                cnt += locks[i].size;\n            }\n        }\n        return cnt;\n    }\n\n    /**\n     * Gets the values.\n     *\n     * @return the values\n     */\n    @Override\n    public Collection<V> values() {\n        return new Values();\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final int DEFAULT_BUCKETS = 255;", "docstring": " The default number of buckets to use", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "int", "name": "DEFAULT_BUCKETS = 255", "syntax_pass": true}, {"attribute_expression": "private final Node<K, V>[] buckets;", "docstring": " The array of buckets, where the actual data is held", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Node<K, V>[]", "name": "buckets", "syntax_pass": true}, {"attribute_expression": "private final Lock[] locks;", "docstring": " The matching array of locks", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Lock[]", "name": "locks", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/map/PassiveExpiringMap.java.PassiveExpiringMap", "name": "PassiveExpiringMap", "file_path": "src/main/java/org/apache/commons/collections4/map/PassiveExpiringMap.java", "superclasses": "", "methods": ["[long]validateAndConvertToMillis(long,TimeUnit)", "[]PassiveExpiringMap()", "[]PassiveExpiringMap(ExpirationPolicy<K, V>)", "[]PassiveExpiringMap(ExpirationPolicy<K, V>,Map<K, V>)", "[]PassiveExpiringMap(long)", "[]PassiveExpiringMap(long,Map<K, V>)", "[]PassiveExpiringMap(long,TimeUnit)", "[]PassiveExpiringMap(long,TimeUnit,Map<K, V>)", "[]PassiveExpiringMap(Map<K, V>)", "[void]clear()", "[boolean]containsKey(Object)", "[boolean]containsValue(Object)", "[Set<Entry<K, V>>]entrySet()", "[V]get(Object)", "[boolean]isEmpty()", "[boolean]isExpired(long,Long)", "[Set<K>]keySet()", "[long]now()", "[V]put(K,V)", "[void]putAll(Map<? extends K, ? extends V>)", "[void]readObject(ObjectInputStream)", "[V]remove(Object)", "[void]removeAllExpired(long)", "[void]removeIfExpired(Object,long)", "[int]size()", "[Collection<V>]values()", "[void]writeObject(ObjectOutputStream)"], "method_uris": ["src/main/java/org/apache/commons/collections4/map/PassiveExpiringMap.java.PassiveExpiringMap.[long]validateAndConvertToMillis(long,TimeUnit)", "src/main/java/org/apache/commons/collections4/map/PassiveExpiringMap.java.PassiveExpiringMap.[]PassiveExpiringMap()", "src/main/java/org/apache/commons/collections4/map/PassiveExpiringMap.java.PassiveExpiringMap.[]PassiveExpiringMap(ExpirationPolicy<K, V>)", "src/main/java/org/apache/commons/collections4/map/PassiveExpiringMap.java.PassiveExpiringMap.[]PassiveExpiringMap(ExpirationPolicy<K, V>,Map<K, V>)", "src/main/java/org/apache/commons/collections4/map/PassiveExpiringMap.java.PassiveExpiringMap.[]PassiveExpiringMap(long)", "src/main/java/org/apache/commons/collections4/map/PassiveExpiringMap.java.PassiveExpiringMap.[]PassiveExpiringMap(long,Map<K, V>)", "src/main/java/org/apache/commons/collections4/map/PassiveExpiringMap.java.PassiveExpiringMap.[]PassiveExpiringMap(long,TimeUnit)", "src/main/java/org/apache/commons/collections4/map/PassiveExpiringMap.java.PassiveExpiringMap.[]PassiveExpiringMap(long,TimeUnit,Map<K, V>)", "src/main/java/org/apache/commons/collections4/map/PassiveExpiringMap.java.PassiveExpiringMap.[]PassiveExpiringMap(Map<K, V>)", "src/main/java/org/apache/commons/collections4/map/PassiveExpiringMap.java.PassiveExpiringMap.[void]clear()", "src/main/java/org/apache/commons/collections4/map/PassiveExpiringMap.java.PassiveExpiringMap.[boolean]containsKey(Object)", "src/main/java/org/apache/commons/collections4/map/PassiveExpiringMap.java.PassiveExpiringMap.[boolean]containsValue(Object)", "src/main/java/org/apache/commons/collections4/map/PassiveExpiringMap.java.PassiveExpiringMap.[Set<Entry<K, V>>]entrySet()", "src/main/java/org/apache/commons/collections4/map/PassiveExpiringMap.java.PassiveExpiringMap.[V]get(Object)", "src/main/java/org/apache/commons/collections4/map/PassiveExpiringMap.java.PassiveExpiringMap.[boolean]isEmpty()", "src/main/java/org/apache/commons/collections4/map/PassiveExpiringMap.java.PassiveExpiringMap.[boolean]isExpired(long,Long)", "src/main/java/org/apache/commons/collections4/map/PassiveExpiringMap.java.PassiveExpiringMap.[Set<K>]keySet()", "src/main/java/org/apache/commons/collections4/map/PassiveExpiringMap.java.PassiveExpiringMap.[long]now()", "src/main/java/org/apache/commons/collections4/map/PassiveExpiringMap.java.PassiveExpiringMap.[V]put(K,V)", "src/main/java/org/apache/commons/collections4/map/PassiveExpiringMap.java.PassiveExpiringMap.[void]putAll(Map<? extends K, ? extends V>)", "src/main/java/org/apache/commons/collections4/map/PassiveExpiringMap.java.PassiveExpiringMap.[void]readObject(ObjectInputStream)", "src/main/java/org/apache/commons/collections4/map/PassiveExpiringMap.java.PassiveExpiringMap.[V]remove(Object)", "src/main/java/org/apache/commons/collections4/map/PassiveExpiringMap.java.PassiveExpiringMap.[void]removeAllExpired(long)", "src/main/java/org/apache/commons/collections4/map/PassiveExpiringMap.java.PassiveExpiringMap.[void]removeIfExpired(Object,long)", "src/main/java/org/apache/commons/collections4/map/PassiveExpiringMap.java.PassiveExpiringMap.[int]size()", "src/main/java/org/apache/commons/collections4/map/PassiveExpiringMap.java.PassiveExpiringMap.[Collection<V>]values()", "src/main/java/org/apache/commons/collections4/map/PassiveExpiringMap.java.PassiveExpiringMap.[void]writeObject(ObjectOutputStream)"], "overrides": null, "attributes": [{"original_string": "    public static class ConstantTimeToLiveExpirationPolicy<K, V>\n        implements ExpirationPolicy<K, V> {\n\n        /** Serialization version */\n        private static final long serialVersionUID = 1L;\n\n        /** The constant time-to-live value measured in milliseconds. */\n        private final long timeToLiveMillis;\n\n        /**\n         * Default constructor. Constructs a policy using a negative\n         * time-to-live value that results in entries never expiring.\n         */\n        public ConstantTimeToLiveExpirationPolicy() {\n            this(-1L);\n        }\n\n        /**\n         * Constructs a policy with the given time-to-live constant measured in\n         * milliseconds. A negative time-to-live value indicates entries never\n         * expire. A zero time-to-live value indicates entries expire (nearly)\n         * immediately.\n         *\n         * @param timeToLiveMillis the constant amount of time (in milliseconds)\n         *        an entry is available before it expires. A negative value\n         *        results in entries that NEVER expire. A zero value results in\n         *        entries that ALWAYS expire.\n         */\n        public ConstantTimeToLiveExpirationPolicy(final long timeToLiveMillis) {\n            this.timeToLiveMillis = timeToLiveMillis;\n        }\n\n        /**\n         * Constructs a policy with the given time-to-live constant measured in\n         * the given time unit of measure.\n         *\n         * @param timeToLive the constant amount of time an entry is available\n         *        before it expires. A negative value results in entries that\n         *        NEVER expire. A zero value results in entries that ALWAYS\n         *        expire.\n         * @param timeUnit the unit of time for the {@code timeToLive}\n         *        parameter, must not be null.\n         * @throws NullPointerException if the time unit is null.\n         */\n        public ConstantTimeToLiveExpirationPolicy(final long timeToLive,\n                                                  final TimeUnit timeUnit) {\n            this(validateAndConvertToMillis(timeToLive, timeUnit));\n        }\n\n        /**\n         * Determine the expiration time for the given key-value entry.\n         *\n         * @param key the key for the entry (ignored).\n         * @param value the value for the entry (ignored).\n         * @return if {@link #timeToLiveMillis} &ge; 0, an expiration time of\n         *         {@link #timeToLiveMillis} +\n         *         {@link System#currentTimeMillis()} is returned. Otherwise, -1\n         *         is returned indicating the entry never expires.\n         */\n        @Override\n        public long expirationTime(final K key, final V value) {\n            if (timeToLiveMillis >= 0L) {\n                // avoid numerical overflow\n                final long nowMillis = System.currentTimeMillis();\n                if (nowMillis > Long.MAX_VALUE - timeToLiveMillis) {\n                    // expiration would be greater than Long.MAX_VALUE\n                    // never expire\n                    return -1;\n                }\n\n                // timeToLiveMillis in the future\n                return nowMillis + timeToLiveMillis;\n            }\n\n            // never expire\n            return -1L;\n        }\n    }", "definition": "    public static class ConstantTimeToLiveExpirationPolicy<K, V>\n        implements ExpirationPolicy<K, V>", "class_docstring": "\nA {@link org.apache.commons.collections4.map.PassiveExpiringMap.ExpirationPolicy ExpirationPolicy}\nthat returns an expiration time that is a\nconstant about of time in the future from the current time.\n\n@param <K> the type of the keys in the map\n@param <V> the type of the values in the map\n@since 4.0\n", "name": "ConstantTimeToLiveExpirationPolicy", "super_interfaces": ["ExpirationPolicy<K, V>"], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = 1L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 1L", "syntax_pass": true}, {"attribute_expression": "private final long timeToLiveMillis;", "docstring": " The constant time-to-live value measured in milliseconds.", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "long", "name": "timeToLiveMillis", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public ConstantTimeToLiveExpirationPolicy() {\n            this(-1L);\n        }", "docstring": "\nDefault constructor. Constructs a policy using a negative\ntime-to-live value that results in entries never expiring.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ConstantTimeToLiveExpirationPolicy", "params": [], "body": "                                                    {\n            this(-1L);\n        }", "signature": "public ConstantTimeToLiveExpirationPolicy()"}, {"syntax_pass": true, "original_string": "        public ConstantTimeToLiveExpirationPolicy(final long timeToLiveMillis) {\n            this.timeToLiveMillis = timeToLiveMillis;\n        }", "docstring": "\nConstructs a policy with the given time-to-live constant measured in\nmilliseconds. A negative time-to-live value indicates entries never\nexpire. A zero time-to-live value indicates entries expire (nearly)\nimmediately.\n\n@param timeToLiveMillis the constant amount of time (in milliseconds)\n       an entry is available before it expires. A negative value\n       results in entries that NEVER expire. A zero value results in\n       entries that ALWAYS expire.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ConstantTimeToLiveExpirationPolicy", "params": [{"name": "timeToLiveMillis", "type": "long"}], "body": "                                                                               {\n            this.timeToLiveMillis = timeToLiveMillis;\n        }", "signature": "public ConstantTimeToLiveExpirationPolicy(final long timeToLiveMillis)"}, {"syntax_pass": true, "original_string": "        public ConstantTimeToLiveExpirationPolicy(final long timeToLive,\n                                                  final TimeUnit timeUnit) {\n            this(validateAndConvertToMillis(timeToLive, timeUnit));\n        }", "docstring": "\nConstructs a policy with the given time-to-live constant measured in\nthe given time unit of measure.\n\n@param timeToLive the constant amount of time an entry is available\n       before it expires. A negative value results in entries that\n       NEVER expire. A zero value results in entries that ALWAYS\n       expire.\n@param timeUnit the unit of time for the {@code timeToLive}\n       parameter, must not be null.\n@throws NullPointerException if the time unit is null.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ConstantTimeToLiveExpirationPolicy", "params": [{"name": "timeToLive", "type": "long"}, {"name": "timeUnit", "type": "TimeUnit"}], "body": "                                                                           {\n            this(validateAndConvertToMillis(timeToLive, timeUnit));\n        }", "signature": "public ConstantTimeToLiveExpirationPolicy(final long timeToLive,\n                                                  final TimeUnit timeUnit)"}, {"syntax_pass": true, "original_string": "        @Override\n        public long expirationTime(final K key, final V value) {\n            if (timeToLiveMillis >= 0L) {\n                // avoid numerical overflow\n                final long nowMillis = System.currentTimeMillis();\n                if (nowMillis > Long.MAX_VALUE - timeToLiveMillis) {\n                    // expiration would be greater than Long.MAX_VALUE\n                    // never expire\n                    return -1;\n                }\n\n                // timeToLiveMillis in the future\n                return nowMillis + timeToLiveMillis;\n            }\n\n            // never expire\n            return -1L;\n        }", "docstring": "\nDetermine the expiration time for the given key-value entry.\n\n@param key the key for the entry (ignored).\n@param value the value for the entry (ignored).\n@return if {@link #timeToLiveMillis} &ge; 0, an expiration time of\n        {@link #timeToLiveMillis} +\n        {@link System#currentTimeMillis()} is returned. Otherwise, -1\n        is returned indicating the entry never expires.\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "long", "classes": []}, "name": "expirationTime", "params": [{"name": "key", "type": "K"}, {"name": "value", "type": "V"}], "body": "                                                               {\n            if (timeToLiveMillis >= 0L) {\n                // avoid numerical overflow\n                final long nowMillis = System.currentTimeMillis();\n                if (nowMillis > Long.MAX_VALUE - timeToLiveMillis) {\n                    // expiration would be greater than Long.MAX_VALUE\n                    // never expire\n                    return -1;\n                }\n\n                // timeToLiveMillis in the future\n                return nowMillis + timeToLiveMillis;\n            }\n\n            // never expire\n            return -1L;\n        }", "signature": "@Override\n        public long expirationTime(final K key, final V value)"}]}], "class_docstring": "\nDecorates a {@code Map} to evict expired entries once their expiration\ntime has been reached.\n<p>\nWhen putting a key-value pair in the map this decorator uses a\n{@link ExpirationPolicy} to determine how long the entry should remain alive\nas defined by an expiration time value.\n</p>\n<p>\nWhen accessing the mapped value for a key, its expiration time is checked,\nand if it is a negative value or if it is greater than the current time, the\nmapped value is returned. Otherwise, the key is removed from the decorated\nmap, and {@code null} is returned.\n</p>\n<p>\nWhen invoking methods that involve accessing the entire map contents (i.e\n{@link #containsValue(Object)}, {@link #entrySet()}, etc.) this decorator\nremoves all expired entries prior to actually completing the invocation.\n</p>\n<p>\n<strong>Note that {@link PassiveExpiringMap} is not synchronized and is not\nthread-safe.</strong> If you wish to use this map from multiple threads\nconcurrently, you must use appropriate synchronization. The simplest approach\nis to wrap this map using {@link java.util.Collections#synchronizedMap(Map)}.\nThis class may throw exceptions when accessed by concurrent threads without\nsynchronization.\n</p>\n\n@param <K> the type of the keys in this map\n@param <V> the type of the values in this map\n@since 4.0\n", "original_string": "public class PassiveExpiringMap<K, V>\n    extends AbstractMapDecorator<K, V>\n    implements Serializable {\n\n    /**\n     * A {@link org.apache.commons.collections4.map.PassiveExpiringMap.ExpirationPolicy ExpirationPolicy}\n     * that returns an expiration time that is a\n     * constant about of time in the future from the current time.\n     *\n     * @param <K> the type of the keys in the map\n     * @param <V> the type of the values in the map\n     * @since 4.0\n     */\n    public static class ConstantTimeToLiveExpirationPolicy<K, V>\n        implements ExpirationPolicy<K, V> {\n\n        /** Serialization version */\n        private static final long serialVersionUID = 1L;\n\n        /** The constant time-to-live value measured in milliseconds. */\n        private final long timeToLiveMillis;\n\n        /**\n         * Default constructor. Constructs a policy using a negative\n         * time-to-live value that results in entries never expiring.\n         */\n        public ConstantTimeToLiveExpirationPolicy() {\n            this(-1L);\n        }\n\n        /**\n         * Constructs a policy with the given time-to-live constant measured in\n         * milliseconds. A negative time-to-live value indicates entries never\n         * expire. A zero time-to-live value indicates entries expire (nearly)\n         * immediately.\n         *\n         * @param timeToLiveMillis the constant amount of time (in milliseconds)\n         *        an entry is available before it expires. A negative value\n         *        results in entries that NEVER expire. A zero value results in\n         *        entries that ALWAYS expire.\n         */\n        public ConstantTimeToLiveExpirationPolicy(final long timeToLiveMillis) {\n            this.timeToLiveMillis = timeToLiveMillis;\n        }\n\n        /**\n         * Constructs a policy with the given time-to-live constant measured in\n         * the given time unit of measure.\n         *\n         * @param timeToLive the constant amount of time an entry is available\n         *        before it expires. A negative value results in entries that\n         *        NEVER expire. A zero value results in entries that ALWAYS\n         *        expire.\n         * @param timeUnit the unit of time for the {@code timeToLive}\n         *        parameter, must not be null.\n         * @throws NullPointerException if the time unit is null.\n         */\n        public ConstantTimeToLiveExpirationPolicy(final long timeToLive,\n                                                  final TimeUnit timeUnit) {\n            this(validateAndConvertToMillis(timeToLive, timeUnit));\n        }\n\n        /**\n         * Determine the expiration time for the given key-value entry.\n         *\n         * @param key the key for the entry (ignored).\n         * @param value the value for the entry (ignored).\n         * @return if {@link #timeToLiveMillis} &ge; 0, an expiration time of\n         *         {@link #timeToLiveMillis} +\n         *         {@link System#currentTimeMillis()} is returned. Otherwise, -1\n         *         is returned indicating the entry never expires.\n         */\n        @Override\n        public long expirationTime(final K key, final V value) {\n            if (timeToLiveMillis >= 0L) {\n                // avoid numerical overflow\n                final long nowMillis = System.currentTimeMillis();\n                if (nowMillis > Long.MAX_VALUE - timeToLiveMillis) {\n                    // expiration would be greater than Long.MAX_VALUE\n                    // never expire\n                    return -1;\n                }\n\n                // timeToLiveMillis in the future\n                return nowMillis + timeToLiveMillis;\n            }\n\n            // never expire\n            return -1L;\n        }\n    }\n\n    /**\n     * A policy to determine the expiration time for key-value entries.\n     *\n     * @param <K> the key object type.\n     * @param <V> the value object type\n     * @since 4.0\n     */\n    @FunctionalInterface\n    public interface ExpirationPolicy<K, V>\n        extends Serializable {\n\n        /**\n         * Determine the expiration time for the given key-value entry.\n         *\n         * @param key the key for the entry.\n         * @param value the value for the entry.\n         * @return the expiration time value measured in milliseconds. A\n         *         negative return value indicates the entry never expires.\n         */\n        long expirationTime(K key, V value);\n    }\n\n    /** Serialization version */\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * First validate the input parameters. If the parameters are valid, convert\n     * the given time measured in the given units to the same time measured in\n     * milliseconds.\n     *\n     * @param timeToLive the constant amount of time an entry is available\n     *        before it expires. A negative value results in entries that NEVER\n     *        expire. A zero value results in entries that ALWAYS expire.\n     * @param timeUnit the unit of time for the {@code timeToLive}\n     *        parameter, must not be null.\n     * @throws NullPointerException if the time unit is null.\n     */\n    private static long validateAndConvertToMillis(final long timeToLive,\n                                                   final TimeUnit timeUnit) {\n        Objects.requireNonNull(timeUnit, \"timeUnit\");\n        return TimeUnit.MILLISECONDS.convert(timeToLive, timeUnit);\n    }\n\n    /** Map used to manage expiration times for the actual map entries. */\n    private final Map<Object, Long> expirationMap = new HashMap<>();\n\n    /** The policy used to determine time-to-live values for map entries. */\n    private final ExpirationPolicy<K, V> expiringPolicy;\n\n    /**\n     * Default constructor. Constructs a map decorator that results in entries\n     * NEVER expiring.\n     */\n    public PassiveExpiringMap() {\n        this(-1L);\n    }\n\n    /**\n     * Constructs a map decorator using the given expiration policy to determine\n     * expiration times.\n     *\n     * @param expiringPolicy the policy used to determine expiration times of\n     *        entries as they are added.\n     * @throws NullPointerException if expiringPolicy is null\n     */\n    public PassiveExpiringMap(final ExpirationPolicy<K, V> expiringPolicy) {\n        this(expiringPolicy, new HashMap<>());\n    }\n\n    /**\n     * Constructs a map decorator that decorates the given map and uses the given\n     * expiration policy to determine expiration times. If there are any\n     * elements already in the map being decorated, they will NEVER expire\n     * unless they are replaced.\n     *\n     * @param expiringPolicy the policy used to determine expiration times of\n     *        entries as they are added.\n     * @param map the map to decorate, must not be null.\n     * @throws NullPointerException if the map or expiringPolicy is null.\n     */\n    public PassiveExpiringMap(final ExpirationPolicy<K, V> expiringPolicy,\n                              final Map<K, V> map) {\n        super(map);\n        this.expiringPolicy = Objects.requireNonNull(expiringPolicy, \"expiringPolicy\");\n    }\n\n    /**\n     * Constructs a map decorator that decorates the given map using the given\n     * time-to-live value measured in milliseconds to create and use a\n     * {@link ConstantTimeToLiveExpirationPolicy} expiration policy.\n     *\n     * @param timeToLiveMillis the constant amount of time (in milliseconds) an\n     *        entry is available before it expires. A negative value results in\n     *        entries that NEVER expire. A zero value results in entries that\n     *        ALWAYS expire.\n     */\n    public PassiveExpiringMap(final long timeToLiveMillis) {\n        this(new ConstantTimeToLiveExpirationPolicy<>(timeToLiveMillis),\n                new HashMap<>());\n    }\n\n    /**\n     * Constructs a map decorator using the given time-to-live value measured in\n     * milliseconds to create and use a\n     * {@link ConstantTimeToLiveExpirationPolicy} expiration policy. If there\n     * are any elements already in the map being decorated, they will NEVER\n     * expire unless they are replaced.\n     *\n     * @param timeToLiveMillis the constant amount of time (in milliseconds) an\n     *        entry is available before it expires. A negative value results in\n     *        entries that NEVER expire. A zero value results in entries that\n     *        ALWAYS expire.\n     * @param map the map to decorate, must not be null.\n     * @throws NullPointerException if the map is null.\n     */\n    public PassiveExpiringMap(final long timeToLiveMillis, final Map<K, V> map) {\n        this(new ConstantTimeToLiveExpirationPolicy<>(timeToLiveMillis),\n             map);\n    }\n\n    /**\n     * Constructs a map decorator using the given time-to-live value measured in\n     * the given time units of measure to create and use a\n     * {@link ConstantTimeToLiveExpirationPolicy} expiration policy.\n     *\n     * @param timeToLive the constant amount of time an entry is available\n     *        before it expires. A negative value results in entries that NEVER\n     *        expire. A zero value results in entries that ALWAYS expire.\n     * @param timeUnit the unit of time for the {@code timeToLive}\n     *        parameter, must not be null.\n     * @throws NullPointerException if the time unit is null.\n     */\n    public PassiveExpiringMap(final long timeToLive, final TimeUnit timeUnit) {\n        this(validateAndConvertToMillis(timeToLive, timeUnit));\n    }\n\n    /**\n     * Constructs a map decorator that decorates the given map using the given\n     * time-to-live value measured in the given time units of measure to create\n     * {@link ConstantTimeToLiveExpirationPolicy} expiration policy. This policy\n     * is used to determine expiration times. If there are any elements already\n     * in the map being decorated, they will NEVER expire unless they are\n     * replaced.\n     *\n     * @param timeToLive the constant amount of time an entry is available\n     *        before it expires. A negative value results in entries that NEVER\n     *        expire. A zero value results in entries that ALWAYS expire.\n     * @param timeUnit the unit of time for the {@code timeToLive}\n     *        parameter, must not be null.\n     * @param map the map to decorate, must not be null.\n     * @throws NullPointerException if the map or time unit is null.\n     */\n    public PassiveExpiringMap(final long timeToLive, final TimeUnit timeUnit, final Map<K, V> map) {\n        this(validateAndConvertToMillis(timeToLive, timeUnit), map);\n    }\n\n    /**\n     * Constructs a map decorator that decorates the given map and results in\n     * entries NEVER expiring. If there are any elements already in the map\n     * being decorated, they also will NEVER expire.\n     *\n     * @param map the map to decorate, must not be null.\n     * @throws NullPointerException if the map is null.\n     */\n    public PassiveExpiringMap(final Map<K, V> map) {\n        this(-1L, map);\n    }\n\n    /**\n     * Normal {@link Map#clear()} behavior with the addition of clearing all\n     * expiration entries as well.\n     */\n    @Override\n    public void clear() {\n        super.clear();\n        expirationMap.clear();\n    }\n\n    /**\n     * All expired entries are removed from the map prior to determining the\n     * contains result.\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean containsKey(final Object key) {\n        removeIfExpired(key, now());\n        return super.containsKey(key);\n    }\n\n    /**\n     * All expired entries are removed from the map prior to determining the\n     * contains result.\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean containsValue(final Object value) {\n        removeAllExpired(now());\n        return super.containsValue(value);\n    }\n\n    /**\n     * All expired entries are removed from the map prior to returning the entry set.\n     * {@inheritDoc}\n     */\n    @Override\n    public Set<Entry<K, V>> entrySet() {\n        removeAllExpired(now());\n        return super.entrySet();\n    }\n\n    /**\n     * All expired entries are removed from the map prior to returning the entry value.\n     * {@inheritDoc}\n     */\n    @Override\n    public V get(final Object key) {\n        removeIfExpired(key, now());\n        return super.get(key);\n    }\n\n    /**\n     * All expired entries are removed from the map prior to determining if it is empty.\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean isEmpty() {\n        removeAllExpired(now());\n        return super.isEmpty();\n    }\n\n    /**\n     * Determines if the given expiration time is less than {@code now}.\n     *\n     * @param now the time in milliseconds used to compare against the\n     *        expiration time.\n     * @param expirationTimeObject the expiration time value retrieved from\n     *        {@link #expirationMap}, can be null.\n     * @return {@code true} if {@code expirationTimeObject} is &ge; 0\n     *         and {@code expirationTimeObject} &lt; {@code now}.\n     *         {@code false} otherwise.\n     */\n    private boolean isExpired(final long now, final Long expirationTimeObject) {\n        if (expirationTimeObject != null) {\n            final long expirationTime = expirationTimeObject.longValue();\n            return expirationTime >= 0 && now >= expirationTime;\n        }\n        return false;\n    }\n\n    /**\n     * All expired entries are removed from the map prior to returning the key set.\n     * {@inheritDoc}\n     */\n    @Override\n    public Set<K> keySet() {\n        removeAllExpired(now());\n        return super.keySet();\n    }\n\n    /**\n     * The current time in milliseconds.\n     */\n    private long now() {\n        return System.currentTimeMillis();\n    }\n\n    /**\n    * Add the given key-value pair to this map as well as recording the entry's expiration time based on\n    * the current time in milliseconds and this map's {@link #expiringPolicy}.\n    * <p>\n    * {@inheritDoc}\n    */\n    @Override\n    public V put(final K key, final V value) {\n        // remove the previous record\n        removeIfExpired(key, now());\n\n        // record expiration time of new entry\n        final long expirationTime = expiringPolicy.expirationTime(key, value);\n        expirationMap.put(key, Long.valueOf(expirationTime));\n\n        return super.put(key, value);\n    }\n\n    @Override\n    public void putAll(final Map<? extends K, ? extends V> mapToCopy) {\n        for (final Map.Entry<? extends K, ? extends V> entry : mapToCopy.entrySet()) {\n            put(entry.getKey(), entry.getValue());\n        }\n    }\n\n    /**\n     * Deserializes the map in using a custom routine.\n     *\n     * @param in the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded\n     */\n    @SuppressWarnings(\"unchecked\")\n    // (1) should only fail if input stream is incorrect\n    private void readObject(final ObjectInputStream in)\n        throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        map = (Map<K, V>) in.readObject(); // (1)\n    }\n\n    /**\n     * Normal {@link Map#remove(Object)} behavior with the addition of removing\n     * any expiration entry as well.\n     * {@inheritDoc}\n     */\n    @Override\n    public V remove(final Object key) {\n        expirationMap.remove(key);\n        return super.remove(key);\n    }\n\n    /**\n     * Removes all entries in the map whose expiration time is less than\n     * {@code now}. The exceptions are entries with negative expiration\n     * times; those entries are never removed.\n     *\n     * @see #isExpired(long, Long)\n     */\n    private void removeAllExpired(final long nowMillis) {\n        final Iterator<Map.Entry<Object, Long>> iter = expirationMap.entrySet().iterator();\n        while (iter.hasNext()) {\n            final Map.Entry<Object, Long> expirationEntry = iter.next();\n            if (isExpired(nowMillis, expirationEntry.getValue())) {\n                // remove entry from collection\n                super.remove(expirationEntry.getKey());\n                // remove entry from expiration map\n                iter.remove();\n            }\n        }\n    }\n\n    /**\n     * Removes the entry with the given key if the entry's expiration time is\n     * less than {@code now}. If the entry has a negative expiration time,\n     * the entry is never removed.\n     */\n    private void removeIfExpired(final Object key, final long nowMillis) {\n        final Long expirationTimeObject = expirationMap.get(key);\n        if (isExpired(nowMillis, expirationTimeObject)) {\n            remove(key);\n        }\n    }\n\n    /**\n     * All expired entries are removed from the map prior to returning the size.\n     * {@inheritDoc}\n     */\n    @Override\n    public int size() {\n        removeAllExpired(now());\n        return super.size();\n    }\n\n    /**\n     * All expired entries are removed from the map prior to returning the value collection.\n     * {@inheritDoc}\n     */\n    @Override\n    public Collection<V> values() {\n        removeAllExpired(now());\n        return super.values();\n    }\n\n    /**\n     * Serializes this object to an ObjectOutputStream.\n     *\n     * @param out the target ObjectOutputStream.\n     * @throws IOException thrown when an I/O errors occur writing to the target stream.\n     */\n    private void writeObject(final ObjectOutputStream out)\n        throws IOException {\n        out.defaultWriteObject();\n        out.writeObject(map);\n    }\n}", "super_interfaces": ["Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 1L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 1L", "syntax_pass": true}, {"attribute_expression": "private final Map<Object, Long> expirationMap = new HashMap<>();", "docstring": " Map used to manage expiration times for the actual map entries.", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Map<Object, Long>", "name": "expirationMap = new HashMap<>()", "syntax_pass": true}, {"attribute_expression": "private final ExpirationPolicy<K, V> expiringPolicy;", "docstring": " The policy used to determine time-to-live values for map entries.", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ExpirationPolicy<K, V>", "name": "expiringPolicy", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/map/ListOrderedMap.java.ListOrderedMap", "name": "ListOrderedMap", "file_path": "src/main/java/org/apache/commons/collections4/map/ListOrderedMap.java", "superclasses": "", "methods": ["[ListOrderedMap<K, V>]listOrderedMap(Map<K, V>)", "[]ListOrderedMap()", "[]ListOrderedMap(Map<K, V>)", "[List<K>]asList()", "[void]clear()", "[Set<Map.Entry<K, V>>]entrySet()", "[K]firstKey()", "[K]get(int)", "[V]getValue(int)", "[int]indexOf(Object)", "[List<K>]keyList()", "[Set<K>]keySet()", "[K]lastKey()", "[OrderedMapIterator<K, V>]mapIterator()", "[K]nextKey(Object)", "[K]previousKey(Object)", "[V]put(int,K,V)", "[V]put(K,V)", "[void]putAll(int,Map<? extends K, ? extends V>)", "[void]putAll(Map<? extends K, ? extends V>)", "[void]readObject(ObjectInputStream)", "[V]remove(int)", "[V]remove(Object)", "[V]setValue(int,V)", "[String]toString()", "[List<V>]valueList()", "[Collection<V>]values()", "[void]writeObject(ObjectOutputStream)"], "method_uris": ["src/main/java/org/apache/commons/collections4/map/ListOrderedMap.java.ListOrderedMap.[ListOrderedMap<K, V>]listOrderedMap(Map<K, V>)", "src/main/java/org/apache/commons/collections4/map/ListOrderedMap.java.ListOrderedMap.[]ListOrderedMap()", "src/main/java/org/apache/commons/collections4/map/ListOrderedMap.java.ListOrderedMap.[]ListOrderedMap(Map<K, V>)", "src/main/java/org/apache/commons/collections4/map/ListOrderedMap.java.ListOrderedMap.[List<K>]asList()", "src/main/java/org/apache/commons/collections4/map/ListOrderedMap.java.ListOrderedMap.[void]clear()", "src/main/java/org/apache/commons/collections4/map/ListOrderedMap.java.ListOrderedMap.[Set<Map.Entry<K, V>>]entrySet()", "src/main/java/org/apache/commons/collections4/map/ListOrderedMap.java.ListOrderedMap.[K]firstKey()", "src/main/java/org/apache/commons/collections4/map/ListOrderedMap.java.ListOrderedMap.[K]get(int)", "src/main/java/org/apache/commons/collections4/map/ListOrderedMap.java.ListOrderedMap.[V]getValue(int)", "src/main/java/org/apache/commons/collections4/map/ListOrderedMap.java.ListOrderedMap.[int]indexOf(Object)", "src/main/java/org/apache/commons/collections4/map/ListOrderedMap.java.ListOrderedMap.[List<K>]keyList()", "src/main/java/org/apache/commons/collections4/map/ListOrderedMap.java.ListOrderedMap.[Set<K>]keySet()", "src/main/java/org/apache/commons/collections4/map/ListOrderedMap.java.ListOrderedMap.[K]lastKey()", "src/main/java/org/apache/commons/collections4/map/ListOrderedMap.java.ListOrderedMap.[OrderedMapIterator<K, V>]mapIterator()", "src/main/java/org/apache/commons/collections4/map/ListOrderedMap.java.ListOrderedMap.[K]nextKey(Object)", "src/main/java/org/apache/commons/collections4/map/ListOrderedMap.java.ListOrderedMap.[K]previousKey(Object)", "src/main/java/org/apache/commons/collections4/map/ListOrderedMap.java.ListOrderedMap.[V]put(int,K,V)", "src/main/java/org/apache/commons/collections4/map/ListOrderedMap.java.ListOrderedMap.[V]put(K,V)", "src/main/java/org/apache/commons/collections4/map/ListOrderedMap.java.ListOrderedMap.[void]putAll(int,Map<? extends K, ? extends V>)", "src/main/java/org/apache/commons/collections4/map/ListOrderedMap.java.ListOrderedMap.[void]putAll(Map<? extends K, ? extends V>)", "src/main/java/org/apache/commons/collections4/map/ListOrderedMap.java.ListOrderedMap.[void]readObject(ObjectInputStream)", "src/main/java/org/apache/commons/collections4/map/ListOrderedMap.java.ListOrderedMap.[V]remove(int)", "src/main/java/org/apache/commons/collections4/map/ListOrderedMap.java.ListOrderedMap.[V]remove(Object)", "src/main/java/org/apache/commons/collections4/map/ListOrderedMap.java.ListOrderedMap.[V]setValue(int,V)", "src/main/java/org/apache/commons/collections4/map/ListOrderedMap.java.ListOrderedMap.[String]toString()", "src/main/java/org/apache/commons/collections4/map/ListOrderedMap.java.ListOrderedMap.[List<V>]valueList()", "src/main/java/org/apache/commons/collections4/map/ListOrderedMap.java.ListOrderedMap.[Collection<V>]values()", "src/main/java/org/apache/commons/collections4/map/ListOrderedMap.java.ListOrderedMap.[void]writeObject(ObjectOutputStream)"], "overrides": null, "attributes": [{"original_string": "    static class EntrySetView<K, V> extends AbstractSet<Map.Entry<K, V>> {\n        private final ListOrderedMap<K, V> parent;\n        private final List<K> insertOrder;\n        private Set<Map.Entry<K, V>> entrySet;\n\n        EntrySetView(final ListOrderedMap<K, V> parent, final List<K> insertOrder) {\n            this.parent = parent;\n            this.insertOrder = insertOrder;\n        }\n\n        @Override\n        public void clear() {\n            parent.clear();\n        }\n\n        @Override\n        public boolean contains(final Object obj) {\n            return getEntrySet().contains(obj);\n        }\n        @Override\n        public boolean containsAll(final Collection<?> coll) {\n            return getEntrySet().containsAll(coll);\n        }\n\n        @Override\n        public boolean equals(final Object obj) {\n            if (obj == this) {\n                return true;\n            }\n            return getEntrySet().equals(obj);\n        }\n\n        private Set<Map.Entry<K, V>> getEntrySet() {\n            if (entrySet == null) {\n                entrySet = parent.decorated().entrySet();\n            }\n            return entrySet;\n        }\n\n        @Override\n        public int hashCode() {\n            return getEntrySet().hashCode();\n        }\n\n        @Override\n        public boolean isEmpty() {\n            return parent.isEmpty();\n        }\n\n        @Override\n        public Iterator<Map.Entry<K, V>> iterator() {\n            return new ListOrderedIterator<>(parent, insertOrder);\n        }\n\n        @Override\n        @SuppressWarnings(\"unchecked\")\n        public boolean remove(final Object obj) {\n            if (!(obj instanceof Map.Entry)) {\n                return false;\n            }\n            if (getEntrySet().contains(obj)) {\n                final Object key = ((Map.Entry<K, V>) obj).getKey();\n                parent.remove(key);\n                return true;\n            }\n            return false;\n        }\n\n        @Override\n        public int size() {\n            return parent.size();\n        }\n\n        @Override\n        public String toString() {\n            return getEntrySet().toString();\n        }\n    }", "definition": "    static class EntrySetView<K, V> extends AbstractSet<Map.Entry<K, V>>", "class_docstring": "", "name": "EntrySetView", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "private final ListOrderedMap<K, V> parent;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ListOrderedMap<K, V>", "name": "parent", "syntax_pass": true}, {"attribute_expression": "private final List<K> insertOrder;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<K>", "name": "insertOrder", "syntax_pass": true}, {"attribute_expression": "private Set<Map.Entry<K, V>> entrySet;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Set<Map.Entry<K, V>>", "name": "entrySet", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        EntrySetView(final ListOrderedMap<K, V> parent, final List<K> insertOrder) {\n            this.parent = parent;\n            this.insertOrder = insertOrder;\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "EntrySetView", "params": [{"name": "parent", "type": "ListOrderedMap<K, V>"}, {"name": "insertOrder", "type": "List<K>"}], "body": "                                                                                   {\n            this.parent = parent;\n            this.insertOrder = insertOrder;\n        }", "signature": "EntrySetView(final ListOrderedMap<K, V> parent, final List<K> insertOrder)"}, {"syntax_pass": true, "original_string": "        @Override\n        public void clear() {\n            parent.clear();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "clear", "params": [], "body": "                            {\n            parent.clear();\n        }", "signature": "@Override\n        public void clear()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean contains(final Object obj) {\n            return getEntrySet().contains(obj);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "contains", "params": [{"name": "obj", "type": "Object"}], "body": "                                                  {\n            return getEntrySet().contains(obj);\n        }", "signature": "@Override\n        public boolean contains(final Object obj)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean containsAll(final Collection<?> coll) {\n            return getEntrySet().containsAll(coll);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "containsAll", "params": [{"name": "coll", "type": "Collection<?>"}], "body": "                                                             {\n            return getEntrySet().containsAll(coll);\n        }", "signature": "@Override\n        public boolean containsAll(final Collection<?> coll)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean equals(final Object obj) {\n            if (obj == this) {\n                return true;\n            }\n            return getEntrySet().equals(obj);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "obj", "type": "Object"}], "body": "                                                {\n            if (obj == this) {\n                return true;\n            }\n            return getEntrySet().equals(obj);\n        }", "signature": "@Override\n        public boolean equals(final Object obj)"}, {"syntax_pass": true, "original_string": "        private Set<Map.Entry<K, V>> getEntrySet() {\n            if (entrySet == null) {\n                entrySet = parent.decorated().entrySet();\n            }\n            return entrySet;\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Set<Map.Entry<K, V>>", "classes": []}, "name": "getEntrySet", "params": [], "body": "                                                   {\n            if (entrySet == null) {\n                entrySet = parent.decorated().entrySet();\n            }\n            return entrySet;\n        }", "signature": "private Set<Map.Entry<K, V>> getEntrySet()"}, {"syntax_pass": true, "original_string": "        @Override\n        public int hashCode() {\n            return getEntrySet().hashCode();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                              {\n            return getEntrySet().hashCode();\n        }", "signature": "@Override\n        public int hashCode()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isEmpty() {\n            return parent.isEmpty();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isEmpty", "params": [], "body": "                                 {\n            return parent.isEmpty();\n        }", "signature": "@Override\n        public boolean isEmpty()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Iterator<Map.Entry<K, V>> iterator() {\n            return new ListOrderedIterator<>(parent, insertOrder);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Iterator<Map.Entry<K, V>>", "classes": []}, "name": "iterator", "params": [], "body": "                                                    {\n            return new ListOrderedIterator<>(parent, insertOrder);\n        }", "signature": "@Override\n        public Iterator<Map.Entry<K, V>> iterator()"}, {"syntax_pass": true, "original_string": "        @Override\n        @SuppressWarnings(\"unchecked\")\n        public boolean remove(final Object obj) {\n            if (!(obj instanceof Map.Entry)) {\n                return false;\n            }\n            if (getEntrySet().contains(obj)) {\n                final Object key = ((Map.Entry<K, V>) obj).getKey();\n                parent.remove(key);\n                return true;\n            }\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        @SuppressWarnings(\"unchecked\")\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "remove", "params": [{"name": "obj", "type": "Object"}], "body": "                                                {\n            if (!(obj instanceof Map.Entry)) {\n                return false;\n            }\n            if (getEntrySet().contains(obj)) {\n                final Object key = ((Map.Entry<K, V>) obj).getKey();\n                parent.remove(key);\n                return true;\n            }\n            return false;\n        }", "signature": "@Override\n        @SuppressWarnings(\"unchecked\")\n        public boolean remove(final Object obj)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int size() {\n            return parent.size();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "size", "params": [], "body": "                          {\n            return parent.size();\n        }", "signature": "@Override\n        public int size()"}, {"syntax_pass": true, "original_string": "        @Override\n        public String toString() {\n            return getEntrySet().toString();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                 {\n            return getEntrySet().toString();\n        }", "signature": "@Override\n        public String toString()"}]}, {"original_string": "    static class KeySetView<K> extends AbstractSet<K> {\n        private final ListOrderedMap<K, Object> parent;\n\n        @SuppressWarnings(\"unchecked\")\n        KeySetView(final ListOrderedMap<K, ?> parent) {\n            this.parent = (ListOrderedMap<K, Object>) parent;\n        }\n\n        @Override\n        public void clear() {\n            parent.clear();\n        }\n\n        @Override\n        public boolean contains(final Object value) {\n            return parent.containsKey(value);\n        }\n\n        @Override\n        public Iterator<K> iterator() {\n            return new AbstractUntypedIteratorDecorator<Map.Entry<K, Object>, K>(parent.entrySet().iterator()) {\n                @Override\n                public K next() {\n                    return getIterator().next().getKey();\n                }\n            };\n        }\n\n        @Override\n        public int size() {\n            return parent.size();\n        }\n    }", "definition": "    static class KeySetView<K> extends AbstractSet<K>", "class_docstring": "", "name": "KeySetView", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "private final ListOrderedMap<K, Object> parent;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ListOrderedMap<K, Object>", "name": "parent", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @SuppressWarnings(\"unchecked\")\n        KeySetView(final ListOrderedMap<K, ?> parent) {\n            this.parent = (ListOrderedMap<K, Object>) parent;\n        }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")"], "comments": [], "return_type": "", "classes": []}, "name": "KeySetView", "params": [{"name": "parent", "type": "ListOrderedMap<K, ?>"}], "body": "                                                      {\n            this.parent = (ListOrderedMap<K, Object>) parent;\n        }", "signature": "@SuppressWarnings(\"unchecked\")\n        KeySetView(final ListOrderedMap<K, ?> parent)"}, {"syntax_pass": true, "original_string": "        @Override\n        public void clear() {\n            parent.clear();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "clear", "params": [], "body": "                            {\n            parent.clear();\n        }", "signature": "@Override\n        public void clear()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean contains(final Object value) {\n            return parent.containsKey(value);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "contains", "params": [{"name": "value", "type": "Object"}], "body": "                                                    {\n            return parent.containsKey(value);\n        }", "signature": "@Override\n        public boolean contains(final Object value)"}, {"syntax_pass": true, "original_string": "        @Override\n        public Iterator<K> iterator() {\n            return new AbstractUntypedIteratorDecorator<Map.Entry<K, Object>, K>(parent.entrySet().iterator()) {\n                @Override\n                public K next() {\n                    return getIterator().next().getKey();\n                }\n            };\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Iterator<K>", "classes": []}, "name": "iterator", "params": [], "body": "                                      {\n            return new AbstractUntypedIteratorDecorator<Map.Entry<K, Object>, K>(parent.entrySet().iterator()) {\n                @Override\n                public K next() {\n                    return getIterator().next().getKey();\n                }\n            };\n        }", "signature": "@Override\n        public Iterator<K> iterator()"}, {"syntax_pass": true, "original_string": "        @Override\n        public int size() {\n            return parent.size();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "size", "params": [], "body": "                          {\n            return parent.size();\n        }", "signature": "@Override\n        public int size()"}]}, {"original_string": "    static class ListOrderedIterator<K, V> extends AbstractUntypedIteratorDecorator<K, Map.Entry<K, V>> {\n        private final ListOrderedMap<K, V> parent;\n        private K last;\n\n        ListOrderedIterator(final ListOrderedMap<K, V> parent, final List<K> insertOrder) {\n            super(insertOrder.iterator());\n            this.parent = parent;\n        }\n\n        @Override\n        public Map.Entry<K, V> next() {\n            last = getIterator().next();\n            return new ListOrderedMapEntry<>(parent, last);\n        }\n\n        @Override\n        public void remove() {\n            super.remove();\n            parent.decorated().remove(last);\n        }\n    }", "definition": "    static class ListOrderedIterator<K, V> extends AbstractUntypedIteratorDecorator<K, Map.Entry<K, V>>", "class_docstring": "", "name": "ListOrderedIterator", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "private final ListOrderedMap<K, V> parent;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ListOrderedMap<K, V>", "name": "parent", "syntax_pass": true}, {"attribute_expression": "private K last;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "K", "name": "last", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        ListOrderedIterator(final ListOrderedMap<K, V> parent, final List<K> insertOrder) {\n            super(insertOrder.iterator());\n            this.parent = parent;\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "ListOrderedIterator", "params": [{"name": "parent", "type": "ListOrderedMap<K, V>"}, {"name": "insertOrder", "type": "List<K>"}], "body": "                                                                                          {\n            super(insertOrder.iterator());\n            this.parent = parent;\n        }", "signature": "ListOrderedIterator(final ListOrderedMap<K, V> parent, final List<K> insertOrder)"}, {"syntax_pass": true, "original_string": "        @Override\n        public Map.Entry<K, V> next() {\n            last = getIterator().next();\n            return new ListOrderedMapEntry<>(parent, last);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map.Entry<K, V>", "classes": []}, "name": "next", "params": [], "body": "                                      {\n            last = getIterator().next();\n            return new ListOrderedMapEntry<>(parent, last);\n        }", "signature": "@Override\n        public Map.Entry<K, V> next()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void remove() {\n            super.remove();\n            parent.decorated().remove(last);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "remove", "params": [], "body": "                             {\n            super.remove();\n            parent.decorated().remove(last);\n        }", "signature": "@Override\n        public void remove()"}]}, {"original_string": "    static class ListOrderedMapEntry<K, V> extends AbstractMapEntry<K, V> {\n        private final ListOrderedMap<K, V> parent;\n\n        ListOrderedMapEntry(final ListOrderedMap<K, V> parent, final K key) {\n            super(key, null);\n            this.parent = parent;\n        }\n\n        @Override\n        public V getValue() {\n            return parent.get(getKey());\n        }\n\n        @Override\n        public V setValue(final V value) {\n            return parent.decorated().put(getKey(), value);\n        }\n    }", "definition": "    static class ListOrderedMapEntry<K, V> extends AbstractMapEntry<K, V>", "class_docstring": "", "name": "ListOrderedMapEntry", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "private final ListOrderedMap<K, V> parent;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ListOrderedMap<K, V>", "name": "parent", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        ListOrderedMapEntry(final ListOrderedMap<K, V> parent, final K key) {\n            super(key, null);\n            this.parent = parent;\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "ListOrderedMapEntry", "params": [{"name": "parent", "type": "ListOrderedMap<K, V>"}, {"name": "key", "type": "K"}], "body": "                                                                            {\n            super(key, null);\n            this.parent = parent;\n        }", "signature": "ListOrderedMapEntry(final ListOrderedMap<K, V> parent, final K key)"}, {"syntax_pass": true, "original_string": "        @Override\n        public V getValue() {\n            return parent.get(getKey());\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "getValue", "params": [], "body": "                            {\n            return parent.get(getKey());\n        }", "signature": "@Override\n        public V getValue()"}, {"syntax_pass": true, "original_string": "        @Override\n        public V setValue(final V value) {\n            return parent.decorated().put(getKey(), value);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "setValue", "params": [{"name": "value", "type": "V"}], "body": "                                         {\n            return parent.decorated().put(getKey(), value);\n        }", "signature": "@Override\n        public V setValue(final V value)"}]}, {"original_string": "    static class ListOrderedMapIterator<K, V> implements OrderedMapIterator<K, V>, ResettableIterator<K> {\n        private final ListOrderedMap<K, V> parent;\n        private ListIterator<K> iterator;\n        private K last;\n        private boolean readable;\n\n        ListOrderedMapIterator(final ListOrderedMap<K, V> parent) {\n            this.parent = parent;\n            this.iterator = parent.insertOrder.listIterator();\n        }\n\n        @Override\n        public K getKey() {\n            if (!readable) {\n                throw new IllegalStateException(AbstractHashedMap.GETKEY_INVALID);\n            }\n            return last;\n        }\n\n        @Override\n        public V getValue() {\n            if (!readable) {\n                throw new IllegalStateException(AbstractHashedMap.GETVALUE_INVALID);\n            }\n            return parent.get(last);\n        }\n\n        @Override\n        public boolean hasNext() {\n            return iterator.hasNext();\n        }\n\n        @Override\n        public boolean hasPrevious() {\n            return iterator.hasPrevious();\n        }\n\n        @Override\n        public K next() {\n            last = iterator.next();\n            readable = true;\n            return last;\n        }\n\n        @Override\n        public K previous() {\n            last = iterator.previous();\n            readable = true;\n            return last;\n        }\n\n        @Override\n        public void remove() {\n            if (!readable) {\n                throw new IllegalStateException(AbstractHashedMap.REMOVE_INVALID);\n            }\n            iterator.remove();\n            parent.map.remove(last);\n            readable = false;\n        }\n\n        @Override\n        public void reset() {\n            iterator = parent.insertOrder.listIterator();\n            last = null;\n            readable = false;\n        }\n\n        @Override\n        public V setValue(final V value) {\n            if (!readable) {\n                throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);\n            }\n            return parent.map.put(last, value);\n        }\n\n        @Override\n        public String toString() {\n            if (readable) {\n                return \"Iterator[\" + getKey() + \"=\" + getValue() + \"]\";\n            }\n            return \"Iterator[]\";\n        }\n    }", "definition": "    static class ListOrderedMapIterator<K, V> implements OrderedMapIterator<K, V>, ResettableIterator<K>", "class_docstring": "", "name": "ListOrderedMapIterator", "super_interfaces": ["OrderedMapIterator<K, V>", "ResettableIterator<K>"], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "private final ListOrderedMap<K, V> parent;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ListOrderedMap<K, V>", "name": "parent", "syntax_pass": true}, {"attribute_expression": "private ListIterator<K> iterator;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ListIterator<K>", "name": "iterator", "syntax_pass": true}, {"attribute_expression": "private K last;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "K", "name": "last", "syntax_pass": true}, {"attribute_expression": "private boolean readable;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "readable", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        ListOrderedMapIterator(final ListOrderedMap<K, V> parent) {\n            this.parent = parent;\n            this.iterator = parent.insertOrder.listIterator();\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "ListOrderedMapIterator", "params": [{"name": "parent", "type": "ListOrderedMap<K, V>"}], "body": "                                                                  {\n            this.parent = parent;\n            this.iterator = parent.insertOrder.listIterator();\n        }", "signature": "ListOrderedMapIterator(final ListOrderedMap<K, V> parent)"}, {"syntax_pass": true, "original_string": "        @Override\n        public K getKey() {\n            if (!readable) {\n                throw new IllegalStateException(AbstractHashedMap.GETKEY_INVALID);\n            }\n            return last;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "K", "classes": []}, "name": "getKey", "params": [], "body": "                          {\n            if (!readable) {\n                throw new IllegalStateException(AbstractHashedMap.GETKEY_INVALID);\n            }\n            return last;\n        }", "signature": "@Override\n        public K getKey()"}, {"syntax_pass": true, "original_string": "        @Override\n        public V getValue() {\n            if (!readable) {\n                throw new IllegalStateException(AbstractHashedMap.GETVALUE_INVALID);\n            }\n            return parent.get(last);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "getValue", "params": [], "body": "                            {\n            if (!readable) {\n                throw new IllegalStateException(AbstractHashedMap.GETVALUE_INVALID);\n            }\n            return parent.get(last);\n        }", "signature": "@Override\n        public V getValue()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean hasNext() {\n            return iterator.hasNext();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasNext", "params": [], "body": "                                 {\n            return iterator.hasNext();\n        }", "signature": "@Override\n        public boolean hasNext()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean hasPrevious() {\n            return iterator.hasPrevious();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasPrevious", "params": [], "body": "                                     {\n            return iterator.hasPrevious();\n        }", "signature": "@Override\n        public boolean hasPrevious()"}, {"syntax_pass": true, "original_string": "        @Override\n        public K next() {\n            last = iterator.next();\n            readable = true;\n            return last;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "K", "classes": []}, "name": "next", "params": [], "body": "                        {\n            last = iterator.next();\n            readable = true;\n            return last;\n        }", "signature": "@Override\n        public K next()"}, {"syntax_pass": true, "original_string": "        @Override\n        public K previous() {\n            last = iterator.previous();\n            readable = true;\n            return last;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "K", "classes": []}, "name": "previous", "params": [], "body": "                            {\n            last = iterator.previous();\n            readable = true;\n            return last;\n        }", "signature": "@Override\n        public K previous()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void remove() {\n            if (!readable) {\n                throw new IllegalStateException(AbstractHashedMap.REMOVE_INVALID);\n            }\n            iterator.remove();\n            parent.map.remove(last);\n            readable = false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "remove", "params": [], "body": "                             {\n            if (!readable) {\n                throw new IllegalStateException(AbstractHashedMap.REMOVE_INVALID);\n            }\n            iterator.remove();\n            parent.map.remove(last);\n            readable = false;\n        }", "signature": "@Override\n        public void remove()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void reset() {\n            iterator = parent.insertOrder.listIterator();\n            last = null;\n            readable = false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "reset", "params": [], "body": "                            {\n            iterator = parent.insertOrder.listIterator();\n            last = null;\n            readable = false;\n        }", "signature": "@Override\n        public void reset()"}, {"syntax_pass": true, "original_string": "        @Override\n        public V setValue(final V value) {\n            if (!readable) {\n                throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);\n            }\n            return parent.map.put(last, value);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "setValue", "params": [{"name": "value", "type": "V"}], "body": "                                         {\n            if (!readable) {\n                throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);\n            }\n            return parent.map.put(last, value);\n        }", "signature": "@Override\n        public V setValue(final V value)"}, {"syntax_pass": true, "original_string": "        @Override\n        public String toString() {\n            if (readable) {\n                return \"Iterator[\" + getKey() + \"=\" + getValue() + \"]\";\n            }\n            return \"Iterator[]\";\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                 {\n            if (readable) {\n                return \"Iterator[\" + getKey() + \"=\" + getValue() + \"]\";\n            }\n            return \"Iterator[]\";\n        }", "signature": "@Override\n        public String toString()"}]}, {"original_string": "    static class ValuesView<V> extends AbstractList<V> {\n        private final ListOrderedMap<Object, V> parent;\n\n        @SuppressWarnings(\"unchecked\")\n        ValuesView(final ListOrderedMap<?, V> parent) {\n            this.parent = (ListOrderedMap<Object, V>) parent;\n        }\n\n        @Override\n        public void clear() {\n            parent.clear();\n        }\n\n        @Override\n        public boolean contains(final Object value) {\n            return parent.containsValue(value);\n        }\n\n        @Override\n        public V get(final int index) {\n            return parent.getValue(index);\n        }\n\n        @Override\n        public Iterator<V> iterator() {\n            return new AbstractUntypedIteratorDecorator<Map.Entry<Object, V>, V>(parent.entrySet().iterator()) {\n                @Override\n                public V next() {\n                    return getIterator().next().getValue();\n                }\n            };\n        }\n\n        @Override\n        public V remove(final int index) {\n            return parent.remove(index);\n        }\n\n        @Override\n        public V set(final int index, final V value) {\n            return parent.setValue(index, value);\n        }\n\n        @Override\n        public int size() {\n            return parent.size();\n        }\n    }", "definition": "    static class ValuesView<V> extends AbstractList<V>", "class_docstring": "", "name": "ValuesView", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "private final ListOrderedMap<Object, V> parent;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ListOrderedMap<Object, V>", "name": "parent", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @SuppressWarnings(\"unchecked\")\n        ValuesView(final ListOrderedMap<?, V> parent) {\n            this.parent = (ListOrderedMap<Object, V>) parent;\n        }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")"], "comments": [], "return_type": "", "classes": []}, "name": "ValuesView", "params": [{"name": "parent", "type": "ListOrderedMap<?, V>"}], "body": "                                                      {\n            this.parent = (ListOrderedMap<Object, V>) parent;\n        }", "signature": "@SuppressWarnings(\"unchecked\")\n        ValuesView(final ListOrderedMap<?, V> parent)"}, {"syntax_pass": true, "original_string": "        @Override\n        public void clear() {\n            parent.clear();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "clear", "params": [], "body": "                            {\n            parent.clear();\n        }", "signature": "@Override\n        public void clear()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean contains(final Object value) {\n            return parent.containsValue(value);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "contains", "params": [{"name": "value", "type": "Object"}], "body": "                                                    {\n            return parent.containsValue(value);\n        }", "signature": "@Override\n        public boolean contains(final Object value)"}, {"syntax_pass": true, "original_string": "        @Override\n        public V get(final int index) {\n            return parent.getValue(index);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "get", "params": [{"name": "index", "type": "int"}], "body": "                                      {\n            return parent.getValue(index);\n        }", "signature": "@Override\n        public V get(final int index)"}, {"syntax_pass": true, "original_string": "        @Override\n        public Iterator<V> iterator() {\n            return new AbstractUntypedIteratorDecorator<Map.Entry<Object, V>, V>(parent.entrySet().iterator()) {\n                @Override\n                public V next() {\n                    return getIterator().next().getValue();\n                }\n            };\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Iterator<V>", "classes": []}, "name": "iterator", "params": [], "body": "                                      {\n            return new AbstractUntypedIteratorDecorator<Map.Entry<Object, V>, V>(parent.entrySet().iterator()) {\n                @Override\n                public V next() {\n                    return getIterator().next().getValue();\n                }\n            };\n        }", "signature": "@Override\n        public Iterator<V> iterator()"}, {"syntax_pass": true, "original_string": "        @Override\n        public V remove(final int index) {\n            return parent.remove(index);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "remove", "params": [{"name": "index", "type": "int"}], "body": "                                         {\n            return parent.remove(index);\n        }", "signature": "@Override\n        public V remove(final int index)"}, {"syntax_pass": true, "original_string": "        @Override\n        public V set(final int index, final V value) {\n            return parent.setValue(index, value);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "set", "params": [{"name": "index", "type": "int"}, {"name": "value", "type": "V"}], "body": "                                                     {\n            return parent.setValue(index, value);\n        }", "signature": "@Override\n        public V set(final int index, final V value)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int size() {\n            return parent.size();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "size", "params": [], "body": "                          {\n            return parent.size();\n        }", "signature": "@Override\n        public int size()"}]}], "class_docstring": "\nDecorates a {@code Map} to ensure that the order of addition is retained\nusing a {@code List} to maintain order.\n<p>\nThe order will be used via the iterators and toArray methods on the views.\nThe order is also returned by the {@code MapIterator}.\nThe {@code orderedMapIterator()} method accesses an iterator that can\niterate both forwards and backwards through the map.\nIn addition, non-interface methods are provided to access the map by index.\n</p>\n<p>\nIf an object is added to the Map for a second time, it will remain in the\noriginal position in the iteration.\n</p>\n<p>\n<strong>Note that ListOrderedMap is not synchronized and is not thread-safe.</strong>\nIf you wish to use this map from multiple threads concurrently, you must use\nappropriate synchronization. The simplest approach is to wrap this map\nusing {@link java.util.Collections#synchronizedMap(Map)}. This class may throw\nexceptions when accessed by concurrent threads without synchronization.\n</p>\n<p>\n<strong>Note that ListOrderedMap doesn't work with\n{@link java.util.IdentityHashMap IdentityHashMap}, {@link CaseInsensitiveMap},\nor similar maps that violate the general contract of {@link java.util.Map}.</strong>\nThe {@code ListOrderedMap} (or, more precisely, the underlying {@code List})\nis relying on {@link Object#equals(Object) equals()}. This is fine, as long as the\ndecorated {@code Map} is also based on {@link Object#equals(Object) equals()},\nand {@link Object#hashCode() hashCode()}, which\n{@link java.util.IdentityHashMap IdentityHashMap}, and\n{@link CaseInsensitiveMap} don't: The former uses {@code ==}, and\nthe latter uses {@link Object#equals(Object) equals()} on a lower-cased\nkey.\n</p>\n<p>\nThis class is {@link Serializable} starting with Commons Collections 3.1.\n</p>\n\n@param <K> the type of the keys in this map\n@param <V> the type of the values in this map\n@since 3.0\n", "original_string": "public class ListOrderedMap<K, V>\n        extends AbstractMapDecorator<K, V>\n        implements OrderedMap<K, V>, Serializable {\n\n    static class EntrySetView<K, V> extends AbstractSet<Map.Entry<K, V>> {\n        private final ListOrderedMap<K, V> parent;\n        private final List<K> insertOrder;\n        private Set<Map.Entry<K, V>> entrySet;\n\n        EntrySetView(final ListOrderedMap<K, V> parent, final List<K> insertOrder) {\n            this.parent = parent;\n            this.insertOrder = insertOrder;\n        }\n\n        @Override\n        public void clear() {\n            parent.clear();\n        }\n\n        @Override\n        public boolean contains(final Object obj) {\n            return getEntrySet().contains(obj);\n        }\n        @Override\n        public boolean containsAll(final Collection<?> coll) {\n            return getEntrySet().containsAll(coll);\n        }\n\n        @Override\n        public boolean equals(final Object obj) {\n            if (obj == this) {\n                return true;\n            }\n            return getEntrySet().equals(obj);\n        }\n\n        private Set<Map.Entry<K, V>> getEntrySet() {\n            if (entrySet == null) {\n                entrySet = parent.decorated().entrySet();\n            }\n            return entrySet;\n        }\n\n        @Override\n        public int hashCode() {\n            return getEntrySet().hashCode();\n        }\n\n        @Override\n        public boolean isEmpty() {\n            return parent.isEmpty();\n        }\n\n        @Override\n        public Iterator<Map.Entry<K, V>> iterator() {\n            return new ListOrderedIterator<>(parent, insertOrder);\n        }\n\n        @Override\n        @SuppressWarnings(\"unchecked\")\n        public boolean remove(final Object obj) {\n            if (!(obj instanceof Map.Entry)) {\n                return false;\n            }\n            if (getEntrySet().contains(obj)) {\n                final Object key = ((Map.Entry<K, V>) obj).getKey();\n                parent.remove(key);\n                return true;\n            }\n            return false;\n        }\n\n        @Override\n        public int size() {\n            return parent.size();\n        }\n\n        @Override\n        public String toString() {\n            return getEntrySet().toString();\n        }\n    }\n\n    static class KeySetView<K> extends AbstractSet<K> {\n        private final ListOrderedMap<K, Object> parent;\n\n        @SuppressWarnings(\"unchecked\")\n        KeySetView(final ListOrderedMap<K, ?> parent) {\n            this.parent = (ListOrderedMap<K, Object>) parent;\n        }\n\n        @Override\n        public void clear() {\n            parent.clear();\n        }\n\n        @Override\n        public boolean contains(final Object value) {\n            return parent.containsKey(value);\n        }\n\n        @Override\n        public Iterator<K> iterator() {\n            return new AbstractUntypedIteratorDecorator<Map.Entry<K, Object>, K>(parent.entrySet().iterator()) {\n                @Override\n                public K next() {\n                    return getIterator().next().getKey();\n                }\n            };\n        }\n\n        @Override\n        public int size() {\n            return parent.size();\n        }\n    }\n\n    static class ListOrderedIterator<K, V> extends AbstractUntypedIteratorDecorator<K, Map.Entry<K, V>> {\n        private final ListOrderedMap<K, V> parent;\n        private K last;\n\n        ListOrderedIterator(final ListOrderedMap<K, V> parent, final List<K> insertOrder) {\n            super(insertOrder.iterator());\n            this.parent = parent;\n        }\n\n        @Override\n        public Map.Entry<K, V> next() {\n            last = getIterator().next();\n            return new ListOrderedMapEntry<>(parent, last);\n        }\n\n        @Override\n        public void remove() {\n            super.remove();\n            parent.decorated().remove(last);\n        }\n    }\n\n    static class ListOrderedMapEntry<K, V> extends AbstractMapEntry<K, V> {\n        private final ListOrderedMap<K, V> parent;\n\n        ListOrderedMapEntry(final ListOrderedMap<K, V> parent, final K key) {\n            super(key, null);\n            this.parent = parent;\n        }\n\n        @Override\n        public V getValue() {\n            return parent.get(getKey());\n        }\n\n        @Override\n        public V setValue(final V value) {\n            return parent.decorated().put(getKey(), value);\n        }\n    }\n\n    static class ListOrderedMapIterator<K, V> implements OrderedMapIterator<K, V>, ResettableIterator<K> {\n        private final ListOrderedMap<K, V> parent;\n        private ListIterator<K> iterator;\n        private K last;\n        private boolean readable;\n\n        ListOrderedMapIterator(final ListOrderedMap<K, V> parent) {\n            this.parent = parent;\n            this.iterator = parent.insertOrder.listIterator();\n        }\n\n        @Override\n        public K getKey() {\n            if (!readable) {\n                throw new IllegalStateException(AbstractHashedMap.GETKEY_INVALID);\n            }\n            return last;\n        }\n\n        @Override\n        public V getValue() {\n            if (!readable) {\n                throw new IllegalStateException(AbstractHashedMap.GETVALUE_INVALID);\n            }\n            return parent.get(last);\n        }\n\n        @Override\n        public boolean hasNext() {\n            return iterator.hasNext();\n        }\n\n        @Override\n        public boolean hasPrevious() {\n            return iterator.hasPrevious();\n        }\n\n        @Override\n        public K next() {\n            last = iterator.next();\n            readable = true;\n            return last;\n        }\n\n        @Override\n        public K previous() {\n            last = iterator.previous();\n            readable = true;\n            return last;\n        }\n\n        @Override\n        public void remove() {\n            if (!readable) {\n                throw new IllegalStateException(AbstractHashedMap.REMOVE_INVALID);\n            }\n            iterator.remove();\n            parent.map.remove(last);\n            readable = false;\n        }\n\n        @Override\n        public void reset() {\n            iterator = parent.insertOrder.listIterator();\n            last = null;\n            readable = false;\n        }\n\n        @Override\n        public V setValue(final V value) {\n            if (!readable) {\n                throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);\n            }\n            return parent.map.put(last, value);\n        }\n\n        @Override\n        public String toString() {\n            if (readable) {\n                return \"Iterator[\" + getKey() + \"=\" + getValue() + \"]\";\n            }\n            return \"Iterator[]\";\n        }\n    }\n\n    static class ValuesView<V> extends AbstractList<V> {\n        private final ListOrderedMap<Object, V> parent;\n\n        @SuppressWarnings(\"unchecked\")\n        ValuesView(final ListOrderedMap<?, V> parent) {\n            this.parent = (ListOrderedMap<Object, V>) parent;\n        }\n\n        @Override\n        public void clear() {\n            parent.clear();\n        }\n\n        @Override\n        public boolean contains(final Object value) {\n            return parent.containsValue(value);\n        }\n\n        @Override\n        public V get(final int index) {\n            return parent.getValue(index);\n        }\n\n        @Override\n        public Iterator<V> iterator() {\n            return new AbstractUntypedIteratorDecorator<Map.Entry<Object, V>, V>(parent.entrySet().iterator()) {\n                @Override\n                public V next() {\n                    return getIterator().next().getValue();\n                }\n            };\n        }\n\n        @Override\n        public V remove(final int index) {\n            return parent.remove(index);\n        }\n\n        @Override\n        public V set(final int index, final V value) {\n            return parent.setValue(index, value);\n        }\n\n        @Override\n        public int size() {\n            return parent.size();\n        }\n    }\n\n    /** Serialization version */\n    private static final long serialVersionUID = 2728177751851003750L;\n\n    /**\n     * Factory method to create an ordered map.\n     * <p>\n     * An {@code ArrayList} is used to retain order.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param map  the map to decorate, must not be null\n     * @return a new list ordered map\n     * @throws NullPointerException if map is null\n     * @since 4.0\n     */\n    public static <K, V> ListOrderedMap<K, V> listOrderedMap(final Map<K, V> map) {\n        return new ListOrderedMap<>(map);\n    }\n\n    /** Internal list to hold the sequence of objects */\n    private final List<K> insertOrder = new ArrayList<>();\n\n    /**\n     * Constructs a new empty {@code ListOrderedMap} that decorates\n     * a {@code HashMap}.\n     *\n     * @since 3.1\n     */\n    public ListOrderedMap() {\n        this(new HashMap<>());\n    }\n\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param map  the map to decorate, must not be null\n     * @throws NullPointerException if map is null\n     */\n    protected ListOrderedMap(final Map<K, V> map) {\n        super(map);\n        insertOrder.addAll(decorated().keySet());\n    }\n\n    /**\n     * Gets an unmodifiable List view of the keys which changes as the map changes.\n     * <p>\n     * The returned list is unmodifiable because changes to the values of\n     * the list (using {@link java.util.ListIterator#set(Object)}) will\n     * effectively remove the value from the list and reinsert that value at\n     * the end of the list, which is an unexpected side effect of changing the\n     * value of a list.  This occurs because changing the key, changes when the\n     * mapping is added to the map and thus where it appears in the list.\n     * <p>\n     * An alternative to this method is to use the better named\n     * {@link #keyList()} or {@link #keySet()}.\n     *\n     * @see #keyList()\n     * @see #keySet()\n     * @return The ordered list of keys.\n     */\n    public List<K> asList() {\n        return keyList();\n    }\n\n    @Override\n    public void clear() {\n        decorated().clear();\n        insertOrder.clear();\n    }\n\n    /**\n     * Gets a view over the entries in the map.\n     * <p>\n     * The Set will be ordered by object insertion into the map.\n     *\n     * @return the fully modifiable set view over the entries\n     */\n    @Override\n    public Set<Map.Entry<K, V>> entrySet() {\n        return new EntrySetView<>(this, insertOrder);\n    }\n\n    /**\n     * Gets the first key in this map by insert order.\n     *\n     * @return the first key currently in this map\n     * @throws NoSuchElementException if this map is empty\n     */\n    @Override\n    public K firstKey() {\n        if (isEmpty()) {\n            throw new NoSuchElementException(\"Map is empty\");\n        }\n        return insertOrder.get(0);\n    }\n\n    /**\n     * Gets the key at the specified index.\n     *\n     * @param index  the index to retrieve\n     * @return the key at the specified index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public K get(final int index) {\n        return insertOrder.get(index);\n    }\n\n    /**\n     * Gets the value at the specified index.\n     *\n     * @param index  the index to retrieve\n     * @return the key at the specified index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public V getValue(final int index) {\n        return get(insertOrder.get(index));\n    }\n\n    /**\n     * Gets the index of the specified key.\n     *\n     * @param key  the key to find the index of\n     * @return the index, or -1 if not found\n     */\n    public int indexOf(final Object key) {\n        return insertOrder.indexOf(key);\n    }\n\n    /**\n     * Gets a view over the keys in the map as a List.\n     * <p>\n     * The List will be ordered by object insertion into the map.\n     * The List is unmodifiable.\n     *\n     * @see #keySet()\n     * @return the unmodifiable list view over the keys\n     * @since 3.2\n     */\n    public List<K> keyList() {\n        return UnmodifiableList.unmodifiableList(insertOrder);\n    }\n\n    /**\n     * Gets a view over the keys in the map.\n     * <p>\n     * The Collection will be ordered by object insertion into the map.\n     *\n     * @see #keyList()\n     * @return the fully modifiable collection view over the keys\n     */\n    @Override\n    public Set<K> keySet() {\n        return new KeySetView<>(this);\n    }\n\n    /**\n     * Gets the last key in this map by insert order.\n     *\n     * @return the last key currently in this map\n     * @throws NoSuchElementException if this map is empty\n     */\n    @Override\n    public K lastKey() {\n        if (isEmpty()) {\n            throw new NoSuchElementException(\"Map is empty\");\n        }\n        return insertOrder.get(size() - 1);\n    }\n\n    // Implement OrderedMap\n    @Override\n    public OrderedMapIterator<K, V> mapIterator() {\n        return new ListOrderedMapIterator<>(this);\n    }\n\n    /**\n     * Gets the next key to the one specified using insert order.\n     * This method performs a list search to find the key and is O(n).\n     *\n     * @param key  the key to find previous for\n     * @return the next key, null if no match or at start\n     */\n    @Override\n    public K nextKey(final Object key) {\n        final int index = insertOrder.indexOf(key);\n        if (index >= 0 && index < size() - 1) {\n            return insertOrder.get(index + 1);\n        }\n        return null;\n    }\n\n    /**\n     * Gets the previous key to the one specified using insert order.\n     * This method performs a list search to find the key and is O(n).\n     *\n     * @param key  the key to find previous for\n     * @return the previous key, null if no match or at start\n     */\n    @Override\n    public K previousKey(final Object key) {\n        final int index = insertOrder.indexOf(key);\n        if (index > 0) {\n            return insertOrder.get(index - 1);\n        }\n        return null;\n    }\n\n    /**\n     * Puts a key-value mapping into the map at the specified index.\n     * <p>\n     * If the map already contains the key, then the original mapping\n     * is removed and the new mapping added at the specified index.\n     * The remove may change the effect of the index. The index is\n     * always calculated relative to the original state of the map.\n     * <p>\n     * Thus, the steps are: (1) remove the existing key-value mapping,\n     * then (2) insert the new key-value mapping at the position it\n     * would have been inserted had the remove not occurred.\n     *\n     * @param index  the index at which the mapping should be inserted\n     * @param key  the key\n     * @param value  the value\n     * @return the value previously mapped to the key\n     * @throws IndexOutOfBoundsException if the index is out of range [0, size]\n     * @since 3.2\n     */\n    public V put(int index, final K key, final V value) {\n        if (index < 0 || index > insertOrder.size()) {\n            throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size: \" + insertOrder.size());\n        }\n\n        final Map<K, V> m = decorated();\n        if (m.containsKey(key)) {\n            final V result = m.remove(key);\n            final int pos = insertOrder.indexOf(key);\n            insertOrder.remove(pos);\n            if (pos < index) {\n                index--;\n            }\n            insertOrder.add(index, key);\n            m.put(key, value);\n            return result;\n        }\n        insertOrder.add(index, key);\n        m.put(key, value);\n        return null;\n    }\n\n    @Override\n    public V put(final K key, final V value) {\n        if (decorated().containsKey(key)) {\n            // re-adding doesn't change order\n            return decorated().put(key, value);\n        }\n        // first add, so add to both map and list\n        final V result = decorated().put(key, value);\n        insertOrder.add(key);\n        return result;\n    }\n\n    /**\n     * Puts the values contained in a supplied Map into the Map starting at\n     * the specified index.\n     *\n     * @param index the index in the Map to start at.\n     * @param map the Map containing the entries to be added.\n     * @throws IndexOutOfBoundsException if the index is out of range [0, size]\n     */\n    public void putAll(int index, final Map<? extends K, ? extends V> map) {\n        if (index < 0 || index > insertOrder.size()) {\n            throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size: \" + insertOrder.size());\n        }\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            final K key = entry.getKey();\n            final boolean contains = containsKey(key);\n            // The return value of put is null if the key did not exist OR the value was null\n            // so it cannot be used to determine whether the key was added\n            put(index, entry.getKey(), entry.getValue());\n            if (!contains) {\n                // if no key was replaced, increment the index\n                index++;\n            } else {\n                // otherwise put the next item after the currently inserted key\n                index = indexOf(entry.getKey()) + 1;\n            }\n        }\n    }\n\n    @Override\n    public void putAll(final Map<? extends K, ? extends V> map) {\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            put(entry.getKey(), entry.getValue());\n        }\n    }\n\n    /**\n     * Deserializes the map in using a custom routine.\n     *\n     * @param in  the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded\n     * @since 3.1\n     */\n    @SuppressWarnings(\"unchecked\") // (1) should only fail if input stream is incorrect\n    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        map = (Map<K, V>) in.readObject(); // (1)\n    }\n\n    /**\n     * Removes the element at the specified index.\n     *\n     * @param index  the index of the object to remove\n     * @return the removed value, or {@code null} if none existed\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public V remove(final int index) {\n        return remove(get(index));\n    }\n\n    @Override\n    public V remove(final Object key) {\n        V result = null;\n        if (decorated().containsKey(key)) {\n            result = decorated().remove(key);\n            insertOrder.remove(key);\n        }\n        return result;\n    }\n\n    /**\n     * Sets the value at the specified index.\n     *\n     * @param index  the index of the value to set\n     * @param value  the new value to set\n     * @return the previous value at that index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     * @since 3.2\n     */\n    public V setValue(final int index, final V value) {\n        final K key = insertOrder.get(index);\n        return put(key, value);\n    }\n\n    /**\n     * Returns the Map as a string.\n     *\n     * @return the Map as a String\n     */\n    @Override\n    public String toString() {\n        if (isEmpty()) {\n            return \"{}\";\n        }\n        final StringBuilder buf = new StringBuilder();\n        buf.append('{');\n        boolean first = true;\n        for (final Map.Entry<K, V> entry : entrySet()) {\n            final K key = entry.getKey();\n            final V value = entry.getValue();\n            if (first) {\n                first = false;\n            } else {\n                buf.append(\", \");\n            }\n            buf.append(key == this ? \"(this Map)\" : key);\n            buf.append('=');\n            buf.append(value == this ? \"(this Map)\" : value);\n        }\n        buf.append('}');\n        return buf.toString();\n    }\n\n    /**\n     * Gets a view over the values in the map as a List.\n     * <p>\n     * The List will be ordered by object insertion into the map.\n     * The List supports remove and set, but does not support add.\n     *\n     * @see #values()\n     * @return the partially modifiable list view over the values\n     * @since 3.2\n     */\n    public List<V> valueList() {\n        return new ValuesView<>(this);\n    }\n\n    /**\n     * Gets a view over the values in the map.\n     * <p>\n     * The Collection will be ordered by object insertion into the map.\n     * <p>\n     * From Commons Collections 3.2, this Collection can be cast\n     * to a list, see {@link #valueList()}\n     *\n     * @see #valueList()\n     * @return the fully modifiable collection view over the values\n     */\n    @Override\n    public Collection<V> values() {\n        return new ValuesView<>(this);\n    }\n\n    /**\n     * Serializes this object to an ObjectOutputStream.\n     *\n     * @param out the target ObjectOutputStream.\n     * @throws IOException thrown when an I/O errors occur writing to the target stream.\n     * @since 3.1\n     */\n    private void writeObject(final ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        out.writeObject(map);\n    }\n\n}", "super_interfaces": ["OrderedMap<K, V>", "Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 2728177751851003750L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 2728177751851003750L", "syntax_pass": true}, {"attribute_expression": "private final List<K> insertOrder = new ArrayList<>();", "docstring": " Internal list to hold the sequence of objects", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<K>", "name": "insertOrder = new ArrayList<>()", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/map/EntrySetToMapIteratorAdapter.java.EntrySetToMapIteratorAdapter", "name": "EntrySetToMapIteratorAdapter", "file_path": "src/main/java/org/apache/commons/collections4/map/EntrySetToMapIteratorAdapter.java", "superclasses": "", "methods": ["[]EntrySetToMapIteratorAdapter(Set<Map.Entry<K, V>>)", "[Map.Entry<K, V>]current()", "[K]getKey()", "[V]getValue()", "[boolean]hasNext()", "[K]next()", "[void]remove()", "[void]reset()", "[V]setValue(V)"], "method_uris": ["src/main/java/org/apache/commons/collections4/map/EntrySetToMapIteratorAdapter.java.EntrySetToMapIteratorAdapter.[]EntrySetToMapIteratorAdapter(Set<Map.Entry<K, V>>)", "src/main/java/org/apache/commons/collections4/map/EntrySetToMapIteratorAdapter.java.EntrySetToMapIteratorAdapter.[Map.Entry<K, V>]current()", "src/main/java/org/apache/commons/collections4/map/EntrySetToMapIteratorAdapter.java.EntrySetToMapIteratorAdapter.[K]getKey()", "src/main/java/org/apache/commons/collections4/map/EntrySetToMapIteratorAdapter.java.EntrySetToMapIteratorAdapter.[V]getValue()", "src/main/java/org/apache/commons/collections4/map/EntrySetToMapIteratorAdapter.java.EntrySetToMapIteratorAdapter.[boolean]hasNext()", "src/main/java/org/apache/commons/collections4/map/EntrySetToMapIteratorAdapter.java.EntrySetToMapIteratorAdapter.[K]next()", "src/main/java/org/apache/commons/collections4/map/EntrySetToMapIteratorAdapter.java.EntrySetToMapIteratorAdapter.[void]remove()", "src/main/java/org/apache/commons/collections4/map/EntrySetToMapIteratorAdapter.java.EntrySetToMapIteratorAdapter.[void]reset()", "src/main/java/org/apache/commons/collections4/map/EntrySetToMapIteratorAdapter.java.EntrySetToMapIteratorAdapter.[V]setValue(V)"], "overrides": null, "attributes": [], "class_docstring": "\nAdapts a Map entrySet to the MapIterator interface.\n\n@param <K> the type of the keys in the map\n@param <V> the type of the values in the map\n\n@since 4.0\n", "original_string": "public class EntrySetToMapIteratorAdapter<K, V> implements MapIterator<K, V>, ResettableIterator<K> {\n\n    /** The adapted Map entry Set. */\n    final Set<Map.Entry<K, V>> entrySet;\n\n    /** The resettable iterator in use. */\n    transient Iterator<Map.Entry<K, V>> iterator;\n\n    /** The currently positioned Map entry. */\n    transient Map.Entry<K, V> entry;\n\n    /**\n     * Create a new EntrySetToMapIteratorAdapter.\n     * @param entrySet  the entrySet to adapt\n     */\n    public EntrySetToMapIteratorAdapter(final Set<Map.Entry<K, V>> entrySet) {\n        this.entrySet = entrySet;\n        reset();\n    }\n\n    /**\n     * Gets the currently active entry.\n     * @return Map.Entry&lt;K, V&gt;\n     */\n    protected synchronized Map.Entry<K, V> current() {\n        if (entry == null) {\n            throw new IllegalStateException();\n        }\n        return entry;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public K getKey() {\n        return current().getKey();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public V getValue() {\n        return current().getValue();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean hasNext() {\n        return iterator.hasNext();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public K next() {\n        entry = iterator.next();\n        return getKey();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void remove() {\n        iterator.remove();\n        entry = null;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public synchronized void reset() {\n        iterator = entrySet.iterator();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public V setValue(final V value) {\n        return current().setValue(value);\n    }\n}", "super_interfaces": ["MapIterator<K, V>", "ResettableIterator<K>"], "fields": [{"attribute_expression": "final Set<Map.Entry<K, V>> entrySet;", "docstring": " The adapted Map entry Set.", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Set<Map.Entry<K, V>>", "name": "entrySet", "syntax_pass": true}, {"attribute_expression": "transient Iterator<Map.Entry<K, V>> iterator;", "docstring": " The resettable iterator in use.", "modifiers": "transient", "marker_annotations": [], "non_marker_annotations": ["transient"], "comments": [], "type": "Iterator<Map.Entry<K, V>>", "name": "iterator", "syntax_pass": true}, {"attribute_expression": "transient Map.Entry<K, V> entry;", "docstring": " The currently positioned Map entry.", "modifiers": "transient", "marker_annotations": [], "non_marker_annotations": ["transient"], "comments": [], "type": "Map.Entry<K, V>", "name": "entry", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/map/UnmodifiableMap.java.UnmodifiableMap", "name": "UnmodifiableMap", "file_path": "src/main/java/org/apache/commons/collections4/map/UnmodifiableMap.java", "superclasses": "", "methods": ["[Map<K, V>]unmodifiableMap(Map<? extends K, ? extends V>)", "[]UnmodifiableMap(Map<? extends K, ? extends V>)", "[void]clear()", "[Set<Map.Entry<K, V>>]entrySet()", "[Set<K>]keySet()", "[MapIterator<K, V>]mapIterator()", "[V]put(K,V)", "[void]putAll(Map<? extends K, ? extends V>)", "[void]readObject(ObjectInputStream)", "[V]remove(Object)", "[Collection<V>]values()", "[void]writeObject(ObjectOutputStream)"], "method_uris": ["src/main/java/org/apache/commons/collections4/map/UnmodifiableMap.java.UnmodifiableMap.[Map<K, V>]unmodifiableMap(Map<? extends K, ? extends V>)", "src/main/java/org/apache/commons/collections4/map/UnmodifiableMap.java.UnmodifiableMap.[]UnmodifiableMap(Map<? extends K, ? extends V>)", "src/main/java/org/apache/commons/collections4/map/UnmodifiableMap.java.UnmodifiableMap.[void]clear()", "src/main/java/org/apache/commons/collections4/map/UnmodifiableMap.java.UnmodifiableMap.[Set<Map.Entry<K, V>>]entrySet()", "src/main/java/org/apache/commons/collections4/map/UnmodifiableMap.java.UnmodifiableMap.[Set<K>]keySet()", "src/main/java/org/apache/commons/collections4/map/UnmodifiableMap.java.UnmodifiableMap.[MapIterator<K, V>]mapIterator()", "src/main/java/org/apache/commons/collections4/map/UnmodifiableMap.java.UnmodifiableMap.[V]put(K,V)", "src/main/java/org/apache/commons/collections4/map/UnmodifiableMap.java.UnmodifiableMap.[void]putAll(Map<? extends K, ? extends V>)", "src/main/java/org/apache/commons/collections4/map/UnmodifiableMap.java.UnmodifiableMap.[void]readObject(ObjectInputStream)", "src/main/java/org/apache/commons/collections4/map/UnmodifiableMap.java.UnmodifiableMap.[V]remove(Object)", "src/main/java/org/apache/commons/collections4/map/UnmodifiableMap.java.UnmodifiableMap.[Collection<V>]values()", "src/main/java/org/apache/commons/collections4/map/UnmodifiableMap.java.UnmodifiableMap.[void]writeObject(ObjectOutputStream)"], "overrides": null, "attributes": [], "class_docstring": "\nDecorates another {@code Map} to ensure it can't be altered.\n<p>\nThis class is Serializable from Commons Collections 3.1.\n</p>\n<p>\nAttempts to modify it will result in an UnsupportedOperationException.\n</p>\n\n@param <K> the type of the keys in this map\n@param <V> the type of the values in this map\n@since 3.0\n", "original_string": "public final class UnmodifiableMap<K, V>\n        extends AbstractMapDecorator<K, V>\n        implements Unmodifiable, Serializable {\n\n    /** Serialization version */\n    private static final long serialVersionUID = 2737023427269031941L;\n\n    /**\n     * Factory method to create an unmodifiable map.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param map  the map to decorate, must not be null\n     * @return a new unmodifiable map\n     * @throws NullPointerException if map is null\n     * @since 4.0\n     */\n    public static <K, V> Map<K, V> unmodifiableMap(final Map<? extends K, ? extends V> map) {\n        if (map instanceof Unmodifiable) {\n            @SuppressWarnings(\"unchecked\") // safe to upcast\n            final Map<K, V> tmpMap = (Map<K, V>) map;\n            return tmpMap;\n        }\n        return new UnmodifiableMap<>(map);\n    }\n\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param map  the map to decorate, must not be null\n     * @throws NullPointerException if map is null\n     */\n    @SuppressWarnings(\"unchecked\") // safe to upcast\n    private UnmodifiableMap(final Map<? extends K, ? extends V> map) {\n        super((Map<K, V>) map);\n    }\n\n    @Override\n    public void clear() {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public Set<Map.Entry<K, V>> entrySet() {\n        final Set<Map.Entry<K, V>> set = super.entrySet();\n        return UnmodifiableEntrySet.unmodifiableEntrySet(set);\n    }\n\n    @Override\n    public Set<K> keySet() {\n        final Set<K> set = super.keySet();\n        return UnmodifiableSet.unmodifiableSet(set);\n    }\n\n    @Override\n    public MapIterator<K, V> mapIterator() {\n        if (map instanceof IterableMap) {\n            final MapIterator<K, V> it = ((IterableMap<K, V>) map).mapIterator();\n            return UnmodifiableMapIterator.unmodifiableMapIterator(it);\n        }\n        final MapIterator<K, V> it = new EntrySetMapIterator<>(map);\n        return UnmodifiableMapIterator.unmodifiableMapIterator(it);\n    }\n\n    @Override\n    public V put(final K key, final V value) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public void putAll(final Map<? extends K, ? extends V> mapToCopy) {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * Deserializes the map in using a custom routine.\n     *\n     * @param in  the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded\n     * @since 3.1\n     */\n    @SuppressWarnings(\"unchecked\")\n    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        map = (Map<K, V>) in.readObject();\n    }\n\n    @Override\n    public V remove(final Object key) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public Collection<V> values() {\n        final Collection<V> coll = super.values();\n        return UnmodifiableCollection.unmodifiableCollection(coll);\n    }\n\n    /**\n     * Serializes this object to an ObjectOutputStream.\n     *\n     * @param out the target ObjectOutputStream.\n     * @throws IOException thrown when an I/O errors occur writing to the target stream.\n     * @since 3.1\n     */\n    private void writeObject(final ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        out.writeObject(map);\n    }\n\n}", "super_interfaces": ["Unmodifiable", "Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 2737023427269031941L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 2737023427269031941L", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/map/TransformedSortedMap.java.TransformedSortedMap", "name": "TransformedSortedMap", "file_path": "src/main/java/org/apache/commons/collections4/map/TransformedSortedMap.java", "superclasses": "", "methods": ["[TransformedSortedMap<K, V>]transformedSortedMap(SortedMap<K, V>,Transformer<? super K, ? extends K>,Transformer<? super V, ? extends V>)", "[TransformedSortedMap<K, V>]transformingSortedMap(SortedMap<K, V>,Transformer<? super K, ? extends K>,Transformer<? super V, ? extends V>)", "[]TransformedSortedMap(SortedMap<K, V>,Transformer<? super K, ? extends K>,Transformer<? super V, ? extends V>)", "[Comparator<? super K>]comparator()", "[K]firstKey()", "[SortedMap<K, V>]getSortedMap()", "[SortedMap<K, V>]headMap(K)", "[K]lastKey()", "[SortedMap<K, V>]subMap(K,K)", "[SortedMap<K, V>]tailMap(K)"], "method_uris": ["src/main/java/org/apache/commons/collections4/map/TransformedSortedMap.java.TransformedSortedMap.[TransformedSortedMap<K, V>]transformedSortedMap(SortedMap<K, V>,Transformer<? super K, ? extends K>,Transformer<? super V, ? extends V>)", "src/main/java/org/apache/commons/collections4/map/TransformedSortedMap.java.TransformedSortedMap.[TransformedSortedMap<K, V>]transformingSortedMap(SortedMap<K, V>,Transformer<? super K, ? extends K>,Transformer<? super V, ? extends V>)", "src/main/java/org/apache/commons/collections4/map/TransformedSortedMap.java.TransformedSortedMap.[]TransformedSortedMap(SortedMap<K, V>,Transformer<? super K, ? extends K>,Transformer<? super V, ? extends V>)", "src/main/java/org/apache/commons/collections4/map/TransformedSortedMap.java.TransformedSortedMap.[Comparator<? super K>]comparator()", "src/main/java/org/apache/commons/collections4/map/TransformedSortedMap.java.TransformedSortedMap.[K]firstKey()", "src/main/java/org/apache/commons/collections4/map/TransformedSortedMap.java.TransformedSortedMap.[SortedMap<K, V>]getSortedMap()", "src/main/java/org/apache/commons/collections4/map/TransformedSortedMap.java.TransformedSortedMap.[SortedMap<K, V>]headMap(K)", "src/main/java/org/apache/commons/collections4/map/TransformedSortedMap.java.TransformedSortedMap.[K]lastKey()", "src/main/java/org/apache/commons/collections4/map/TransformedSortedMap.java.TransformedSortedMap.[SortedMap<K, V>]subMap(K,K)", "src/main/java/org/apache/commons/collections4/map/TransformedSortedMap.java.TransformedSortedMap.[SortedMap<K, V>]tailMap(K)"], "overrides": null, "attributes": [], "class_docstring": "\nDecorates another {@code SortedMap } to transform objects that are added.\n<p>\nThe Map put methods and Map.Entry setValue method are affected by this class.\nThus objects must be removed or searched for using their transformed form.\nFor example, if the transformation converts Strings to Integers, you must\nuse the Integer form to remove objects.\n</p>\n<p>\n<strong>Note that TransformedSortedMap is not synchronized and is not thread-safe.</strong>\nIf you wish to use this map from multiple threads concurrently, you must use\nappropriate synchronization. The simplest approach is to wrap this map\nusing {@link java.util.Collections#synchronizedSortedMap}. This class may throw\nexceptions when accessed by concurrent threads without synchronization.\n</p>\n<p>\nThis class is Serializable from Commons Collections 3.1.\n</p>\n\n@param <K> the type of the keys in this map\n@param <V> the type of the values in this map\n@since 3.0\n", "original_string": "public class TransformedSortedMap<K, V>\n        extends TransformedMap<K, V>\n        implements SortedMap<K, V> {\n\n    /** Serialization version */\n    private static final long serialVersionUID = -8751771676410385778L;\n\n    /**\n     * Factory method to create a transforming sorted map that will transform\n     * existing contents of the specified map.\n     * <p>\n     * If there are any elements already in the map being decorated, they\n     * will be transformed by this method.\n     * Contrast this with {@link #transformingSortedMap(SortedMap, Transformer, Transformer)}.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param map  the map to decorate, must not be null\n     * @param keyTransformer  the transformer to use for key conversion, null means no transformation\n     * @param valueTransformer  the transformer to use for value conversion, null means no transformation\n     * @return a new transformed sorted map\n     * @throws NullPointerException if map is null\n     * @since 4.0\n     */\n    public static <K, V> TransformedSortedMap<K, V> transformedSortedMap(final SortedMap<K, V> map,\n            final Transformer<? super K, ? extends K> keyTransformer,\n            final Transformer<? super V, ? extends V> valueTransformer) {\n\n        final TransformedSortedMap<K, V> decorated =\n                new TransformedSortedMap<>(map, keyTransformer, valueTransformer);\n        if (!map.isEmpty()) {\n            final Map<K, V> transformed = decorated.transformMap(map);\n            decorated.clear();\n            decorated.decorated().putAll(transformed);  // avoids double transformation\n        }\n        return decorated;\n    }\n\n    /**\n     * Factory method to create a transforming sorted map.\n     * <p>\n     * If there are any elements already in the map being decorated, they are NOT transformed.\n     * Contrast this with {@link #transformedSortedMap(SortedMap, Transformer, Transformer)}.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param map  the map to decorate, must not be null\n     * @param keyTransformer  the predicate to validate the keys, null means no transformation\n     * @param valueTransformer  the predicate to validate to values, null means no transformation\n     * @return a new transformed sorted map\n     * @throws NullPointerException if the map is null\n     * @since 4.0\n     */\n    public static <K, V> TransformedSortedMap<K, V> transformingSortedMap(final SortedMap<K, V> map,\n            final Transformer<? super K, ? extends K> keyTransformer,\n            final Transformer<? super V, ? extends V> valueTransformer) {\n        return new TransformedSortedMap<>(map, keyTransformer, valueTransformer);\n    }\n\n    /**\n     * Constructor that wraps (not copies).\n     * <p>\n     * If there are any elements already in the collection being decorated, they\n     * are NOT transformed.</p>\n     *\n     * @param map  the map to decorate, must not be null\n     * @param keyTransformer  the predicate to validate the keys, null means no transformation\n     * @param valueTransformer  the predicate to validate to values, null means no transformation\n     * @throws NullPointerException if the map is null\n     */\n    protected TransformedSortedMap(final SortedMap<K, V> map,\n            final Transformer<? super K, ? extends K> keyTransformer,\n            final Transformer<? super V, ? extends V> valueTransformer) {\n        super(map, keyTransformer, valueTransformer);\n    }\n\n    @Override\n    public Comparator<? super K> comparator() {\n        return getSortedMap().comparator();\n    }\n\n    @Override\n    public K firstKey() {\n        return getSortedMap().firstKey();\n    }\n\n    /**\n     * Gets the map being decorated.\n     *\n     * @return the decorated map\n     */\n    protected SortedMap<K, V> getSortedMap() {\n        return (SortedMap<K, V>) map;\n    }\n\n    @Override\n    public SortedMap<K, V> headMap(final K toKey) {\n        final SortedMap<K, V> map = getSortedMap().headMap(toKey);\n        return new TransformedSortedMap<>(map, keyTransformer, valueTransformer);\n    }\n\n    @Override\n    public K lastKey() {\n        return getSortedMap().lastKey();\n    }\n\n    @Override\n    public SortedMap<K, V> subMap(final K fromKey, final K toKey) {\n        final SortedMap<K, V> map = getSortedMap().subMap(fromKey, toKey);\n        return new TransformedSortedMap<>(map, keyTransformer, valueTransformer);\n    }\n\n    @Override\n    public SortedMap<K, V> tailMap(final K fromKey) {\n        final SortedMap<K, V> map = getSortedMap().tailMap(fromKey);\n        return new TransformedSortedMap<>(map, keyTransformer, valueTransformer);\n    }\n\n}", "super_interfaces": ["SortedMap<K, V>"], "fields": [{"attribute_expression": "private static final long serialVersionUID = -8751771676410385778L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -8751771676410385778L", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/map/PredicatedMap.java.PredicatedMap", "name": "PredicatedMap", "file_path": "src/main/java/org/apache/commons/collections4/map/PredicatedMap.java", "superclasses": "", "methods": ["[PredicatedMap<K, V>]predicatedMap(Map<K, V>,Predicate<? super K>,Predicate<? super V>)", "[]PredicatedMap(Map<K, V>,Predicate<? super K>,Predicate<? super V>)", "[V]checkSetValue(V)", "[boolean]isSetValueChecking()", "[V]put(K,V)", "[void]putAll(Map<? extends K, ? extends V>)", "[void]readObject(ObjectInputStream)", "[void]validate(K,V)", "[void]writeObject(ObjectOutputStream)"], "method_uris": ["src/main/java/org/apache/commons/collections4/map/PredicatedMap.java.PredicatedMap.[PredicatedMap<K, V>]predicatedMap(Map<K, V>,Predicate<? super K>,Predicate<? super V>)", "src/main/java/org/apache/commons/collections4/map/PredicatedMap.java.PredicatedMap.[]PredicatedMap(Map<K, V>,Predicate<? super K>,Predicate<? super V>)", "src/main/java/org/apache/commons/collections4/map/PredicatedMap.java.PredicatedMap.[V]checkSetValue(V)", "src/main/java/org/apache/commons/collections4/map/PredicatedMap.java.PredicatedMap.[boolean]isSetValueChecking()", "src/main/java/org/apache/commons/collections4/map/PredicatedMap.java.PredicatedMap.[V]put(K,V)", "src/main/java/org/apache/commons/collections4/map/PredicatedMap.java.PredicatedMap.[void]putAll(Map<? extends K, ? extends V>)", "src/main/java/org/apache/commons/collections4/map/PredicatedMap.java.PredicatedMap.[void]readObject(ObjectInputStream)", "src/main/java/org/apache/commons/collections4/map/PredicatedMap.java.PredicatedMap.[void]validate(K,V)", "src/main/java/org/apache/commons/collections4/map/PredicatedMap.java.PredicatedMap.[void]writeObject(ObjectOutputStream)"], "overrides": null, "attributes": [], "class_docstring": "\nDecorates another {@code Map} to validate that additions\nmatch a specified predicate.\n<p>\nThis map exists to provide validation for the decorated map.\nIt is normally created to decorate an empty map.\nIf an object cannot be added to the map, an IllegalArgumentException is thrown.\n</p>\n<p>\nOne usage would be to ensure that no null keys are added to the map.\n</p>\n<pre>Map map = PredicatedSet.decorate(new HashMap(), NotNullPredicate.INSTANCE, null);</pre>\n<p>\n<strong>Note that PredicatedMap is not synchronized and is not thread-safe.</strong>\nIf you wish to use this map from multiple threads concurrently, you must use\nappropriate synchronization. The simplest approach is to wrap this map\nusing {@link java.util.Collections#synchronizedMap(Map)}. This class may throw\nexceptions when accessed by concurrent threads without synchronization.\n</p>\n<p>\nThis class is Serializable from Commons Collections 3.1.\n</p>\n\n@param <K> the type of the keys in this map\n@param <V> the type of the values in this map\n@since 3.0\n", "original_string": "public class PredicatedMap<K, V>\n        extends AbstractInputCheckedMapDecorator<K, V>\n        implements Serializable {\n\n    /** Serialization version */\n    private static final long serialVersionUID = 7412622456128415156L;\n\n    /**\n     * Factory method to create a predicated (validating) map.\n     * <p>\n     * If there are any elements already in the list being decorated, they\n     * are validated.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param map  the map to decorate, must not be null\n     * @param keyPredicate  the predicate to validate the keys, null means no check\n     * @param valuePredicate  the predicate to validate to values, null means no check\n     * @return a new predicated map\n     * @throws NullPointerException if the map is null\n     * @since 4.0\n     */\n    public static <K, V> PredicatedMap<K, V> predicatedMap(final Map<K, V> map,\n                                                           final Predicate<? super K> keyPredicate,\n                                                           final Predicate<? super V> valuePredicate) {\n        return new PredicatedMap<>(map, keyPredicate, valuePredicate);\n    }\n\n    /** The key predicate to use */\n    protected final Predicate<? super K> keyPredicate;\n\n    /** The value predicate to use */\n    protected final Predicate<? super V> valuePredicate;\n\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param map  the map to decorate, must not be null\n     * @param keyPredicate  the predicate to validate the keys, null means no check\n     * @param valuePredicate  the predicate to validate to values, null means no check\n     * @throws NullPointerException if the map is null\n     */\n    protected PredicatedMap(final Map<K, V> map, final Predicate<? super K> keyPredicate,\n                            final Predicate<? super V> valuePredicate) {\n        super(map);\n        this.keyPredicate = keyPredicate;\n        this.valuePredicate = valuePredicate;\n        map.forEach(this::validate);\n    }\n\n    /**\n     * Override to validate an object set into the map via {@code setValue}.\n     *\n     * @param value  the value to validate\n     * @return the value itself\n     * @throws IllegalArgumentException if invalid\n     * @since 3.1\n     */\n    @Override\n    protected V checkSetValue(final V value) {\n        if (!valuePredicate.test(value)) {\n            throw new IllegalArgumentException(\"Cannot set value - Predicate rejected it\");\n        }\n        return value;\n    }\n\n    /**\n     * Override to only return true when there is a value transformer.\n     *\n     * @return true if a value predicate is in use\n     * @since 3.1\n     */\n    @Override\n    protected boolean isSetValueChecking() {\n        return valuePredicate != null;\n    }\n\n    @Override\n    public V put(final K key, final V value) {\n        validate(key, value);\n        return map.put(key, value);\n    }\n\n    @Override\n    public void putAll(final Map<? extends K, ? extends V> mapToCopy) {\n        for (final Map.Entry<? extends K, ? extends V> entry : mapToCopy.entrySet()) {\n            validate(entry.getKey(), entry.getValue());\n        }\n        super.putAll(mapToCopy);\n    }\n\n    /**\n     * Deserializes the map in using a custom routine.\n     *\n     * @param in  the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded\n     * @since 3.1\n     */\n    @SuppressWarnings(\"unchecked\") // (1) should only fail if input stream is incorrect\n    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        map = (Map<K, V>) in.readObject(); // (1)\n    }\n\n    /**\n     * Validates a key value pair.\n     *\n     * @param key  the key to validate\n     * @param value  the value to validate\n     * @throws IllegalArgumentException if invalid\n     */\n    protected void validate(final K key, final V value) {\n        if (keyPredicate != null && !keyPredicate.test(key)) {\n            throw new IllegalArgumentException(\"Cannot add key - Predicate rejected it\");\n        }\n        if (valuePredicate != null && !valuePredicate.test(value)) {\n            throw new IllegalArgumentException(\"Cannot add value - Predicate rejected it\");\n        }\n    }\n\n    /**\n     * Serializes this object to an ObjectOutputStream.\n     *\n     * @param out the target ObjectOutputStream.\n     * @throws IOException thrown when an I/O errors occur writing to the target stream.\n     * @since 3.1\n     */\n    private void writeObject(final ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        out.writeObject(map);\n    }\n\n}", "super_interfaces": ["Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 7412622456128415156L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 7412622456128415156L", "syntax_pass": true}, {"attribute_expression": "protected final Predicate<? super K> keyPredicate;", "docstring": " The key predicate to use", "modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "type": "Predicate<? super K>", "name": "keyPredicate", "syntax_pass": true}, {"attribute_expression": "protected final Predicate<? super V> valuePredicate;", "docstring": " The value predicate to use", "modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "type": "Predicate<? super V>", "name": "valuePredicate", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/map/ReferenceIdentityMap.java.ReferenceIdentityMap", "name": "ReferenceIdentityMap", "file_path": "src/main/java/org/apache/commons/collections4/map/ReferenceIdentityMap.java", "superclasses": "", "methods": ["[]ReferenceIdentityMap()", "[]ReferenceIdentityMap(ReferenceStrength,ReferenceStrength)", "[]ReferenceIdentityMap(ReferenceStrength,ReferenceStrength,boolean)", "[]ReferenceIdentityMap(ReferenceStrength,ReferenceStrength,int,float)", "[]ReferenceIdentityMap(ReferenceStrength,ReferenceStrength,int,float,boolean)", "[int]hash(Object)", "[int]hashEntry(Object,Object)", "[boolean]isEqualKey(Object,Object)", "[boolean]isEqualValue(Object,Object)", "[void]readObject(ObjectInputStream)", "[void]writeObject(ObjectOutputStream)"], "method_uris": ["src/main/java/org/apache/commons/collections4/map/ReferenceIdentityMap.java.ReferenceIdentityMap.[]ReferenceIdentityMap()", "src/main/java/org/apache/commons/collections4/map/ReferenceIdentityMap.java.ReferenceIdentityMap.[]ReferenceIdentityMap(ReferenceStrength,ReferenceStrength)", "src/main/java/org/apache/commons/collections4/map/ReferenceIdentityMap.java.ReferenceIdentityMap.[]ReferenceIdentityMap(ReferenceStrength,ReferenceStrength,boolean)", "src/main/java/org/apache/commons/collections4/map/ReferenceIdentityMap.java.ReferenceIdentityMap.[]ReferenceIdentityMap(ReferenceStrength,ReferenceStrength,int,float)", "src/main/java/org/apache/commons/collections4/map/ReferenceIdentityMap.java.ReferenceIdentityMap.[]ReferenceIdentityMap(ReferenceStrength,ReferenceStrength,int,float,boolean)", "src/main/java/org/apache/commons/collections4/map/ReferenceIdentityMap.java.ReferenceIdentityMap.[int]hash(Object)", "src/main/java/org/apache/commons/collections4/map/ReferenceIdentityMap.java.ReferenceIdentityMap.[int]hashEntry(Object,Object)", "src/main/java/org/apache/commons/collections4/map/ReferenceIdentityMap.java.ReferenceIdentityMap.[boolean]isEqualKey(Object,Object)", "src/main/java/org/apache/commons/collections4/map/ReferenceIdentityMap.java.ReferenceIdentityMap.[boolean]isEqualValue(Object,Object)", "src/main/java/org/apache/commons/collections4/map/ReferenceIdentityMap.java.ReferenceIdentityMap.[void]readObject(ObjectInputStream)", "src/main/java/org/apache/commons/collections4/map/ReferenceIdentityMap.java.ReferenceIdentityMap.[void]writeObject(ObjectOutputStream)"], "overrides": null, "attributes": [], "class_docstring": "\nA {@code Map} implementation that allows mappings to be\nremoved by the garbage collector and matches keys and values based\non {@code ==} not {@code equals()}.\n<p>\nWhen you construct a {@code ReferenceIdentityMap}, you can specify what kind\nof references are used to store the map's keys and values.\nIf non-hard references are used, then the garbage collector can remove\nmappings if a key or value becomes unreachable, or if the JVM's memory is\nrunning low. For information on how the different reference types behave,\nsee {@link Reference}.\n</p>\n<p>\nDifferent types of references can be specified for keys and values.\nThe default constructor uses hard keys and soft values, providing a\nmemory-sensitive cache.\n</p>\n<p>\nThis map is similar to\n{@link org.apache.commons.collections4.map.ReferenceMap ReferenceMap}.\nIt differs in that keys and values in this class are compared using {@code ==}.\n</p>\n<p>\nThis map will violate the detail of various Map and map view contracts.\nAs a general rule, don't compare this map to other maps.\n</p>\n<p>\nThis {@link java.util.Map Map} implementation does <em>not</em> allow null elements.\nAttempting to add a null key or value to the map will raise a {@code NullPointerException}.\n</p>\n<p>\nThis implementation is not synchronized.\nYou can use {@link java.util.Collections#synchronizedMap} to\nprovide synchronized access to a {@code ReferenceIdentityMap}.\nRemember that synchronization will not stop the garbage collector removing entries.\n</p>\n<p>\nAll the available iterators can be reset back to the start by casting to\n{@code ResettableIterator} and calling {@code reset()}.\n</p>\n<p>\n<strong>Note that ReferenceIdentityMap is not synchronized and is not thread-safe.</strong>\nIf you wish to use this map from multiple threads concurrently, you must use\nappropriate synchronization. The simplest approach is to wrap this map\nusing {@link java.util.Collections#synchronizedMap}. This class may throw\nexceptions when accessed by concurrent threads without synchronization.\n</p>\n\n@param <K> the type of the keys in this map\n@param <V> the type of the values in this map\n\n@see java.lang.ref.Reference\n@since 3.0 (previously in main package v2.1)\n", "original_string": "public class ReferenceIdentityMap<K, V> extends AbstractReferenceMap<K, V> implements Serializable {\n\n    /** Serialization version */\n    private static final long serialVersionUID = -1266190134568365852L;\n\n    /**\n     * Constructs a new {@code ReferenceIdentityMap} that will\n     * use hard references to keys and soft references to values.\n     */\n    public ReferenceIdentityMap() {\n        super(ReferenceStrength.HARD, ReferenceStrength.SOFT, DEFAULT_CAPACITY,\n                DEFAULT_LOAD_FACTOR, false);\n    }\n\n    /**\n     * Constructs a new {@code ReferenceIdentityMap} that will\n     * use the specified types of references.\n     *\n     * @param keyType  the type of reference to use for keys;\n     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\n     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\n     *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n     * @param valueType  the type of reference to use for values;\n     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\n     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\n     *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n     */\n    public ReferenceIdentityMap(final ReferenceStrength keyType, final ReferenceStrength valueType) {\n        super(keyType, valueType, DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR, false);\n    }\n\n    /**\n     * Constructs a new {@code ReferenceIdentityMap} that will\n     * use the specified types of references.\n     *\n     * @param keyType  the type of reference to use for keys;\n     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\n     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\n     *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n     * @param valueType  the type of reference to use for values;\n     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\n     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\n     *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n     * @param purgeValues should the value be automatically purged when the\n     *   key is garbage collected\n     */\n    public ReferenceIdentityMap(final ReferenceStrength keyType, final ReferenceStrength valueType,\n            final boolean purgeValues) {\n        super(keyType, valueType, DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR, purgeValues);\n    }\n\n    /**\n     * Constructs a new {@code ReferenceIdentityMap} with the\n     * specified reference types, load factor and initial capacity.\n     *\n     * @param keyType  the type of reference to use for keys;\n     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\n     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\n     *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n     * @param valueType  the type of reference to use for values;\n     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\n     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\n     *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n     * @param capacity  the initial capacity for the map\n     * @param loadFactor  the load factor for the map\n     */\n    public ReferenceIdentityMap(final ReferenceStrength keyType, final ReferenceStrength valueType,\n            final int capacity, final float loadFactor) {\n        super(keyType, valueType, capacity, loadFactor, false);\n    }\n\n    /**\n     * Constructs a new {@code ReferenceIdentityMap} with the\n     * specified reference types, load factor and initial capacity.\n     *\n     * @param keyType  the type of reference to use for keys;\n     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\n     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\n     *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n     * @param valueType  the type of reference to use for values;\n     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\n     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\n     *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n     * @param capacity  the initial capacity for the map\n     * @param loadFactor  the load factor for the map\n     * @param purgeValues  should the value be automatically purged when the\n     *   key is garbage collected\n     */\n    public ReferenceIdentityMap(final ReferenceStrength keyType, final ReferenceStrength valueType,\n            final int capacity, final float loadFactor, final boolean purgeValues) {\n        super(keyType, valueType, capacity, loadFactor, purgeValues);\n    }\n\n    /**\n     * Gets the hash code for the key specified.\n     * <p>\n     * This implementation uses the identity hash code.\n     *\n     * @param key  the key to get a hash code for\n     * @return the hash code\n     */\n    @Override\n    protected int hash(final Object key) {\n        return System.identityHashCode(key);\n    }\n\n    /**\n     * Gets the hash code for a MapEntry.\n     * <p>\n     * This implementation uses the identity hash code.\n     *\n     * @param key  the key to get a hash code for, may be null\n     * @param value  the value to get a hash code for, may be null\n     * @return the hash code, as per the MapEntry specification\n     */\n    @Override\n    protected int hashEntry(final Object key, final Object value) {\n        return System.identityHashCode(key) ^\n               System.identityHashCode(value);\n    }\n\n    /**\n     * Compares two keys for equals.\n     * <p>\n     * This implementation converts the key from the entry to a real reference\n     * before comparison and uses {@code ==}.\n     *\n     * @param key1  the first key to compare passed in from outside\n     * @param key2  the second key extracted from the entry via {@code entry.key}\n     * @return true if equal by identity\n     */\n    @Override\n    protected boolean isEqualKey(final Object key1, Object key2) {\n        key2 = isKeyType(ReferenceStrength.HARD) ? key2 : ((Reference<?>) key2).get();\n        return key1 == key2;\n    }\n\n    /**\n     * Compares two values for equals.\n     * <p>\n     * This implementation uses {@code ==}.\n     *\n     * @param value1  the first value to compare passed in from outside\n     * @param value2  the second value extracted from the entry via {@code getValue()}\n     * @return true if equal by identity\n     */\n    @Override\n    protected boolean isEqualValue(final Object value1, final Object value2) {\n        return value1 == value2;\n    }\n\n    /**\n     * Deserializes the map in using a custom routine.\n     *\n     * @param in the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded\n     */\n    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        doReadObject(in);\n    }\n\n    /**\n     * Serializes this object to an ObjectOutputStream.\n     *\n     * @param out the target ObjectOutputStream.\n     * @throws IOException thrown when an I/O errors occur writing to the target stream.\n     */\n    private void writeObject(final ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        doWriteObject(out);\n    }\n\n}", "super_interfaces": ["Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = -1266190134568365852L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -1266190134568365852L", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/map/LRUMap.java.LRUMap", "name": "LRUMap", "file_path": "src/main/java/org/apache/commons/collections4/map/LRUMap.java", "superclasses": "", "methods": ["[]LRUMap()", "[]LRUMap(int)", "[]LRUMap(int,boolean)", "[]LRUMap(int,float)", "[]LRUMap(int,float,boolean)", "[]LRUMap(int,int)", "[]LRUMap(int,int,float)", "[]LRUMap(int,int,float,boolean)", "[]LRUMap(Map<? extends K, ? extends V>)", "[]LRUMap(Map<? extends K, ? extends V>,boolean)", "[void]addMapping(int,int,K,V)", "[LRUMap<K, V>]clone()", "[void]doReadObject(ObjectInputStream)", "[void]doWriteObject(ObjectOutputStream)", "[V]get(Object)", "[V]get(Object,boolean)", "[boolean]isFull()", "[boolean]isScanUntilRemovable()", "[int]maxSize()", "[void]moveToMRU(LinkEntry<K, V>)", "[void]readObject(ObjectInputStream)", "[boolean]removeLRU(LinkEntry<K, V>)", "[void]reuseMapping(LinkEntry<K, V>,int,int,K,V)", "[void]updateEntry(HashEntry<K, V>,V)", "[void]writeObject(ObjectOutputStream)"], "method_uris": ["src/main/java/org/apache/commons/collections4/map/LRUMap.java.LRUMap.[]LRUMap()", "src/main/java/org/apache/commons/collections4/map/LRUMap.java.LRUMap.[]LRUMap(int)", "src/main/java/org/apache/commons/collections4/map/LRUMap.java.LRUMap.[]LRUMap(int,boolean)", "src/main/java/org/apache/commons/collections4/map/LRUMap.java.LRUMap.[]LRUMap(int,float)", "src/main/java/org/apache/commons/collections4/map/LRUMap.java.LRUMap.[]LRUMap(int,float,boolean)", "src/main/java/org/apache/commons/collections4/map/LRUMap.java.LRUMap.[]LRUMap(int,int)", "src/main/java/org/apache/commons/collections4/map/LRUMap.java.LRUMap.[]LRUMap(int,int,float)", "src/main/java/org/apache/commons/collections4/map/LRUMap.java.LRUMap.[]LRUMap(int,int,float,boolean)", "src/main/java/org/apache/commons/collections4/map/LRUMap.java.LRUMap.[]LRUMap(Map<? extends K, ? extends V>)", "src/main/java/org/apache/commons/collections4/map/LRUMap.java.LRUMap.[]LRUMap(Map<? extends K, ? extends V>,boolean)", "src/main/java/org/apache/commons/collections4/map/LRUMap.java.LRUMap.[void]addMapping(int,int,K,V)", "src/main/java/org/apache/commons/collections4/map/LRUMap.java.LRUMap.[LRUMap<K, V>]clone()", "src/main/java/org/apache/commons/collections4/map/LRUMap.java.LRUMap.[void]doReadObject(ObjectInputStream)", "src/main/java/org/apache/commons/collections4/map/LRUMap.java.LRUMap.[void]doWriteObject(ObjectOutputStream)", "src/main/java/org/apache/commons/collections4/map/LRUMap.java.LRUMap.[V]get(Object)", "src/main/java/org/apache/commons/collections4/map/LRUMap.java.LRUMap.[V]get(Object,boolean)", "src/main/java/org/apache/commons/collections4/map/LRUMap.java.LRUMap.[boolean]isFull()", "src/main/java/org/apache/commons/collections4/map/LRUMap.java.LRUMap.[boolean]isScanUntilRemovable()", "src/main/java/org/apache/commons/collections4/map/LRUMap.java.LRUMap.[int]maxSize()", "src/main/java/org/apache/commons/collections4/map/LRUMap.java.LRUMap.[void]moveToMRU(LinkEntry<K, V>)", "src/main/java/org/apache/commons/collections4/map/LRUMap.java.LRUMap.[void]readObject(ObjectInputStream)", "src/main/java/org/apache/commons/collections4/map/LRUMap.java.LRUMap.[boolean]removeLRU(LinkEntry<K, V>)", "src/main/java/org/apache/commons/collections4/map/LRUMap.java.LRUMap.[void]reuseMapping(LinkEntry<K, V>,int,int,K,V)", "src/main/java/org/apache/commons/collections4/map/LRUMap.java.LRUMap.[void]updateEntry(HashEntry<K, V>,V)", "src/main/java/org/apache/commons/collections4/map/LRUMap.java.LRUMap.[void]writeObject(ObjectOutputStream)"], "overrides": null, "attributes": [], "class_docstring": "\nA {@code Map} implementation with a fixed maximum size which removes\nthe least recently used entry if an entry is added when full.\n<p>\nThe least recently used algorithm works on the get and put operations only.\nIteration of any kind, including setting the value by iteration, does not\nchange the order. Queries such as containsKey and containsValue or access\nvia views also do not change the order.\n</p>\n<p>\nA somewhat subtle ramification of the least recently used\nalgorithm is that calls to {@link #get(Object)} stand a very good chance\nof modifying the map's iteration order and thus invalidating any\niterators currently in use.  It is therefore suggested that iterations\nover an {@link LRUMap} instance access entry values only through a\n{@link org.apache.commons.collections4.MapIterator MapIterator} or {@link #entrySet()} iterator.\n</p>\n<p>\nThe map implements {@code OrderedMap} and entries may be queried using\nthe bidirectional {@code OrderedMapIterator}. The order returned is\nleast recently used to most recently used. Iterators from map views can\nalso be cast to {@code OrderedIterator} if required.\n</p>\n<p>\nAll the available iterators can be reset back to the start by casting to\n{@code ResettableIterator} and calling {@code reset()}.\n</p>\n<p>\n<strong>Note that LRUMap is not synchronized and is not thread-safe.</strong>\nIf you wish to use this map from multiple threads concurrently, you must use\nappropriate synchronization. The simplest approach is to wrap this map\nusing {@link java.util.Collections#synchronizedMap(Map)}. This class may throw\n{@code NullPointerException}'s when accessed by concurrent threads.\n</p>\n\n@param <K> the type of the keys in this map\n@param <V> the type of the values in this map\n@since 3.0 (previously in main package v1.0)\n", "original_string": "public class LRUMap<K, V>\n        extends AbstractLinkedMap<K, V> implements BoundedMap<K, V>, Serializable, Cloneable {\n\n    /** Serialisation version */\n    private static final long serialVersionUID = -612114643488955218L;\n    /** Default maximum size */\n    protected static final int DEFAULT_MAX_SIZE = 100;\n\n    /** Maximum size */\n    private transient int maxSize;\n    /** Scan behavior */\n    private final boolean scanUntilRemovable;\n\n    /**\n     * Constructs a new empty map with a maximum size of 100.\n     */\n    public LRUMap() {\n        this(DEFAULT_MAX_SIZE, DEFAULT_LOAD_FACTOR, false);\n    }\n\n    /**\n     * Constructs a new, empty map with the specified maximum size.\n     *\n     * @param maxSize  the maximum size of the map\n     * @throws IllegalArgumentException if the maximum size is less than one\n     */\n    public LRUMap(final int maxSize) {\n        this(maxSize, DEFAULT_LOAD_FACTOR);\n    }\n\n    /**\n     * Constructs a new, empty map with the specified maximum size.\n     *\n     * @param maxSize  the maximum size of the map\n     * @param scanUntilRemovable  scan until a removable entry is found, default false\n     * @throws IllegalArgumentException if the maximum size is less than one\n     * @since 3.1\n     */\n    public LRUMap(final int maxSize, final boolean scanUntilRemovable) {\n        this(maxSize, DEFAULT_LOAD_FACTOR, scanUntilRemovable);\n    }\n\n    /**\n     * Constructs a new, empty map with the specified max capacity and\n     * load factor.\n     *\n     * @param maxSize  the maximum size of the map\n     * @param loadFactor  the load factor\n     * @throws IllegalArgumentException if the maximum size is less than one\n     * @throws IllegalArgumentException if the load factor is less than zero\n     */\n    public LRUMap(final int maxSize, final float loadFactor) {\n        this(maxSize, loadFactor, false);\n    }\n\n    /**\n     * Constructs a new, empty map with the specified max capacity and load factor.\n     *\n     * @param maxSize  the maximum size of the map\n     * @param loadFactor  the load factor\n     * @param scanUntilRemovable  scan until a removable entry is found, default false\n     * @throws IllegalArgumentException if the maximum size is less than one\n     * @throws IllegalArgumentException if the load factor is less than zero\n     * @since 3.1\n     */\n    public LRUMap(final int maxSize, final float loadFactor, final boolean scanUntilRemovable) {\n        this(maxSize, maxSize, loadFactor, scanUntilRemovable);\n    }\n\n    /**\n     * Constructs a new, empty map with the specified maximum size.\n     *\n     * @param maxSize  the maximum size of the map\n     * @param initialSize  the initial size of the map\n     * @throws IllegalArgumentException if the maximum size is less than one\n     * @throws IllegalArgumentException if the initial size is negative or larger than the maximum size\n     * @since 4.1\n     */\n    public LRUMap(final int maxSize, final int initialSize) {\n        this(maxSize, initialSize, DEFAULT_LOAD_FACTOR);\n    }\n\n    /**\n     * Constructs a new, empty map with the specified max / initial capacity and\n     * load factor.\n     *\n     * @param maxSize  the maximum size of the map\n     * @param initialSize  the initial size of the map\n     * @param loadFactor  the load factor\n     * @throws IllegalArgumentException if the maximum size is less than one\n     * @throws IllegalArgumentException if the initial size is negative or larger than the maximum size\n     * @throws IllegalArgumentException if the load factor is less than zero\n     * @since 4.1\n     */\n    public LRUMap(final int maxSize, final int initialSize, final float loadFactor) {\n        this(maxSize, initialSize, loadFactor, false);\n    }\n\n    /**\n     * Constructs a new, empty map with the specified max / initial capacity and load factor.\n     *\n     * @param maxSize  the maximum size of the map\n     * @param initialSize  the initial size of the map\n     * @param loadFactor  the load factor\n     * @param scanUntilRemovable  scan until a removable entry is found, default false\n     * @throws IllegalArgumentException if the maximum size is less than one\n     * @throws IllegalArgumentException if the initial size is negative or larger than the maximum size\n     * @throws IllegalArgumentException if the load factor is less than zero\n     * @since 4.1\n     */\n    public LRUMap(final int maxSize,\n                  final int initialSize,\n                  final float loadFactor,\n                  final boolean scanUntilRemovable) {\n\n        super(initialSize, loadFactor);\n        if (maxSize < 1) {\n            throw new IllegalArgumentException(\"LRUMap max size must be greater than 0\");\n        }\n        if (initialSize > maxSize) {\n            throw new IllegalArgumentException(\"LRUMap initial size must not be greater than max size\");\n        }\n        this.maxSize = maxSize;\n        this.scanUntilRemovable = scanUntilRemovable;\n    }\n\n    /**\n     * Constructor copying elements from another map.\n     * <p>\n     * The maximum size is set from the map's size.\n     *\n     * @param map  the map to copy\n     * @throws NullPointerException if the map is null\n     * @throws IllegalArgumentException if the map is empty\n     */\n    public LRUMap(final Map<? extends K, ? extends V> map) {\n        this(map, false);\n    }\n\n    /**\n     * Constructor copying elements from another map.\n     *\n     * <p>The maximum size is set from the map's size.</p>\n     *\n     * @param map  the map to copy\n     * @param scanUntilRemovable  scan until a removable entry is found, default false\n     * @throws NullPointerException if the map is null\n     * @throws IllegalArgumentException if the map is empty\n     * @since 3.1\n     */\n    public LRUMap(final Map<? extends K, ? extends V> map, final boolean scanUntilRemovable) {\n        this(map.size(), DEFAULT_LOAD_FACTOR, scanUntilRemovable);\n        putAll(map);\n    }\n\n    /**\n     * Adds a new key-value mapping into this map.\n     * <p>\n     * This implementation checks the LRU size and determines whether to\n     * discard an entry or not using {@link #removeLRU(AbstractLinkedMap.LinkEntry)}.\n     * <p>\n     * From Commons Collections 3.1 this method uses {@link #isFull()} rather\n     * than accessing {@code size} and {@code maxSize} directly.\n     * It also handles the scanUntilRemovable functionality.\n     *\n     * @param hashIndex  the index into the data array to store at\n     * @param hashCode  the hash code of the key to add\n     * @param key  the key to add\n     * @param value  the value to add\n     */\n    @Override\n    protected void addMapping(final int hashIndex, final int hashCode, final K key, final V value) {\n        if (isFull()) {\n            LinkEntry<K, V> reuse = header.after;\n            boolean removeLRUEntry = false;\n            if (scanUntilRemovable) {\n                while (reuse != header && reuse != null) {\n                    if (removeLRU(reuse)) {\n                        removeLRUEntry = true;\n                        break;\n                    }\n                    reuse = reuse.after;\n                }\n                if (reuse == null) {\n                    throw new IllegalStateException(\n                        \"Entry.after=null, header.after=\" + header.after + \" header.before=\" + header.before +\n                        \" key=\" + key + \" value=\" + value + \" size=\" + size + \" maxSize=\" + maxSize +\n                        \" This should not occur if your keys are immutable and you used synchronization properly.\");\n                }\n            } else {\n                removeLRUEntry = removeLRU(reuse);\n            }\n\n            if (removeLRUEntry) {\n                if (reuse == null) {\n                    throw new IllegalStateException(\n                        \"reuse=null, header.after=\" + header.after + \" header.before=\" + header.before +\n                        \" key=\" + key + \" value=\" + value + \" size=\" + size + \" maxSize=\" + maxSize +\n                        \" This should not occur if your keys are immutable and you used synchronization properly.\");\n                }\n                reuseMapping(reuse, hashIndex, hashCode, key, value);\n            } else {\n                super.addMapping(hashIndex, hashCode, key, value);\n            }\n        } else {\n            super.addMapping(hashIndex, hashCode, key, value);\n        }\n    }\n\n    /**\n     * Clones the map without cloning the keys or values.\n     *\n     * @return a shallow clone\n     */\n    @Override\n    public LRUMap<K, V> clone() {\n        return (LRUMap<K, V>) super.clone();\n    }\n\n    /**\n     * Reads the data necessary for {@code put()} to work in the superclass.\n     *\n     * @param in  the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded\n     */\n    @Override\n    protected void doReadObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n        maxSize = in.readInt();\n        super.doReadObject(in);\n    }\n\n    /**\n     * Writes the data necessary for {@code put()} to work in deserialization.\n     *\n     * @param out  the output stream\n     * @throws IOException if an error occurs while writing to the stream\n     */\n    @Override\n    protected void doWriteObject(final ObjectOutputStream out) throws IOException {\n        out.writeInt(maxSize);\n        super.doWriteObject(out);\n    }\n\n    /**\n     * Gets the value mapped to the key specified.\n     * <p>\n     * This operation changes the position of the key in the map to the\n     * most recently used position (last).\n     *\n     * @param key  the key\n     * @return the mapped value, null if no match\n     */\n    @Override\n    public V get(final Object key) {\n        return get(key, true);\n    }\n\n    /**\n     * Gets the value mapped to the key specified.\n     * <p>\n     * If {@code updateToMRU} is {@code true}, the position of the key in the map\n     * is changed to the most recently used position (last), otherwise the iteration\n     * order is not changed by this operation.\n     *\n     * @param key  the key\n     * @param updateToMRU  whether the key shall be updated to the\n     *   most recently used position\n     * @return the mapped value, null if no match\n     * @since 4.1\n     */\n    public V get(final Object key, final boolean updateToMRU) {\n        final LinkEntry<K, V> entry = getEntry(key);\n        if (entry == null) {\n            return null;\n        }\n        if (updateToMRU) {\n            moveToMRU(entry);\n        }\n        return entry.getValue();\n    }\n\n    /**\n     * Returns true if this map is full and no new mappings can be added.\n     *\n     * @return {@code true} if the map is full\n     */\n    @Override\n    public boolean isFull() {\n        return size >= maxSize;\n    }\n\n    /**\n     * Whether this LRUMap will scan until a removable entry is found when the\n     * map is full.\n     *\n     * @return true if this map scans\n     * @since 3.1\n     */\n    public boolean isScanUntilRemovable() {\n        return scanUntilRemovable;\n    }\n\n    /**\n     * Gets the maximum size of the map (the bound).\n     *\n     * @return the maximum number of elements the map can hold\n     */\n    @Override\n    public int maxSize() {\n        return maxSize;\n    }\n\n    /**\n     * Moves an entry to the MRU position at the end of the list.\n     * <p>\n     * This implementation moves the updated entry to the end of the list.\n     *\n     * @param entry  the entry to update\n     */\n    protected void moveToMRU(final LinkEntry<K, V> entry) {\n        if (entry.after != header) {\n            modCount++;\n            // remove\n            if (entry.before == null) {\n                throw new IllegalStateException(\"Entry.before is null.\" +\n                    \" This should not occur if your keys are immutable, and you have used synchronization properly.\");\n            }\n            entry.before.after = entry.after;\n            entry.after.before = entry.before;\n            // add first\n            entry.after = header;\n            entry.before = header.before;\n            header.before.after = entry;\n            header.before = entry;\n        } else if (entry == header) {\n            throw new IllegalStateException(\"Can't move header to MRU\" +\n                    \" This should not occur if your keys are immutable, and you have used synchronization properly.\");\n        }\n    }\n\n    /**\n     * Deserializes the map in using a custom routine.\n     *\n     * @param in the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded\n     */\n    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        doReadObject(in);\n    }\n\n    /**\n     * Subclass method to control removal of the least recently used entry from the map.\n     * <p>\n     * This method exists for subclasses to override. A subclass may wish to\n     * provide cleanup of resources when an entry is removed. For example:\n     * <pre>\n     * protected boolean removeLRU(LinkEntry entry) {\n     *   releaseResources(entry.getValue());  // release resources held by entry\n     *   return true;  // actually delete entry\n     * }\n     * </pre>\n     * <p>\n     * Alternatively, a subclass may choose to not remove the entry or selectively\n     * keep certain LRU entries. For example:\n     * <pre>\n     * protected boolean removeLRU(LinkEntry entry) {\n     *   if (entry.getKey().toString().startsWith(\"System.\")) {\n     *     return false;  // entry not removed from LRUMap\n     *   } else {\n     *     return true;  // actually delete entry\n     *   }\n     * }\n     * </pre>\n     * The effect of returning false is dependent on the scanUntilRemovable flag.\n     * If the flag is true, the next LRU entry will be passed to this method and so on\n     * until one returns false and is removed, or every entry in the map has been passed.\n     * If the scanUntilRemovable flag is false, the map will exceed the maximum size.\n     * <p>\n     * NOTE: Commons Collections 3.0 passed the wrong entry to this method.\n     * This is fixed in version 3.1 onwards.\n     *\n     * @param entry  the entry to be removed\n     * @return {@code true}\n     */\n    protected boolean removeLRU(final LinkEntry<K, V> entry) {\n        return true;\n    }\n\n    /**\n     * Reuses an entry by removing it and moving it to a new place in the map.\n     * <p>\n     * This method uses {@link #removeEntry}, {@link #reuseEntry} and {@link #addEntry}.\n     *\n     * @param entry  the entry to reuse\n     * @param hashIndex  the index into the data array to store at\n     * @param hashCode  the hash code of the key to add\n     * @param key  the key to add\n     * @param value  the value to add\n     */\n    protected void reuseMapping(final LinkEntry<K, V> entry, final int hashIndex, final int hashCode,\n                                final K key, final V value) {\n        // find the entry before the entry specified in the hash table\n        // remember that the parameters (except the first) refer to the new entry,\n        // not the old one\n        try {\n            final int removeIndex = hashIndex(entry.hashCode, data.length);\n            final HashEntry<K, V>[] tmp = data;  // may protect against some sync issues\n            HashEntry<K, V> loop = tmp[removeIndex];\n            HashEntry<K, V> previous = null;\n            while (loop != entry && loop != null) {\n                previous = loop;\n                loop = loop.next;\n            }\n            if (loop == null) {\n                throw new IllegalStateException(\n                    \"Entry.next=null, data[removeIndex]=\" + data[removeIndex] + \" previous=\" + previous +\n                    \" key=\" + key + \" value=\" + value + \" size=\" + size + \" maxSize=\" + maxSize +\n                    \" This should not occur if your keys are immutable, and you have used synchronization properly.\");\n            }\n\n            // reuse the entry\n            modCount++;\n            removeEntry(entry, removeIndex, previous);\n            reuseEntry(entry, hashIndex, hashCode, key, value);\n            addEntry(entry, hashIndex);\n        } catch (final NullPointerException ex) {\n            throw new IllegalStateException(\"NPE, entry=\" + entry + \" entryIsHeader=\" + (entry == header) + \" key=\" + key + \" value=\" + value + \" size=\" + size\n                    + \" maxSize=\" + maxSize + \" This should not occur if your keys are immutable, and you have used synchronization properly.\");\n        }\n    }\n\n    /**\n     * Updates an existing key-value mapping.\n     * <p>\n     * This implementation moves the updated entry to the end of the list\n     * using {@link #moveToMRU(AbstractLinkedMap.LinkEntry)}.\n     *\n     * @param entry  the entry to update\n     * @param newValue  the new value to store\n     */\n    @Override\n    protected void updateEntry(final HashEntry<K, V> entry, final V newValue) {\n        moveToMRU((LinkEntry<K, V>) entry);  // handles modCount\n        entry.setValue(newValue);\n    }\n\n    /**\n     * Serializes this object to an ObjectOutputStream.\n     *\n     * @param out the target ObjectOutputStream.\n     * @throws IOException thrown when an I/O errors occur writing to the target stream.\n     */\n    private void writeObject(final ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        doWriteObject(out);\n    }\n\n}", "super_interfaces": ["BoundedMap<K, V>", "Serializable", "Cloneable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = -612114643488955218L;", "docstring": " Serialisation version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -612114643488955218L", "syntax_pass": true}, {"attribute_expression": "protected static final int DEFAULT_MAX_SIZE = 100;", "docstring": " Default maximum size", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "int", "name": "DEFAULT_MAX_SIZE = 100", "syntax_pass": true}, {"attribute_expression": "private transient int maxSize;", "docstring": " Maximum size", "modifiers": "private transient", "marker_annotations": [], "non_marker_annotations": ["private", "transient"], "comments": [], "type": "int", "name": "maxSize", "syntax_pass": true}, {"attribute_expression": "private final boolean scanUntilRemovable;", "docstring": " Scan behavior", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "boolean", "name": "scanUntilRemovable", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/map/Flat3Map.java.Flat3Map", "name": "Flat3Map", "file_path": "src/main/java/org/apache/commons/collections4/map/Flat3Map.java", "superclasses": "", "methods": ["[]Flat3Map()", "[]Flat3Map(Map<? extends K, ? extends V>)", "[void]clear()", "[Flat3Map<K, V>]clone()", "[boolean]containsKey(Object)", "[boolean]containsValue(Object)", "[void]convertToMap()", "[AbstractHashedMap<K, V>]createDelegateMap()", "[Set<Map.Entry<K, V>>]entrySet()", "[boolean]equals(Object)", "[V]get(Object)", "[int]hashCode()", "[boolean]isEmpty()", "[Set<K>]keySet()", "[MapIterator<K, V>]mapIterator()", "[V]put(K,V)", "[void]putAll(Map<? extends K, ? extends V>)", "[void]readObject(ObjectInputStream)", "[V]remove(Object)", "[int]size()", "[String]toString()", "[Collection<V>]values()", "[void]writeObject(ObjectOutputStream)"], "method_uris": ["src/main/java/org/apache/commons/collections4/map/Flat3Map.java.Flat3Map.[]Flat3Map()", "src/main/java/org/apache/commons/collections4/map/Flat3Map.java.Flat3Map.[]Flat3Map(Map<? extends K, ? extends V>)", "src/main/java/org/apache/commons/collections4/map/Flat3Map.java.Flat3Map.[void]clear()", "src/main/java/org/apache/commons/collections4/map/Flat3Map.java.Flat3Map.[Flat3Map<K, V>]clone()", "src/main/java/org/apache/commons/collections4/map/Flat3Map.java.Flat3Map.[boolean]containsKey(Object)", "src/main/java/org/apache/commons/collections4/map/Flat3Map.java.Flat3Map.[boolean]containsValue(Object)", "src/main/java/org/apache/commons/collections4/map/Flat3Map.java.Flat3Map.[void]convertToMap()", "src/main/java/org/apache/commons/collections4/map/Flat3Map.java.Flat3Map.[AbstractHashedMap<K, V>]createDelegateMap()", "src/main/java/org/apache/commons/collections4/map/Flat3Map.java.Flat3Map.[Set<Map.Entry<K, V>>]entrySet()", "src/main/java/org/apache/commons/collections4/map/Flat3Map.java.Flat3Map.[boolean]equals(Object)", "src/main/java/org/apache/commons/collections4/map/Flat3Map.java.Flat3Map.[V]get(Object)", "src/main/java/org/apache/commons/collections4/map/Flat3Map.java.Flat3Map.[int]hashCode()", "src/main/java/org/apache/commons/collections4/map/Flat3Map.java.Flat3Map.[boolean]isEmpty()", "src/main/java/org/apache/commons/collections4/map/Flat3Map.java.Flat3Map.[Set<K>]keySet()", "src/main/java/org/apache/commons/collections4/map/Flat3Map.java.Flat3Map.[MapIterator<K, V>]mapIterator()", "src/main/java/org/apache/commons/collections4/map/Flat3Map.java.Flat3Map.[V]put(K,V)", "src/main/java/org/apache/commons/collections4/map/Flat3Map.java.Flat3Map.[void]putAll(Map<? extends K, ? extends V>)", "src/main/java/org/apache/commons/collections4/map/Flat3Map.java.Flat3Map.[void]readObject(ObjectInputStream)", "src/main/java/org/apache/commons/collections4/map/Flat3Map.java.Flat3Map.[V]remove(Object)", "src/main/java/org/apache/commons/collections4/map/Flat3Map.java.Flat3Map.[int]size()", "src/main/java/org/apache/commons/collections4/map/Flat3Map.java.Flat3Map.[String]toString()", "src/main/java/org/apache/commons/collections4/map/Flat3Map.java.Flat3Map.[Collection<V>]values()", "src/main/java/org/apache/commons/collections4/map/Flat3Map.java.Flat3Map.[void]writeObject(ObjectOutputStream)"], "overrides": null, "attributes": [{"original_string": "    abstract static class EntryIterator<K, V> {\n        private final Flat3Map<K, V> parent;\n        private int nextIndex;\n        private FlatMapEntry<K, V> currentEntry;\n\n        /**\n         * Create a new Flat3Map.EntryIterator.\n         */\n        EntryIterator(final Flat3Map<K, V> parent) {\n            this.parent = parent;\n        }\n\n        public boolean hasNext() {\n            return nextIndex < parent.size;\n        }\n\n        public Map.Entry<K, V> nextEntry() {\n            if (!hasNext()) {\n                throw new NoSuchElementException(AbstractHashedMap.NO_NEXT_ENTRY);\n            }\n            currentEntry = new FlatMapEntry<>(parent, ++nextIndex);\n            return currentEntry;\n        }\n\n        public void remove() {\n            if (currentEntry == null) {\n                throw new IllegalStateException(AbstractHashedMap.REMOVE_INVALID);\n            }\n            parent.remove(currentEntry.getKey());\n            currentEntry.setRemoved(true);\n            nextIndex--;\n            currentEntry = null;\n        }\n\n    }", "definition": "    abstract static class EntryIterator<K, V>", "class_docstring": "", "name": "EntryIterator", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "abstract static", "marker_annotations": [], "non_marker_annotations": ["abstract", "static"], "comments": [], "fields": [{"attribute_expression": "private final Flat3Map<K, V> parent;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Flat3Map<K, V>", "name": "parent", "syntax_pass": true}, {"attribute_expression": "private int nextIndex;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "nextIndex", "syntax_pass": true}, {"attribute_expression": "private FlatMapEntry<K, V> currentEntry;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "FlatMapEntry<K, V>", "name": "currentEntry", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        EntryIterator(final Flat3Map<K, V> parent) {\n            this.parent = parent;\n        }", "docstring": "\nCreate a new Flat3Map.EntryIterator.\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "EntryIterator", "params": [{"name": "parent", "type": "Flat3Map<K, V>"}], "body": "                                                   {\n            this.parent = parent;\n        }", "signature": "EntryIterator(final Flat3Map<K, V> parent)"}, {"syntax_pass": true, "original_string": "        public boolean hasNext() {\n            return nextIndex < parent.size;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasNext", "params": [], "body": "                                 {\n            return nextIndex < parent.size;\n        }", "signature": "public boolean hasNext()"}, {"syntax_pass": true, "original_string": "        public Map.Entry<K, V> nextEntry() {\n            if (!hasNext()) {\n                throw new NoSuchElementException(AbstractHashedMap.NO_NEXT_ENTRY);\n            }\n            currentEntry = new FlatMapEntry<>(parent, ++nextIndex);\n            return currentEntry;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map.Entry<K, V>", "classes": []}, "name": "nextEntry", "params": [], "body": "                                           {\n            if (!hasNext()) {\n                throw new NoSuchElementException(AbstractHashedMap.NO_NEXT_ENTRY);\n            }\n            currentEntry = new FlatMapEntry<>(parent, ++nextIndex);\n            return currentEntry;\n        }", "signature": "public Map.Entry<K, V> nextEntry()"}, {"syntax_pass": true, "original_string": "        public void remove() {\n            if (currentEntry == null) {\n                throw new IllegalStateException(AbstractHashedMap.REMOVE_INVALID);\n            }\n            parent.remove(currentEntry.getKey());\n            currentEntry.setRemoved(true);\n            nextIndex--;\n            currentEntry = null;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "remove", "params": [], "body": "                             {\n            if (currentEntry == null) {\n                throw new IllegalStateException(AbstractHashedMap.REMOVE_INVALID);\n            }\n            parent.remove(currentEntry.getKey());\n            currentEntry.setRemoved(true);\n            nextIndex--;\n            currentEntry = null;\n        }", "signature": "public void remove()"}]}, {"original_string": "    static class EntrySet<K, V> extends AbstractSet<Map.Entry<K, V>> {\n        private final Flat3Map<K, V> parent;\n\n        EntrySet(final Flat3Map<K, V> parent) {\n            this.parent = parent;\n        }\n\n        @Override\n        public void clear() {\n            parent.clear();\n        }\n\n        @Override\n        public Iterator<Map.Entry<K, V>> iterator() {\n            if (parent.delegateMap != null) {\n                return parent.delegateMap.entrySet().iterator();\n            }\n            if (parent.isEmpty()) {\n                return EmptyIterator.<Map.Entry<K, V>>emptyIterator();\n            }\n            return new EntrySetIterator<>(parent);\n        }\n\n        @Override\n        public boolean remove(final Object obj) {\n            if (!(obj instanceof Map.Entry)) {\n                return false;\n            }\n            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n            final Object key = entry.getKey();\n            final boolean result = parent.containsKey(key);\n            parent.remove(key);\n            return result;\n        }\n\n        @Override\n        public int size() {\n            return parent.size();\n        }\n    }", "definition": "    static class EntrySet<K, V> extends AbstractSet<Map.Entry<K, V>>", "class_docstring": "\nEntrySet\n", "name": "EntrySet", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "private final Flat3Map<K, V> parent;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Flat3Map<K, V>", "name": "parent", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        EntrySet(final Flat3Map<K, V> parent) {\n            this.parent = parent;\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "EntrySet", "params": [{"name": "parent", "type": "Flat3Map<K, V>"}], "body": "                                              {\n            this.parent = parent;\n        }", "signature": "EntrySet(final Flat3Map<K, V> parent)"}, {"syntax_pass": true, "original_string": "        @Override\n        public void clear() {\n            parent.clear();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "clear", "params": [], "body": "                            {\n            parent.clear();\n        }", "signature": "@Override\n        public void clear()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Iterator<Map.Entry<K, V>> iterator() {\n            if (parent.delegateMap != null) {\n                return parent.delegateMap.entrySet().iterator();\n            }\n            if (parent.isEmpty()) {\n                return EmptyIterator.<Map.Entry<K, V>>emptyIterator();\n            }\n            return new EntrySetIterator<>(parent);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Iterator<Map.Entry<K, V>>", "classes": []}, "name": "iterator", "params": [], "body": "                                                    {\n            if (parent.delegateMap != null) {\n                return parent.delegateMap.entrySet().iterator();\n            }\n            if (parent.isEmpty()) {\n                return EmptyIterator.<Map.Entry<K, V>>emptyIterator();\n            }\n            return new EntrySetIterator<>(parent);\n        }", "signature": "@Override\n        public Iterator<Map.Entry<K, V>> iterator()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean remove(final Object obj) {\n            if (!(obj instanceof Map.Entry)) {\n                return false;\n            }\n            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n            final Object key = entry.getKey();\n            final boolean result = parent.containsKey(key);\n            parent.remove(key);\n            return result;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "remove", "params": [{"name": "obj", "type": "Object"}], "body": "                                                {\n            if (!(obj instanceof Map.Entry)) {\n                return false;\n            }\n            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n            final Object key = entry.getKey();\n            final boolean result = parent.containsKey(key);\n            parent.remove(key);\n            return result;\n        }", "signature": "@Override\n        public boolean remove(final Object obj)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int size() {\n            return parent.size();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "size", "params": [], "body": "                          {\n            return parent.size();\n        }", "signature": "@Override\n        public int size()"}]}, {"original_string": "    static class EntrySetIterator<K, V> extends EntryIterator<K, V> implements Iterator<Map.Entry<K, V>> {\n        EntrySetIterator(final Flat3Map<K, V> parent) {\n            super(parent);\n        }\n\n        @Override\n        public Map.Entry<K, V> next() {\n            return nextEntry();\n        }\n    }", "definition": "    static class EntrySetIterator<K, V> extends EntryIterator<K, V> implements Iterator<Map.Entry<K, V>>", "class_docstring": "\nEntrySetIterator and MapEntry\n", "name": "EntrySetIterator", "super_interfaces": ["Iterator<Map.Entry<K, V>>"], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        EntrySetIterator(final Flat3Map<K, V> parent) {\n            super(parent);\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "EntrySetIterator", "params": [{"name": "parent", "type": "Flat3Map<K, V>"}], "body": "                                                      {\n            super(parent);\n        }", "signature": "EntrySetIterator(final Flat3Map<K, V> parent)"}, {"syntax_pass": true, "original_string": "        @Override\n        public Map.Entry<K, V> next() {\n            return nextEntry();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map.Entry<K, V>", "classes": []}, "name": "next", "params": [], "body": "                                      {\n            return nextEntry();\n        }", "signature": "@Override\n        public Map.Entry<K, V> next()"}]}, {"original_string": "    static class FlatMapEntry<K, V> implements Map.Entry<K, V> {\n        private final Flat3Map<K, V> parent;\n        private final int index;\n        private volatile boolean removed;\n\n        FlatMapEntry(final Flat3Map<K, V> parent, final int index) {\n            this.parent = parent;\n            this.index = index;\n            this.removed = false;\n        }\n\n        @Override\n        public boolean equals(final Object obj) {\n            if (removed) {\n                return false;\n            }\n            if (!(obj instanceof Map.Entry)) {\n                return false;\n            }\n            final Map.Entry<?, ?> other = (Map.Entry<?, ?>) obj;\n            final Object key = getKey();\n            final Object value = getValue();\n            return (key == null ? other.getKey() == null : key.equals(other.getKey())) &&\n                   (value == null ? other.getValue() == null : value.equals(other.getValue()));\n        }\n\n        @Override\n        public K getKey() {\n            if (removed) {\n                throw new IllegalStateException(AbstractHashedMap.GETKEY_INVALID);\n            }\n            switch (index) {\n            case 3:\n                return parent.key3;\n            case 2:\n                return parent.key2;\n            case 1:\n                return parent.key1;\n            }\n            throw new IllegalStateException(\"Invalid map index: \" + index);\n        }\n\n        @Override\n        public V getValue() {\n            if (removed) {\n                throw new IllegalStateException(AbstractHashedMap.GETVALUE_INVALID);\n            }\n            switch (index) {\n            case 3:\n                return parent.value3;\n            case 2:\n                return parent.value2;\n            case 1:\n                return parent.value1;\n            }\n            throw new IllegalStateException(\"Invalid map index: \" + index);\n        }\n\n        @Override\n        public int hashCode() {\n            if (removed) {\n                return 0;\n            }\n            final Object key = getKey();\n            final Object value = getValue();\n            return (key == null ? 0 : key.hashCode()) ^\n                   (value == null ? 0 : value.hashCode());\n        }\n\n        /**\n         * Used by the iterator that created this entry to indicate that\n         * {@link java.util.Iterator#remove()} has been called.\n         * <p>\n         * As a consequence, all subsequent call to {@link #getKey()},\n         * {@link #setValue(Object)} and {@link #getValue()} will fail.\n         *\n         * @param removed the new value of the removed flag\n         */\n        void setRemoved(final boolean removed) {\n            this.removed = removed;\n        }\n\n        @Override\n        public V setValue(final V value) {\n            if (removed) {\n                throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);\n            }\n            final V old = getValue();\n            switch (index) {\n            case 3:\n                parent.value3 = value;\n                break;\n            case 2:\n                parent.value2 = value;\n                break;\n            case 1:\n                parent.value1 = value;\n                break;\n            default:\n                throw new IllegalStateException(\"Invalid map index: \" + index);\n            }\n            return old;\n        }\n\n        @Override\n        public String toString() {\n            if (!removed) {\n                return getKey() + \"=\" + getValue();\n            }\n            return \"\";\n        }\n\n    }", "definition": "    static class FlatMapEntry<K, V> implements Map.Entry<K, V>", "class_docstring": "", "name": "FlatMapEntry", "super_interfaces": ["Map.Entry<K, V>"], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "private final Flat3Map<K, V> parent;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Flat3Map<K, V>", "name": "parent", "syntax_pass": true}, {"attribute_expression": "private final int index;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "index", "syntax_pass": true}, {"attribute_expression": "private volatile boolean removed;", "docstring": "", "modifiers": "private volatile", "marker_annotations": [], "non_marker_annotations": ["private", "volatile"], "comments": [], "type": "boolean", "name": "removed", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        FlatMapEntry(final Flat3Map<K, V> parent, final int index) {\n            this.parent = parent;\n            this.index = index;\n            this.removed = false;\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "FlatMapEntry", "params": [{"name": "parent", "type": "Flat3Map<K, V>"}, {"name": "index", "type": "int"}], "body": "                                                                   {\n            this.parent = parent;\n            this.index = index;\n            this.removed = false;\n        }", "signature": "FlatMapEntry(final Flat3Map<K, V> parent, final int index)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean equals(final Object obj) {\n            if (removed) {\n                return false;\n            }\n            if (!(obj instanceof Map.Entry)) {\n                return false;\n            }\n            final Map.Entry<?, ?> other = (Map.Entry<?, ?>) obj;\n            final Object key = getKey();\n            final Object value = getValue();\n            return (key == null ? other.getKey() == null : key.equals(other.getKey())) &&\n                   (value == null ? other.getValue() == null : value.equals(other.getValue()));\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "obj", "type": "Object"}], "body": "                                                {\n            if (removed) {\n                return false;\n            }\n            if (!(obj instanceof Map.Entry)) {\n                return false;\n            }\n            final Map.Entry<?, ?> other = (Map.Entry<?, ?>) obj;\n            final Object key = getKey();\n            final Object value = getValue();\n            return (key == null ? other.getKey() == null : key.equals(other.getKey())) &&\n                   (value == null ? other.getValue() == null : value.equals(other.getValue()));\n        }", "signature": "@Override\n        public boolean equals(final Object obj)"}, {"syntax_pass": true, "original_string": "        @Override\n        public K getKey() {\n            if (removed) {\n                throw new IllegalStateException(AbstractHashedMap.GETKEY_INVALID);\n            }\n            switch (index) {\n            case 3:\n                return parent.key3;\n            case 2:\n                return parent.key2;\n            case 1:\n                return parent.key1;\n            }\n            throw new IllegalStateException(\"Invalid map index: \" + index);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "K", "classes": []}, "name": "getKey", "params": [], "body": "                          {\n            if (removed) {\n                throw new IllegalStateException(AbstractHashedMap.GETKEY_INVALID);\n            }\n            switch (index) {\n            case 3:\n                return parent.key3;\n            case 2:\n                return parent.key2;\n            case 1:\n                return parent.key1;\n            }\n            throw new IllegalStateException(\"Invalid map index: \" + index);\n        }", "signature": "@Override\n        public K getKey()"}, {"syntax_pass": true, "original_string": "        @Override\n        public V getValue() {\n            if (removed) {\n                throw new IllegalStateException(AbstractHashedMap.GETVALUE_INVALID);\n            }\n            switch (index) {\n            case 3:\n                return parent.value3;\n            case 2:\n                return parent.value2;\n            case 1:\n                return parent.value1;\n            }\n            throw new IllegalStateException(\"Invalid map index: \" + index);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "getValue", "params": [], "body": "                            {\n            if (removed) {\n                throw new IllegalStateException(AbstractHashedMap.GETVALUE_INVALID);\n            }\n            switch (index) {\n            case 3:\n                return parent.value3;\n            case 2:\n                return parent.value2;\n            case 1:\n                return parent.value1;\n            }\n            throw new IllegalStateException(\"Invalid map index: \" + index);\n        }", "signature": "@Override\n        public V getValue()"}, {"syntax_pass": true, "original_string": "        @Override\n        public int hashCode() {\n            if (removed) {\n                return 0;\n            }\n            final Object key = getKey();\n            final Object value = getValue();\n            return (key == null ? 0 : key.hashCode()) ^\n                   (value == null ? 0 : value.hashCode());\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                              {\n            if (removed) {\n                return 0;\n            }\n            final Object key = getKey();\n            final Object value = getValue();\n            return (key == null ? 0 : key.hashCode()) ^\n                   (value == null ? 0 : value.hashCode());\n        }", "signature": "@Override\n        public int hashCode()"}, {"syntax_pass": true, "original_string": "        void setRemoved(final boolean removed) {\n            this.removed = removed;\n        }", "docstring": "\nUsed by the iterator that created this entry to indicate that\n{@link java.util.Iterator#remove()} has been called.\n<p>\nAs a consequence, all subsequent call to {@link #getKey()},\n{@link #setValue(Object)} and {@link #getValue()} will fail.\n\n@param removed the new value of the removed flag\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "setRemoved", "params": [{"name": "removed", "type": "boolean"}], "body": "                                               {\n            this.removed = removed;\n        }", "signature": "void setRemoved(final boolean removed)"}, {"syntax_pass": true, "original_string": "        @Override\n        public V setValue(final V value) {\n            if (removed) {\n                throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);\n            }\n            final V old = getValue();\n            switch (index) {\n            case 3:\n                parent.value3 = value;\n                break;\n            case 2:\n                parent.value2 = value;\n                break;\n            case 1:\n                parent.value1 = value;\n                break;\n            default:\n                throw new IllegalStateException(\"Invalid map index: \" + index);\n            }\n            return old;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "setValue", "params": [{"name": "value", "type": "V"}], "body": "                                         {\n            if (removed) {\n                throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);\n            }\n            final V old = getValue();\n            switch (index) {\n            case 3:\n                parent.value3 = value;\n                break;\n            case 2:\n                parent.value2 = value;\n                break;\n            case 1:\n                parent.value1 = value;\n                break;\n            default:\n                throw new IllegalStateException(\"Invalid map index: \" + index);\n            }\n            return old;\n        }", "signature": "@Override\n        public V setValue(final V value)"}, {"syntax_pass": true, "original_string": "        @Override\n        public String toString() {\n            if (!removed) {\n                return getKey() + \"=\" + getValue();\n            }\n            return \"\";\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                 {\n            if (!removed) {\n                return getKey() + \"=\" + getValue();\n            }\n            return \"\";\n        }", "signature": "@Override\n        public String toString()"}]}, {"original_string": "    static class FlatMapIterator<K, V> implements MapIterator<K, V>, ResettableIterator<K> {\n        private final Flat3Map<K, V> parent;\n        private int nextIndex;\n        private boolean canRemove;\n\n        FlatMapIterator(final Flat3Map<K, V> parent) {\n            this.parent = parent;\n        }\n\n        @Override\n        public K getKey() {\n            if (!canRemove) {\n                throw new IllegalStateException(AbstractHashedMap.GETKEY_INVALID);\n            }\n            switch (nextIndex) {\n            case 3:\n                return parent.key3;\n            case 2:\n                return parent.key2;\n            case 1:\n                return parent.key1;\n            }\n            throw new IllegalStateException(\"Invalid map index: \" + nextIndex);\n        }\n\n        @Override\n        public V getValue() {\n            if (!canRemove) {\n                throw new IllegalStateException(AbstractHashedMap.GETVALUE_INVALID);\n            }\n            switch (nextIndex) {\n            case 3:\n                return parent.value3;\n            case 2:\n                return parent.value2;\n            case 1:\n                return parent.value1;\n            }\n            throw new IllegalStateException(\"Invalid map index: \" + nextIndex);\n        }\n\n        @Override\n        public boolean hasNext() {\n            return nextIndex < parent.size;\n        }\n\n        @Override\n        public K next() {\n            if (!hasNext()) {\n                throw new NoSuchElementException(AbstractHashedMap.NO_NEXT_ENTRY);\n            }\n            canRemove = true;\n            nextIndex++;\n            return getKey();\n        }\n\n        @Override\n        public void remove() {\n            if (!canRemove) {\n                throw new IllegalStateException(AbstractHashedMap.REMOVE_INVALID);\n            }\n            parent.remove(getKey());\n            nextIndex--;\n            canRemove = false;\n        }\n\n        @Override\n        public void reset() {\n            nextIndex = 0;\n            canRemove = false;\n        }\n\n        @Override\n        public V setValue(final V value) {\n            if (!canRemove) {\n                throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);\n            }\n            final V old = getValue();\n            switch (nextIndex) {\n            case 3:\n                parent.value3 = value;\n                break;\n            case 2:\n                parent.value2 = value;\n                break;\n            case 1:\n                parent.value1 = value;\n                break;\n            default:\n                throw new IllegalStateException(\"Invalid map index: \" + nextIndex);\n            }\n            return old;\n        }\n\n        @Override\n        public String toString() {\n            if (canRemove) {\n                return \"Iterator[\" + getKey() + \"=\" + getValue() + \"]\";\n            }\n            return \"Iterator[]\";\n        }\n    }", "definition": "    static class FlatMapIterator<K, V> implements MapIterator<K, V>, ResettableIterator<K>", "class_docstring": "\nFlatMapIterator\n", "name": "FlatMapIterator", "super_interfaces": ["MapIterator<K, V>", "ResettableIterator<K>"], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "private final Flat3Map<K, V> parent;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Flat3Map<K, V>", "name": "parent", "syntax_pass": true}, {"attribute_expression": "private int nextIndex;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "nextIndex", "syntax_pass": true}, {"attribute_expression": "private boolean canRemove;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "canRemove", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        FlatMapIterator(final Flat3Map<K, V> parent) {\n            this.parent = parent;\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "FlatMapIterator", "params": [{"name": "parent", "type": "Flat3Map<K, V>"}], "body": "                                                     {\n            this.parent = parent;\n        }", "signature": "FlatMapIterator(final Flat3Map<K, V> parent)"}, {"syntax_pass": true, "original_string": "        @Override\n        public K getKey() {\n            if (!canRemove) {\n                throw new IllegalStateException(AbstractHashedMap.GETKEY_INVALID);\n            }\n            switch (nextIndex) {\n            case 3:\n                return parent.key3;\n            case 2:\n                return parent.key2;\n            case 1:\n                return parent.key1;\n            }\n            throw new IllegalStateException(\"Invalid map index: \" + nextIndex);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "K", "classes": []}, "name": "getKey", "params": [], "body": "                          {\n            if (!canRemove) {\n                throw new IllegalStateException(AbstractHashedMap.GETKEY_INVALID);\n            }\n            switch (nextIndex) {\n            case 3:\n                return parent.key3;\n            case 2:\n                return parent.key2;\n            case 1:\n                return parent.key1;\n            }\n            throw new IllegalStateException(\"Invalid map index: \" + nextIndex);\n        }", "signature": "@Override\n        public K getKey()"}, {"syntax_pass": true, "original_string": "        @Override\n        public V getValue() {\n            if (!canRemove) {\n                throw new IllegalStateException(AbstractHashedMap.GETVALUE_INVALID);\n            }\n            switch (nextIndex) {\n            case 3:\n                return parent.value3;\n            case 2:\n                return parent.value2;\n            case 1:\n                return parent.value1;\n            }\n            throw new IllegalStateException(\"Invalid map index: \" + nextIndex);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "getValue", "params": [], "body": "                            {\n            if (!canRemove) {\n                throw new IllegalStateException(AbstractHashedMap.GETVALUE_INVALID);\n            }\n            switch (nextIndex) {\n            case 3:\n                return parent.value3;\n            case 2:\n                return parent.value2;\n            case 1:\n                return parent.value1;\n            }\n            throw new IllegalStateException(\"Invalid map index: \" + nextIndex);\n        }", "signature": "@Override\n        public V getValue()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean hasNext() {\n            return nextIndex < parent.size;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasNext", "params": [], "body": "                                 {\n            return nextIndex < parent.size;\n        }", "signature": "@Override\n        public boolean hasNext()"}, {"syntax_pass": true, "original_string": "        @Override\n        public K next() {\n            if (!hasNext()) {\n                throw new NoSuchElementException(AbstractHashedMap.NO_NEXT_ENTRY);\n            }\n            canRemove = true;\n            nextIndex++;\n            return getKey();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "K", "classes": []}, "name": "next", "params": [], "body": "                        {\n            if (!hasNext()) {\n                throw new NoSuchElementException(AbstractHashedMap.NO_NEXT_ENTRY);\n            }\n            canRemove = true;\n            nextIndex++;\n            return getKey();\n        }", "signature": "@Override\n        public K next()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void remove() {\n            if (!canRemove) {\n                throw new IllegalStateException(AbstractHashedMap.REMOVE_INVALID);\n            }\n            parent.remove(getKey());\n            nextIndex--;\n            canRemove = false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "remove", "params": [], "body": "                             {\n            if (!canRemove) {\n                throw new IllegalStateException(AbstractHashedMap.REMOVE_INVALID);\n            }\n            parent.remove(getKey());\n            nextIndex--;\n            canRemove = false;\n        }", "signature": "@Override\n        public void remove()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void reset() {\n            nextIndex = 0;\n            canRemove = false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "reset", "params": [], "body": "                            {\n            nextIndex = 0;\n            canRemove = false;\n        }", "signature": "@Override\n        public void reset()"}, {"syntax_pass": true, "original_string": "        @Override\n        public V setValue(final V value) {\n            if (!canRemove) {\n                throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);\n            }\n            final V old = getValue();\n            switch (nextIndex) {\n            case 3:\n                parent.value3 = value;\n                break;\n            case 2:\n                parent.value2 = value;\n                break;\n            case 1:\n                parent.value1 = value;\n                break;\n            default:\n                throw new IllegalStateException(\"Invalid map index: \" + nextIndex);\n            }\n            return old;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "setValue", "params": [{"name": "value", "type": "V"}], "body": "                                         {\n            if (!canRemove) {\n                throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);\n            }\n            final V old = getValue();\n            switch (nextIndex) {\n            case 3:\n                parent.value3 = value;\n                break;\n            case 2:\n                parent.value2 = value;\n                break;\n            case 1:\n                parent.value1 = value;\n                break;\n            default:\n                throw new IllegalStateException(\"Invalid map index: \" + nextIndex);\n            }\n            return old;\n        }", "signature": "@Override\n        public V setValue(final V value)"}, {"syntax_pass": true, "original_string": "        @Override\n        public String toString() {\n            if (canRemove) {\n                return \"Iterator[\" + getKey() + \"=\" + getValue() + \"]\";\n            }\n            return \"Iterator[]\";\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                 {\n            if (canRemove) {\n                return \"Iterator[\" + getKey() + \"=\" + getValue() + \"]\";\n            }\n            return \"Iterator[]\";\n        }", "signature": "@Override\n        public String toString()"}]}, {"original_string": "    static class KeySet<K> extends AbstractSet<K> {\n        private final Flat3Map<K, ?> parent;\n\n        KeySet(final Flat3Map<K, ?> parent) {\n            this.parent = parent;\n        }\n\n        @Override\n        public void clear() {\n            parent.clear();\n        }\n\n        @Override\n        public boolean contains(final Object key) {\n            return parent.containsKey(key);\n        }\n\n        @Override\n        public Iterator<K> iterator() {\n            if (parent.delegateMap != null) {\n                return parent.delegateMap.keySet().iterator();\n            }\n            if (parent.isEmpty()) {\n                return EmptyIterator.<K>emptyIterator();\n            }\n            return new KeySetIterator<>(parent);\n        }\n\n        @Override\n        public boolean remove(final Object key) {\n            final boolean result = parent.containsKey(key);\n            parent.remove(key);\n            return result;\n        }\n\n        @Override\n        public int size() {\n            return parent.size();\n        }\n    }", "definition": "    static class KeySet<K> extends AbstractSet<K>", "class_docstring": "\nKeySet\n", "name": "KeySet", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "private final Flat3Map<K, ?> parent;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Flat3Map<K, ?>", "name": "parent", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        KeySet(final Flat3Map<K, ?> parent) {\n            this.parent = parent;\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "KeySet", "params": [{"name": "parent", "type": "Flat3Map<K, ?>"}], "body": "                                            {\n            this.parent = parent;\n        }", "signature": "KeySet(final Flat3Map<K, ?> parent)"}, {"syntax_pass": true, "original_string": "        @Override\n        public void clear() {\n            parent.clear();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "clear", "params": [], "body": "                            {\n            parent.clear();\n        }", "signature": "@Override\n        public void clear()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean contains(final Object key) {\n            return parent.containsKey(key);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "contains", "params": [{"name": "key", "type": "Object"}], "body": "                                                  {\n            return parent.containsKey(key);\n        }", "signature": "@Override\n        public boolean contains(final Object key)"}, {"syntax_pass": true, "original_string": "        @Override\n        public Iterator<K> iterator() {\n            if (parent.delegateMap != null) {\n                return parent.delegateMap.keySet().iterator();\n            }\n            if (parent.isEmpty()) {\n                return EmptyIterator.<K>emptyIterator();\n            }\n            return new KeySetIterator<>(parent);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Iterator<K>", "classes": []}, "name": "iterator", "params": [], "body": "                                      {\n            if (parent.delegateMap != null) {\n                return parent.delegateMap.keySet().iterator();\n            }\n            if (parent.isEmpty()) {\n                return EmptyIterator.<K>emptyIterator();\n            }\n            return new KeySetIterator<>(parent);\n        }", "signature": "@Override\n        public Iterator<K> iterator()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean remove(final Object key) {\n            final boolean result = parent.containsKey(key);\n            parent.remove(key);\n            return result;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "remove", "params": [{"name": "key", "type": "Object"}], "body": "                                                {\n            final boolean result = parent.containsKey(key);\n            parent.remove(key);\n            return result;\n        }", "signature": "@Override\n        public boolean remove(final Object key)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int size() {\n            return parent.size();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "size", "params": [], "body": "                          {\n            return parent.size();\n        }", "signature": "@Override\n        public int size()"}]}, {"original_string": "    static class KeySetIterator<K> extends EntryIterator<K, Object> implements Iterator<K> {\n\n        @SuppressWarnings(\"unchecked\")\n        KeySetIterator(final Flat3Map<K, ?> parent) {\n            super((Flat3Map<K, Object>) parent);\n        }\n\n        @Override\n        public K next() {\n            return nextEntry().getKey();\n        }\n    }", "definition": "    static class KeySetIterator<K> extends EntryIterator<K, Object> implements Iterator<K>", "class_docstring": "\nKeySetIterator\n", "name": "KeySetIterator", "super_interfaces": ["Iterator<K>"], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @SuppressWarnings(\"unchecked\")\n        KeySetIterator(final Flat3Map<K, ?> parent) {\n            super((Flat3Map<K, Object>) parent);\n        }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")"], "comments": [], "return_type": "", "classes": []}, "name": "KeySetIterator", "params": [{"name": "parent", "type": "Flat3Map<K, ?>"}], "body": "                                                    {\n            super((Flat3Map<K, Object>) parent);\n        }", "signature": "@SuppressWarnings(\"unchecked\")\n        KeySetIterator(final Flat3Map<K, ?> parent)"}, {"syntax_pass": true, "original_string": "        @Override\n        public K next() {\n            return nextEntry().getKey();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "K", "classes": []}, "name": "next", "params": [], "body": "                        {\n            return nextEntry().getKey();\n        }", "signature": "@Override\n        public K next()"}]}, {"original_string": "    static class Values<V> extends AbstractCollection<V> {\n        private final Flat3Map<?, V> parent;\n\n        Values(final Flat3Map<?, V> parent) {\n            this.parent = parent;\n        }\n\n        @Override\n        public void clear() {\n            parent.clear();\n        }\n\n        @Override\n        public boolean contains(final Object value) {\n            return parent.containsValue(value);\n        }\n\n        @Override\n        public Iterator<V> iterator() {\n            if (parent.delegateMap != null) {\n                return parent.delegateMap.values().iterator();\n            }\n            if (parent.isEmpty()) {\n                return EmptyIterator.<V>emptyIterator();\n            }\n            return new ValuesIterator<>(parent);\n        }\n\n        @Override\n        public int size() {\n            return parent.size();\n        }\n    }", "definition": "    static class Values<V> extends AbstractCollection<V>", "class_docstring": "\nValues\n", "name": "Values", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "private final Flat3Map<?, V> parent;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Flat3Map<?, V>", "name": "parent", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        Values(final Flat3Map<?, V> parent) {\n            this.parent = parent;\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Values", "params": [{"name": "parent", "type": "Flat3Map<?, V>"}], "body": "                                            {\n            this.parent = parent;\n        }", "signature": "Values(final Flat3Map<?, V> parent)"}, {"syntax_pass": true, "original_string": "        @Override\n        public void clear() {\n            parent.clear();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "clear", "params": [], "body": "                            {\n            parent.clear();\n        }", "signature": "@Override\n        public void clear()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean contains(final Object value) {\n            return parent.containsValue(value);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "contains", "params": [{"name": "value", "type": "Object"}], "body": "                                                    {\n            return parent.containsValue(value);\n        }", "signature": "@Override\n        public boolean contains(final Object value)"}, {"syntax_pass": true, "original_string": "        @Override\n        public Iterator<V> iterator() {\n            if (parent.delegateMap != null) {\n                return parent.delegateMap.values().iterator();\n            }\n            if (parent.isEmpty()) {\n                return EmptyIterator.<V>emptyIterator();\n            }\n            return new ValuesIterator<>(parent);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Iterator<V>", "classes": []}, "name": "iterator", "params": [], "body": "                                      {\n            if (parent.delegateMap != null) {\n                return parent.delegateMap.values().iterator();\n            }\n            if (parent.isEmpty()) {\n                return EmptyIterator.<V>emptyIterator();\n            }\n            return new ValuesIterator<>(parent);\n        }", "signature": "@Override\n        public Iterator<V> iterator()"}, {"syntax_pass": true, "original_string": "        @Override\n        public int size() {\n            return parent.size();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "size", "params": [], "body": "                          {\n            return parent.size();\n        }", "signature": "@Override\n        public int size()"}]}, {"original_string": "    static class ValuesIterator<V> extends EntryIterator<Object, V> implements Iterator<V> {\n\n        @SuppressWarnings(\"unchecked\")\n        ValuesIterator(final Flat3Map<?, V> parent) {\n            super((Flat3Map<Object, V>) parent);\n        }\n\n        @Override\n        public V next() {\n            return nextEntry().getValue();\n        }\n    }", "definition": "    static class ValuesIterator<V> extends EntryIterator<Object, V> implements Iterator<V>", "class_docstring": "\nValuesIterator\n", "name": "ValuesIterator", "super_interfaces": ["Iterator<V>"], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @SuppressWarnings(\"unchecked\")\n        ValuesIterator(final Flat3Map<?, V> parent) {\n            super((Flat3Map<Object, V>) parent);\n        }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")"], "comments": [], "return_type": "", "classes": []}, "name": "ValuesIterator", "params": [{"name": "parent", "type": "Flat3Map<?, V>"}], "body": "                                                    {\n            super((Flat3Map<Object, V>) parent);\n        }", "signature": "@SuppressWarnings(\"unchecked\")\n        ValuesIterator(final Flat3Map<?, V> parent)"}, {"syntax_pass": true, "original_string": "        @Override\n        public V next() {\n            return nextEntry().getValue();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "next", "params": [], "body": "                        {\n            return nextEntry().getValue();\n        }", "signature": "@Override\n        public V next()"}]}], "class_docstring": "\nA {@code Map} implementation that stores data in simple fields until\nthe size is greater than 3.\n<p>\nThis map is designed for performance and can outstrip HashMap.\nIt also has good garbage collection characteristics.\n</p>\n<ul>\n<li>Optimised for operation at size 3 or less.\n<li>Still works well once size 3 exceeded.\n<li>Gets at size 3 or less are about 0-10% faster than HashMap,\n<li>Puts at size 3 or less are over 4 times faster than HashMap.\n<li>Performance 5% slower than HashMap once size 3 exceeded once.\n</ul>\n<p>\nThe design uses two distinct modes of operation - flat and delegate.\nWhile the map is size 3 or less, operations map straight onto fields using\nswitch statements. Once size 4 is reached, the map switches to delegate mode\nand only switches back when cleared. In delegate mode, all operations are\nforwarded straight to a HashMap resulting in the 5% performance loss.\n</p>\n<p>\nThe performance gains on puts are due to not needing to create a Map Entry\nobject. This is a large saving not only in performance but in garbage collection.\n</p>\n<p>\nWhilst in flat mode this map is also easy for the garbage collector to dispatch.\nThis is because it contains no complex objects or arrays which slow the progress.\n</p>\n<p>\nDo not use {@code Flat3Map} if the size is likely to grow beyond 3.\n</p>\n<p>\n<strong>Note that Flat3Map is not synchronized and is not thread-safe.</strong>\nIf you wish to use this map from multiple threads concurrently, you must use\nappropriate synchronization. The simplest approach is to wrap this map\nusing {@link java.util.Collections#synchronizedMap(Map)}. This class may throw\nexceptions when accessed by concurrent threads without synchronization.\n</p>\n\n@param <K> the type of the keys in this map\n@param <V> the type of the values in this map\n@since 3.0\n", "original_string": "public class Flat3Map<K, V> implements IterableMap<K, V>, Serializable, Cloneable {\n\n    abstract static class EntryIterator<K, V> {\n        private final Flat3Map<K, V> parent;\n        private int nextIndex;\n        private FlatMapEntry<K, V> currentEntry;\n\n        /**\n         * Create a new Flat3Map.EntryIterator.\n         */\n        EntryIterator(final Flat3Map<K, V> parent) {\n            this.parent = parent;\n        }\n\n        public boolean hasNext() {\n            return nextIndex < parent.size;\n        }\n\n        public Map.Entry<K, V> nextEntry() {\n            if (!hasNext()) {\n                throw new NoSuchElementException(AbstractHashedMap.NO_NEXT_ENTRY);\n            }\n            currentEntry = new FlatMapEntry<>(parent, ++nextIndex);\n            return currentEntry;\n        }\n\n        public void remove() {\n            if (currentEntry == null) {\n                throw new IllegalStateException(AbstractHashedMap.REMOVE_INVALID);\n            }\n            parent.remove(currentEntry.getKey());\n            currentEntry.setRemoved(true);\n            nextIndex--;\n            currentEntry = null;\n        }\n\n    }\n\n    /**\n     * EntrySet\n     */\n    static class EntrySet<K, V> extends AbstractSet<Map.Entry<K, V>> {\n        private final Flat3Map<K, V> parent;\n\n        EntrySet(final Flat3Map<K, V> parent) {\n            this.parent = parent;\n        }\n\n        @Override\n        public void clear() {\n            parent.clear();\n        }\n\n        @Override\n        public Iterator<Map.Entry<K, V>> iterator() {\n            if (parent.delegateMap != null) {\n                return parent.delegateMap.entrySet().iterator();\n            }\n            if (parent.isEmpty()) {\n                return EmptyIterator.<Map.Entry<K, V>>emptyIterator();\n            }\n            return new EntrySetIterator<>(parent);\n        }\n\n        @Override\n        public boolean remove(final Object obj) {\n            if (!(obj instanceof Map.Entry)) {\n                return false;\n            }\n            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n            final Object key = entry.getKey();\n            final boolean result = parent.containsKey(key);\n            parent.remove(key);\n            return result;\n        }\n\n        @Override\n        public int size() {\n            return parent.size();\n        }\n    }\n    /**\n     * EntrySetIterator and MapEntry\n     */\n    static class EntrySetIterator<K, V> extends EntryIterator<K, V> implements Iterator<Map.Entry<K, V>> {\n        EntrySetIterator(final Flat3Map<K, V> parent) {\n            super(parent);\n        }\n\n        @Override\n        public Map.Entry<K, V> next() {\n            return nextEntry();\n        }\n    }\n    static class FlatMapEntry<K, V> implements Map.Entry<K, V> {\n        private final Flat3Map<K, V> parent;\n        private final int index;\n        private volatile boolean removed;\n\n        FlatMapEntry(final Flat3Map<K, V> parent, final int index) {\n            this.parent = parent;\n            this.index = index;\n            this.removed = false;\n        }\n\n        @Override\n        public boolean equals(final Object obj) {\n            if (removed) {\n                return false;\n            }\n            if (!(obj instanceof Map.Entry)) {\n                return false;\n            }\n            final Map.Entry<?, ?> other = (Map.Entry<?, ?>) obj;\n            final Object key = getKey();\n            final Object value = getValue();\n            return (key == null ? other.getKey() == null : key.equals(other.getKey())) &&\n                   (value == null ? other.getValue() == null : value.equals(other.getValue()));\n        }\n\n        @Override\n        public K getKey() {\n            if (removed) {\n                throw new IllegalStateException(AbstractHashedMap.GETKEY_INVALID);\n            }\n            switch (index) {\n            case 3:\n                return parent.key3;\n            case 2:\n                return parent.key2;\n            case 1:\n                return parent.key1;\n            }\n            throw new IllegalStateException(\"Invalid map index: \" + index);\n        }\n\n        @Override\n        public V getValue() {\n            if (removed) {\n                throw new IllegalStateException(AbstractHashedMap.GETVALUE_INVALID);\n            }\n            switch (index) {\n            case 3:\n                return parent.value3;\n            case 2:\n                return parent.value2;\n            case 1:\n                return parent.value1;\n            }\n            throw new IllegalStateException(\"Invalid map index: \" + index);\n        }\n\n        @Override\n        public int hashCode() {\n            if (removed) {\n                return 0;\n            }\n            final Object key = getKey();\n            final Object value = getValue();\n            return (key == null ? 0 : key.hashCode()) ^\n                   (value == null ? 0 : value.hashCode());\n        }\n\n        /**\n         * Used by the iterator that created this entry to indicate that\n         * {@link java.util.Iterator#remove()} has been called.\n         * <p>\n         * As a consequence, all subsequent call to {@link #getKey()},\n         * {@link #setValue(Object)} and {@link #getValue()} will fail.\n         *\n         * @param removed the new value of the removed flag\n         */\n        void setRemoved(final boolean removed) {\n            this.removed = removed;\n        }\n\n        @Override\n        public V setValue(final V value) {\n            if (removed) {\n                throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);\n            }\n            final V old = getValue();\n            switch (index) {\n            case 3:\n                parent.value3 = value;\n                break;\n            case 2:\n                parent.value2 = value;\n                break;\n            case 1:\n                parent.value1 = value;\n                break;\n            default:\n                throw new IllegalStateException(\"Invalid map index: \" + index);\n            }\n            return old;\n        }\n\n        @Override\n        public String toString() {\n            if (!removed) {\n                return getKey() + \"=\" + getValue();\n            }\n            return \"\";\n        }\n\n    }\n    /**\n     * FlatMapIterator\n     */\n    static class FlatMapIterator<K, V> implements MapIterator<K, V>, ResettableIterator<K> {\n        private final Flat3Map<K, V> parent;\n        private int nextIndex;\n        private boolean canRemove;\n\n        FlatMapIterator(final Flat3Map<K, V> parent) {\n            this.parent = parent;\n        }\n\n        @Override\n        public K getKey() {\n            if (!canRemove) {\n                throw new IllegalStateException(AbstractHashedMap.GETKEY_INVALID);\n            }\n            switch (nextIndex) {\n            case 3:\n                return parent.key3;\n            case 2:\n                return parent.key2;\n            case 1:\n                return parent.key1;\n            }\n            throw new IllegalStateException(\"Invalid map index: \" + nextIndex);\n        }\n\n        @Override\n        public V getValue() {\n            if (!canRemove) {\n                throw new IllegalStateException(AbstractHashedMap.GETVALUE_INVALID);\n            }\n            switch (nextIndex) {\n            case 3:\n                return parent.value3;\n            case 2:\n                return parent.value2;\n            case 1:\n                return parent.value1;\n            }\n            throw new IllegalStateException(\"Invalid map index: \" + nextIndex);\n        }\n\n        @Override\n        public boolean hasNext() {\n            return nextIndex < parent.size;\n        }\n\n        @Override\n        public K next() {\n            if (!hasNext()) {\n                throw new NoSuchElementException(AbstractHashedMap.NO_NEXT_ENTRY);\n            }\n            canRemove = true;\n            nextIndex++;\n            return getKey();\n        }\n\n        @Override\n        public void remove() {\n            if (!canRemove) {\n                throw new IllegalStateException(AbstractHashedMap.REMOVE_INVALID);\n            }\n            parent.remove(getKey());\n            nextIndex--;\n            canRemove = false;\n        }\n\n        @Override\n        public void reset() {\n            nextIndex = 0;\n            canRemove = false;\n        }\n\n        @Override\n        public V setValue(final V value) {\n            if (!canRemove) {\n                throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);\n            }\n            final V old = getValue();\n            switch (nextIndex) {\n            case 3:\n                parent.value3 = value;\n                break;\n            case 2:\n                parent.value2 = value;\n                break;\n            case 1:\n                parent.value1 = value;\n                break;\n            default:\n                throw new IllegalStateException(\"Invalid map index: \" + nextIndex);\n            }\n            return old;\n        }\n\n        @Override\n        public String toString() {\n            if (canRemove) {\n                return \"Iterator[\" + getKey() + \"=\" + getValue() + \"]\";\n            }\n            return \"Iterator[]\";\n        }\n    }\n    /**\n     * KeySet\n     */\n    static class KeySet<K> extends AbstractSet<K> {\n        private final Flat3Map<K, ?> parent;\n\n        KeySet(final Flat3Map<K, ?> parent) {\n            this.parent = parent;\n        }\n\n        @Override\n        public void clear() {\n            parent.clear();\n        }\n\n        @Override\n        public boolean contains(final Object key) {\n            return parent.containsKey(key);\n        }\n\n        @Override\n        public Iterator<K> iterator() {\n            if (parent.delegateMap != null) {\n                return parent.delegateMap.keySet().iterator();\n            }\n            if (parent.isEmpty()) {\n                return EmptyIterator.<K>emptyIterator();\n            }\n            return new KeySetIterator<>(parent);\n        }\n\n        @Override\n        public boolean remove(final Object key) {\n            final boolean result = parent.containsKey(key);\n            parent.remove(key);\n            return result;\n        }\n\n        @Override\n        public int size() {\n            return parent.size();\n        }\n    }\n    /**\n     * KeySetIterator\n     */\n    static class KeySetIterator<K> extends EntryIterator<K, Object> implements Iterator<K> {\n\n        @SuppressWarnings(\"unchecked\")\n        KeySetIterator(final Flat3Map<K, ?> parent) {\n            super((Flat3Map<K, Object>) parent);\n        }\n\n        @Override\n        public K next() {\n            return nextEntry().getKey();\n        }\n    }\n    /**\n     * Values\n     */\n    static class Values<V> extends AbstractCollection<V> {\n        private final Flat3Map<?, V> parent;\n\n        Values(final Flat3Map<?, V> parent) {\n            this.parent = parent;\n        }\n\n        @Override\n        public void clear() {\n            parent.clear();\n        }\n\n        @Override\n        public boolean contains(final Object value) {\n            return parent.containsValue(value);\n        }\n\n        @Override\n        public Iterator<V> iterator() {\n            if (parent.delegateMap != null) {\n                return parent.delegateMap.values().iterator();\n            }\n            if (parent.isEmpty()) {\n                return EmptyIterator.<V>emptyIterator();\n            }\n            return new ValuesIterator<>(parent);\n        }\n\n        @Override\n        public int size() {\n            return parent.size();\n        }\n    }\n    /**\n     * ValuesIterator\n     */\n    static class ValuesIterator<V> extends EntryIterator<Object, V> implements Iterator<V> {\n\n        @SuppressWarnings(\"unchecked\")\n        ValuesIterator(final Flat3Map<?, V> parent) {\n            super((Flat3Map<Object, V>) parent);\n        }\n\n        @Override\n        public V next() {\n            return nextEntry().getValue();\n        }\n    }\n    /** Serialization version */\n    private static final long serialVersionUID = -6701087419741928296L;\n    /** The size of the map, used while in flat mode */\n    private transient int size;\n    /** Hash, used while in flat mode */\n    private transient int hash1;\n\n    /** Hash, used while in flat mode */\n    private transient int hash2;\n\n    /** Hash, used while in flat mode */\n    private transient int hash3;\n\n    /** Key, used while in flat mode */\n    private transient K key1;\n\n    /** Key, used while in flat mode */\n    private transient K key2;\n\n    /** Key, used while in flat mode */\n    private transient K key3;\n\n    /** Value, used while in flat mode */\n    private transient V value1;\n\n    /** Value, used while in flat mode */\n    private transient V value2;\n\n    /** Value, used while in flat mode */\n    private transient V value3;\n\n    /** Map, used while in delegate mode */\n    private transient AbstractHashedMap<K, V> delegateMap;\n\n    /**\n     * Constructs a new instance.\n     */\n    public Flat3Map() {\n    }\n\n    /**\n     * Constructor copying elements from another map.\n     *\n     * @param map  the map to copy\n     * @throws NullPointerException if the map is null\n     */\n    public Flat3Map(final Map<? extends K, ? extends V> map) {\n        putAll(map);\n    }\n\n    /**\n     * Clears the map, resetting the size to zero and nullifying references\n     * to avoid garbage collection issues.\n     */\n    @Override\n    public void clear() {\n        if (delegateMap != null) {\n            delegateMap.clear();  // should aid gc\n            delegateMap = null;  // switch back to flat mode\n        } else {\n            size = 0;\n            hash1 = hash2 = hash3 = 0;\n            key1 = key2 = key3 = null;\n            value1 = value2 = value3 = null;\n        }\n    }\n\n    /**\n     * Clones the map without cloning the keys or values.\n     *\n     * @return a shallow clone\n     * @since 3.1\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public Flat3Map<K, V> clone() {\n        try {\n            final Flat3Map<K, V> cloned = (Flat3Map<K, V>) super.clone();\n            if (cloned.delegateMap != null) {\n                cloned.delegateMap = cloned.delegateMap.clone();\n            }\n            return cloned;\n        } catch (final CloneNotSupportedException ex) {\n            throw new UnsupportedOperationException(ex);\n        }\n    }\n\n    /**\n     * Checks whether the map contains the specified key.\n     *\n     * @param key  the key to search for\n     * @return true if the map contains the key\n     */\n    @Override\n    public boolean containsKey(final Object key) {\n        if (delegateMap != null) {\n            return delegateMap.containsKey(key);\n        }\n        if (key == null) {\n            switch (size) {  // drop through\n            case 3:\n                if (key3 == null) {\n                    return true;\n                }\n            case 2:\n                if (key2 == null) {\n                    return true;\n                }\n            case 1:\n                if (key1 == null) {\n                    return true;\n                }\n            }\n        } else if (size > 0) {\n            final int hashCode = key.hashCode();\n            switch (size) {  // drop through\n            case 3:\n                if (hash3 == hashCode && key.equals(key3)) {\n                    return true;\n                }\n            case 2:\n                if (hash2 == hashCode && key.equals(key2)) {\n                    return true;\n                }\n            case 1:\n                if (hash1 == hashCode && key.equals(key1)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Checks whether the map contains the specified value.\n     *\n     * @param value  the value to search for\n     * @return true if the map contains the key\n     */\n    @Override\n    public boolean containsValue(final Object value) {\n        if (delegateMap != null) {\n            return delegateMap.containsValue(value);\n        }\n        if (value == null) {  // drop through\n            switch (size) {\n            case 3:\n                if (value3 == null) {\n                    return true;\n                }\n            case 2:\n                if (value2 == null) {\n                    return true;\n                }\n            case 1:\n                if (value1 == null) {\n                    return true;\n                }\n            }\n        } else {\n            switch (size) {  // drop through\n            case 3:\n                if (value.equals(value3)) {\n                    return true;\n                }\n            case 2:\n                if (value.equals(value2)) {\n                    return true;\n                }\n            case 1:\n                if (value.equals(value1)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Converts the flat map data to a map.\n     */\n    private void convertToMap() {\n        delegateMap = createDelegateMap();\n        switch (size) {  // drop through\n        case 3:\n            delegateMap.put(key3, value3);\n        case 2:\n            delegateMap.put(key2, value2);\n        case 1:\n            delegateMap.put(key1, value1);\n        case 0:\n            break;\n        default:\n            throw new IllegalStateException(\"Invalid map index: \" + size);\n        }\n\n        size = 0;\n        hash1 = hash2 = hash3 = 0;\n        key1 = key2 = key3 = null;\n        value1 = value2 = value3 = null;\n    }\n\n    /**\n     * Create an instance of the map used for storage when in delegation mode.\n     * <p>\n     * This can be overridden by subclasses to provide a different map implementation.\n     * Not every AbstractHashedMap is suitable, identity and reference based maps\n     * would be poor choices.\n     *\n     * @return a new AbstractHashedMap or subclass\n     * @since 3.1\n     */\n    protected AbstractHashedMap<K, V> createDelegateMap() {\n        return new HashedMap<>();\n    }\n\n    /**\n     * Gets the entrySet view of the map.\n     * Changes made to the view affect this map.\n     * <p>\n     * NOTE: from 4.0, the returned Map Entry will be an independent object and will\n     * not change anymore as the iterator progresses. To avoid this additional object\n     * creation and simply iterate through the entries, use {@link #mapIterator()}.\n     *\n     * @return the entrySet view\n     */\n    @Override\n    public Set<Map.Entry<K, V>> entrySet() {\n        if (delegateMap != null) {\n            return delegateMap.entrySet();\n        }\n        return new EntrySet<>(this);\n    }\n\n    /**\n     * Compares this map with another.\n     *\n     * @param obj  the object to compare to\n     * @return true if equal\n     */\n    @Override\n    public boolean equals(final Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (delegateMap != null) {\n            return delegateMap.equals(obj);\n        }\n        if (!(obj instanceof Map)) {\n            return false;\n        }\n        final Map<?, ?> other = (Map<?, ?>) obj;\n        if (size != other.size()) {\n            return false;\n        }\n        if (size > 0) {\n            Object otherValue = null;\n            switch (size) {  // drop through\n            case 3:\n                if (!other.containsKey(key3)) {\n                    return false;\n                }\n                otherValue = other.get(key3);\n                if (!Objects.equals(value3, otherValue)) {\n                    return false;\n                }\n            case 2:\n                if (!other.containsKey(key2)) {\n                    return false;\n                }\n                otherValue = other.get(key2);\n                if (!Objects.equals(value2, otherValue)) {\n                    return false;\n                }\n            case 1:\n                if (!other.containsKey(key1)) {\n                    return false;\n                }\n                otherValue = other.get(key1);\n                if (!Objects.equals(value1, otherValue)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Gets the value mapped to the key specified.\n     *\n     * @param key  the key\n     * @return the mapped value, null if no match\n     */\n    @Override\n    public V get(final Object key) {\n        if (delegateMap != null) {\n            return delegateMap.get(key);\n        }\n        if (key == null) {\n            switch (size) {\n            // drop through\n            case 3:\n                if (key3 == null) {\n                    return value3;\n                }\n            case 2:\n                if (key2 == null) {\n                    return value2;\n                }\n            case 1:\n                if (key1 == null) {\n                    return value1;\n                }\n            }\n        } else if (size > 0) {\n            final int hashCode = key.hashCode();\n            switch (size) {\n            // drop through\n            case 3:\n                if (hash3 == hashCode && key.equals(key3)) {\n                    return value3;\n                }\n            case 2:\n                if (hash2 == hashCode && key.equals(key2)) {\n                    return value2;\n                }\n            case 1:\n                if (hash1 == hashCode && key.equals(key1)) {\n                    return value1;\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Gets the standard Map hashCode.\n     *\n     * @return the hash code defined in the Map interface\n     */\n    @Override\n    public int hashCode() {\n        if (delegateMap != null) {\n            return delegateMap.hashCode();\n        }\n        int total = 0;\n        switch (size) {  // drop through\n        case 3:\n            total += hash3 ^ (value3 == null ? 0 : value3.hashCode());\n        case 2:\n            total += hash2 ^ (value2 == null ? 0 : value2.hashCode());\n        case 1:\n            total += hash1 ^ (value1 == null ? 0 : value1.hashCode());\n        case 0:\n            break;\n        default:\n            throw new IllegalStateException(\"Invalid map index: \" + size);\n        }\n        return total;\n    }\n\n    /**\n     * Checks whether the map is currently empty.\n     *\n     * @return true if the map is currently size zero\n     */\n    @Override\n    public boolean isEmpty() {\n        return size() == 0;\n    }\n\n    /**\n     * Gets the keySet view of the map.\n     * Changes made to the view affect this map.\n     * To simply iterate through the keys, use {@link #mapIterator()}.\n     *\n     * @return the keySet view\n     */\n    @Override\n    public Set<K> keySet() {\n        if (delegateMap != null) {\n            return delegateMap.keySet();\n        }\n        return new KeySet<>(this);\n    }\n\n    /**\n     * Gets an iterator over the map.\n     * Changes made to the iterator affect this map.\n     * <p>\n     * A MapIterator returns the keys in the map. It also provides convenient\n     * methods to get the key and value, and set the value.\n     * It avoids the need to create an entrySet/keySet/values object.\n     * It also avoids creating the Map Entry object.\n     *\n     * @return the map iterator\n     */\n    @Override\n    public MapIterator<K, V> mapIterator() {\n        if (delegateMap != null) {\n            return delegateMap.mapIterator();\n        }\n        if (size == 0) {\n            return EmptyMapIterator.<K, V>emptyMapIterator();\n        }\n        return new FlatMapIterator<>(this);\n    }\n\n    /**\n     * Puts a key-value mapping into this map.\n     *\n     * @param key  the key to add\n     * @param value  the value to add\n     * @return the value previously mapped to this key, null if none\n     */\n    @Override\n    public V put(final K key, final V value) {\n        if (delegateMap != null) {\n            return delegateMap.put(key, value);\n        }\n        // change existing mapping\n        if (key == null) {\n            switch (size) {  // drop through\n            case 3:\n                if (key3 == null) {\n                    final V old = value3;\n                    value3 = value;\n                    return old;\n                }\n            case 2:\n                if (key2 == null) {\n                    final V old = value2;\n                    value2 = value;\n                    return old;\n                }\n            case 1:\n                if (key1 == null) {\n                    final V old = value1;\n                    value1 = value;\n                    return old;\n                }\n            }\n        } else if (size > 0) {\n            final int hashCode = key.hashCode();\n            switch (size) {  // drop through\n            case 3:\n                if (hash3 == hashCode && key.equals(key3)) {\n                    final V old = value3;\n                    value3 = value;\n                    return old;\n                }\n            case 2:\n                if (hash2 == hashCode && key.equals(key2)) {\n                    final V old = value2;\n                    value2 = value;\n                    return old;\n                }\n            case 1:\n                if (hash1 == hashCode && key.equals(key1)) {\n                    final V old = value1;\n                    value1 = value;\n                    return old;\n                }\n            }\n        }\n\n        // add new mapping\n        switch (size) {\n        default:\n            convertToMap();\n            delegateMap.put(key, value);\n            return null;\n        case 2:\n            hash3 = key == null ? 0 : key.hashCode();\n            key3 = key;\n            value3 = value;\n            break;\n        case 1:\n            hash2 = key == null ? 0 : key.hashCode();\n            key2 = key;\n            value2 = value;\n            break;\n        case 0:\n            hash1 = key == null ? 0 : key.hashCode();\n            key1 = key;\n            value1 = value;\n            break;\n        }\n        size++;\n        return null;\n    }\n\n    /**\n     * Puts all the values from the specified map into this map.\n     *\n     * @param map  the map to add\n     * @throws NullPointerException if the map is null\n     */\n    @Override\n    public void putAll(final Map<? extends K, ? extends V> map) {\n        final int size = map.size();\n        if (size == 0) {\n            return;\n        }\n        if (delegateMap != null) {\n            delegateMap.putAll(map);\n            return;\n        }\n        if (size < 4) {\n            for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n                put(entry.getKey(), entry.getValue());\n            }\n        } else {\n            convertToMap();\n            delegateMap.putAll(map);\n        }\n    }\n\n    /**\n     * Deserializes the map in using a custom routine.\n     *\n     * @param in the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded\n     */\n    @SuppressWarnings(\"unchecked\")\n    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        final int count = in.readInt();\n        if (count > 3) {\n            delegateMap = createDelegateMap();\n        }\n        for (int i = count; i > 0; i--) {\n            put((K) in.readObject(), (V) in.readObject());\n        }\n    }\n\n    /**\n     * Removes the specified mapping from this map.\n     *\n     * @param key  the mapping to remove\n     * @return the value mapped to the removed key, null if key not in map\n     */\n    @Override\n    public V remove(final Object key) {\n        if (delegateMap != null) {\n            return delegateMap.remove(key);\n        }\n        if (size == 0) {\n            return null;\n        }\n        if (key == null) {\n            switch (size) {  // drop through\n            case 3:\n                if (key3 == null) {\n                    final V old = value3;\n                    hash3 = 0;\n                    key3 = null;\n                    value3 = null;\n                    size = 2;\n                    return old;\n                }\n                if (key2 == null) {\n                    final V old = value2;\n                    hash2 = hash3;\n                    key2 = key3;\n                    value2 = value3;\n                    hash3 = 0;\n                    key3 = null;\n                    value3 = null;\n                    size = 2;\n                    return old;\n                }\n                if (key1 == null) {\n                    final V old = value1;\n                    hash1 = hash3;\n                    key1 = key3;\n                    value1 = value3;\n                    hash3 = 0;\n                    key3 = null;\n                    value3 = null;\n                    size = 2;\n                    return old;\n                }\n                return null;\n            case 2:\n                if (key2 == null) {\n                    final V old = value2;\n                    hash2 = 0;\n                    key2 = null;\n                    value2 = null;\n                    size = 1;\n                    return old;\n                }\n                if (key1 == null) {\n                    final V old = value1;\n                    hash1 = hash2;\n                    key1 = key2;\n                    value1 = value2;\n                    hash2 = 0;\n                    key2 = null;\n                    value2 = null;\n                    size = 1;\n                    return old;\n                }\n                return null;\n            case 1:\n                if (key1 == null) {\n                    final V old = value1;\n                    hash1 = 0;\n                    key1 = null;\n                    value1 = null;\n                    size = 0;\n                    return old;\n                }\n            }\n        } else if (size > 0) {\n            final int hashCode = key.hashCode();\n            switch (size) {  // drop through\n            case 3:\n                if (hash3 == hashCode && key.equals(key3)) {\n                    final V old = value3;\n                    hash3 = 0;\n                    key3 = null;\n                    value3 = null;\n                    size = 2;\n                    return old;\n                }\n                if (hash2 == hashCode && key.equals(key2)) {\n                    final V old = value2;\n                    hash2 = hash3;\n                    key2 = key3;\n                    value2 = value3;\n                    hash3 = 0;\n                    key3 = null;\n                    value3 = null;\n                    size = 2;\n                    return old;\n                }\n                if (hash1 == hashCode && key.equals(key1)) {\n                    final V old = value1;\n                    hash1 = hash3;\n                    key1 = key3;\n                    value1 = value3;\n                    hash3 = 0;\n                    key3 = null;\n                    value3 = null;\n                    size = 2;\n                    return old;\n                }\n                return null;\n            case 2:\n                if (hash2 == hashCode && key.equals(key2)) {\n                    final V old = value2;\n                    hash2 = 0;\n                    key2 = null;\n                    value2 = null;\n                    size = 1;\n                    return old;\n                }\n                if (hash1 == hashCode && key.equals(key1)) {\n                    final V old = value1;\n                    hash1 = hash2;\n                    key1 = key2;\n                    value1 = value2;\n                    hash2 = 0;\n                    key2 = null;\n                    value2 = null;\n                    size = 1;\n                    return old;\n                }\n                return null;\n            case 1:\n                if (hash1 == hashCode && key.equals(key1)) {\n                    final V old = value1;\n                    hash1 = 0;\n                    key1 = null;\n                    value1 = null;\n                    size = 0;\n                    return old;\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Gets the size of the map.\n     *\n     * @return the size\n     */\n    @Override\n    public int size() {\n        if (delegateMap != null) {\n            return delegateMap.size();\n        }\n        return size;\n    }\n\n    /**\n     * Gets the map as a String.\n     *\n     * @return a string version of the map\n     */\n    @Override\n    public String toString() {\n        if (delegateMap != null) {\n            return delegateMap.toString();\n        }\n        if (size == 0) {\n            return \"{}\";\n        }\n        final StringBuilder buf = new StringBuilder(128);\n        buf.append('{');\n        switch (size) {  // drop through\n        case 3:\n            buf.append(key3 == this ? \"(this Map)\" : key3);\n            buf.append('=');\n            buf.append(value3 == this ? \"(this Map)\" : value3);\n            buf.append(CollectionUtils.COMMA);\n        case 2:\n            buf.append(key2 == this ? \"(this Map)\" : key2);\n            buf.append('=');\n            buf.append(value2 == this ? \"(this Map)\" : value2);\n            buf.append(CollectionUtils.COMMA);\n        case 1:\n            buf.append(key1 == this ? \"(this Map)\" : key1);\n            buf.append('=');\n            buf.append(value1 == this ? \"(this Map)\" : value1);\n            break;\n        // case 0: has already been dealt with\n        default:\n            throw new IllegalStateException(\"Invalid map index: \" + size);\n        }\n        buf.append('}');\n        return buf.toString();\n    }\n\n    /**\n     * Gets the values view of the map.\n     * Changes made to the view affect this map.\n     * To simply iterate through the values, use {@link #mapIterator()}.\n     *\n     * @return the values view\n     */\n    @Override\n    public Collection<V> values() {\n        if (delegateMap != null) {\n            return delegateMap.values();\n        }\n        return new Values<>(this);\n    }\n\n    /**\n     * Serializes this object to an ObjectOutputStream.\n     *\n     * @param out the target ObjectOutputStream.\n     * @throws IOException thrown when an I/O errors occur writing to the target stream.\n     */\n    private void writeObject(final ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        out.writeInt(size());\n        for (final MapIterator<?, ?> it = mapIterator(); it.hasNext();) {\n            out.writeObject(it.next());  // key\n            out.writeObject(it.getValue());  // value\n        }\n    }\n\n}", "super_interfaces": ["IterableMap<K, V>", "Serializable", "Cloneable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = -6701087419741928296L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -6701087419741928296L", "syntax_pass": true}, {"attribute_expression": "private transient int size;", "docstring": " The size of the map, used while in flat mode", "modifiers": "private transient", "marker_annotations": [], "non_marker_annotations": ["private", "transient"], "comments": [], "type": "int", "name": "size", "syntax_pass": true}, {"attribute_expression": "private transient int hash1;", "docstring": " Hash, used while in flat mode", "modifiers": "private transient", "marker_annotations": [], "non_marker_annotations": ["private", "transient"], "comments": [], "type": "int", "name": "hash1", "syntax_pass": true}, {"attribute_expression": "private transient int hash2;", "docstring": " Hash, used while in flat mode", "modifiers": "private transient", "marker_annotations": [], "non_marker_annotations": ["private", "transient"], "comments": [], "type": "int", "name": "hash2", "syntax_pass": true}, {"attribute_expression": "private transient int hash3;", "docstring": " Hash, used while in flat mode", "modifiers": "private transient", "marker_annotations": [], "non_marker_annotations": ["private", "transient"], "comments": [], "type": "int", "name": "hash3", "syntax_pass": true}, {"attribute_expression": "private transient K key1;", "docstring": " Key, used while in flat mode", "modifiers": "private transient", "marker_annotations": [], "non_marker_annotations": ["private", "transient"], "comments": [], "type": "K", "name": "key1", "syntax_pass": true}, {"attribute_expression": "private transient K key2;", "docstring": " Key, used while in flat mode", "modifiers": "private transient", "marker_annotations": [], "non_marker_annotations": ["private", "transient"], "comments": [], "type": "K", "name": "key2", "syntax_pass": true}, {"attribute_expression": "private transient K key3;", "docstring": " Key, used while in flat mode", "modifiers": "private transient", "marker_annotations": [], "non_marker_annotations": ["private", "transient"], "comments": [], "type": "K", "name": "key3", "syntax_pass": true}, {"attribute_expression": "private transient V value1;", "docstring": " Value, used while in flat mode", "modifiers": "private transient", "marker_annotations": [], "non_marker_annotations": ["private", "transient"], "comments": [], "type": "V", "name": "value1", "syntax_pass": true}, {"attribute_expression": "private transient V value2;", "docstring": " Value, used while in flat mode", "modifiers": "private transient", "marker_annotations": [], "non_marker_annotations": ["private", "transient"], "comments": [], "type": "V", "name": "value2", "syntax_pass": true}, {"attribute_expression": "private transient V value3;", "docstring": " Value, used while in flat mode", "modifiers": "private transient", "marker_annotations": [], "non_marker_annotations": ["private", "transient"], "comments": [], "type": "V", "name": "value3", "syntax_pass": true}, {"attribute_expression": "private transient AbstractHashedMap<K, V> delegateMap;", "docstring": " Map, used while in delegate mode", "modifiers": "private transient", "marker_annotations": [], "non_marker_annotations": ["private", "transient"], "comments": [], "type": "AbstractHashedMap<K, V>", "name": "delegateMap", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/sequence/ReplacementsFinder.java.ReplacementsFinder", "name": "ReplacementsFinder", "file_path": "src/main/java/org/apache/commons/collections4/sequence/ReplacementsFinder.java", "superclasses": "", "methods": ["[]ReplacementsFinder(ReplacementsHandler<T>)", "[void]visitDeleteCommand(T)", "[void]visitInsertCommand(T)", "[void]visitKeepCommand(T)"], "method_uris": ["src/main/java/org/apache/commons/collections4/sequence/ReplacementsFinder.java.ReplacementsFinder.[]ReplacementsFinder(ReplacementsHandler<T>)", "src/main/java/org/apache/commons/collections4/sequence/ReplacementsFinder.java.ReplacementsFinder.[void]visitDeleteCommand(T)", "src/main/java/org/apache/commons/collections4/sequence/ReplacementsFinder.java.ReplacementsFinder.[void]visitInsertCommand(T)", "src/main/java/org/apache/commons/collections4/sequence/ReplacementsFinder.java.ReplacementsFinder.[void]visitKeepCommand(T)"], "overrides": null, "attributes": [], "class_docstring": "\nThis class handles sequences of replacements resulting from a comparison.\n<p>\nThe comparison of two objects sequences leads to the identification of common\nparts and parts which only belong to the first or to the second sequence. The\ncommon parts appear in the edit script in the form of <em>keep</em> commands,\nthey can be considered as synchronization objects between the two sequences.\nThese synchronization objects split the two sequences in synchronized\nsub-sequences. The first sequence can be transformed into the second one by\nreplacing each synchronized sub-sequence of the first sequence by the\ncorresponding sub-sequence of the second sequence. This is a synthetic way to\nsee an {@link EditScript edit script}, replacing individual\n{@link DeleteCommand delete}, {@link KeepCommand keep} and\n{@link InsertCommand insert} commands by fewer replacements acting on\ncomplete sub-sequences.\n</p>\n<p>\nThis class is devoted to perform this interpretation. It visits an\n{@link EditScript edit script} (because it implements the\n{@link CommandVisitor CommandVisitor} interface) and calls a user-supplied\nhandler implementing the {@link ReplacementsHandler ReplacementsHandler}\ninterface to process the sub-sequences.\n</p>\n\n@param <T> the type of the input to the visit operations.\n@see ReplacementsHandler\n@see EditScript\n@see SequencesComparator\n@since 4.0\n", "original_string": "public class ReplacementsFinder<T> implements CommandVisitor<T> {\n\n    private final List<T> pendingInsertions;\n    private final List<T> pendingDeletions;\n    private int skipped;\n\n    /** Handler to call when synchronized sequences are found. */\n    private final ReplacementsHandler<T> handler;\n\n    /**\n     * Simple constructor. Creates a new instance of {@link ReplacementsFinder}.\n     *\n     * @param handler  handler to call when synchronized sequences are found\n     */\n    public ReplacementsFinder(final ReplacementsHandler<T> handler) {\n        pendingInsertions = new ArrayList<>();\n        pendingDeletions = new ArrayList<>();\n        skipped = 0;\n        this.handler = handler;\n    }\n\n    /**\n     * Add an object to the pending deletions set.\n     *\n     * @param object  object to delete\n     */\n    @Override\n    public void visitDeleteCommand(final T object) {\n        pendingDeletions.add(object);\n    }\n\n    /**\n     * Add an object to the pending insertions set.\n     *\n     * @param object  object to insert\n     */\n    @Override\n    public void visitInsertCommand(final T object) {\n        pendingInsertions.add(object);\n    }\n\n    /**\n     * Handle a synchronization object.\n     * <p>\n     * When a synchronization object is identified, the pending insertions and\n     * pending deletions sets are provided to the user handler as subsequences.\n     *\n     * @param object  synchronization object detected\n     */\n    @Override\n    public void visitKeepCommand(final T object) {\n        if (pendingDeletions.isEmpty() && pendingInsertions.isEmpty()) {\n            ++skipped;\n        } else {\n            handler.handleReplacement(skipped, pendingDeletions, pendingInsertions);\n            pendingDeletions.clear();\n            pendingInsertions.clear();\n            skipped = 1;\n        }\n    }\n\n}", "super_interfaces": ["CommandVisitor<T>"], "fields": [{"attribute_expression": "private final List<T> pendingInsertions;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<T>", "name": "pendingInsertions", "syntax_pass": true}, {"attribute_expression": "private final List<T> pendingDeletions;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<T>", "name": "pendingDeletions", "syntax_pass": true}, {"attribute_expression": "private int skipped;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "skipped", "syntax_pass": true}, {"attribute_expression": "private final ReplacementsHandler<T> handler;", "docstring": " Handler to call when synchronized sequences are found.", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ReplacementsHandler<T>", "name": "handler", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/sequence/SequencesComparator.java.SequencesComparator", "name": "SequencesComparator", "file_path": "src/main/java/org/apache/commons/collections4/sequence/SequencesComparator.java", "superclasses": "", "methods": ["[]SequencesComparator(List<T>,List<T>)", "[]SequencesComparator(List<T>,List<T>,Equator<? super T>)", "[void]buildScript(int,int,int,int,EditScript<T>)", "[Snake]buildSnake(int,int,int,int)", "[Snake]getMiddleSnake(int,int,int,int)", "[EditScript<T>]getScript()"], "method_uris": ["src/main/java/org/apache/commons/collections4/sequence/SequencesComparator.java.SequencesComparator.[]SequencesComparator(List<T>,List<T>)", "src/main/java/org/apache/commons/collections4/sequence/SequencesComparator.java.SequencesComparator.[]SequencesComparator(List<T>,List<T>,Equator<? super T>)", "src/main/java/org/apache/commons/collections4/sequence/SequencesComparator.java.SequencesComparator.[void]buildScript(int,int,int,int,EditScript<T>)", "src/main/java/org/apache/commons/collections4/sequence/SequencesComparator.java.SequencesComparator.[Snake]buildSnake(int,int,int,int)", "src/main/java/org/apache/commons/collections4/sequence/SequencesComparator.java.SequencesComparator.[Snake]getMiddleSnake(int,int,int,int)", "src/main/java/org/apache/commons/collections4/sequence/SequencesComparator.java.SequencesComparator.[EditScript<T>]getScript()"], "overrides": null, "attributes": [{"original_string": "    private static final class Snake {\n\n        /** Start index. */\n        private final int start;\n\n        /** End index. */\n        private final int end;\n\n        /** Diagonal number. */\n        private final int diag;\n\n        /**\n         * Simple constructor. Creates a new instance of Snake with specified indices.\n         *\n         * @param start  start index of the snake\n         * @param end  end index of the snake\n         * @param diag  diagonal number\n         */\n        Snake(final int start, final int end, final int diag) {\n            this.start = start;\n            this.end   = end;\n            this.diag  = diag;\n        }\n\n        /**\n         * Gets the diagonal number of the snake.\n         *\n         * @return diagonal number of the snake\n         */\n        public int getDiag() {\n            return diag;\n        }\n\n        /**\n         * Gets the end index of the snake.\n         *\n         * @return end index of the snake\n         */\n        public int getEnd() {\n            return end;\n        }\n\n        /**\n         * Gets the start index of the snake.\n         *\n         * @return start index of the snake\n         */\n        public int getStart() {\n            return start;\n        }\n    }", "definition": "    private static final class Snake", "class_docstring": "\nThis class is a simple placeholder to hold the end part of a path\nunder construction in a {@link SequencesComparator SequencesComparator}.\n", "name": "Snake", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "fields": [{"attribute_expression": "private final int start;", "docstring": " Start index.", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "start", "syntax_pass": true}, {"attribute_expression": "private final int end;", "docstring": " End index.", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "end", "syntax_pass": true}, {"attribute_expression": "private final int diag;", "docstring": " Diagonal number.", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "diag", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        Snake(final int start, final int end, final int diag) {\n            this.start = start;\n            this.end   = end;\n            this.diag  = diag;\n        }", "docstring": "\nSimple constructor. Creates a new instance of Snake with specified indices.\n\n@param start  start index of the snake\n@param end  end index of the snake\n@param diag  diagonal number\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Snake", "params": [{"name": "start", "type": "int"}, {"name": "end", "type": "int"}, {"name": "diag", "type": "int"}], "body": "                                                              {\n            this.start = start;\n            this.end   = end;\n            this.diag  = diag;\n        }", "signature": "Snake(final int start, final int end, final int diag)"}, {"syntax_pass": true, "original_string": "        public int getDiag() {\n            return diag;\n        }", "docstring": "\nGets the diagonal number of the snake.\n\n@return diagonal number of the snake\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "getDiag", "params": [], "body": "                             {\n            return diag;\n        }", "signature": "public int getDiag()"}, {"syntax_pass": true, "original_string": "        public int getEnd() {\n            return end;\n        }", "docstring": "\nGets the end index of the snake.\n\n@return end index of the snake\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "getEnd", "params": [], "body": "                            {\n            return end;\n        }", "signature": "public int getEnd()"}, {"syntax_pass": true, "original_string": "        public int getStart() {\n            return start;\n        }", "docstring": "\nGets the start index of the snake.\n\n@return start index of the snake\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "getStart", "params": [], "body": "                              {\n            return start;\n        }", "signature": "public int getStart()"}]}], "class_docstring": "\nThis class allows to compare two objects sequences.\n<p>\nThe two sequences can hold any object type, as only the {@code equals}\nmethod is used to compare the elements of the sequences. It is guaranteed\nthat the comparisons will always be done as {@code o1.equals(o2)} where\n{@code o1} belongs to the first sequence and {@code o2} belongs to\nthe second sequence. This can be important if subclassing is used for some\nelements in the first sequence and the {@code equals} method is\nspecialized.\n</p>\n<p>\nComparison can be seen from two points of view: either as giving the smallest\nmodification allowing to transform the first sequence into the second one, or\nas giving the longest sequence which is a subsequence of both initial\nsequences. The {@code equals} method is used to compare objects, so any\nobject can be put into sequences. Modifications include deleting, inserting\nor keeping one object, starting from the beginning of the first sequence.\n</p>\n<p>\nThis class implements the comparison algorithm, which is the very efficient\nalgorithm from Eugene W. Myers\n<a href=\"https://www.cis.upenn.edu/~bcpierce/courses/dd/papers/diff.ps\">\nAn O(ND) Difference Algorithm and Its Variations</a>. This algorithm produces\nthe shortest possible\n{@link EditScript edit script}\ncontaining all the\n{@link EditCommand commands}\nneeded to transform the first sequence into the second one.\n</p>\n\n@param <T> the type of elements in the lists.\n@see EditScript\n@see EditCommand\n@see CommandVisitor\n@since 4.0\n", "original_string": "public class SequencesComparator<T> {\n\n    /**\n     * This class is a simple placeholder to hold the end part of a path\n     * under construction in a {@link SequencesComparator SequencesComparator}.\n     */\n    private static final class Snake {\n\n        /** Start index. */\n        private final int start;\n\n        /** End index. */\n        private final int end;\n\n        /** Diagonal number. */\n        private final int diag;\n\n        /**\n         * Simple constructor. Creates a new instance of Snake with specified indices.\n         *\n         * @param start  start index of the snake\n         * @param end  end index of the snake\n         * @param diag  diagonal number\n         */\n        Snake(final int start, final int end, final int diag) {\n            this.start = start;\n            this.end   = end;\n            this.diag  = diag;\n        }\n\n        /**\n         * Gets the diagonal number of the snake.\n         *\n         * @return diagonal number of the snake\n         */\n        public int getDiag() {\n            return diag;\n        }\n\n        /**\n         * Gets the end index of the snake.\n         *\n         * @return end index of the snake\n         */\n        public int getEnd() {\n            return end;\n        }\n\n        /**\n         * Gets the start index of the snake.\n         *\n         * @return start index of the snake\n         */\n        public int getStart() {\n            return start;\n        }\n    }\n\n    /** First sequence. */\n    private final List<T> sequence1;\n\n    /** Second sequence. */\n    private final List<T> sequence2;\n\n    /** The equator used for testing object equality. */\n    private final Equator<? super T> equator;\n    /** Temporary variables. */\n    private final int[] vDown;\n\n    private final int[] vUp;\n\n    /**\n     * Simple constructor.\n     * <p>\n     * Creates a new instance of SequencesComparator using a {@link DefaultEquator}.\n     * <p>\n     * It is <em>guaranteed</em> that the comparisons will always be done as\n     * {@code o1.equals(o2)} where {@code o1} belongs to the first\n     * sequence and {@code o2} belongs to the second sequence. This can be\n     * important if subclassing is used for some elements in the first sequence\n     * and the {@code equals} method is specialized.\n     *\n     * @param sequence1  first sequence to be compared\n     * @param sequence2  second sequence to be compared\n     */\n    public SequencesComparator(final List<T> sequence1, final List<T> sequence2) {\n        this(sequence1, sequence2, DefaultEquator.defaultEquator());\n    }\n\n    /**\n     * Simple constructor.\n     * <p>\n     * Creates a new instance of SequencesComparator with a custom {@link Equator}.\n     * <p>\n     * It is <em>guaranteed</em> that the comparisons will always be done as\n     * {@code Equator.equate(o1, o2)} where {@code o1} belongs to the first\n     * sequence and {@code o2} belongs to the second sequence.\n     *\n     * @param sequence1  first sequence to be compared\n     * @param sequence2  second sequence to be compared\n     * @param equator  the equator to use for testing object equality\n     */\n    public SequencesComparator(final List<T> sequence1, final List<T> sequence2, final Equator<? super T> equator) {\n        this.sequence1 = sequence1;\n        this.sequence2 = sequence2;\n        this.equator = equator;\n\n        final int size = sequence1.size() + sequence2.size() + 2;\n        vDown = new int[size];\n        vUp   = new int[size];\n    }\n\n    /**\n     * Build an edit script.\n     *\n     * @param start1  the start of the first sequence to be compared\n     * @param end1  the end of the first sequence to be compared\n     * @param start2  the start of the second sequence to be compared\n     * @param end2  the end of the second sequence to be compared\n     * @param script the edited script\n     */\n    private void buildScript(final int start1, final int end1, final int start2, final int end2,\n                             final EditScript<T> script) {\n\n        final Snake middle = getMiddleSnake(start1, end1, start2, end2);\n\n        if (middle == null\n                || middle.getStart() == end1 && middle.getDiag() == end1 - end2\n                || middle.getEnd() == start1 && middle.getDiag() == start1 - start2) {\n\n            int i = start1;\n            int j = start2;\n            while (i < end1 || j < end2) {\n                if (i < end1 && j < end2 && equator.equate(sequence1.get(i), sequence2.get(j))) {\n                    script.append(new KeepCommand<>(sequence1.get(i)));\n                    ++i;\n                    ++j;\n                } else if (end1 - start1 > end2 - start2) {\n                    script.append(new DeleteCommand<>(sequence1.get(i)));\n                    ++i;\n                } else {\n                    script.append(new InsertCommand<>(sequence2.get(j)));\n                    ++j;\n                }\n            }\n\n        } else {\n\n            buildScript(start1, middle.getStart(),\n                        start2, middle.getStart() - middle.getDiag(),\n                        script);\n            for (int i = middle.getStart(); i < middle.getEnd(); ++i) {\n                script.append(new KeepCommand<>(sequence1.get(i)));\n            }\n            buildScript(middle.getEnd(), end1,\n                        middle.getEnd() - middle.getDiag(), end2,\n                        script);\n        }\n    }\n\n    /**\n     * Build a snake.\n     *\n     * @param start  the value of the start of the snake\n     * @param diag  the value of the diagonal of the snake\n     * @param end1  the value of the end of the first sequence to be compared\n     * @param end2  the value of the end of the second sequence to be compared\n     * @return the snake built\n     */\n    private Snake buildSnake(final int start, final int diag, final int end1, final int end2) {\n        int end = start;\n        while (end - diag < end2\n                && end < end1\n                && equator.equate(sequence1.get(end), sequence2.get(end - diag))) {\n            ++end;\n        }\n        return new Snake(start, end, diag);\n    }\n\n    /**\n     * Gets the middle snake corresponding to two subsequences of the\n     * main sequences.\n     * <p>\n     * The snake is found using the MYERS Algorithm (this algorithm has\n     * also been implemented in the GNU diff program). This algorithm is\n     * explained in Eugene Myers article:\n     * <a href=\"https://web.archive.org/web/20040719035900/http%3A//www.cs.arizona.edu/people/gene/PAPERS/diff.ps\">\n     * An O(ND) Difference Algorithm and Its Variations</a>.\n     *\n     * @param start1  the start of the first sequence to be compared\n     * @param end1  the end of the first sequence to be compared\n     * @param start2  the start of the second sequence to be compared\n     * @param end2  the end of the second sequence to be compared\n     * @return the middle snake\n     */\n    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta = m - n;\n        final int sum = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1 + offset] = start1;\n        vUp[1 + offset] = end1 + 1;\n\n        for (int d = 0; d <= offset; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i - 1] < vDown[i + 1]) {\n                    vDown[i] = vDown[i + 1];\n                } else {\n                    vDown[i] = vDown[i - 1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d && vUp[i - delta] <= vDown[i]) { // NOPMD\n                    return buildSnake(vUp[i - delta], k + start1 - start2, end1, end2);\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d || k != delta + d && vUp[i + 1] <= vUp[i - 1]) {\n                    vUp[i] = vUp[i + 1] - 1;\n                } else {\n                    vUp[i] = vUp[i - 1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d && vUp[i] <= vDown[i + delta]) { // NOPMD\n                    return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                }\n            }\n        }\n\n        // this should not happen\n        throw new IllegalStateException(\"Internal Error\");\n    }\n\n    /**\n     * Gets the {@link EditScript} object.\n     * <p>\n     * It is guaranteed that the objects embedded in the {@link InsertCommand\n     * insert commands} come from the second sequence and that the objects\n     * embedded in either the {@link DeleteCommand delete commands} or\n     * {@link KeepCommand keep commands} come from the first sequence. This can\n     * be important if subclassing is used for some elements in the first\n     * sequence and the {@code equals} method is specialized.\n     *\n     * @return the edit script resulting from the comparison of the two\n     *         sequences\n     */\n    public EditScript<T> getScript() {\n        final EditScript<T> script = new EditScript<>();\n        buildScript(0, sequence1.size(), 0, sequence2.size(), script);\n        return script;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final List<T> sequence1;", "docstring": " First sequence.", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<T>", "name": "sequence1", "syntax_pass": true}, {"attribute_expression": "private final List<T> sequence2;", "docstring": " Second sequence.", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<T>", "name": "sequence2", "syntax_pass": true}, {"attribute_expression": "private final Equator<? super T> equator;", "docstring": " The equator used for testing object equality.", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Equator<? super T>", "name": "equator", "syntax_pass": true}, {"attribute_expression": "private final int[] vDown;", "docstring": " Temporary variables.", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int[]", "name": "vDown", "syntax_pass": true}, {"attribute_expression": "private final int[] vUp;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int[]", "name": "vUp", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/sequence/InsertCommand.java.InsertCommand", "name": "InsertCommand", "file_path": "src/main/java/org/apache/commons/collections4/sequence/InsertCommand.java", "superclasses": "", "methods": ["[]InsertCommand(T)", "[void]accept(CommandVisitor<T>)"], "method_uris": ["src/main/java/org/apache/commons/collections4/sequence/InsertCommand.java.InsertCommand.[]InsertCommand(T)", "src/main/java/org/apache/commons/collections4/sequence/InsertCommand.java.InsertCommand.[void]accept(CommandVisitor<T>)"], "overrides": null, "attributes": [], "class_docstring": "\nCommand representing the insertion of one object of the second sequence.\n<p>\nWhen one object of the second sequence has no corresponding object in the\nfirst sequence at the right place, the {@link EditScript edit script}\ntransforming the first sequence into the second sequence uses an instance of\nthis class to represent the insertion of this object. The objects embedded in\nthese type of commands always come from the second sequence.\n</p>\n\n@param <T> the type of object to apply this command.\n@see SequencesComparator\n@see EditScript\n@since 4.0\n", "original_string": "public class InsertCommand<T> extends EditCommand<T> {\n\n    /**\n     * Simple constructor. Creates a new instance of InsertCommand\n     *\n     * @param object  the object of the second sequence that should be inserted\n     */\n    public InsertCommand(final T object) {\n        super(object);\n    }\n\n    /**\n     * Accept a visitor. When an {@code InsertCommand} accepts a visitor,\n     * it calls its {@link CommandVisitor#visitInsertCommand visitInsertCommand}\n     * method.\n     *\n     * @param visitor  the visitor to be accepted\n     */\n    @Override\n    public void accept(final CommandVisitor<T> visitor) {\n        visitor.visitInsertCommand(getObject());\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/org/apache/commons/collections4/sequence/EditScript.java.EditScript", "name": "EditScript", "file_path": "src/main/java/org/apache/commons/collections4/sequence/EditScript.java", "superclasses": "", "methods": ["[]EditScript()", "[void]append(DeleteCommand<T>)", "[void]append(InsertCommand<T>)", "[void]append(KeepCommand<T>)", "[int]getLCSLength()", "[int]getModifications()", "[void]visit(CommandVisitor<T>)"], "method_uris": ["src/main/java/org/apache/commons/collections4/sequence/EditScript.java.EditScript.[]EditScript()", "src/main/java/org/apache/commons/collections4/sequence/EditScript.java.EditScript.[void]append(DeleteCommand<T>)", "src/main/java/org/apache/commons/collections4/sequence/EditScript.java.EditScript.[void]append(InsertCommand<T>)", "src/main/java/org/apache/commons/collections4/sequence/EditScript.java.EditScript.[void]append(KeepCommand<T>)", "src/main/java/org/apache/commons/collections4/sequence/EditScript.java.EditScript.[int]getLCSLength()", "src/main/java/org/apache/commons/collections4/sequence/EditScript.java.EditScript.[int]getModifications()", "src/main/java/org/apache/commons/collections4/sequence/EditScript.java.EditScript.[void]visit(CommandVisitor<T>)"], "overrides": null, "attributes": [], "class_docstring": "\nThis class gathers all the {@link EditCommand commands} needed to transform\none objects sequence into another objects sequence.\n<p>\nAn edit script is the most general view of the differences between two\nsequences. It is built as the result of the comparison between two sequences\nby the {@link SequencesComparator SequencesComparator} class. The user can\nwalk through it using the <em>visitor</em> design pattern.\n</p>\n<p>\nIt is guaranteed that the objects embedded in the {@link InsertCommand insert\ncommands} come from the second sequence and that the objects embedded in\neither the {@link DeleteCommand delete commands} or {@link KeepCommand keep\ncommands} come from the first sequence. This can be important if subclassing\nis used for some elements in the first sequence and the {@code equals}\nmethod is specialized.\n</p>\n\n@param <T> the type of object to apply commands.\n@see SequencesComparator\n@see EditCommand\n@see CommandVisitor\n@see ReplacementsHandler\n@since 4.0\n", "original_string": "public class EditScript<T> {\n\n    /** Container for the commands. */\n    private final List<EditCommand<T>> commands;\n\n    /** Length of the longest common subsequence. */\n    private int lcsLength;\n\n    /** Number of modifications. */\n    private int modifications;\n\n    /**\n     * Simple constructor. Creates a new empty script.\n     */\n    public EditScript() {\n        commands = new ArrayList<>();\n        lcsLength = 0;\n        modifications = 0;\n    }\n\n    /**\n     * Add a delete command to the script.\n     *\n     * @param command  command to add\n     */\n    public void append(final DeleteCommand<T> command) {\n        commands.add(command);\n        ++modifications;\n    }\n\n    /**\n     * Add an insert command to the script.\n     *\n     * @param command  command to add\n     */\n    public void append(final InsertCommand<T> command) {\n        commands.add(command);\n        ++modifications;\n    }\n\n    /**\n     * Add a keep command to the script.\n     *\n     * @param command  command to add\n     */\n    public void append(final KeepCommand<T> command) {\n        commands.add(command);\n        ++lcsLength;\n    }\n\n    /**\n     * Gets the length of the Longest Common Subsequence (LCS). The length of the\n     * longest common subsequence is the number of {@link KeepCommand keep\n     * commands} in the script.\n     *\n     * @return length of the Longest Common Subsequence\n     */\n    public int getLCSLength() {\n        return lcsLength;\n    }\n\n    /**\n     * Gets the number of effective modifications. The number of effective\n     * modification is the number of {@link DeleteCommand delete} and\n     * {@link InsertCommand insert} commands in the script.\n     *\n     * @return number of effective modifications\n     */\n    public int getModifications() {\n        return modifications;\n    }\n\n    /**\n     * Visit the script. The script implements the <em>visitor</em> design\n     * pattern, this method is the entry point to which the user supplies its\n     * own visitor, the script will be responsible to drive it through the\n     * commands in order and call the appropriate method as each command is\n     * encountered.\n     *\n     * @param visitor  the visitor that will visit all commands in turn\n     */\n    public void visit(final CommandVisitor<T> visitor) {\n        for (final EditCommand<T> command : commands) {\n            command.accept(visitor);\n        }\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final List<EditCommand<T>> commands;", "docstring": " Container for the commands.", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<EditCommand<T>>", "name": "commands", "syntax_pass": true}, {"attribute_expression": "private int lcsLength;", "docstring": " Length of the longest common subsequence.", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "lcsLength", "syntax_pass": true}, {"attribute_expression": "private int modifications;", "docstring": " Number of modifications.", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "modifications", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/sequence/DeleteCommand.java.DeleteCommand", "name": "DeleteCommand", "file_path": "src/main/java/org/apache/commons/collections4/sequence/DeleteCommand.java", "superclasses": "", "methods": ["[]DeleteCommand(T)", "[void]accept(CommandVisitor<T>)"], "method_uris": ["src/main/java/org/apache/commons/collections4/sequence/DeleteCommand.java.DeleteCommand.[]DeleteCommand(T)", "src/main/java/org/apache/commons/collections4/sequence/DeleteCommand.java.DeleteCommand.[void]accept(CommandVisitor<T>)"], "overrides": null, "attributes": [], "class_docstring": "\nCommand representing the deletion of one object of the first sequence.\n<p>\nWhen one object of the first sequence has no corresponding object in the\nsecond sequence at the right place, the {@link EditScript edit script}\ntransforming the first sequence into the second sequence uses an instance of\nthis class to represent the deletion of this object. The objects embedded in\nthese type of commands always come from the first sequence.\n</p>\n\n@param <T> the type of object to apply this command.\n@see SequencesComparator\n@see EditScript\n@since 4.0\n", "original_string": "public class DeleteCommand<T> extends EditCommand<T> {\n\n    /**\n     * Simple constructor. Creates a new instance of {@link DeleteCommand}.\n     *\n     * @param object  the object of the first sequence that should be deleted\n     */\n    public DeleteCommand(final T object) {\n        super(object);\n    }\n\n    /**\n     * Accept a visitor. When a {@code DeleteCommand} accepts a visitor, it calls\n     * its {@link CommandVisitor#visitDeleteCommand visitDeleteCommand} method.\n     *\n     * @param visitor  the visitor to be accepted\n     */\n    @Override\n    public void accept(final CommandVisitor<T> visitor) {\n        visitor.visitDeleteCommand(getObject());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/org/apache/commons/collections4/sequence/KeepCommand.java.KeepCommand", "name": "KeepCommand", "file_path": "src/main/java/org/apache/commons/collections4/sequence/KeepCommand.java", "superclasses": "", "methods": ["[]KeepCommand(T)", "[void]accept(CommandVisitor<T>)"], "method_uris": ["src/main/java/org/apache/commons/collections4/sequence/KeepCommand.java.KeepCommand.[]KeepCommand(T)", "src/main/java/org/apache/commons/collections4/sequence/KeepCommand.java.KeepCommand.[void]accept(CommandVisitor<T>)"], "overrides": null, "attributes": [], "class_docstring": "\nCommand representing the keeping of one object present in both sequences.\n<p>\nWhen one object of the first sequence {@code equals} another objects in\nthe second sequence at the right place, the {@link EditScript edit script}\ntransforming the first sequence into the second sequence uses an instance of\nthis class to represent the keeping of this object. The objects embedded in\nthese type of commands always come from the first sequence.\n</p>\n\n@param <T> the type of object to apply this command.\n@see SequencesComparator\n@see EditScript\n@since 4.0\n", "original_string": "public class KeepCommand<T> extends EditCommand<T> {\n\n    /**\n     * Simple constructor. Creates a new instance of KeepCommand\n     *\n     * @param object  the object belonging to both sequences (the object is a\n     *   reference to the instance in the first sequence which is known\n     *   to be equal to an instance in the second sequence)\n     */\n    public KeepCommand(final T object) {\n        super(object);\n    }\n\n    /**\n     * Accept a visitor. When a {@code KeepCommand} accepts a visitor, it\n     * calls its {@link CommandVisitor#visitKeepCommand visitKeepCommand} method.\n     *\n     * @param visitor  the visitor to be accepted\n     */\n    @Override\n    public void accept(final CommandVisitor<T> visitor) {\n        visitor.visitKeepCommand(getObject());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/org/apache/commons/collections4/functors/ChainedClosure.java.ChainedClosure", "name": "ChainedClosure", "file_path": "src/main/java/org/apache/commons/collections4/functors/ChainedClosure.java", "superclasses": "", "methods": ["[Closure<E>]chainedClosure()", "[Closure<E>]chainedClosure(Collection<? extends Closure<? super E>>)", "[]ChainedClosure(boolean)", "[]ChainedClosure()", "[void]execute(T)", "[Closure<? super T>[]]getClosures()"], "method_uris": ["src/main/java/org/apache/commons/collections4/functors/ChainedClosure.java.ChainedClosure.[Closure<E>]chainedClosure()", "src/main/java/org/apache/commons/collections4/functors/ChainedClosure.java.ChainedClosure.[Closure<E>]chainedClosure(Collection<? extends Closure<? super E>>)", "src/main/java/org/apache/commons/collections4/functors/ChainedClosure.java.ChainedClosure.[]ChainedClosure(boolean)", "src/main/java/org/apache/commons/collections4/functors/ChainedClosure.java.ChainedClosure.[]ChainedClosure()", "src/main/java/org/apache/commons/collections4/functors/ChainedClosure.java.ChainedClosure.[void]execute(T)", "src/main/java/org/apache/commons/collections4/functors/ChainedClosure.java.ChainedClosure.[Closure<? super T>[]]getClosures()"], "overrides": null, "attributes": [], "class_docstring": "\nClosure implementation that chains the specified closures together.\n\n@param <T> the type of the input to the operation.\n@since 3.0\n", "original_string": "public class ChainedClosure<T> implements Closure<T>, Serializable {\n\n    /** Serial version UID */\n    private static final long serialVersionUID = -3520677225766901240L;\n\n    /**\n     * Factory method that performs validation and copies the parameter array.\n     *\n     * @param <E> the type that the closure acts on\n     * @param closures  the closures to chain, copied, no nulls\n     * @return the {@code chained} closure\n     * @throws NullPointerException if the closures array is null\n     * @throws NullPointerException if any closure in the array is null\n     */\n    public static <E> Closure<E> chainedClosure(final Closure<? super E>... closures) {\n        FunctorUtils.validate(closures);\n        if (closures.length == 0) {\n            return NOPClosure.<E>nopClosure();\n        }\n        return new ChainedClosure<>(closures);\n    }\n\n    /**\n     * Create a new Closure that calls each closure in turn, passing the\n     * result into the next closure. The ordering is that of the iterator()\n     * method on the collection.\n     *\n     * @param <E> the type that the closure acts on\n     * @param closures  a collection of closures to chain\n     * @return the {@code chained} closure\n     * @throws NullPointerException if the closures collection is null\n     * @throws NullPointerException if any closure in the collection is null\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static <E> Closure<E> chainedClosure(final Collection<? extends Closure<? super E>> closures) {\n        Objects.requireNonNull(closures, \"closures\");\n        if (closures.isEmpty()) {\n            return NOPClosure.<E>nopClosure();\n        }\n        // convert to array like this to guarantee iterator() ordering\n        final Closure<? super E>[] cmds = new Closure[closures.size()];\n        int i = 0;\n        for (final Closure<? super E> closure : closures) {\n            cmds[i++] = closure;\n        }\n        FunctorUtils.validate(cmds);\n        return new ChainedClosure<>(false, cmds);\n    }\n\n    /** The closures to call in turn */\n    private final Closure<? super T>[] iClosures;\n\n    /**\n     * Hidden constructor for the use by the static factory methods.\n     *\n     * @param clone  if {@code true} the input argument will be cloned\n     * @param closures  the closures to chain, no nulls\n     */\n    private ChainedClosure(final boolean clone, final Closure<? super T>... closures) {\n        iClosures = clone ? FunctorUtils.copy(closures) : closures;\n    }\n\n    /**\n     * Constructor that performs no validation.\n     * Use {@code chainedClosure} if you want that.\n     *\n     * @param closures  the closures to chain, copied, no nulls\n     */\n    public ChainedClosure(final Closure<? super T>... closures) {\n        this(true, closures);\n    }\n\n    /**\n     * Execute a list of closures.\n     *\n     * @param input  the input object passed to each closure\n     */\n    @Override\n    public void execute(final T input) {\n        for (final Closure<? super T> iClosure : iClosures) {\n            iClosure.accept(input);\n        }\n    }\n\n    /**\n     * Gets the closures.\n     *\n     * @return a copy of the closures\n     * @since 3.1\n     */\n    public Closure<? super T>[] getClosures() {\n        return FunctorUtils.copy(iClosures);\n    }\n\n}", "super_interfaces": ["Closure<T>", "Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = -3520677225766901240L;", "docstring": " Serial version UID", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -3520677225766901240L", "syntax_pass": true}, {"attribute_expression": "private final Closure<? super T>[] iClosures;", "docstring": " The closures to call in turn", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Closure<? super T>[]", "name": "iClosures", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/functors/ExceptionPredicate.java.ExceptionPredicate", "name": "ExceptionPredicate", "file_path": "src/main/java/org/apache/commons/collections4/functors/ExceptionPredicate.java", "superclasses": "", "methods": ["[Predicate<T>]exceptionPredicate()", "[]ExceptionPredicate()", "[Object]readResolve()", "[boolean]test(T)"], "method_uris": ["src/main/java/org/apache/commons/collections4/functors/ExceptionPredicate.java.ExceptionPredicate.[Predicate<T>]exceptionPredicate()", "src/main/java/org/apache/commons/collections4/functors/ExceptionPredicate.java.ExceptionPredicate.[]ExceptionPredicate()", "src/main/java/org/apache/commons/collections4/functors/ExceptionPredicate.java.ExceptionPredicate.[Object]readResolve()", "src/main/java/org/apache/commons/collections4/functors/ExceptionPredicate.java.ExceptionPredicate.[boolean]test(T)"], "overrides": null, "attributes": [], "class_docstring": "\nPredicate implementation that always throws an exception.\n\n@param <T> the type of the input to the predicate.\n@since 3.0\n", "original_string": "public final class ExceptionPredicate<T> extends AbstractPredicate<T> implements Serializable {\n\n    /** Serial version UID */\n    private static final long serialVersionUID = 7179106032121985545L;\n\n    /** Singleton predicate instance */\n    @SuppressWarnings(\"rawtypes\") // the static instance works for all types\n    public static final Predicate INSTANCE = new ExceptionPredicate<>();\n\n    /**\n     * Factory returning the singleton instance.\n     *\n     * @param <T>  the object type\n     * @return the singleton instance\n     * @since 3.1\n     */\n    public static <T> Predicate<T> exceptionPredicate() {\n        return INSTANCE;\n    }\n\n    /**\n     * Restricted constructor.\n     */\n    private ExceptionPredicate() {\n    }\n\n    /**\n     * Returns the singleton instance.\n     *\n     * @return the singleton instance.\n     */\n    private Object readResolve() {\n        return INSTANCE;\n    }\n\n    /**\n     * Evaluates the predicate always throwing an exception.\n     *\n     * @param object  the input object\n     * @return never\n     * @throws FunctorException always\n     */\n    @Override\n    public boolean test(final T object) {\n        throw new FunctorException(\"ExceptionPredicate invoked\");\n    }\n\n}", "super_interfaces": ["Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 7179106032121985545L;", "docstring": " Serial version UID", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 7179106032121985545L", "syntax_pass": true}, {"attribute_expression": "@SuppressWarnings(\"rawtypes\") // the static instance works for all types\n    public static final Predicate INSTANCE = new ExceptionPredicate<>();", "docstring": " Singleton predicate instance", "modifiers": "@SuppressWarnings(\"rawtypes\") // the static instance works for all types\n    public static final", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"rawtypes\")", "public", "static", "final"], "comments": ["// the static instance works for all types"], "type": "Predicate", "name": "INSTANCE = new ExceptionPredicate<>()", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/functors/DefaultEquator.java.DefaultEquator", "name": "DefaultEquator", "file_path": "src/main/java/org/apache/commons/collections4/functors/DefaultEquator.java", "superclasses": "", "methods": ["[DefaultEquator<T>]defaultEquator()", "[]DefaultEquator()", "[boolean]equate(T,T)", "[int]hash(T)", "[Object]readResolve()"], "method_uris": ["src/main/java/org/apache/commons/collections4/functors/DefaultEquator.java.DefaultEquator.[DefaultEquator<T>]defaultEquator()", "src/main/java/org/apache/commons/collections4/functors/DefaultEquator.java.DefaultEquator.[]DefaultEquator()", "src/main/java/org/apache/commons/collections4/functors/DefaultEquator.java.DefaultEquator.[boolean]equate(T,T)", "src/main/java/org/apache/commons/collections4/functors/DefaultEquator.java.DefaultEquator.[int]hash(T)", "src/main/java/org/apache/commons/collections4/functors/DefaultEquator.java.DefaultEquator.[Object]readResolve()"], "overrides": null, "attributes": [], "class_docstring": "\nDefault {@link Equator} implementation.\n\n@param <T>  the types of object this {@link Equator} can evaluate.\n@since 4.0\n", "original_string": "public class DefaultEquator<T> implements Equator<T>, Serializable {\n\n    /** Serial version UID */\n    private static final long serialVersionUID = 825802648423525485L;\n\n    /** Static instance */\n    @SuppressWarnings(\"rawtypes\") // the static instance works for all types\n    public static final DefaultEquator INSTANCE = new DefaultEquator<>();\n\n    /**\n     * Hashcode used for {@code null} objects.\n     */\n    public static final int HASHCODE_NULL = -1;\n\n    /**\n     * Factory returning the typed singleton instance.\n     *\n     * @param <T>  the object type\n     * @return the singleton instance\n     */\n    public static <T> DefaultEquator<T> defaultEquator() {\n        return INSTANCE;\n    }\n\n    /**\n     * Restricted constructor.\n     */\n    private DefaultEquator() {\n    }\n\n    /**\n     * {@inheritDoc} Delegates to {@link Objects#equals(Object, Object)}.\n     */\n    @Override\n    public boolean equate(final T o1, final T o2) {\n        return Objects.equals(o1, o2);\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * @return {@code o.hashCode()} if {@code o} is non-\n     *         {@code null}, else {@link #HASHCODE_NULL}.\n     */\n    @Override\n    public int hash(final T o) {\n        return o == null ? HASHCODE_NULL : o.hashCode();\n    }\n\n    /**\n     * Returns the singleton instance.\n     *\n     * @return the singleton instance.\n     */\n    private Object readResolve() {\n        return INSTANCE;\n    }\n\n}", "super_interfaces": ["Equator<T>", "Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 825802648423525485L;", "docstring": " Serial version UID", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 825802648423525485L", "syntax_pass": true}, {"attribute_expression": "@SuppressWarnings(\"rawtypes\") // the static instance works for all types\n    public static final DefaultEquator INSTANCE = new DefaultEquator<>();", "docstring": " Static instance", "modifiers": "@SuppressWarnings(\"rawtypes\") // the static instance works for all types\n    public static final", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"rawtypes\")", "public", "static", "final"], "comments": ["// the static instance works for all types"], "type": "DefaultEquator", "name": "INSTANCE = new DefaultEquator<>()", "syntax_pass": true}, {"attribute_expression": "public static final int HASHCODE_NULL = -1;", "docstring": "\nHashcode used for {@code null} objects.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "int", "name": "HASHCODE_NULL = -1", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/functors/ChainedTransformer.java.ChainedTransformer", "name": "ChainedTransformer", "file_path": "src/main/java/org/apache/commons/collections4/functors/ChainedTransformer.java", "superclasses": "", "methods": ["[Transformer<T, T>]chainedTransformer(Collection<? extends Transformer<? super T, ? extends T>>)", "[Transformer<T, T>]chainedTransformer()", "[]ChainedTransformer(boolean,Transformer<? super T, ? extends T>[])", "[]ChainedTransformer()", "[Transformer<? super T, ? extends T>[]]getTransformers()", "[T]transform(T)"], "method_uris": ["src/main/java/org/apache/commons/collections4/functors/ChainedTransformer.java.ChainedTransformer.[Transformer<T, T>]chainedTransformer(Collection<? extends Transformer<? super T, ? extends T>>)", "src/main/java/org/apache/commons/collections4/functors/ChainedTransformer.java.ChainedTransformer.[Transformer<T, T>]chainedTransformer()", "src/main/java/org/apache/commons/collections4/functors/ChainedTransformer.java.ChainedTransformer.[]ChainedTransformer(boolean,Transformer<? super T, ? extends T>[])", "src/main/java/org/apache/commons/collections4/functors/ChainedTransformer.java.ChainedTransformer.[]ChainedTransformer()", "src/main/java/org/apache/commons/collections4/functors/ChainedTransformer.java.ChainedTransformer.[Transformer<? super T, ? extends T>[]]getTransformers()", "src/main/java/org/apache/commons/collections4/functors/ChainedTransformer.java.ChainedTransformer.[T]transform(T)"], "overrides": null, "attributes": [], "class_docstring": "\nTransformer implementation that chains the specified transformers together.\n<p>\nThe input object is passed to the first transformer. The transformed result\nis passed to the second transformer and so on.\n</p>\n\n@param <T> the type of the input and result to the function.\n@since 3.0\n", "original_string": "public class ChainedTransformer<T> implements Transformer<T, T>, Serializable {\n\n    private static final Transformer[] EMPTY_TRANSFORMER_ARRAY = {};\n\n    /** Serial version UID */\n    private static final long serialVersionUID = 3514945074733160196L;\n\n    /**\n     * Create a new Transformer that calls each transformer in turn, passing the\n     * result into the next transformer. The ordering is that of the iterator()\n     * method on the collection.\n     *\n     * @param <T>  the object type\n     * @param transformers  a collection of transformers to chain\n     * @return the {@code chained} transformer\n     * @throws NullPointerException if the transformers collection is null\n     * @throws NullPointerException if any transformer in the collection is null\n     */\n    public static <T> Transformer<T, T> chainedTransformer(\n            final Collection<? extends Transformer<? super T, ? extends T>> transformers) {\n        Objects.requireNonNull(transformers, \"transformers\");\n        if (transformers.isEmpty()) {\n            return NOPTransformer.<T>nopTransformer();\n        }\n        // convert to array like this to guarantee iterator() ordering\n        final Transformer<T, T>[] cmds = transformers.toArray(EMPTY_TRANSFORMER_ARRAY);\n        FunctorUtils.validate(cmds);\n        return new ChainedTransformer<>(false, cmds);\n    }\n\n    /**\n     * Factory method that performs validation and copies the parameter array.\n     *\n     * @param <T>  the object type\n     * @param transformers  the transformers to chain, copied, no nulls\n     * @return the {@code chained} transformer\n     * @throws NullPointerException if the transformers array is null\n     * @throws NullPointerException if any transformer in the array is null\n     */\n    public static <T> Transformer<T, T> chainedTransformer(final Transformer<? super T, ? extends T>... transformers) {\n        FunctorUtils.validate(transformers);\n        if (transformers.length == 0) {\n            return NOPTransformer.<T>nopTransformer();\n        }\n        return new ChainedTransformer<>(transformers);\n    }\n\n    /** The transformers to call in turn */\n    private final Transformer<? super T, ? extends T>[] iTransformers;\n\n    /**\n     * Hidden constructor for the use by the static factory methods.\n     *\n     * @param clone  if {@code true} the input argument will be cloned\n     * @param transformers  the transformers to chain, no nulls\n     */\n    private ChainedTransformer(final boolean clone, final Transformer<? super T, ? extends T>[] transformers) {\n        iTransformers = clone ? FunctorUtils.copy(transformers) : transformers;\n    }\n\n    /**\n     * Constructor that performs no validation.\n     * Use {@code chainedTransformer} if you want that.\n     *\n     * @param transformers  the transformers to chain, copied, no nulls\n     */\n    public ChainedTransformer(final Transformer<? super T, ? extends T>... transformers) {\n        this(true, transformers);\n    }\n\n    /**\n     * Gets the transformers.\n     *\n     * @return a copy of the transformers\n     * @since 3.1\n     */\n    public Transformer<? super T, ? extends T>[] getTransformers() {\n        return FunctorUtils.copy(iTransformers);\n    }\n\n    /**\n     * Transforms the input to result via each decorated transformer\n     *\n     * @param object  the input object passed to the first transformer\n     * @return the transformed result\n     */\n    @Override\n    public T transform(T object) {\n        for (final Transformer<? super T, ? extends T> iTransformer : iTransformers) {\n            object = iTransformer.apply(object);\n        }\n        return object;\n    }\n\n}", "super_interfaces": ["Transformer<T, T>", "Serializable"], "fields": [{"attribute_expression": "private static final Transformer[] EMPTY_TRANSFORMER_ARRAY = {};", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Transformer[]", "name": "EMPTY_TRANSFORMER_ARRAY = {}", "syntax_pass": true}, {"attribute_expression": "private static final long serialVersionUID = 3514945074733160196L;", "docstring": " Serial version UID", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 3514945074733160196L", "syntax_pass": true}, {"attribute_expression": "private final Transformer<? super T, ? extends T>[] iTransformers;", "docstring": " The transformers to call in turn", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Transformer<? super T, ? extends T>[]", "name": "iTransformers", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/functors/PrototypeFactory.java.PrototypeFactory", "name": "PrototypeFactory", "file_path": "src/main/java/org/apache/commons/collections4/functors/PrototypeFactory.java", "superclasses": "", "methods": ["[Factory<T>]prototypeFactory(T)", "[]PrototypeFactory()"], "method_uris": ["src/main/java/org/apache/commons/collections4/functors/PrototypeFactory.java.PrototypeFactory.[Factory<T>]prototypeFactory(T)", "src/main/java/org/apache/commons/collections4/functors/PrototypeFactory.java.PrototypeFactory.[]PrototypeFactory()"], "overrides": null, "attributes": [{"original_string": "    static class PrototypeCloneFactory<T> implements Factory<T> {\n\n        /** The object to clone each time */\n        private final T iPrototype;\n        /** The method used to clone */\n        private transient Method iCloneMethod;\n\n        /**\n         * Constructor to store prototype.\n         */\n        private PrototypeCloneFactory(final T prototype, final Method method) {\n            iPrototype = prototype;\n            iCloneMethod = method;\n        }\n\n        /**\n         * Creates an object by calling the clone method.\n         *\n         * @return the new object\n         */\n        @Override\n        @SuppressWarnings(\"unchecked\")\n        public T create() {\n            // needed for post-serialization\n            if (iCloneMethod == null) {\n                findCloneMethod();\n            }\n\n            try {\n                return (T) iCloneMethod.invoke(iPrototype, (Object[]) null);\n            } catch (final IllegalAccessException ex) {\n                throw new FunctorException(\"PrototypeCloneFactory: Clone method must be public\", ex);\n            } catch (final InvocationTargetException ex) {\n                throw new FunctorException(\"PrototypeCloneFactory: Clone method threw an exception\", ex);\n            }\n        }\n\n        /**\n         * Find the Clone method for the class specified.\n         */\n        private void findCloneMethod() {\n            try {\n                iCloneMethod = iPrototype.getClass().getMethod(\"clone\", (Class[]) null);\n            } catch (final NoSuchMethodException ex) {\n                throw new IllegalArgumentException(\"PrototypeCloneFactory: The clone method must exist and be public \");\n            }\n        }\n    }", "definition": "    static class PrototypeCloneFactory<T> implements Factory<T>", "class_docstring": "\nPrototypeCloneFactory creates objects by copying a prototype using the clone method.\n\n@param <T> the type of results supplied by this supplier.\n", "name": "PrototypeCloneFactory", "super_interfaces": ["Factory<T>"], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "private final T iPrototype;", "docstring": " The object to clone each time", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "T", "name": "iPrototype", "syntax_pass": true}, {"attribute_expression": "private transient Method iCloneMethod;", "docstring": " The method used to clone", "modifiers": "private transient", "marker_annotations": [], "non_marker_annotations": ["private", "transient"], "comments": [], "type": "Method", "name": "iCloneMethod", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        private PrototypeCloneFactory(final T prototype, final Method method) {\n            iPrototype = prototype;\n            iCloneMethod = method;\n        }", "docstring": "\nConstructor to store prototype.\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "PrototypeCloneFactory", "params": [{"name": "prototype", "type": "T"}, {"name": "method", "type": "Method"}], "body": "                                                                              {\n            iPrototype = prototype;\n            iCloneMethod = method;\n        }", "signature": "private PrototypeCloneFactory(final T prototype, final Method method)"}, {"syntax_pass": true, "original_string": "        @Override\n        @SuppressWarnings(\"unchecked\")\n        public T create() {\n            // needed for post-serialization\n            if (iCloneMethod == null) {\n                findCloneMethod();\n            }\n\n            try {\n                return (T) iCloneMethod.invoke(iPrototype, (Object[]) null);\n            } catch (final IllegalAccessException ex) {\n                throw new FunctorException(\"PrototypeCloneFactory: Clone method must be public\", ex);\n            } catch (final InvocationTargetException ex) {\n                throw new FunctorException(\"PrototypeCloneFactory: Clone method threw an exception\", ex);\n            }\n        }", "docstring": "\nCreates an object by calling the clone method.\n\n@return the new object\n", "attributes": {"modifiers": "@Override\n        @SuppressWarnings(\"unchecked\")\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "T", "classes": []}, "name": "create", "params": [], "body": "                          {\n            // needed for post-serialization\n            if (iCloneMethod == null) {\n                findCloneMethod();\n            }\n\n            try {\n                return (T) iCloneMethod.invoke(iPrototype, (Object[]) null);\n            } catch (final IllegalAccessException ex) {\n                throw new FunctorException(\"PrototypeCloneFactory: Clone method must be public\", ex);\n            } catch (final InvocationTargetException ex) {\n                throw new FunctorException(\"PrototypeCloneFactory: Clone method threw an exception\", ex);\n            }\n        }", "signature": "@Override\n        @SuppressWarnings(\"unchecked\")\n        public T create()"}, {"syntax_pass": true, "original_string": "        private void findCloneMethod() {\n            try {\n                iCloneMethod = iPrototype.getClass().getMethod(\"clone\", (Class[]) null);\n            } catch (final NoSuchMethodException ex) {\n                throw new IllegalArgumentException(\"PrototypeCloneFactory: The clone method must exist and be public \");\n            }\n        }", "docstring": "\nFind the Clone method for the class specified.\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "findCloneMethod", "params": [], "body": "                                       {\n            try {\n                iCloneMethod = iPrototype.getClass().getMethod(\"clone\", (Class[]) null);\n            } catch (final NoSuchMethodException ex) {\n                throw new IllegalArgumentException(\"PrototypeCloneFactory: The clone method must exist and be public \");\n            }\n        }", "signature": "private void findCloneMethod()"}]}, {"original_string": "    static class PrototypeSerializationFactory<T extends Serializable> implements Factory<T> {\n\n        /** The object to clone via serialization each time */\n        private final T iPrototype;\n\n        /**\n         * Constructor to store prototype\n         */\n        private PrototypeSerializationFactory(final T prototype) {\n            iPrototype = prototype;\n        }\n\n        /**\n         * Creates an object using serialization.\n         *\n         * @return the new object\n         */\n        @Override\n        @SuppressWarnings(\"unchecked\")\n        public T create() {\n            final ByteArrayOutputStream baos = new ByteArrayOutputStream(512);\n            ByteArrayInputStream bais = null;\n            try {\n                final ObjectOutputStream out = new ObjectOutputStream(baos);\n                out.writeObject(iPrototype);\n\n                bais = new ByteArrayInputStream(baos.toByteArray());\n                final ObjectInputStream in = new ObjectInputStream(bais);\n                return (T) in.readObject();\n\n            } catch (final ClassNotFoundException | IOException ex) {\n                throw new FunctorException(ex);\n            } finally {\n                try {\n                    if (bais != null) {\n                        bais.close();\n                    }\n                } catch (final IOException ex) { //NOPMD\n                    // ignore\n                }\n                try {\n                    baos.close();\n                } catch (final IOException ex) { //NOPMD\n                    // ignore\n                }\n            }\n        }\n    }", "definition": "    static class PrototypeSerializationFactory<T extends Serializable> implements Factory<T>", "class_docstring": "\nPrototypeSerializationFactory creates objects by cloning a prototype using serialization.\n\n@param <T> the type of results supplied by this supplier.\n", "name": "PrototypeSerializationFactory", "super_interfaces": ["Factory<T>"], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "private final T iPrototype;", "docstring": " The object to clone via serialization each time", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "T", "name": "iPrototype", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        private PrototypeSerializationFactory(final T prototype) {\n            iPrototype = prototype;\n        }", "docstring": "\nConstructor to store prototype\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "PrototypeSerializationFactory", "params": [{"name": "prototype", "type": "T"}], "body": "                                                                 {\n            iPrototype = prototype;\n        }", "signature": "private PrototypeSerializationFactory(final T prototype)"}, {"syntax_pass": true, "original_string": "        @Override\n        @SuppressWarnings(\"unchecked\")\n        public T create() {\n            final ByteArrayOutputStream baos = new ByteArrayOutputStream(512);\n            ByteArrayInputStream bais = null;\n            try {\n                final ObjectOutputStream out = new ObjectOutputStream(baos);\n                out.writeObject(iPrototype);\n\n                bais = new ByteArrayInputStream(baos.toByteArray());\n                final ObjectInputStream in = new ObjectInputStream(bais);\n                return (T) in.readObject();\n\n            } catch (final ClassNotFoundException | IOException ex) {\n                throw new FunctorException(ex);\n            } finally {\n                try {\n                    if (bais != null) {\n                        bais.close();\n                    }\n                } catch (final IOException ex) { //NOPMD\n                    // ignore\n                }\n                try {\n                    baos.close();\n                } catch (final IOException ex) { //NOPMD\n                    // ignore\n                }\n            }\n        }", "docstring": "\nCreates an object using serialization.\n\n@return the new object\n", "attributes": {"modifiers": "@Override\n        @SuppressWarnings(\"unchecked\")\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "T", "classes": []}, "name": "create", "params": [], "body": "                          {\n            final ByteArrayOutputStream baos = new ByteArrayOutputStream(512);\n            ByteArrayInputStream bais = null;\n            try {\n                final ObjectOutputStream out = new ObjectOutputStream(baos);\n                out.writeObject(iPrototype);\n\n                bais = new ByteArrayInputStream(baos.toByteArray());\n                final ObjectInputStream in = new ObjectInputStream(bais);\n                return (T) in.readObject();\n\n            } catch (final ClassNotFoundException | IOException ex) {\n                throw new FunctorException(ex);\n            } finally {\n                try {\n                    if (bais != null) {\n                        bais.close();\n                    }\n                } catch (final IOException ex) { //NOPMD\n                    // ignore\n                }\n                try {\n                    baos.close();\n                } catch (final IOException ex) { //NOPMD\n                    // ignore\n                }\n            }\n        }", "signature": "@Override\n        @SuppressWarnings(\"unchecked\")\n        public T create()"}]}], "class_docstring": "\nFactory implementation that creates a new instance each time based on a prototype.\n<p>\n<b>WARNING:</b> from v4.1 onwards {@link Factory} instances returned by\n{@link #prototypeFactory(Object)} will <b>not</b> be serializable anymore in order\nto prevent potential remote code execution exploits. Please refer to\n<a href=\"https://issues.apache.org/jira/browse/COLLECTIONS-580\">COLLECTIONS-580</a>\nfor more details.\n</p>\n\n@since 3.0\n", "original_string": "public class PrototypeFactory {\n\n    /**\n     * PrototypeCloneFactory creates objects by copying a prototype using the clone method.\n     *\n     * @param <T> the type of results supplied by this supplier.\n     */\n    static class PrototypeCloneFactory<T> implements Factory<T> {\n\n        /** The object to clone each time */\n        private final T iPrototype;\n        /** The method used to clone */\n        private transient Method iCloneMethod;\n\n        /**\n         * Constructor to store prototype.\n         */\n        private PrototypeCloneFactory(final T prototype, final Method method) {\n            iPrototype = prototype;\n            iCloneMethod = method;\n        }\n\n        /**\n         * Creates an object by calling the clone method.\n         *\n         * @return the new object\n         */\n        @Override\n        @SuppressWarnings(\"unchecked\")\n        public T create() {\n            // needed for post-serialization\n            if (iCloneMethod == null) {\n                findCloneMethod();\n            }\n\n            try {\n                return (T) iCloneMethod.invoke(iPrototype, (Object[]) null);\n            } catch (final IllegalAccessException ex) {\n                throw new FunctorException(\"PrototypeCloneFactory: Clone method must be public\", ex);\n            } catch (final InvocationTargetException ex) {\n                throw new FunctorException(\"PrototypeCloneFactory: Clone method threw an exception\", ex);\n            }\n        }\n\n        /**\n         * Find the Clone method for the class specified.\n         */\n        private void findCloneMethod() {\n            try {\n                iCloneMethod = iPrototype.getClass().getMethod(\"clone\", (Class[]) null);\n            } catch (final NoSuchMethodException ex) {\n                throw new IllegalArgumentException(\"PrototypeCloneFactory: The clone method must exist and be public \");\n            }\n        }\n    }\n\n    /**\n     * PrototypeSerializationFactory creates objects by cloning a prototype using serialization.\n     *\n     * @param <T> the type of results supplied by this supplier.\n     */\n    static class PrototypeSerializationFactory<T extends Serializable> implements Factory<T> {\n\n        /** The object to clone via serialization each time */\n        private final T iPrototype;\n\n        /**\n         * Constructor to store prototype\n         */\n        private PrototypeSerializationFactory(final T prototype) {\n            iPrototype = prototype;\n        }\n\n        /**\n         * Creates an object using serialization.\n         *\n         * @return the new object\n         */\n        @Override\n        @SuppressWarnings(\"unchecked\")\n        public T create() {\n            final ByteArrayOutputStream baos = new ByteArrayOutputStream(512);\n            ByteArrayInputStream bais = null;\n            try {\n                final ObjectOutputStream out = new ObjectOutputStream(baos);\n                out.writeObject(iPrototype);\n\n                bais = new ByteArrayInputStream(baos.toByteArray());\n                final ObjectInputStream in = new ObjectInputStream(bais);\n                return (T) in.readObject();\n\n            } catch (final ClassNotFoundException | IOException ex) {\n                throw new FunctorException(ex);\n            } finally {\n                try {\n                    if (bais != null) {\n                        bais.close();\n                    }\n                } catch (final IOException ex) { //NOPMD\n                    // ignore\n                }\n                try {\n                    baos.close();\n                } catch (final IOException ex) { //NOPMD\n                    // ignore\n                }\n            }\n        }\n    }\n\n    /**\n     * Factory method that performs validation.\n     * <p>\n     * Creates a Factory that will return a clone of the same prototype object\n     * each time the factory is used. The prototype will be cloned using one of these\n     * techniques (in order):\n     * </p>\n     *\n     * <ul>\n     * <li>public clone method</li>\n     * <li>public copy constructor</li>\n     * <li>serialization clone</li>\n     * </ul>\n     *\n     * @param <T>  the type the factory creates\n     * @param prototype  the object to clone each time in the factory\n     * @return the {@code prototype} factory, or a {@link ConstantFactory#NULL_INSTANCE} if\n     * the {@code prototype} is {@code null}\n     * @throws IllegalArgumentException if the prototype cannot be cloned\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static <T> Factory<T> prototypeFactory(final T prototype) {\n        if (prototype == null) {\n            return ConstantFactory.<T>constantFactory(null);\n        }\n        try {\n            final Method method = prototype.getClass().getMethod(\"clone\", (Class[]) null);\n            return new PrototypeCloneFactory<>(prototype, method);\n\n        } catch (final NoSuchMethodException ex) {\n            try {\n                prototype.getClass().getConstructor(prototype.getClass());\n                return new InstantiateFactory<>(\n                    (Class<T>) prototype.getClass(),\n                    new Class<?>[] { prototype.getClass() },\n                    new Object[] { prototype });\n            } catch (final NoSuchMethodException ex2) {\n                if (prototype instanceof Serializable) {\n                    return (Factory<T>) new PrototypeSerializationFactory<>((Serializable) prototype);\n                }\n            }\n        }\n        throw new IllegalArgumentException(\"The prototype must be cloneable via a public clone method\");\n    }\n\n    /**\n     * Restricted constructor.\n     */\n    private PrototypeFactory() {\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/org/apache/commons/collections4/functors/WhileClosure.java.WhileClosure", "name": "WhileClosure", "file_path": "src/main/java/org/apache/commons/collections4/functors/WhileClosure.java", "superclasses": "", "methods": ["[Closure<E>]whileClosure(Predicate<? super E>,Closure<? super E>,boolean)", "[]WhileClosure(Predicate<? super T>,Closure<? super T>,boolean)", "[void]execute(T)", "[Closure<? super T>]getClosure()", "[Predicate<? super T>]getPredicate()", "[boolean]isDoLoop()"], "method_uris": ["src/main/java/org/apache/commons/collections4/functors/WhileClosure.java.WhileClosure.[Closure<E>]whileClosure(Predicate<? super E>,Closure<? super E>,boolean)", "src/main/java/org/apache/commons/collections4/functors/WhileClosure.java.WhileClosure.[]WhileClosure(Predicate<? super T>,Closure<? super T>,boolean)", "src/main/java/org/apache/commons/collections4/functors/WhileClosure.java.WhileClosure.[void]execute(T)", "src/main/java/org/apache/commons/collections4/functors/WhileClosure.java.WhileClosure.[Closure<? super T>]getClosure()", "src/main/java/org/apache/commons/collections4/functors/WhileClosure.java.WhileClosure.[Predicate<? super T>]getPredicate()", "src/main/java/org/apache/commons/collections4/functors/WhileClosure.java.WhileClosure.[boolean]isDoLoop()"], "overrides": null, "attributes": [], "class_docstring": "\nClosure implementation that executes a closure repeatedly until a condition is met,\nlike a do-while or while loop.\n<p>\n<b>WARNING:</b> from v4.1 onwards this class will <b>not</b> be serializable anymore\nin order to prevent potential remote code execution exploits. Please refer to\n<a href=\"https://issues.apache.org/jira/browse/COLLECTIONS-580\">COLLECTIONS-580</a>\nfor more details.\n</p>\n\n@param <T> the type of the input to the operation.\n@since 3.0\n", "original_string": "public class WhileClosure<T> implements Closure<T> {\n\n    /**\n     * Factory method that performs validation.\n     *\n     * @param <E> the type that the closure acts on\n     * @param predicate  the predicate used to evaluate when the loop terminates, not null\n     * @param closure  the closure to execute, not null\n     * @param doLoop  true to act as a do-while loop, always executing the closure once\n     * @return the {@code while} closure\n     * @throws NullPointerException if the predicate or closure is null\n     */\n    public static <E> Closure<E> whileClosure(final Predicate<? super E> predicate,\n                                              final Closure<? super E> closure, final boolean doLoop) {\n        return new WhileClosure<>(Objects.requireNonNull(predicate, \"predicate\"),\n                Objects.requireNonNull(closure, \"closure\"), doLoop);\n    }\n    /** The test condition */\n    private final Predicate<? super T> iPredicate;\n    /** The closure to call */\n    private final Closure<? super T> iClosure;\n\n    /** The flag, true is a do loop, false is a while */\n    private final boolean iDoLoop;\n\n    /**\n     * Constructor that performs no validation.\n     * Use {@code whileClosure} if you want that.\n     *\n     * @param predicate  the predicate used to evaluate when the loop terminates, not null\n     * @param closure  the closure to execute, not null\n     * @param doLoop  true to act as a do-while loop, always executing the closure once\n     */\n    public WhileClosure(final Predicate<? super T> predicate, final Closure<? super T> closure, final boolean doLoop) {\n        iPredicate = predicate;\n        iClosure = closure;\n        iDoLoop = doLoop;\n    }\n\n    /**\n     * Executes the closure until the predicate is false.\n     *\n     * @param input  the input object\n     */\n    @Override\n    public void execute(final T input) {\n        if (iDoLoop) {\n            iClosure.accept(input);\n        }\n        while (iPredicate.test(input)) {\n            iClosure.accept(input);\n        }\n    }\n\n    /**\n     * Gets the closure.\n     *\n     * @return the closure\n     * @since 3.1\n     */\n    public Closure<? super T> getClosure() {\n        return iClosure;\n    }\n\n    /**\n     * Gets the predicate in use.\n     *\n     * @return the predicate\n     * @since 3.1\n     */\n    public Predicate<? super T> getPredicate() {\n        return iPredicate;\n    }\n\n    /**\n     * Is the loop a do-while loop.\n     *\n     * @return true is do-while, false if while\n     * @since 3.1\n     */\n    public boolean isDoLoop() {\n        return iDoLoop;\n    }\n\n}", "super_interfaces": ["Closure<T>"], "fields": [{"attribute_expression": "private final Predicate<? super T> iPredicate;", "docstring": " The test condition", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Predicate<? super T>", "name": "iPredicate", "syntax_pass": true}, {"attribute_expression": "private final Closure<? super T> iClosure;", "docstring": " The closure to call", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Closure<? super T>", "name": "iClosure", "syntax_pass": true}, {"attribute_expression": "private final boolean iDoLoop;", "docstring": " The flag, true is a do loop, false is a while", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "boolean", "name": "iDoLoop", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/functors/ExceptionFactory.java.ExceptionFactory", "name": "ExceptionFactory", "file_path": "src/main/java/org/apache/commons/collections4/functors/ExceptionFactory.java", "superclasses": "", "methods": ["[Factory<T>]exceptionFactory()", "[]ExceptionFactory()", "[T]create()", "[Object]readResolve()"], "method_uris": ["src/main/java/org/apache/commons/collections4/functors/ExceptionFactory.java.ExceptionFactory.[Factory<T>]exceptionFactory()", "src/main/java/org/apache/commons/collections4/functors/ExceptionFactory.java.ExceptionFactory.[]ExceptionFactory()", "src/main/java/org/apache/commons/collections4/functors/ExceptionFactory.java.ExceptionFactory.[T]create()", "src/main/java/org/apache/commons/collections4/functors/ExceptionFactory.java.ExceptionFactory.[Object]readResolve()"], "overrides": null, "attributes": [], "class_docstring": "\nFactory implementation that always throws an exception.\n\n@param <T> the type of results supplied by this supplier.\n@since 3.0\n", "original_string": "public final class ExceptionFactory<T> implements Factory<T>, Serializable {\n\n    /** Serial version UID */\n    private static final long serialVersionUID = 7179106032121985545L;\n\n    /** Singleton predicate instance */\n    @SuppressWarnings(\"rawtypes\") // the static instance works for all types\n    public static final Factory INSTANCE = new ExceptionFactory<>();\n\n    /**\n     * Factory returning the singleton instance.\n     *\n     * @param <T>  the type the factory creates\n     * @return the singleton instance\n     * @since 3.1\n     */\n    public static <T> Factory<T> exceptionFactory() {\n        return INSTANCE;\n    }\n\n    /**\n     * Restricted constructor.\n     */\n    private ExceptionFactory() {\n    }\n\n    /**\n     * Always throws an exception.\n     *\n     * @return never\n     * @throws FunctorException always\n     */\n    @Override\n    public T create() {\n        throw new FunctorException(\"ExceptionFactory invoked\");\n    }\n\n    /**\n     * Returns the singleton instance.\n     *\n     * @return the singleton instance.\n     */\n    private Object readResolve() {\n        return INSTANCE;\n    }\n\n}", "super_interfaces": ["Factory<T>", "Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 7179106032121985545L;", "docstring": " Serial version UID", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 7179106032121985545L", "syntax_pass": true}, {"attribute_expression": "@SuppressWarnings(\"rawtypes\") // the static instance works for all types\n    public static final Factory INSTANCE = new ExceptionFactory<>();", "docstring": " Singleton predicate instance", "modifiers": "@SuppressWarnings(\"rawtypes\") // the static instance works for all types\n    public static final", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"rawtypes\")", "public", "static", "final"], "comments": ["// the static instance works for all types"], "type": "Factory", "name": "INSTANCE = new ExceptionFactory<>()", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/functors/AllPredicate.java.AllPredicate", "name": "AllPredicate", "file_path": "src/main/java/org/apache/commons/collections4/functors/AllPredicate.java", "superclasses": "", "methods": ["[Predicate<T>]allPredicate(Collection<? extends Predicate<? super T>>)", "[Predicate<T>]allPredicate()", "[]AllPredicate()", "[boolean]test(T)"], "method_uris": ["src/main/java/org/apache/commons/collections4/functors/AllPredicate.java.AllPredicate.[Predicate<T>]allPredicate(Collection<? extends Predicate<? super T>>)", "src/main/java/org/apache/commons/collections4/functors/AllPredicate.java.AllPredicate.[Predicate<T>]allPredicate()", "src/main/java/org/apache/commons/collections4/functors/AllPredicate.java.AllPredicate.[]AllPredicate()", "src/main/java/org/apache/commons/collections4/functors/AllPredicate.java.AllPredicate.[boolean]test(T)"], "overrides": null, "attributes": [], "class_docstring": "\nPredicate implementation that returns true if all the\npredicates return true.\nIf the array of predicates is empty, then this predicate returns true.\n<p>\nNOTE: In versions prior to 3.2 an array size of zero or one\nthrew an exception.\n</p>\n\n@param <T> the type of the input to the predicate.\n@since 3.0\n", "original_string": "public final class AllPredicate<T> extends AbstractQuantifierPredicate<T> {\n\n    /** Serial version UID */\n    private static final long serialVersionUID = -3094696765038308799L;\n\n    /**\n     * Factory to create the predicate.\n     * <p>\n     * If the collection is size zero, the predicate always returns true.\n     * If the collection is size one, then that predicate is returned.\n     *\n     * @param <T> the type that the predicate queries\n     * @param predicates  the predicates to check, cloned, not null\n     * @return the {@code all} predicate\n     * @throws NullPointerException if the predicates array is null\n     * @throws NullPointerException if any predicate in the array is null\n     */\n    public static <T> Predicate<T> allPredicate(final Collection<? extends Predicate<? super T>> predicates) {\n        final Predicate<? super T>[] preds = validate(predicates);\n        if (preds.length == 0) {\n            return truePredicate();\n        }\n        if (preds.length == 1) {\n            return coerce(preds[0]);\n        }\n        return new AllPredicate<>(preds);\n    }\n\n    /**\n     * Factory to create the predicate.\n     * <p>\n     * If the array is size zero, the predicate always returns true.\n     * If the array is size one, then that predicate is returned.\n     *\n     * @param <T> the type that the predicate queries\n     * @param predicates  the predicates to check, cloned, not null\n     * @return the {@code all} predicate\n     * @throws NullPointerException if the predicates array is null\n     * @throws NullPointerException if any predicate in the array is null\n     */\n    public static <T> Predicate<T> allPredicate(final Predicate<? super T>... predicates) {\n        validate(predicates);\n        if (predicates.length == 0) {\n            return truePredicate();\n        }\n        if (predicates.length == 1) {\n            return coerce(predicates[0]);\n        }\n        // <T> not needed in Eclipse but needed by the command line compiler\n        return new AllPredicate<T>(FunctorUtils.copy(predicates));\n    }\n\n    /**\n     * Constructor that performs no validation.\n     * Use {@code allPredicate} if you want that.\n     *\n     * @param predicates  the predicates to check, not cloned, not null\n     */\n    public AllPredicate(final Predicate<? super T>... predicates) {\n        super(predicates);\n    }\n\n    /**\n     * Evaluates the predicate returning true if all predicates return true.\n     *\n     * @param object  the input object\n     * @return true if all decorated predicates return true\n     */\n    @Override\n    public boolean test(final T object) {\n        for (final Predicate<? super T> iPredicate : iPredicates) {\n            if (!iPredicate.test(object)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = -3094696765038308799L;", "docstring": " Serial version UID", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -3094696765038308799L", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/functors/NullIsTruePredicate.java.NullIsTruePredicate", "name": "NullIsTruePredicate", "file_path": "src/main/java/org/apache/commons/collections4/functors/NullIsTruePredicate.java", "superclasses": "", "methods": ["[Predicate<T>]nullIsTruePredicate(Predicate<? super T>)", "[]NullIsTruePredicate(Predicate<? super T>)", "[Predicate<? super T>[]]getPredicates()", "[boolean]test(T)"], "method_uris": ["src/main/java/org/apache/commons/collections4/functors/NullIsTruePredicate.java.NullIsTruePredicate.[Predicate<T>]nullIsTruePredicate(Predicate<? super T>)", "src/main/java/org/apache/commons/collections4/functors/NullIsTruePredicate.java.NullIsTruePredicate.[]NullIsTruePredicate(Predicate<? super T>)", "src/main/java/org/apache/commons/collections4/functors/NullIsTruePredicate.java.NullIsTruePredicate.[Predicate<? super T>[]]getPredicates()", "src/main/java/org/apache/commons/collections4/functors/NullIsTruePredicate.java.NullIsTruePredicate.[boolean]test(T)"], "overrides": null, "attributes": [], "class_docstring": "\nPredicate implementation that returns true if the input is null.\n\n@param <T> the type of the input to the predicate.\n@since 3.0\n", "original_string": "public final class NullIsTruePredicate<T> extends AbstractPredicate<T> implements PredicateDecorator<T>, Serializable {\n\n    /** Serial version UID */\n    private static final long serialVersionUID = -7625133768987126273L;\n\n    /**\n     * Factory to create the null true predicate.\n     *\n     * @param <T> the type that the predicate queries\n     * @param predicate  the predicate to decorate, not null\n     * @return the predicate\n     * @throws NullPointerException if the predicate is null\n     */\n    public static <T> Predicate<T> nullIsTruePredicate(final Predicate<? super T> predicate) {\n        return new NullIsTruePredicate<>(Objects.requireNonNull(predicate, \"predicate\"));\n    }\n\n    /** The predicate to decorate */\n    private final Predicate<? super T> iPredicate;\n\n    /**\n     * Constructor that performs no validation.\n     * Use {@code nullIsTruePredicate} if you want that.\n     *\n     * @param predicate  the predicate to call after the null check\n     */\n    public NullIsTruePredicate(final Predicate<? super T> predicate) {\n        iPredicate = predicate;\n    }\n\n    /**\n     * Gets the predicate being decorated.\n     *\n     * @return the predicate as the only element in an array\n     * @since 3.1\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public Predicate<? super T>[] getPredicates() {\n        return new Predicate[] { iPredicate };\n    }\n\n    /**\n     * Evaluates the predicate returning the result of the decorated predicate\n     * once a null check is performed.\n     *\n     * @param object  the input object\n     * @return true if decorated predicate returns true or input is null\n     */\n    @Override\n    public boolean test(final T object) {\n        if (object == null) {\n            return true;\n        }\n        return iPredicate.test(object);\n    }\n\n}", "super_interfaces": ["PredicateDecorator<T>", "Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = -7625133768987126273L;", "docstring": " Serial version UID", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -7625133768987126273L", "syntax_pass": true}, {"attribute_expression": "private final Predicate<? super T> iPredicate;", "docstring": " The predicate to decorate", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Predicate<? super T>", "name": "iPredicate", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/functors/ExceptionTransformer.java.ExceptionTransformer", "name": "ExceptionTransformer", "file_path": "src/main/java/org/apache/commons/collections4/functors/ExceptionTransformer.java", "superclasses": "", "methods": ["[Transformer<I, O>]exceptionTransformer()", "[]ExceptionTransformer()", "[Object]readResolve()", "[R]transform(T)"], "method_uris": ["src/main/java/org/apache/commons/collections4/functors/ExceptionTransformer.java.ExceptionTransformer.[Transformer<I, O>]exceptionTransformer()", "src/main/java/org/apache/commons/collections4/functors/ExceptionTransformer.java.ExceptionTransformer.[]ExceptionTransformer()", "src/main/java/org/apache/commons/collections4/functors/ExceptionTransformer.java.ExceptionTransformer.[Object]readResolve()", "src/main/java/org/apache/commons/collections4/functors/ExceptionTransformer.java.ExceptionTransformer.[R]transform(T)"], "overrides": null, "attributes": [], "class_docstring": "\nTransformer implementation that always throws an exception.\n\n@param <T> the type of the input to the function.\n@param <R> the type of the result of the function.\n@since 3.0\n", "original_string": "public final class ExceptionTransformer<T, R> implements Transformer<T, R>, Serializable {\n\n    /** Serial version UID */\n    private static final long serialVersionUID = 7179106032121985545L;\n\n    /** Singleton predicate instance */\n    @SuppressWarnings(\"rawtypes\") // the static instance works for all types\n    public static final Transformer INSTANCE = new ExceptionTransformer<>();\n\n    /**\n     * Factory returning the singleton instance.\n     *\n     * @param <I>  the input type\n     * @param <O>  the output type\n     * @return the singleton instance\n     * @since 3.1\n     */\n    public static <I, O> Transformer<I, O> exceptionTransformer() {\n        return INSTANCE;\n    }\n\n    /**\n     * Restricted constructor.\n     */\n    private ExceptionTransformer() {\n    }\n\n    /**\n     * Returns the singleton instance.\n     *\n     * @return the singleton instance.\n     */\n    private Object readResolve() {\n        return INSTANCE;\n    }\n\n    /**\n     * Transforms the input to result by cloning it.\n     *\n     * @param input  the input object to transform\n     * @return never\n     * @throws FunctorException always\n     */\n    @Override\n    public R transform(final T input) {\n        throw new FunctorException(\"ExceptionTransformer invoked\");\n    }\n\n}", "super_interfaces": ["Transformer<T, R>", "Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 7179106032121985545L;", "docstring": " Serial version UID", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 7179106032121985545L", "syntax_pass": true}, {"attribute_expression": "@SuppressWarnings(\"rawtypes\") // the static instance works for all types\n    public static final Transformer INSTANCE = new ExceptionTransformer<>();", "docstring": " Singleton predicate instance", "modifiers": "@SuppressWarnings(\"rawtypes\") // the static instance works for all types\n    public static final", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"rawtypes\")", "public", "static", "final"], "comments": ["// the static instance works for all types"], "type": "Transformer", "name": "INSTANCE = new ExceptionTransformer<>()", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/functors/ForClosure.java.ForClosure", "name": "ForClosure", "file_path": "src/main/java/org/apache/commons/collections4/functors/ForClosure.java", "superclasses": "", "methods": ["[Closure<E>]forClosure(int,Closure<? super E>)", "[]ForClosure(int,Closure<? super T>)", "[void]execute(T)", "[Closure<? super T>]getClosure()", "[int]getCount()"], "method_uris": ["src/main/java/org/apache/commons/collections4/functors/ForClosure.java.ForClosure.[Closure<E>]forClosure(int,Closure<? super E>)", "src/main/java/org/apache/commons/collections4/functors/ForClosure.java.ForClosure.[]ForClosure(int,Closure<? super T>)", "src/main/java/org/apache/commons/collections4/functors/ForClosure.java.ForClosure.[void]execute(T)", "src/main/java/org/apache/commons/collections4/functors/ForClosure.java.ForClosure.[Closure<? super T>]getClosure()", "src/main/java/org/apache/commons/collections4/functors/ForClosure.java.ForClosure.[int]getCount()"], "overrides": null, "attributes": [], "class_docstring": "\nClosure implementation that calls another closure n times, like a for loop.\n<p>\n<b>WARNING:</b> from v4.1 onwards this class will <b>not</b> be serializable anymore\nin order to prevent potential remote code execution exploits. Please refer to\n<a href=\"https://issues.apache.org/jira/browse/COLLECTIONS-580\">COLLECTIONS-580</a>\nfor more details.\n</p>\n\n@param <T> the type of the input to the operation.\n@since 3.0\n", "original_string": "public class ForClosure<T> implements Closure<T> {\n\n    /**\n     * Factory method that performs validation.\n     * <p>\n     * A null closure or zero count returns the {@code NOPClosure}.\n     * A count of one returns the specified closure.\n     *\n     * @param <E> the type that the closure acts on\n     * @param count  the number of times to execute the closure\n     * @param closure  the closure to execute, not null\n     * @return the {@code for} closure\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static <E> Closure<E> forClosure(final int count, final Closure<? super E> closure) {\n        if (count <= 0 || closure == null) {\n            return NOPClosure.<E>nopClosure();\n        }\n        if (count == 1) {\n            return (Closure<E>) closure;\n        }\n        return new ForClosure<>(count, closure);\n    }\n    /** The number of times to loop */\n    private final int iCount;\n\n    /** The closure to call */\n    private final Closure<? super T> iClosure;\n\n    /**\n     * Constructor that performs no validation.\n     * Use {@code forClosure} if you want that.\n     *\n     * @param count  the number of times to execute the closure\n     * @param closure  the closure to execute, not null\n     */\n    public ForClosure(final int count, final Closure<? super T> closure) {\n        iCount = count;\n        iClosure = closure;\n    }\n\n    /**\n     * Executes the closure {@code count} times.\n     *\n     * @param input  the input object\n     */\n    @Override\n    public void execute(final T input) {\n        for (int i = 0; i < iCount; i++) {\n            iClosure.accept(input);\n        }\n    }\n\n    /**\n     * Gets the closure.\n     *\n     * @return the closure\n     * @since 3.1\n     */\n    public Closure<? super T> getClosure() {\n        return iClosure;\n    }\n\n    /**\n     * Gets the count.\n     *\n     * @return the count\n     * @since 3.1\n     */\n    public int getCount() {\n        return iCount;\n    }\n\n}", "super_interfaces": ["Closure<T>"], "fields": [{"attribute_expression": "private final int iCount;", "docstring": " The number of times to loop", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "iCount", "syntax_pass": true}, {"attribute_expression": "private final Closure<? super T> iClosure;", "docstring": " The closure to call", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Closure<? super T>", "name": "iClosure", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/functors/FunctorUtils.java.FunctorUtils", "name": "FunctorUtils", "file_path": "src/main/java/org/apache/commons/collections4/functors/FunctorUtils.java", "superclasses": "", "methods": ["[R]coerce(P)", "[R]coerce(P)", "[T[]]copy()", "[T[]]copy()", "[T[]]copy()", "[Predicate<? super T>[]]validate(Collection<? extends java.util.function.Predicate<? super T>>)", "[void]validate()", "[void]validate()", "[void]validate()", "[]FunctorUtils()"], "method_uris": ["src/main/java/org/apache/commons/collections4/functors/FunctorUtils.java.FunctorUtils.[R]coerce(P)", "src/main/java/org/apache/commons/collections4/functors/FunctorUtils.java.FunctorUtils.[R]coerce(P)", "src/main/java/org/apache/commons/collections4/functors/FunctorUtils.java.FunctorUtils.[T[]]copy()", "src/main/java/org/apache/commons/collections4/functors/FunctorUtils.java.FunctorUtils.[T[]]copy()", "src/main/java/org/apache/commons/collections4/functors/FunctorUtils.java.FunctorUtils.[T[]]copy()", "src/main/java/org/apache/commons/collections4/functors/FunctorUtils.java.FunctorUtils.[Predicate<? super T>[]]validate(Collection<? extends java.util.function.Predicate<? super T>>)", "src/main/java/org/apache/commons/collections4/functors/FunctorUtils.java.FunctorUtils.[void]validate()", "src/main/java/org/apache/commons/collections4/functors/FunctorUtils.java.FunctorUtils.[void]validate()", "src/main/java/org/apache/commons/collections4/functors/FunctorUtils.java.FunctorUtils.[void]validate()", "src/main/java/org/apache/commons/collections4/functors/FunctorUtils.java.FunctorUtils.[]FunctorUtils()"], "overrides": null, "attributes": [], "class_docstring": "\nInternal utilities for functors.\n\n@since 3.0\n", "original_string": "final class FunctorUtils {\n\n    /**\n     * A very simple method that coerces Predicate<? super T> to Predicate<T>.\n     * Due to the {@link Predicate#test(T)} method, Predicate<? super T> is\n     * able to be coerced to Predicate<T> without casting issues.\n     * <p>This method exists\n     * simply as centralized documentation and atomic unchecked warning\n     * suppression.\n     *\n     * @param <T> the type of object the returned predicate should \"accept\"\n     * @param predicate the predicate to coerce.\n     * @return the coerced predicate.\n     */\n    @SuppressWarnings(\"unchecked\")\n    static <R extends java.util.function.Predicate<T>, P extends java.util.function.Predicate<? super T>, T> R coerce(final P predicate) {\n        return (R) predicate;\n    }\n\n    /**\n     * A very simple method that coerces Transformer<? super I, ? extends O> to Transformer<I, O>.\n     * <p>This method exists\n     * simply as centralized documentation and atomic unchecked warning\n     * suppression.\n     *\n     * @param <I> the type of object the returned transformer should \"accept\"\n     * @param <O> the type of object the returned transformer should \"produce\"\n     * @param transformer the transformer to coerce.\n     * @return the coerced transformer.\n     */\n    @SuppressWarnings(\"unchecked\")\n    static <R extends Function<I, O>, P extends Function<? super I, ? extends O>, I, O> R coerce(final P transformer) {\n        return (R) transformer;\n    }\n\n    /**\n     * Clones the consumers to ensure that the internal references can't be updated.\n     *\n     * @param consumers  the consumers to copy.\n     * @return the cloned consumers.\n     */\n    @SuppressWarnings(\"unchecked\")\n    static <T extends Consumer<?>> T[] copy(final T... consumers) {\n        if (consumers == null) {\n            return null;\n        }\n        return consumers.clone();\n    }\n\n    /**\n     * Clone the predicates to ensure that the internal reference can't be messed with.\n     * Due to the {@link Predicate#test(T)} method, Predicate<? super T> is\n     * able to be coerced to Predicate<T> without casting issues.\n     *\n     * @param predicates  the predicates to copy\n     * @return the cloned predicates\n     */\n    @SuppressWarnings(\"unchecked\")\n    static <T extends java.util.function.Predicate<?>> T[] copy(final T... predicates) {\n        if (predicates == null) {\n            return null;\n        }\n        return predicates.clone();\n    }\n\n    /**\n     * Copy method.\n     *\n     * @param transformers  the transformers to copy\n     * @return a clone of the transformers\n     */\n    @SuppressWarnings(\"unchecked\")\n    static <T extends Function<?, ?>> T[] copy(final T... transformers) {\n        if (transformers == null) {\n            return null;\n        }\n        return transformers.clone();\n    }\n\n    /**\n     * Validate the predicates to ensure that all is well.\n     *\n     * @param predicates  the predicates to validate\n     * @return predicate array\n     */\n    static <T> Predicate<? super T>[] validate(final Collection<? extends java.util.function.Predicate<? super T>> predicates) {\n        Objects.requireNonNull(predicates, \"predicates\");\n        // convert to array like this to guarantee iterator() ordering\n        @SuppressWarnings(\"unchecked\") // OK\n        final Predicate<? super T>[] preds = new Predicate[predicates.size()];\n        int i = 0;\n        for (final java.util.function.Predicate<? super T> predicate : predicates) {\n            preds[i] = (Predicate<? super T>) predicate;\n            if (preds[i] == null) {\n                throw new NullPointerException(\"predicates[\" + i + \"]\");\n            }\n            i++;\n        }\n        return preds;\n    }\n\n    /**\n     * Validates the consumers to ensure that all is well.\n     *\n     * @param consumers  the consumers to validate.\n     */\n    static void validate(final Consumer<?>... consumers) {\n        Objects.requireNonNull(consumers, \"closures\");\n        for (int i = 0; i < consumers.length; i++) {\n            if (consumers[i] == null) {\n                throw new NullPointerException(\"closures[\" + i + \"]\");\n            }\n        }\n    }\n\n    /**\n     * Validate method\n     *\n     * @param functions  the transformers to validate\n     */\n    static void validate(final Function<?, ?>... functions) {\n        Objects.requireNonNull(functions, \"functions\");\n        for (int i = 0; i < functions.length; i++) {\n            if (functions[i] == null) {\n                throw new NullPointerException(\"functions[\" + i + \"]\");\n            }\n        }\n    }\n\n    /**\n     * Validate the predicates to ensure that all is well.\n     *\n     * @param predicates  the predicates to validate\n     */\n    static void validate(final java.util.function.Predicate<?>... predicates) {\n        Objects.requireNonNull(predicates, \"predicates\");\n        for (int i = 0; i < predicates.length; i++) {\n            if (predicates[i] == null) {\n                throw new NullPointerException(\"predicates[\" + i + \"]\");\n            }\n        }\n    }\n\n    /**\n     * Restricted constructor.\n     */\n    private FunctorUtils() {\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/org/apache/commons/collections4/functors/FactoryTransformer.java.FactoryTransformer", "name": "FactoryTransformer", "file_path": "src/main/java/org/apache/commons/collections4/functors/FactoryTransformer.java", "superclasses": "", "methods": ["[Transformer<I, O>]factoryTransformer(Factory<? extends O>)", "[]FactoryTransformer(Factory<? extends R>)", "[Factory<? extends R>]getFactory()", "[R]transform(T)"], "method_uris": ["src/main/java/org/apache/commons/collections4/functors/FactoryTransformer.java.FactoryTransformer.[Transformer<I, O>]factoryTransformer(Factory<? extends O>)", "src/main/java/org/apache/commons/collections4/functors/FactoryTransformer.java.FactoryTransformer.[]FactoryTransformer(Factory<? extends R>)", "src/main/java/org/apache/commons/collections4/functors/FactoryTransformer.java.FactoryTransformer.[Factory<? extends R>]getFactory()", "src/main/java/org/apache/commons/collections4/functors/FactoryTransformer.java.FactoryTransformer.[R]transform(T)"], "overrides": null, "attributes": [], "class_docstring": "\nTransformer implementation that calls a Factory and returns the result.\n\n@param <T> the type of the input to the function.\n@param <R> the type of the result of the function.\n@since 3.0\n", "original_string": "public class FactoryTransformer<T, R> implements Transformer<T, R>, Serializable {\n\n    /** Serial version UID */\n    private static final long serialVersionUID = -6817674502475353160L;\n\n    /**\n     * Factory method that performs validation.\n     *\n     * @param <I>  the input type\n     * @param <O>  the output type\n     * @param factory  the factory to call, not null\n     * @return the {@code factory} transformer\n     * @throws NullPointerException if the factory is null\n     */\n    public static <I, O> Transformer<I, O> factoryTransformer(final Factory<? extends O> factory) {\n        return new FactoryTransformer<>(Objects.requireNonNull(factory, \"factory\"));\n    }\n\n    /** The factory to wrap */\n    private final Factory<? extends R> iFactory;\n\n    /**\n     * Constructor that performs no validation.\n     * Use {@code factoryTransformer} if you want that.\n     *\n     * @param factory  the factory to call, not null\n     */\n    public FactoryTransformer(final Factory<? extends R> factory) {\n        iFactory = factory;\n    }\n\n    /**\n     * Gets the factory.\n     *\n     * @return the factory\n     * @since 3.1\n     */\n    public Factory<? extends R> getFactory() {\n        return iFactory;\n    }\n\n    /**\n     * Transforms the input by ignoring the input and returning the result of\n     * calling the decorated factory.\n     *\n     * @param input  the input object to transform\n     * @return the transformed result\n     */\n    @Override\n    public R transform(final T input) {\n        return iFactory.get();\n    }\n\n}", "super_interfaces": ["Transformer<T, R>", "Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = -6817674502475353160L;", "docstring": " Serial version UID", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -6817674502475353160L", "syntax_pass": true}, {"attribute_expression": "private final Factory<? extends R> iFactory;", "docstring": " The factory to wrap", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Factory<? extends R>", "name": "iFactory", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/functors/ConstantFactory.java.ConstantFactory", "name": "ConstantFactory", "file_path": "src/main/java/org/apache/commons/collections4/functors/ConstantFactory.java", "superclasses": "", "methods": ["[Factory<T>]constantFactory(T)", "[]ConstantFactory(T)", "[T]create()", "[T]getConstant()"], "method_uris": ["src/main/java/org/apache/commons/collections4/functors/ConstantFactory.java.ConstantFactory.[Factory<T>]constantFactory(T)", "src/main/java/org/apache/commons/collections4/functors/ConstantFactory.java.ConstantFactory.[]ConstantFactory(T)", "src/main/java/org/apache/commons/collections4/functors/ConstantFactory.java.ConstantFactory.[T]create()", "src/main/java/org/apache/commons/collections4/functors/ConstantFactory.java.ConstantFactory.[T]getConstant()"], "overrides": null, "attributes": [], "class_docstring": "\nFactory implementation that returns the same constant each time.\n<p>\nNo check is made that the object is immutable. In general, only immutable\nobjects should use the constant factory. Mutable objects should\nuse the prototype factory.\n</p>\n\n@param <T> the type of results supplied by this supplier.\n@since 3.0\n", "original_string": "public class ConstantFactory<T> implements Factory<T>, Serializable {\n\n    /** Serial version UID */\n    private static final long serialVersionUID = -3520677225766901240L;\n\n    /** Returns null each time */\n    @SuppressWarnings(\"rawtypes\") // The null factory works for all object types\n    public static final Factory NULL_INSTANCE = new ConstantFactory<>(null);\n\n    /**\n     * Factory method that performs validation.\n     *\n     * @param <T>  the type of the constant\n     * @param constantToReturn  the constant object to return each time in the factory\n     * @return the {@code constant} factory.\n     */\n    public static <T> Factory<T> constantFactory(final T constantToReturn) {\n        if (constantToReturn == null) {\n            return NULL_INSTANCE;\n        }\n        return new ConstantFactory<>(constantToReturn);\n    }\n\n    /** The closures to call in turn */\n    private final T iConstant;\n\n    /**\n     * Constructor that performs no validation.\n     * Use {@code constantFactory} if you want that.\n     *\n     * @param constantToReturn  the constant to return each time\n     */\n    public ConstantFactory(final T constantToReturn) {\n        iConstant = constantToReturn;\n    }\n\n    /**\n     * Always return constant.\n     *\n     * @return the stored constant value\n     */\n    @Override\n    public T create() {\n        return iConstant;\n    }\n\n    /**\n     * Gets the constant.\n     *\n     * @return the constant\n     * @since 3.1\n     */\n    public T getConstant() {\n        return iConstant;\n    }\n\n}", "super_interfaces": ["Factory<T>", "Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = -3520677225766901240L;", "docstring": " Serial version UID", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -3520677225766901240L", "syntax_pass": true}, {"attribute_expression": "@SuppressWarnings(\"rawtypes\") // The null factory works for all object types\n    public static final Factory NULL_INSTANCE = new ConstantFactory<>(null);", "docstring": " Returns null each time", "modifiers": "@SuppressWarnings(\"rawtypes\") // The null factory works for all object types\n    public static final", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"rawtypes\")", "public", "static", "final"], "comments": ["// The null factory works for all object types"], "type": "Factory", "name": "NULL_INSTANCE = new ConstantFactory<>(null)", "syntax_pass": true}, {"attribute_expression": "private final T iConstant;", "docstring": " The closures to call in turn", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "T", "name": "iConstant", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/functors/InstantiateFactory.java.InstantiateFactory", "name": "InstantiateFactory", "file_path": "src/main/java/org/apache/commons/collections4/functors/InstantiateFactory.java", "superclasses": "", "methods": ["[Factory<T>]instantiateFactory(Class<T>,Class<?>[],Object[])", "[]InstantiateFactory(Class<T>)", "[]InstantiateFactory(Class<T>,Class<?>[],Object[])", "[T]create()", "[void]findConstructor()"], "method_uris": ["src/main/java/org/apache/commons/collections4/functors/InstantiateFactory.java.InstantiateFactory.[Factory<T>]instantiateFactory(Class<T>,Class<?>[],Object[])", "src/main/java/org/apache/commons/collections4/functors/InstantiateFactory.java.InstantiateFactory.[]InstantiateFactory(Class<T>)", "src/main/java/org/apache/commons/collections4/functors/InstantiateFactory.java.InstantiateFactory.[]InstantiateFactory(Class<T>,Class<?>[],Object[])", "src/main/java/org/apache/commons/collections4/functors/InstantiateFactory.java.InstantiateFactory.[T]create()", "src/main/java/org/apache/commons/collections4/functors/InstantiateFactory.java.InstantiateFactory.[void]findConstructor()"], "overrides": null, "attributes": [], "class_docstring": "\nFactory implementation that creates a new object instance by reflection.\n<p>\n<b>WARNING:</b> from v4.1 onwards this class will <b>not</b> be serializable anymore\nin order to prevent potential remote code execution exploits. Please refer to\n<a href=\"https://issues.apache.org/jira/browse/COLLECTIONS-580\">COLLECTIONS-580</a>\nfor more details.\n</p>\n\n@param <T> the type of results supplied by this supplier.\n@since 3.0\n", "original_string": "public class InstantiateFactory<T> implements Factory<T> {\n\n    /**\n     * Factory method that performs validation.\n     *\n     * @param <T>  the type the factory creates\n     * @param classToInstantiate  the class to instantiate, not null\n     * @param paramTypes  the constructor parameter types, cloned\n     * @param args  the constructor arguments, cloned\n     * @return a new instantiate factory\n     * @throws NullPointerException if classToInstantiate is null\n     * @throws IllegalArgumentException if paramTypes does not match args\n     */\n    public static <T> Factory<T> instantiateFactory(final Class<T> classToInstantiate,\n                                                    final Class<?>[] paramTypes,\n                                                    final Object[] args) {\n        Objects.requireNonNull(classToInstantiate, \"classToInstantiate\");\n        if (paramTypes == null && args != null\n            || paramTypes != null && args == null\n            || paramTypes != null && args != null && paramTypes.length != args.length) {\n            throw new IllegalArgumentException(\"Parameter types must match the arguments\");\n        }\n\n        if (paramTypes == null || paramTypes.length == 0) {\n            return new InstantiateFactory<>(classToInstantiate);\n        }\n        return new InstantiateFactory<>(classToInstantiate, paramTypes, args);\n    }\n    /** The class to create */\n    private final Class<T> iClassToInstantiate;\n    /** The constructor parameter types */\n    private final Class<?>[] iParamTypes;\n    /** The constructor arguments */\n    private final Object[] iArgs;\n\n    /** The constructor */\n    private transient Constructor<T> iConstructor;\n\n    /**\n     * Constructor that performs no validation.\n     * Use {@code instantiateFactory} if you want that.\n     *\n     * @param classToInstantiate  the class to instantiate\n     */\n    public InstantiateFactory(final Class<T> classToInstantiate) {\n        iClassToInstantiate = classToInstantiate;\n        iParamTypes = null;\n        iArgs = null;\n        findConstructor();\n    }\n\n    /**\n     * Constructor that performs no validation.\n     * Use {@code instantiateFactory} if you want that.\n     *\n     * @param classToInstantiate  the class to instantiate\n     * @param paramTypes  the constructor parameter types, cloned\n     * @param args  the constructor arguments, cloned\n     */\n    public InstantiateFactory(final Class<T> classToInstantiate, final Class<?>[] paramTypes, final Object[] args) {\n        iClassToInstantiate = classToInstantiate;\n        iParamTypes = paramTypes.clone();\n        iArgs = args.clone();\n        findConstructor();\n    }\n\n    /**\n     * Creates an object using the stored constructor.\n     *\n     * @return the new object\n     */\n    @Override\n    public T create() {\n        // needed for post-serialization\n        if (iConstructor == null) {\n            findConstructor();\n        }\n\n        try {\n            return iConstructor.newInstance(iArgs);\n        } catch (final InstantiationException ex) {\n            throw new FunctorException(\"InstantiateFactory: InstantiationException\", ex);\n        } catch (final IllegalAccessException ex) {\n            throw new FunctorException(\"InstantiateFactory: Constructor must be public\", ex);\n        } catch (final InvocationTargetException ex) {\n            throw new FunctorException(\"InstantiateFactory: Constructor threw an exception\", ex);\n        }\n    }\n\n    /**\n     * Find the Constructor for the class specified.\n     */\n    private void findConstructor() {\n        try {\n            iConstructor = iClassToInstantiate.getConstructor(iParamTypes);\n        } catch (final NoSuchMethodException ex) {\n            throw new IllegalArgumentException(\"InstantiateFactory: The constructor must exist and be public \");\n        }\n    }\n\n}", "super_interfaces": ["Factory<T>"], "fields": [{"attribute_expression": "private final Class<T> iClassToInstantiate;", "docstring": " The class to create", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Class<T>", "name": "iClassToInstantiate", "syntax_pass": true}, {"attribute_expression": "private final Class<?>[] iParamTypes;", "docstring": " The constructor parameter types", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Class<?>[]", "name": "iParamTypes", "syntax_pass": true}, {"attribute_expression": "private final Object[] iArgs;", "docstring": " The constructor arguments", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Object[]", "name": "iArgs", "syntax_pass": true}, {"attribute_expression": "private transient Constructor<T> iConstructor;", "docstring": " The constructor", "modifiers": "private transient", "marker_annotations": [], "non_marker_annotations": ["private", "transient"], "comments": [], "type": "Constructor<T>", "name": "iConstructor", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/functors/EqualPredicate.java.EqualPredicate", "name": "EqualPredicate", "file_path": "src/main/java/org/apache/commons/collections4/functors/EqualPredicate.java", "superclasses": "", "methods": ["[Predicate<T>]equalPredicate(T)", "[Predicate<T>]equalPredicate(T,Equator<T>)", "[]EqualPredicate(T)", "[]EqualPredicate(T,Equator<T>)", "[Object]getValue()", "[boolean]test(T)"], "method_uris": ["src/main/java/org/apache/commons/collections4/functors/EqualPredicate.java.EqualPredicate.[Predicate<T>]equalPredicate(T)", "src/main/java/org/apache/commons/collections4/functors/EqualPredicate.java.EqualPredicate.[Predicate<T>]equalPredicate(T,Equator<T>)", "src/main/java/org/apache/commons/collections4/functors/EqualPredicate.java.EqualPredicate.[]EqualPredicate(T)", "src/main/java/org/apache/commons/collections4/functors/EqualPredicate.java.EqualPredicate.[]EqualPredicate(T,Equator<T>)", "src/main/java/org/apache/commons/collections4/functors/EqualPredicate.java.EqualPredicate.[Object]getValue()", "src/main/java/org/apache/commons/collections4/functors/EqualPredicate.java.EqualPredicate.[boolean]test(T)"], "overrides": null, "attributes": [], "class_docstring": "\nPredicate implementation that returns true if the input is the same object\nas the one stored in this predicate by equals.\n\n@param <T> the type of the input to the predicate.\n@since 3.0\n", "original_string": "public final class EqualPredicate<T> extends AbstractPredicate<T> implements Serializable {\n\n    /** Serial version UID */\n    private static final long serialVersionUID = 5633766978029907089L;\n\n    /**\n     * Factory to create the predicate.\n     *\n     * @param <T> the type that the predicate queries\n     * @param object  the object to compare to\n     * @return the predicate\n     */\n    public static <T> Predicate<T> equalPredicate(final T object) {\n        if (object == null) {\n            return NullPredicate.nullPredicate();\n        }\n        return new EqualPredicate<>(object);\n    }\n\n    /**\n     * Factory to create the identity predicate.\n     *\n     * @param <T> the type that the predicate queries\n     * @param object  the object to compare to\n     * @param equator  the equator to use for comparison\n     * @return the predicate\n     * @since 4.0\n     */\n    public static <T> Predicate<T> equalPredicate(final T object, final Equator<T> equator) {\n        if (object == null) {\n            return NullPredicate.nullPredicate();\n        }\n        return new EqualPredicate<>(object, equator);\n    }\n\n    /** The value to compare to */\n    private final T iValue;\n\n    /** The equator to use for comparison */\n    private final Equator<T> equator;\n\n    /**\n     * Constructor that performs no validation.\n     * Use {@code equalPredicate} if you want that.\n     *\n     * @param object  the object to compare to\n     */\n    public EqualPredicate(final T object) {\n        // do not use the DefaultEquator to keep backwards compatibility\n        // the DefaultEquator returns also true if the two object references are equal\n        this(object, null);\n    }\n\n    /**\n     * Constructor that performs no validation.\n     * Use {@code equalPredicate} if you want that.\n     *\n     * @param object  the object to compare to\n     * @param equator  the equator to use for comparison\n     * @since 4.0\n     */\n    public EqualPredicate(final T object, final Equator<T> equator) {\n        iValue = object;\n        this.equator = equator;\n    }\n\n    /**\n     * Gets the value.\n     *\n     * @return the value\n     * @since 3.1\n     */\n    public Object getValue() {\n        return iValue;\n    }\n\n    /**\n     * Evaluates the predicate returning true if the input equals the stored value.\n     *\n     * @param object  the input object\n     * @return true if input object equals stored value\n     */\n    @Override\n    public boolean test(final T object) {\n        if (equator != null) {\n            return equator.equate(iValue, object);\n        }\n        return iValue.equals(object);\n    }\n\n}", "super_interfaces": ["Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 5633766978029907089L;", "docstring": " Serial version UID", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 5633766978029907089L", "syntax_pass": true}, {"attribute_expression": "private final T iValue;", "docstring": " The value to compare to", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "T", "name": "iValue", "syntax_pass": true}, {"attribute_expression": "private final Equator<T> equator;", "docstring": " The equator to use for comparison", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Equator<T>", "name": "equator", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/functors/TransformedPredicate.java.TransformedPredicate", "name": "TransformedPredicate", "file_path": "src/main/java/org/apache/commons/collections4/functors/TransformedPredicate.java", "superclasses": "", "methods": ["[Predicate<T>]transformedPredicate(Transformer<? super T, ? extends T>,Predicate<? super T>)", "[]TransformedPredicate(Transformer<? super T, ? extends T>,Predicate<? super T>)", "[Predicate<? super T>[]]getPredicates()", "[Transformer<? super T, ? extends T>]getTransformer()", "[boolean]test(T)"], "method_uris": ["src/main/java/org/apache/commons/collections4/functors/TransformedPredicate.java.TransformedPredicate.[Predicate<T>]transformedPredicate(Transformer<? super T, ? extends T>,Predicate<? super T>)", "src/main/java/org/apache/commons/collections4/functors/TransformedPredicate.java.TransformedPredicate.[]TransformedPredicate(Transformer<? super T, ? extends T>,Predicate<? super T>)", "src/main/java/org/apache/commons/collections4/functors/TransformedPredicate.java.TransformedPredicate.[Predicate<? super T>[]]getPredicates()", "src/main/java/org/apache/commons/collections4/functors/TransformedPredicate.java.TransformedPredicate.[Transformer<? super T, ? extends T>]getTransformer()", "src/main/java/org/apache/commons/collections4/functors/TransformedPredicate.java.TransformedPredicate.[boolean]test(T)"], "overrides": null, "attributes": [], "class_docstring": "\nPredicate implementation that transforms the given object before invoking\nanother {@code Predicate}.\n\n@param <T> the type of the input to the predicate.\n@since 3.1\n", "original_string": "public final class TransformedPredicate<T> extends AbstractPredicate<T> implements PredicateDecorator<T>, Serializable {\n\n    /** Serial version UID */\n    private static final long serialVersionUID = -5596090919668315834L;\n\n    /**\n     * Factory to create the predicate.\n     *\n     * @param <T> the type that the predicate queries\n     * @param transformer  the transformer to call\n     * @param predicate  the predicate to call with the result of the transform\n     * @return the predicate\n     * @throws NullPointerException if the transformer or the predicate is null\n     */\n    public static <T> Predicate<T> transformedPredicate(final Transformer<? super T, ? extends T> transformer,\n                                                        final Predicate<? super T> predicate) {\n        return new TransformedPredicate<>(Objects.requireNonNull(transformer, \"transformer\"),\n                Objects.requireNonNull(predicate, \"predicate\"));\n    }\n\n    /** The transformer to call */\n    private final Transformer<? super T, ? extends T> iTransformer;\n\n    /** The predicate to call */\n    private final Predicate<? super T> iPredicate;\n\n    /**\n     * Constructor that performs no validation.\n     * Use {@code transformedPredicate} if you want that.\n     *\n     * @param transformer  the transformer to use\n     * @param predicate  the predicate to decorate\n     */\n    public TransformedPredicate(final Transformer<? super T, ? extends T> transformer,\n                                final Predicate<? super T> predicate) {\n        iTransformer = transformer;\n        iPredicate = predicate;\n    }\n\n    /**\n     * Gets the predicate being decorated.\n     *\n     * @return the predicate as the only element in an array\n     * @since 3.1\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public Predicate<? super T>[] getPredicates() {\n        return new Predicate[] {iPredicate};\n    }\n\n    /**\n     * Gets the transformer in use.\n     *\n     * @return the transformer\n     */\n    public Transformer<? super T, ? extends T> getTransformer() {\n        return iTransformer;\n    }\n\n    /**\n     * Evaluates the predicate returning the result of the decorated predicate\n     * once the input has been transformed\n     *\n     * @param object  the input object which will be transformed\n     * @return true if decorated predicate returns true\n     */\n    @Override\n    public boolean test(final T object) {\n        final T result = iTransformer.apply(object);\n        return iPredicate.test(result);\n    }\n\n}", "super_interfaces": ["PredicateDecorator<T>", "Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = -5596090919668315834L;", "docstring": " Serial version UID", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -5596090919668315834L", "syntax_pass": true}, {"attribute_expression": "private final Transformer<? super T, ? extends T> iTransformer;", "docstring": " The transformer to call", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Transformer<? super T, ? extends T>", "name": "iTransformer", "syntax_pass": true}, {"attribute_expression": "private final Predicate<? super T> iPredicate;", "docstring": " The predicate to call", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Predicate<? super T>", "name": "iPredicate", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/functors/IfTransformer.java.IfTransformer", "name": "IfTransformer", "file_path": "src/main/java/org/apache/commons/collections4/functors/IfTransformer.java", "superclasses": "", "methods": ["[Transformer<I, O>]ifTransformer(Predicate<? super I>,Transformer<? super I, ? extends O>,Transformer<? super I, ? extends O>)", "[Transformer<T, T>]ifTransformer(Predicate<? super T>,Transformer<? super T, ? extends T>)", "[]IfTransformer(Predicate<? super T>,Transformer<? super T, ? extends R>,Transformer<? super T, ? extends R>)", "[Transformer<? super T, ? extends R>]getFalseTransformer()", "[Predicate<? super T>]getPredicate()", "[Transformer<? super T, ? extends R>]getTrueTransformer()", "[R]transform(T)"], "method_uris": ["src/main/java/org/apache/commons/collections4/functors/IfTransformer.java.IfTransformer.[Transformer<I, O>]ifTransformer(Predicate<? super I>,Transformer<? super I, ? extends O>,Transformer<? super I, ? extends O>)", "src/main/java/org/apache/commons/collections4/functors/IfTransformer.java.IfTransformer.[Transformer<T, T>]ifTransformer(Predicate<? super T>,Transformer<? super T, ? extends T>)", "src/main/java/org/apache/commons/collections4/functors/IfTransformer.java.IfTransformer.[]IfTransformer(Predicate<? super T>,Transformer<? super T, ? extends R>,Transformer<? super T, ? extends R>)", "src/main/java/org/apache/commons/collections4/functors/IfTransformer.java.IfTransformer.[Transformer<? super T, ? extends R>]getFalseTransformer()", "src/main/java/org/apache/commons/collections4/functors/IfTransformer.java.IfTransformer.[Predicate<? super T>]getPredicate()", "src/main/java/org/apache/commons/collections4/functors/IfTransformer.java.IfTransformer.[Transformer<? super T, ? extends R>]getTrueTransformer()", "src/main/java/org/apache/commons/collections4/functors/IfTransformer.java.IfTransformer.[R]transform(T)"], "overrides": null, "attributes": [], "class_docstring": "\nTransformer implementation that will call one of two closures based on whether a predicate evaluates\nas true or false.\n\n@param <T> the type of the input to the function.\n@param <R> the type of the result of the function.\n@since 4.1\n", "original_string": "public class IfTransformer<T, R> implements Transformer<T, R>, Serializable {\n\n    /** Serial version UID */\n    private static final long serialVersionUID = 8069309411242014252L;\n\n    /**\n     * Factory method that performs validation.\n     *\n     * @param <I>  input type for the transformer\n     * @param <O>  output type for the transformer\n     * @param predicate  predicate to switch on\n     * @param trueTransformer  transformer used if true\n     * @param falseTransformer  transformer used if false\n     * @return the {@code if} transformer\n     * @throws NullPointerException if either argument is null\n     */\n    public static <I, O> Transformer<I, O> ifTransformer(final Predicate<? super I> predicate,\n                                                         final Transformer<? super I, ? extends O> trueTransformer,\n                                                         final Transformer<? super I, ? extends O> falseTransformer) {\n        return new IfTransformer<>(Objects.requireNonNull(predicate, \"predicate\"),\n                Objects.requireNonNull(trueTransformer, \"trueTransformer\"),\n                Objects.requireNonNull(falseTransformer, \"falseTransformer\"));\n    }\n    /**\n     * Factory method that performs validation.\n     * <p>\n     * This factory creates a transformer that just returns the input object when\n     * the predicate is false.\n     *\n     * @param <T>  input and output type for the transformer\n     * @param predicate  predicate to switch on\n     * @param trueTransformer  transformer used if true\n     * @return the {@code if} transformer\n     * @throws NullPointerException if either argument is null\n     */\n    public static <T> Transformer<T, T> ifTransformer(\n            final Predicate<? super T> predicate,\n            final Transformer<? super T, ? extends T> trueTransformer) {\n        return new IfTransformer<>(Objects.requireNonNull(predicate, \"predicate\"),\n                Objects.requireNonNull(trueTransformer, \"trueTransformer\"), NOPTransformer.<T>nopTransformer());\n    }\n    /** The test */\n    private final Predicate<? super T> iPredicate;\n\n    /** The transformer to use if true */\n    private final Transformer<? super T, ? extends R> iTrueTransformer;\n\n    /** The transformer to use if false */\n    private final Transformer<? super T, ? extends R> iFalseTransformer;\n\n    /**\n     * Constructor that performs no validation.\n     * Use the static factory method {@code ifTransformer} if you want that.\n     *\n     * @param predicate  predicate to switch on, not null\n     * @param trueTransformer  transformer used if true, not null\n     * @param falseTransformer  transformer used if false, not null\n     */\n    public IfTransformer(final Predicate<? super T> predicate,\n        final Transformer<? super T, ? extends R> trueTransformer,\n        final Transformer<? super T, ? extends R> falseTransformer) {\n\n        iPredicate = predicate;\n        iTrueTransformer = trueTransformer;\n        iFalseTransformer = falseTransformer;\n    }\n\n    /**\n     * Gets the transformer used when false.\n     *\n     * @return the transformer\n     */\n    public Transformer<? super T, ? extends R> getFalseTransformer() {\n        return iFalseTransformer;\n    }\n\n    /**\n     * Gets the predicate.\n     *\n     * @return the predicate\n     */\n    public Predicate<? super T> getPredicate() {\n        return iPredicate;\n    }\n\n    /**\n     * Gets the transformer used when true.\n     *\n     * @return the transformer\n     */\n    public Transformer<? super T, ? extends R> getTrueTransformer() {\n        return iTrueTransformer;\n    }\n\n    /**\n     * Transforms the input using the true or false transformer based to the result of the predicate.\n     *\n     * @param input  the input object to transform\n     * @return the transformed result\n     */\n    @Override\n    public R transform(final T input) {\n        if (iPredicate.test(input)) {\n            return iTrueTransformer.apply(input);\n        }\n        return iFalseTransformer.apply(input);\n    }\n}", "super_interfaces": ["Transformer<T, R>", "Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 8069309411242014252L;", "docstring": " Serial version UID", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 8069309411242014252L", "syntax_pass": true}, {"attribute_expression": "private final Predicate<? super T> iPredicate;", "docstring": " The test", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Predicate<? super T>", "name": "iPredicate", "syntax_pass": true}, {"attribute_expression": "private final Transformer<? super T, ? extends R> iTrueTransformer;", "docstring": " The transformer to use if true", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Transformer<? super T, ? extends R>", "name": "iTrueTransformer", "syntax_pass": true}, {"attribute_expression": "private final Transformer<? super T, ? extends R> iFalseTransformer;", "docstring": " The transformer to use if false", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Transformer<? super T, ? extends R>", "name": "iFalseTransformer", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/functors/FalsePredicate.java.FalsePredicate", "name": "FalsePredicate", "file_path": "src/main/java/org/apache/commons/collections4/functors/FalsePredicate.java", "superclasses": "", "methods": ["[Predicate<T>]falsePredicate()", "[]FalsePredicate()", "[Object]readResolve()", "[boolean]test(T)"], "method_uris": ["src/main/java/org/apache/commons/collections4/functors/FalsePredicate.java.FalsePredicate.[Predicate<T>]falsePredicate()", "src/main/java/org/apache/commons/collections4/functors/FalsePredicate.java.FalsePredicate.[]FalsePredicate()", "src/main/java/org/apache/commons/collections4/functors/FalsePredicate.java.FalsePredicate.[Object]readResolve()", "src/main/java/org/apache/commons/collections4/functors/FalsePredicate.java.FalsePredicate.[boolean]test(T)"], "overrides": null, "attributes": [], "class_docstring": "\nPredicate implementation that always returns false.\n\n@param <T> the type of the input to the predicate.\n@since 3.0\n", "original_string": "public final class FalsePredicate<T> extends AbstractPredicate<T> implements Serializable {\n\n    /** Serial version UID */\n    private static final long serialVersionUID = 7533784454832764388L;\n\n    /** Singleton predicate instance */\n    @SuppressWarnings(\"rawtypes\") // the static instance works for all types\n    public static final Predicate INSTANCE = new FalsePredicate<>();\n\n    /**\n     * Gets a typed instance.\n     *\n     * @param <T> the type that the predicate queries\n     * @return the singleton instance\n     * @since 4.0\n     */\n    public static <T> Predicate<T> falsePredicate() {\n        return INSTANCE;\n    }\n\n    /**\n     * Restricted constructor.\n     */\n    private FalsePredicate() {\n    }\n\n    /**\n     * Returns the singleton instance.\n     *\n     * @return the singleton instance.\n     */\n    private Object readResolve() {\n        return INSTANCE;\n    }\n\n    /**\n     * Evaluates the predicate returning false always.\n     *\n     * @param object  the input object\n     * @return false always\n     */\n    @Override\n    public boolean test(final T object) {\n        return false;\n    }\n\n}", "super_interfaces": ["Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 7533784454832764388L;", "docstring": " Serial version UID", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 7533784454832764388L", "syntax_pass": true}, {"attribute_expression": "@SuppressWarnings(\"rawtypes\") // the static instance works for all types\n    public static final Predicate INSTANCE = new FalsePredicate<>();", "docstring": " Singleton predicate instance", "modifiers": "@SuppressWarnings(\"rawtypes\") // the static instance works for all types\n    public static final", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"rawtypes\")", "public", "static", "final"], "comments": ["// the static instance works for all types"], "type": "Predicate", "name": "INSTANCE = new FalsePredicate<>()", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/functors/TruePredicate.java.TruePredicate", "name": "TruePredicate", "file_path": "src/main/java/org/apache/commons/collections4/functors/TruePredicate.java", "superclasses": "", "methods": ["[Predicate<T>]truePredicate()", "[]TruePredicate()", "[Object]readResolve()", "[boolean]test(T)"], "method_uris": ["src/main/java/org/apache/commons/collections4/functors/TruePredicate.java.TruePredicate.[Predicate<T>]truePredicate()", "src/main/java/org/apache/commons/collections4/functors/TruePredicate.java.TruePredicate.[]TruePredicate()", "src/main/java/org/apache/commons/collections4/functors/TruePredicate.java.TruePredicate.[Object]readResolve()", "src/main/java/org/apache/commons/collections4/functors/TruePredicate.java.TruePredicate.[boolean]test(T)"], "overrides": null, "attributes": [], "class_docstring": "\nPredicate implementation that always returns true.\n\n@param <T> the type of the input to the predicate.\n@since 3.0\n", "original_string": "public final class TruePredicate<T> extends AbstractPredicate<T> implements Serializable {\n\n    /** Serial version UID */\n    private static final long serialVersionUID = 3374767158756189740L;\n\n    /** Singleton predicate instance */\n    @SuppressWarnings(\"rawtypes\")\n    public static final Predicate INSTANCE = new TruePredicate<>();\n\n    /**\n     * Factory returning the singleton instance.\n     *\n     * @param <T> the type that the predicate queries\n     * @return the singleton instance\n     * @since 3.1\n     */\n    public static <T> Predicate<T> truePredicate() {\n        return INSTANCE;\n    }\n\n    /**\n     * Restricted constructor.\n     */\n    private TruePredicate() {\n    }\n\n    /**\n     * Returns the singleton instance.\n     *\n     * @return the singleton instance.\n     */\n    private Object readResolve() {\n        return INSTANCE;\n    }\n\n    /**\n     * Evaluates the predicate returning true always.\n     *\n     * @param object  the input object\n     * @return true always\n     */\n    @Override\n    public boolean test(final T object) {\n        return true;\n    }\n\n}", "super_interfaces": ["Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 3374767158756189740L;", "docstring": " Serial version UID", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 3374767158756189740L", "syntax_pass": true}, {"attribute_expression": "@SuppressWarnings(\"rawtypes\")\n    public static final Predicate INSTANCE = new TruePredicate<>();", "docstring": " Singleton predicate instance", "modifiers": "@SuppressWarnings(\"rawtypes\")\n    public static final", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"rawtypes\")", "public", "static", "final"], "comments": [], "type": "Predicate", "name": "INSTANCE = new TruePredicate<>()", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/functors/InstanceofPredicate.java.InstanceofPredicate", "name": "InstanceofPredicate", "file_path": "src/main/java/org/apache/commons/collections4/functors/InstanceofPredicate.java", "superclasses": "", "methods": ["[Predicate<Object>]instanceOfPredicate(Class<?>)", "[]InstanceofPredicate(Class<?>)", "[Class<?>]getType()", "[boolean]test(Object)"], "method_uris": ["src/main/java/org/apache/commons/collections4/functors/InstanceofPredicate.java.InstanceofPredicate.[Predicate<Object>]instanceOfPredicate(Class<?>)", "src/main/java/org/apache/commons/collections4/functors/InstanceofPredicate.java.InstanceofPredicate.[]InstanceofPredicate(Class<?>)", "src/main/java/org/apache/commons/collections4/functors/InstanceofPredicate.java.InstanceofPredicate.[Class<?>]getType()", "src/main/java/org/apache/commons/collections4/functors/InstanceofPredicate.java.InstanceofPredicate.[boolean]test(Object)"], "overrides": null, "attributes": [], "class_docstring": "\nPredicate implementation that returns true if the input is an instanceof\nthe type stored in this predicate.\n\n@since 3.0\n", "original_string": "public final class InstanceofPredicate extends AbstractPredicate<Object> implements Serializable {\n\n    /** Serial version UID */\n    private static final long serialVersionUID = -6682656911025165584L;\n\n    /**\n     * Factory to create the identity predicate.\n     *\n     * @param type  the type to check for, may not be null\n     * @return the predicate\n     * @throws NullPointerException if the class is null\n     */\n    public static Predicate<Object> instanceOfPredicate(final Class<?> type) {\n        return new InstanceofPredicate(Objects.requireNonNull(type, \"type\"));\n    }\n\n    /** The type to compare to */\n    private final Class<?> iType;\n\n    /**\n     * Constructor that performs no validation.\n     * Use {@code instanceOfPredicate} if you want that.\n     *\n     * @param type  the type to check for\n     */\n    public InstanceofPredicate(final Class<?> type) {\n        iType = type;\n    }\n\n    /**\n     * Gets the type to compare to.\n     *\n     * @return the type\n     * @since 3.1\n     */\n    public Class<?> getType() {\n        return iType;\n    }\n\n    /**\n     * Evaluates the predicate returning true if the input object is of the correct type.\n     *\n     * @param object  the input object\n     * @return true if input is of stored type\n     */\n    @Override\n    public boolean test(final Object object) {\n        return iType.isInstance(object);\n    }\n\n}", "super_interfaces": ["Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = -6682656911025165584L;", "docstring": " Serial version UID", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -6682656911025165584L", "syntax_pass": true}, {"attribute_expression": "private final Class<?> iType;", "docstring": " The type to compare to", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Class<?>", "name": "iType", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/functors/OnePredicate.java.OnePredicate", "name": "OnePredicate", "file_path": "src/main/java/org/apache/commons/collections4/functors/OnePredicate.java", "superclasses": "", "methods": ["[Predicate<T>]onePredicate(Collection<? extends Predicate<? super T>>)", "[Predicate<T>]onePredicate()", "[]OnePredicate()", "[boolean]test(T)"], "method_uris": ["src/main/java/org/apache/commons/collections4/functors/OnePredicate.java.OnePredicate.[Predicate<T>]onePredicate(Collection<? extends Predicate<? super T>>)", "src/main/java/org/apache/commons/collections4/functors/OnePredicate.java.OnePredicate.[Predicate<T>]onePredicate()", "src/main/java/org/apache/commons/collections4/functors/OnePredicate.java.OnePredicate.[]OnePredicate()", "src/main/java/org/apache/commons/collections4/functors/OnePredicate.java.OnePredicate.[boolean]test(T)"], "overrides": null, "attributes": [], "class_docstring": "\nPredicate implementation that returns true if only one of the\npredicates return true.\nIf the array of predicates is empty, then this predicate returns false.\n<p>\nNOTE: In versions prior to 3.2 an array size of zero or one\nthrew an exception.\n</p>\n\n@param <T> the type of the input to the predicate.\n@since 3.0\n", "original_string": "public final class OnePredicate<T> extends AbstractQuantifierPredicate<T> {\n\n    /** Serial version UID */\n    private static final long serialVersionUID = -8125389089924745785L;\n\n    /**\n     * Factory to create the predicate.\n     *\n     * @param <T> the type that the predicate queries\n     * @param predicates  the predicates to check, cloned, not null\n     * @return the {@code one} predicate\n     * @throws NullPointerException if the predicates array is null\n     * @throws NullPointerException if any predicate in the array is null\n     */\n    public static <T> Predicate<T> onePredicate(final Collection<? extends Predicate<? super T>> predicates) {\n        final Predicate<? super T>[] preds = FunctorUtils.validate(predicates);\n        return new OnePredicate<>(preds);\n    }\n\n    /**\n     * Factory to create the predicate.\n     * <p>\n     * If the array is size zero, the predicate always returns false.\n     * If the array is size one, then that predicate is returned.\n     *\n     * @param <T> the type that the predicate queries\n     * @param predicates  the predicates to check, cloned, not null\n     * @return the {@code any} predicate\n     * @throws NullPointerException if the predicates array is null\n     * @throws NullPointerException if any predicate in the array is null\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static <T> Predicate<T> onePredicate(final Predicate<? super T>... predicates) {\n        FunctorUtils.validate(predicates);\n        if (predicates.length == 0) {\n            return FalsePredicate.<T>falsePredicate();\n        }\n        if (predicates.length == 1) {\n            return (Predicate<T>) predicates[0];\n        }\n        // <T> not needed in Eclipse but needed by the command line compiler\n        return new OnePredicate<T>(FunctorUtils.copy(predicates));\n    }\n\n    /**\n     * Constructor that performs no validation.\n     * Use {@code onePredicate} if you want that.\n     *\n     * @param predicates  the predicates to check, not cloned, not null\n     */\n    public OnePredicate(final Predicate<? super T>... predicates) {\n        super(predicates);\n    }\n\n    /**\n     * Evaluates the predicate returning true if only one decorated predicate\n     * returns true.\n     *\n     * @param object  the input object\n     * @return true if only one decorated predicate returns true\n     */\n    @Override\n    public boolean test(final T object) {\n        boolean match = false;\n        for (final Predicate<? super T> iPredicate : iPredicates) {\n            if (iPredicate.test(object)) {\n                if (match) {\n                    return false;\n                }\n                match = true;\n            }\n        }\n        return match;\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = -8125389089924745785L;", "docstring": " Serial version UID", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -8125389089924745785L", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/functors/TransformerClosure.java.TransformerClosure", "name": "TransformerClosure", "file_path": "src/main/java/org/apache/commons/collections4/functors/TransformerClosure.java", "superclasses": "", "methods": ["[Closure<E>]transformerClosure(Transformer<? super E, ?>)", "[]TransformerClosure(Transformer<? super T, ?>)", "[void]execute(T)", "[Transformer<? super T, ?>]getTransformer()"], "method_uris": ["src/main/java/org/apache/commons/collections4/functors/TransformerClosure.java.TransformerClosure.[Closure<E>]transformerClosure(Transformer<? super E, ?>)", "src/main/java/org/apache/commons/collections4/functors/TransformerClosure.java.TransformerClosure.[]TransformerClosure(Transformer<? super T, ?>)", "src/main/java/org/apache/commons/collections4/functors/TransformerClosure.java.TransformerClosure.[void]execute(T)", "src/main/java/org/apache/commons/collections4/functors/TransformerClosure.java.TransformerClosure.[Transformer<? super T, ?>]getTransformer()"], "overrides": null, "attributes": [], "class_docstring": "\nClosure implementation that calls a Transformer using the input object\nand ignore the result.\n\n@param <T> the type of the input to the operation.\n@since 3.0\n", "original_string": "public class TransformerClosure<T> implements Closure<T>, Serializable {\n\n    /** Serial version UID */\n    private static final long serialVersionUID = -5194992589193388969L;\n\n    /**\n     * Factory method that performs validation.\n     * <p>\n     * A null transformer will return the {@code NOPClosure}.\n     *\n     * @param <E> the type that the closure acts on\n     * @param transformer  the transformer to call, null means nop\n     * @return the {@code transformer} closure\n     */\n    public static <E> Closure<E> transformerClosure(final Transformer<? super E, ?> transformer) {\n        if (transformer == null) {\n            return NOPClosure.<E>nopClosure();\n        }\n        return new TransformerClosure<>(transformer);\n    }\n\n    /** The transformer to wrap */\n    private final Transformer<? super T, ?> iTransformer;\n\n    /**\n     * Constructor that performs no validation.\n     * Use {@code transformerClosure} if you want that.\n     *\n     * @param transformer  the transformer to call, not null\n     */\n    public TransformerClosure(final Transformer<? super T, ?> transformer) {\n        iTransformer = transformer;\n    }\n\n    /**\n     * Executes the closure by calling the decorated transformer.\n     *\n     * @param input  the input object\n     */\n    @Override\n    public void execute(final T input) {\n        iTransformer.apply(input);\n    }\n\n    /**\n     * Gets the transformer.\n     *\n     * @return the transformer\n     * @since 3.1\n     */\n    public Transformer<? super T, ?> getTransformer() {\n        return iTransformer;\n    }\n\n}", "super_interfaces": ["Closure<T>", "Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = -5194992589193388969L;", "docstring": " Serial version UID", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -5194992589193388969L", "syntax_pass": true}, {"attribute_expression": "private final Transformer<? super T, ?> iTransformer;", "docstring": " The transformer to wrap", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Transformer<? super T, ?>", "name": "iTransformer", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/functors/StringValueTransformer.java.StringValueTransformer", "name": "StringValueTransformer", "file_path": "src/main/java/org/apache/commons/collections4/functors/StringValueTransformer.java", "superclasses": "", "methods": ["[Transformer<T, String>]stringValueTransformer()", "[]StringValueTransformer()", "[Object]readResolve()", "[String]transform(T)"], "method_uris": ["src/main/java/org/apache/commons/collections4/functors/StringValueTransformer.java.StringValueTransformer.[Transformer<T, String>]stringValueTransformer()", "src/main/java/org/apache/commons/collections4/functors/StringValueTransformer.java.StringValueTransformer.[]StringValueTransformer()", "src/main/java/org/apache/commons/collections4/functors/StringValueTransformer.java.StringValueTransformer.[Object]readResolve()", "src/main/java/org/apache/commons/collections4/functors/StringValueTransformer.java.StringValueTransformer.[String]transform(T)"], "overrides": null, "attributes": [], "class_docstring": "\nTransformer implementation that returns the result of calling\n{@code String.valueOf} on the input object.\n\n@param <T> the type of the input and result to the function.\n@since 3.0\n", "original_string": "public final class StringValueTransformer<T> implements Transformer<T, String>, Serializable {\n\n    /** Serial version UID */\n    private static final long serialVersionUID = 7511110693171758606L;\n\n    /** Singleton predicate instance */\n    private static final Transformer<Object, String> INSTANCE = new StringValueTransformer<>();\n\n    /**\n     * Factory returning the singleton instance.\n     *\n     * @param <T>  the input type\n     * @return the singleton instance\n     * @since 3.1\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static <T> Transformer<T, String> stringValueTransformer() {\n        return (Transformer<T, String>) INSTANCE;\n    }\n\n    /**\n     * Restricted constructor.\n     */\n    private StringValueTransformer() {\n    }\n\n    /**\n     * Returns the singleton instance.\n     *\n     * @return the singleton instance.\n     */\n    private Object readResolve() {\n        return INSTANCE;\n    }\n\n    /**\n     * Transforms the input to result by calling {@code String.valueOf}.\n     *\n     * @param input  the input object to transform\n     * @return the transformed result\n     */\n    @Override\n    public String transform(final T input) {\n        return String.valueOf(input);\n    }\n\n}", "super_interfaces": ["Transformer<T, String>", "Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 7511110693171758606L;", "docstring": " Serial version UID", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 7511110693171758606L", "syntax_pass": true}, {"attribute_expression": "private static final Transformer<Object, String> INSTANCE = new StringValueTransformer<>();", "docstring": " Singleton predicate instance", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Transformer<Object, String>", "name": "INSTANCE = new StringValueTransformer<>()", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/functors/CloneTransformer.java.CloneTransformer", "name": "CloneTransformer", "file_path": "src/main/java/org/apache/commons/collections4/functors/CloneTransformer.java", "superclasses": "", "methods": ["[Transformer<T, T>]cloneTransformer()", "[]CloneTransformer()", "[T]transform(T)"], "method_uris": ["src/main/java/org/apache/commons/collections4/functors/CloneTransformer.java.CloneTransformer.[Transformer<T, T>]cloneTransformer()", "src/main/java/org/apache/commons/collections4/functors/CloneTransformer.java.CloneTransformer.[]CloneTransformer()", "src/main/java/org/apache/commons/collections4/functors/CloneTransformer.java.CloneTransformer.[T]transform(T)"], "overrides": null, "attributes": [], "class_docstring": "\nTransformer implementation that returns a clone of the input object.\n<p>\nClone is performed using {@code PrototypeFactory.prototypeFactory(input).create()}.\n</p>\n<p>\n<b>WARNING:</b> from v4.1 onwards this class will <b>not</b> be serializable anymore\nin order to prevent potential remote code execution exploits. Please refer to\n<a href=\"https://issues.apache.org/jira/browse/COLLECTIONS-580\">COLLECTIONS-580</a>\nfor more details.\n</p>\n\n@param <T> the type of the input and result to the function.\n@since 3.0\n", "original_string": "public class CloneTransformer<T> implements Transformer<T, T> {\n\n    /** Singleton predicate instance */\n    @SuppressWarnings(\"rawtypes\") // the singleton instance works for all types\n    public static final Transformer INSTANCE = new CloneTransformer<>();\n\n    /**\n     * Factory returning the singleton instance.\n     *\n     * @param <T>  the type of the objects to be cloned\n     * @return the singleton instance\n     * @since 3.1\n     */\n    public static <T> Transformer<T, T> cloneTransformer() {\n        return INSTANCE;\n    }\n\n    /**\n     * Constructs a new instance.\n     */\n    private CloneTransformer() {\n    }\n\n    /**\n     * Transforms the input to result by cloning it.\n     *\n     * @param input  the input object to transform\n     * @return the transformed result\n     */\n    @Override\n    public T transform(final T input) {\n        if (input == null) {\n            return null;\n        }\n        return PrototypeFactory.prototypeFactory(input).get();\n    }\n\n}", "super_interfaces": ["Transformer<T, T>"], "fields": [{"attribute_expression": "@SuppressWarnings(\"rawtypes\") // the singleton instance works for all types\n    public static final Transformer INSTANCE = new CloneTransformer<>();", "docstring": " Singleton predicate instance", "modifiers": "@SuppressWarnings(\"rawtypes\") // the singleton instance works for all types\n    public static final", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"rawtypes\")", "public", "static", "final"], "comments": ["// the singleton instance works for all types"], "type": "Transformer", "name": "INSTANCE = new CloneTransformer<>()", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/functors/InstantiateTransformer.java.InstantiateTransformer", "name": "InstantiateTransformer", "file_path": "src/main/java/org/apache/commons/collections4/functors/InstantiateTransformer.java", "superclasses": "", "methods": ["[Transformer<Class<? extends T>, T>]instantiateTransformer()", "[Transformer<Class<? extends T>, T>]instantiateTransformer(Class<?>[],Object[])", "[]InstantiateTransformer()", "[]InstantiateTransformer(Class<?>[],Object[])", "[T]transform(Class<? extends T>)"], "method_uris": ["src/main/java/org/apache/commons/collections4/functors/InstantiateTransformer.java.InstantiateTransformer.[Transformer<Class<? extends T>, T>]instantiateTransformer()", "src/main/java/org/apache/commons/collections4/functors/InstantiateTransformer.java.InstantiateTransformer.[Transformer<Class<? extends T>, T>]instantiateTransformer(Class<?>[],Object[])", "src/main/java/org/apache/commons/collections4/functors/InstantiateTransformer.java.InstantiateTransformer.[]InstantiateTransformer()", "src/main/java/org/apache/commons/collections4/functors/InstantiateTransformer.java.InstantiateTransformer.[]InstantiateTransformer(Class<?>[],Object[])", "src/main/java/org/apache/commons/collections4/functors/InstantiateTransformer.java.InstantiateTransformer.[T]transform(Class<? extends T>)"], "overrides": null, "attributes": [], "class_docstring": "\nTransformer implementation that creates a new object instance by reflection.\n<p>\n<b>WARNING:</b> from v4.1 onwards this class will <b>not</b> be serializable anymore\nin order to prevent potential remote code execution exploits. Please refer to\n<a href=\"https://issues.apache.org/jira/browse/COLLECTIONS-580\">COLLECTIONS-580</a>\nfor more details.\n</p>\n\n@param <T> the type of the input and result to the function.\n@since 3.0\n", "original_string": "public class InstantiateTransformer<T> implements Transformer<Class<? extends T>, T> {\n\n    /** Singleton instance that uses the no arg constructor */\n    @SuppressWarnings(\"rawtypes\")\n    private static final Transformer NO_ARG_INSTANCE = new InstantiateTransformer<>();\n\n    /**\n     * Gets a typed no-arg instance.\n     *\n     * @param <T>  the type of the objects to be created\n     * @return Transformer&lt;Class&lt;? extends T&gt;, T&gt;\n     */\n    public static <T> Transformer<Class<? extends T>, T> instantiateTransformer() {\n        return NO_ARG_INSTANCE;\n    }\n    /**\n     * Transformer method that performs validation.\n     *\n     * @param <T>  the type of the objects to be created\n     * @param paramTypes  the constructor parameter types\n     * @param args  the constructor arguments\n     * @return an instantiate transformer\n     * @throws IllegalArgumentException if paramTypes does not match args\n     */\n    public static <T> Transformer<Class<? extends T>, T> instantiateTransformer(final Class<?>[] paramTypes,\n                                                                                final Object[] args) {\n        if (paramTypes == null && args != null\n            || paramTypes != null && args == null\n            || paramTypes != null && args != null && paramTypes.length != args.length) {\n            throw new IllegalArgumentException(\"Parameter types must match the arguments\");\n        }\n\n        if (paramTypes == null || paramTypes.length == 0) {\n            return new InstantiateTransformer<>();\n        }\n        return new InstantiateTransformer<>(paramTypes, args);\n    }\n\n    /** The constructor parameter types */\n    private final Class<?>[] iParamTypes;\n\n    /** The constructor arguments */\n    private final Object[] iArgs;\n\n    /**\n     * Constructor for no arg instance.\n     */\n    private InstantiateTransformer() {\n        iParamTypes = null;\n        iArgs = null;\n    }\n\n    /**\n     * Constructor that performs no validation.\n     * Use {@code instantiateTransformer} if you want that.\n     * <p>\n     * Note: from 4.0, the input parameters will be cloned\n     *\n     * @param paramTypes  the constructor parameter types\n     * @param args  the constructor arguments\n     */\n    public InstantiateTransformer(final Class<?>[] paramTypes, final Object[] args) {\n        iParamTypes = paramTypes != null ? paramTypes.clone() : null;\n        iArgs = args != null ? args.clone() : null;\n    }\n\n    /**\n     * Transforms the input Class object to a result by instantiation.\n     *\n     * @param input  the input object to transform\n     * @return the transformed result\n     */\n    @Override\n    public T transform(final Class<? extends T> input) {\n        try {\n            if (input == null) {\n                throw new FunctorException(\n                    \"InstantiateTransformer: Input object was not an instanceof Class, it was a null object\");\n            }\n            final Constructor<? extends T> con = input.getConstructor(iParamTypes);\n            return con.newInstance(iArgs);\n        } catch (final NoSuchMethodException ex) {\n            throw new FunctorException(\"InstantiateTransformer: The constructor must exist and be public \");\n        } catch (final InstantiationException ex) {\n            throw new FunctorException(\"InstantiateTransformer: InstantiationException\", ex);\n        } catch (final IllegalAccessException ex) {\n            throw new FunctorException(\"InstantiateTransformer: Constructor must be public\", ex);\n        } catch (final InvocationTargetException ex) {\n            throw new FunctorException(\"InstantiateTransformer: Constructor threw an exception\", ex);\n        }\n    }\n\n}", "super_interfaces": ["Transformer<Class<? extends T>, T>"], "fields": [{"attribute_expression": "@SuppressWarnings(\"rawtypes\")\n    private static final Transformer NO_ARG_INSTANCE = new InstantiateTransformer<>();", "docstring": " Singleton instance that uses the no arg constructor", "modifiers": "@SuppressWarnings(\"rawtypes\")\n    private static final", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"rawtypes\")", "private", "static", "final"], "comments": [], "type": "Transformer", "name": "NO_ARG_INSTANCE = new InstantiateTransformer<>()", "syntax_pass": true}, {"attribute_expression": "private final Class<?>[] iParamTypes;", "docstring": " The constructor parameter types", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Class<?>[]", "name": "iParamTypes", "syntax_pass": true}, {"attribute_expression": "private final Object[] iArgs;", "docstring": " The constructor arguments", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Object[]", "name": "iArgs", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/functors/PredicateTransformer.java.PredicateTransformer", "name": "PredicateTransformer", "file_path": "src/main/java/org/apache/commons/collections4/functors/PredicateTransformer.java", "superclasses": "", "methods": ["[Transformer<T, Boolean>]predicateTransformer(Predicate<? super T>)", "[]PredicateTransformer(Predicate<? super T>)", "[Predicate<? super T>]getPredicate()", "[Boolean]transform(T)"], "method_uris": ["src/main/java/org/apache/commons/collections4/functors/PredicateTransformer.java.PredicateTransformer.[Transformer<T, Boolean>]predicateTransformer(Predicate<? super T>)", "src/main/java/org/apache/commons/collections4/functors/PredicateTransformer.java.PredicateTransformer.[]PredicateTransformer(Predicate<? super T>)", "src/main/java/org/apache/commons/collections4/functors/PredicateTransformer.java.PredicateTransformer.[Predicate<? super T>]getPredicate()", "src/main/java/org/apache/commons/collections4/functors/PredicateTransformer.java.PredicateTransformer.[Boolean]transform(T)"], "overrides": null, "attributes": [], "class_docstring": "\nTransformer implementation that calls a Predicate using the input object\nand then returns the result.\n\n@param <T> the type of the input and result to the function.\n@since 3.0\n", "original_string": "public class PredicateTransformer<T> implements Transformer<T, Boolean>, Serializable {\n\n    /** Serial version UID */\n    private static final long serialVersionUID = 5278818408044349346L;\n\n    /**\n     * Factory method that performs validation.\n     *\n     * @param <T>  the input type\n     * @param predicate  the predicate to call, not null\n     * @return the {@code predicate} transformer\n     * @throws IllegalArgumentException if the predicate is null\n     */\n    public static <T> Transformer<T, Boolean> predicateTransformer(final Predicate<? super T> predicate) {\n        if (predicate == null) {\n            throw new IllegalArgumentException(\"Predicate must not be null\");\n        }\n        return new PredicateTransformer<>(predicate);\n    }\n\n    /** The closure to wrap */\n    private final Predicate<? super T> iPredicate;\n\n    /**\n     * Constructor that performs no validation.\n     * Use {@code predicateTransformer} if you want that.\n     *\n     * @param predicate  the predicate to call, not null\n     */\n    public PredicateTransformer(final Predicate<? super T> predicate) {\n        iPredicate = predicate;\n    }\n\n    /**\n     * Gets the predicate.\n     *\n     * @return the predicate\n     * @since 3.1\n     */\n    public Predicate<? super T> getPredicate() {\n        return iPredicate;\n    }\n\n    /**\n     * Transforms the input to result by calling a predicate.\n     *\n     * @param input  the input object to transform\n     * @return the transformed result\n     */\n    @Override\n    public Boolean transform(final T input) {\n        return Boolean.valueOf(iPredicate.test(input));\n    }\n\n}", "super_interfaces": ["Transformer<T, Boolean>", "Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 5278818408044349346L;", "docstring": " Serial version UID", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 5278818408044349346L", "syntax_pass": true}, {"attribute_expression": "private final Predicate<? super T> iPredicate;", "docstring": " The closure to wrap", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Predicate<? super T>", "name": "iPredicate", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/functors/TransformerPredicate.java.TransformerPredicate", "name": "TransformerPredicate", "file_path": "src/main/java/org/apache/commons/collections4/functors/TransformerPredicate.java", "superclasses": "", "methods": ["[Predicate<T>]transformerPredicate(Transformer<? super T, Boolean>)", "[]TransformerPredicate(Transformer<? super T, Boolean>)", "[Transformer<? super T, Boolean>]getTransformer()", "[boolean]test(T)"], "method_uris": ["src/main/java/org/apache/commons/collections4/functors/TransformerPredicate.java.TransformerPredicate.[Predicate<T>]transformerPredicate(Transformer<? super T, Boolean>)", "src/main/java/org/apache/commons/collections4/functors/TransformerPredicate.java.TransformerPredicate.[]TransformerPredicate(Transformer<? super T, Boolean>)", "src/main/java/org/apache/commons/collections4/functors/TransformerPredicate.java.TransformerPredicate.[Transformer<? super T, Boolean>]getTransformer()", "src/main/java/org/apache/commons/collections4/functors/TransformerPredicate.java.TransformerPredicate.[boolean]test(T)"], "overrides": null, "attributes": [], "class_docstring": "\nPredicate implementation that returns the result of a transformer.\n\n@param <T> the type of the input to the predicate.\n@since 3.0\n", "original_string": "public final class TransformerPredicate<T> extends AbstractPredicate<T> implements Serializable {\n\n    /** Serial version UID */\n    private static final long serialVersionUID = -2407966402920578741L;\n\n    /**\n     * Factory to create the predicate.\n     *\n     * @param <T> the type that the predicate queries\n     * @param transformer  the transformer to decorate\n     * @return the predicate\n     * @throws NullPointerException if the transformer is null\n     */\n    public static <T> Predicate<T> transformerPredicate(final Transformer<? super T, Boolean> transformer) {\n        return new TransformerPredicate<>(Objects.requireNonNull(transformer, \"transformer\"));\n    }\n\n    /** The transformer to call */\n    private final Transformer<? super T, Boolean> iTransformer;\n\n    /**\n     * Constructor that performs no validation.\n     * Use {@code transformerPredicate} if you want that.\n     *\n     * @param transformer  the transformer to decorate\n     */\n    public TransformerPredicate(final Transformer<? super T, Boolean> transformer) {\n        iTransformer = transformer;\n    }\n\n    /**\n     * Gets the transformer.\n     *\n     * @return the transformer\n     * @since 3.1\n     */\n    public Transformer<? super T, Boolean> getTransformer() {\n        return iTransformer;\n    }\n\n    /**\n     * Evaluates the predicate returning the result of the decorated transformer.\n     *\n     * @param object  the input object\n     * @return true if decorated transformer returns Boolean.TRUE\n     * @throws FunctorException if the transformer returns an invalid type\n     */\n    @Override\n    public boolean test(final T object) {\n        final Boolean result = iTransformer.apply(object);\n        if (result == null) {\n            throw new FunctorException(\n                    \"Transformer must return an instanceof Boolean, it was a null object\");\n        }\n        return result.booleanValue();\n    }\n\n}", "super_interfaces": ["Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = -2407966402920578741L;", "docstring": " Serial version UID", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -2407966402920578741L", "syntax_pass": true}, {"attribute_expression": "private final Transformer<? super T, Boolean> iTransformer;", "docstring": " The transformer to call", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Transformer<? super T, Boolean>", "name": "iTransformer", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/functors/NullIsFalsePredicate.java.NullIsFalsePredicate", "name": "NullIsFalsePredicate", "file_path": "src/main/java/org/apache/commons/collections4/functors/NullIsFalsePredicate.java", "superclasses": "", "methods": ["[Predicate<T>]nullIsFalsePredicate(Predicate<? super T>)", "[]NullIsFalsePredicate(Predicate<? super T>)", "[Predicate<? super T>[]]getPredicates()", "[boolean]test(T)"], "method_uris": ["src/main/java/org/apache/commons/collections4/functors/NullIsFalsePredicate.java.NullIsFalsePredicate.[Predicate<T>]nullIsFalsePredicate(Predicate<? super T>)", "src/main/java/org/apache/commons/collections4/functors/NullIsFalsePredicate.java.NullIsFalsePredicate.[]NullIsFalsePredicate(Predicate<? super T>)", "src/main/java/org/apache/commons/collections4/functors/NullIsFalsePredicate.java.NullIsFalsePredicate.[Predicate<? super T>[]]getPredicates()", "src/main/java/org/apache/commons/collections4/functors/NullIsFalsePredicate.java.NullIsFalsePredicate.[boolean]test(T)"], "overrides": null, "attributes": [], "class_docstring": "\nPredicate implementation that returns false if the input is null.\n\n@param <T> the type of the input to the predicate.\n@since 3.0\n", "original_string": "public final class NullIsFalsePredicate<T> extends AbstractPredicate<T> implements PredicateDecorator<T>, Serializable {\n\n    /** Serial version UID */\n    private static final long serialVersionUID = -2997501534564735525L;\n\n    /**\n     * Factory to create the null false predicate.\n     *\n     * @param <T> the type that the predicate queries\n     * @param predicate  the predicate to decorate, not null\n     * @return the predicate\n     * @throws NullPointerException if the predicate is null\n     */\n    public static <T> Predicate<T> nullIsFalsePredicate(final Predicate<? super T> predicate) {\n        return new NullIsFalsePredicate<>(Objects.requireNonNull(predicate, \"predicate\"));\n    }\n\n    /** The predicate to decorate */\n    private final Predicate<? super T> iPredicate;\n\n    /**\n     * Constructor that performs no validation.\n     * Use {@code nullIsFalsePredicate} if you want that.\n     *\n     * @param predicate  the predicate to call after the null check\n     */\n    public NullIsFalsePredicate(final Predicate<? super T> predicate) {\n        iPredicate = predicate;\n    }\n\n    /**\n     * Gets the predicate being decorated.\n     *\n     * @return the predicate as the only element in an array\n     * @since 3.1\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public Predicate<? super T>[] getPredicates() {\n        return new Predicate[] { iPredicate };\n    }\n\n    /**\n     * Evaluates the predicate returning the result of the decorated predicate\n     * once a null check is performed.\n     *\n     * @param object  the input object\n     * @return true if decorated predicate returns true, false if input is null\n     */\n    @Override\n    public boolean test(final T object) {\n        if (object == null) {\n            return false;\n        }\n        return iPredicate.test(object);\n    }\n\n}", "super_interfaces": ["PredicateDecorator<T>", "Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = -2997501534564735525L;", "docstring": " Serial version UID", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -2997501534564735525L", "syntax_pass": true}, {"attribute_expression": "private final Predicate<? super T> iPredicate;", "docstring": " The predicate to decorate", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Predicate<? super T>", "name": "iPredicate", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/functors/OrPredicate.java.OrPredicate", "name": "OrPredicate", "file_path": "src/main/java/org/apache/commons/collections4/functors/OrPredicate.java", "superclasses": "", "methods": ["[Predicate<T>]orPredicate(Predicate<? super T>,Predicate<? super T>)", "[]OrPredicate(Predicate<? super T>,Predicate<? super T>)", "[Predicate<? super T>[]]getPredicates()", "[boolean]test(T)"], "method_uris": ["src/main/java/org/apache/commons/collections4/functors/OrPredicate.java.OrPredicate.[Predicate<T>]orPredicate(Predicate<? super T>,Predicate<? super T>)", "src/main/java/org/apache/commons/collections4/functors/OrPredicate.java.OrPredicate.[]OrPredicate(Predicate<? super T>,Predicate<? super T>)", "src/main/java/org/apache/commons/collections4/functors/OrPredicate.java.OrPredicate.[Predicate<? super T>[]]getPredicates()", "src/main/java/org/apache/commons/collections4/functors/OrPredicate.java.OrPredicate.[boolean]test(T)"], "overrides": null, "attributes": [], "class_docstring": "\nPredicate implementation that returns true if either of the predicates return true.\n\n@param <T> the type of the input to the predicate.\n@since 3.0\n", "original_string": "public final class OrPredicate<T> extends AbstractPredicate<T> implements PredicateDecorator<T>, Serializable {\n\n    /** Serial version UID */\n    private static final long serialVersionUID = -8791518325735182855L;\n\n    /**\n     * Factory to create the predicate.\n     *\n     * @param <T> the type that the predicate queries\n     * @param predicate1  the first predicate to check, not null\n     * @param predicate2  the second predicate to check, not null\n     * @return the {@code and} predicate\n     * @throws NullPointerException if either predicate is null\n     */\n    public static <T> Predicate<T> orPredicate(final Predicate<? super T> predicate1,\n                                               final Predicate<? super T> predicate2) {\n        return new OrPredicate<>(Objects.requireNonNull(predicate1, \"predicate1\"),\n                Objects.requireNonNull(predicate2, \"predicate2\"));\n    }\n    /** The array of predicates to call */\n    private final Predicate<? super T> iPredicate1;\n\n    /** The array of predicates to call */\n    private final Predicate<? super T> iPredicate2;\n\n    /**\n     * Constructor that performs no validation.\n     * Use {@code orPredicate} if you want that.\n     *\n     * @param predicate1  the first predicate to check, not null\n     * @param predicate2  the second predicate to check, not null\n     */\n    public OrPredicate(final Predicate<? super T> predicate1, final Predicate<? super T> predicate2) {\n        iPredicate1 = predicate1;\n        iPredicate2 = predicate2;\n    }\n\n    /**\n     * Gets the two predicates being decorated as an array.\n     *\n     * @return the predicates\n     * @since 3.1\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public Predicate<? super T>[] getPredicates() {\n        return new Predicate[] {iPredicate1, iPredicate2};\n    }\n\n    /**\n     * Evaluates the predicate returning true if either predicate returns true.\n     *\n     * @param object  the input object\n     * @return true if either decorated predicate returns true\n     */\n    @Override\n    public boolean test(final T object) {\n        return iPredicate1.test(object) || iPredicate2.test(object);\n    }\n\n}", "super_interfaces": ["PredicateDecorator<T>", "Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = -8791518325735182855L;", "docstring": " Serial version UID", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -8791518325735182855L", "syntax_pass": true}, {"attribute_expression": "private final Predicate<? super T> iPredicate1;", "docstring": " The array of predicates to call", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Predicate<? super T>", "name": "iPredicate1", "syntax_pass": true}, {"attribute_expression": "private final Predicate<? super T> iPredicate2;", "docstring": " The array of predicates to call", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Predicate<? super T>", "name": "iPredicate2", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/functors/IdentityPredicate.java.IdentityPredicate", "name": "IdentityPredicate", "file_path": "src/main/java/org/apache/commons/collections4/functors/IdentityPredicate.java", "superclasses": "", "methods": ["[Predicate<T>]identityPredicate(T)", "[]IdentityPredicate(T)", "[T]getValue()", "[boolean]test(T)"], "method_uris": ["src/main/java/org/apache/commons/collections4/functors/IdentityPredicate.java.IdentityPredicate.[Predicate<T>]identityPredicate(T)", "src/main/java/org/apache/commons/collections4/functors/IdentityPredicate.java.IdentityPredicate.[]IdentityPredicate(T)", "src/main/java/org/apache/commons/collections4/functors/IdentityPredicate.java.IdentityPredicate.[T]getValue()", "src/main/java/org/apache/commons/collections4/functors/IdentityPredicate.java.IdentityPredicate.[boolean]test(T)"], "overrides": null, "attributes": [], "class_docstring": "\nPredicate implementation that returns true if the input is the same object\nas the one stored in this predicate.\n\n@param <T> the type of the input to the predicate.\n@since 3.0\n", "original_string": "public final class IdentityPredicate<T> extends AbstractPredicate<T> implements Serializable {\n\n    /** Serial version UID */\n    private static final long serialVersionUID = -89901658494523293L;\n\n    /**\n     * Factory to create the identity predicate.\n     *\n     * @param <T> the type that the predicate queries\n     * @param object  the object to compare to\n     * @return the predicate\n     */\n    public static <T> Predicate<T> identityPredicate(final T object) {\n        if (object == null) {\n            return NullPredicate.<T>nullPredicate();\n        }\n        return new IdentityPredicate<>(object);\n    }\n\n    /** The value to compare to */\n    private final T iValue;\n\n    /**\n     * Constructor that performs no validation.\n     * Use {@code identityPredicate} if you want that.\n     *\n     * @param object  the object to compare to\n     */\n    public IdentityPredicate(final T object) {\n        iValue = object;\n    }\n\n    /**\n     * Gets the value.\n     *\n     * @return the value\n     * @since 3.1\n     */\n    public T getValue() {\n        return iValue;\n    }\n\n    /**\n     * Evaluates the predicate returning true if the input object is identical to\n     * the stored object.\n     *\n     * @param object  the input object\n     * @return true if input is the same object as the stored value\n     */\n    @Override\n    public boolean test(final T object) {\n        return iValue == object;\n    }\n\n}", "super_interfaces": ["Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = -89901658494523293L;", "docstring": " Serial version UID", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -89901658494523293L", "syntax_pass": true}, {"attribute_expression": "private final T iValue;", "docstring": " The value to compare to", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "T", "name": "iValue", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/functors/NotPredicate.java.NotPredicate", "name": "NotPredicate", "file_path": "src/main/java/org/apache/commons/collections4/functors/NotPredicate.java", "superclasses": "", "methods": ["[Predicate<T>]notPredicate(Predicate<? super T>)", "[]NotPredicate(Predicate<? super T>)", "[Predicate<? super T>[]]getPredicates()", "[boolean]test(T)"], "method_uris": ["src/main/java/org/apache/commons/collections4/functors/NotPredicate.java.NotPredicate.[Predicate<T>]notPredicate(Predicate<? super T>)", "src/main/java/org/apache/commons/collections4/functors/NotPredicate.java.NotPredicate.[]NotPredicate(Predicate<? super T>)", "src/main/java/org/apache/commons/collections4/functors/NotPredicate.java.NotPredicate.[Predicate<? super T>[]]getPredicates()", "src/main/java/org/apache/commons/collections4/functors/NotPredicate.java.NotPredicate.[boolean]test(T)"], "overrides": null, "attributes": [], "class_docstring": "\nPredicate implementation that returns the opposite of the decorated predicate.\n\n@param <T> the type of the input to the predicate.\n@since 3.0\n", "original_string": "public final class NotPredicate<T> extends AbstractPredicate<T> implements PredicateDecorator<T>, Serializable {\n\n    /** Serial version UID */\n    private static final long serialVersionUID = -2654603322338049674L;\n\n    /**\n     * Factory to create the not predicate.\n     *\n     * @param <T> the type that the predicate queries\n     * @param predicate  the predicate to decorate, not null\n     * @return the predicate\n     * @throws NullPointerException if the predicate is null\n     */\n    public static <T> Predicate<T> notPredicate(final Predicate<? super T> predicate) {\n        return new NotPredicate<>(Objects.requireNonNull(predicate, \"predicate\"));\n    }\n\n    /** The predicate to decorate */\n    private final Predicate<? super T> iPredicate;\n\n    /**\n     * Constructor that performs no validation.\n     * Use {@code notPredicate} if you want that.\n     *\n     * @param predicate  the predicate to call after the null check\n     */\n    public NotPredicate(final Predicate<? super T> predicate) {\n        iPredicate = predicate;\n    }\n\n    /**\n     * Gets the predicate being decorated.\n     *\n     * @return the predicate as the only element in an array\n     * @since 3.1\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public Predicate<? super T>[] getPredicates() {\n        return new Predicate[] {iPredicate};\n    }\n\n    /**\n     * Evaluates the predicate returning the opposite to the stored predicate.\n     *\n     * @param object  the input object\n     * @return true if predicate returns false\n     */\n    @Override\n    public boolean test(final T object) {\n        return !iPredicate.test(object);\n    }\n\n}", "super_interfaces": ["PredicateDecorator<T>", "Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = -2654603322338049674L;", "docstring": " Serial version UID", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -2654603322338049674L", "syntax_pass": true}, {"attribute_expression": "private final Predicate<? super T> iPredicate;", "docstring": " The predicate to decorate", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Predicate<? super T>", "name": "iPredicate", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/functors/AnyPredicate.java.AnyPredicate", "name": "AnyPredicate", "file_path": "src/main/java/org/apache/commons/collections4/functors/AnyPredicate.java", "superclasses": "", "methods": ["[Predicate<T>]anyPredicate(Collection<? extends Predicate<? super T>>)", "[Predicate<T>]anyPredicate()", "[]AnyPredicate()", "[boolean]test(T)"], "method_uris": ["src/main/java/org/apache/commons/collections4/functors/AnyPredicate.java.AnyPredicate.[Predicate<T>]anyPredicate(Collection<? extends Predicate<? super T>>)", "src/main/java/org/apache/commons/collections4/functors/AnyPredicate.java.AnyPredicate.[Predicate<T>]anyPredicate()", "src/main/java/org/apache/commons/collections4/functors/AnyPredicate.java.AnyPredicate.[]AnyPredicate()", "src/main/java/org/apache/commons/collections4/functors/AnyPredicate.java.AnyPredicate.[boolean]test(T)"], "overrides": null, "attributes": [], "class_docstring": "\nPredicate implementation that returns true if any of the\npredicates return true.\nIf the array of predicates is empty, then this predicate returns false.\n<p>\nNOTE: In versions prior to 3.2 an array size of zero or one\nthrew an exception.\n</p>\n\n@param <T> the type of the input to the predicate.\n@since 3.0\n", "original_string": "public final class AnyPredicate<T> extends AbstractQuantifierPredicate<T> {\n\n    /** Serial version UID */\n    private static final long serialVersionUID = 7429999530934647542L;\n\n    /**\n     * Factory to create the predicate.\n     * <p>\n     * If the collection is size zero, the predicate always returns false.\n     * If the collection is size one, then that predicate is returned.\n     *\n     * @param <T> the type that the predicate queries\n     * @param predicates  the predicates to check, cloned, not null\n     * @return the {@code all} predicate\n     * @throws NullPointerException if the predicates array is null\n     * @throws NullPointerException if any predicate in the array is null\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static <T> Predicate<T> anyPredicate(final Collection<? extends Predicate<? super T>> predicates) {\n        final Predicate<? super T>[] preds = FunctorUtils.validate(predicates);\n        if (preds.length == 0) {\n            return FalsePredicate.<T>falsePredicate();\n        }\n        if (preds.length == 1) {\n            return (Predicate<T>) preds[0];\n        }\n        return new AnyPredicate<>(preds);\n    }\n\n    /**\n     * Factory to create the predicate.\n     * <p>\n     * If the array is size zero, the predicate always returns false.\n     * If the array is size one, then that predicate is returned.\n     *\n     * @param <T> the type that the predicate queries\n     * @param predicates  the predicates to check, cloned, not null\n     * @return the {@code any} predicate\n     * @throws NullPointerException if the predicates array is null\n     * @throws NullPointerException if any predicate in the array is null\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static <T> Predicate<T> anyPredicate(final Predicate<? super T>... predicates) {\n        FunctorUtils.validate(predicates);\n        if (predicates.length == 0) {\n            return FalsePredicate.<T>falsePredicate();\n        }\n        if (predicates.length == 1) {\n            return (Predicate<T>) predicates[0];\n        }\n        return new AnyPredicate<T>(FunctorUtils.copy(predicates));\n    }\n\n    /**\n     * Constructor that performs no validation.\n     * Use {@code anyPredicate} if you want that.\n     *\n     * @param predicates  the predicates to check, not cloned, not null\n     */\n    public AnyPredicate(final Predicate<? super T>... predicates) {\n        super(predicates);\n    }\n\n    /**\n     * Evaluates the predicate returning true if any predicate returns true.\n     *\n     * @param object  the input object\n     * @return true if any decorated predicate return true\n     */\n    @Override\n    public boolean test(final T object) {\n        for (final Predicate<? super T> iPredicate : iPredicates) {\n            if (iPredicate.test(object)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = 7429999530934647542L;", "docstring": " Serial version UID", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 7429999530934647542L", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/functors/NonePredicate.java.NonePredicate", "name": "NonePredicate", "file_path": "src/main/java/org/apache/commons/collections4/functors/NonePredicate.java", "superclasses": "", "methods": ["[Predicate<T>]nonePredicate(Collection<? extends Predicate<? super T>>)", "[Predicate<T>]nonePredicate()", "[]NonePredicate()", "[boolean]test(T)"], "method_uris": ["src/main/java/org/apache/commons/collections4/functors/NonePredicate.java.NonePredicate.[Predicate<T>]nonePredicate(Collection<? extends Predicate<? super T>>)", "src/main/java/org/apache/commons/collections4/functors/NonePredicate.java.NonePredicate.[Predicate<T>]nonePredicate()", "src/main/java/org/apache/commons/collections4/functors/NonePredicate.java.NonePredicate.[]NonePredicate()", "src/main/java/org/apache/commons/collections4/functors/NonePredicate.java.NonePredicate.[boolean]test(T)"], "overrides": null, "attributes": [], "class_docstring": "\nPredicate implementation that returns true if none of the\npredicates return true.\nIf the array of predicates is empty, then this predicate returns true.\n<p>\nNOTE: In versions prior to 3.2 an array size of zero or one\nthrew an exception.\n</p>\n\n@param <T> the type of the input to the predicate.\n@since 3.0\n", "original_string": "public final class NonePredicate<T> extends AbstractQuantifierPredicate<T> {\n\n    /** Serial version UID */\n    private static final long serialVersionUID = 2007613066565892961L;\n\n    /**\n     * Factory to create the predicate.\n     * <p>\n     * If the collection is size zero, the predicate always returns true.\n     *\n     * @param <T> the type that the predicate queries\n     * @param predicates  the predicates to check, cloned, not null\n     * @return the {@code one} predicate\n     * @throws NullPointerException if the predicates array is null\n     * @throws NullPointerException if any predicate in the array is null\n     */\n    public static <T> Predicate<T> nonePredicate(final Collection<? extends Predicate<? super T>> predicates) {\n        final Predicate<? super T>[] preds = FunctorUtils.validate(predicates);\n        if (preds.length == 0) {\n            return TruePredicate.<T>truePredicate();\n        }\n        return new NonePredicate<>(preds);\n    }\n\n    /**\n     * Factory to create the predicate.\n     * <p>\n     * If the array is size zero, the predicate always returns true.\n     *\n     * @param <T> the type that the predicate queries\n     * @param predicates  the predicates to check, cloned, not null\n     * @return the {@code any} predicate\n     * @throws NullPointerException if the predicates array is null\n     * @throws NullPointerException if any predicate in the array is null\n     */\n    public static <T> Predicate<T> nonePredicate(final Predicate<? super T>... predicates) {\n        FunctorUtils.validate(predicates);\n        if (predicates.length == 0) {\n            return TruePredicate.<T>truePredicate();\n        }\n        // <T> not needed in Eclipse but needed by the command line compiler\n        return new NonePredicate<T>(FunctorUtils.copy(predicates));\n    }\n\n    /**\n     * Constructor that performs no validation.\n     * Use {@code nonePredicate} if you want that.\n     *\n     * @param predicates  the predicates to check, not cloned, not null\n     */\n    public NonePredicate(final Predicate<? super T>... predicates) {\n        super(predicates);\n    }\n\n    /**\n     * Evaluates the predicate returning false if any stored predicate returns false.\n     *\n     * @param object  the input object\n     * @return true if none of decorated predicates return true\n     */\n    @Override\n    public boolean test(final T object) {\n        for (final Predicate<? super T> iPredicate : iPredicates) {\n            if (iPredicate.test(object)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = 2007613066565892961L;", "docstring": " Serial version UID", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 2007613066565892961L", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/functors/NotNullPredicate.java.NotNullPredicate", "name": "NotNullPredicate", "file_path": "src/main/java/org/apache/commons/collections4/functors/NotNullPredicate.java", "superclasses": "", "methods": ["[Predicate<T>]notNullPredicate()", "[]NotNullPredicate()", "[Object]readResolve()", "[boolean]test(T)"], "method_uris": ["src/main/java/org/apache/commons/collections4/functors/NotNullPredicate.java.NotNullPredicate.[Predicate<T>]notNullPredicate()", "src/main/java/org/apache/commons/collections4/functors/NotNullPredicate.java.NotNullPredicate.[]NotNullPredicate()", "src/main/java/org/apache/commons/collections4/functors/NotNullPredicate.java.NotNullPredicate.[Object]readResolve()", "src/main/java/org/apache/commons/collections4/functors/NotNullPredicate.java.NotNullPredicate.[boolean]test(T)"], "overrides": null, "attributes": [], "class_docstring": "\nPredicate implementation that returns true if the input is not null.\n\n@param <T> the type of the input to the predicate.\n@since 3.0\n", "original_string": "public final class NotNullPredicate<T> extends AbstractPredicate<T> implements Serializable {\n\n    /** Serial version UID */\n    private static final long serialVersionUID = 7533784454832764388L;\n\n    /** Singleton predicate instance */\n    @SuppressWarnings(\"rawtypes\")\n    public static final Predicate INSTANCE = new NotNullPredicate<>();\n\n    /**\n     * Factory returning the singleton instance.\n     *\n     * @param <T> the type that the predicate queries\n     * @return the singleton instance\n     * @since 3.1\n     */\n    public static <T> Predicate<T> notNullPredicate() {\n        return INSTANCE;\n    }\n\n    /**\n     * Restricted constructor.\n     */\n    private NotNullPredicate() {\n    }\n\n    /**\n     * Returns the singleton instance.\n     *\n     * @return the singleton instance.\n     */\n    private Object readResolve() {\n        return INSTANCE;\n    }\n\n    /**\n     * Evaluates the predicate returning true if the object does not equal null.\n     *\n     * @param object  the object to evaluate\n     * @return true if not null\n     */\n    @Override\n    public boolean test(final T object) {\n        return object != null;\n    }\n\n}", "super_interfaces": ["Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 7533784454832764388L;", "docstring": " Serial version UID", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 7533784454832764388L", "syntax_pass": true}, {"attribute_expression": "@SuppressWarnings(\"rawtypes\")\n    public static final Predicate INSTANCE = new NotNullPredicate<>();", "docstring": " Singleton predicate instance", "modifiers": "@SuppressWarnings(\"rawtypes\")\n    public static final", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"rawtypes\")", "public", "static", "final"], "comments": [], "type": "Predicate", "name": "INSTANCE = new NotNullPredicate<>()", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/functors/AndPredicate.java.AndPredicate", "name": "AndPredicate", "file_path": "src/main/java/org/apache/commons/collections4/functors/AndPredicate.java", "superclasses": "", "methods": ["[Predicate<T>]andPredicate(Predicate<? super T>,Predicate<? super T>)", "[]AndPredicate(Predicate<? super T>,Predicate<? super T>)", "[Predicate<? super T>[]]getPredicates()", "[boolean]test(T)"], "method_uris": ["src/main/java/org/apache/commons/collections4/functors/AndPredicate.java.AndPredicate.[Predicate<T>]andPredicate(Predicate<? super T>,Predicate<? super T>)", "src/main/java/org/apache/commons/collections4/functors/AndPredicate.java.AndPredicate.[]AndPredicate(Predicate<? super T>,Predicate<? super T>)", "src/main/java/org/apache/commons/collections4/functors/AndPredicate.java.AndPredicate.[Predicate<? super T>[]]getPredicates()", "src/main/java/org/apache/commons/collections4/functors/AndPredicate.java.AndPredicate.[boolean]test(T)"], "overrides": null, "attributes": [], "class_docstring": "\nPredicate implementation that returns true if both the predicates return true.\n\n@param <T> the type of the input to the predicate.\n@since 3.0\n", "original_string": "public final class AndPredicate<T> extends AbstractPredicate<T> implements PredicateDecorator<T>, Serializable {\n\n    /** Serial version UID */\n    private static final long serialVersionUID = 4189014213763186912L;\n\n    /**\n     * Factory to create the predicate.\n     *\n     * @param <T> the type that the predicate queries\n     * @param predicate1  the first predicate to check, not null\n     * @param predicate2  the second predicate to check, not null\n     * @return the {@code and} predicate\n     * @throws NullPointerException if either predicate is null\n     */\n    public static <T> Predicate<T> andPredicate(final Predicate<? super T> predicate1,\n            final Predicate<? super T> predicate2) {\n        return new AndPredicate<>(Objects.requireNonNull(predicate1, \"predicate1\"),\n                Objects.requireNonNull(predicate2, \"predicate2\"));\n    }\n    /** The array of predicates to call */\n    private final Predicate<? super T> iPredicate1;\n\n    /** The array of predicates to call */\n    private final Predicate<? super T> iPredicate2;\n\n    /**\n     * Constructor that performs no validation.\n     * Use {@code andPredicate} if you want that.\n     *\n     * @param predicate1  the first predicate to check, not null\n     * @param predicate2  the second predicate to check, not null\n     */\n    public AndPredicate(final Predicate<? super T> predicate1, final Predicate<? super T> predicate2) {\n        iPredicate1 = predicate1;\n        iPredicate2 = predicate2;\n    }\n\n    /**\n     * Gets the two predicates being decorated as an array.\n     *\n     * @return the predicates\n     * @since 3.1\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public Predicate<? super T>[] getPredicates() {\n        return new Predicate[] {iPredicate1, iPredicate2};\n    }\n\n    /**\n     * Evaluates the predicate returning true if both predicates return true.\n     *\n     * @param object  the input object\n     * @return true if both decorated predicates return true\n     */\n    @Override\n    public boolean test(final T object) {\n        return iPredicate1.test(object) && iPredicate2.test(object);\n    }\n\n}", "super_interfaces": ["PredicateDecorator<T>", "Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 4189014213763186912L;", "docstring": " Serial version UID", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 4189014213763186912L", "syntax_pass": true}, {"attribute_expression": "private final Predicate<? super T> iPredicate1;", "docstring": " The array of predicates to call", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Predicate<? super T>", "name": "iPredicate1", "syntax_pass": true}, {"attribute_expression": "private final Predicate<? super T> iPredicate2;", "docstring": " The array of predicates to call", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Predicate<? super T>", "name": "iPredicate2", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/functors/NOPTransformer.java.NOPTransformer", "name": "NOPTransformer", "file_path": "src/main/java/org/apache/commons/collections4/functors/NOPTransformer.java", "superclasses": "", "methods": ["[Transformer<T, T>]nopTransformer()", "[]NOPTransformer()", "[Object]readResolve()", "[T]transform(T)"], "method_uris": ["src/main/java/org/apache/commons/collections4/functors/NOPTransformer.java.NOPTransformer.[Transformer<T, T>]nopTransformer()", "src/main/java/org/apache/commons/collections4/functors/NOPTransformer.java.NOPTransformer.[]NOPTransformer()", "src/main/java/org/apache/commons/collections4/functors/NOPTransformer.java.NOPTransformer.[Object]readResolve()", "src/main/java/org/apache/commons/collections4/functors/NOPTransformer.java.NOPTransformer.[T]transform(T)"], "overrides": null, "attributes": [], "class_docstring": "\nTransformer implementation that does nothing.\n\n@param <T> the type of the input and result to the function.\n@since 3.0\n", "original_string": "public class NOPTransformer<T> implements Transformer<T, T>, Serializable {\n\n    /** Serial version UID */\n    private static final long serialVersionUID = 2133891748318574490L;\n\n    /** Singleton predicate instance */\n    @SuppressWarnings(\"rawtypes\")\n    public static final Transformer INSTANCE = new NOPTransformer<>();\n\n    /**\n     * Factory returning the singleton instance.\n     *\n     * @param <T>  the input/output type\n     * @return the singleton instance\n     * @since 3.1\n     */\n    public static <T> Transformer<T, T> nopTransformer() {\n        return INSTANCE;\n    }\n\n    /**\n     * Constructs a new instance.\n     */\n    private NOPTransformer() {\n    }\n\n    /**\n     * Returns the singleton instance.\n     *\n     * @return the singleton instance.\n     */\n    private Object readResolve() {\n        return INSTANCE;\n    }\n\n    /**\n     * Transforms the input to result by doing nothing.\n     *\n     * @param input  the input object to transform\n     * @return the transformed result which is the input\n     */\n    @Override\n    public T transform(final T input) {\n        return input;\n    }\n\n}", "super_interfaces": ["Transformer<T, T>", "Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 2133891748318574490L;", "docstring": " Serial version UID", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 2133891748318574490L", "syntax_pass": true}, {"attribute_expression": "@SuppressWarnings(\"rawtypes\")\n    public static final Transformer INSTANCE = new NOPTransformer<>();", "docstring": " Singleton predicate instance", "modifiers": "@SuppressWarnings(\"rawtypes\")\n    public static final", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"rawtypes\")", "public", "static", "final"], "comments": [], "type": "Transformer", "name": "INSTANCE = new NOPTransformer<>()", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/functors/UniquePredicate.java.UniquePredicate", "name": "UniquePredicate", "file_path": "src/main/java/org/apache/commons/collections4/functors/UniquePredicate.java", "superclasses": "", "methods": ["[Predicate<T>]uniquePredicate()", "[]UniquePredicate()", "[boolean]test(T)"], "method_uris": ["src/main/java/org/apache/commons/collections4/functors/UniquePredicate.java.UniquePredicate.[Predicate<T>]uniquePredicate()", "src/main/java/org/apache/commons/collections4/functors/UniquePredicate.java.UniquePredicate.[]UniquePredicate()", "src/main/java/org/apache/commons/collections4/functors/UniquePredicate.java.UniquePredicate.[boolean]test(T)"], "overrides": null, "attributes": [], "class_docstring": "\nPredicate implementation that returns true the first time an object is\npassed into the predicate.\n\n@param <T> the type of the input to the predicate.\n@since 3.0\n", "original_string": "public final class UniquePredicate<T>  extends AbstractPredicate<T> implements Serializable {\n\n    /** Serial version UID */\n    private static final long serialVersionUID = -3319417438027438040L;\n\n    /**\n     * Factory to create the predicate.\n     *\n     * @param <T> the type that the predicate queries\n     * @return the predicate\n     * @throws IllegalArgumentException if the predicate is null\n     */\n    public static <T> Predicate<T> uniquePredicate() {\n        return new UniquePredicate<>();\n    }\n\n    /** The set of previously seen objects */\n    private final Set<T> iSet = new HashSet<>();\n\n    /**\n     * Constructor that performs no validation.\n     * Use {@code uniquePredicate} if you want that.\n     */\n    public UniquePredicate() {\n    }\n\n    /**\n     * Evaluates the predicate returning true if the input object hasn't been\n     * received yet.\n     *\n     * @param object  the input object\n     * @return true if this is the first time the object is seen\n     */\n    @Override\n    public boolean test(final T object) {\n        return iSet.add(object);\n    }\n\n}", "super_interfaces": ["Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = -3319417438027438040L;", "docstring": " Serial version UID", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -3319417438027438040L", "syntax_pass": true}, {"attribute_expression": "private final Set<T> iSet = new HashSet<>();", "docstring": " The set of previously seen objects", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Set<T>", "name": "iSet = new HashSet<>()", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/functors/SwitchTransformer.java.SwitchTransformer", "name": "SwitchTransformer", "file_path": "src/main/java/org/apache/commons/collections4/functors/SwitchTransformer.java", "superclasses": "", "methods": ["[Transformer<I, O>]switchTransformer(Map<? extends Predicate<? super I>, ? extends Transformer<? super I, ? extends O>>)", "[Transformer<I, O>]switchTransformer(Predicate<? super I>[],Transformer<? super I, ? extends O>[],Transformer<? super I, ? extends O>)", "[]SwitchTransformer(boolean,Predicate<? super T>[],Transformer<? super T, ? extends R>[],Transformer<? super T, ? extends R>)", "[]SwitchTransformer(Predicate<? super T>[],Transformer<? super T, ? extends R>[],Transformer<? super T, ? extends R>)", "[Transformer<? super T, ? extends R>]getDefaultTransformer()", "[Predicate<? super T>[]]getPredicates()", "[Transformer<? super T, ? extends R>[]]getTransformers()", "[R]transform(T)"], "method_uris": ["src/main/java/org/apache/commons/collections4/functors/SwitchTransformer.java.SwitchTransformer.[Transformer<I, O>]switchTransformer(Map<? extends Predicate<? super I>, ? extends Transformer<? super I, ? extends O>>)", "src/main/java/org/apache/commons/collections4/functors/SwitchTransformer.java.SwitchTransformer.[Transformer<I, O>]switchTransformer(Predicate<? super I>[],Transformer<? super I, ? extends O>[],Transformer<? super I, ? extends O>)", "src/main/java/org/apache/commons/collections4/functors/SwitchTransformer.java.SwitchTransformer.[]SwitchTransformer(boolean,Predicate<? super T>[],Transformer<? super T, ? extends R>[],Transformer<? super T, ? extends R>)", "src/main/java/org/apache/commons/collections4/functors/SwitchTransformer.java.SwitchTransformer.[]SwitchTransformer(Predicate<? super T>[],Transformer<? super T, ? extends R>[],Transformer<? super T, ? extends R>)", "src/main/java/org/apache/commons/collections4/functors/SwitchTransformer.java.SwitchTransformer.[Transformer<? super T, ? extends R>]getDefaultTransformer()", "src/main/java/org/apache/commons/collections4/functors/SwitchTransformer.java.SwitchTransformer.[Predicate<? super T>[]]getPredicates()", "src/main/java/org/apache/commons/collections4/functors/SwitchTransformer.java.SwitchTransformer.[Transformer<? super T, ? extends R>[]]getTransformers()", "src/main/java/org/apache/commons/collections4/functors/SwitchTransformer.java.SwitchTransformer.[R]transform(T)"], "overrides": null, "attributes": [], "class_docstring": "\nTransformer implementation calls the transformer whose predicate returns true,\nlike a switch statement.\n\n@param <T> the type of the input to the function.\n@param <R> the type of the result of the function.\n@since 3.0\n", "original_string": "public class SwitchTransformer<T, R> implements Transformer<T, R>, Serializable {\n\n    /** Serial version UID */\n    private static final long serialVersionUID = -6404460890903469332L;\n\n    /**\n     * Create a new Transformer that calls one of the transformers depending\n     * on the predicates.\n     * <p>\n     * The Map consists of Predicate keys and Transformer values. A transformer\n     * is called if its matching predicate returns true. Each predicate is evaluated\n     * until one returns true. If no predicates evaluate to true, the default\n     * transformer is called. The default transformer is set in the map with a\n     * null key. The ordering is that of the iterator() method on the entryset\n     * collection of the map.\n     *\n     * @param <I>  the input type\n     * @param <O>  the output type\n     * @param map  a map of predicates to transformers\n     * @return the {@code switch} transformer\n     * @throws NullPointerException if the map is null\n     * @throws NullPointerException if any transformer in the map is null\n     * @throws ClassCastException  if the map elements are of the wrong type\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static <I, O> Transformer<I, O> switchTransformer(\n            final Map<? extends Predicate<? super I>, ? extends Transformer<? super I, ? extends O>> map) {\n\n        Objects.requireNonNull(map, \"map\");\n        if (map.isEmpty()) {\n            return ConstantTransformer.<I, O>nullTransformer();\n        }\n        // convert to array like this to guarantee iterator() ordering\n        final Transformer<? super I, ? extends O> defaultTransformer = map.remove(null);\n        final int size = map.size();\n        if (size == 0) {\n            return (Transformer<I, O>) (defaultTransformer == null ? ConstantTransformer.<I, O>nullTransformer() :\n                                                                     defaultTransformer);\n        }\n        final Transformer<? super I, ? extends O>[] transformers = new Transformer[size];\n        final Predicate<? super I>[] preds = new Predicate[size];\n        int i = 0;\n        for (final Map.Entry<? extends Predicate<? super I>,\n                             ? extends Transformer<? super I, ? extends O>> entry : map.entrySet()) {\n            preds[i] = entry.getKey();\n            transformers[i] = entry.getValue();\n            i++;\n        }\n        return new SwitchTransformer<>(false, preds, transformers, defaultTransformer);\n    }\n    /**\n     * Factory method that performs validation and copies the parameter arrays.\n     *\n     * @param <I>  the input type\n     * @param <O>  the output type\n     * @param predicates  array of predicates, cloned, no nulls\n     * @param transformers  matching array of transformers, cloned, no nulls\n     * @param defaultTransformer  the transformer to use if no match, null means return null\n     * @return the {@code chained} transformer\n     * @throws NullPointerException if either array is null\n     * @throws NullPointerException if any element in the arrays is null\n     * @throws IllegalArgumentException if the arrays have different sizes\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static <I, O> Transformer<I, O> switchTransformer(final Predicate<? super I>[] predicates,\n            final Transformer<? super I, ? extends O>[] transformers,\n            final Transformer<? super I, ? extends O> defaultTransformer) {\n        FunctorUtils.validate(predicates);\n        FunctorUtils.validate(transformers);\n        if (predicates.length != transformers.length) {\n            throw new IllegalArgumentException(\"The predicate and transformer arrays must be the same size\");\n        }\n        if (predicates.length == 0) {\n            return (Transformer<I, O>) (defaultTransformer == null ? ConstantTransformer.<I, O>nullTransformer() :\n                                                                     defaultTransformer);\n        }\n        return new SwitchTransformer<>(predicates, transformers, defaultTransformer);\n    }\n    /** The tests to consider */\n    private final Predicate<? super T>[] iPredicates;\n\n    /** The matching transformers to call */\n    private final Transformer<? super T, ? extends R>[] iTransformers;\n\n    /** The default transformer to call if no tests match */\n    private final Transformer<? super T, ? extends R> iDefault;\n\n    /**\n     * Hidden constructor for the use by the static factory methods.\n     *\n     * @param clone  if {@code true} the input arguments will be cloned\n     * @param predicates  array of predicates, no nulls\n     * @param transformers  matching array of transformers, no nulls\n     * @param defaultTransformer  the transformer to use if no match, null means return null\n     */\n    private SwitchTransformer(final boolean clone, final Predicate<? super T>[] predicates,\n                             final Transformer<? super T, ? extends R>[] transformers,\n                             final Transformer<? super T, ? extends R> defaultTransformer) {\n        iPredicates = clone ? FunctorUtils.copy(predicates) : predicates;\n        iTransformers = clone ? FunctorUtils.copy(transformers) : transformers;\n        iDefault = defaultTransformer == null ?\n                ConstantTransformer.<T, R>nullTransformer() : defaultTransformer;\n    }\n\n    /**\n     * Constructor that performs no validation.\n     * Use {@code switchTransformer} if you want that.\n     *\n     * @param predicates  array of predicates, cloned, no nulls\n     * @param transformers  matching array of transformers, cloned, no nulls\n     * @param defaultTransformer  the transformer to use if no match, null means return null\n     */\n    public SwitchTransformer(final Predicate<? super T>[] predicates,\n            final Transformer<? super T, ? extends R>[] transformers,\n            final Transformer<? super T, ? extends R> defaultTransformer) {\n        this(true, predicates, transformers, defaultTransformer);\n    }\n\n    /**\n     * Gets the default transformer.\n     *\n     * @return the default transformer\n     * @since 3.1\n     */\n    public Transformer<? super T, ? extends R> getDefaultTransformer() {\n        return iDefault;\n    }\n\n    /**\n     * Gets the predicates.\n     *\n     * @return a copy of the predicates\n     * @since 3.1\n     */\n    public Predicate<? super T>[] getPredicates() {\n        return FunctorUtils.copy(iPredicates);\n    }\n\n    /**\n     * Gets the transformers.\n     *\n     * @return a copy of the transformers\n     * @since 3.1\n     */\n    public Transformer<? super T, ? extends R>[] getTransformers() {\n        return FunctorUtils.copy(iTransformers);\n    }\n\n    /**\n     * Transforms the input to result by calling the transformer whose matching\n     * predicate returns true.\n     *\n     * @param input  the input object to transform\n     * @return the transformed result\n     */\n    @Override\n    public R transform(final T input) {\n        for (int i = 0; i < iPredicates.length; i++) {\n            if (iPredicates[i].test(input)) {\n                return iTransformers[i].apply(input);\n            }\n        }\n        return iDefault.apply(input);\n    }\n\n}", "super_interfaces": ["Transformer<T, R>", "Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = -6404460890903469332L;", "docstring": " Serial version UID", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -6404460890903469332L", "syntax_pass": true}, {"attribute_expression": "private final Predicate<? super T>[] iPredicates;", "docstring": " The tests to consider", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Predicate<? super T>[]", "name": "iPredicates", "syntax_pass": true}, {"attribute_expression": "private final Transformer<? super T, ? extends R>[] iTransformers;", "docstring": " The matching transformers to call", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Transformer<? super T, ? extends R>[]", "name": "iTransformers", "syntax_pass": true}, {"attribute_expression": "private final Transformer<? super T, ? extends R> iDefault;", "docstring": " The default transformer to call if no tests match", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Transformer<? super T, ? extends R>", "name": "iDefault", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/functors/NullPredicate.java.NullPredicate", "name": "NullPredicate", "file_path": "src/main/java/org/apache/commons/collections4/functors/NullPredicate.java", "superclasses": "", "methods": ["[Predicate<T>]nullPredicate()", "[]NullPredicate()", "[Object]readResolve()", "[boolean]test(T)"], "method_uris": ["src/main/java/org/apache/commons/collections4/functors/NullPredicate.java.NullPredicate.[Predicate<T>]nullPredicate()", "src/main/java/org/apache/commons/collections4/functors/NullPredicate.java.NullPredicate.[]NullPredicate()", "src/main/java/org/apache/commons/collections4/functors/NullPredicate.java.NullPredicate.[Object]readResolve()", "src/main/java/org/apache/commons/collections4/functors/NullPredicate.java.NullPredicate.[boolean]test(T)"], "overrides": null, "attributes": [], "class_docstring": "\nPredicate implementation that returns true if the input is null.\n\n@param <T> the type of the input to the predicate.\n@since 3.0\n", "original_string": "public final class NullPredicate<T> extends AbstractPredicate<T> implements Serializable {\n\n    /** Serial version UID */\n    private static final long serialVersionUID = 7533784454832764388L;\n\n    /** Singleton predicate instance */\n    @SuppressWarnings(\"rawtypes\")\n    public static final Predicate INSTANCE = new NullPredicate<>();\n\n    /**\n     * Factory returning the singleton instance.\n     *\n     * @param <T> the type that the predicate queries\n     * @return the singleton instance\n     * @since 3.1\n     */\n    public static <T> Predicate<T> nullPredicate() {\n        return INSTANCE;\n    }\n\n    /**\n     * Restricted constructor.\n     */\n    private NullPredicate() {\n    }\n\n    /**\n     * Returns the singleton instance.\n     *\n     * @return the singleton instance.\n     */\n    private Object readResolve() {\n        return INSTANCE;\n    }\n\n    /**\n     * Evaluates the predicate returning true if the input is null.\n     *\n     * @param object  the input object\n     * @return true if input is null\n     */\n    @Override\n    public boolean test(final T object) {\n        return object == null;\n    }\n\n}", "super_interfaces": ["Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 7533784454832764388L;", "docstring": " Serial version UID", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 7533784454832764388L", "syntax_pass": true}, {"attribute_expression": "@SuppressWarnings(\"rawtypes\")\n    public static final Predicate INSTANCE = new NullPredicate<>();", "docstring": " Singleton predicate instance", "modifiers": "@SuppressWarnings(\"rawtypes\")\n    public static final", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"rawtypes\")", "public", "static", "final"], "comments": [], "type": "Predicate", "name": "INSTANCE = new NullPredicate<>()", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/functors/MapTransformer.java.MapTransformer", "name": "MapTransformer", "file_path": "src/main/java/org/apache/commons/collections4/functors/MapTransformer.java", "superclasses": "", "methods": ["[Transformer<I, O>]mapTransformer(Map<? super I, ? extends O>)", "[]MapTransformer(Map<? super T, ? extends R>)", "[Map<? super T, ? extends R>]getMap()", "[R]transform(T)"], "method_uris": ["src/main/java/org/apache/commons/collections4/functors/MapTransformer.java.MapTransformer.[Transformer<I, O>]mapTransformer(Map<? super I, ? extends O>)", "src/main/java/org/apache/commons/collections4/functors/MapTransformer.java.MapTransformer.[]MapTransformer(Map<? super T, ? extends R>)", "src/main/java/org/apache/commons/collections4/functors/MapTransformer.java.MapTransformer.[Map<? super T, ? extends R>]getMap()", "src/main/java/org/apache/commons/collections4/functors/MapTransformer.java.MapTransformer.[R]transform(T)"], "overrides": null, "attributes": [], "class_docstring": "\nTransformer implementation that returns the value held in a specified map\nusing the input parameter as a key.\n\n@param <T> the type of the input to the function.\n@param <R> the type of the result of the function.\n@since 3.0\n", "original_string": "public final class MapTransformer<T, R> implements Transformer<T, R>, Serializable {\n\n    /** Serial version UID */\n    private static final long serialVersionUID = 862391807045468939L;\n\n    /**\n     * Factory to create the transformer.\n     * <p>\n     * If the map is null, a transformer that always returns null is returned.\n     *\n     * @param <I>  the input type\n     * @param <O>  the output type\n     * @param map the map, not cloned\n     * @return the transformer\n     */\n    public static <I, O> Transformer<I, O> mapTransformer(final Map<? super I, ? extends O> map) {\n        if (map == null) {\n            return ConstantTransformer.<I, O>nullTransformer();\n        }\n        return new MapTransformer<>(map);\n    }\n\n    /** The map of data to lookup in */\n    private final Map<? super T, ? extends R> iMap;\n\n    /**\n     * Constructor that performs no validation.\n     * Use {@code mapTransformer} if you want that.\n     *\n     * @param map  the map to use for lookup, not cloned\n     */\n    private MapTransformer(final Map<? super T, ? extends R> map) {\n        iMap = map;\n    }\n\n    /**\n     * Gets the map to lookup in.\n     *\n     * @return the map\n     * @since 3.1\n     */\n    public Map<? super T, ? extends R> getMap() {\n        return iMap;\n    }\n\n    /**\n     * Transforms the input to result by looking it up in a {@code Map}.\n     *\n     * @param input  the input object to transform\n     * @return the transformed result\n     */\n    @Override\n    public R transform(final T input) {\n        return iMap.get(input);\n    }\n\n}", "super_interfaces": ["Transformer<T, R>", "Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 862391807045468939L;", "docstring": " Serial version UID", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 862391807045468939L", "syntax_pass": true}, {"attribute_expression": "private final Map<? super T, ? extends R> iMap;", "docstring": " The map of data to lookup in", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Map<? super T, ? extends R>", "name": "iMap", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/functors/SwitchClosure.java.SwitchClosure", "name": "SwitchClosure", "file_path": "src/main/java/org/apache/commons/collections4/functors/SwitchClosure.java", "superclasses": "", "methods": ["[Closure<E>]switchClosure(Map<Predicate<E>, Closure<E>>)", "[Closure<E>]switchClosure(Predicate<? super E>[],Closure<? super E>[],Closure<? super E>)", "[]SwitchClosure(boolean,Predicate<? super T>[],Closure<? super T>[],Closure<? super T>)", "[]SwitchClosure(Predicate<? super T>[],Closure<? super T>[],Closure<? super T>)", "[void]execute(T)", "[Closure<? super T>[]]getClosures()", "[Closure<? super T>]getDefaultClosure()", "[Predicate<? super T>[]]getPredicates()"], "method_uris": ["src/main/java/org/apache/commons/collections4/functors/SwitchClosure.java.SwitchClosure.[Closure<E>]switchClosure(Map<Predicate<E>, Closure<E>>)", "src/main/java/org/apache/commons/collections4/functors/SwitchClosure.java.SwitchClosure.[Closure<E>]switchClosure(Predicate<? super E>[],Closure<? super E>[],Closure<? super E>)", "src/main/java/org/apache/commons/collections4/functors/SwitchClosure.java.SwitchClosure.[]SwitchClosure(boolean,Predicate<? super T>[],Closure<? super T>[],Closure<? super T>)", "src/main/java/org/apache/commons/collections4/functors/SwitchClosure.java.SwitchClosure.[]SwitchClosure(Predicate<? super T>[],Closure<? super T>[],Closure<? super T>)", "src/main/java/org/apache/commons/collections4/functors/SwitchClosure.java.SwitchClosure.[void]execute(T)", "src/main/java/org/apache/commons/collections4/functors/SwitchClosure.java.SwitchClosure.[Closure<? super T>[]]getClosures()", "src/main/java/org/apache/commons/collections4/functors/SwitchClosure.java.SwitchClosure.[Closure<? super T>]getDefaultClosure()", "src/main/java/org/apache/commons/collections4/functors/SwitchClosure.java.SwitchClosure.[Predicate<? super T>[]]getPredicates()"], "overrides": null, "attributes": [], "class_docstring": "\nClosure implementation calls the closure whose predicate returns true,\nlike a switch statement.\n\n@param <T> the type of the input to the operation.\n@since 3.0\n", "original_string": "public class SwitchClosure<T> implements Closure<T>, Serializable {\n\n    /** Serial version UID */\n    private static final long serialVersionUID = 3518477308466486130L;\n\n    /**\n     * Create a new Closure that calls one of the closures depending\n     * on the predicates.\n     * <p>\n     * The Map consists of Predicate keys and Closure values. A closure\n     * is called if its matching predicate returns true. Each predicate is evaluated\n     * until one returns true. If no predicates evaluate to true, the default\n     * closure is called. The default closure is set in the map with a\n     * null key. The ordering is that of the iterator() method on the entryset\n     * collection of the map.\n     *\n     * @param <E> the type that the closure acts on\n     * @param predicatesAndClosures  a map of predicates to closures\n     * @return the {@code switch} closure\n     * @throws NullPointerException if the map is null\n     * @throws NullPointerException if any closure in the map is null\n     * @throws ClassCastException  if the map elements are of the wrong type\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static <E> Closure<E> switchClosure(final Map<Predicate<E>, Closure<E>> predicatesAndClosures) {\n        Objects.requireNonNull(predicatesAndClosures, \"predicatesAndClosures\");\n        // convert to array like this to guarantee iterator() ordering\n        final Closure<? super E> defaultClosure = predicatesAndClosures.remove(null);\n        final int size = predicatesAndClosures.size();\n        if (size == 0) {\n            return (Closure<E>) (defaultClosure == null ? NOPClosure.<E>nopClosure() : defaultClosure);\n        }\n        final Closure<E>[] closures = new Closure[size];\n        final Predicate<E>[] preds = new Predicate[size];\n        int i = 0;\n        for (final Map.Entry<Predicate<E>, Closure<E>> entry : predicatesAndClosures.entrySet()) {\n            preds[i] = entry.getKey();\n            closures[i] = entry.getValue();\n            i++;\n        }\n        return new SwitchClosure<>(false, preds, closures, defaultClosure);\n    }\n    /**\n     * Factory method that performs validation and copies the parameter arrays.\n     *\n     * @param <E> the type that the closure acts on\n     * @param predicates  array of predicates, cloned, no nulls\n     * @param closures  matching array of closures, cloned, no nulls\n     * @param defaultClosure  the closure to use if no match, null means nop\n     * @return the {@code chained} closure\n     * @throws NullPointerException if array is null\n     * @throws NullPointerException if any element in the array is null\n     * @throws IllegalArgumentException if the array lengths of predicates and closures do not match\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static <E> Closure<E> switchClosure(final Predicate<? super E>[] predicates,\n                                               final Closure<? super E>[] closures,\n                                               final Closure<? super E> defaultClosure) {\n        FunctorUtils.validate(predicates);\n        FunctorUtils.validate(closures);\n        if (predicates.length != closures.length) {\n            throw new IllegalArgumentException(\"The predicate and closure arrays must be the same size\");\n        }\n        if (predicates.length == 0) {\n            return (Closure<E>) (defaultClosure == null ? NOPClosure.<E>nopClosure() : defaultClosure);\n        }\n        return new SwitchClosure<>(predicates, closures, defaultClosure);\n    }\n    /** The tests to consider */\n    private final Predicate<? super T>[] iPredicates;\n\n    /** The matching closures to call */\n    private final Closure<? super T>[] iClosures;\n\n    /** The default closure to call if no tests match */\n    private final Closure<? super T> iDefault;\n\n    /**\n     * Hidden constructor for the use by the static factory methods.\n     *\n     * @param clone  if {@code true} the input arguments will be cloned\n     * @param predicates  array of predicates, no nulls\n     * @param closures  matching array of closures, no nulls\n     * @param defaultClosure  the closure to use if no match, null means nop\n     */\n    private SwitchClosure(final boolean clone, final Predicate<? super T>[] predicates,\n                          final Closure<? super T>[] closures, final Closure<? super T> defaultClosure) {\n        iPredicates = clone ? FunctorUtils.copy(predicates) : predicates;\n        iClosures = clone ? FunctorUtils.copy(closures) : closures;\n        iDefault = defaultClosure == null ? NOPClosure.<T>nopClosure() : defaultClosure;\n    }\n\n    /**\n     * Constructor that performs no validation.\n     * Use {@code switchClosure} if you want that.\n     *\n     * @param predicates  array of predicates, cloned, no nulls\n     * @param closures  matching array of closures, cloned, no nulls\n     * @param defaultClosure  the closure to use if no match, null means nop\n     */\n    public SwitchClosure(final Predicate<? super T>[] predicates, final Closure<? super T>[] closures,\n                         final Closure<? super T> defaultClosure) {\n        this(true, predicates, closures, defaultClosure);\n    }\n\n    /**\n     * Executes the closure whose matching predicate returns true\n     *\n     * @param input  the input object\n     */\n    @Override\n    public void execute(final T input) {\n        for (int i = 0; i < iPredicates.length; i++) {\n            if (iPredicates[i].test(input)) {\n                iClosures[i].accept(input);\n                return;\n            }\n        }\n        iDefault.accept(input);\n    }\n\n    /**\n     * Gets the closures.\n     *\n     * @return a copy of the closures\n     * @since 3.1\n     */\n    public Closure<? super T>[] getClosures() {\n        return FunctorUtils.copy(iClosures);\n    }\n\n    /**\n     * Gets the default closure.\n     *\n     * @return the default closure\n     * @since 3.1\n     */\n    public Closure<? super T> getDefaultClosure() {\n        return iDefault;\n    }\n\n    /**\n     * Gets the predicates.\n     *\n     * @return a copy of the predicates\n     * @since 3.1\n     */\n    public Predicate<? super T>[] getPredicates() {\n        return FunctorUtils.copy(iPredicates);\n    }\n\n}", "super_interfaces": ["Closure<T>", "Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 3518477308466486130L;", "docstring": " Serial version UID", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 3518477308466486130L", "syntax_pass": true}, {"attribute_expression": "private final Predicate<? super T>[] iPredicates;", "docstring": " The tests to consider", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Predicate<? super T>[]", "name": "iPredicates", "syntax_pass": true}, {"attribute_expression": "private final Closure<? super T>[] iClosures;", "docstring": " The matching closures to call", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Closure<? super T>[]", "name": "iClosures", "syntax_pass": true}, {"attribute_expression": "private final Closure<? super T> iDefault;", "docstring": " The default closure to call if no tests match", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Closure<? super T>", "name": "iDefault", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/functors/ConstantTransformer.java.ConstantTransformer", "name": "ConstantTransformer", "file_path": "src/main/java/org/apache/commons/collections4/functors/ConstantTransformer.java", "superclasses": "", "methods": ["[Transformer<I, O>]constantTransformer(O)", "[Transformer<I, O>]nullTransformer()", "[]ConstantTransformer(R)", "[boolean]equals(Object)", "[R]getConstant()", "[int]hashCode()", "[R]transform(T)"], "method_uris": ["src/main/java/org/apache/commons/collections4/functors/ConstantTransformer.java.ConstantTransformer.[Transformer<I, O>]constantTransformer(O)", "src/main/java/org/apache/commons/collections4/functors/ConstantTransformer.java.ConstantTransformer.[Transformer<I, O>]nullTransformer()", "src/main/java/org/apache/commons/collections4/functors/ConstantTransformer.java.ConstantTransformer.[]ConstantTransformer(R)", "src/main/java/org/apache/commons/collections4/functors/ConstantTransformer.java.ConstantTransformer.[boolean]equals(Object)", "src/main/java/org/apache/commons/collections4/functors/ConstantTransformer.java.ConstantTransformer.[R]getConstant()", "src/main/java/org/apache/commons/collections4/functors/ConstantTransformer.java.ConstantTransformer.[int]hashCode()", "src/main/java/org/apache/commons/collections4/functors/ConstantTransformer.java.ConstantTransformer.[R]transform(T)"], "overrides": null, "attributes": [], "class_docstring": "\nTransformer implementation that returns the same constant each time.\n<p>\nNo check is made that the object is immutable. In general, only immutable\nobjects should use the constant factory. Mutable objects should\nuse the prototype factory.\n</p>\n\n@param <T> the type of the input to the function.\n@param <R> the type of the result of the function.\n@since 3.0\n", "original_string": "public class ConstantTransformer<T, R> implements Transformer<T, R>, Serializable {\n\n    /** Serial version UID */\n    private static final long serialVersionUID = 6374440726369055124L;\n\n    /** Returns null each time */\n    @SuppressWarnings(\"rawtypes\")\n    public static final Transformer NULL_INSTANCE = new ConstantTransformer<>(null);\n\n    /**\n     * Transformer method that performs validation.\n     *\n     * @param <I>  the input type\n     * @param <O>  the output type\n     * @param constantToReturn  the constant object to return each time in the factory\n     * @return the {@code constant} factory.\n     */\n    public static <I, O> Transformer<I, O> constantTransformer(final O constantToReturn) {\n        if (constantToReturn == null) {\n            return nullTransformer();\n        }\n        return new ConstantTransformer<>(constantToReturn);\n    }\n\n    /**\n     * Gets a typed null instance.\n     *\n     * @param <I>  the input type\n     * @param <O>  the output type\n     * @return Transformer&lt;I, O&gt; that always returns null.\n     */\n    public static <I, O> Transformer<I, O> nullTransformer() {\n        return NULL_INSTANCE;\n    }\n\n    /** The closures to call in turn */\n    private final R iConstant;\n\n    /**\n     * Constructor that performs no validation.\n     * Use {@code constantTransformer} if you want that.\n     *\n     * @param constantToReturn  the constant to return each time\n     */\n    public ConstantTransformer(final R constantToReturn) {\n        iConstant = constantToReturn;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean equals(final Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof ConstantTransformer)) {\n            return false;\n        }\n        final Object otherConstant = ((ConstantTransformer<?, ?>) obj).getConstant();\n        return otherConstant == getConstant() || otherConstant != null && otherConstant.equals(getConstant());\n    }\n\n    /**\n     * Gets the constant.\n     *\n     * @return the constant\n     * @since 3.1\n     */\n    public R getConstant() {\n        return iConstant;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public int hashCode() {\n        int result = \"ConstantTransformer\".hashCode() << 2;\n        if (getConstant() != null) {\n            result |= getConstant().hashCode();\n        }\n        return result;\n    }\n\n    /**\n     * Transforms the input by ignoring it and returning the stored constant instead.\n     *\n     * @param input  the input object which is ignored\n     * @return the stored constant\n     */\n    @Override\n    public R transform(final T input) {\n        return iConstant;\n    }\n}", "super_interfaces": ["Transformer<T, R>", "Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 6374440726369055124L;", "docstring": " Serial version UID", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 6374440726369055124L", "syntax_pass": true}, {"attribute_expression": "@SuppressWarnings(\"rawtypes\")\n    public static final Transformer NULL_INSTANCE = new ConstantTransformer<>(null);", "docstring": " Returns null each time", "modifiers": "@SuppressWarnings(\"rawtypes\")\n    public static final", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"rawtypes\")", "public", "static", "final"], "comments": [], "type": "Transformer", "name": "NULL_INSTANCE = new ConstantTransformer<>(null)", "syntax_pass": true}, {"attribute_expression": "private final R iConstant;", "docstring": " The closures to call in turn", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "R", "name": "iConstant", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/functors/IfClosure.java.IfClosure", "name": "IfClosure", "file_path": "src/main/java/org/apache/commons/collections4/functors/IfClosure.java", "superclasses": "", "methods": ["[Closure<E>]ifClosure(Predicate<? super E>,Closure<? super E>)", "[Closure<E>]ifClosure(Predicate<? super E>,Closure<? super E>,Closure<? super E>)", "[]IfClosure(Predicate<? super T>,Closure<? super T>)", "[]IfClosure(Predicate<? super T>,Closure<? super T>,Closure<? super T>)", "[void]execute(T)", "[Closure<? super T>]getFalseClosure()", "[Predicate<? super T>]getPredicate()", "[Closure<? super T>]getTrueClosure()"], "method_uris": ["src/main/java/org/apache/commons/collections4/functors/IfClosure.java.IfClosure.[Closure<E>]ifClosure(Predicate<? super E>,Closure<? super E>)", "src/main/java/org/apache/commons/collections4/functors/IfClosure.java.IfClosure.[Closure<E>]ifClosure(Predicate<? super E>,Closure<? super E>,Closure<? super E>)", "src/main/java/org/apache/commons/collections4/functors/IfClosure.java.IfClosure.[]IfClosure(Predicate<? super T>,Closure<? super T>)", "src/main/java/org/apache/commons/collections4/functors/IfClosure.java.IfClosure.[]IfClosure(Predicate<? super T>,Closure<? super T>,Closure<? super T>)", "src/main/java/org/apache/commons/collections4/functors/IfClosure.java.IfClosure.[void]execute(T)", "src/main/java/org/apache/commons/collections4/functors/IfClosure.java.IfClosure.[Closure<? super T>]getFalseClosure()", "src/main/java/org/apache/commons/collections4/functors/IfClosure.java.IfClosure.[Predicate<? super T>]getPredicate()", "src/main/java/org/apache/commons/collections4/functors/IfClosure.java.IfClosure.[Closure<? super T>]getTrueClosure()"], "overrides": null, "attributes": [], "class_docstring": "\nClosure implementation acts as an if statement calling one or other closure\nbased on a predicate.\n\n@param <T> the type of the input to the operation.\n@since 3.0\n", "original_string": "public class IfClosure<T> implements Closure<T>, Serializable {\n\n    /** Serial version UID */\n    private static final long serialVersionUID = 3518477308466486130L;\n\n    /**\n     * Factory method that performs validation.\n     * <p>\n     * This factory creates a closure that performs no action when\n     * the predicate is false.\n     *\n     * @param <E> the type that the closure acts on\n     * @param predicate  predicate to switch on\n     * @param trueClosure  closure used if true\n     * @return the {@code if} closure\n     * @throws NullPointerException if either argument is null\n     * @since 3.2\n     */\n    public static <E> Closure<E> ifClosure(final Predicate<? super E> predicate, final Closure<? super E> trueClosure) {\n        return IfClosure.<E>ifClosure(predicate, trueClosure, NOPClosure.<E>nopClosure());\n    }\n    /**\n     * Factory method that performs validation.\n     *\n     * @param <E> the type that the closure acts on\n     * @param predicate  predicate to switch on\n     * @param trueClosure  closure used if true\n     * @param falseClosure  closure used if false\n     * @return the {@code if} closure\n     * @throws NullPointerException if any argument is null\n     */\n    public static <E> Closure<E> ifClosure(final Predicate<? super E> predicate,\n                                           final Closure<? super E> trueClosure,\n                                           final Closure<? super E> falseClosure) {\n        return new IfClosure<>(Objects.requireNonNull(predicate, \"predicate\"),\n                Objects.requireNonNull(trueClosure, \"trueClosure\"),\n                Objects.requireNonNull(falseClosure, \"falseClosure\"));\n    }\n    /** The test */\n    private final Predicate<? super T> iPredicate;\n\n    /** The closure to use if true */\n    private final Closure<? super T> iTrueClosure;\n\n    /** The closure to use if false */\n    private final Closure<? super T> iFalseClosure;\n\n    /**\n     * Constructor that performs no validation.\n     * Use {@code ifClosure} if you want that.\n     * <p>\n     * This constructor creates a closure that performs no action when\n     * the predicate is false.\n     *\n     * @param predicate  predicate to switch on, not null\n     * @param trueClosure  closure used if true, not null\n     * @since 3.2\n     */\n    public IfClosure(final Predicate<? super T> predicate, final Closure<? super T> trueClosure) {\n        this(predicate, trueClosure, NOPClosure.nopClosure());\n    }\n\n    /**\n     * Constructor that performs no validation.\n     * Use {@code ifClosure} if you want that.\n     *\n     * @param predicate  predicate to switch on, not null\n     * @param trueClosure  closure used if true, not null\n     * @param falseClosure  closure used if false, not null\n     */\n    public IfClosure(final Predicate<? super T> predicate, final Closure<? super T> trueClosure,\n                     final Closure<? super T> falseClosure) {\n        iPredicate = predicate;\n        iTrueClosure = trueClosure;\n        iFalseClosure = falseClosure;\n    }\n\n    /**\n     * Executes the true or false closure according to the result of the predicate.\n     *\n     * @param input  the input object\n     */\n    @Override\n    public void execute(final T input) {\n        if (iPredicate.test(input)) {\n            iTrueClosure.accept(input);\n        } else {\n            iFalseClosure.accept(input);\n        }\n    }\n\n    /**\n     * Gets the closure called when false.\n     *\n     * @return the closure\n     * @since 3.1\n     */\n    public Closure<? super T> getFalseClosure() {\n        return iFalseClosure;\n    }\n\n    /**\n     * Gets the predicate.\n     *\n     * @return the predicate\n     * @since 3.1\n     */\n    public Predicate<? super T> getPredicate() {\n        return iPredicate;\n    }\n\n    /**\n     * Gets the closure called when true.\n     *\n     * @return the closure\n     * @since 3.1\n     */\n    public Closure<? super T> getTrueClosure() {\n        return iTrueClosure;\n    }\n\n}", "super_interfaces": ["Closure<T>", "Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 3518477308466486130L;", "docstring": " Serial version UID", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 3518477308466486130L", "syntax_pass": true}, {"attribute_expression": "private final Predicate<? super T> iPredicate;", "docstring": " The test", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Predicate<? super T>", "name": "iPredicate", "syntax_pass": true}, {"attribute_expression": "private final Closure<? super T> iTrueClosure;", "docstring": " The closure to use if true", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Closure<? super T>", "name": "iTrueClosure", "syntax_pass": true}, {"attribute_expression": "private final Closure<? super T> iFalseClosure;", "docstring": " The closure to use if false", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Closure<? super T>", "name": "iFalseClosure", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/functors/ExceptionClosure.java.ExceptionClosure", "name": "ExceptionClosure", "file_path": "src/main/java/org/apache/commons/collections4/functors/ExceptionClosure.java", "superclasses": "", "methods": ["[Closure<T>]exceptionClosure()", "[]ExceptionClosure()", "[void]execute(T)", "[Object]readResolve()"], "method_uris": ["src/main/java/org/apache/commons/collections4/functors/ExceptionClosure.java.ExceptionClosure.[Closure<T>]exceptionClosure()", "src/main/java/org/apache/commons/collections4/functors/ExceptionClosure.java.ExceptionClosure.[]ExceptionClosure()", "src/main/java/org/apache/commons/collections4/functors/ExceptionClosure.java.ExceptionClosure.[void]execute(T)", "src/main/java/org/apache/commons/collections4/functors/ExceptionClosure.java.ExceptionClosure.[Object]readResolve()"], "overrides": null, "attributes": [], "class_docstring": "\nClosure implementation that always throws an exception.\n\n@param <T> the type of the input to the operation.\n@since 3.0\n", "original_string": "public final class ExceptionClosure<T> implements Closure<T>, Serializable {\n\n    /** Serial version UID */\n    private static final long serialVersionUID = 7179106032121985545L;\n\n    /** Singleton predicate instance */\n    @SuppressWarnings(\"rawtypes\") // the static instance works for all types\n    public static final Closure INSTANCE = new ExceptionClosure<>();\n\n    /**\n     * Factory returning the singleton instance.\n     *\n     * @param <T> the type of the input to the operation.\n     * @return the singleton instance\n     * @since 3.1\n     */\n    public static <T> Closure<T> exceptionClosure() {\n        return INSTANCE;\n    }\n\n    /**\n     * Restricted constructor.\n     */\n    private ExceptionClosure() {\n    }\n\n    /**\n     * Always throw an exception.\n     *\n     * @param input  the input object\n     * @throws FunctorException always\n     */\n    @Override\n    public void execute(final T input) {\n        throw new FunctorException(\"ExceptionClosure invoked\");\n    }\n\n    /**\n     * Returns the singleton instance.\n     *\n     * @return the singleton instance.\n     */\n    private Object readResolve() {\n        return INSTANCE;\n    }\n\n}", "super_interfaces": ["Closure<T>", "Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 7179106032121985545L;", "docstring": " Serial version UID", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 7179106032121985545L", "syntax_pass": true}, {"attribute_expression": "@SuppressWarnings(\"rawtypes\") // the static instance works for all types\n    public static final Closure INSTANCE = new ExceptionClosure<>();", "docstring": " Singleton predicate instance", "modifiers": "@SuppressWarnings(\"rawtypes\") // the static instance works for all types\n    public static final", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"rawtypes\")", "public", "static", "final"], "comments": ["// the static instance works for all types"], "type": "Closure", "name": "INSTANCE = new ExceptionClosure<>()", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/functors/NOPClosure.java.NOPClosure", "name": "NOPClosure", "file_path": "src/main/java/org/apache/commons/collections4/functors/NOPClosure.java", "superclasses": "", "methods": ["[Closure<E>]nopClosure()", "[]NOPClosure()", "[void]execute(T)", "[Object]readResolve()"], "method_uris": ["src/main/java/org/apache/commons/collections4/functors/NOPClosure.java.NOPClosure.[Closure<E>]nopClosure()", "src/main/java/org/apache/commons/collections4/functors/NOPClosure.java.NOPClosure.[]NOPClosure()", "src/main/java/org/apache/commons/collections4/functors/NOPClosure.java.NOPClosure.[void]execute(T)", "src/main/java/org/apache/commons/collections4/functors/NOPClosure.java.NOPClosure.[Object]readResolve()"], "overrides": null, "attributes": [], "class_docstring": "\nClosure implementation that does nothing.\n\n@param <T> the type of the input to the operation.\n@since 3.0\n", "original_string": "public final class NOPClosure<T> implements Closure<T>, Serializable {\n\n    /** Serial version UID */\n    private static final long serialVersionUID = 3518477308466486130L;\n\n    /** Singleton predicate instance */\n    @SuppressWarnings(\"rawtypes\")\n    public static final Closure INSTANCE = new NOPClosure<>();\n\n    /**\n     * Factory returning the singleton instance.\n     *\n     * @param <E> the type that the closure acts on\n     * @return the singleton instance\n     * @since 3.1\n     */\n    public static <E> Closure<E> nopClosure() {\n        return INSTANCE;\n    }\n\n    /**\n     * Constructs a new instance.\n     */\n    private NOPClosure() {\n    }\n\n    /**\n     * Do nothing.\n     *\n     * @param input  the input object\n     */\n    @Override\n    public void execute(final T input) {\n        // do nothing\n    }\n\n    /**\n     * Returns the singleton instance.\n     *\n     * @return the singleton instance.\n     */\n    private Object readResolve() {\n        return INSTANCE;\n    }\n\n}", "super_interfaces": ["Closure<T>", "Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 3518477308466486130L;", "docstring": " Serial version UID", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 3518477308466486130L", "syntax_pass": true}, {"attribute_expression": "@SuppressWarnings(\"rawtypes\")\n    public static final Closure INSTANCE = new NOPClosure<>();", "docstring": " Singleton predicate instance", "modifiers": "@SuppressWarnings(\"rawtypes\")\n    public static final", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"rawtypes\")", "public", "static", "final"], "comments": [], "type": "Closure", "name": "INSTANCE = new NOPClosure<>()", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/functors/ComparatorPredicate.java.ComparatorPredicate", "name": "ComparatorPredicate", "file_path": "src/main/java/org/apache/commons/collections4/functors/ComparatorPredicate.java", "superclasses": "", "methods": ["[Predicate<T>]comparatorPredicate(T,Comparator<T>)", "[Predicate<T>]comparatorPredicate(T,Comparator<T>,Criterion)", "[]ComparatorPredicate(T,Comparator<T>,Criterion)", "[boolean]test(T)"], "method_uris": ["src/main/java/org/apache/commons/collections4/functors/ComparatorPredicate.java.ComparatorPredicate.[Predicate<T>]comparatorPredicate(T,Comparator<T>)", "src/main/java/org/apache/commons/collections4/functors/ComparatorPredicate.java.ComparatorPredicate.[Predicate<T>]comparatorPredicate(T,Comparator<T>,Criterion)", "src/main/java/org/apache/commons/collections4/functors/ComparatorPredicate.java.ComparatorPredicate.[]ComparatorPredicate(T,Comparator<T>,Criterion)", "src/main/java/org/apache/commons/collections4/functors/ComparatorPredicate.java.ComparatorPredicate.[boolean]test(T)"], "overrides": null, "attributes": [], "class_docstring": "\nPredicate that compares the input object with the one stored in the predicate using a comparator.\nIn addition, the comparator result can be evaluated in accordance to a supplied criterion value.\n\n<p>In order to demonstrate the use of the predicate, the following variables are declared:</p>\n\n<pre>\nInteger ONE = Integer.valueOf(1);\nInteger TWO = Integer.valueOf(2);\n\nComparator comparator = new Comparator() {\n\n    public int compare(Object first, Object second) {\n        return ((Integer) second) - ((Integer) first);\n    }\n\n};\n</pre>\n\n<p>Using the declared variables, the {@code ComparatorPredicate} can be used in the\nfollowing way:</p>\n\n<pre>\nComparatorPredicate.comparatorPredicate(ONE, comparator).test(TWO);\n</pre>\n\n<p>The input variable {@code TWO} in compared to the stored variable {@code ONE} using\nthe supplied {@code comparator}. This is the default usage of the predicate and will return\n{@code true} if the underlying comparator returns {@code 0}. In addition to the default\nusage of the predicate, it is possible to evaluate the comparator's result in several ways. The\nfollowing {@link Criterion} enumeration values are provided by the predicate:\n</p>\n\n<ul>\n    <li>EQUAL</li>\n    <li>GREATER</li>\n    <li>GREATER_OR_EQUAL</li>\n    <li>LESS</li>\n    <li>LESS_OR_EQUAL</li>\n</ul>\n\n<p>The following examples demonstrates how these constants can be used in order to manipulate the\nevaluation of a comparator result.</p>\n\n<pre>\nComparatorPredicate.comparatorPredicate(ONE, comparator,<b>ComparatorPredicate.Criterion.GREATER</b>).test(TWO);\n</pre>\n\n<p>The input variable TWO is compared to the stored variable ONE using the supplied {@code comparator}\nusing the {@code GREATER} evaluation criterion constant. This instructs the predicate to\nreturn {@code true} if the comparator returns a value greater than {@code 0}.</p>\n\n@param <T> the type of the input to the predicate.\n@since 4.0\n", "original_string": "public class ComparatorPredicate<T> extends AbstractPredicate<T> implements Serializable {\n\n    /**\n     * Enumerates the comparator criteria.\n     */\n    public enum Criterion {\n\n        /**\n         * Equal criterion.\n         */\n        EQUAL,\n\n        /**\n         * Greater criterion.\n         */\n        GREATER,\n\n        /**\n         * Less criterion.\n         */\n        LESS,\n\n        /**\n         * Greater or equal criterion.\n         */\n        GREATER_OR_EQUAL,\n\n        /**\n         * Less or equal Criterion.\n         */\n        LESS_OR_EQUAL,\n    }\n\n    private static final long serialVersionUID = -1863209236504077399L;\n\n    /**\n     * Factory to create the comparator predicate\n     *\n     * @param <T> the type that the predicate queries\n     * @param object  the object to compare to\n     * @param comparator  the comparator to use for comparison\n     * @return the predicate\n     * @throws NullPointerException if comparator is null\n     */\n    public static <T> Predicate<T> comparatorPredicate(final T object, final Comparator<T> comparator) {\n        return comparatorPredicate(object, comparator, Criterion.EQUAL);\n    }\n\n    /**\n     * Factory to create the comparator predicate\n     *\n     * @param <T> the type that the predicate queries\n     * @param object  the object to compare to\n     * @param comparator  the comparator to use for comparison\n     * @param criterion  the criterion to use to evaluate comparison\n     * @return the predicate\n     * @throws NullPointerException if comparator or criterion is null\n     */\n    public static <T> Predicate<T> comparatorPredicate(final T object, final Comparator<T> comparator,\n                                                       final Criterion criterion) {\n        return new ComparatorPredicate<>(object, Objects.requireNonNull(comparator, \"comparator\"),\n                Objects.requireNonNull(criterion, \"criterion\"));\n    }\n\n    /** The internal object to compare with */\n    private final T object;\n\n    /** The comparator to use for comparison */\n    private final Comparator<T> comparator;\n\n    /** The comparison evaluation criterion to use */\n    private final Criterion criterion;\n\n    /**\n     * Constructor that performs no validation.\n     * Use {@code comparatorPredicate} if you want that.\n     *\n     * @param object  the object to compare to\n     * @param comparator  the comparator to use for comparison\n     * @param criterion  the criterion to use to evaluate comparison\n     */\n    public ComparatorPredicate(final T object, final Comparator<T> comparator, final Criterion criterion) {\n        this.object = object;\n        this.comparator = comparator;\n        this.criterion = criterion;\n    }\n\n    /**\n     * Evaluates the predicate. The predicate evaluates to {@code true} in the following cases:\n     *\n     * <ul>\n     * <li>{@code comparator.compare(object, input) == 0 &amp;&amp; criterion == EQUAL}</li>\n     * <li>{@code comparator.compare(object, input) &lt; 0 &amp;&amp; criterion == LESS}</li>\n     * <li>{@code comparator.compare(object, input) &gt; 0 &amp;&amp; criterion == GREATER}</li>\n     * <li>{@code comparator.compare(object, input) &gt;= 0 &amp;&amp; criterion == GREATER_OR_EQUAL}</li>\n     * <li>{@code comparator.compare(object, input) &lt;= 0 &amp;&amp; criterion == LESS_OR_EQUAL}</li>\n     * </ul>\n     *\n     * @see org.apache.commons.collections4.Predicate#test(Object)\n     * @see java.util.Comparator#compare(Object first, Object second)\n     *\n     * @param target  the target object to compare to\n     * @return {@code true} if the comparison succeeds according to the selected criterion\n     * @throws IllegalStateException if the criterion is invalid (really not possible)\n     */\n    @Override\n    public boolean test(final T target) {\n\n        boolean result = false;\n        final int comparison = comparator.compare(object, target);\n        switch (criterion) {\n        case EQUAL:\n            result = comparison == 0;\n            break;\n        case GREATER:\n            result = comparison > 0;\n            break;\n        case LESS:\n            result = comparison < 0;\n            break;\n        case GREATER_OR_EQUAL:\n            result = comparison >= 0;\n            break;\n        case LESS_OR_EQUAL:\n            result = comparison <= 0;\n            break;\n        default:\n            throw new IllegalStateException(\"The current criterion '\" + criterion + \"' is invalid.\");\n        }\n\n        return result;\n    }\n}", "super_interfaces": ["Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = -1863209236504077399L;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -1863209236504077399L", "syntax_pass": true}, {"attribute_expression": "private final T object;", "docstring": " The internal object to compare with", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "T", "name": "object", "syntax_pass": true}, {"attribute_expression": "private final Comparator<T> comparator;", "docstring": " The comparator to use for comparison", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Comparator<T>", "name": "comparator", "syntax_pass": true}, {"attribute_expression": "private final Criterion criterion;", "docstring": " The comparison evaluation criterion to use", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Criterion", "name": "criterion", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/functors/NullIsExceptionPredicate.java.NullIsExceptionPredicate", "name": "NullIsExceptionPredicate", "file_path": "src/main/java/org/apache/commons/collections4/functors/NullIsExceptionPredicate.java", "superclasses": "", "methods": ["[Predicate<T>]nullIsExceptionPredicate(Predicate<? super T>)", "[]NullIsExceptionPredicate(Predicate<? super T>)", "[Predicate<? super T>[]]getPredicates()", "[boolean]test(T)"], "method_uris": ["src/main/java/org/apache/commons/collections4/functors/NullIsExceptionPredicate.java.NullIsExceptionPredicate.[Predicate<T>]nullIsExceptionPredicate(Predicate<? super T>)", "src/main/java/org/apache/commons/collections4/functors/NullIsExceptionPredicate.java.NullIsExceptionPredicate.[]NullIsExceptionPredicate(Predicate<? super T>)", "src/main/java/org/apache/commons/collections4/functors/NullIsExceptionPredicate.java.NullIsExceptionPredicate.[Predicate<? super T>[]]getPredicates()", "src/main/java/org/apache/commons/collections4/functors/NullIsExceptionPredicate.java.NullIsExceptionPredicate.[boolean]test(T)"], "overrides": null, "attributes": [], "class_docstring": "\nPredicate implementation that throws an exception if the input is null.\n\n@param <T> the type of the input to the predicate.\n@since 3.0\n", "original_string": "public final class NullIsExceptionPredicate<T> extends AbstractPredicate<T> implements PredicateDecorator<T>, Serializable {\n\n    /** Serial version UID */\n    private static final long serialVersionUID = 3243449850504576071L;\n\n    /**\n     * Factory to create the null exception predicate.\n     *\n     * @param <T> the type that the predicate queries\n     * @param predicate  the predicate to decorate, not null\n     * @return the predicate\n     * @throws NullPointerException if the predicate is null\n     */\n    public static <T> Predicate<T> nullIsExceptionPredicate(final Predicate<? super T> predicate) {\n        return new NullIsExceptionPredicate<>(Objects.requireNonNull(predicate, \"predicate\"));\n    }\n\n    /** The predicate to decorate */\n    private final Predicate<? super T> iPredicate;\n\n    /**\n     * Constructor that performs no validation.\n     * Use {@code nullIsExceptionPredicate} if you want that.\n     *\n     * @param predicate  the predicate to call after the null check\n     */\n    public NullIsExceptionPredicate(final Predicate<? super T> predicate) {\n        iPredicate = predicate;\n    }\n\n    /**\n     * Gets the predicate being decorated.\n     *\n     * @return the predicate as the only element in an array\n     * @since 3.1\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public Predicate<? super T>[] getPredicates() {\n        return new Predicate[] { iPredicate };\n    }\n\n    /**\n     * Evaluates the predicate returning the result of the decorated predicate\n     * once a null check is performed.\n     *\n     * @param object  the input object\n     * @return true if decorated predicate returns true\n     * @throws FunctorException if input is null\n     */\n    @Override\n    public boolean test(final T object) {\n        if (object == null) {\n            throw new FunctorException(\"Input Object must not be null\");\n        }\n        return iPredicate.test(object);\n    }\n\n}", "super_interfaces": ["PredicateDecorator<T>", "Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 3243449850504576071L;", "docstring": " Serial version UID", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 3243449850504576071L", "syntax_pass": true}, {"attribute_expression": "private final Predicate<? super T> iPredicate;", "docstring": " The predicate to decorate", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Predicate<? super T>", "name": "iPredicate", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/functors/ClosureTransformer.java.ClosureTransformer", "name": "ClosureTransformer", "file_path": "src/main/java/org/apache/commons/collections4/functors/ClosureTransformer.java", "superclasses": "", "methods": ["[Transformer<T, T>]closureTransformer(Closure<? super T>)", "[]ClosureTransformer(Closure<? super T>)", "[Closure<? super T>]getClosure()", "[T]transform(T)"], "method_uris": ["src/main/java/org/apache/commons/collections4/functors/ClosureTransformer.java.ClosureTransformer.[Transformer<T, T>]closureTransformer(Closure<? super T>)", "src/main/java/org/apache/commons/collections4/functors/ClosureTransformer.java.ClosureTransformer.[]ClosureTransformer(Closure<? super T>)", "src/main/java/org/apache/commons/collections4/functors/ClosureTransformer.java.ClosureTransformer.[Closure<? super T>]getClosure()", "src/main/java/org/apache/commons/collections4/functors/ClosureTransformer.java.ClosureTransformer.[T]transform(T)"], "overrides": null, "attributes": [], "class_docstring": "\nTransformer implementation that calls a Closure using the input object\nand then returns the input.\n\n@param <T> the type of the input and result to the function.\n@since 3.0\n", "original_string": "public class ClosureTransformer<T> implements Transformer<T, T>, Serializable {\n\n    /** Serial version UID */\n    private static final long serialVersionUID = 478466901448617286L;\n\n    /**\n     * Factory method that performs validation.\n     *\n     * @param <T>  the type of the object to transform\n     * @param closure  the closure to call, not null\n     * @return the {@code closure} transformer\n     * @throws NullPointerException if the closure is null\n     */\n    public static <T> Transformer<T, T> closureTransformer(final Closure<? super T> closure) {\n        return new ClosureTransformer<>(Objects.requireNonNull(closure, \"closure\"));\n    }\n\n    /** The closure to wrap */\n    private final Closure<? super T> iClosure;\n\n    /**\n     * Constructor that performs no validation.\n     * Use {@code closureTransformer} if you want that.\n     *\n     * @param closure  the closure to call, not null\n     */\n    public ClosureTransformer(final Closure<? super T> closure) {\n        iClosure = closure;\n    }\n\n    /**\n     * Gets the closure.\n     *\n     * @return the closure\n     * @since 3.1\n     */\n    public Closure<? super T> getClosure() {\n        return iClosure;\n    }\n\n    /**\n     * Transforms the input to result by executing a closure.\n     *\n     * @param input  the input object to transform\n     * @return the transformed result\n     */\n    @Override\n    public T transform(final T input) {\n        iClosure.accept(input);\n        return input;\n    }\n\n}", "super_interfaces": ["Transformer<T, T>", "Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 478466901448617286L;", "docstring": " Serial version UID", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 478466901448617286L", "syntax_pass": true}, {"attribute_expression": "private final Closure<? super T> iClosure;", "docstring": " The closure to wrap", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Closure<? super T>", "name": "iClosure", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/functors/InvokerTransformer.java.InvokerTransformer", "name": "InvokerTransformer", "file_path": "src/main/java/org/apache/commons/collections4/functors/InvokerTransformer.java", "superclasses": "", "methods": ["[Transformer<I, O>]invokerTransformer(String)", "[Transformer<I, O>]invokerTransformer(String,Class<?>[],Object[])", "[]InvokerTransformer(String)", "[]InvokerTransformer(String,Class<?>[],Object[])", "[R]transform(Object)"], "method_uris": ["src/main/java/org/apache/commons/collections4/functors/InvokerTransformer.java.InvokerTransformer.[Transformer<I, O>]invokerTransformer(String)", "src/main/java/org/apache/commons/collections4/functors/InvokerTransformer.java.InvokerTransformer.[Transformer<I, O>]invokerTransformer(String,Class<?>[],Object[])", "src/main/java/org/apache/commons/collections4/functors/InvokerTransformer.java.InvokerTransformer.[]InvokerTransformer(String)", "src/main/java/org/apache/commons/collections4/functors/InvokerTransformer.java.InvokerTransformer.[]InvokerTransformer(String,Class<?>[],Object[])", "src/main/java/org/apache/commons/collections4/functors/InvokerTransformer.java.InvokerTransformer.[R]transform(Object)"], "overrides": null, "attributes": [], "class_docstring": "\nTransformer implementation that creates a new object instance by reflection.\n<p>\n<b>WARNING:</b> from v4.1 onwards this class will <b>not</b> be serializable anymore\nin order to prevent potential remote code execution exploits. Please refer to\n<a href=\"https://issues.apache.org/jira/browse/COLLECTIONS-580\">COLLECTIONS-580</a>\nfor more details.\n</p>\n\n@param <T> the type of the input to the function.\n@param <R> the type of the result of the function.\n@since 3.0\n", "original_string": "public class InvokerTransformer<T, R> implements Transformer<T, R> {\n\n    /**\n     * Gets an instance of this transformer calling a specific method with no arguments.\n     *\n     * @param <I>  the input type\n     * @param <O>  the output type\n     * @param methodName  the method name to call\n     * @return an invoker transformer\n     * @throws NullPointerException if methodName is null\n     * @since 3.1\n     */\n    public static <I, O> Transformer<I, O> invokerTransformer(final String methodName) {\n        return new InvokerTransformer<>(Objects.requireNonNull(methodName, \"methodName\"));\n    }\n    /**\n     * Gets an instance of this transformer calling a specific method with specific values.\n     *\n     * @param <I>  the input type\n     * @param <O>  the output type\n     * @param methodName  the method name to call\n     * @param paramTypes  the parameter types of the method\n     * @param args  the arguments to pass to the method\n     * @return an invoker transformer\n     * @throws NullPointerException if methodName is null\n     * @throws IllegalArgumentException if paramTypes does not match args\n     */\n    public static <I, O> Transformer<I, O> invokerTransformer(final String methodName, final Class<?>[] paramTypes,\n                                                              final Object[] args) {\n        Objects.requireNonNull(methodName, \"methodName\");\n        if (paramTypes == null && args != null\n            || paramTypes != null && args == null\n            || paramTypes != null && args != null && paramTypes.length != args.length) {\n            throw new IllegalArgumentException(\"The parameter types must match the arguments\");\n        }\n        if (paramTypes == null || paramTypes.length == 0) {\n            return new InvokerTransformer<>(methodName);\n        }\n        return new InvokerTransformer<>(methodName, paramTypes, args);\n    }\n    /** The method name to call */\n    private final String iMethodName;\n\n    /** The array of reflection parameter types */\n    private final Class<?>[] iParamTypes;\n\n    /** The array of reflection arguments */\n    private final Object[] iArgs;\n\n    /**\n     * Constructor for no arg instance.\n     *\n     * @param methodName  the method to call\n     */\n    private InvokerTransformer(final String methodName) {\n        iMethodName = methodName;\n        iParamTypes = null;\n        iArgs = null;\n    }\n\n    /**\n     * Constructor that performs no validation.\n     * Use {@code invokerTransformer} if you want that.\n     * <p>\n     * Note: from 4.0, the input parameters will be cloned\n     *\n     * @param methodName  the method to call\n     * @param paramTypes  the constructor parameter types\n     * @param args  the constructor arguments\n     */\n    public InvokerTransformer(final String methodName, final Class<?>[] paramTypes, final Object[] args) {\n        iMethodName = methodName;\n        iParamTypes = paramTypes != null ? paramTypes.clone() : null;\n        iArgs = args != null ? args.clone() : null;\n    }\n\n    /**\n     * Transforms the input to result by invoking a method on the input.\n     *\n     * @param input  the input object to transform\n     * @return the transformed result, null if null input\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public R transform(final Object input) {\n        if (input == null) {\n            return null;\n        }\n        try {\n            final Class<?> cls = input.getClass();\n            final Method method = cls.getMethod(iMethodName, iParamTypes);\n            return (R) method.invoke(input, iArgs);\n        } catch (final NoSuchMethodException ex) {\n            throw new FunctorException(\"InvokerTransformer: The method '\" + iMethodName + \"' on '\" +\n                                       input.getClass() + \"' does not exist\");\n        } catch (final IllegalAccessException ex) {\n            throw new FunctorException(\"InvokerTransformer: The method '\" + iMethodName + \"' on '\" +\n                                       input.getClass() + \"' cannot be accessed\");\n        } catch (final InvocationTargetException ex) {\n            throw new FunctorException(\"InvokerTransformer: The method '\" + iMethodName + \"' on '\" +\n                                       input.getClass() + \"' threw an exception\", ex);\n        }\n    }\n\n}", "super_interfaces": ["Transformer<T, R>"], "fields": [{"attribute_expression": "private final String iMethodName;", "docstring": " The method name to call", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "iMethodName", "syntax_pass": true}, {"attribute_expression": "private final Class<?>[] iParamTypes;", "docstring": " The array of reflection parameter types", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Class<?>[]", "name": "iParamTypes", "syntax_pass": true}, {"attribute_expression": "private final Object[] iArgs;", "docstring": " The array of reflection arguments", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Object[]", "name": "iArgs", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/comparators/ComparableComparator.java.ComparableComparator", "name": "ComparableComparator", "file_path": "src/main/java/org/apache/commons/collections4/comparators/ComparableComparator.java", "superclasses": "", "methods": ["[ComparableComparator<E>]comparableComparator()", "[]ComparableComparator()", "[int]compare(E,E)", "[boolean]equals(Object)", "[int]hashCode()"], "method_uris": ["src/main/java/org/apache/commons/collections4/comparators/ComparableComparator.java.ComparableComparator.[ComparableComparator<E>]comparableComparator()", "src/main/java/org/apache/commons/collections4/comparators/ComparableComparator.java.ComparableComparator.[]ComparableComparator()", "src/main/java/org/apache/commons/collections4/comparators/ComparableComparator.java.ComparableComparator.[int]compare(E,E)", "src/main/java/org/apache/commons/collections4/comparators/ComparableComparator.java.ComparableComparator.[boolean]equals(Object)", "src/main/java/org/apache/commons/collections4/comparators/ComparableComparator.java.ComparableComparator.[int]hashCode()"], "overrides": null, "attributes": [], "class_docstring": "\nA {@link Comparator Comparator} that compares {@link Comparable Comparable}\nobjects.\n<p>\nThis Comparator is useful, for example, for enforcing the natural order in\ncustom implementations of {@link java.util.SortedSet SortedSet} and\n{@link java.util.SortedMap SortedMap}.\n</p>\n<p>\nNote: In the 2.0 and 2.1 releases of Commons Collections, this class would\nthrow a {@link ClassCastException} if either of the arguments to\n{@link #compare(Comparable, Comparable)} compare} were {@code null}, not\n{@link Comparable Comparable}, or for which\n{@link Comparable#compareTo(Object) compareTo} gave inconsistent results.\nThis is no longer the case. See {@link #compare(Comparable, Comparable)} compare} for\ndetails.\n</p>\n\n@param <E> the type of objects compared by this comparator\n\n@since 2.0\n@see java.util.Collections#reverseOrder()\n", "original_string": "public class ComparableComparator<E extends Comparable<? super E>> implements Comparator<E>, Serializable {\n\n    /** Serialization version. */\n    private static final long serialVersionUID = -291439688585137865L;\n\n    /** The singleton instance. */\n    @SuppressWarnings(\"rawtypes\")\n    public static final ComparableComparator INSTANCE = new ComparableComparator();\n\n    /**\n     * Gets the singleton instance of a ComparableComparator.\n     * <p>\n     * Developers are encouraged to use the comparator returned from this method\n     * instead of constructing a new instance to reduce allocation and GC overhead\n     * when multiple comparable comparators may be used in the same VM.\n     *\n     * @param <E>  the element type\n     * @return the singleton ComparableComparator\n     * @since 4.0\n     */\n    public static <E extends Comparable<? super E>> ComparableComparator<E> comparableComparator() {\n        return INSTANCE;\n    }\n\n    /**\n     * Constructor whose use should be avoided.\n     * <p>\n     * Please use the {@link #comparableComparator()} method whenever possible.\n     */\n    public ComparableComparator() {\n    }\n\n    /**\n     * Compare the two {@link Comparable Comparable} arguments.\n     * This method is equivalent to:\n     * <pre>((Comparable)obj1).compareTo(obj2)</pre>\n     *\n     * @param obj1  the first object to compare\n     * @param obj2  the second object to compare\n     * @return negative if obj1 is less, positive if greater, zero if equal\n     * @throws NullPointerException if <em>obj1</em> is {@code null},\n     *         or when {@code ((Comparable)obj1).compareTo(obj2)} does\n     * @throws ClassCastException if <em>obj1</em> is not a {@code Comparable},\n     *         or when {@code ((Comparable)obj1).compareTo(obj2)} does\n     */\n    @Override\n    public int compare(final E obj1, final E obj2) {\n        return obj1.compareTo(obj2);\n    }\n\n    /**\n     * Returns {@code true} iff <em>that</em> Object is a {@link Comparator Comparator}\n     * whose ordering is known to be equivalent to mine.\n     * <p>\n     * This implementation returns {@code true} iff\n     * {@code <em>object</em>.{@link Object#getClass() getClass()}} equals\n     * {@code this.getClass()}. Subclasses may want to override this behavior to remain\n     * consistent with the {@link Comparator#equals(Object)} contract.\n     *\n     * @param object  the object to compare with\n     * @return {@code true} if equal\n     * @since 3.0\n     */\n    @Override\n    public boolean equals(final Object object) {\n        return this == object ||\n               null != object && object.getClass().equals(this.getClass());\n    }\n\n    /**\n     * Implement a hash code for this comparator that is consistent with\n     * {@link #equals(Object) equals}.\n     *\n     * @return a hash code for this comparator.\n     * @since 3.0\n     */\n    @Override\n    public int hashCode() {\n        return \"ComparableComparator\".hashCode();\n    }\n\n}", "super_interfaces": ["Comparator<E>", "Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = -291439688585137865L;", "docstring": " Serialization version.", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -291439688585137865L", "syntax_pass": true}, {"attribute_expression": "@SuppressWarnings(\"rawtypes\")\n    public static final ComparableComparator INSTANCE = new ComparableComparator();", "docstring": " The singleton instance.", "modifiers": "@SuppressWarnings(\"rawtypes\")\n    public static final", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"rawtypes\")", "public", "static", "final"], "comments": [], "type": "ComparableComparator", "name": "INSTANCE = new ComparableComparator()", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/comparators/TransformingComparator.java.TransformingComparator", "name": "TransformingComparator", "file_path": "src/main/java/org/apache/commons/collections4/comparators/TransformingComparator.java", "superclasses": "", "methods": ["[]TransformingComparator(Transformer<? super I, ? extends O>)", "[]TransformingComparator(Transformer<? super I, ? extends O>,Comparator<O>)", "[int]compare(I,I)", "[boolean]equals(Object)", "[int]hashCode()"], "method_uris": ["src/main/java/org/apache/commons/collections4/comparators/TransformingComparator.java.TransformingComparator.[]TransformingComparator(Transformer<? super I, ? extends O>)", "src/main/java/org/apache/commons/collections4/comparators/TransformingComparator.java.TransformingComparator.[]TransformingComparator(Transformer<? super I, ? extends O>,Comparator<O>)", "src/main/java/org/apache/commons/collections4/comparators/TransformingComparator.java.TransformingComparator.[int]compare(I,I)", "src/main/java/org/apache/commons/collections4/comparators/TransformingComparator.java.TransformingComparator.[boolean]equals(Object)", "src/main/java/org/apache/commons/collections4/comparators/TransformingComparator.java.TransformingComparator.[int]hashCode()"], "overrides": null, "attributes": [], "class_docstring": "\nDecorates another Comparator with transformation behavior. That is, the\nreturn value from the transform operation will be passed to the decorated\n{@link Comparator#compare(Object,Object) compare} method.\n<p>\nThis class is Serializable from Commons Collections 4.0.\n</p>\n\n@param <I> the type of the input to the function\n@param <O> the type of the result of the function\n\n@since 2.1\n\n@see org.apache.commons.collections4.Transformer\n@see org.apache.commons.collections4.comparators.ComparableComparator\n", "original_string": "public class TransformingComparator<I, O> implements Comparator<I>, Serializable {\n\n    /** Serialization version from Collections 4.0. */\n    private static final long serialVersionUID = 3456940356043606220L;\n\n    /** The decorated comparator. */\n    private final Comparator<O> decorated;\n\n    /** The transformer being used. */\n    private final Transformer<? super I, ? extends O> transformer;\n\n    /**\n     * Constructs an instance with the given Transformer and a\n     * {@link ComparableComparator ComparableComparator}.\n     *\n     * @param transformer what will transform the arguments to {@code compare}\n     */\n    public TransformingComparator(final Transformer<? super I, ? extends O> transformer) {\n        this(transformer, ComparatorUtils.NATURAL_COMPARATOR);\n    }\n\n    /**\n     * Constructs an instance with the given Transformer and Comparator.\n     *\n     * @param transformer  what will transform the arguments to {@code compare}\n     * @param decorated  the decorated Comparator\n     */\n    public TransformingComparator(final Transformer<? super I, ? extends O> transformer,\n                                  final Comparator<O> decorated) {\n        this.decorated = decorated;\n        this.transformer = transformer;\n    }\n\n    /**\n     * Returns the result of comparing the values from the transform operation.\n     *\n     * @param obj1  the first object to transform then compare\n     * @param obj2  the second object to transform then compare\n     * @return negative if obj1 is less, positive if greater, zero if equal\n     */\n    @Override\n    public int compare(final I obj1, final I obj2) {\n        final O value1 = transformer.apply(obj1);\n        final O value2 = transformer.apply(obj2);\n        return decorated.compare(value1, value2);\n    }\n\n    /**\n     * Returns {@code true} iff <em>that</em> Object is\n     * a {@link Comparator} whose ordering is known to be\n     * equivalent to mine.\n     * <p>\n     * This implementation returns {@code true}\n     * iff {@code <em>that</em>} is a {@link TransformingComparator}\n     * whose attributes are equal to mine.\n     *\n     * @param object  the object to compare to\n     * @return true if equal\n     */\n    @Override\n    public boolean equals(final Object object) {\n        if (this == object) {\n            return true;\n        }\n        if (null == object) {\n            return false;\n        }\n        if (object.getClass().equals(this.getClass())) {\n            final TransformingComparator<?, ?> comp = (TransformingComparator<?, ?>) object;\n            return Objects.equals(decorated, comp.decorated) &&\n                   Objects.equals(transformer, comp.transformer);\n        }\n        return false;\n    }\n\n    /**\n     * Implement a hash code for this comparator that is consistent with\n     * {@link #equals(Object) equals}.\n     *\n     * @return a hash code for this comparator.\n     */\n    @Override\n    public int hashCode() {\n        int total = 17;\n        total = total * 37 + (decorated == null ? 0 : decorated.hashCode());\n        return total * 37 + (transformer == null ? 0 : transformer.hashCode());\n    }\n\n}", "super_interfaces": ["Comparator<I>", "Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 3456940356043606220L;", "docstring": " Serialization version from Collections 4.0.", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 3456940356043606220L", "syntax_pass": true}, {"attribute_expression": "private final Comparator<O> decorated;", "docstring": " The decorated comparator.", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Comparator<O>", "name": "decorated", "syntax_pass": true}, {"attribute_expression": "private final Transformer<? super I, ? extends O> transformer;", "docstring": " The transformer being used.", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Transformer<? super I, ? extends O>", "name": "transformer", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/comparators/NullComparator.java.NullComparator", "name": "NullComparator", "file_path": "src/main/java/org/apache/commons/collections4/comparators/NullComparator.java", "superclasses": "", "methods": ["[]NullComparator()", "[]NullComparator(boolean)", "[]NullComparator(Comparator<? super E>)", "[]NullComparator(Comparator<? super E>,boolean)", "[int]compare(E,E)", "[boolean]equals(Object)", "[int]hashCode()"], "method_uris": ["src/main/java/org/apache/commons/collections4/comparators/NullComparator.java.NullComparator.[]NullComparator()", "src/main/java/org/apache/commons/collections4/comparators/NullComparator.java.NullComparator.[]NullComparator(boolean)", "src/main/java/org/apache/commons/collections4/comparators/NullComparator.java.NullComparator.[]NullComparator(Comparator<? super E>)", "src/main/java/org/apache/commons/collections4/comparators/NullComparator.java.NullComparator.[]NullComparator(Comparator<? super E>,boolean)", "src/main/java/org/apache/commons/collections4/comparators/NullComparator.java.NullComparator.[int]compare(E,E)", "src/main/java/org/apache/commons/collections4/comparators/NullComparator.java.NullComparator.[boolean]equals(Object)", "src/main/java/org/apache/commons/collections4/comparators/NullComparator.java.NullComparator.[int]hashCode()"], "overrides": null, "attributes": [], "class_docstring": "\nA Comparator that will compare nulls to be either lower or higher than\nother objects.\n\n@param <E> the type of objects compared by this comparator\n@since 2.0\n", "original_string": "public class NullComparator<E> implements Comparator<E>, Serializable {\n\n    /** Serialization version. */\n    private static final long serialVersionUID = -5820772575483504339L;\n\n    /**\n     *  The comparator to use when comparing two non-{@code null} objects.\n     **/\n    private final Comparator<? super E> nonNullComparator;\n\n    /**\n     *  Specifies whether a {@code null} are compared as higher than\n     *  non-{@code null} objects.\n     **/\n    private final boolean nullsAreHigh;\n\n    /**\n     *  Construct an instance that sorts {@code null} higher than any\n     *  non-{@code null} object it is compared with. When comparing two\n     *  non-{@code null} objects, the {@link ComparableComparator} is\n     *  used.\n     **/\n    public NullComparator() {\n        this(ComparatorUtils.NATURAL_COMPARATOR, true);\n    }\n\n    /**\n     *  Construct an instance that sorts {@code null} higher or lower than\n     *  any non-{@code null} object it is compared with.  When comparing\n     *  two non-{@code null} objects, the {@link ComparableComparator} is\n     *  used.\n     *\n     *  @param nullsAreHigh a {@code true} value indicates that\n     *  {@code null} should be compared as higher than a\n     *  non-{@code null} object.  A {@code false} value indicates\n     *  that {@code null} should be compared as lower than a\n     *  non-{@code null} object.\n     **/\n    public NullComparator(final boolean nullsAreHigh) {\n        this(ComparatorUtils.NATURAL_COMPARATOR, nullsAreHigh);\n    }\n\n    /**\n     *  Construct an instance that sorts {@code null} higher than any\n     *  non-{@code null} object it is compared with.  When comparing two\n     *  non-{@code null} objects, the specified {@link Comparator} is\n     *  used.\n     *\n     *  @param nonNullComparator the comparator to use when comparing two\n     *  non-{@code null} objects.  This argument cannot be\n     *  {@code null}\n     *\n     *  @throws NullPointerException if {@code nonNullComparator} is\n     *  {@code null}\n     **/\n    public NullComparator(final Comparator<? super E> nonNullComparator) {\n        this(nonNullComparator, true);\n    }\n\n    /**\n     *  Construct an instance that sorts {@code null} higher or lower than\n     *  any non-{@code null} object it is compared with.  When comparing\n     *  two non-{@code null} objects, the specified {@link Comparator} is\n     *  used.\n     *\n     *  @param nonNullComparator the comparator to use when comparing two\n     *  non-{@code null} objects. This argument cannot be\n     *  {@code null}\n     *\n     *  @param nullsAreHigh a {@code true} value indicates that\n     *  {@code null} should be compared as higher than a\n     *  non-{@code null} object.  A {@code false} value indicates\n     *  that {@code null} should be compared as lower than a\n     *  non-{@code null} object.\n     *\n     *  @throws NullPointerException if {@code nonNullComparator} is\n     *  {@code null}\n     **/\n    public NullComparator(final Comparator<? super E> nonNullComparator, final boolean nullsAreHigh) {\n        this.nonNullComparator = Objects.requireNonNull(nonNullComparator, \"nonNullComparator\");\n        this.nullsAreHigh = nullsAreHigh;\n    }\n\n    /**\n     *  Perform a comparison between two objects.  If both objects are\n     *  {@code null}, a {@code 0} value is returned.  If one object\n     *  is {@code null} and the other is not, the result is determined on\n     *  whether the Comparator was constructed to have nulls as higher or lower\n     *  than other objects.  If neither object is {@code null}, an\n     *  underlying comparator specified in the constructor (or the default) is\n     *  used to compare the non-{@code null} objects.\n     *\n     *  @param o1  the first object to compare\n     *  @param o2  the object to compare it to.\n     *  @return {@code -1} if {@code o1} is \"lower\" than (less than,\n     *  before, etc.) {@code o2}; {@code 1} if {@code o1} is\n     *  \"higher\" than (greater than, after, etc.) {@code o2}; or\n     *  {@code 0} if {@code o1} and {@code o2} are equal.\n     **/\n    @Override\n    public int compare(final E o1, final E o2) {\n        if (o1 == o2) {\n            return 0;\n        }\n        if (o1 == null) {\n            return nullsAreHigh ? 1 : -1;\n        }\n        if (o2 == null) {\n            return nullsAreHigh ? -1 : 1;\n        }\n        return nonNullComparator.compare(o1, o2);\n    }\n\n    /**\n     *  Determines whether the specified object represents a comparator that is\n     *  equal to this comparator.\n     *\n     *  @param obj  the object to compare this comparator with.\n     *\n     *  @return {@code true} if the specified object is a NullComparator\n     *  with equivalent {@code null} comparison behavior\n     *  (i.e. {@code null} high or low) and with equivalent underlying\n     *  non-{@code null} object comparators.\n     **/\n    @Override\n    public boolean equals(final Object obj) {\n        if (obj == null) {\n            return false;\n        }\n        if (obj == this) {\n            return true;\n        }\n        if (!obj.getClass().equals(this.getClass())) {\n            return false;\n        }\n\n        final NullComparator<?> other = (NullComparator<?>) obj;\n\n        return nullsAreHigh == other.nullsAreHigh &&\n                nonNullComparator.equals(other.nonNullComparator);\n    }\n\n    /**\n     *  Implement a hash code for this comparator that is consistent with\n     *  {@link #equals(Object)}.\n     *\n     *  @return a hash code for this comparator.\n     **/\n    @Override\n    public int hashCode() {\n        return (nullsAreHigh ? -1 : 1) * nonNullComparator.hashCode();\n    }\n}", "super_interfaces": ["Comparator<E>", "Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = -5820772575483504339L;", "docstring": " Serialization version.", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -5820772575483504339L", "syntax_pass": true}, {"attribute_expression": "private final Comparator<? super E> nonNullComparator;", "docstring": "\n The comparator to use when comparing two non-{@code null} objects.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Comparator<? super E>", "name": "nonNullComparator", "syntax_pass": true}, {"attribute_expression": "private final boolean nullsAreHigh;", "docstring": "\n Specifies whether a {@code null} are compared as higher than\n non-{@code null} objects.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "boolean", "name": "nullsAreHigh", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/comparators/BooleanComparator.java.BooleanComparator", "name": "BooleanComparator", "file_path": "src/main/java/org/apache/commons/collections4/comparators/BooleanComparator.java", "superclasses": "", "methods": ["[BooleanComparator]booleanComparator(boolean)", "[BooleanComparator]getFalseFirstComparator()", "[BooleanComparator]getTrueFirstComparator()", "[]BooleanComparator()", "[]BooleanComparator(boolean)", "[int]compare(Boolean,Boolean)", "[boolean]equals(Object)", "[int]hashCode()", "[boolean]sortsTrueFirst()"], "method_uris": ["src/main/java/org/apache/commons/collections4/comparators/BooleanComparator.java.BooleanComparator.[BooleanComparator]booleanComparator(boolean)", "src/main/java/org/apache/commons/collections4/comparators/BooleanComparator.java.BooleanComparator.[BooleanComparator]getFalseFirstComparator()", "src/main/java/org/apache/commons/collections4/comparators/BooleanComparator.java.BooleanComparator.[BooleanComparator]getTrueFirstComparator()", "src/main/java/org/apache/commons/collections4/comparators/BooleanComparator.java.BooleanComparator.[]BooleanComparator()", "src/main/java/org/apache/commons/collections4/comparators/BooleanComparator.java.BooleanComparator.[]BooleanComparator(boolean)", "src/main/java/org/apache/commons/collections4/comparators/BooleanComparator.java.BooleanComparator.[int]compare(Boolean,Boolean)", "src/main/java/org/apache/commons/collections4/comparators/BooleanComparator.java.BooleanComparator.[boolean]equals(Object)", "src/main/java/org/apache/commons/collections4/comparators/BooleanComparator.java.BooleanComparator.[int]hashCode()", "src/main/java/org/apache/commons/collections4/comparators/BooleanComparator.java.BooleanComparator.[boolean]sortsTrueFirst()"], "overrides": null, "attributes": [], "class_docstring": "\nA {@link Comparator} for {@link Boolean} objects that can sort either\ntrue or false first.\n\n@see #getTrueFirstComparator()\n@see #getFalseFirstComparator()\n@see #booleanComparator(boolean)\n\n@since 3.0\n", "original_string": "public final class BooleanComparator implements Comparator<Boolean>, Serializable {\n\n    /** Serialization version. */\n    private static final long serialVersionUID = 1830042991606340609L;\n\n    /** Constant \"true first\" reference. */\n    private static final BooleanComparator TRUE_FIRST = new BooleanComparator(true);\n\n    /** Constant \"false first\" reference. */\n    private static final BooleanComparator FALSE_FIRST = new BooleanComparator(false);\n\n    /**\n     * Returns a BooleanComparator instance that sorts\n     * {@code <em>trueFirst</em>} values before\n     * {@code &#x21;<em>trueFirst</em>} values.\n     * <p>\n     * Clients are encouraged to use the value returned from\n     * this method instead of constructing a new instance\n     * to reduce allocation and garbage collection overhead when\n     * multiple BooleanComparators may be used in the same\n     * virtual machine.\n     * </p>\n     *\n     * @param trueFirst when {@code true}, sort\n     * {@code true} {@code Boolean}s before {@code false}\n     * @return a singleton BooleanComparator instance\n     * @since 4.0\n     */\n    public static BooleanComparator booleanComparator(final boolean trueFirst) {\n        return trueFirst ? TRUE_FIRST : FALSE_FIRST;\n    }\n\n    /**\n     * Returns a BooleanComparator instance that sorts\n     * {@code false} values before {@code true} values.\n     * <p>\n     * Clients are encouraged to use the value returned from\n     * this method instead of constructing a new instance\n     * to reduce allocation and garbage collection overhead when\n     * multiple BooleanComparators may be used in the same\n     * virtual machine.\n     * </p>\n     *\n     * @return the false first singleton BooleanComparator\n     */\n    public static BooleanComparator getFalseFirstComparator() {\n        return FALSE_FIRST;\n    }\n\n    /**\n     * Returns a BooleanComparator instance that sorts\n     * {@code true} values before {@code false} values.\n     * <p>\n     * Clients are encouraged to use the value returned from\n     * this method instead of constructing a new instance\n     * to reduce allocation and garbage collection overhead when\n     * multiple BooleanComparators may be used in the same\n     * virtual machine.\n     * </p>\n     *\n     * @return the true first singleton BooleanComparator\n     */\n    public static BooleanComparator getTrueFirstComparator() {\n        return TRUE_FIRST;\n    }\n\n    /** {@code true} iff {@code true} values sort before {@code false} values. */\n    private final boolean trueFirst;\n\n    /**\n     * Creates a {@code BooleanComparator} that sorts\n     * {@code false} values before {@code true} values.\n     * <p>\n     * Equivalent to {@link #BooleanComparator(boolean) BooleanComparator(false)}.\n     * <p>\n     * Please use the static factory instead whenever possible.\n     */\n    public BooleanComparator() {\n        this(false);\n    }\n\n    /**\n     * Creates a {@code BooleanComparator} that sorts\n     * {@code <em>trueFirst</em>} values before\n     * {@code &#x21;<em>trueFirst</em>} values.\n     * <p>\n     * Please use the static factories instead whenever possible.\n     *\n     * @param trueFirst when {@code true}, sort\n     *  {@code true} boolean values before {@code false}\n     */\n    public BooleanComparator(final boolean trueFirst) {\n        this.trueFirst = trueFirst;\n    }\n\n    /**\n     * Compares two non-{@code null} {@code Boolean} objects\n     * according to the value of {@link #sortsTrueFirst()}.\n     *\n     * @param b1  the first boolean to compare\n     * @param b2  the second boolean to compare\n     * @return negative if obj1 is less, positive if greater, zero if equal\n     * @throws NullPointerException when either argument {@code null}\n     */\n    @Override\n    public int compare(final Boolean b1, final Boolean b2) {\n        final boolean v1 = b1.booleanValue();\n        final boolean v2 = b2.booleanValue();\n\n        return v1 ^ v2 ? v1 ^ trueFirst ? 1 : -1 : 0;\n    }\n\n    /**\n     * Returns {@code true} iff <em>that</em> Object is\n     * a {@link Comparator} whose ordering is known to be\n     * equivalent to mine.\n     * <p>\n     * This implementation returns {@code true}\n     * iff {@code <em>that</em>} is a {@link BooleanComparator}\n     * whose value of {@link #sortsTrueFirst()} is equal to mine.\n     *\n     * @param object  the object to compare to\n     * @return true if equal\n     */\n    @Override\n    public boolean equals(final Object object) {\n        return this == object ||\n               object instanceof BooleanComparator &&\n                trueFirst == ((BooleanComparator) object).trueFirst;\n    }\n\n    /**\n     * Implement a hash code for this comparator that is consistent with\n     * {@link #equals(Object) equals}.\n     *\n     * @return a hash code for this comparator.\n     */\n    @Override\n    public int hashCode() {\n        final int hash = \"BooleanComparator\".hashCode();\n        return trueFirst ? -1 * hash : hash;\n    }\n\n    /**\n     * Returns {@code true} iff\n     * I sort {@code true} values before\n     * {@code false} values.  In other words,\n     * returns {@code true} iff\n     * {@link #compare(Boolean,Boolean) compare(Boolean.FALSE,Boolean.TRUE)}\n     * returns a positive value.\n     *\n     * @return the trueFirst flag\n     */\n    public boolean sortsTrueFirst() {\n        return trueFirst;\n    }\n\n}", "super_interfaces": ["Comparator<Boolean>", "Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 1830042991606340609L;", "docstring": " Serialization version.", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 1830042991606340609L", "syntax_pass": true}, {"attribute_expression": "private static final BooleanComparator TRUE_FIRST = new BooleanComparator(true);", "docstring": " Constant \"true first\" reference.", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "BooleanComparator", "name": "TRUE_FIRST = new BooleanComparator(true)", "syntax_pass": true}, {"attribute_expression": "private static final BooleanComparator FALSE_FIRST = new BooleanComparator(false);", "docstring": " Constant \"false first\" reference.", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "BooleanComparator", "name": "FALSE_FIRST = new BooleanComparator(false)", "syntax_pass": true}, {"attribute_expression": "private final boolean trueFirst;", "docstring": " {@code true} iff {@code true} values sort before {@code false} values.", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "boolean", "name": "trueFirst", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/comparators/FixedOrderComparator.java.FixedOrderComparator", "name": "FixedOrderComparator", "file_path": "src/main/java/org/apache/commons/collections4/comparators/FixedOrderComparator.java", "superclasses": "", "methods": ["[]FixedOrderComparator()", "[]FixedOrderComparator(List<T>)", "[]FixedOrderComparator()", "[boolean]add(T)", "[boolean]addAsEqual(T,T)", "[void]checkLocked()", "[int]compare(T,T)", "[boolean]equals(Object)", "[UnknownObjectBehavior]getUnknownObjectBehavior()", "[int]hashCode()", "[boolean]isLocked()", "[void]setUnknownObjectBehavior(UnknownObjectBehavior)"], "method_uris": ["src/main/java/org/apache/commons/collections4/comparators/FixedOrderComparator.java.FixedOrderComparator.[]FixedOrderComparator()", "src/main/java/org/apache/commons/collections4/comparators/FixedOrderComparator.java.FixedOrderComparator.[]FixedOrderComparator(List<T>)", "src/main/java/org/apache/commons/collections4/comparators/FixedOrderComparator.java.FixedOrderComparator.[]FixedOrderComparator()", "src/main/java/org/apache/commons/collections4/comparators/FixedOrderComparator.java.FixedOrderComparator.[boolean]add(T)", "src/main/java/org/apache/commons/collections4/comparators/FixedOrderComparator.java.FixedOrderComparator.[boolean]addAsEqual(T,T)", "src/main/java/org/apache/commons/collections4/comparators/FixedOrderComparator.java.FixedOrderComparator.[void]checkLocked()", "src/main/java/org/apache/commons/collections4/comparators/FixedOrderComparator.java.FixedOrderComparator.[int]compare(T,T)", "src/main/java/org/apache/commons/collections4/comparators/FixedOrderComparator.java.FixedOrderComparator.[boolean]equals(Object)", "src/main/java/org/apache/commons/collections4/comparators/FixedOrderComparator.java.FixedOrderComparator.[UnknownObjectBehavior]getUnknownObjectBehavior()", "src/main/java/org/apache/commons/collections4/comparators/FixedOrderComparator.java.FixedOrderComparator.[int]hashCode()", "src/main/java/org/apache/commons/collections4/comparators/FixedOrderComparator.java.FixedOrderComparator.[boolean]isLocked()", "src/main/java/org/apache/commons/collections4/comparators/FixedOrderComparator.java.FixedOrderComparator.[void]setUnknownObjectBehavior(UnknownObjectBehavior)"], "overrides": null, "attributes": [], "class_docstring": "\nA Comparator which imposes a specific order on a specific set of Objects.\nObjects are presented to the FixedOrderComparator in a specified order and\nsubsequent calls to {@link #compare(Object, Object) compare} yield that order.\nFor example:\n<pre>\nString[] planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\"};\nFixedOrderComparator distanceFromSun = new FixedOrderComparator(planets);\nArrays.sort(planets);                     // Sort to alphabetical order\nArrays.sort(planets, distanceFromSun);    // Back to original order\n</pre>\n<p>\nOnce {@code compare} has been called, the FixedOrderComparator is locked\nand attempts to modify it yield an UnsupportedOperationException.\n</p>\n<p>\nInstances of FixedOrderComparator are not synchronized.  The class is not\nthread-safe at construction time, but it is thread-safe to perform\nmultiple comparisons  after all the setup operations are complete.\n</p>\n<p>\nThis class is Serializable from Commons Collections 4.0.\n</p>\n\n@param <T> the type of objects compared by this comparator\n@since 3.0\n", "original_string": "public class FixedOrderComparator<T> implements Comparator<T>, Serializable {\n\n    /**\n     * Enumerates the unknown object behaviors.\n     *\n     * @since 4.0\n     */\n    public enum UnknownObjectBehavior {\n\n        /**\n         * Before unknown object behaviors.\n         */\n        BEFORE,\n\n        /**\n         * After unknown object behaviors.\n         */\n        AFTER,\n\n        /**\n         * Exception unknown object behaviors.\n         */\n        EXCEPTION\n    }\n\n    /** Serialization version from Collections 4.0. */\n    private static final long serialVersionUID = 82794675842863201L;\n\n    /** Internal map of object to position */\n    private final Map<T, Integer> map = new HashMap<>();\n\n    /** Counter used in determining the position in the map */\n    private int counter;\n\n    /** Is the comparator locked against further change */\n    private boolean isLocked;\n\n    /** The behavior in the case of an unknown object */\n    private UnknownObjectBehavior unknownObjectBehavior = UnknownObjectBehavior.EXCEPTION;\n\n    // Constructors\n    /**\n     * Constructs an empty FixedOrderComparator.\n     */\n    public FixedOrderComparator() {\n    }\n\n    /**\n     * Constructs a FixedOrderComparator which uses the order of the given list\n     * to compare the objects.\n     * <p>\n     * The list is copied, so later changes will not affect the comparator.\n     *\n     * @param items  the items that the comparator can compare in order\n     * @throws NullPointerException if the list is null\n     */\n    public FixedOrderComparator(final List<T> items) {\n        for (final T t : Objects.requireNonNull(items, \"items\")) {\n            add(t);\n        }\n    }\n\n    /**\n     * Constructs a FixedOrderComparator which uses the order of the given array\n     * to compare the objects.\n     * <p>\n     * The array is copied, so later changes will not affect the comparator.\n     *\n     * @param items  the items that the comparator can compare in order\n     * @throws NullPointerException if the array is null\n     */\n    public FixedOrderComparator(final T... items) {\n        for (final T item : Objects.requireNonNull(items, \"items\")) {\n            add(item);\n        }\n    }\n\n    // Methods for adding items\n    /**\n     * Adds an item, which compares as after all items known to the Comparator.\n     * If the item is already known to the Comparator, its old position is\n     * replaced with the new position.\n     *\n     * @param obj  the item to be added to the Comparator.\n     * @return true if obj has been added for the first time, false if\n     *  it was already known to the Comparator.\n     * @throws UnsupportedOperationException if a comparison has already been made\n     */\n    public boolean add(final T obj) {\n        checkLocked();\n        final Integer position = map.put(obj, Integer.valueOf(counter++));\n        return position == null;\n    }\n\n    /**\n     * Adds a new item, which compares as equal to the given existing item.\n     *\n     * @param existingObj  an item already in the Comparator's set of\n     *  known objects\n     * @param newObj  an item to be added to the Comparator's set of\n     *  known objects\n     * @return true if newObj has been added for the first time, false if\n     *  it was already known to the Comparator.\n     * @throws IllegalArgumentException if existingObject is not in the\n     *  Comparator's set of known objects.\n     * @throws UnsupportedOperationException if a comparison has already been made\n     */\n    public boolean addAsEqual(final T existingObj, final T newObj) {\n        checkLocked();\n        final Integer position = map.get(existingObj);\n        if (position == null) {\n            throw new IllegalArgumentException(existingObj + \" not known to \" + this);\n        }\n        final Integer result = map.put(newObj, position);\n        return result == null;\n    }\n\n    /**\n     * Checks to see whether the comparator is now locked against further changes.\n     *\n     * @throws UnsupportedOperationException if the comparator is locked\n     */\n    protected void checkLocked() {\n        if (isLocked()) {\n            throw new UnsupportedOperationException(\"Cannot modify a FixedOrderComparator after a comparison\");\n        }\n    }\n\n    // Comparator methods\n    /**\n     * Compares two objects according to the order of this Comparator.\n     * <p>\n     * It is important to note that this class will throw an IllegalArgumentException\n     * in the case of an unrecognized object. This is not specified in the\n     * Comparator interface, but is the most appropriate exception.\n     *\n     * @param obj1  the first object to compare\n     * @param obj2  the second object to compare\n     * @return negative if obj1 is less, positive if greater, zero if equal\n     * @throws IllegalArgumentException if obj1 or obj2 are not known\n     *  to this Comparator and an alternative behavior has not been set\n     *  via {@link #setUnknownObjectBehavior(UnknownObjectBehavior)}.\n     */\n    @Override\n    public int compare(final T obj1, final T obj2) {\n        isLocked = true;\n        final Integer position1 = map.get(obj1);\n        final Integer position2 = map.get(obj2);\n        if (position1 == null || position2 == null) {\n            switch (unknownObjectBehavior) {\n            case BEFORE:\n                return position1 == null ? position2 == null ? 0 : -1 : 1;\n            case AFTER:\n                return position1 == null ? position2 == null ? 0 : 1 : -1;\n            case EXCEPTION:\n                final Object unknownObj = position1 == null ? obj1 : obj2;\n                throw new IllegalArgumentException(\"Attempting to compare unknown object \"\n                        + unknownObj);\n            default: //could be null\n                throw new UnsupportedOperationException(\"Unknown unknownObjectBehavior: \"\n                        + unknownObjectBehavior);\n            }\n        }\n        return position1.compareTo(position2);\n    }\n\n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (getClass() != obj.getClass()) {\n            return false;\n        }\n        final FixedOrderComparator<?> other = (FixedOrderComparator<?>) obj;\n        return counter == other.counter && isLocked == other.isLocked && Objects.equals(map, other.map) && unknownObjectBehavior == other.unknownObjectBehavior;\n    }\n\n    /**\n     * Gets the behavior for comparing unknown objects.\n     *\n     * @return {@link UnknownObjectBehavior}\n     */\n    public UnknownObjectBehavior getUnknownObjectBehavior() {\n        return unknownObjectBehavior;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(counter, isLocked, map, unknownObjectBehavior);\n    }\n\n    // Bean methods / state querying methods\n    /**\n     * Returns true if modifications cannot be made to the FixedOrderComparator.\n     * FixedOrderComparators cannot be modified once they have performed a comparison.\n     *\n     * @return true if attempts to change the FixedOrderComparator yield an\n     *  UnsupportedOperationException, false if it can be changed.\n     */\n    public boolean isLocked() {\n        return isLocked;\n    }\n\n    /**\n     * Sets the behavior for comparing unknown objects.\n     *\n     * @param unknownObjectBehavior  the flag for unknown behavior -\n     * UNKNOWN_AFTER, UNKNOWN_BEFORE or UNKNOWN_THROW_EXCEPTION\n     * @throws UnsupportedOperationException if a comparison has been performed\n     * @throws NullPointerException if unknownObjectBehavior is null\n     */\n    public void setUnknownObjectBehavior(final UnknownObjectBehavior unknownObjectBehavior) {\n        checkLocked();\n        this.unknownObjectBehavior = Objects.requireNonNull(unknownObjectBehavior, \"unknownObjectBehavior\");\n    }\n\n}", "super_interfaces": ["Comparator<T>", "Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 82794675842863201L;", "docstring": " Serialization version from Collections 4.0.", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 82794675842863201L", "syntax_pass": true}, {"attribute_expression": "private final Map<T, Integer> map = new HashMap<>();", "docstring": " Internal map of object to position", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Map<T, Integer>", "name": "map = new HashMap<>()", "syntax_pass": true}, {"attribute_expression": "private int counter;", "docstring": " Counter used in determining the position in the map", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "counter", "syntax_pass": true}, {"attribute_expression": "private boolean isLocked;", "docstring": " Is the comparator locked against further change", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "isLocked", "syntax_pass": true}, {"attribute_expression": "private UnknownObjectBehavior unknownObjectBehavior = UnknownObjectBehavior.EXCEPTION;", "docstring": " The behavior in the case of an unknown object", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "UnknownObjectBehavior", "name": "unknownObjectBehavior = UnknownObjectBehavior.EXCEPTION", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/comparators/ComparatorChain.java.ComparatorChain", "name": "ComparatorChain", "file_path": "src/main/java/org/apache/commons/collections4/comparators/ComparatorChain.java", "superclasses": "", "methods": ["[]ComparatorChain()", "[]ComparatorChain(Comparator<E>)", "[]ComparatorChain(Comparator<E>,boolean)", "[]ComparatorChain(List<Comparator<E>>)", "[]ComparatorChain(List<Comparator<E>>,BitSet)", "[void]addComparator(Comparator<E>)", "[void]addComparator(Comparator<E>,boolean)", "[void]checkChainIntegrity()", "[void]checkLocked()", "[int]compare(E,E)", "[boolean]equals(Object)", "[int]hashCode()", "[boolean]isLocked()", "[void]setComparator(int,Comparator<E>)", "[void]setComparator(int,Comparator<E>,boolean)", "[void]setForwardSort(int)", "[void]setReverseSort(int)", "[int]size()"], "method_uris": ["src/main/java/org/apache/commons/collections4/comparators/ComparatorChain.java.ComparatorChain.[]ComparatorChain()", "src/main/java/org/apache/commons/collections4/comparators/ComparatorChain.java.ComparatorChain.[]ComparatorChain(Comparator<E>)", "src/main/java/org/apache/commons/collections4/comparators/ComparatorChain.java.ComparatorChain.[]ComparatorChain(Comparator<E>,boolean)", "src/main/java/org/apache/commons/collections4/comparators/ComparatorChain.java.ComparatorChain.[]ComparatorChain(List<Comparator<E>>)", "src/main/java/org/apache/commons/collections4/comparators/ComparatorChain.java.ComparatorChain.[]ComparatorChain(List<Comparator<E>>,BitSet)", "src/main/java/org/apache/commons/collections4/comparators/ComparatorChain.java.ComparatorChain.[void]addComparator(Comparator<E>)", "src/main/java/org/apache/commons/collections4/comparators/ComparatorChain.java.ComparatorChain.[void]addComparator(Comparator<E>,boolean)", "src/main/java/org/apache/commons/collections4/comparators/ComparatorChain.java.ComparatorChain.[void]checkChainIntegrity()", "src/main/java/org/apache/commons/collections4/comparators/ComparatorChain.java.ComparatorChain.[void]checkLocked()", "src/main/java/org/apache/commons/collections4/comparators/ComparatorChain.java.ComparatorChain.[int]compare(E,E)", "src/main/java/org/apache/commons/collections4/comparators/ComparatorChain.java.ComparatorChain.[boolean]equals(Object)", "src/main/java/org/apache/commons/collections4/comparators/ComparatorChain.java.ComparatorChain.[int]hashCode()", "src/main/java/org/apache/commons/collections4/comparators/ComparatorChain.java.ComparatorChain.[boolean]isLocked()", "src/main/java/org/apache/commons/collections4/comparators/ComparatorChain.java.ComparatorChain.[void]setComparator(int,Comparator<E>)", "src/main/java/org/apache/commons/collections4/comparators/ComparatorChain.java.ComparatorChain.[void]setComparator(int,Comparator<E>,boolean)", "src/main/java/org/apache/commons/collections4/comparators/ComparatorChain.java.ComparatorChain.[void]setForwardSort(int)", "src/main/java/org/apache/commons/collections4/comparators/ComparatorChain.java.ComparatorChain.[void]setReverseSort(int)", "src/main/java/org/apache/commons/collections4/comparators/ComparatorChain.java.ComparatorChain.[int]size()"], "overrides": null, "attributes": [], "class_docstring": "\nA ComparatorChain is a Comparator that wraps one or more Comparators in\nsequence. The ComparatorChain calls each Comparator in sequence until either\n1) any single Comparator returns a non-zero result (and that result is then\nreturned), or 2) the ComparatorChain is exhausted (and zero is returned).\nThis type of sorting is very similar to multi-column sorting in SQL, and this\nclass allows Java classes to emulate that kind of behavior when sorting a\nList.\n<p>\nTo further facilitate SQL-like sorting, the order of any single Comparator in\nthe list can be reversed.\n</p>\n<p>\nCalling a method that adds new Comparators or changes the ascend/descend sort\n<em>after compare(Object, Object) has been called</em> will result in an\nUnsupportedOperationException. However, <em>take care</em> to not alter the\nunderlying List of Comparators or the BitSet that defines the sort order.\n</p>\n<p>\nInstances of ComparatorChain are not synchronized. The class is not\nthread-safe at construction time, but it <em>is</em> thread-safe to perform\nmultiple comparisons after all the setup operations are complete.\n</p>\n\n@param <E> the type of objects compared by this comparator\n@since 2.0\n", "original_string": "public class ComparatorChain<E> implements Comparator<E>, Serializable {\n\n    /** Serialization version from Collections 2.0. */\n    private static final long serialVersionUID = -721644942746081630L;\n\n    /** The list of comparators in the chain. */\n    private final List<Comparator<E>> comparatorChain;\n    /** Order - false (clear) = ascend; true (set) = descend. */\n    private final BitSet orderingBits;\n   /** Whether the chain has been \"locked\". */\n    private boolean isLocked;\n\n    /**\n     * Constructs a ComparatorChain with no Comparators.\n     * You must add at least one Comparator before calling\n     * the compare(Object,Object) method, or an\n     * UnsupportedOperationException is thrown\n     */\n    public ComparatorChain() {\n        this(new ArrayList<>(), new BitSet());\n    }\n\n    /**\n     * Constructs a ComparatorChain with a single Comparator,\n     * sorting in the forward order\n     *\n     * @param comparator First comparator in the Comparator chain\n     */\n    public ComparatorChain(final Comparator<E> comparator) {\n        this(comparator, false);\n    }\n\n    /**\n     * Constructs a Comparator chain with a single Comparator,\n     * sorting in the given order\n     *\n     * @param comparator First Comparator in the ComparatorChain\n     * @param reverse    false = forward sort; true = reverse sort\n     */\n    public ComparatorChain(final Comparator<E> comparator, final boolean reverse) {\n        comparatorChain = new ArrayList<>(1);\n        comparatorChain.add(comparator);\n        orderingBits = new BitSet(1);\n        if (reverse) {\n            orderingBits.set(0);\n        }\n    }\n\n    /**\n     * Constructs a ComparatorChain from the Comparators in the\n     * List.  All Comparators will default to the forward\n     * sort order.\n     *\n     * @param list   List of Comparators\n     * @see #ComparatorChain(List,BitSet)\n     */\n    public ComparatorChain(final List<Comparator<E>> list) {\n        this(list, new BitSet(list.size()));\n    }\n\n    /**\n     * Constructs a ComparatorChain from the Comparators in the\n     * given List.  The sort order of each column will be\n     * drawn from the given BitSet.  When determining the sort\n     * order for Comparator at index <em>i</em> in the List,\n     * the ComparatorChain will call BitSet.get(<em>i</em>).\n     * If that method returns <em>false</em>, the forward\n     * sort order is used; a return value of <em>true</em>\n     * indicates reverse sort order.\n     *\n     * @param list   List of Comparators.  NOTE: This constructor does not perform a\n     *               defensive copy of the list\n     * @param bits   Sort order for each Comparator.  Extra bits are ignored,\n     *               unless extra Comparators are added by another method.\n     */\n    public ComparatorChain(final List<Comparator<E>> list, final BitSet bits) {\n        comparatorChain = list;\n        orderingBits = bits;\n    }\n\n    /**\n     * Add a Comparator to the end of the chain using the\n     * forward sort order\n     *\n     * @param comparator Comparator with the forward sort order\n     */\n    public void addComparator(final Comparator<E> comparator) {\n        addComparator(comparator, false);\n    }\n\n    /**\n     * Add a Comparator to the end of the chain using the\n     * given sort order\n     *\n     * @param comparator Comparator to add to the end of the chain\n     * @param reverse    false = forward sort order; true = reverse sort order\n     */\n    public void addComparator(final Comparator<E> comparator, final boolean reverse) {\n        checkLocked();\n\n        comparatorChain.add(comparator);\n        if (reverse) {\n            orderingBits.set(comparatorChain.size() - 1);\n        }\n    }\n\n    /**\n     * Throws an exception if the {@link ComparatorChain} is empty.\n     *\n     * @throws UnsupportedOperationException if the {@link ComparatorChain} is empty\n     */\n    private void checkChainIntegrity() {\n        if (comparatorChain.isEmpty()) {\n            throw new UnsupportedOperationException(\"ComparatorChains must contain at least one Comparator\");\n        }\n    }\n\n    /**\n     * Throws an exception if the {@link ComparatorChain} is locked.\n     *\n     * @throws UnsupportedOperationException if the {@link ComparatorChain} is locked\n     */\n    private void checkLocked() {\n        if (isLocked) {\n            throw new UnsupportedOperationException(\n                    \"Comparator ordering cannot be changed after the first comparison is performed\");\n        }\n    }\n\n    /**\n     * Perform comparisons on the Objects as per\n     * Comparator.compare(o1,o2).\n     *\n     * @param o1  the first object to compare\n     * @param o2  the second object to compare\n     * @return -1, 0, or 1\n     * @throws UnsupportedOperationException if the ComparatorChain does not contain at least one Comparator\n     */\n    @Override\n    public int compare(final E o1, final E o2) throws UnsupportedOperationException {\n        if (!isLocked) {\n            checkChainIntegrity();\n            isLocked = true;\n        }\n\n        // iterate over all comparators in the chain\n        final Iterator<Comparator<E>> comparators = comparatorChain.iterator();\n        for (int comparatorIndex = 0; comparators.hasNext(); ++comparatorIndex) {\n\n            final Comparator<? super E> comparator = comparators.next();\n            int retval = comparator.compare(o1, o2);\n            if (retval != 0) {\n                // invert the order if it is a reverse sort\n                if (orderingBits.get(comparatorIndex)) {\n                    if (retval > 0) {\n                        retval = -1;\n                    } else {\n                        retval = 1;\n                    }\n                }\n                return retval;\n            }\n        }\n\n        // if comparators are exhausted, return 0\n        return 0;\n    }\n\n    /**\n     * Returns {@code true} iff <em>that</em> Object is\n     * a {@link Comparator} whose ordering is known to be\n     * equivalent to mine.\n     * <p>\n     * This implementation returns {@code true}\n     * iff {@code <em>object</em>.{@link Object#getClass() getClass()}}\n     * equals {@code this.getClass()}, and the underlying\n     * comparators and order bits are equal.\n     * Subclasses may want to override this behavior to remain consistent\n     * with the {@link Comparator#equals(Object)} contract.\n     *\n     * @param object  the object to compare with\n     * @return true if equal\n     * @since 3.0\n     */\n    @Override\n    public boolean equals(final Object object) {\n        if (this == object) {\n            return true;\n        }\n        if (null == object) {\n            return false;\n        }\n        if (object.getClass().equals(this.getClass())) {\n            final ComparatorChain<?> chain = (ComparatorChain<?>) object;\n            return Objects.equals(orderingBits, chain.orderingBits) &&\n                   Objects.equals(comparatorChain, chain.comparatorChain);\n        }\n        return false;\n    }\n\n    /**\n     * Implement a hash code for this comparator that is consistent with\n     * {@link #equals(Object) equals}.\n     *\n     * @return a suitable hash code\n     * @since 3.0\n     */\n    @Override\n    public int hashCode() {\n        int hash = 0;\n        if (null != comparatorChain) {\n            hash ^= comparatorChain.hashCode();\n        }\n        if (null != orderingBits) {\n            hash ^= orderingBits.hashCode();\n        }\n        return hash;\n    }\n\n    /**\n     * Determine if modifications can still be made to the\n     * ComparatorChain.  ComparatorChains cannot be modified\n     * once they have performed a comparison.\n     *\n     * @return true = ComparatorChain cannot be modified; false =\n     *         ComparatorChain can still be modified.\n     */\n    public boolean isLocked() {\n        return isLocked;\n    }\n\n    /**\n     * Replace the Comparator at the given index, maintaining\n     * the existing sort order.\n     *\n     * @param index      index of the Comparator to replace\n     * @param comparator Comparator to place at the given index\n     * @throws IndexOutOfBoundsException\n     *                   if index &lt; 0 or index &gt;= size()\n     */\n    public void setComparator(final int index, final Comparator<E> comparator) throws IndexOutOfBoundsException {\n        setComparator(index, comparator, false);\n    }\n\n    /**\n     * Replace the Comparator at the given index in the\n     * ComparatorChain, using the given sort order\n     *\n     * @param index      index of the Comparator to replace\n     * @param comparator Comparator to set\n     * @param reverse    false = forward sort order; true = reverse sort order\n     */\n    public void setComparator(final int index, final Comparator<E> comparator, final boolean reverse) {\n        checkLocked();\n\n        comparatorChain.set(index, comparator);\n        if (reverse) {\n            orderingBits.set(index);\n        } else {\n            orderingBits.clear(index);\n        }\n    }\n\n    /**\n     * Change the sort order at the given index in the\n     * ComparatorChain to a forward sort.\n     *\n     * @param index  Index of the ComparatorChain\n     */\n    public void setForwardSort(final int index) {\n        checkLocked();\n        orderingBits.clear(index);\n    }\n\n    /**\n     * Change the sort order at the given index in the\n     * ComparatorChain to a reverse sort.\n     *\n     * @param index  Index of the ComparatorChain\n     */\n    public void setReverseSort(final int index) {\n        checkLocked();\n        orderingBits.set(index);\n    }\n\n    /**\n     * Number of Comparators in the current ComparatorChain.\n     *\n     * @return Comparator count\n     */\n    public int size() {\n        return comparatorChain.size();\n    }\n\n}", "super_interfaces": ["Comparator<E>", "Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = -721644942746081630L;", "docstring": " Serialization version from Collections 2.0.", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -721644942746081630L", "syntax_pass": true}, {"attribute_expression": "private final List<Comparator<E>> comparatorChain;", "docstring": " The list of comparators in the chain.", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<Comparator<E>>", "name": "comparatorChain", "syntax_pass": true}, {"attribute_expression": "private final BitSet orderingBits;", "docstring": " Order - false (clear) = ascend; true (set) = descend.", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "BitSet", "name": "orderingBits", "syntax_pass": true}, {"attribute_expression": "private boolean isLocked;", "docstring": " Whether the chain has been \"locked\".", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "isLocked", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/comparators/ReverseComparator.java.ReverseComparator", "name": "ReverseComparator", "file_path": "src/main/java/org/apache/commons/collections4/comparators/ReverseComparator.java", "superclasses": "", "methods": ["[]ReverseComparator()", "[]ReverseComparator(Comparator<? super E>)", "[int]compare(E,E)", "[boolean]equals(Object)", "[int]hashCode()"], "method_uris": ["src/main/java/org/apache/commons/collections4/comparators/ReverseComparator.java.ReverseComparator.[]ReverseComparator()", "src/main/java/org/apache/commons/collections4/comparators/ReverseComparator.java.ReverseComparator.[]ReverseComparator(Comparator<? super E>)", "src/main/java/org/apache/commons/collections4/comparators/ReverseComparator.java.ReverseComparator.[int]compare(E,E)", "src/main/java/org/apache/commons/collections4/comparators/ReverseComparator.java.ReverseComparator.[boolean]equals(Object)", "src/main/java/org/apache/commons/collections4/comparators/ReverseComparator.java.ReverseComparator.[int]hashCode()"], "overrides": null, "attributes": [], "class_docstring": "\nReverses the order of another comparator by reversing the arguments\nto its {@link #compare(Object, Object) compare} method.\n\n@param <E> the type of objects compared by this comparator\n\n@since 2.0\n@see java.util.Collections#reverseOrder()\n", "original_string": "public class ReverseComparator<E> implements Comparator<E>, Serializable {\n\n    /** Serialization version from Collections 2.0. */\n    private static final long serialVersionUID = 2858887242028539265L;\n\n    /** The comparator being decorated. */\n    private final Comparator<? super E> comparator;\n\n    /**\n     * Creates a comparator that compares objects based on the inverse of their\n     * natural ordering.  Using this Constructor will create a ReverseComparator\n     * that is functionally identical to the Comparator returned by\n     * java.util.Collections.<b>reverseOrder()</b>.\n     *\n     * @see java.util.Collections#reverseOrder()\n     */\n    public ReverseComparator() {\n        this(null);\n    }\n\n    /**\n     * Creates a comparator that inverts the comparison\n     * of the given comparator.  If you pass in {@code null},\n     * the ReverseComparator defaults to reversing the\n     * natural order, as per {@link java.util.Collections#reverseOrder()}.\n     *\n     * @param comparator Comparator to reverse\n     */\n    public ReverseComparator(final Comparator<? super E> comparator) {\n        this.comparator = comparator == null ? ComparatorUtils.NATURAL_COMPARATOR : comparator;\n    }\n\n    /**\n     * Compares two objects in reverse order.\n     *\n     * @param obj1  the first object to compare\n     * @param obj2  the second object to compare\n     * @return negative if obj1 is less, positive if greater, zero if equal\n     */\n    @Override\n    public int compare(final E obj1, final E obj2) {\n        return comparator.compare(obj2, obj1);\n    }\n\n    /**\n     * Returns {@code true} iff <em>that</em> Object is\n     * a {@link Comparator} whose ordering is known to be\n     * equivalent to mine.\n     * <p>\n     * This implementation returns {@code true}\n     * iff {@code <em>object</em>.{@link Object#getClass() getClass()}}\n     * equals {@code this.getClass()}, and the underlying\n     * comparators are equal.\n     * Subclasses may want to override this behavior to remain consistent\n     * with the {@link Comparator#equals(Object) equals} contract.\n     *\n     * @param object  the object to compare to\n     * @return true if equal\n     * @since 3.0\n     */\n    @Override\n    public boolean equals(final Object object) {\n        if (this == object) {\n            return true;\n        }\n        if (null == object) {\n            return false;\n        }\n        if (object.getClass().equals(this.getClass())) {\n            final ReverseComparator<?> thatrc = (ReverseComparator<?>) object;\n            return comparator.equals(thatrc.comparator);\n        }\n        return false;\n    }\n\n    /**\n     * Implement a hash code for this comparator that is consistent with\n     * {@link #equals(Object) equals}.\n     *\n     * @return a suitable hash code\n     * @since 3.0\n     */\n    @Override\n    public int hashCode() {\n        return \"ReverseComparator\".hashCode() ^ comparator.hashCode();\n    }\n\n}", "super_interfaces": ["Comparator<E>", "Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 2858887242028539265L;", "docstring": " Serialization version from Collections 2.0.", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 2858887242028539265L", "syntax_pass": true}, {"attribute_expression": "private final Comparator<? super E> comparator;", "docstring": " The comparator being decorated.", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Comparator<? super E>", "name": "comparator", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/trie/PatriciaTrie.java.PatriciaTrie", "name": "PatriciaTrie", "file_path": "src/main/java/org/apache/commons/collections4/trie/PatriciaTrie.java", "superclasses": "", "methods": ["[]PatriciaTrie()", "[]PatriciaTrie(Map<? extends String, ? extends V>)"], "method_uris": ["src/main/java/org/apache/commons/collections4/trie/PatriciaTrie.java.PatriciaTrie.[]PatriciaTrie()", "src/main/java/org/apache/commons/collections4/trie/PatriciaTrie.java.PatriciaTrie.[]PatriciaTrie(Map<? extends String, ? extends V>)"], "overrides": null, "attributes": [], "class_docstring": "\nImplements a PATRICIA Trie (Practical Algorithm to Retrieve Information\nCoded in Alphanumeric).\n<p>\nA PATRICIA {@link org.apache.commons.collections4.Trie} is a compressed\n{@link org.apache.commons.collections4.Trie}. Instead of storing\nall data at the edges of the {@link org.apache.commons.collections4.Trie}\n(and having empty internal nodes), PATRICIA stores data in every node.\nThis allows for very efficient traversal, insert, delete, predecessor,\nsuccessor, prefix, range, and {@link #select(Object)}\noperations. All operations are performed at worst in O(K) time, where K\nis the number of bits in the largest item in the tree. In practice,\noperations actually take O(A(K)) time, where A(K) is the average number of\nbits of all items in the tree.\n</p>\n<p>\nMost importantly, PATRICIA requires very few comparisons to keys while\ndoing any operation. While performing a lookup, each comparison (at most\nK of them, described above) will perform a single bit comparison against\nthe given key, instead of comparing the entire key to another key.\n</p>\n<p>\nThe {@link org.apache.commons.collections4.Trie} can return operations in\nlexicographical order using the 'prefixMap', 'submap', or 'iterator' methods.\nThe {@link org.apache.commons.collections4.Trie} can also\nscan for items that are 'bitwise' (using an XOR metric) by the 'select' method.\nBitwise closeness is determined by the {@link KeyAnalyzer} returning true or\nfalse for a bit being set or not in a given key.\n</p>\n<p>\nThis PATRICIA {@link org.apache.commons.collections4.Trie} supports both variable\nlength &amp; fixed length keys. Some methods, such as {@link org.apache.commons.collections4.Trie#prefixMap(Object)}\nare suited only to variable length keys.\n</p>\n\n@param <V> the type of the values in this map\n\n@see <a href=\"https://en.wikipedia.org/wiki/Radix_tree\">Radix Tree</a>\n@see <a href=\"https://users.monash.edu/~lloyd/tildeAlgDS/Tree/PATRICIA/\">PATRICIA</a>\n@see <a href=\"https://www.imperialviolet.org/binary/critbit.pdf\">Crit-Bit Tree</a>\n@since 4.0\n", "original_string": "public class PatriciaTrie<V> extends AbstractPatriciaTrie<String, V> {\n\n    private static final long serialVersionUID = 4446367780901817838L;\n\n    /**\n     * Constructs a new instance.\n     */\n    public PatriciaTrie() {\n        super(StringKeyAnalyzer.INSTANCE);\n    }\n\n    /**\n     * Constructs a new instance.\n     *\n     * @param map mappings to be stored in this map.\n     */\n    public PatriciaTrie(final Map<? extends String, ? extends V> map) {\n        super(StringKeyAnalyzer.INSTANCE, map);\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = 4446367780901817838L;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 4446367780901817838L", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/trie/UnmodifiableTrie.java.UnmodifiableTrie", "name": "UnmodifiableTrie", "file_path": "src/main/java/org/apache/commons/collections4/trie/UnmodifiableTrie.java", "superclasses": "", "methods": ["[Trie<K, V>]unmodifiableTrie(Trie<K, ? extends V>)", "[]UnmodifiableTrie(Trie<K, ? extends V>)", "[void]clear()", "[Comparator<? super K>]comparator()", "[boolean]containsKey(Object)", "[boolean]containsValue(Object)", "[Set<Entry<K, V>>]entrySet()", "[boolean]equals(Object)", "[K]firstKey()", "[V]get(Object)", "[int]hashCode()", "[SortedMap<K, V>]headMap(K)", "[boolean]isEmpty()", "[Set<K>]keySet()", "[K]lastKey()", "[OrderedMapIterator<K, V>]mapIterator()", "[K]nextKey(K)", "[SortedMap<K, V>]prefixMap(K)", "[K]previousKey(K)", "[V]put(K,V)", "[void]putAll(Map<? extends K, ? extends V>)", "[V]remove(Object)", "[int]size()", "[SortedMap<K, V>]subMap(K,K)", "[SortedMap<K, V>]tailMap(K)", "[String]toString()", "[Collection<V>]values()"], "method_uris": ["src/main/java/org/apache/commons/collections4/trie/UnmodifiableTrie.java.UnmodifiableTrie.[Trie<K, V>]unmodifiableTrie(Trie<K, ? extends V>)", "src/main/java/org/apache/commons/collections4/trie/UnmodifiableTrie.java.UnmodifiableTrie.[]UnmodifiableTrie(Trie<K, ? extends V>)", "src/main/java/org/apache/commons/collections4/trie/UnmodifiableTrie.java.UnmodifiableTrie.[void]clear()", "src/main/java/org/apache/commons/collections4/trie/UnmodifiableTrie.java.UnmodifiableTrie.[Comparator<? super K>]comparator()", "src/main/java/org/apache/commons/collections4/trie/UnmodifiableTrie.java.UnmodifiableTrie.[boolean]containsKey(Object)", "src/main/java/org/apache/commons/collections4/trie/UnmodifiableTrie.java.UnmodifiableTrie.[boolean]containsValue(Object)", "src/main/java/org/apache/commons/collections4/trie/UnmodifiableTrie.java.UnmodifiableTrie.[Set<Entry<K, V>>]entrySet()", "src/main/java/org/apache/commons/collections4/trie/UnmodifiableTrie.java.UnmodifiableTrie.[boolean]equals(Object)", "src/main/java/org/apache/commons/collections4/trie/UnmodifiableTrie.java.UnmodifiableTrie.[K]firstKey()", "src/main/java/org/apache/commons/collections4/trie/UnmodifiableTrie.java.UnmodifiableTrie.[V]get(Object)", "src/main/java/org/apache/commons/collections4/trie/UnmodifiableTrie.java.UnmodifiableTrie.[int]hashCode()", "src/main/java/org/apache/commons/collections4/trie/UnmodifiableTrie.java.UnmodifiableTrie.[SortedMap<K, V>]headMap(K)", "src/main/java/org/apache/commons/collections4/trie/UnmodifiableTrie.java.UnmodifiableTrie.[boolean]isEmpty()", "src/main/java/org/apache/commons/collections4/trie/UnmodifiableTrie.java.UnmodifiableTrie.[Set<K>]keySet()", "src/main/java/org/apache/commons/collections4/trie/UnmodifiableTrie.java.UnmodifiableTrie.[K]lastKey()", "src/main/java/org/apache/commons/collections4/trie/UnmodifiableTrie.java.UnmodifiableTrie.[OrderedMapIterator<K, V>]mapIterator()", "src/main/java/org/apache/commons/collections4/trie/UnmodifiableTrie.java.UnmodifiableTrie.[K]nextKey(K)", "src/main/java/org/apache/commons/collections4/trie/UnmodifiableTrie.java.UnmodifiableTrie.[SortedMap<K, V>]prefixMap(K)", "src/main/java/org/apache/commons/collections4/trie/UnmodifiableTrie.java.UnmodifiableTrie.[K]previousKey(K)", "src/main/java/org/apache/commons/collections4/trie/UnmodifiableTrie.java.UnmodifiableTrie.[V]put(K,V)", "src/main/java/org/apache/commons/collections4/trie/UnmodifiableTrie.java.UnmodifiableTrie.[void]putAll(Map<? extends K, ? extends V>)", "src/main/java/org/apache/commons/collections4/trie/UnmodifiableTrie.java.UnmodifiableTrie.[V]remove(Object)", "src/main/java/org/apache/commons/collections4/trie/UnmodifiableTrie.java.UnmodifiableTrie.[int]size()", "src/main/java/org/apache/commons/collections4/trie/UnmodifiableTrie.java.UnmodifiableTrie.[SortedMap<K, V>]subMap(K,K)", "src/main/java/org/apache/commons/collections4/trie/UnmodifiableTrie.java.UnmodifiableTrie.[SortedMap<K, V>]tailMap(K)", "src/main/java/org/apache/commons/collections4/trie/UnmodifiableTrie.java.UnmodifiableTrie.[String]toString()", "src/main/java/org/apache/commons/collections4/trie/UnmodifiableTrie.java.UnmodifiableTrie.[Collection<V>]values()"], "overrides": null, "attributes": [], "class_docstring": "\nAn unmodifiable {@link Trie}.\n\n@param <K> the type of the keys in this map\n@param <V> the type of the values in this map\n@since 4.0\n", "original_string": "public class UnmodifiableTrie<K, V> implements Trie<K, V>, Serializable, Unmodifiable {\n\n    /** Serialization version */\n    private static final long serialVersionUID = -7156426030315945159L;\n\n    /**\n     * Factory method to create an unmodifiable trie.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param trie  the trie to decorate, must not be null\n     * @return a new unmodifiable trie\n     * @throws NullPointerException if trie is null\n     */\n    public static <K, V> Trie<K, V> unmodifiableTrie(final Trie<K, ? extends V> trie) {\n        if (trie instanceof Unmodifiable) {\n            @SuppressWarnings(\"unchecked\") // safe to upcast\n            final Trie<K, V> tmpTrie = (Trie<K, V>) trie;\n            return tmpTrie;\n        }\n        return new UnmodifiableTrie<>(trie);\n    }\n\n    /**\n     * The delegate Trie.\n     */\n    private final Trie<K, V> delegate;\n\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param trie  the trie to decorate, must not be null\n     * @throws NullPointerException if trie is null\n     */\n    public UnmodifiableTrie(final Trie<K, ? extends V> trie) {\n        @SuppressWarnings(\"unchecked\") // safe to upcast\n        final Trie<K, V> tmpTrie = (Trie<K, V>) Objects.requireNonNull(trie, \"trie\");\n        this.delegate = tmpTrie;\n    }\n\n    @Override\n    public void clear() {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public Comparator<? super K> comparator() {\n        return delegate.comparator();\n    }\n\n    @Override\n    public boolean containsKey(final Object key) {\n        return delegate.containsKey(key);\n    }\n\n    @Override\n    public boolean containsValue(final Object value) {\n        return delegate.containsValue(value);\n    }\n\n    @Override\n    public Set<Entry<K, V>> entrySet() {\n        return Collections.unmodifiableSet(delegate.entrySet());\n    }\n\n    @Override\n    public boolean equals(final Object obj) {\n        return delegate.equals(obj);\n    }\n\n    @Override\n    public K firstKey() {\n        return delegate.firstKey();\n    }\n\n    @Override\n    public V get(final Object key) {\n        return delegate.get(key);\n    }\n\n    @Override\n    public int hashCode() {\n        return delegate.hashCode();\n    }\n\n    @Override\n    public SortedMap<K, V> headMap(final K toKey) {\n        return Collections.unmodifiableSortedMap(delegate.headMap(toKey));\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return delegate.isEmpty();\n    }\n\n    @Override\n    public Set<K> keySet() {\n        return Collections.unmodifiableSet(delegate.keySet());\n    }\n\n    @Override\n    public K lastKey() {\n        return delegate.lastKey();\n    }\n\n    @Override\n    public OrderedMapIterator<K, V> mapIterator() {\n        final OrderedMapIterator<K, V> it = delegate.mapIterator();\n        return UnmodifiableOrderedMapIterator.unmodifiableOrderedMapIterator(it);\n    }\n\n    @Override\n    public K nextKey(final K key) {\n        return delegate.nextKey(key);\n    }\n\n    @Override\n    public SortedMap<K, V> prefixMap(final K key) {\n        return Collections.unmodifiableSortedMap(delegate.prefixMap(key));\n    }\n\n    @Override\n    public K previousKey(final K key) {\n        return delegate.previousKey(key);\n    }\n\n    @Override\n    public V put(final K key, final V value) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public void putAll(final Map<? extends K, ? extends V> m) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public V remove(final Object key) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public int size() {\n        return delegate.size();\n    }\n\n    @Override\n    public SortedMap<K, V> subMap(final K fromKey, final K toKey) {\n        return Collections.unmodifiableSortedMap(delegate.subMap(fromKey, toKey));\n    }\n\n    @Override\n    public SortedMap<K, V> tailMap(final K fromKey) {\n        return Collections.unmodifiableSortedMap(delegate.tailMap(fromKey));\n    }\n\n    @Override\n    public String toString() {\n        return delegate.toString();\n    }\n\n    @Override\n    public Collection<V> values() {\n        return Collections.unmodifiableCollection(delegate.values());\n    }\n\n}", "super_interfaces": ["Trie<K, V>", "Serializable", "Unmodifiable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = -7156426030315945159L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -7156426030315945159L", "syntax_pass": true}, {"attribute_expression": "private final Trie<K, V> delegate;", "docstring": "\nThe delegate Trie.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Trie<K, V>", "name": "delegate", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/trie/analyzer/StringKeyAnalyzer.java.StringKeyAnalyzer", "name": "StringKeyAnalyzer", "file_path": "src/main/java/org/apache/commons/collections4/trie/analyzer/StringKeyAnalyzer.java", "superclasses": "", "methods": ["[int]mask(int)", "[]StringKeyAnalyzer()", "[int]bitIndex(String,int,int,String,int,int)", "[int]bitsPerElement()", "[boolean]isBitSet(String,int,int)", "[boolean]isPrefix(String,int,int,String)", "[int]lengthInBits(String)"], "method_uris": ["src/main/java/org/apache/commons/collections4/trie/analyzer/StringKeyAnalyzer.java.StringKeyAnalyzer.[int]mask(int)", "src/main/java/org/apache/commons/collections4/trie/analyzer/StringKeyAnalyzer.java.StringKeyAnalyzer.[]StringKeyAnalyzer()", "src/main/java/org/apache/commons/collections4/trie/analyzer/StringKeyAnalyzer.java.StringKeyAnalyzer.[int]bitIndex(String,int,int,String,int,int)", "src/main/java/org/apache/commons/collections4/trie/analyzer/StringKeyAnalyzer.java.StringKeyAnalyzer.[int]bitsPerElement()", "src/main/java/org/apache/commons/collections4/trie/analyzer/StringKeyAnalyzer.java.StringKeyAnalyzer.[boolean]isBitSet(String,int,int)", "src/main/java/org/apache/commons/collections4/trie/analyzer/StringKeyAnalyzer.java.StringKeyAnalyzer.[boolean]isPrefix(String,int,int,String)", "src/main/java/org/apache/commons/collections4/trie/analyzer/StringKeyAnalyzer.java.StringKeyAnalyzer.[int]lengthInBits(String)"], "overrides": null, "attributes": [], "class_docstring": "\nAn {@link KeyAnalyzer} for {@link String}s.\n<p>\nThis class is stateless.\n</p>\n@since 4.0\n", "original_string": "public class StringKeyAnalyzer extends KeyAnalyzer<String> {\n\n    private static final long serialVersionUID = -7032449491269434877L;\n\n    /** A singleton instance of {@link StringKeyAnalyzer}. */\n    public static final StringKeyAnalyzer INSTANCE = new StringKeyAnalyzer();\n\n    /** The number of bits per {@link Character}. */\n    public static final int LENGTH = Character.SIZE;\n\n    /** A bit mask where the first bit is 1 and the others are zero. */\n    private static final int MSB = 0x8000;\n\n    /** Returns a bit mask where the given bit is set. */\n    private static int mask(final int bit) {\n        return MSB >>> bit;\n    }\n\n    /**\n     * Constructs a new instance.\n     *\n     * @deprecated Use {@link #INSTANCE}.\n     */\n    @Deprecated\n    public StringKeyAnalyzer() {\n        // empty\n    }\n\n    @Override\n    public int bitIndex(final String key, final int offsetInBits, final int lengthInBits,\n                        final String other, final int otherOffsetInBits, final int otherLengthInBits) {\n\n        boolean allNull = true;\n\n        if (offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0\n                || lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0) {\n            throw new IllegalArgumentException(\"The offsets and lengths must be at Character boundaries\");\n        }\n\n        final int beginIndex1 = offsetInBits / LENGTH;\n        final int beginIndex2 = otherOffsetInBits / LENGTH;\n\n        final int endIndex1 = beginIndex1 + lengthInBits / LENGTH;\n        final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH;\n\n        final int length = Math.max(endIndex1, endIndex2);\n\n        // Look at each character, and if they're different\n        // then figure out which bit makes the difference\n        // and return it.\n        char k = 0, f = 0;\n        for (int i = 0; i < length; i++) {\n            final int index1 = beginIndex1 + i;\n            final int index2 = beginIndex2 + i;\n\n            if (index1 >= endIndex1) {\n                k = 0;\n            } else {\n                k = key.charAt(index1);\n            }\n\n            if (other == null || index2 >= endIndex2) {\n                f = 0;\n            } else {\n                f = other.charAt(index2);\n            }\n\n            if (k != f) {\n                final int x = k ^ f;\n                return i * LENGTH + Integer.numberOfLeadingZeros(x) - LENGTH;\n            }\n\n            if (k != 0) {\n                allNull = false;\n            }\n        }\n\n        // All bits are 0\n        if (allNull) {\n            return NULL_BIT_KEY;\n        }\n\n        // Both keys are equal\n        return EQUAL_BIT_KEY;\n    }\n\n    @Override\n    public int bitsPerElement() {\n        return LENGTH;\n    }\n\n    @Override\n    public boolean isBitSet(final String key, final int bitIndex, final int lengthInBits) {\n        if (key == null || bitIndex >= lengthInBits) {\n            return false;\n        }\n\n        final int index = bitIndex / LENGTH;\n        final int bit = bitIndex % LENGTH;\n\n        return (key.charAt(index) & mask(bit)) != 0;\n    }\n\n    @Override\n    public boolean isPrefix(final String prefix, final int offsetInBits,\n                            final int lengthInBits, final String key) {\n        if (offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0) {\n            throw new IllegalArgumentException(\n                    \"Cannot determine prefix outside of Character boundaries\");\n        }\n\n        final String s1 = prefix.substring(offsetInBits / LENGTH, lengthInBits / LENGTH);\n        return key.startsWith(s1);\n    }\n\n    @Override\n    public int lengthInBits(final String key) {\n        return key != null ? key.length() * LENGTH : 0;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = -7032449491269434877L;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -7032449491269434877L", "syntax_pass": true}, {"attribute_expression": "public static final StringKeyAnalyzer INSTANCE = new StringKeyAnalyzer();", "docstring": " A singleton instance of {@link StringKeyAnalyzer}.", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "StringKeyAnalyzer", "name": "INSTANCE = new StringKeyAnalyzer()", "syntax_pass": true}, {"attribute_expression": "public static final int LENGTH = Character.SIZE;", "docstring": " The number of bits per {@link Character}.", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "int", "name": "LENGTH = Character.SIZE", "syntax_pass": true}, {"attribute_expression": "private static final int MSB = 0x8000;", "docstring": " A bit mask where the first bit is 1 and the others are zero.", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "int", "name": "MSB = 0x8000", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/splitmap/AbstractIterableGetMapDecorator.java.AbstractIterableGetMapDecorator", "name": "AbstractIterableGetMapDecorator", "file_path": "src/main/java/org/apache/commons/collections4/splitmap/AbstractIterableGetMapDecorator.java", "superclasses": "", "methods": ["[]AbstractIterableGetMapDecorator()", "[]AbstractIterableGetMapDecorator(Map<K, V>)", "[boolean]containsKey(Object)", "[boolean]containsValue(Object)", "[Map<K, V>]decorated()", "[Set<Map.Entry<K, V>>]entrySet()", "[boolean]equals(Object)", "[V]get(Object)", "[int]hashCode()", "[boolean]isEmpty()", "[Set<K>]keySet()", "[MapIterator<K, V>]mapIterator()", "[V]remove(Object)", "[int]size()", "[String]toString()", "[Collection<V>]values()"], "method_uris": ["src/main/java/org/apache/commons/collections4/splitmap/AbstractIterableGetMapDecorator.java.AbstractIterableGetMapDecorator.[]AbstractIterableGetMapDecorator()", "src/main/java/org/apache/commons/collections4/splitmap/AbstractIterableGetMapDecorator.java.AbstractIterableGetMapDecorator.[]AbstractIterableGetMapDecorator(Map<K, V>)", "src/main/java/org/apache/commons/collections4/splitmap/AbstractIterableGetMapDecorator.java.AbstractIterableGetMapDecorator.[boolean]containsKey(Object)", "src/main/java/org/apache/commons/collections4/splitmap/AbstractIterableGetMapDecorator.java.AbstractIterableGetMapDecorator.[boolean]containsValue(Object)", "src/main/java/org/apache/commons/collections4/splitmap/AbstractIterableGetMapDecorator.java.AbstractIterableGetMapDecorator.[Map<K, V>]decorated()", "src/main/java/org/apache/commons/collections4/splitmap/AbstractIterableGetMapDecorator.java.AbstractIterableGetMapDecorator.[Set<Map.Entry<K, V>>]entrySet()", "src/main/java/org/apache/commons/collections4/splitmap/AbstractIterableGetMapDecorator.java.AbstractIterableGetMapDecorator.[boolean]equals(Object)", "src/main/java/org/apache/commons/collections4/splitmap/AbstractIterableGetMapDecorator.java.AbstractIterableGetMapDecorator.[V]get(Object)", "src/main/java/org/apache/commons/collections4/splitmap/AbstractIterableGetMapDecorator.java.AbstractIterableGetMapDecorator.[int]hashCode()", "src/main/java/org/apache/commons/collections4/splitmap/AbstractIterableGetMapDecorator.java.AbstractIterableGetMapDecorator.[boolean]isEmpty()", "src/main/java/org/apache/commons/collections4/splitmap/AbstractIterableGetMapDecorator.java.AbstractIterableGetMapDecorator.[Set<K>]keySet()", "src/main/java/org/apache/commons/collections4/splitmap/AbstractIterableGetMapDecorator.java.AbstractIterableGetMapDecorator.[MapIterator<K, V>]mapIterator()", "src/main/java/org/apache/commons/collections4/splitmap/AbstractIterableGetMapDecorator.java.AbstractIterableGetMapDecorator.[V]remove(Object)", "src/main/java/org/apache/commons/collections4/splitmap/AbstractIterableGetMapDecorator.java.AbstractIterableGetMapDecorator.[int]size()", "src/main/java/org/apache/commons/collections4/splitmap/AbstractIterableGetMapDecorator.java.AbstractIterableGetMapDecorator.[String]toString()", "src/main/java/org/apache/commons/collections4/splitmap/AbstractIterableGetMapDecorator.java.AbstractIterableGetMapDecorator.[Collection<V>]values()"], "overrides": null, "attributes": [], "class_docstring": "\n{@link IterableGet} that uses a {@link Map}&lt;K, V&gt; for the\n{@link org.apache.commons.collections4.Get Get}&lt;K, V&gt; implementation.\n\n@param <K> the type of the keys in this map\n@param <V> the type of the values in this map\n@since 4.0\n", "original_string": "public class AbstractIterableGetMapDecorator<K, V> implements IterableGet<K, V> {\n\n    /** The map to decorate */\n    transient Map<K, V> map;\n\n    /**\n     * Constructor only used in deserialization, do not use otherwise.\n     */\n    protected AbstractIterableGetMapDecorator() {\n    }\n\n    /**\n     * Create a new AbstractSplitMapDecorator.\n     * @param map the map to decorate, must not be null\n     * @throws NullPointerException if map is null\n     */\n    public AbstractIterableGetMapDecorator(final Map<K, V> map) {\n        this.map = Objects.requireNonNull(map, \"map\");\n    }\n\n    @Override\n    public boolean containsKey(final Object key) {\n        return decorated().containsKey(key);\n    }\n\n    @Override\n    public boolean containsValue(final Object value) {\n        return decorated().containsValue(value);\n    }\n\n    /**\n     * Gets the map being decorated.\n     *\n     * @return the decorated map\n     */\n    protected Map<K, V> decorated() {\n        return map;\n    }\n\n    @Override\n    public Set<Map.Entry<K, V>> entrySet() {\n        return decorated().entrySet();\n    }\n\n    @Override\n    public boolean equals(final Object object) {\n        if (object == this) {\n            return true;\n        }\n        return decorated().equals(object);\n    }\n\n    @Override\n    public V get(final Object key) {\n        return decorated().get(key);\n    }\n\n    @Override\n    public int hashCode() {\n        return decorated().hashCode();\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return decorated().isEmpty();\n    }\n\n    @Override\n    public Set<K> keySet() {\n        return decorated().keySet();\n    }\n\n    /**\n     * Gets a MapIterator over this Get.\n     * @return MapIterator&lt;K, V&gt;\n     */\n    @Override\n    public MapIterator<K, V> mapIterator() {\n        return new EntrySetToMapIteratorAdapter<>(entrySet());\n    }\n\n    @Override\n    public V remove(final Object key) {\n        return decorated().remove(key);\n    }\n\n    @Override\n    public int size() {\n        return decorated().size();\n    }\n\n    @Override\n    public String toString() {\n        return decorated().toString();\n    }\n\n    @Override\n    public Collection<V> values() {\n        return decorated().values();\n    }\n\n}", "super_interfaces": ["IterableGet<K, V>"], "fields": [{"attribute_expression": "transient Map<K, V> map;", "docstring": " The map to decorate", "modifiers": "transient", "marker_annotations": [], "non_marker_annotations": ["transient"], "comments": [], "type": "Map<K, V>", "name": "map", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/splitmap/TransformedSplitMap.java.TransformedSplitMap", "name": "TransformedSplitMap", "file_path": "src/main/java/org/apache/commons/collections4/splitmap/TransformedSplitMap.java", "superclasses": "", "methods": ["[TransformedSplitMap<J, K, U, V>]transformingMap(Map<K, V>,Transformer<? super J, ? extends K>,Transformer<? super U, ? extends V>)", "[]TransformedSplitMap(Map<K, V>,Transformer<? super J, ? extends K>,Transformer<? super U, ? extends V>)", "[V]checkSetValue(U)", "[void]clear()", "[V]put(J,U)", "[void]putAll(Map<? extends J, ? extends U>)", "[void]readObject(ObjectInputStream)", "[K]transformKey(J)", "[Map<K, V>]transformMap(Map<? extends J, ? extends U>)", "[V]transformValue(U)", "[void]writeObject(ObjectOutputStream)"], "method_uris": ["src/main/java/org/apache/commons/collections4/splitmap/TransformedSplitMap.java.TransformedSplitMap.[TransformedSplitMap<J, K, U, V>]transformingMap(Map<K, V>,Transformer<? super J, ? extends K>,Transformer<? super U, ? extends V>)", "src/main/java/org/apache/commons/collections4/splitmap/TransformedSplitMap.java.TransformedSplitMap.[]TransformedSplitMap(Map<K, V>,Transformer<? super J, ? extends K>,Transformer<? super U, ? extends V>)", "src/main/java/org/apache/commons/collections4/splitmap/TransformedSplitMap.java.TransformedSplitMap.[V]checkSetValue(U)", "src/main/java/org/apache/commons/collections4/splitmap/TransformedSplitMap.java.TransformedSplitMap.[void]clear()", "src/main/java/org/apache/commons/collections4/splitmap/TransformedSplitMap.java.TransformedSplitMap.[V]put(J,U)", "src/main/java/org/apache/commons/collections4/splitmap/TransformedSplitMap.java.TransformedSplitMap.[void]putAll(Map<? extends J, ? extends U>)", "src/main/java/org/apache/commons/collections4/splitmap/TransformedSplitMap.java.TransformedSplitMap.[void]readObject(ObjectInputStream)", "src/main/java/org/apache/commons/collections4/splitmap/TransformedSplitMap.java.TransformedSplitMap.[K]transformKey(J)", "src/main/java/org/apache/commons/collections4/splitmap/TransformedSplitMap.java.TransformedSplitMap.[Map<K, V>]transformMap(Map<? extends J, ? extends U>)", "src/main/java/org/apache/commons/collections4/splitmap/TransformedSplitMap.java.TransformedSplitMap.[V]transformValue(U)", "src/main/java/org/apache/commons/collections4/splitmap/TransformedSplitMap.java.TransformedSplitMap.[void]writeObject(ObjectOutputStream)"], "overrides": null, "attributes": [], "class_docstring": "\nDecorates another {@link Map} to transform objects that are added.\n<p>\nThe Map put methods and Map.Entry setValue method are affected by this class.\nThus objects must be removed or searched for using their transformed form.\nFor example, if the transformation converts Strings to Integers, you must use\nthe Integer form to remove objects.\n</p>\n<p>\n<strong>Note that TransformedMap is not synchronized and is not\nthread-safe.</strong> If you wish to use this map from multiple threads\nconcurrently, you must use appropriate synchronization. The simplest approach\nis to wrap this map using {@link java.util.Collections#synchronizedMap(Map)}.\nThis class may throw exceptions when accessed by concurrent threads without\nsynchronization.\n</p>\n<p>\nThe \"put\" and \"get\" type constraints of this class are mutually independent;\ncontrast with {@link org.apache.commons.collections4.map.TransformedMap} which,\nby virtue of its implementing {@link Map}&lt;K, V&gt;, must be constructed in such\na way that its read and write parameters are generalized to a common (super-)type.\nIn practice this would often mean {@code &gt;Object, Object&gt;}, defeating\nmuch of the usefulness of having parameterized types.\n</p>\n<p>\nOn the downside, this class is not drop-in compatible with {@link java.util.Map}\nbut is intended to be worked with either directly or by {@link Put} and\n{@link org.apache.commons.collections4.Get Get} generalizations.\n</p>\n\n@param <J> the type of the keys to put in this map\n@param <K> the type of the keys to get in this map\n@param <U> the type of the values to put in this map\n@param <V> the type of the values to get in this map\n@since 4.0\n\n@see org.apache.commons.collections4.SplitMapUtils#readableMap(org.apache.commons.collections4.Get)\n@see org.apache.commons.collections4.SplitMapUtils#writableMap(Put)\n", "original_string": "public class TransformedSplitMap<J, K, U, V> extends AbstractIterableGetMapDecorator<K, V>\n        implements Put<J, U>, Serializable {\n\n    /** Serialization version */\n    private static final long serialVersionUID = 5966875321133456994L;\n\n    /**\n     * Factory method to create a transforming map.\n     * <p>\n     * If there are any elements already in the map being decorated, they are\n     * NOT transformed.\n     *\n     * @param <J>  the input key type\n     * @param <K>  the output key type\n     * @param <U>  the input value type\n     * @param <V>  the output value type\n     * @param map the map to decorate, must not be null\n     * @param keyTransformer the transformer to use for key conversion, must not be null\n     * @param valueTransformer the transformer to use for value conversion, must not be null\n     * @return a new transformed map\n     * @throws NullPointerException if map or either of the transformers is null\n     */\n    public static <J, K, U, V> TransformedSplitMap<J, K, U, V> transformingMap(final Map<K, V> map,\n            final Transformer<? super J, ? extends K> keyTransformer,\n            final Transformer<? super U, ? extends V> valueTransformer) {\n        return new TransformedSplitMap<>(map, keyTransformer, valueTransformer);\n    }\n    /** The transformer to use for the key */\n    private final Transformer<? super J, ? extends K> keyTransformer;\n\n    /** The transformer to use for the value */\n    private final Transformer<? super U, ? extends V> valueTransformer;\n\n    /**\n     * Constructor that wraps (not copies).\n     * <p>\n     * If there are any elements already in the collection being decorated, they\n     * are NOT transformed.\n     *\n     * @param map the map to decorate, must not be null\n     * @param keyTransformer the transformer to use for key conversion, must not be null\n     * @param valueTransformer the transformer to use for value conversion, must not be null\n     * @throws NullPointerException if map or either of the transformers is null\n     */\n    protected TransformedSplitMap(final Map<K, V> map, final Transformer<? super J, ? extends K> keyTransformer,\n            final Transformer<? super U, ? extends V> valueTransformer) {\n        super(map);\n        this.keyTransformer = Objects.requireNonNull(keyTransformer, \"keyTransformer\");\n        this.valueTransformer = Objects.requireNonNull(valueTransformer, \"valueTransformer\");\n    }\n\n    /**\n     * Override to transform the value when using {@code setValue}.\n     *\n     * @param value the value to transform\n     * @return the transformed value\n     */\n    protected V checkSetValue(final U value) {\n        return valueTransformer.apply(value);\n    }\n\n    @Override\n    public void clear() {\n        decorated().clear();\n    }\n\n    @Override\n    public V put(final J key, final U value) {\n        return decorated().put(transformKey(key), transformValue(value));\n    }\n\n    @Override\n    public void putAll(final Map<? extends J, ? extends U> mapToCopy) {\n        decorated().putAll(transformMap(mapToCopy));\n    }\n\n    /**\n     * Deserializes the map in using a custom routine.\n     *\n     * @param in the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded\n     * @since 3.1\n     */\n    @SuppressWarnings(\"unchecked\") // (1) should only fail if input stream is incorrect\n    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        map = (Map<K, V>) in.readObject(); // (1)\n    }\n\n    /**\n     * Transforms a key.\n     * <p>\n     * The transformer itself may throw an exception if necessary.\n     *\n     * @param object the object to transform\n     * @return the transformed object\n     */\n    protected K transformKey(final J object) {\n        return keyTransformer.apply(object);\n    }\n\n    /**\n     * Transforms a map.\n     * <p>\n     * The transformer itself may throw an exception if necessary.\n     *\n     * @param map the map to transform\n     * @return the transformed object\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends J, ? extends U> map) {\n        if (map.isEmpty()) {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<>(map.size());\n\n        for (final Map.Entry<? extends J, ? extends U> entry : map.entrySet()) {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }\n\n    /**\n     * Transforms a value.\n     * <p>\n     * The transformer itself may throw an exception if necessary.\n     *\n     * @param object the object to transform\n     * @return the transformed object\n     */\n    protected V transformValue(final U object) {\n        return valueTransformer.apply(object);\n    }\n\n    /**\n     * Serializes this object to an ObjectOutputStream.\n     *\n     * @param out the target ObjectOutputStream.\n     * @throws IOException thrown when an I/O errors occur writing to the target stream.\n     */\n    private void writeObject(final ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        out.writeObject(decorated());\n    }\n}", "super_interfaces": ["Put<J, U>", "Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 5966875321133456994L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 5966875321133456994L", "syntax_pass": true}, {"attribute_expression": "private final Transformer<? super J, ? extends K> keyTransformer;", "docstring": " The transformer to use for the key", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Transformer<? super J, ? extends K>", "name": "keyTransformer", "syntax_pass": true}, {"attribute_expression": "private final Transformer<? super U, ? extends V> valueTransformer;", "docstring": " The transformer to use for the value", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Transformer<? super U, ? extends V>", "name": "valueTransformer", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/iterators/LoopingIterator.java.LoopingIterator", "name": "LoopingIterator", "file_path": "src/main/java/org/apache/commons/collections4/iterators/LoopingIterator.java", "superclasses": "", "methods": ["[]LoopingIterator(Collection<? extends E>)", "[boolean]hasNext()", "[E]next()", "[void]remove()", "[void]reset()", "[int]size()"], "method_uris": ["src/main/java/org/apache/commons/collections4/iterators/LoopingIterator.java.LoopingIterator.[]LoopingIterator(Collection<? extends E>)", "src/main/java/org/apache/commons/collections4/iterators/LoopingIterator.java.LoopingIterator.[boolean]hasNext()", "src/main/java/org/apache/commons/collections4/iterators/LoopingIterator.java.LoopingIterator.[E]next()", "src/main/java/org/apache/commons/collections4/iterators/LoopingIterator.java.LoopingIterator.[void]remove()", "src/main/java/org/apache/commons/collections4/iterators/LoopingIterator.java.LoopingIterator.[void]reset()", "src/main/java/org/apache/commons/collections4/iterators/LoopingIterator.java.LoopingIterator.[int]size()"], "overrides": null, "attributes": [], "class_docstring": "\nAn Iterator that restarts when it reaches the end.\n<p>\nThe iterator will loop continuously around the provided elements, unless\nthere are no elements in the collection to begin with, or all the elements\nhave been {@link #remove removed}.\n<p>\nConcurrent modifications are not directly supported, and for most collection\nimplementations will throw a ConcurrentModificationException.\n\n@param <E> the type of elements returned by this iterator.\n@since 3.0\n", "original_string": "public class LoopingIterator<E> implements ResettableIterator<E> {\n\n    /** The collection to base the iterator on */\n    private final Collection<? extends E> collection;\n    /** The current iterator */\n    private Iterator<? extends E> iterator;\n\n    /**\n     * Constructor that wraps a collection.\n     * <p>\n     * There is no way to reset an Iterator instance without recreating it from\n     * the original source, so the Collection must be passed in.\n     *\n     * @param collection  the collection to wrap\n     * @throws NullPointerException if the collection is null\n     */\n    public LoopingIterator(final Collection<? extends E> collection) {\n        this.collection = Objects.requireNonNull(collection, \"collection\");\n        reset();\n    }\n\n    /**\n     * Has the iterator any more elements.\n     * <p>\n     * Returns false only if the collection originally had zero elements, or\n     * all the elements have been {@link #remove removed}.\n     *\n     * @return {@code true} if there are more elements\n     */\n    @Override\n    public boolean hasNext() {\n        return !collection.isEmpty();\n    }\n\n    /**\n     * Returns the next object in the collection.\n     * <p>\n     * If at the end of the collection, return the first element.\n     *\n     * @return the next object\n     * @throws NoSuchElementException if there are no elements\n     *         at all.  Use {@link #hasNext} to avoid this error.\n     */\n    @Override\n    public E next() {\n        if (collection.isEmpty()) {\n            throw new NoSuchElementException(\"There are no elements for this iterator to loop on\");\n        }\n        if (!iterator.hasNext()) {\n            reset();\n        }\n        return iterator.next();\n    }\n\n    /**\n     * Removes the previously retrieved item from the underlying collection.\n     * <p>\n     * This feature is only supported if the underlying collection's\n     * {@link Collection#iterator()} method returns an implementation\n     * that supports it.\n     * <p>\n     * This method can only be called after at least one {@link #next} method call.\n     * After a removal, the remove method may not be called again until another\n     * next has been performed. If the {@link #reset} is called, then remove may\n     * not be called until {@link #next} is called again.\n     */\n    @Override\n    public void remove() {\n        iterator.remove();\n    }\n\n    /**\n     * Resets the iterator back to the start of the collection.\n     */\n    @Override\n    public void reset() {\n        iterator = collection.iterator();\n    }\n\n    /**\n     * Gets the size of the collection underlying the iterator.\n     *\n     * @return the current collection size\n     */\n    public int size() {\n        return collection.size();\n    }\n\n}", "super_interfaces": ["ResettableIterator<E>"], "fields": [{"attribute_expression": "private final Collection<? extends E> collection;", "docstring": " The collection to base the iterator on", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Collection<? extends E>", "name": "collection", "syntax_pass": true}, {"attribute_expression": "private Iterator<? extends E> iterator;", "docstring": " The current iterator", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Iterator<? extends E>", "name": "iterator", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/iterators/ListIteratorWrapper.java.ListIteratorWrapper", "name": "ListIteratorWrapper", "file_path": "src/main/java/org/apache/commons/collections4/iterators/ListIteratorWrapper.java", "superclasses": "", "methods": ["[]ListIteratorWrapper(Iterator<? extends E>)", "[void]add(E)", "[boolean]hasNext()", "[boolean]hasPrevious()", "[E]next()", "[int]nextIndex()", "[E]previous()", "[int]previousIndex()", "[void]remove()", "[void]reset()", "[void]set(E)"], "method_uris": ["src/main/java/org/apache/commons/collections4/iterators/ListIteratorWrapper.java.ListIteratorWrapper.[]ListIteratorWrapper(Iterator<? extends E>)", "src/main/java/org/apache/commons/collections4/iterators/ListIteratorWrapper.java.ListIteratorWrapper.[void]add(E)", "src/main/java/org/apache/commons/collections4/iterators/ListIteratorWrapper.java.ListIteratorWrapper.[boolean]hasNext()", "src/main/java/org/apache/commons/collections4/iterators/ListIteratorWrapper.java.ListIteratorWrapper.[boolean]hasPrevious()", "src/main/java/org/apache/commons/collections4/iterators/ListIteratorWrapper.java.ListIteratorWrapper.[E]next()", "src/main/java/org/apache/commons/collections4/iterators/ListIteratorWrapper.java.ListIteratorWrapper.[int]nextIndex()", "src/main/java/org/apache/commons/collections4/iterators/ListIteratorWrapper.java.ListIteratorWrapper.[E]previous()", "src/main/java/org/apache/commons/collections4/iterators/ListIteratorWrapper.java.ListIteratorWrapper.[int]previousIndex()", "src/main/java/org/apache/commons/collections4/iterators/ListIteratorWrapper.java.ListIteratorWrapper.[void]remove()", "src/main/java/org/apache/commons/collections4/iterators/ListIteratorWrapper.java.ListIteratorWrapper.[void]reset()", "src/main/java/org/apache/commons/collections4/iterators/ListIteratorWrapper.java.ListIteratorWrapper.[void]set(E)"], "overrides": null, "attributes": [], "class_docstring": "\nConverts an {@link Iterator} into a {@link ResettableListIterator}.\nFor plain {@code Iterator}s this is accomplished by caching the returned\nelements.  This class can also be used to simply add\n{@link org.apache.commons.collections4.ResettableIterator ResettableIterator}\nfunctionality to a given {@link ListIterator}.\n<p>\nThe {@code ListIterator} interface has additional useful methods\nfor navigation - {@code previous()} and the index methods.\nThis class allows a regular {@code Iterator} to behave as a\n{@code ListIterator}. It achieves this by building a list internally\nof as the underlying iterator is traversed.\n<p>\nThe optional operations of {@code ListIterator} are not supported for plain {@code Iterator}s.\n<p>\nThis class implements ResettableListIterator from Commons Collections 3.2.\n\n@param <E> the type of elements in this iterator.\n@since 2.1\n", "original_string": "public class ListIteratorWrapper<E> implements ResettableListIterator<E> {\n\n    /** Message used when set or add are called. */\n    private static final String UNSUPPORTED_OPERATION_MESSAGE =\n        \"ListIteratorWrapper does not support optional operations of ListIterator.\";\n\n    /** Message used when set or add are called. */\n    private static final String CANNOT_REMOVE_MESSAGE = \"Cannot remove element at index {0}.\";\n\n    /** The underlying iterator being decorated. */\n    private final Iterator<? extends E> iterator;\n    /** The list being used to cache the iterator. */\n    private final List<E> list = new ArrayList<>();\n\n    /** The current index of this iterator. */\n    private int currentIndex;\n    /** The current index of the wrapped iterator. */\n    private int wrappedIteratorIndex;\n    /** Recall whether the wrapped iterator's \"cursor\" is in such a state as to allow remove() to be called */\n    private boolean removeState;\n\n    /**\n     * Constructs a new {@code ListIteratorWrapper} that will wrap\n     * the given iterator.\n     *\n     * @param iterator  the iterator to wrap\n     * @throws NullPointerException if the iterator is null\n     */\n    public ListIteratorWrapper(final Iterator<? extends E> iterator) {\n        this.iterator = Objects.requireNonNull(iterator, \"iterator\");\n    }\n\n    /**\n     * Throws {@link UnsupportedOperationException}\n     * unless the underlying {@code Iterator} is a {@code ListIterator}.\n     *\n     * @param obj  the object to add\n     * @throws UnsupportedOperationException if the underlying iterator is not of\n     * type {@link ListIterator}\n     */\n    @Override\n    public void add(final E obj) throws UnsupportedOperationException {\n        if (iterator instanceof ListIterator) {\n            @SuppressWarnings(\"unchecked\")\n            final ListIterator<E> li = (ListIterator<E>) iterator;\n            li.add(obj);\n            return;\n        }\n        throw new UnsupportedOperationException(UNSUPPORTED_OPERATION_MESSAGE);\n    }\n\n    /**\n     * Returns true if there are more elements in the iterator.\n     *\n     * @return true if there are more elements\n     */\n    @Override\n    public boolean hasNext() {\n        if (currentIndex == wrappedIteratorIndex || iterator instanceof ListIterator) {\n            return iterator.hasNext();\n        }\n        return true;\n    }\n\n    /**\n     * Returns true if there are previous elements in the iterator.\n     *\n     * @return true if there are previous elements\n     */\n    @Override\n    public boolean hasPrevious() {\n        if (iterator instanceof ListIterator) {\n            final ListIterator<?> li = (ListIterator<?>) iterator;\n            return li.hasPrevious();\n        }\n        return currentIndex > 0;\n    }\n\n    /**\n     * Returns the next element from the iterator.\n     *\n     * @return the next element from the iterator\n     * @throws NoSuchElementException if there are no more elements\n     */\n    @Override\n    public E next() throws NoSuchElementException {\n        if (iterator instanceof ListIterator) {\n            return iterator.next();\n        }\n\n        if (currentIndex < wrappedIteratorIndex) {\n            ++currentIndex;\n            return list.get(currentIndex - 1);\n        }\n\n        final E retval = iterator.next();\n        list.add(retval);\n        ++currentIndex;\n        ++wrappedIteratorIndex;\n        removeState = true;\n        return retval;\n    }\n\n    /**\n     * Returns the index of the next element.\n     *\n     * @return the index of the next element\n     */\n    @Override\n    public int nextIndex() {\n        if (iterator instanceof ListIterator) {\n            final ListIterator<?> li = (ListIterator<?>) iterator;\n            return li.nextIndex();\n        }\n        return currentIndex;\n    }\n\n    /**\n     * Returns the previous element.\n     *\n     * @return the previous element\n     * @throws NoSuchElementException  if there are no previous elements\n     */\n    @Override\n    public E previous() throws NoSuchElementException {\n        if (iterator instanceof ListIterator) {\n            @SuppressWarnings(\"unchecked\")\n            final ListIterator<E> li = (ListIterator<E>) iterator;\n            return li.previous();\n        }\n\n        if (currentIndex == 0) {\n            throw new NoSuchElementException();\n        }\n        removeState = wrappedIteratorIndex == currentIndex;\n        return list.get(--currentIndex);\n    }\n\n    /**\n     * Returns the index of the previous element.\n     *\n     * @return  the index of the previous element\n     */\n    @Override\n    public int previousIndex() {\n        if (iterator instanceof ListIterator) {\n            final ListIterator<?> li = (ListIterator<?>) iterator;\n            return li.previousIndex();\n        }\n        return currentIndex - 1;\n    }\n\n    /**\n     * Removes the last element that was returned by {@link #next()} or {@link #previous()} from the underlying collection.\n     * This call can only be made once per call to {@code next} or {@code previous} and only if {@link #add(Object)} was not called in between.\n     *\n     * @throws IllegalStateException if {@code next} or {@code previous} have not been called before, or if {@code remove} or {@code add} have been called after the last call to {@code next} or {@code previous}\n     */\n    @Override\n    public void remove() throws IllegalStateException {\n        if (iterator instanceof ListIterator) {\n            iterator.remove();\n            return;\n        }\n        int removeIndex = currentIndex;\n        if (currentIndex == wrappedIteratorIndex) {\n            --removeIndex;\n        }\n        if (!removeState || wrappedIteratorIndex - currentIndex > 1) {\n            throw new IllegalStateException(MessageFormat.format(CANNOT_REMOVE_MESSAGE, Integer.valueOf(removeIndex)));\n        }\n        iterator.remove();\n        list.remove(removeIndex);\n        currentIndex = removeIndex;\n        wrappedIteratorIndex--;\n        removeState = false;\n    }\n\n    /**\n     * Resets this iterator back to the position at which the iterator\n     * was created.\n     *\n     * @since 3.2\n     */\n    @Override\n    public void reset()  {\n        if (iterator instanceof ListIterator) {\n            final ListIterator<?> li = (ListIterator<?>) iterator;\n            while (li.previousIndex() >= 0) {\n                li.previous();\n            }\n            return;\n        }\n        currentIndex = 0;\n    }\n\n    /**\n     * Throws {@link UnsupportedOperationException}\n     * unless the underlying {@code Iterator} is a {@code ListIterator}.\n     *\n     * @param obj  the object to set\n     * @throws UnsupportedOperationException if the underlying iterator is not of\n     * type {@link ListIterator}\n     */\n    @Override\n    public void set(final E obj) throws UnsupportedOperationException {\n        if (iterator instanceof ListIterator) {\n            @SuppressWarnings(\"unchecked\")\n            final ListIterator<E> li = (ListIterator<E>) iterator;\n            li.set(obj);\n            return;\n        }\n        throw new UnsupportedOperationException(UNSUPPORTED_OPERATION_MESSAGE);\n    }\n\n}", "super_interfaces": ["ResettableListIterator<E>"], "fields": [{"attribute_expression": "private static final String UNSUPPORTED_OPERATION_MESSAGE =\n        \"ListIteratorWrapper does not support optional operations of ListIterator.\";", "docstring": " Message used when set or add are called.", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "UNSUPPORTED_OPERATION_MESSAGE =\n        \"ListIteratorWrapper does not support optional operations of ListIterator.\"", "syntax_pass": true}, {"attribute_expression": "private static final String CANNOT_REMOVE_MESSAGE = \"Cannot remove element at index {0}.\";", "docstring": " Message used when set or add are called.", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "CANNOT_REMOVE_MESSAGE = \"Cannot remove element at index {0}.\"", "syntax_pass": true}, {"attribute_expression": "private final Iterator<? extends E> iterator;", "docstring": " The underlying iterator being decorated.", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Iterator<? extends E>", "name": "iterator", "syntax_pass": true}, {"attribute_expression": "private final List<E> list = new ArrayList<>();", "docstring": " The list being used to cache the iterator.", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<E>", "name": "list = new ArrayList<>()", "syntax_pass": true}, {"attribute_expression": "private int currentIndex;", "docstring": " The current index of this iterator.", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "currentIndex", "syntax_pass": true}, {"attribute_expression": "private int wrappedIteratorIndex;", "docstring": " The current index of the wrapped iterator.", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "wrappedIteratorIndex", "syntax_pass": true}, {"attribute_expression": "private boolean removeState;", "docstring": " Recall whether the wrapped iterator's \"cursor\" is in such a state as to allow remove() to be called", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "removeState", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/iterators/FilterListIterator.java.FilterListIterator", "name": "FilterListIterator", "file_path": "src/main/java/org/apache/commons/collections4/iterators/FilterListIterator.java", "superclasses": "", "methods": ["[]FilterListIterator()", "[]FilterListIterator(ListIterator<? extends E>)", "[]FilterListIterator(ListIterator<? extends E>,Predicate<? super E>)", "[]FilterListIterator(Predicate<? super E>)", "[void]add(E)", "[void]clearNextObject()", "[void]clearPreviousObject()", "[ListIterator<? extends E>]getListIterator()", "[Predicate<? super E>]getPredicate()", "[boolean]hasNext()", "[boolean]hasPrevious()", "[E]next()", "[int]nextIndex()", "[E]previous()", "[int]previousIndex()", "[void]remove()", "[void]set(E)", "[void]setListIterator(ListIterator<? extends E>)", "[boolean]setNextObject()", "[void]setPredicate(Predicate<? super E>)", "[boolean]setPreviousObject()"], "method_uris": ["src/main/java/org/apache/commons/collections4/iterators/FilterListIterator.java.FilterListIterator.[]FilterListIterator()", "src/main/java/org/apache/commons/collections4/iterators/FilterListIterator.java.FilterListIterator.[]FilterListIterator(ListIterator<? extends E>)", "src/main/java/org/apache/commons/collections4/iterators/FilterListIterator.java.FilterListIterator.[]FilterListIterator(ListIterator<? extends E>,Predicate<? super E>)", "src/main/java/org/apache/commons/collections4/iterators/FilterListIterator.java.FilterListIterator.[]FilterListIterator(Predicate<? super E>)", "src/main/java/org/apache/commons/collections4/iterators/FilterListIterator.java.FilterListIterator.[void]add(E)", "src/main/java/org/apache/commons/collections4/iterators/FilterListIterator.java.FilterListIterator.[void]clearNextObject()", "src/main/java/org/apache/commons/collections4/iterators/FilterListIterator.java.FilterListIterator.[void]clearPreviousObject()", "src/main/java/org/apache/commons/collections4/iterators/FilterListIterator.java.FilterListIterator.[ListIterator<? extends E>]getListIterator()", "src/main/java/org/apache/commons/collections4/iterators/FilterListIterator.java.FilterListIterator.[Predicate<? super E>]getPredicate()", "src/main/java/org/apache/commons/collections4/iterators/FilterListIterator.java.FilterListIterator.[boolean]hasNext()", "src/main/java/org/apache/commons/collections4/iterators/FilterListIterator.java.FilterListIterator.[boolean]hasPrevious()", "src/main/java/org/apache/commons/collections4/iterators/FilterListIterator.java.FilterListIterator.[E]next()", "src/main/java/org/apache/commons/collections4/iterators/FilterListIterator.java.FilterListIterator.[int]nextIndex()", "src/main/java/org/apache/commons/collections4/iterators/FilterListIterator.java.FilterListIterator.[E]previous()", "src/main/java/org/apache/commons/collections4/iterators/FilterListIterator.java.FilterListIterator.[int]previousIndex()", "src/main/java/org/apache/commons/collections4/iterators/FilterListIterator.java.FilterListIterator.[void]remove()", "src/main/java/org/apache/commons/collections4/iterators/FilterListIterator.java.FilterListIterator.[void]set(E)", "src/main/java/org/apache/commons/collections4/iterators/FilterListIterator.java.FilterListIterator.[void]setListIterator(ListIterator<? extends E>)", "src/main/java/org/apache/commons/collections4/iterators/FilterListIterator.java.FilterListIterator.[boolean]setNextObject()", "src/main/java/org/apache/commons/collections4/iterators/FilterListIterator.java.FilterListIterator.[void]setPredicate(Predicate<? super E>)", "src/main/java/org/apache/commons/collections4/iterators/FilterListIterator.java.FilterListIterator.[boolean]setPreviousObject()"], "overrides": null, "attributes": [], "class_docstring": "\nDecorates another {@link ListIterator} using a predicate to filter elements.\n<p>\nThis iterator decorates the underlying iterator, only allowing through\nthose elements that match the specified {@link Predicate Predicate}.\n\n@param <E> the type of elements returned by this iterator.\n@since 2.0\n", "original_string": "public class FilterListIterator<E> implements ListIterator<E> {\n\n    /** The iterator being used */\n    private ListIterator<? extends E> iterator;\n\n    /** The predicate being used */\n    private Predicate<? super E> predicate;\n\n    /**\n     * The value of the next (matching) object, when\n     * {@link #nextObjectSet} is true.\n     */\n    private E nextObject;\n\n    /**\n     * Whether or not the {@link #nextObject} has been set\n     * (possibly to {@code null}).\n     */\n    private boolean nextObjectSet;\n\n    /**\n     * The value of the previous (matching) object, when\n     * {@link #previousObjectSet} is true.\n     */\n    private E previousObject;\n\n    /**\n     * Whether or not the {@link #previousObject} has been set\n     * (possibly to {@code null}).\n     */\n    private boolean previousObjectSet;\n\n    /**\n     * The index of the element that would be returned by {@link #next}.\n     */\n    private int nextIndex;\n\n    /**\n     * Constructs a new {@code FilterListIterator} that will not function\n     * until {@link #setListIterator(ListIterator) setListIterator}\n     * and {@link #setPredicate(Predicate) setPredicate} are invoked.\n     */\n    public FilterListIterator() {\n    }\n\n    /**\n     * Constructs a new {@code FilterListIterator} that will not\n     * function until {@link #setPredicate(Predicate) setPredicate} is invoked.\n     *\n     * @param iterator  the iterator to use\n     */\n    public FilterListIterator(final ListIterator<? extends E> iterator ) {\n        this.iterator = iterator;\n    }\n\n    /**\n     * Constructs a new {@code FilterListIterator}.\n     *\n     * @param iterator  the iterator to use\n     * @param predicate  the predicate to use\n     */\n    public FilterListIterator(final ListIterator<? extends E> iterator, final Predicate<? super E> predicate) {\n        this.iterator = iterator;\n        this.predicate = predicate;\n    }\n\n    /**\n     * Constructs a new {@code FilterListIterator} that will not function\n     * until {@link #setListIterator(ListIterator) setListIterator} is invoked.\n     *\n     * @param predicate  the predicate to use.\n     */\n    public FilterListIterator(final Predicate<? super E> predicate) {\n        this.predicate = predicate;\n    }\n\n    /**\n     * Not supported.\n     * @param o the element to insert\n     */\n    @Override\n    public void add(final E o) {\n        throw new UnsupportedOperationException(\"FilterListIterator.add(Object) is not supported.\");\n    }\n\n    private void clearNextObject() {\n        nextObject = null;\n        nextObjectSet = false;\n    }\n\n    private void clearPreviousObject() {\n        previousObject = null;\n        previousObjectSet = false;\n    }\n\n    /**\n     * Gets the iterator this iterator is using.\n     *\n     * @return the iterator.\n     */\n    public ListIterator<? extends E> getListIterator() {\n        return iterator;\n    }\n\n    /**\n     * Gets the predicate this iterator is using.\n     *\n     * @return the predicate.\n     */\n    public Predicate<? super E> getPredicate() {\n        return predicate;\n    }\n\n    @Override\n    public boolean hasNext() {\n        return nextObjectSet || setNextObject();\n    }\n\n    @Override\n    public boolean hasPrevious() {\n        return previousObjectSet || setPreviousObject();\n    }\n\n    @Override\n    public E next() {\n        if (!nextObjectSet && !setNextObject()) {\n            throw new NoSuchElementException();\n        }\n        nextIndex++;\n        final E temp = nextObject;\n        clearNextObject();\n        return temp;\n    }\n\n    @Override\n    public int nextIndex() {\n        return nextIndex;\n    }\n\n    @Override\n    public E previous() {\n        if (!previousObjectSet && !setPreviousObject()) {\n            throw new NoSuchElementException();\n        }\n        nextIndex--;\n        final E temp = previousObject;\n        clearPreviousObject();\n        return temp;\n    }\n\n    @Override\n    public int previousIndex() {\n        return nextIndex - 1;\n    }\n\n    /** Not supported. */\n    @Override\n    public void remove() {\n        throw new UnsupportedOperationException(\"FilterListIterator.remove() is not supported.\");\n    }\n\n    /**\n     * Not supported.\n     * @param ignored the element with which to replace the last element returned by\n     *          {@code next} or {@code previous}\n     */\n    @Override\n    public void set(final E ignored) {\n        throw new UnsupportedOperationException(\"FilterListIterator.set(Object) is not supported.\");\n    }\n\n    /**\n     * Sets the iterator for this iterator to use.\n     * If iteration has started, this effectively resets the iterator.\n     *\n     * @param iterator  the iterator to use\n     */\n    public void setListIterator(final ListIterator<? extends E> iterator) {\n        this.iterator = iterator;\n    }\n\n    private boolean setNextObject() {\n        // if previousObjectSet,\n        // then we've walked back one step in the\n        // underlying list (due to a hasPrevious() call)\n        // so skip ahead one matching object\n        if (previousObjectSet) {\n            clearPreviousObject();\n            if (!setNextObject()) {\n                return false;\n            }\n            clearNextObject();\n        }\n\n        if (iterator == null) {\n            return false;\n        }\n        while (iterator.hasNext()) {\n            final E object = iterator.next();\n            if (predicate.test(object)) {\n                nextObject = object;\n                nextObjectSet = true;\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Sets the predicate this the iterator to use.\n     *\n     * @param predicate  the transformer to use\n     */\n    public void setPredicate(final Predicate<? super E> predicate) {\n        this.predicate = predicate;\n    }\n\n    private boolean setPreviousObject() {\n        // if nextObjectSet,\n        // then we've walked back one step in the\n        // underlying list (due to a hasNext() call)\n        // so skip ahead one matching object\n        if (nextObjectSet) {\n            clearNextObject();\n            if (!setPreviousObject()) {\n                return false;\n            }\n            clearPreviousObject();\n        }\n\n        if (iterator == null) {\n            return false;\n        }\n        while (iterator.hasPrevious()) {\n            final E object = iterator.previous();\n            if (predicate.test(object)) {\n                previousObject = object;\n                previousObjectSet = true;\n                return true;\n            }\n        }\n        return false;\n    }\n\n}", "super_interfaces": ["ListIterator<E>"], "fields": [{"attribute_expression": "private ListIterator<? extends E> iterator;", "docstring": " The iterator being used", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ListIterator<? extends E>", "name": "iterator", "syntax_pass": true}, {"attribute_expression": "private Predicate<? super E> predicate;", "docstring": " The predicate being used", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Predicate<? super E>", "name": "predicate", "syntax_pass": true}, {"attribute_expression": "private E nextObject;", "docstring": "\nThe value of the next (matching) object, when\n{@link #nextObjectSet} is true.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "E", "name": "nextObject", "syntax_pass": true}, {"attribute_expression": "private boolean nextObjectSet;", "docstring": "\nWhether or not the {@link #nextObject} has been set\n(possibly to {@code null}).\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "nextObjectSet", "syntax_pass": true}, {"attribute_expression": "private E previousObject;", "docstring": "\nThe value of the previous (matching) object, when\n{@link #previousObjectSet} is true.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "E", "name": "previousObject", "syntax_pass": true}, {"attribute_expression": "private boolean previousObjectSet;", "docstring": "\nWhether or not the {@link #previousObject} has been set\n(possibly to {@code null}).\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "previousObjectSet", "syntax_pass": true}, {"attribute_expression": "private int nextIndex;", "docstring": "\nThe index of the element that would be returned by {@link #next}.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "nextIndex", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/iterators/ObjectArrayIterator.java.ObjectArrayIterator", "name": "ObjectArrayIterator", "file_path": "src/main/java/org/apache/commons/collections4/iterators/ObjectArrayIterator.java", "superclasses": "", "methods": ["[]ObjectArrayIterator()", "[]ObjectArrayIterator(E[],int)", "[]ObjectArrayIterator(E[],int,int)", "[E[]]getArray()", "[int]getEndIndex()", "[int]getStartIndex()", "[boolean]hasNext()", "[E]next()", "[void]remove()", "[void]reset()"], "method_uris": ["src/main/java/org/apache/commons/collections4/iterators/ObjectArrayIterator.java.ObjectArrayIterator.[]ObjectArrayIterator()", "src/main/java/org/apache/commons/collections4/iterators/ObjectArrayIterator.java.ObjectArrayIterator.[]ObjectArrayIterator(E[],int)", "src/main/java/org/apache/commons/collections4/iterators/ObjectArrayIterator.java.ObjectArrayIterator.[]ObjectArrayIterator(E[],int,int)", "src/main/java/org/apache/commons/collections4/iterators/ObjectArrayIterator.java.ObjectArrayIterator.[E[]]getArray()", "src/main/java/org/apache/commons/collections4/iterators/ObjectArrayIterator.java.ObjectArrayIterator.[int]getEndIndex()", "src/main/java/org/apache/commons/collections4/iterators/ObjectArrayIterator.java.ObjectArrayIterator.[int]getStartIndex()", "src/main/java/org/apache/commons/collections4/iterators/ObjectArrayIterator.java.ObjectArrayIterator.[boolean]hasNext()", "src/main/java/org/apache/commons/collections4/iterators/ObjectArrayIterator.java.ObjectArrayIterator.[E]next()", "src/main/java/org/apache/commons/collections4/iterators/ObjectArrayIterator.java.ObjectArrayIterator.[void]remove()", "src/main/java/org/apache/commons/collections4/iterators/ObjectArrayIterator.java.ObjectArrayIterator.[void]reset()"], "overrides": null, "attributes": [], "class_docstring": "\nAn {@link java.util.Iterator Iterator} over an array of objects.\n<p>\nThis iterator does not support {@link #remove}, as the object array cannot be\nstructurally modified.\n<p>\nThe iterator implements a {@link #reset} method, allowing the reset of the iterator\nback to the start if required.\n\n@param <E> the type of elements returned by this iterator.\n@since 3.0\n", "original_string": "public class ObjectArrayIterator<E> implements ResettableIterator<E> {\n\n    /** The array */\n    final E[] array;\n    /** The start index to loop from */\n    final int startIndex;\n    /** The end index to loop to */\n    final int endIndex;\n    /** The current iterator index */\n    int index;\n\n    /**\n     * Constructs an ObjectArrayIterator that will iterate over the values in the\n     * specified array.\n     *\n     * @param array the array to iterate over\n     * @throws NullPointerException if {@code array} is {@code null}\n     */\n    public ObjectArrayIterator(final E... array) {\n        this(array, 0, array.length);\n    }\n\n    /**\n     * Constructs an ObjectArrayIterator that will iterate over the values in the\n     * specified array from a specific start index.\n     *\n     * @param array  the array to iterate over\n     * @param start  the index to start iterating at\n     * @throws NullPointerException if {@code array} is {@code null}\n     * @throws IndexOutOfBoundsException if the start index is out of bounds\n     */\n    public ObjectArrayIterator(final E[] array, final int start) {\n        this(array, start, array.length);\n    }\n\n    /**\n     * Constructs an ObjectArrayIterator that will iterate over a range of values\n     * in the specified array.\n     *\n     * @param array  the array to iterate over\n     * @param start  the index to start iterating at\n     * @param end  the index (exclusive) to finish iterating at\n     * @throws IndexOutOfBoundsException if the start or end index is out of bounds\n     * @throws IllegalArgumentException if end index is before the start\n     * @throws NullPointerException if {@code array} is {@code null}\n     */\n    public ObjectArrayIterator(final E[] array, final int start, final int end) {\n        if (start < 0) {\n            throw new ArrayIndexOutOfBoundsException(\"Start index must not be less than zero\");\n        }\n        if (end > array.length) {\n            throw new ArrayIndexOutOfBoundsException(\"End index must not be greater than the array length\");\n        }\n        if (start > array.length) {\n            throw new ArrayIndexOutOfBoundsException(\"Start index must not be greater than the array length\");\n        }\n        if (end < start) {\n            throw new IllegalArgumentException(\"End index must not be less than start index\");\n        }\n        this.array = array;\n        startIndex = start;\n        endIndex = end;\n        index = start;\n    }\n\n    /**\n     * Gets the array that this iterator is iterating over.\n     *\n     * @return the array this iterator iterates over\n     */\n    public E[] getArray() {\n        return array;\n    }\n\n    /**\n     * Gets the end index to loop to.\n     *\n     * @return the end index\n     */\n    public int getEndIndex() {\n        return endIndex;\n    }\n\n    /**\n     * Gets the start index to loop from.\n     *\n     * @return the start index\n     */\n    public int getStartIndex() {\n        return startIndex;\n    }\n\n    /**\n     * Returns true if there are more elements to return from the array.\n     *\n     * @return true if there is a next element to return\n     */\n    @Override\n    public boolean hasNext() {\n        return index < endIndex;\n    }\n\n    /**\n     * Returns the next element in the array.\n     *\n     * @return the next element in the array\n     * @throws NoSuchElementException if all the elements in the array\n     *    have already been returned\n     */\n    @Override\n    public E next() {\n        if (!hasNext()) {\n            throw new NoSuchElementException();\n        }\n        return array[index++];\n    }\n\n    /**\n     * Throws {@link UnsupportedOperationException}.\n     *\n     * @throws UnsupportedOperationException always\n     */\n    @Override\n    public void remove() {\n        throw new UnsupportedOperationException(\"remove() method is not supported for an ObjectArrayIterator\");\n    }\n\n    /**\n     * Resets the iterator back to the start index.\n     */\n    @Override\n    public void reset() {\n        index = startIndex;\n    }\n\n}", "super_interfaces": ["ResettableIterator<E>"], "fields": [{"attribute_expression": "final E[] array;", "docstring": " The array", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "E[]", "name": "array", "syntax_pass": true}, {"attribute_expression": "final int startIndex;", "docstring": " The start index to loop from", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "int", "name": "startIndex", "syntax_pass": true}, {"attribute_expression": "final int endIndex;", "docstring": " The end index to loop to", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "int", "name": "endIndex", "syntax_pass": true}, {"attribute_expression": "int index;", "docstring": " The current iterator index", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int", "name": "index", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/iterators/ObjectArrayListIterator.java.ObjectArrayListIterator", "name": "ObjectArrayListIterator", "file_path": "src/main/java/org/apache/commons/collections4/iterators/ObjectArrayListIterator.java", "superclasses": "", "methods": ["[]ObjectArrayListIterator()", "[]ObjectArrayListIterator(E[],int)", "[]ObjectArrayListIterator(E[],int,int)", "[void]add(E)", "[boolean]hasPrevious()", "[E]next()", "[int]nextIndex()", "[E]previous()", "[int]previousIndex()", "[void]reset()", "[void]set(E)"], "method_uris": ["src/main/java/org/apache/commons/collections4/iterators/ObjectArrayListIterator.java.ObjectArrayListIterator.[]ObjectArrayListIterator()", "src/main/java/org/apache/commons/collections4/iterators/ObjectArrayListIterator.java.ObjectArrayListIterator.[]ObjectArrayListIterator(E[],int)", "src/main/java/org/apache/commons/collections4/iterators/ObjectArrayListIterator.java.ObjectArrayListIterator.[]ObjectArrayListIterator(E[],int,int)", "src/main/java/org/apache/commons/collections4/iterators/ObjectArrayListIterator.java.ObjectArrayListIterator.[void]add(E)", "src/main/java/org/apache/commons/collections4/iterators/ObjectArrayListIterator.java.ObjectArrayListIterator.[boolean]hasPrevious()", "src/main/java/org/apache/commons/collections4/iterators/ObjectArrayListIterator.java.ObjectArrayListIterator.[E]next()", "src/main/java/org/apache/commons/collections4/iterators/ObjectArrayListIterator.java.ObjectArrayListIterator.[int]nextIndex()", "src/main/java/org/apache/commons/collections4/iterators/ObjectArrayListIterator.java.ObjectArrayListIterator.[E]previous()", "src/main/java/org/apache/commons/collections4/iterators/ObjectArrayListIterator.java.ObjectArrayListIterator.[int]previousIndex()", "src/main/java/org/apache/commons/collections4/iterators/ObjectArrayListIterator.java.ObjectArrayListIterator.[void]reset()", "src/main/java/org/apache/commons/collections4/iterators/ObjectArrayListIterator.java.ObjectArrayListIterator.[void]set(E)"], "overrides": null, "attributes": [], "class_docstring": "\nImplements a {@link java.util.ListIterator} over an array of objects.\n<p>\nThis iterator does not support {@link #add} or {@link #remove}, as the object array\ncannot be structurally modified. The {@link #set} method is supported however.\n<p>\nThe iterator implements a {@link #reset} method, allowing the reset of the iterator\nback to the start if required.\n\n@param <E> the type of elements returned by this iterator.\n@see org.apache.commons.collections4.iterators.ObjectArrayIterator\n@see java.util.Iterator\n@see java.util.ListIterator\n\n@since 3.0\n", "original_string": "public class ObjectArrayListIterator<E> extends ObjectArrayIterator<E>\n        implements ResettableListIterator<E> {\n\n    /**\n     * Holds the index of the last item returned by a call to {@code next()}\n     * or {@code previous()}. This is set to {@code -1} if neither method\n     * has yet been invoked. {@code lastItemIndex} is used to implement the\n     * {@link #set} method.\n     */\n    private int lastItemIndex = -1;\n\n    /**\n     * Constructs an ObjectArrayListIterator that will iterate over the values in the\n     * specified array.\n     *\n     * @param array the array to iterate over\n     * @throws NullPointerException if {@code array} is {@code null}\n     */\n    public ObjectArrayListIterator(final E... array) {\n        super(array);\n    }\n\n    /**\n     * Constructs an ObjectArrayListIterator that will iterate over the values in the\n     * specified array from a specific start index.\n     *\n     * @param array  the array to iterate over\n     * @param start  the index to start iterating at\n     * @throws NullPointerException if {@code array} is {@code null}\n     * @throws IndexOutOfBoundsException if the start index is out of bounds\n     */\n    public ObjectArrayListIterator(final E[] array, final int start) {\n        super(array, start);\n    }\n\n    /**\n     * Constructs an ObjectArrayListIterator that will iterate over a range of values\n     * in the specified array.\n     *\n     * @param array  the array to iterate over\n     * @param start  the index to start iterating at\n     * @param end  the index (exclusive) to finish iterating at\n     * @throws IndexOutOfBoundsException if the start or end index is out of bounds\n     * @throws IllegalArgumentException if end index is before the start\n     * @throws NullPointerException if {@code array} is {@code null}\n     */\n    public ObjectArrayListIterator(final E[] array, final int start, final int end) {\n        super(array, start, end);\n    }\n\n    /**\n     * This iterator does not support modification of its backing array's size, and so will\n     * always throw an {@link UnsupportedOperationException} when this method is invoked.\n     *\n     * @param obj  the object to add\n     * @throws UnsupportedOperationException always thrown.\n     */\n    @Override\n    public void add(final E obj) {\n        throw new UnsupportedOperationException(\"add() method is not supported\");\n    }\n\n    /**\n     * Returns true if there are previous elements to return from the array.\n     *\n     * @return true if there is a previous element to return\n     */\n    @Override\n    public boolean hasPrevious() {\n        return index > getStartIndex();\n    }\n\n    /**\n     * Gets the next element from the array.\n     *\n     * @return the next element\n     * @throws NoSuchElementException if there is no next element\n     */\n    @Override\n    public E next() {\n        if (!hasNext()) {\n            throw new NoSuchElementException();\n        }\n        lastItemIndex = index;\n        return array[index++];\n    }\n\n    /**\n     * Gets the next index to be retrieved.\n     *\n     * @return the index of the item to be retrieved next\n     */\n    @Override\n    public int nextIndex() {\n        return index - getStartIndex();\n    }\n\n    /**\n     * Gets the previous element from the array.\n     *\n     * @return the previous element\n     * @throws NoSuchElementException if there is no previous element\n     */\n    @Override\n    public E previous() {\n        if (!hasPrevious()) {\n            throw new NoSuchElementException();\n        }\n        lastItemIndex = --index;\n        return array[index];\n    }\n\n    /**\n     * Gets the index of the item to be retrieved if {@link #previous()} is called.\n     *\n     * @return the index of the item to be retrieved next\n     */\n    @Override\n    public int previousIndex() {\n        return index - getStartIndex() - 1;\n    }\n\n    /**\n     * Resets the iterator back to the start index.\n     */\n    @Override\n    public void reset() {\n        super.reset();\n        lastItemIndex = -1;\n    }\n\n    /**\n     * Sets the element under the cursor.\n     * <p>\n     * This method sets the element that was returned by the last call\n     * to {@link #next()} of {@link #previous()}.\n     *\n     * <b>Note:</b> {@link java.util.ListIterator} implementations that support {@code add()}\n     * and {@code remove()} only allow {@code set()} to be called once per call\n     * to {@code next()} or {@code previous} (see the {@link java.util.ListIterator}\n     * Javadoc for more details). Since this implementation does not support\n     * {@code add()} or {@code remove()}, {@code set()} may be\n     * called as often as desired.\n     *\n     * @param obj  the object to set into the array\n     * @throws IllegalStateException if next() has not yet been called.\n     * @throws ClassCastException if the object type is unsuitable for the array\n     */\n    @Override\n    public void set(final E obj) {\n        if (lastItemIndex == -1) {\n            throw new IllegalStateException(\"must call next() or previous() before a call to set()\");\n        }\n        array[lastItemIndex] = obj;\n    }\n\n}", "super_interfaces": ["ResettableListIterator<E>"], "fields": [{"attribute_expression": "private int lastItemIndex = -1;", "docstring": "\nHolds the index of the last item returned by a call to {@code next()}\nor {@code previous()}. This is set to {@code -1} if neither method\nhas yet been invoked. {@code lastItemIndex} is used to implement the\n{@link #set} method.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "lastItemIndex = -1", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/iterators/SingletonIterator.java.SingletonIterator", "name": "SingletonIterator", "file_path": "src/main/java/org/apache/commons/collections4/iterators/SingletonIterator.java", "superclasses": "", "methods": ["[]SingletonIterator(E)", "[]SingletonIterator(E,boolean)", "[boolean]hasNext()", "[E]next()", "[void]remove()", "[void]reset()"], "method_uris": ["src/main/java/org/apache/commons/collections4/iterators/SingletonIterator.java.SingletonIterator.[]SingletonIterator(E)", "src/main/java/org/apache/commons/collections4/iterators/SingletonIterator.java.SingletonIterator.[]SingletonIterator(E,boolean)", "src/main/java/org/apache/commons/collections4/iterators/SingletonIterator.java.SingletonIterator.[boolean]hasNext()", "src/main/java/org/apache/commons/collections4/iterators/SingletonIterator.java.SingletonIterator.[E]next()", "src/main/java/org/apache/commons/collections4/iterators/SingletonIterator.java.SingletonIterator.[void]remove()", "src/main/java/org/apache/commons/collections4/iterators/SingletonIterator.java.SingletonIterator.[void]reset()"], "overrides": null, "attributes": [], "class_docstring": "\n{@code SingletonIterator} is an {@link java.util.Iterator} over a single\nobject instance.\n\n@param <E> the type of elements returned by this iterator.\n@since 2.0\n", "original_string": "public class SingletonIterator<E>\n        implements ResettableIterator<E> {\n\n    /** Whether remove is allowed */\n    private final boolean removeAllowed;\n    /** Is the cursor before the first element */\n    private boolean beforeFirst = true;\n    /** Has the element been removed */\n    private boolean removed;\n    /** The object */\n    private E object;\n\n    /**\n     * Constructs a new {@code SingletonIterator} where {@code remove}\n     * is a permitted operation.\n     *\n     * @param object  the single object to return from the iterator\n     */\n    public SingletonIterator(final E object) {\n        this(object, true);\n    }\n\n    /**\n     * Constructs a new {@code SingletonIterator} optionally choosing if\n     * {@code remove} is a permitted operation.\n     *\n     * @param object  the single object to return from the iterator\n     * @param removeAllowed  true if remove is allowed\n     * @since 3.1\n     */\n    public SingletonIterator(final E object, final boolean removeAllowed) {\n        this.object = object;\n        this.removeAllowed = removeAllowed;\n    }\n\n    /**\n     * Is another object available from the iterator?\n     * <p>\n     * This returns true if the single object hasn't been returned yet.\n     *\n     * @return true if the single object hasn't been returned yet\n     */\n    @Override\n    public boolean hasNext() {\n        return beforeFirst && !removed;\n    }\n\n    /**\n     * Gets the next object from the iterator.\n     * <p>\n     * This returns the single object if it hasn't been returned yet.\n     *\n     * @return the single object\n     * @throws NoSuchElementException if the single object has already\n     *    been returned\n     */\n    @Override\n    public E next() {\n        if (!beforeFirst || removed) {\n            throw new NoSuchElementException();\n        }\n        beforeFirst = false;\n        return object;\n    }\n\n    /**\n     * Remove the object from this iterator.\n     *\n     * @throws IllegalStateException if the {@code next} method has not\n     *        yet been called, or the {@code remove} method has already\n     *        been called after the last call to the {@code next}\n     *        method.\n     * @throws UnsupportedOperationException if remove is not supported\n     */\n    @Override\n    public void remove() {\n        if (!removeAllowed) {\n            throw new UnsupportedOperationException();\n        }\n        if (removed || beforeFirst) {\n            throw new IllegalStateException();\n        }\n        object = null;\n        removed = true;\n    }\n\n    /**\n     * Reset the iterator to the start.\n     */\n    @Override\n    public void reset() {\n        beforeFirst = true;\n    }\n\n}", "super_interfaces": ["ResettableIterator<E>"], "fields": [{"attribute_expression": "private final boolean removeAllowed;", "docstring": " Whether remove is allowed", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "boolean", "name": "removeAllowed", "syntax_pass": true}, {"attribute_expression": "private boolean beforeFirst = true;", "docstring": " Is the cursor before the first element", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "beforeFirst = true", "syntax_pass": true}, {"attribute_expression": "private boolean removed;", "docstring": " Has the element been removed", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "removed", "syntax_pass": true}, {"attribute_expression": "private E object;", "docstring": " The object", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "E", "name": "object", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/iterators/PermutationIterator.java.PermutationIterator", "name": "PermutationIterator", "file_path": "src/main/java/org/apache/commons/collections4/iterators/PermutationIterator.java", "superclasses": "", "methods": ["[]PermutationIterator(Collection<? extends E>)", "[boolean]hasNext()", "[List<E>]next()", "[void]remove()"], "method_uris": ["src/main/java/org/apache/commons/collections4/iterators/PermutationIterator.java.PermutationIterator.[]PermutationIterator(Collection<? extends E>)", "src/main/java/org/apache/commons/collections4/iterators/PermutationIterator.java.PermutationIterator.[boolean]hasNext()", "src/main/java/org/apache/commons/collections4/iterators/PermutationIterator.java.PermutationIterator.[List<E>]next()", "src/main/java/org/apache/commons/collections4/iterators/PermutationIterator.java.PermutationIterator.[void]remove()"], "overrides": null, "attributes": [], "class_docstring": "\nThis iterator creates permutations of an input collection, using the\nSteinhaus-Johnson-Trotter algorithm (also called plain changes).\n<p>\nThe iterator will return exactly n! permutations of the input collection.\nThe {@code remove()} operation is not supported, and will throw an\n{@code UnsupportedOperationException}.\n<p>\nNOTE: in case an empty collection is provided, the iterator will\nreturn exactly one empty list as result, as 0! = 1.\n\n@param <E>  the type of the objects being permuted\n\n@since 4.0\n", "original_string": "public class PermutationIterator<E> implements Iterator<List<E>> {\n\n    /**\n     * Permutation is done on these keys to handle equal objects.\n     */\n    private final int[] keys;\n\n    /**\n     * Mapping between keys and objects.\n     */\n    private final Map<Integer, E> objectMap;\n\n    /**\n     * Direction table used in the algorithm:\n     * <ul>\n     *   <li>false is left</li>\n     *   <li>true is right</li>\n     * </ul>\n     */\n    private final boolean[] direction;\n\n    /**\n     * Next permutation to return. When a permutation is requested\n     * this instance is provided and the next one is computed.\n     */\n    private List<E> nextPermutation;\n\n    /**\n     * Standard constructor for this class.\n     * @param collection  the collection to generate permutations for\n     * @throws NullPointerException if coll is null\n     */\n    public PermutationIterator(final Collection<? extends E> collection) {\n        Objects.requireNonNull(collection, \"collection\");\n        keys = new int[collection.size()];\n        direction = new boolean[collection.size()];\n        Arrays.fill(direction, false);\n        int value = 1;\n        objectMap = new HashMap<>();\n        for (final E e : collection) {\n            objectMap.put(Integer.valueOf(value), e);\n            keys[value - 1] = value;\n            value++;\n        }\n        nextPermutation = new ArrayList<>(collection);\n    }\n\n    /**\n     * Indicates if there are more permutation available.\n     * @return true if there are more permutations, otherwise false\n     */\n    @Override\n    public boolean hasNext() {\n        return nextPermutation != null;\n    }\n\n    /**\n     * Returns the next permutation of the input collection.\n     * @return a list of the permutator's elements representing a permutation\n     * @throws NoSuchElementException if there are no more permutations\n     */\n    @Override\n    public List<E> next() {\n        if (!hasNext()) {\n            throw new NoSuchElementException();\n        }\n\n        // find the largest mobile integer k\n        int indexOfLargestMobileInteger = -1;\n        int largestKey = -1;\n        for (int i = 0; i < keys.length; i++) {\n            if (direction[i] && i < keys.length - 1 && keys[i] > keys[i + 1] ||\n                !direction[i] && i > 0 && keys[i] > keys[i - 1]) {\n                if (keys[i] > largestKey) { // NOPMD\n                    largestKey = keys[i];\n                    indexOfLargestMobileInteger = i;\n                }\n            }\n        }\n        if (largestKey == -1) {\n            final List<E> toReturn = nextPermutation;\n            nextPermutation = null;\n            return toReturn;\n        }\n\n        // swap k and the adjacent integer it is looking at\n        final int offset = direction[indexOfLargestMobileInteger] ? 1 : -1;\n        final int tmpKey = keys[indexOfLargestMobileInteger];\n        keys[indexOfLargestMobileInteger] = keys[indexOfLargestMobileInteger + offset];\n        keys[indexOfLargestMobileInteger + offset] = tmpKey;\n        final boolean tmpDirection = direction[indexOfLargestMobileInteger];\n        direction[indexOfLargestMobileInteger] = direction[indexOfLargestMobileInteger + offset];\n        direction[indexOfLargestMobileInteger + offset] = tmpDirection;\n\n        // reverse the direction of all integers larger than k and build the result\n        final List<E> nextP = new ArrayList<>();\n        for (int i = 0; i < keys.length; i++) {\n            if (keys[i] > largestKey) {\n                direction[i] = !direction[i];\n            }\n            nextP.add(objectMap.get(Integer.valueOf(keys[i])));\n        }\n        final List<E> result = nextPermutation;\n        nextPermutation = nextP;\n        return result;\n    }\n\n    @Override\n    public void remove() {\n        throw new UnsupportedOperationException(\"remove() is not supported\");\n    }\n\n}", "super_interfaces": ["Iterator<List<E>>"], "fields": [{"attribute_expression": "private final int[] keys;", "docstring": "\nPermutation is done on these keys to handle equal objects.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int[]", "name": "keys", "syntax_pass": true}, {"attribute_expression": "private final Map<Integer, E> objectMap;", "docstring": "\nMapping between keys and objects.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Map<Integer, E>", "name": "objectMap", "syntax_pass": true}, {"attribute_expression": "private final boolean[] direction;", "docstring": "\nDirection table used in the algorithm:\n<ul>\n  <li>false is left</li>\n  <li>true is right</li>\n</ul>\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "boolean[]", "name": "direction", "syntax_pass": true}, {"attribute_expression": "private List<E> nextPermutation;", "docstring": "\nNext permutation to return. When a permutation is requested\nthis instance is provided and the next one is computed.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "List<E>", "name": "nextPermutation", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/iterators/UnmodifiableListIterator.java.UnmodifiableListIterator", "name": "UnmodifiableListIterator", "file_path": "src/main/java/org/apache/commons/collections4/iterators/UnmodifiableListIterator.java", "superclasses": "", "methods": ["[ListIterator<E>]umodifiableListIterator(ListIterator<? extends E>)", "[ListIterator<E>]unmodifiableListIterator(ListIterator<? extends E>)", "[]UnmodifiableListIterator(ListIterator<? extends E>)", "[void]add(E)", "[boolean]hasNext()", "[boolean]hasPrevious()", "[E]next()", "[int]nextIndex()", "[E]previous()", "[int]previousIndex()", "[void]remove()", "[void]set(E)"], "method_uris": ["src/main/java/org/apache/commons/collections4/iterators/UnmodifiableListIterator.java.UnmodifiableListIterator.[ListIterator<E>]umodifiableListIterator(ListIterator<? extends E>)", "src/main/java/org/apache/commons/collections4/iterators/UnmodifiableListIterator.java.UnmodifiableListIterator.[ListIterator<E>]unmodifiableListIterator(ListIterator<? extends E>)", "src/main/java/org/apache/commons/collections4/iterators/UnmodifiableListIterator.java.UnmodifiableListIterator.[]UnmodifiableListIterator(ListIterator<? extends E>)", "src/main/java/org/apache/commons/collections4/iterators/UnmodifiableListIterator.java.UnmodifiableListIterator.[void]add(E)", "src/main/java/org/apache/commons/collections4/iterators/UnmodifiableListIterator.java.UnmodifiableListIterator.[boolean]hasNext()", "src/main/java/org/apache/commons/collections4/iterators/UnmodifiableListIterator.java.UnmodifiableListIterator.[boolean]hasPrevious()", "src/main/java/org/apache/commons/collections4/iterators/UnmodifiableListIterator.java.UnmodifiableListIterator.[E]next()", "src/main/java/org/apache/commons/collections4/iterators/UnmodifiableListIterator.java.UnmodifiableListIterator.[int]nextIndex()", "src/main/java/org/apache/commons/collections4/iterators/UnmodifiableListIterator.java.UnmodifiableListIterator.[E]previous()", "src/main/java/org/apache/commons/collections4/iterators/UnmodifiableListIterator.java.UnmodifiableListIterator.[int]previousIndex()", "src/main/java/org/apache/commons/collections4/iterators/UnmodifiableListIterator.java.UnmodifiableListIterator.[void]remove()", "src/main/java/org/apache/commons/collections4/iterators/UnmodifiableListIterator.java.UnmodifiableListIterator.[void]set(E)"], "overrides": null, "attributes": [], "class_docstring": "\nDecorates a list iterator such that it cannot be modified.\n<p>\nAttempts to modify it will result in an UnsupportedOperationException.\n</p>\n\n@param <E> the type of elements returned by this iterator.\n@since 3.0\n", "original_string": "public final class UnmodifiableListIterator<E> implements ListIterator<E>, Unmodifiable {\n\n    /**\n     * Decorates the specified iterator such that it cannot be modified.\n     *\n     * @param <E>  the element type\n     * @param iterator  the iterator to decorate\n     * @return a new unmodifiable list iterator\n     * @throws NullPointerException if the iterator is null\n     * @deprecated method name has typo in it. Use {@link org.apache.commons.collections4.iterators.UnmodifiableListIterator#unmodifiableListIterator(ListIterator)} instead.\n     */\n    @Deprecated\n    public static <E> ListIterator<E> umodifiableListIterator(final ListIterator<? extends E> iterator) {\n        return unmodifiableListIterator(iterator);\n    }\n\n    /**\n     * Decorates the specified iterator such that it cannot be modified.\n     *\n     * @param <E>  the element type\n     * @param iterator  the iterator to decorate\n     * @return a new unmodifiable list iterator\n     * @throws NullPointerException if the iterator is null\n     */\n    public static <E> ListIterator<E> unmodifiableListIterator(final ListIterator<? extends E> iterator) {\n        Objects.requireNonNull(iterator, \"iterator\");\n        if (iterator instanceof Unmodifiable) {\n            @SuppressWarnings(\"unchecked\") // safe to upcast\n            final ListIterator<E> tmpIterator = (ListIterator<E>) iterator;\n            return tmpIterator;\n        }\n        return new UnmodifiableListIterator<>(iterator);\n    }\n\n    /** The iterator being decorated */\n    private final ListIterator<? extends E> iterator;\n\n    /**\n     * Constructs a new instance.\n     *\n     * @param iterator  the iterator to decorate\n     */\n    private UnmodifiableListIterator(final ListIterator<? extends E> iterator) {\n        this.iterator = iterator;\n    }\n\n    @Override\n    public void add(final E obj) {\n        throw new UnsupportedOperationException(\"add() is not supported\");\n    }\n\n    @Override\n    public boolean hasNext() {\n        return iterator.hasNext();\n    }\n\n    @Override\n    public boolean hasPrevious() {\n        return iterator.hasPrevious();\n    }\n\n    @Override\n    public E next() {\n        return iterator.next();\n    }\n\n    @Override\n    public int nextIndex() {\n        return iterator.nextIndex();\n    }\n\n    @Override\n    public E previous() {\n        return iterator.previous();\n    }\n\n    @Override\n    public int previousIndex() {\n        return iterator.previousIndex();\n    }\n\n    @Override\n    public void remove() {\n        throw new UnsupportedOperationException(\"remove() is not supported\");\n    }\n\n    @Override\n    public void set(final E ignored) {\n        throw new UnsupportedOperationException(\"set() is not supported\");\n    }\n\n}", "super_interfaces": ["ListIterator<E>", "Unmodifiable"], "fields": [{"attribute_expression": "private final ListIterator<? extends E> iterator;", "docstring": " The iterator being decorated", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ListIterator<? extends E>", "name": "iterator", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/iterators/BoundedIterator.java.BoundedIterator", "name": "BoundedIterator", "file_path": "src/main/java/org/apache/commons/collections4/iterators/BoundedIterator.java", "superclasses": "", "methods": ["[]BoundedIterator(Iterator<? extends E>,long,long)", "[boolean]checkBounds()", "[boolean]hasNext()", "[void]init()", "[E]next()", "[void]remove()"], "method_uris": ["src/main/java/org/apache/commons/collections4/iterators/BoundedIterator.java.BoundedIterator.[]BoundedIterator(Iterator<? extends E>,long,long)", "src/main/java/org/apache/commons/collections4/iterators/BoundedIterator.java.BoundedIterator.[boolean]checkBounds()", "src/main/java/org/apache/commons/collections4/iterators/BoundedIterator.java.BoundedIterator.[boolean]hasNext()", "src/main/java/org/apache/commons/collections4/iterators/BoundedIterator.java.BoundedIterator.[void]init()", "src/main/java/org/apache/commons/collections4/iterators/BoundedIterator.java.BoundedIterator.[E]next()", "src/main/java/org/apache/commons/collections4/iterators/BoundedIterator.java.BoundedIterator.[void]remove()"], "overrides": null, "attributes": [], "class_docstring": "\nDecorates another iterator to return elements in a specific range.\n<p>\nThe decorated iterator is bounded in the range [offset, offset+max).\nThe {@code offset} corresponds to the position of the first element to\nbe returned from the decorated iterator, and {@code max} is the maximum\nnumber of elements to be returned at most.\n<p>\nIn case an offset parameter other than 0 is provided, the decorated\niterator is immediately advanced to this position, skipping all elements\nbefore that position.\n\n@param <E> the type of elements returned by this iterator.\n@since 4.1\n", "original_string": "public class BoundedIterator<E> implements Iterator<E> {\n\n    /** The iterator being decorated. */\n    private final Iterator<? extends E> iterator;\n\n    /** The offset to bound the first element return */\n    private final long offset;\n\n    /** The max number of elements to return */\n    private final long max;\n\n    /** The position of the current element */\n    private long pos;\n\n    /**\n     * Decorates the specified iterator to return at most the given number of elements,\n     * skipping all elements until the iterator reaches the position at {@code offset}.\n     * <p>\n     * The iterator is immediately advanced until it reaches the position at {@code offset},\n     * incurring O(n) time.\n     *\n     * @param iterator  the iterator to be decorated\n     * @param offset  the index of the first element of the decorated iterator to return\n     * @param max  the maximum number of elements of the decorated iterator to return\n     * @throws NullPointerException if iterator is null\n     * @throws IllegalArgumentException if either offset or max is negative\n     */\n    public BoundedIterator(final Iterator<? extends E> iterator, final long offset, final long max) {\n        if (offset < 0) {\n            throw new IllegalArgumentException(\"Offset parameter must not be negative.\");\n        }\n        if (max < 0) {\n            throw new IllegalArgumentException(\"Max parameter must not be negative.\");\n        }\n\n        this.iterator = Objects.requireNonNull(iterator, \"iterator\");\n        this.offset = offset;\n        this.max = max;\n        pos = 0;\n        init();\n    }\n\n    /**\n     * Checks whether the iterator is still within its bounded range.\n     * @return {@code true} if the iterator is within its bounds, {@code false} otherwise\n     */\n    private boolean checkBounds() {\n        if (pos - offset + 1 > max) {\n            return false;\n        }\n        return true;\n    }\n\n    @Override\n    public boolean hasNext() {\n        if (!checkBounds()) {\n            return false;\n        }\n        return iterator.hasNext();\n    }\n\n    /**\n     * Advances the underlying iterator to the beginning of the bounded range.\n     */\n    private void init() {\n        while (pos < offset && iterator.hasNext()) {\n            iterator.next();\n            pos++;\n        }\n    }\n\n    @Override\n    public E next() {\n        if (!checkBounds()) {\n            throw new NoSuchElementException();\n        }\n        final E next = iterator.next();\n        pos++;\n        return next;\n    }\n\n    /**\n     * {@inheritDoc}\n     * <p>\n     * In case an offset other than 0 was specified, the underlying iterator will be advanced\n     * to this position upon creation. A call to {@link #remove()} will still result in an\n     * {@link IllegalStateException} if no explicit call to {@link #next()} has been made prior\n     * to calling {@link #remove()}.\n     */\n    @Override\n    public void remove() {\n        if (pos <= offset) {\n            throw new IllegalStateException(\"remove() can not be called before calling next()\");\n        }\n        iterator.remove();\n    }\n}", "super_interfaces": ["Iterator<E>"], "fields": [{"attribute_expression": "private final Iterator<? extends E> iterator;", "docstring": " The iterator being decorated.", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Iterator<? extends E>", "name": "iterator", "syntax_pass": true}, {"attribute_expression": "private final long offset;", "docstring": " The offset to bound the first element return", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "long", "name": "offset", "syntax_pass": true}, {"attribute_expression": "private final long max;", "docstring": " The max number of elements to return", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "long", "name": "max", "syntax_pass": true}, {"attribute_expression": "private long pos;", "docstring": " The position of the current element", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "long", "name": "pos", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/iterators/EmptyMapIterator.java.EmptyMapIterator", "name": "EmptyMapIterator", "file_path": "src/main/java/org/apache/commons/collections4/iterators/EmptyMapIterator.java", "superclasses": "", "methods": ["[MapIterator<K, V>]emptyMapIterator()", "[]EmptyMapIterator()"], "method_uris": ["src/main/java/org/apache/commons/collections4/iterators/EmptyMapIterator.java.EmptyMapIterator.[MapIterator<K, V>]emptyMapIterator()", "src/main/java/org/apache/commons/collections4/iterators/EmptyMapIterator.java.EmptyMapIterator.[]EmptyMapIterator()"], "overrides": null, "attributes": [], "class_docstring": "\nProvides an implementation of an empty map iterator.\n\n@param <K> the type of keys\n@param <V> the type of mapped values\n@since 3.1\n", "original_string": "public class EmptyMapIterator<K, V> extends AbstractEmptyMapIterator<K, V> implements\n        MapIterator<K, V> {\n\n    /**\n     * Singleton instance of the iterator.\n     * @since 3.1\n     */\n    @SuppressWarnings(\"rawtypes\")\n    public static final MapIterator INSTANCE = new EmptyMapIterator<>();\n\n    /**\n     * Gets a typed instance of the iterator.\n     * @param <K> the key type\n     * @param <V> the value type\n     * @return {@link MapIterator}&lt;K, V&gt;\n     */\n    public static <K, V> MapIterator<K, V> emptyMapIterator() {\n        return INSTANCE;\n    }\n\n    /**\n     * Constructs a new instance.\n     */\n    protected EmptyMapIterator() {\n    }\n\n}", "super_interfaces": ["MapIterator<K, V>"], "fields": [{"attribute_expression": "@SuppressWarnings(\"rawtypes\")\n    public static final MapIterator INSTANCE = new EmptyMapIterator<>();", "docstring": "\nSingleton instance of the iterator.\n@since 3.1\n", "modifiers": "@SuppressWarnings(\"rawtypes\")\n    public static final", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"rawtypes\")", "public", "static", "final"], "comments": [], "type": "MapIterator", "name": "INSTANCE = new EmptyMapIterator<>()", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/iterators/UnmodifiableIterator.java.UnmodifiableIterator", "name": "UnmodifiableIterator", "file_path": "src/main/java/org/apache/commons/collections4/iterators/UnmodifiableIterator.java", "superclasses": "", "methods": ["[Iterator<E>]unmodifiableIterator(Iterator<? extends E>)", "[]UnmodifiableIterator(Iterator<? extends E>)", "[boolean]hasNext()", "[E]next()", "[void]remove()"], "method_uris": ["src/main/java/org/apache/commons/collections4/iterators/UnmodifiableIterator.java.UnmodifiableIterator.[Iterator<E>]unmodifiableIterator(Iterator<? extends E>)", "src/main/java/org/apache/commons/collections4/iterators/UnmodifiableIterator.java.UnmodifiableIterator.[]UnmodifiableIterator(Iterator<? extends E>)", "src/main/java/org/apache/commons/collections4/iterators/UnmodifiableIterator.java.UnmodifiableIterator.[boolean]hasNext()", "src/main/java/org/apache/commons/collections4/iterators/UnmodifiableIterator.java.UnmodifiableIterator.[E]next()", "src/main/java/org/apache/commons/collections4/iterators/UnmodifiableIterator.java.UnmodifiableIterator.[void]remove()"], "overrides": null, "attributes": [], "class_docstring": "\nDecorates an iterator such that it cannot be modified.\n<p>\nAttempts to modify it will result in an UnsupportedOperationException.\n</p>\n\n@param <E> the type of elements returned by this iterator.\n@since 3.0\n", "original_string": "public final class UnmodifiableIterator<E> implements Iterator<E>, Unmodifiable {\n\n    /**\n     * Decorates the specified iterator such that it cannot be modified.\n     * <p>\n     * If the iterator is already unmodifiable it is returned directly.\n     *\n     * @param <E>  the element type\n     * @param iterator  the iterator to decorate\n     * @return a new unmodifiable iterator\n     * @throws NullPointerException if the iterator is null\n     */\n    public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator) {\n        Objects.requireNonNull(iterator, \"iterator\");\n        if (iterator instanceof Unmodifiable) {\n            @SuppressWarnings(\"unchecked\") // safe to upcast\n            final Iterator<E> tmpIterator = (Iterator<E>) iterator;\n            return tmpIterator;\n        }\n        return new UnmodifiableIterator<>(iterator);\n    }\n\n    /** The iterator being decorated */\n    private final Iterator<? extends E> iterator;\n\n    /**\n     * Constructs a new instance.\n     *\n     * @param iterator  the iterator to decorate\n     */\n    private UnmodifiableIterator(final Iterator<? extends E> iterator) {\n        this.iterator = iterator;\n    }\n\n    @Override\n    public boolean hasNext() {\n        return iterator.hasNext();\n    }\n\n    @Override\n    public E next() {\n        return iterator.next();\n    }\n\n    @Override\n    public void remove() {\n        throw new UnsupportedOperationException(\"remove() is not supported\");\n    }\n\n}", "super_interfaces": ["Iterator<E>", "Unmodifiable"], "fields": [{"attribute_expression": "private final Iterator<? extends E> iterator;", "docstring": " The iterator being decorated", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Iterator<? extends E>", "name": "iterator", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/iterators/PushbackIterator.java.PushbackIterator", "name": "PushbackIterator", "file_path": "src/main/java/org/apache/commons/collections4/iterators/PushbackIterator.java", "superclasses": "", "methods": ["[PushbackIterator<E>]pushbackIterator(Iterator<? extends E>)", "[]PushbackIterator(Iterator<? extends E>)", "[boolean]hasNext()", "[E]next()", "[void]pushback(E)", "[void]remove()"], "method_uris": ["src/main/java/org/apache/commons/collections4/iterators/PushbackIterator.java.PushbackIterator.[PushbackIterator<E>]pushbackIterator(Iterator<? extends E>)", "src/main/java/org/apache/commons/collections4/iterators/PushbackIterator.java.PushbackIterator.[]PushbackIterator(Iterator<? extends E>)", "src/main/java/org/apache/commons/collections4/iterators/PushbackIterator.java.PushbackIterator.[boolean]hasNext()", "src/main/java/org/apache/commons/collections4/iterators/PushbackIterator.java.PushbackIterator.[E]next()", "src/main/java/org/apache/commons/collections4/iterators/PushbackIterator.java.PushbackIterator.[void]pushback(E)", "src/main/java/org/apache/commons/collections4/iterators/PushbackIterator.java.PushbackIterator.[void]remove()"], "overrides": null, "attributes": [], "class_docstring": "\nDecorates an iterator to support pushback of elements.\n<p>\nThe decorator stores the pushed back elements in a LIFO manner: the last element\nthat has been pushed back, will be returned as the next element in a call to {@link #next()}.\n<p>\nThe decorator does not support the removal operation. Any call to {@link #remove()} will\nresult in an {@link UnsupportedOperationException}.\n\n@param <E> the type of elements returned by this iterator.\n@since 4.0\n", "original_string": "public class PushbackIterator<E> implements Iterator<E> {\n\n    /**\n     * Decorates the specified iterator to support one-element lookahead.\n     * <p>\n     * If the iterator is already a {@link PushbackIterator} it is returned directly.\n     *\n     * @param <E>  the element type\n     * @param iterator  the iterator to decorate\n     * @return a new peeking iterator\n     * @throws NullPointerException if the iterator is null\n     */\n    public static <E> PushbackIterator<E> pushbackIterator(final Iterator<? extends E> iterator) {\n        Objects.requireNonNull(iterator, \"iterator\");\n        if (iterator instanceof PushbackIterator<?>) {\n            @SuppressWarnings(\"unchecked\") // safe cast\n            final PushbackIterator<E> it = (PushbackIterator<E>) iterator;\n            return it;\n        }\n        return new PushbackIterator<>(iterator);\n    }\n\n    /** The iterator being decorated. */\n    private final Iterator<? extends E> iterator;\n\n    /** The LIFO queue containing the pushed back items. */\n    private final Deque<E> items = new ArrayDeque<>();\n\n    /**\n     * Constructs a new instance.\n     *\n     * @param iterator  the iterator to decorate\n     */\n    public PushbackIterator(final Iterator<? extends E> iterator) {\n        this.iterator = iterator;\n    }\n\n    @Override\n    public boolean hasNext() {\n        return !items.isEmpty() || iterator.hasNext();\n    }\n\n    @Override\n    public E next() {\n        return !items.isEmpty() ? items.pop() : iterator.next();\n    }\n\n    /**\n     * Push back the given element to the iterator.\n     * <p>\n     * Calling {@link #next()} immediately afterwards will return exactly this element.\n     *\n     * @param item  the element to push back to the iterator\n     */\n    public void pushback(final E item) {\n        items.push(item);\n    }\n\n    /**\n     * This iterator will always throw an {@link UnsupportedOperationException}.\n     *\n     * @throws UnsupportedOperationException always\n     */\n    @Override\n    public void remove() {\n        throw new UnsupportedOperationException();\n    }\n\n}", "super_interfaces": ["Iterator<E>"], "fields": [{"attribute_expression": "private final Iterator<? extends E> iterator;", "docstring": " The iterator being decorated.", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Iterator<? extends E>", "name": "iterator", "syntax_pass": true}, {"attribute_expression": "private final Deque<E> items = new ArrayDeque<>();", "docstring": " The LIFO queue containing the pushed back items.", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Deque<E>", "name": "items = new ArrayDeque<>()", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/iterators/PeekingIterator.java.PeekingIterator", "name": "PeekingIterator", "file_path": "src/main/java/org/apache/commons/collections4/iterators/PeekingIterator.java", "superclasses": "", "methods": ["[PeekingIterator<E>]peekingIterator(Iterator<? extends E>)", "[]PeekingIterator(Iterator<? extends E>)", "[E]element()", "[void]fill()", "[boolean]hasNext()", "[E]next()", "[E]peek()", "[void]remove()"], "method_uris": ["src/main/java/org/apache/commons/collections4/iterators/PeekingIterator.java.PeekingIterator.[PeekingIterator<E>]peekingIterator(Iterator<? extends E>)", "src/main/java/org/apache/commons/collections4/iterators/PeekingIterator.java.PeekingIterator.[]PeekingIterator(Iterator<? extends E>)", "src/main/java/org/apache/commons/collections4/iterators/PeekingIterator.java.PeekingIterator.[E]element()", "src/main/java/org/apache/commons/collections4/iterators/PeekingIterator.java.PeekingIterator.[void]fill()", "src/main/java/org/apache/commons/collections4/iterators/PeekingIterator.java.PeekingIterator.[boolean]hasNext()", "src/main/java/org/apache/commons/collections4/iterators/PeekingIterator.java.PeekingIterator.[E]next()", "src/main/java/org/apache/commons/collections4/iterators/PeekingIterator.java.PeekingIterator.[E]peek()", "src/main/java/org/apache/commons/collections4/iterators/PeekingIterator.java.PeekingIterator.[void]remove()"], "overrides": null, "attributes": [], "class_docstring": "\nDecorates an iterator to support one-element lookahead while iterating.\n<p>\nThe decorator supports the removal operation, but an {@link IllegalStateException}\nwill be thrown if {@link #remove()} is called directly after a call to\n{@link #peek()} or {@link #element()}.\n\n@param <E> the type of elements returned by this iterator.\n@since 4.0\n", "original_string": "public class PeekingIterator<E> implements Iterator<E> {\n\n    /**\n     * Decorates the specified iterator to support one-element lookahead.\n     * <p>\n     * If the iterator is already a {@link PeekingIterator} it is returned directly.\n     *\n     * @param <E>  the element type\n     * @param iterator  the iterator to decorate\n     * @return a new peeking iterator\n     * @throws NullPointerException if the iterator is null\n     */\n    public static <E> PeekingIterator<E> peekingIterator(final Iterator<? extends E> iterator) {\n        Objects.requireNonNull(iterator, \"iterator\");\n        if (iterator instanceof PeekingIterator<?>) {\n            @SuppressWarnings(\"unchecked\") // safe cast\n            final PeekingIterator<E> it = (PeekingIterator<E>) iterator;\n            return it;\n        }\n        return new PeekingIterator<>(iterator);\n    }\n\n    /** The iterator being decorated. */\n    private final Iterator<? extends E> iterator;\n\n    /** Indicates that the decorated iterator is exhausted. */\n    private boolean exhausted;\n\n    /** Indicates if the lookahead slot is filled. */\n    private boolean slotFilled;\n\n    /** The current slot for lookahead. */\n    private E slot;\n\n    /**\n     * Constructs a new instance.\n     *\n     * @param iterator  the iterator to decorate\n     */\n    public PeekingIterator(final Iterator<? extends E> iterator) {\n        this.iterator = iterator;\n    }\n\n    /**\n     * Returns the next element in iteration without advancing the underlying iterator.\n     * If the iterator is already exhausted, null will be returned.\n     *\n     * @return the next element from the iterator\n     * @throws NoSuchElementException if the iterator is already exhausted according to {@link #hasNext()}\n     */\n    public E element() {\n        fill();\n        if (exhausted) {\n            throw new NoSuchElementException();\n        }\n        return slot;\n    }\n\n    private void fill() {\n        if (exhausted || slotFilled) {\n            return;\n        }\n        if (iterator.hasNext()) {\n            slot = iterator.next();\n            slotFilled = true;\n        } else {\n            exhausted = true;\n            slot = null;\n            slotFilled = false;\n        }\n    }\n\n    @Override\n    public boolean hasNext() {\n        if (exhausted) {\n            return false;\n        }\n        return slotFilled || iterator.hasNext();\n    }\n\n    @Override\n    public E next() {\n        if (!hasNext()) {\n            throw new NoSuchElementException();\n        }\n        final E x = slotFilled ? slot : iterator.next();\n        // reset the lookahead slot\n        slot = null;\n        slotFilled = false;\n        return x;\n    }\n\n    /**\n     * Returns the next element in iteration without advancing the underlying iterator.\n     * If the iterator is already exhausted, null will be returned.\n     * <p>\n     * Note: this method does not throw a {@link NoSuchElementException} if the iterator\n     * is already exhausted. If you want such a behavior, use {@link #element()} instead.\n     * <p>\n     * The rationale behind this is to follow the {@link java.util.Queue} interface\n     * which uses the same terminology.\n     *\n     * @return the next element from the iterator\n     */\n    public E peek() {\n        fill();\n        return exhausted ? null : slot;\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * @throws IllegalStateException if {@link #peek()} or {@link #element()} has been called\n     *   prior to the call to {@link #remove()}\n     */\n    @Override\n    public void remove() {\n        if (slotFilled) {\n            throw new IllegalStateException(\"peek() or element() called before remove()\");\n        }\n        iterator.remove();\n    }\n\n}", "super_interfaces": ["Iterator<E>"], "fields": [{"attribute_expression": "private final Iterator<? extends E> iterator;", "docstring": " The iterator being decorated.", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Iterator<? extends E>", "name": "iterator", "syntax_pass": true}, {"attribute_expression": "private boolean exhausted;", "docstring": " Indicates that the decorated iterator is exhausted.", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "exhausted", "syntax_pass": true}, {"attribute_expression": "private boolean slotFilled;", "docstring": " Indicates if the lookahead slot is filled.", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "slotFilled", "syntax_pass": true}, {"attribute_expression": "private E slot;", "docstring": " The current slot for lookahead.", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "E", "name": "slot", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/iterators/NodeListIterator.java.NodeListIterator", "name": "NodeListIterator", "file_path": "src/main/java/org/apache/commons/collections4/iterators/NodeListIterator.java", "superclasses": "", "methods": ["[]NodeListIterator(Node)", "[]NodeListIterator(NodeList)", "[boolean]hasNext()", "[Node]next()", "[void]remove()"], "method_uris": ["src/main/java/org/apache/commons/collections4/iterators/NodeListIterator.java.NodeListIterator.[]NodeListIterator(Node)", "src/main/java/org/apache/commons/collections4/iterators/NodeListIterator.java.NodeListIterator.[]NodeListIterator(NodeList)", "src/main/java/org/apache/commons/collections4/iterators/NodeListIterator.java.NodeListIterator.[boolean]hasNext()", "src/main/java/org/apache/commons/collections4/iterators/NodeListIterator.java.NodeListIterator.[Node]next()", "src/main/java/org/apache/commons/collections4/iterators/NodeListIterator.java.NodeListIterator.[void]remove()"], "overrides": null, "attributes": [], "class_docstring": "\nAn {@link Iterator} over a {@link NodeList}.\n<p>\nThis iterator does not support {@link #remove()} as a {@link NodeList} does not support\nremoval of items.\n\n@since 4.0\n@see NodeList\n", "original_string": "public class NodeListIterator implements Iterator<Node> {\n\n    /** The original NodeList instance */\n    private final NodeList nodeList;\n    /** The current iterator index */\n    private int index;\n\n    /**\n     * Convenience constructor, which creates a new NodeListIterator from\n     * the specified node's childNodes.\n     *\n     * @param node Node, whose child nodes are wrapped by this class. Must not be null\n     * @throws NullPointerException if node is null\n     */\n    public NodeListIterator(final Node node) {\n        Objects.requireNonNull(node, \"node\");\n        this.nodeList = node.getChildNodes();\n    }\n\n    /**\n     * Constructor, that creates a new NodeListIterator from the specified\n     * {@code org.w3c.NodeList}\n     *\n     * @param nodeList node list, which is wrapped by this class. Must not be null\n     * @throws NullPointerException if nodeList is null\n     */\n    public NodeListIterator(final NodeList nodeList) {\n        this.nodeList = Objects.requireNonNull(nodeList, \"nodeList\");\n    }\n\n    @Override\n    public boolean hasNext() {\n        return nodeList != null && index < nodeList.getLength();\n    }\n\n    @Override\n    public Node next() {\n        if (nodeList != null && index < nodeList.getLength()) {\n            return nodeList.item(index++);\n        }\n        throw new NoSuchElementException(\"underlying nodeList has no more elements\");\n    }\n\n    /**\n     * Throws {@link UnsupportedOperationException}.\n     *\n     * @throws UnsupportedOperationException always\n     */\n    @Override\n    public void remove() {\n        throw new UnsupportedOperationException(\"remove() method not supported for a NodeListIterator.\");\n    }\n}", "super_interfaces": ["Iterator<Node>"], "fields": [{"attribute_expression": "private final NodeList nodeList;", "docstring": " The original NodeList instance", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "NodeList", "name": "nodeList", "syntax_pass": true}, {"attribute_expression": "private int index;", "docstring": " The current iterator index", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "index", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/iterators/EnumerationIterator.java.EnumerationIterator", "name": "EnumerationIterator", "file_path": "src/main/java/org/apache/commons/collections4/iterators/EnumerationIterator.java", "superclasses": "", "methods": ["[]EnumerationIterator()", "[]EnumerationIterator(Enumeration<? extends E>)", "[]EnumerationIterator(Enumeration<? extends E>,Collection<? super E>)", "[Enumeration<? extends E>]getEnumeration()", "[boolean]hasNext()", "[E]next()", "[void]remove()", "[void]setEnumeration(Enumeration<? extends E>)"], "method_uris": ["src/main/java/org/apache/commons/collections4/iterators/EnumerationIterator.java.EnumerationIterator.[]EnumerationIterator()", "src/main/java/org/apache/commons/collections4/iterators/EnumerationIterator.java.EnumerationIterator.[]EnumerationIterator(Enumeration<? extends E>)", "src/main/java/org/apache/commons/collections4/iterators/EnumerationIterator.java.EnumerationIterator.[]EnumerationIterator(Enumeration<? extends E>,Collection<? super E>)", "src/main/java/org/apache/commons/collections4/iterators/EnumerationIterator.java.EnumerationIterator.[Enumeration<? extends E>]getEnumeration()", "src/main/java/org/apache/commons/collections4/iterators/EnumerationIterator.java.EnumerationIterator.[boolean]hasNext()", "src/main/java/org/apache/commons/collections4/iterators/EnumerationIterator.java.EnumerationIterator.[E]next()", "src/main/java/org/apache/commons/collections4/iterators/EnumerationIterator.java.EnumerationIterator.[void]remove()", "src/main/java/org/apache/commons/collections4/iterators/EnumerationIterator.java.EnumerationIterator.[void]setEnumeration(Enumeration<? extends E>)"], "overrides": null, "attributes": [], "class_docstring": "\nAdapter to make {@link Enumeration Enumeration} instances appear\nto be {@link Iterator Iterator} instances.\n\n@param <E> the type of elements returned by this iterator.\n@since 1.0\n", "original_string": "public class EnumerationIterator<E> implements Iterator<E> {\n\n    /** The collection to remove elements from */\n    private final Collection<? super E> collection;\n    /** The enumeration being converted */\n    private Enumeration<? extends E> enumeration;\n    /** The last object retrieved */\n    private E last;\n\n    // Constructors\n    /**\n     * Constructs a new {@code EnumerationIterator} that will not\n     * function until {@link #setEnumeration(Enumeration)} is called.\n     */\n    public EnumerationIterator() {\n        this(null, null);\n    }\n\n    /**\n     * Constructs a new {@code EnumerationIterator} that provides\n     * an iterator view of the given enumeration.\n     *\n     * @param enumeration  the enumeration to use\n     */\n    public EnumerationIterator(final Enumeration<? extends E> enumeration) {\n        this(enumeration, null);\n    }\n\n    /**\n     * Constructs a new {@code EnumerationIterator} that will remove\n     * elements from the specified collection.\n     *\n     * @param enumeration  the enumeration to use\n     * @param collection  the collection to remove elements from\n     */\n    public EnumerationIterator(final Enumeration<? extends E> enumeration, final Collection<? super E> collection) {\n        this.enumeration = enumeration;\n        this.collection = collection;\n        this.last = null;\n    }\n\n    // Properties\n    /**\n     * Returns the underlying enumeration.\n     *\n     * @return the underlying enumeration\n     */\n    public Enumeration<? extends E> getEnumeration() {\n        return enumeration;\n    }\n\n    // Iterator interface\n    /**\n     * Returns true if the underlying enumeration has more elements.\n     *\n     * @return true if the underlying enumeration has more elements\n     * @throws NullPointerException  if the underlying enumeration is null\n     */\n    @Override\n    public boolean hasNext() {\n        return enumeration.hasMoreElements();\n    }\n\n    /**\n     * Returns the next object from the enumeration.\n     *\n     * @return the next object from the enumeration\n     * @throws NullPointerException if the enumeration is null\n     */\n    @Override\n    public E next() {\n        last = enumeration.nextElement();\n        return last;\n    }\n\n    /**\n     * Removes the last retrieved element if a collection is attached.\n     * <p>\n     * Functions if an associated {@code Collection} is known.\n     * If so, the first occurrence of the last returned object from this\n     * iterator will be removed from the collection.\n     *\n     * @throws IllegalStateException {@code next()} not called.\n     * @throws UnsupportedOperationException if no associated collection\n     */\n    @Override\n    public void remove() {\n        if (collection == null) {\n            throw new UnsupportedOperationException(\"No Collection associated with this Iterator\");\n        }\n        if (last == null) {\n            throw new IllegalStateException(\"next() must have been called for remove() to function\");\n        }\n        collection.remove(last);\n    }\n\n    /**\n     * Sets the underlying enumeration.\n     *\n     * @param enumeration  the new underlying enumeration\n     */\n    public void setEnumeration(final Enumeration<? extends E> enumeration) {\n        this.enumeration = enumeration;\n    }\n\n}", "super_interfaces": ["Iterator<E>"], "fields": [{"attribute_expression": "private final Collection<? super E> collection;", "docstring": " The collection to remove elements from", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Collection<? super E>", "name": "collection", "syntax_pass": true}, {"attribute_expression": "private Enumeration<? extends E> enumeration;", "docstring": " The enumeration being converted", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Enumeration<? extends E>", "name": "enumeration", "syntax_pass": true}, {"attribute_expression": "private E last;", "docstring": " The last object retrieved", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "E", "name": "last", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/iterators/AbstractOrderedMapIteratorDecorator.java.AbstractOrderedMapIteratorDecorator", "name": "AbstractOrderedMapIteratorDecorator", "file_path": "src/main/java/org/apache/commons/collections4/iterators/AbstractOrderedMapIteratorDecorator.java", "superclasses": "", "methods": ["[]AbstractOrderedMapIteratorDecorator(OrderedMapIterator<K, V>)", "[K]getKey()", "[OrderedMapIterator<K, V>]getOrderedMapIterator()", "[V]getValue()", "[boolean]hasNext()", "[boolean]hasPrevious()", "[K]next()", "[K]previous()", "[void]remove()", "[V]setValue(V)"], "method_uris": ["src/main/java/org/apache/commons/collections4/iterators/AbstractOrderedMapIteratorDecorator.java.AbstractOrderedMapIteratorDecorator.[]AbstractOrderedMapIteratorDecorator(OrderedMapIterator<K, V>)", "src/main/java/org/apache/commons/collections4/iterators/AbstractOrderedMapIteratorDecorator.java.AbstractOrderedMapIteratorDecorator.[K]getKey()", "src/main/java/org/apache/commons/collections4/iterators/AbstractOrderedMapIteratorDecorator.java.AbstractOrderedMapIteratorDecorator.[OrderedMapIterator<K, V>]getOrderedMapIterator()", "src/main/java/org/apache/commons/collections4/iterators/AbstractOrderedMapIteratorDecorator.java.AbstractOrderedMapIteratorDecorator.[V]getValue()", "src/main/java/org/apache/commons/collections4/iterators/AbstractOrderedMapIteratorDecorator.java.AbstractOrderedMapIteratorDecorator.[boolean]hasNext()", "src/main/java/org/apache/commons/collections4/iterators/AbstractOrderedMapIteratorDecorator.java.AbstractOrderedMapIteratorDecorator.[boolean]hasPrevious()", "src/main/java/org/apache/commons/collections4/iterators/AbstractOrderedMapIteratorDecorator.java.AbstractOrderedMapIteratorDecorator.[K]next()", "src/main/java/org/apache/commons/collections4/iterators/AbstractOrderedMapIteratorDecorator.java.AbstractOrderedMapIteratorDecorator.[K]previous()", "src/main/java/org/apache/commons/collections4/iterators/AbstractOrderedMapIteratorDecorator.java.AbstractOrderedMapIteratorDecorator.[void]remove()", "src/main/java/org/apache/commons/collections4/iterators/AbstractOrderedMapIteratorDecorator.java.AbstractOrderedMapIteratorDecorator.[V]setValue(V)"], "overrides": null, "attributes": [], "class_docstring": "\nProvides basic behavior for decorating an ordered map iterator with extra functionality.\n<p>\nAll methods are forwarded to the decorated map iterator.\n\n@param <K> the type of keys\n@param <V> the type of mapped values\n@since 3.0\n", "original_string": "public class AbstractOrderedMapIteratorDecorator<K, V> implements OrderedMapIterator<K, V> {\n\n    /** The iterator being decorated */\n    private final OrderedMapIterator<K, V> iterator;\n\n    /**\n     * Constructor that decorates the specified iterator.\n     *\n     * @param iterator  the iterator to decorate, must not be null\n     * @throws NullPointerException if the iterator is null\n     */\n    public AbstractOrderedMapIteratorDecorator(final OrderedMapIterator<K, V> iterator) {\n        this.iterator = Objects.requireNonNull(iterator, \"iterator\");\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public K getKey() {\n        return iterator.getKey();\n    }\n\n    /**\n     * Gets the iterator being decorated.\n     *\n     * @return the decorated iterator\n     */\n    protected OrderedMapIterator<K, V> getOrderedMapIterator() {\n        return iterator;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public V getValue() {\n        return iterator.getValue();\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean hasNext() {\n        return iterator.hasNext();\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean hasPrevious() {\n        return iterator.hasPrevious();\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public K next() {\n        return iterator.next();\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public K previous() {\n        return iterator.previous();\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void remove() {\n        iterator.remove();\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public V setValue(final V value) {\n        return iterator.setValue(value);\n    }\n\n}", "super_interfaces": ["OrderedMapIterator<K, V>"], "fields": [{"attribute_expression": "private final OrderedMapIterator<K, V> iterator;", "docstring": " The iterator being decorated", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "OrderedMapIterator<K, V>", "name": "iterator", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/iterators/SkippingIterator.java.SkippingIterator", "name": "SkippingIterator", "file_path": "src/main/java/org/apache/commons/collections4/iterators/SkippingIterator.java", "superclasses": "", "methods": ["[]SkippingIterator(Iterator<E>,long)", "[void]init()", "[E]next()", "[void]remove()"], "method_uris": ["src/main/java/org/apache/commons/collections4/iterators/SkippingIterator.java.SkippingIterator.[]SkippingIterator(Iterator<E>,long)", "src/main/java/org/apache/commons/collections4/iterators/SkippingIterator.java.SkippingIterator.[void]init()", "src/main/java/org/apache/commons/collections4/iterators/SkippingIterator.java.SkippingIterator.[E]next()", "src/main/java/org/apache/commons/collections4/iterators/SkippingIterator.java.SkippingIterator.[void]remove()"], "overrides": null, "attributes": [], "class_docstring": "\nDecorates another iterator to skip the first N elements.\n<p>\nIn case an offset parameter other than 0 is provided, the decorated\niterator is immediately advanced to this position, skipping all elements\nbefore that position.\n</p>\n\n@param <E> the type of elements returned by this iterator.\n@since 4.1\n", "original_string": "public class SkippingIterator<E> extends AbstractIteratorDecorator<E> {\n\n    /** The offset to bound the first element return */\n    private final long offset;\n\n    /** The position of the current element */\n    private long pos;\n\n    /**\n     * Decorates the specified iterator to skip all elements until the iterator\n     * reaches the position at {@code offset}.\n     * <p>\n     * The iterator is immediately advanced until it reaches the position at {@code offset},\n     * incurring O(n) time.\n     *\n     * @param iterator  the iterator to be decorated\n     * @param offset  the index of the first element of the decorated iterator to return\n     * @throws NullPointerException if iterator is null\n     * @throws IllegalArgumentException if offset is negative\n     */\n    public SkippingIterator(final Iterator<E> iterator, final long offset) {\n        super(iterator);\n\n        if (offset < 0) {\n            throw new IllegalArgumentException(\"Offset parameter must not be negative.\");\n        }\n\n        this.offset = offset;\n        this.pos = 0;\n        init();\n    }\n\n    /**\n     * Skips the given number of elements.\n     */\n    private void init() {\n        while (pos < offset && hasNext()) {\n            next();\n        }\n    }\n\n    @Override\n    public E next() {\n        final E next = super.next();\n        pos++;\n        return next;\n    }\n\n    /**\n     * {@inheritDoc}\n     * <p>\n     * In case an offset other than 0 was specified, the underlying iterator will be advanced\n     * to this position upon creation. A call to {@link #remove()} will still result in an\n     * {@link IllegalStateException} if no explicit call to {@link #next()} has been made prior\n     * to calling {@link #remove()}.\n     */\n    @Override\n    public void remove() {\n        if (pos <= offset) {\n            throw new IllegalStateException(\"remove() can not be called before calling next()\");\n        }\n        super.remove();\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final long offset;", "docstring": " The offset to bound the first element return", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "long", "name": "offset", "syntax_pass": true}, {"attribute_expression": "private long pos;", "docstring": " The position of the current element", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "long", "name": "pos", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/iterators/ArrayListIterator.java.ArrayListIterator", "name": "ArrayListIterator", "file_path": "src/main/java/org/apache/commons/collections4/iterators/ArrayListIterator.java", "superclasses": "", "methods": ["[]ArrayListIterator(Object)", "[]ArrayListIterator(Object,int)", "[]ArrayListIterator(Object,int,int)", "[void]add(Object)", "[boolean]hasPrevious()", "[E]next()", "[int]nextIndex()", "[E]previous()", "[int]previousIndex()", "[void]reset()", "[void]set(Object)"], "method_uris": ["src/main/java/org/apache/commons/collections4/iterators/ArrayListIterator.java.ArrayListIterator.[]ArrayListIterator(Object)", "src/main/java/org/apache/commons/collections4/iterators/ArrayListIterator.java.ArrayListIterator.[]ArrayListIterator(Object,int)", "src/main/java/org/apache/commons/collections4/iterators/ArrayListIterator.java.ArrayListIterator.[]ArrayListIterator(Object,int,int)", "src/main/java/org/apache/commons/collections4/iterators/ArrayListIterator.java.ArrayListIterator.[void]add(Object)", "src/main/java/org/apache/commons/collections4/iterators/ArrayListIterator.java.ArrayListIterator.[boolean]hasPrevious()", "src/main/java/org/apache/commons/collections4/iterators/ArrayListIterator.java.ArrayListIterator.[E]next()", "src/main/java/org/apache/commons/collections4/iterators/ArrayListIterator.java.ArrayListIterator.[int]nextIndex()", "src/main/java/org/apache/commons/collections4/iterators/ArrayListIterator.java.ArrayListIterator.[E]previous()", "src/main/java/org/apache/commons/collections4/iterators/ArrayListIterator.java.ArrayListIterator.[int]previousIndex()", "src/main/java/org/apache/commons/collections4/iterators/ArrayListIterator.java.ArrayListIterator.[void]reset()", "src/main/java/org/apache/commons/collections4/iterators/ArrayListIterator.java.ArrayListIterator.[void]set(Object)"], "overrides": null, "attributes": [], "class_docstring": "\nImplements a {@link java.util.ListIterator} over an array.\n<p>\nThe array can be either an array of object or of primitives. If you know\nthat you have an object array, the {@link ObjectArrayListIterator}\nclass is a better choice, as it will perform better.\n\n<p>\nThis iterator does not support {@link #add(Object)} or {@link #remove()}, as the array\ncannot be changed in size. The {@link #set(Object)} method is supported however.\n\n@param <E> the type of elements returned by this iterator.\n@see org.apache.commons.collections4.iterators.ArrayIterator\n@see java.util.Iterator\n@see java.util.ListIterator\n\n@since 3.0\n", "original_string": "public class ArrayListIterator<E> extends ArrayIterator<E>\n        implements ResettableListIterator<E> {\n\n    /**\n     * Holds the index of the last item returned by a call to {@code next()}\n     * or {@code previous()}. This is set to {@code -1} if neither method\n     * has yet been invoked. {@code lastItemIndex} is used to implement\n     * the {@link #set} method.\n     */\n    private int lastItemIndex = -1;\n\n    /**\n     * Constructs an ArrayListIterator that will iterate over the values in the\n     * specified array.\n     *\n     * @param array the array to iterate over\n     * @throws IllegalArgumentException if {@code array} is not an array.\n     * @throws NullPointerException if {@code array} is {@code null}\n     */\n    public ArrayListIterator(final Object array) {\n        super(array);\n    }\n\n    /**\n     * Constructs an ArrayListIterator that will iterate over the values in the\n     * specified array from a specific start index.\n     *\n     * @param array  the array to iterate over\n     * @param startIndex  the index to start iterating at\n     * @throws IllegalArgumentException if {@code array} is not an array.\n     * @throws NullPointerException if {@code array} is {@code null}\n     * @throws IndexOutOfBoundsException if the start index is out of bounds\n     */\n    public ArrayListIterator(final Object array, final int startIndex) {\n        super(array, startIndex);\n    }\n\n    /**\n     * Constructs an ArrayListIterator that will iterate over a range of values\n     * in the specified array.\n     *\n     * @param array  the array to iterate over\n     * @param startIndex  the index to start iterating at\n     * @param endIndex  the index (exclusive) to finish iterating at\n     * @throws IllegalArgumentException if {@code array} is not an array.\n     * @throws IndexOutOfBoundsException if the start or end index is out of bounds\n     * @throws IllegalArgumentException if end index is before the start\n     * @throws NullPointerException if {@code array} is {@code null}\n     */\n    public ArrayListIterator(final Object array, final int startIndex, final int endIndex) {\n        super(array, startIndex, endIndex);\n    }\n\n    /**\n     * This iterator does not support modification of its backing collection, and so will\n     * always throw an {@link UnsupportedOperationException} when this method is invoked.\n     *\n     * @param o  the element to add\n     * @throws UnsupportedOperationException always thrown.\n     * @see java.util.ListIterator#set\n     */\n    @Override\n    public void add(final Object o) {\n        throw new UnsupportedOperationException(\"add() method is not supported\");\n    }\n\n    // ListIterator interface\n    /**\n     * Returns true if there are previous elements to return from the array.\n     *\n     * @return true if there is a previous element to return\n     */\n    @Override\n    public boolean hasPrevious() {\n        return index > startIndex;\n    }\n\n    /**\n     * Gets the next element from the array.\n     *\n     * @return the next element\n     * @throws NoSuchElementException if there is no next element\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public E next() {\n        if (!hasNext()) {\n            throw new NoSuchElementException();\n        }\n        lastItemIndex = index;\n        return (E) Array.get(array, index++);\n    }\n\n    /**\n     * Gets the next index to be retrieved.\n     *\n     * @return the index of the item to be retrieved next\n     */\n    @Override\n    public int nextIndex() {\n        return index - startIndex;\n    }\n\n    /**\n     * Gets the previous element from the array.\n     *\n     * @return the previous element\n     * @throws NoSuchElementException if there is no previous element\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public E previous() {\n        if (!hasPrevious()) {\n            throw new NoSuchElementException();\n        }\n        lastItemIndex = --index;\n        return (E) Array.get(array, index);\n    }\n\n    /**\n     * Gets the index of the item to be retrieved if {@link #previous()} is called.\n     *\n     * @return the index of the item to be retrieved next\n     */\n    @Override\n    public int previousIndex() {\n        return index - startIndex - 1;\n    }\n\n    /**\n     * Resets the iterator back to the start index.\n     */\n    @Override\n    public void reset() {\n        super.reset();\n        lastItemIndex = -1;\n    }\n\n    /**\n     * Sets the element under the cursor.\n     * <p>\n     * This method sets the element that was returned by the last call\n     * to {@link #next()} of {@link #previous()}.\n     * <p>\n     * <b>Note:</b> {@link java.util.ListIterator} implementations that support\n     * {@code add()} and {@code remove()} only allow {@code set()} to be called\n     * once per call to {@code next()} or {@code previous} (see the {@link java.util.ListIterator}\n     * Javadoc for more details). Since this implementation does\n     * not support {@code add()} or {@code remove()}, {@code set()} may be\n     * called as often as desired.\n     *\n     * @param o  the element to set\n     * @throws IllegalStateException if {@link #next()} or {@link #previous()} has not been called\n     * before {@link #set(Object)}\n     * @see java.util.ListIterator#set\n     */\n    @Override\n    public void set(final Object o) {\n        if (lastItemIndex == -1) {\n            throw new IllegalStateException(\"must call next() or previous() before a call to set()\");\n        }\n\n        Array.set(array, lastItemIndex, o);\n    }\n\n}", "super_interfaces": ["ResettableListIterator<E>"], "fields": [{"attribute_expression": "private int lastItemIndex = -1;", "docstring": "\nHolds the index of the last item returned by a call to {@code next()}\nor {@code previous()}. This is set to {@code -1} if neither method\nhas yet been invoked. {@code lastItemIndex} is used to implement\nthe {@link #set} method.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "lastItemIndex = -1", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/iterators/EmptyListIterator.java.EmptyListIterator", "name": "EmptyListIterator", "file_path": "src/main/java/org/apache/commons/collections4/iterators/EmptyListIterator.java", "superclasses": "", "methods": ["[ListIterator<E>]emptyListIterator()", "[ResettableListIterator<E>]resettableEmptyListIterator()", "[]EmptyListIterator()"], "method_uris": ["src/main/java/org/apache/commons/collections4/iterators/EmptyListIterator.java.EmptyListIterator.[ListIterator<E>]emptyListIterator()", "src/main/java/org/apache/commons/collections4/iterators/EmptyListIterator.java.EmptyListIterator.[ResettableListIterator<E>]resettableEmptyListIterator()", "src/main/java/org/apache/commons/collections4/iterators/EmptyListIterator.java.EmptyListIterator.[]EmptyListIterator()"], "overrides": null, "attributes": [], "class_docstring": "\nProvides an implementation of an empty list iterator.\n<p>\nThis class provides an implementation of an empty list iterator. This class\nprovides for binary compatibility between Commons Collections 2.1.1 and 3.1\ndue to issues with {@code IteratorUtils}.\n\n@param <E> the type of elements returned by this iterator.\n@since 2.1.1 and 3.1\n", "original_string": "public class EmptyListIterator<E> extends AbstractEmptyIterator<E> implements ResettableListIterator<E> {\n\n    /**\n     * Singleton instance of the iterator.\n     * @since 3.1\n     */\n    @SuppressWarnings(\"rawtypes\")\n    public static final ResettableListIterator RESETTABLE_INSTANCE = new EmptyListIterator<>();\n\n    /**\n     * Singleton instance of the iterator.\n     * @since 2.1.1 and 3.1\n     */\n    @SuppressWarnings(\"rawtypes\")\n    public static final ListIterator INSTANCE = RESETTABLE_INSTANCE;\n\n    /**\n     * Gets a typed instance of the iterator.\n     * @param <E> the element type\n     * @return {@link ListIterator}&lt;E&gt;\n     */\n    public static <E> ListIterator<E> emptyListIterator() {\n        return INSTANCE;\n    }\n\n    /**\n     * Gets a typed instance of the iterator.\n     * @param <E> the element type\n     * @return {@link ResettableListIterator}&lt;E&gt;\n     */\n    public static <E> ResettableListIterator<E> resettableEmptyListIterator() {\n        return RESETTABLE_INSTANCE;\n    }\n\n    /**\n     * Constructs a new instance.\n     */\n    protected EmptyListIterator() {\n    }\n\n}", "super_interfaces": ["ResettableListIterator<E>"], "fields": [{"attribute_expression": "@SuppressWarnings(\"rawtypes\")\n    public static final ResettableListIterator RESETTABLE_INSTANCE = new EmptyListIterator<>();", "docstring": "\nSingleton instance of the iterator.\n@since 3.1\n", "modifiers": "@SuppressWarnings(\"rawtypes\")\n    public static final", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"rawtypes\")", "public", "static", "final"], "comments": [], "type": "ResettableListIterator", "name": "RESETTABLE_INSTANCE = new EmptyListIterator<>()", "syntax_pass": true}, {"attribute_expression": "@SuppressWarnings(\"rawtypes\")\n    public static final ListIterator INSTANCE = RESETTABLE_INSTANCE;", "docstring": "\nSingleton instance of the iterator.\n@since 2.1.1 and 3.1\n", "modifiers": "@SuppressWarnings(\"rawtypes\")\n    public static final", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"rawtypes\")", "public", "static", "final"], "comments": [], "type": "ListIterator", "name": "INSTANCE = RESETTABLE_INSTANCE", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/iterators/IteratorEnumeration.java.IteratorEnumeration", "name": "IteratorEnumeration", "file_path": "src/main/java/org/apache/commons/collections4/iterators/IteratorEnumeration.java", "superclasses": "", "methods": ["[]IteratorEnumeration()", "[]IteratorEnumeration(Iterator<? extends E>)", "[Iterator<? extends E>]getIterator()", "[boolean]hasMoreElements()", "[E]nextElement()", "[void]setIterator(Iterator<? extends E>)"], "method_uris": ["src/main/java/org/apache/commons/collections4/iterators/IteratorEnumeration.java.IteratorEnumeration.[]IteratorEnumeration()", "src/main/java/org/apache/commons/collections4/iterators/IteratorEnumeration.java.IteratorEnumeration.[]IteratorEnumeration(Iterator<? extends E>)", "src/main/java/org/apache/commons/collections4/iterators/IteratorEnumeration.java.IteratorEnumeration.[Iterator<? extends E>]getIterator()", "src/main/java/org/apache/commons/collections4/iterators/IteratorEnumeration.java.IteratorEnumeration.[boolean]hasMoreElements()", "src/main/java/org/apache/commons/collections4/iterators/IteratorEnumeration.java.IteratorEnumeration.[E]nextElement()", "src/main/java/org/apache/commons/collections4/iterators/IteratorEnumeration.java.IteratorEnumeration.[void]setIterator(Iterator<? extends E>)"], "overrides": null, "attributes": [], "class_docstring": "\nAdapter to make an {@link Iterator Iterator} instance appear to be an\n{@link Enumeration Enumeration} instance.\n\n@param <E> the type of elements returned by this iterator.\n@since 1.0\n", "original_string": "public class IteratorEnumeration<E> implements Enumeration<E> {\n\n    /** The iterator being decorated. */\n    private Iterator<? extends E> iterator;\n\n    /**\n     * Constructs a new {@code IteratorEnumeration} that will not function\n     * until {@link #setIterator(Iterator) setIterator} is invoked.\n     */\n    public IteratorEnumeration() {\n    }\n\n    /**\n     * Constructs a new {@code IteratorEnumeration} that will use the given\n     * iterator.\n     *\n     * @param iterator the iterator to use\n     */\n    public IteratorEnumeration(final Iterator<? extends E> iterator) {\n        this.iterator = iterator;\n    }\n\n    /**\n     * Returns the underlying iterator.\n     *\n     * @return the underlying iterator\n     */\n    public Iterator<? extends E> getIterator() {\n        return iterator;\n    }\n\n    /**\n     * Returns true if the underlying iterator has more elements.\n     *\n     * @return true if the underlying iterator has more elements\n     */\n    @Override\n    public boolean hasMoreElements() {\n        return iterator.hasNext();\n    }\n\n    /**\n     * Returns the next element from the underlying iterator.\n     *\n     * @return the next element from the underlying iterator.\n     * @throws java.util.NoSuchElementException if the underlying iterator has\n     * no more elements\n     */\n    @Override\n    public E nextElement() {\n        return iterator.next();\n    }\n\n    /**\n     * Sets the underlying iterator.\n     *\n     * @param iterator the new underlying iterator\n     */\n    public void setIterator(final Iterator<? extends E> iterator) {\n        this.iterator = iterator;\n    }\n\n}", "super_interfaces": ["Enumeration<E>"], "fields": [{"attribute_expression": "private Iterator<? extends E> iterator;", "docstring": " The iterator being decorated.", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Iterator<? extends E>", "name": "iterator", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/iterators/UniqueFilterIterator.java.UniqueFilterIterator", "name": "UniqueFilterIterator", "file_path": "src/main/java/org/apache/commons/collections4/iterators/UniqueFilterIterator.java", "superclasses": "", "methods": ["[]UniqueFilterIterator(Iterator<? extends E>)"], "method_uris": ["src/main/java/org/apache/commons/collections4/iterators/UniqueFilterIterator.java.UniqueFilterIterator.[]UniqueFilterIterator(Iterator<? extends E>)"], "overrides": null, "attributes": [], "class_docstring": "\nA FilterIterator which only returns \"unique\" Objects.  Internally,\nthe Iterator maintains a Set of objects it has already encountered,\nand duplicate Objects are skipped.\n\n@param <E> the type of elements returned by this iterator.\n@since 2.1\n", "original_string": "public class UniqueFilterIterator<E> extends FilterIterator<E> {\n\n    /**\n     *  Constructs a new {@code UniqueFilterIterator}.\n     *\n     *  @param iterator  the iterator to use\n     */\n    public UniqueFilterIterator(final Iterator<? extends E> iterator) {\n        super(iterator, UniquePredicate.uniquePredicate());\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/org/apache/commons/collections4/iterators/ZippingIterator.java.ZippingIterator", "name": "ZippingIterator", "file_path": "src/main/java/org/apache/commons/collections4/iterators/ZippingIterator.java", "superclasses": "", "methods": ["[]ZippingIterator()", "[]ZippingIterator(Iterator<? extends E>,Iterator<? extends E>)", "[]ZippingIterator(Iterator<? extends E>,Iterator<? extends E>,Iterator<? extends E>)", "[boolean]hasNext()", "[E]next()", "[void]remove()"], "method_uris": ["src/main/java/org/apache/commons/collections4/iterators/ZippingIterator.java.ZippingIterator.[]ZippingIterator()", "src/main/java/org/apache/commons/collections4/iterators/ZippingIterator.java.ZippingIterator.[]ZippingIterator(Iterator<? extends E>,Iterator<? extends E>)", "src/main/java/org/apache/commons/collections4/iterators/ZippingIterator.java.ZippingIterator.[]ZippingIterator(Iterator<? extends E>,Iterator<? extends E>,Iterator<? extends E>)", "src/main/java/org/apache/commons/collections4/iterators/ZippingIterator.java.ZippingIterator.[boolean]hasNext()", "src/main/java/org/apache/commons/collections4/iterators/ZippingIterator.java.ZippingIterator.[E]next()", "src/main/java/org/apache/commons/collections4/iterators/ZippingIterator.java.ZippingIterator.[void]remove()"], "overrides": null, "attributes": [], "class_docstring": "\nProvides an interleaved iteration over the elements contained in a\ncollection of Iterators.\n<p>\nGiven two {@link Iterator} instances {@code A} and {@code B}, the\n{@link #next} method on this iterator will switch between {@code A.next()}\nand {@code B.next()} until both iterators are exhausted.\n</p>\n\n@param <E> the type of elements returned by this iterator.\n@since 4.1\n", "original_string": "public class ZippingIterator<E> implements Iterator<E> {\n\n    /** The {@link Iterator}s to evaluate. */\n    private final Iterator<Iterator<? extends E>> iterators;\n\n    /** The next iterator to use for next(). */\n    private Iterator<? extends E> nextIterator;\n\n    /** The last iterator which was used for next(). */\n    private Iterator<? extends E> lastReturned;\n\n    /**\n     * Constructs a new {@code ZippingIterator} that will provide\n     * interleaved iteration of the specified iterators.\n     *\n     * @param iterators  the array of iterators\n     * @throws NullPointerException if any iterator is null\n     */\n    public ZippingIterator(final Iterator<? extends E>... iterators) {\n        // create a mutable list to be able to remove exhausted iterators\n        final List<Iterator<? extends E>> list = new ArrayList<>();\n        for (final Iterator<? extends E> iterator : iterators) {\n            Objects.requireNonNull(iterator, \"iterator\");\n            list.add(iterator);\n        }\n        this.iterators = FluentIterable.of(list).loop().iterator();\n    }\n\n    /**\n     * Constructs a new {@code ZippingIterator} that will provide\n     * interleaved iteration over the two given iterators.\n     *\n     * @param a  the first child iterator\n     * @param b  the second child iterator\n     * @throws NullPointerException if either iterator is null\n     */\n    @SuppressWarnings(\"unchecked\")\n    public ZippingIterator(final Iterator<? extends E> a, final Iterator<? extends E> b) {\n        this(new Iterator[] {a, b});\n    }\n\n    /**\n     * Constructs a new {@code ZippingIterator} that will provide\n     * interleaved iteration over the three given iterators.\n     *\n     * @param a  the first child iterator\n     * @param b  the second child iterator\n     * @param c  the third child iterator\n     * @throws NullPointerException if either iterator is null\n     */\n    @SuppressWarnings(\"unchecked\")\n    public ZippingIterator(final Iterator<? extends E> a,\n                           final Iterator<? extends E> b,\n                           final Iterator<? extends E> c) {\n        this(new Iterator[] {a, b, c});\n    }\n\n    /**\n     * Returns {@code true} if any child iterator has remaining elements.\n     *\n     * @return true if this iterator has remaining elements\n     */\n    @Override\n    public boolean hasNext() {\n        // the next iterator has already been determined\n        // this might happen if hasNext() is called multiple\n        if (nextIterator != null) {\n            return true;\n        }\n\n        while (iterators.hasNext()) {\n            final Iterator<? extends E> childIterator = iterators.next();\n            if (childIterator.hasNext()) {\n                nextIterator = childIterator;\n                return true;\n            }\n            // iterator is exhausted, remove it\n            iterators.remove();\n        }\n        return false;\n    }\n\n    /**\n     * Returns the next element from a child iterator.\n     *\n     * @return the next interleaved element\n     * @throws NoSuchElementException if no child iterator has any more elements\n     */\n    @Override\n    public E next() throws NoSuchElementException {\n        if (!hasNext()) {\n            throw new NoSuchElementException();\n        }\n\n        final E val = nextIterator.next();\n        lastReturned = nextIterator;\n        nextIterator = null;\n        return val;\n    }\n\n    /**\n     * Removes the last returned element from the child iterator that produced it.\n     *\n     * @throws IllegalStateException if there is no last returned element, or if\n     *   the last returned element has already been removed\n     */\n    @Override\n    public void remove() {\n        if (lastReturned == null) {\n            throw new IllegalStateException(\"No value can be removed at present\");\n        }\n        lastReturned.remove();\n        lastReturned = null;\n    }\n\n}", "super_interfaces": ["Iterator<E>"], "fields": [{"attribute_expression": "private final Iterator<Iterator<? extends E>> iterators;", "docstring": " The {@link Iterator}s to evaluate.", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Iterator<Iterator<? extends E>>", "name": "iterators", "syntax_pass": true}, {"attribute_expression": "private Iterator<? extends E> nextIterator;", "docstring": " The next iterator to use for next().", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Iterator<? extends E>", "name": "nextIterator", "syntax_pass": true}, {"attribute_expression": "private Iterator<? extends E> lastReturned;", "docstring": " The last iterator which was used for next().", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Iterator<? extends E>", "name": "lastReturned", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/iterators/FilterIterator.java.FilterIterator", "name": "FilterIterator", "file_path": "src/main/java/org/apache/commons/collections4/iterators/FilterIterator.java", "superclasses": "", "methods": ["[]FilterIterator()", "[]FilterIterator(Iterator<? extends E>)", "[]FilterIterator(Iterator<? extends E>,Predicate<? super E>)", "[Iterator<? extends E>]getIterator()", "[Predicate<? super E>]getPredicate()", "[boolean]hasNext()", "[E]next()", "[void]remove()", "[void]setIterator(Iterator<? extends E>)", "[boolean]setNextObject()", "[void]setPredicate(Predicate<? super E>)"], "method_uris": ["src/main/java/org/apache/commons/collections4/iterators/FilterIterator.java.FilterIterator.[]FilterIterator()", "src/main/java/org/apache/commons/collections4/iterators/FilterIterator.java.FilterIterator.[]FilterIterator(Iterator<? extends E>)", "src/main/java/org/apache/commons/collections4/iterators/FilterIterator.java.FilterIterator.[]FilterIterator(Iterator<? extends E>,Predicate<? super E>)", "src/main/java/org/apache/commons/collections4/iterators/FilterIterator.java.FilterIterator.[Iterator<? extends E>]getIterator()", "src/main/java/org/apache/commons/collections4/iterators/FilterIterator.java.FilterIterator.[Predicate<? super E>]getPredicate()", "src/main/java/org/apache/commons/collections4/iterators/FilterIterator.java.FilterIterator.[boolean]hasNext()", "src/main/java/org/apache/commons/collections4/iterators/FilterIterator.java.FilterIterator.[E]next()", "src/main/java/org/apache/commons/collections4/iterators/FilterIterator.java.FilterIterator.[void]remove()", "src/main/java/org/apache/commons/collections4/iterators/FilterIterator.java.FilterIterator.[void]setIterator(Iterator<? extends E>)", "src/main/java/org/apache/commons/collections4/iterators/FilterIterator.java.FilterIterator.[boolean]setNextObject()", "src/main/java/org/apache/commons/collections4/iterators/FilterIterator.java.FilterIterator.[void]setPredicate(Predicate<? super E>)"], "overrides": null, "attributes": [], "class_docstring": "\nDecorates another {@link Iterator} using a predicate to filter elements.\n<p>\nThis iterator decorates the underlying iterator, only allowing through\nthose elements that match the specified {@link Predicate Predicate}.\n\n@param <E> the type of elements returned by this iterator.\n@since 1.0\n", "original_string": "public class FilterIterator<E> implements Iterator<E> {\n\n    /** The iterator being used */\n    private Iterator<? extends E> iterator;\n    /** The predicate being used */\n    private Predicate<? super E> predicate;\n    /** The next object in the iteration */\n    private E nextObject;\n    /** Whether the next object has been calculated yet */\n    private boolean nextObjectSet;\n\n    /**\n     * Constructs a new {@code FilterIterator} that will not function\n     * until {@link #setIterator(Iterator) setIterator} is invoked.\n     */\n    public FilterIterator() {\n    }\n\n    /**\n     * Constructs a new {@code FilterIterator} that will not function\n     * until {@link #setPredicate(Predicate) setPredicate} is invoked.\n     *\n     * @param iterator  the iterator to use\n     */\n    public FilterIterator(final Iterator<? extends E> iterator) {\n        this.iterator = iterator;\n    }\n\n    /**\n     * Constructs a new {@code FilterIterator} that will use the\n     * given iterator and predicate.\n     *\n     * @param iterator  the iterator to use\n     * @param predicate  the predicate to use\n     */\n    public FilterIterator(final Iterator<? extends E> iterator, final Predicate<? super E> predicate) {\n        this.iterator = iterator;\n        this.predicate = predicate;\n    }\n\n    /**\n     * Gets the iterator this iterator is using.\n     *\n     * @return the iterator\n     */\n    public Iterator<? extends E> getIterator() {\n        return iterator;\n    }\n\n    /**\n     * Gets the predicate this iterator is using.\n     *\n     * @return the predicate\n     */\n    public Predicate<? super E> getPredicate() {\n        return predicate;\n    }\n\n    /**\n     * Returns true if the underlying iterator contains an object that\n     * matches the predicate.\n     *\n     * @return true if there is another object that matches the predicate\n     * @throws NullPointerException if either the iterator or predicate are null\n     */\n    @Override\n    public boolean hasNext() {\n        return nextObjectSet || setNextObject();\n    }\n\n    /**\n     * Returns the next object that matches the predicate.\n     *\n     * @return the next object which matches the given predicate\n     * @throws NullPointerException if either the iterator or predicate are null\n     * @throws NoSuchElementException if there are no more elements that\n     *  match the predicate\n     */\n    @Override\n    public E next() {\n        if (!nextObjectSet && !setNextObject()) {\n            throw new NoSuchElementException();\n        }\n        nextObjectSet = false;\n        return nextObject;\n    }\n\n    /**\n     * Removes from the underlying collection of the base iterator the last\n     * element returned by this iterator.\n     * This method can only be called\n     * if {@code next()} was called, but not after\n     * {@code hasNext()}, because the {@code hasNext()} call\n     * changes the base iterator.\n     *\n     * @throws IllegalStateException if {@code hasNext()} has already\n     *  been called.\n     */\n    @Override\n    public void remove() {\n        if (nextObjectSet) {\n            throw new IllegalStateException(\"remove() cannot be called\");\n        }\n        iterator.remove();\n    }\n\n    /**\n     * Sets the iterator for this iterator to use.\n     * If iteration has started, this effectively resets the iterator.\n     *\n     * @param iterator  the iterator to use\n     */\n    public void setIterator(final Iterator<? extends E> iterator) {\n        this.iterator = iterator;\n        nextObject = null;\n        nextObjectSet = false;\n    }\n\n    /**\n     * Sets nextObject to the next object. If there are no more\n     * objects, then return false. Otherwise, return true.\n     */\n    private boolean setNextObject() {\n        while (iterator.hasNext()) {\n            final E object = iterator.next();\n            if (predicate.test(object)) {\n                nextObject = object;\n                nextObjectSet = true;\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Sets the predicate this the iterator to use.\n     *\n     * @param predicate  the predicate to use\n     */\n    public void setPredicate(final Predicate<? super E> predicate) {\n        this.predicate = predicate;\n        nextObject = null;\n        nextObjectSet = false;\n    }\n\n}", "super_interfaces": ["Iterator<E>"], "fields": [{"attribute_expression": "private Iterator<? extends E> iterator;", "docstring": " The iterator being used", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Iterator<? extends E>", "name": "iterator", "syntax_pass": true}, {"attribute_expression": "private Predicate<? super E> predicate;", "docstring": " The predicate being used", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Predicate<? super E>", "name": "predicate", "syntax_pass": true}, {"attribute_expression": "private E nextObject;", "docstring": " The next object in the iteration", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "E", "name": "nextObject", "syntax_pass": true}, {"attribute_expression": "private boolean nextObjectSet;", "docstring": " Whether the next object has been calculated yet", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "nextObjectSet", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/iterators/UnmodifiableMapIterator.java.UnmodifiableMapIterator", "name": "UnmodifiableMapIterator", "file_path": "src/main/java/org/apache/commons/collections4/iterators/UnmodifiableMapIterator.java", "superclasses": "", "methods": ["[MapIterator<K, V>]unmodifiableMapIterator(MapIterator<? extends K, ? extends V>)", "[]UnmodifiableMapIterator(MapIterator<? extends K, ? extends V>)", "[K]getKey()", "[V]getValue()", "[boolean]hasNext()", "[K]next()", "[void]remove()", "[V]setValue(V)"], "method_uris": ["src/main/java/org/apache/commons/collections4/iterators/UnmodifiableMapIterator.java.UnmodifiableMapIterator.[MapIterator<K, V>]unmodifiableMapIterator(MapIterator<? extends K, ? extends V>)", "src/main/java/org/apache/commons/collections4/iterators/UnmodifiableMapIterator.java.UnmodifiableMapIterator.[]UnmodifiableMapIterator(MapIterator<? extends K, ? extends V>)", "src/main/java/org/apache/commons/collections4/iterators/UnmodifiableMapIterator.java.UnmodifiableMapIterator.[K]getKey()", "src/main/java/org/apache/commons/collections4/iterators/UnmodifiableMapIterator.java.UnmodifiableMapIterator.[V]getValue()", "src/main/java/org/apache/commons/collections4/iterators/UnmodifiableMapIterator.java.UnmodifiableMapIterator.[boolean]hasNext()", "src/main/java/org/apache/commons/collections4/iterators/UnmodifiableMapIterator.java.UnmodifiableMapIterator.[K]next()", "src/main/java/org/apache/commons/collections4/iterators/UnmodifiableMapIterator.java.UnmodifiableMapIterator.[void]remove()", "src/main/java/org/apache/commons/collections4/iterators/UnmodifiableMapIterator.java.UnmodifiableMapIterator.[V]setValue(V)"], "overrides": null, "attributes": [], "class_docstring": "\nDecorates a map iterator such that it cannot be modified.\n<p>\nAttempts to modify it will result in an UnsupportedOperationException.\n</p>\n\n@param <K> the type of keys\n@param <V> the type of mapped values\n@since 3.0\n", "original_string": "public final class UnmodifiableMapIterator<K, V> implements MapIterator<K, V>, Unmodifiable {\n\n    /**\n     * Decorates the specified iterator such that it cannot be modified.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param iterator  the iterator to decorate\n     * @return a new unmodifiable map iterator\n     * @throws NullPointerException if the iterator is null\n     */\n    public static <K, V> MapIterator<K, V> unmodifiableMapIterator(\n            final MapIterator<? extends K, ? extends V> iterator) {\n        Objects.requireNonNull(iterator, \"iterator\");\n        if (iterator instanceof Unmodifiable) {\n            @SuppressWarnings(\"unchecked\") // safe to upcast\n            final MapIterator<K, V> tmpIterator = (MapIterator<K, V>) iterator;\n            return tmpIterator;\n        }\n        return new UnmodifiableMapIterator<>(iterator);\n    }\n\n    /** The iterator being decorated */\n    private final MapIterator<? extends K, ? extends V> iterator;\n\n    /**\n     * Constructs a new instance.\n     *\n     * @param iterator  the iterator to decorate\n     */\n    private UnmodifiableMapIterator(final MapIterator<? extends K, ? extends V> iterator) {\n        this.iterator = iterator;\n    }\n\n    @Override\n    public K getKey() {\n        return iterator.getKey();\n    }\n\n    @Override\n    public V getValue() {\n        return iterator.getValue();\n    }\n\n    @Override\n    public boolean hasNext() {\n        return iterator.hasNext();\n    }\n\n    @Override\n    public K next() {\n        return iterator.next();\n    }\n\n    @Override\n    public void remove() {\n        throw new UnsupportedOperationException(\"remove() is not supported\");\n    }\n\n    @Override\n    public V setValue(final V value) {\n        throw new UnsupportedOperationException(\"setValue() is not supported\");\n    }\n\n}", "super_interfaces": ["MapIterator<K, V>", "Unmodifiable"], "fields": [{"attribute_expression": "private final MapIterator<? extends K, ? extends V> iterator;", "docstring": " The iterator being decorated", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "MapIterator<? extends K, ? extends V>", "name": "iterator", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/iterators/IteratorIterable.java.IteratorIterable", "name": "IteratorIterable", "file_path": "src/main/java/org/apache/commons/collections4/iterators/IteratorIterable.java", "superclasses": "", "methods": ["[Iterator<E>]createTypesafeIterator(Iterator<? extends E>)", "[]IteratorIterable(Iterator<? extends E>)", "[]IteratorIterable(Iterator<? extends E>,boolean)", "[Iterator<E>]iterator()"], "method_uris": ["src/main/java/org/apache/commons/collections4/iterators/IteratorIterable.java.IteratorIterable.[Iterator<E>]createTypesafeIterator(Iterator<? extends E>)", "src/main/java/org/apache/commons/collections4/iterators/IteratorIterable.java.IteratorIterable.[]IteratorIterable(Iterator<? extends E>)", "src/main/java/org/apache/commons/collections4/iterators/IteratorIterable.java.IteratorIterable.[]IteratorIterable(Iterator<? extends E>,boolean)", "src/main/java/org/apache/commons/collections4/iterators/IteratorIterable.java.IteratorIterable.[Iterator<E>]iterator()"], "overrides": null, "attributes": [], "class_docstring": "\nAdapter to make an {@link Iterator Iterator} instance appear to be an\n{@link Iterable Iterable} instance.  The iterable can be constructed in one\nof two variants:  single use, multiple use.\n\n<p>\nIn the single use iterable case, the iterable is only usable for one\niterative operation over the source iterator.  Subsequent iterative\noperations use the same, exhausted source iterator.  To create a single use\niterable, construct a new {@link IteratorIterable} using a {@link Iterator}\nthat is NOT a {@link ResettableIterator} iterator:\n</p>\n\n<pre>\n  Iterator&lt;Integer&gt; iterator = // some non-resettable iterator\n  Iterable&lt;Integer&gt; iterable = new IteratorIterable&lt;Integer&gt;(iterator);\n</pre>\n\n<p>\nIn the multiple use iterable case, the iterable is usable for any number of\niterative operations over the source iterator.  Of special note, even though\nthe iterable supports multiple iterations, it does not support concurrent\niterations. To implicitly create a multiple use iterable, construct a new\n{@link IteratorIterable} using a {@link ResettableIterator} iterator:\n</p>\n\n<pre>\n  Integer[] array = {Integer.valueOf(1),Integer.valueOf(2),Integer.valueOf(3)};\n  Iterator&lt;Integer&gt; iterator = IteratorUtils.arrayIterator(array); // a resettable iterator\n  Iterable&lt;Integer&gt; iterable = new IteratorIterable&lt;Integer&gt;(iterator);\n</pre>\n\n<p>\nA multiple use iterable can also be explicitly constructed using any\n{@link Iterator} and specifying {@code true} for the\n{@code multipleUse} flag:\n</p>\n\n<pre>\n  Iterator&lt;Integer&gt; iterator = // some non-resettable iterator\n  Iterable&lt;Integer&gt; iterable = new IteratorIterable&lt;Integer&gt;(iterator, true);\n</pre>\n\n@param <E> the type of elements returned by this iterator.\n@since 4.0\n", "original_string": "public class IteratorIterable<E> implements Iterable<E> {\n\n    /**\n     * Factory method to create an {@link Iterator Iterator} from another\n     * iterator over objects of a different subtype.\n     */\n    private static <E> Iterator<E> createTypesafeIterator(final Iterator<? extends E> iterator) {\n        return new Iterator<E>() {\n            @Override\n            public boolean hasNext() {\n                return iterator.hasNext();\n            }\n\n            @Override\n            public E next() {\n                return iterator.next();\n            }\n\n            @Override\n            public void remove() {\n                iterator.remove();\n            }\n        };\n    }\n\n    /** The iterator being adapted into an iterable. */\n    private final Iterator<? extends E> iterator;\n\n    /** The iterator parameterized as the {@link #iterator()} return type. */\n    private final Iterator<E> typeSafeIterator;\n\n    /**\n     * Constructs a new {@code IteratorIterable} that will use the given\n     * iterator.\n     *\n     * @param iterator the iterator to use.\n     */\n    public IteratorIterable(final Iterator<? extends E> iterator) {\n        this(iterator, false);\n    }\n\n    /**\n     * Constructs a new {@code IteratorIterable} that will use the given\n     * iterator.\n     *\n     * @param iterator the iterator to use.\n     * @param multipleUse {@code true} if the new iterable can be used in multiple iterations\n     */\n    public IteratorIterable(final Iterator<? extends E> iterator, final boolean multipleUse) {\n        if (multipleUse && !(iterator instanceof ResettableIterator)) {\n            this.iterator = new ListIteratorWrapper<>(iterator);\n        } else {\n            this.iterator = iterator;\n        }\n        this.typeSafeIterator = createTypesafeIterator(this.iterator);\n    }\n\n    /**\n     * Gets the iterator wrapped by this iterable.\n     *\n     * @return the iterator\n     */\n    @Override\n    public Iterator<E> iterator() {\n        if (iterator instanceof ResettableIterator) {\n            ((ResettableIterator<? extends E>) iterator).reset();\n        }\n        return typeSafeIterator;\n    }\n}", "super_interfaces": ["Iterable<E>"], "fields": [{"attribute_expression": "private final Iterator<? extends E> iterator;", "docstring": " The iterator being adapted into an iterable.", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Iterator<? extends E>", "name": "iterator", "syntax_pass": true}, {"attribute_expression": "private final Iterator<E> typeSafeIterator;", "docstring": " The iterator parameterized as the {@link #iterator()} return type.", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Iterator<E>", "name": "typeSafeIterator", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/iterators/ObjectGraphIterator.java.ObjectGraphIterator", "name": "ObjectGraphIterator", "file_path": "src/main/java/org/apache/commons/collections4/iterators/ObjectGraphIterator.java", "superclasses": "", "methods": ["[]ObjectGraphIterator(E,Transformer<? super E, ? extends E>)", "[]ObjectGraphIterator(Iterator<? extends E>)", "[void]findNext(E)", "[void]findNextByIterator(Iterator<? extends E>)", "[boolean]hasNext()", "[E]next()", "[void]remove()", "[void]updateCurrentIterator()"], "method_uris": ["src/main/java/org/apache/commons/collections4/iterators/ObjectGraphIterator.java.ObjectGraphIterator.[]ObjectGraphIterator(E,Transformer<? super E, ? extends E>)", "src/main/java/org/apache/commons/collections4/iterators/ObjectGraphIterator.java.ObjectGraphIterator.[]ObjectGraphIterator(Iterator<? extends E>)", "src/main/java/org/apache/commons/collections4/iterators/ObjectGraphIterator.java.ObjectGraphIterator.[void]findNext(E)", "src/main/java/org/apache/commons/collections4/iterators/ObjectGraphIterator.java.ObjectGraphIterator.[void]findNextByIterator(Iterator<? extends E>)", "src/main/java/org/apache/commons/collections4/iterators/ObjectGraphIterator.java.ObjectGraphIterator.[boolean]hasNext()", "src/main/java/org/apache/commons/collections4/iterators/ObjectGraphIterator.java.ObjectGraphIterator.[E]next()", "src/main/java/org/apache/commons/collections4/iterators/ObjectGraphIterator.java.ObjectGraphIterator.[void]remove()", "src/main/java/org/apache/commons/collections4/iterators/ObjectGraphIterator.java.ObjectGraphIterator.[void]updateCurrentIterator()"], "overrides": null, "attributes": [], "class_docstring": "\nAn Iterator that can traverse multiple iterators down an object graph.\n<p>\nThis iterator can extract multiple objects from a complex tree-like object graph.\nThe iteration starts from a single root object.\nIt uses a {@code Transformer} to extract the iterators and elements.\nIts main benefit is that no intermediate {@code List} is created.\n<p>\nFor example, consider an object graph:\n<pre>\n                |- Branch -- Leaf\n                |         \\- Leaf\n        |- Tree |         /- Leaf\n        |       |- Branch -- Leaf\n Forest |                 \\- Leaf\n        |       |- Branch -- Leaf\n        |       |         \\- Leaf\n        |- Tree |         /- Leaf\n                |- Branch -- Leaf\n                |- Branch -- Leaf</pre>\nThe following {@code Transformer}, used in this class, will extract all\nthe Leaf objects without creating a combined intermediate list:\n<pre>\npublic Object transform(Object input) {\n  if (input instanceof Forest) {\n    return ((Forest) input).treeIterator();\n  }\n  if (input instanceof Tree) {\n    return ((Tree) input).branchIterator();\n  }\n  if (input instanceof Branch) {\n    return ((Branch) input).leafIterator();\n  }\n  if (input instanceof Leaf) {\n    return input;\n  }\n  throw new ClassCastException();\n}</pre>\n<p>\nInternally, iteration starts from the root object. When next is called,\nthe transformer is called to examine the object. The transformer will return\neither an iterator or an object. If the object is an Iterator, the next element\nfrom that iterator is obtained and the process repeats. If the element is an object\nit is returned.\n<p>\nUnder many circumstances, linking Iterators together in this manner is\nmore efficient (and convenient) than using nested for loops to extract a list.\n\n@param <E> the type of elements returned by this iterator.\n@since 3.1\n", "original_string": "public class ObjectGraphIterator<E> implements Iterator<E> {\n\n    /** The stack of iterators */\n    private final Deque<Iterator<? extends E>> stack = new ArrayDeque<>(8);\n    /** The root object in the tree */\n    private E root;\n    /** The transformer to use */\n    private final Transformer<? super E, ? extends E> transformer;\n\n    /** Whether there is another element in the iteration */\n    private boolean hasNext;\n    /** The current iterator */\n    private Iterator<? extends E> currentIterator;\n    /** The current value */\n    private E currentValue;\n    /** The last used iterator, needed for remove() */\n    private Iterator<? extends E> lastUsedIterator;\n\n    /**\n     * Constructs an ObjectGraphIterator using a root object and transformer.\n     * <p>\n     * The root object can be an iterator, in which case it will be immediately\n     * looped around.\n     *\n     * @param root  the root object, null will result in an empty iterator\n     * @param transformer  the transformer to use, null will use a no effect transformer\n     */\n    @SuppressWarnings(\"unchecked\")\n    public ObjectGraphIterator(final E root, final Transformer<? super E, ? extends E> transformer) {\n        if (root instanceof Iterator) {\n            this.currentIterator = (Iterator<? extends E>) root;\n        } else {\n            this.root = root;\n        }\n        this.transformer = transformer;\n    }\n\n    /**\n     * Constructs a ObjectGraphIterator that will handle an iterator of iterators.\n     * <p>\n     * This constructor exists for convenience to emphasise that this class can\n     * be used to iterate over nested iterators. That is to say that the iterator\n     * passed in here contains other iterators, which may in turn contain further\n     * iterators.\n     *\n     * @param rootIterator  the root iterator, null will result in an empty iterator\n     */\n    public ObjectGraphIterator(final Iterator<? extends E> rootIterator) {\n        this.currentIterator = rootIterator;\n        this.transformer = null;\n    }\n\n    /**\n     * Finds the next object in the iteration given any start object.\n     *\n     * @param value  the value to start from\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected void findNext(final E value) {\n        if (value instanceof Iterator) {\n            // need to examine this iterator\n            findNextByIterator((Iterator<? extends E>) value);\n        } else {\n            // next value found\n            currentValue = value;\n            hasNext = true;\n        }\n    }\n\n    /**\n     * Finds the next object in the iteration given an iterator.\n     *\n     * @param iterator  the iterator to start from\n     */\n    protected void findNextByIterator(final Iterator<? extends E> iterator) {\n        if (iterator != currentIterator) {\n            // recurse a level\n            if (currentIterator != null) {\n                stack.push(currentIterator);\n            }\n            currentIterator = iterator;\n        }\n\n        while (currentIterator.hasNext() && !hasNext) {\n            E next = currentIterator.next();\n            if (transformer != null) {\n                next = transformer.apply(next);\n            }\n            findNext(next);\n        }\n        // if we haven't found the next value and iterators are not yet exhausted\n        if (!hasNext && !stack.isEmpty()) {\n            // current iterator exhausted, go up a level\n            currentIterator = stack.pop();\n            findNextByIterator(currentIterator);\n        }\n    }\n\n    /**\n     * Checks whether there are any more elements in the iteration to obtain.\n     *\n     * @return true if elements remain in the iteration\n     */\n    @Override\n    public boolean hasNext() {\n        updateCurrentIterator();\n        return hasNext;\n    }\n\n    /**\n     * Gets the next element of the iteration.\n     *\n     * @return the next element from the iteration\n     * @throws NoSuchElementException if all the Iterators are exhausted\n     */\n    @Override\n    public E next() {\n        updateCurrentIterator();\n        if (!hasNext) {\n            throw new NoSuchElementException(\"No more elements in the iteration\");\n        }\n        lastUsedIterator = currentIterator;\n        final E result = currentValue;\n        currentValue = null;\n        hasNext = false;\n        return result;\n    }\n\n    /**\n     * Removes from the underlying collection the last element returned.\n     * <p>\n     * This method calls remove() on the underlying Iterator, and it may\n     * throw an UnsupportedOperationException if the underlying Iterator\n     * does not support this method.\n     *\n     * @throws UnsupportedOperationException\n     *   if the remove operator is not supported by the underlying Iterator\n     * @throws IllegalStateException\n     *   if the next method has not yet been called, or the remove method has\n     *   already been called after the last call to the next method.\n     */\n    @Override\n    public void remove() {\n        if (lastUsedIterator == null) {\n            throw new IllegalStateException(\"Iterator remove() cannot be called at this time\");\n        }\n        lastUsedIterator.remove();\n        lastUsedIterator = null;\n    }\n\n    /**\n     * Loops around the iterators to find the next value to return.\n     */\n    protected void updateCurrentIterator() {\n        if (hasNext) {\n            return;\n        }\n        if (currentIterator == null) {\n            if (root == null) { // NOPMD\n                // do nothing, hasNext will be false\n            } else {\n                if (transformer == null) {\n                    findNext(root);\n                } else {\n                    findNext(transformer.apply(root));\n                }\n                root = null;\n            }\n        } else {\n            findNextByIterator(currentIterator);\n        }\n    }\n\n}", "super_interfaces": ["Iterator<E>"], "fields": [{"attribute_expression": "private final Deque<Iterator<? extends E>> stack = new ArrayDeque<>(8);", "docstring": " The stack of iterators", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Deque<Iterator<? extends E>>", "name": "stack = new ArrayDeque<>(8)", "syntax_pass": true}, {"attribute_expression": "private E root;", "docstring": " The root object in the tree", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "E", "name": "root", "syntax_pass": true}, {"attribute_expression": "private final Transformer<? super E, ? extends E> transformer;", "docstring": " The transformer to use", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Transformer<? super E, ? extends E>", "name": "transformer", "syntax_pass": true}, {"attribute_expression": "private boolean hasNext;", "docstring": " Whether there is another element in the iteration", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "hasNext", "syntax_pass": true}, {"attribute_expression": "private Iterator<? extends E> currentIterator;", "docstring": " The current iterator", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Iterator<? extends E>", "name": "currentIterator", "syntax_pass": true}, {"attribute_expression": "private E currentValue;", "docstring": " The current value", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "E", "name": "currentValue", "syntax_pass": true}, {"attribute_expression": "private Iterator<? extends E> lastUsedIterator;", "docstring": " The last used iterator, needed for remove()", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Iterator<? extends E>", "name": "lastUsedIterator", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/iterators/CollatingIterator.java.CollatingIterator", "name": "CollatingIterator", "file_path": "src/main/java/org/apache/commons/collections4/iterators/CollatingIterator.java", "superclasses": "", "methods": ["[]CollatingIterator()", "[]CollatingIterator(Comparator<? super E>)", "[]CollatingIterator(Comparator<? super E>,Collection<Iterator<? extends E>>)", "[]CollatingIterator(Comparator<? super E>,int)", "[]CollatingIterator(Comparator<? super E>,Iterator<? extends E>,Iterator<? extends E>)", "[]CollatingIterator(Comparator<? super E>,Iterator<? extends E>[])", "[void]addIterator(Iterator<? extends E>)", "[boolean]anyHasNext(List<Iterator<? extends E>>)", "[boolean]anyValueSet(BitSet)", "[void]checkNotStarted()", "[void]clear(int)", "[Comparator<? super E>]getComparator()", "[int]getIteratorIndex()", "[List<Iterator<? extends E>>]getIterators()", "[boolean]hasNext()", "[int]least()", "[E]next()", "[void]remove()", "[boolean]set(int)", "[void]setComparator(Comparator<? super E>)", "[void]setIterator(int,Iterator<? extends E>)", "[void]start()"], "method_uris": ["src/main/java/org/apache/commons/collections4/iterators/CollatingIterator.java.CollatingIterator.[]CollatingIterator()", "src/main/java/org/apache/commons/collections4/iterators/CollatingIterator.java.CollatingIterator.[]CollatingIterator(Comparator<? super E>)", "src/main/java/org/apache/commons/collections4/iterators/CollatingIterator.java.CollatingIterator.[]CollatingIterator(Comparator<? super E>,Collection<Iterator<? extends E>>)", "src/main/java/org/apache/commons/collections4/iterators/CollatingIterator.java.CollatingIterator.[]CollatingIterator(Comparator<? super E>,int)", "src/main/java/org/apache/commons/collections4/iterators/CollatingIterator.java.CollatingIterator.[]CollatingIterator(Comparator<? super E>,Iterator<? extends E>,Iterator<? extends E>)", "src/main/java/org/apache/commons/collections4/iterators/CollatingIterator.java.CollatingIterator.[]CollatingIterator(Comparator<? super E>,Iterator<? extends E>[])", "src/main/java/org/apache/commons/collections4/iterators/CollatingIterator.java.CollatingIterator.[void]addIterator(Iterator<? extends E>)", "src/main/java/org/apache/commons/collections4/iterators/CollatingIterator.java.CollatingIterator.[boolean]anyHasNext(List<Iterator<? extends E>>)", "src/main/java/org/apache/commons/collections4/iterators/CollatingIterator.java.CollatingIterator.[boolean]anyValueSet(BitSet)", "src/main/java/org/apache/commons/collections4/iterators/CollatingIterator.java.CollatingIterator.[void]checkNotStarted()", "src/main/java/org/apache/commons/collections4/iterators/CollatingIterator.java.CollatingIterator.[void]clear(int)", "src/main/java/org/apache/commons/collections4/iterators/CollatingIterator.java.CollatingIterator.[Comparator<? super E>]getComparator()", "src/main/java/org/apache/commons/collections4/iterators/CollatingIterator.java.CollatingIterator.[int]getIteratorIndex()", "src/main/java/org/apache/commons/collections4/iterators/CollatingIterator.java.CollatingIterator.[List<Iterator<? extends E>>]getIterators()", "src/main/java/org/apache/commons/collections4/iterators/CollatingIterator.java.CollatingIterator.[boolean]hasNext()", "src/main/java/org/apache/commons/collections4/iterators/CollatingIterator.java.CollatingIterator.[int]least()", "src/main/java/org/apache/commons/collections4/iterators/CollatingIterator.java.CollatingIterator.[E]next()", "src/main/java/org/apache/commons/collections4/iterators/CollatingIterator.java.CollatingIterator.[void]remove()", "src/main/java/org/apache/commons/collections4/iterators/CollatingIterator.java.CollatingIterator.[boolean]set(int)", "src/main/java/org/apache/commons/collections4/iterators/CollatingIterator.java.CollatingIterator.[void]setComparator(Comparator<? super E>)", "src/main/java/org/apache/commons/collections4/iterators/CollatingIterator.java.CollatingIterator.[void]setIterator(int,Iterator<? extends E>)", "src/main/java/org/apache/commons/collections4/iterators/CollatingIterator.java.CollatingIterator.[void]start()"], "overrides": null, "attributes": [], "class_docstring": "\nProvides an ordered iteration over the elements contained in a collection of\nordered Iterators.\n<p>\nGiven two ordered {@link Iterator} instances {@code A} and\n{@code B}, the {@link #next} method on this iterator will return the\nlesser of {@code A.next()} and {@code B.next()}.\n\n@param <E> the type of elements returned by this iterator.\n@since 2.1\n", "original_string": "public class CollatingIterator<E> implements Iterator<E> {\n\n    /** The {@link Comparator} used to evaluate order. */\n    private Comparator<? super E> comparator;\n\n    /** The list of {@link Iterator}s to evaluate. */\n    private final List<Iterator<? extends E>> iterators;\n\n    /** {@link Iterator#next Next} objects peeked from each iterator. */\n    private List<E> values;\n\n    /** Whether or not each {@link #values} element has been set. */\n    private BitSet valueSet;\n\n    /**\n     * Index of the {@link #iterators iterator} from whom the last returned\n     * value was obtained.\n     */\n    private int lastReturned = -1;\n\n    /**\n     * Constructs a new {@code CollatingIterator}. A comparator must be\n     * set by calling {@link #setComparator(Comparator)} before invoking\n     * {@link #hasNext()}, or {@link #next()} for the first time. Child\n     * iterators will have to be manually added using the\n     * {@link #addIterator(Iterator)} method.\n     */\n    public CollatingIterator() {\n        this(null, 2);\n    }\n\n    /**\n     * Constructs a new {@code CollatingIterator} that will use the\n     * specified comparator for ordering. Child iterators will have to be\n     * manually added using the {@link #addIterator(Iterator)} method.\n     *\n     * @param comp the comparator to use to sort; must not be null,\n     *   unless you'll be invoking {@link #setComparator(Comparator)} later on.\n     */\n    public CollatingIterator(final Comparator<? super E> comp) {\n        this(comp, 2);\n    }\n\n    /**\n     * Constructs a new {@code CollatingIterator} that will use the\n     * specified comparator to provide ordered iteration over the collection of\n     * iterators.\n     *\n     * @param comp the comparator to use to sort; must not be null,\n     *   unless you'll be invoking {@link #setComparator(Comparator)} later on.\n     * @param iterators the collection of iterators\n     * @throws NullPointerException if the iterators collection is or contains null\n     * @throws ClassCastException if the iterators collection contains an\n     *   element that's not an {@link Iterator}\n     */\n    public CollatingIterator(final Comparator<? super E> comp, final Collection<Iterator<? extends E>> iterators) {\n        this(comp, iterators.size());\n        for (final Iterator<? extends E> iterator : iterators) {\n            addIterator(iterator);\n        }\n    }\n\n    /**\n     * Constructs a new {@code CollatingIterator} that will use the\n     * specified comparator for ordering and have the specified initial\n     * capacity. Child iterators will have to be manually added using the\n     * {@link #addIterator(Iterator)} method.\n     *\n     * @param comp the comparator to use to sort; must not be null,\n     *   unless you'll be invoking {@link #setComparator(Comparator)} later on.\n     * @param initIterCapacity the initial capacity for the internal list of\n     *   child iterators\n     */\n    public CollatingIterator(final Comparator<? super E> comp, final int initIterCapacity) {\n        iterators = new ArrayList<>(initIterCapacity);\n        setComparator(comp);\n    }\n\n    /**\n     * Constructs a new {@code CollatingIterator} that will use the\n     * specified comparator to provide ordered iteration over the two given\n     * iterators.\n     *\n     * @param comp the comparator to use to sort; must not be null,\n     *   unless you'll be invoking {@link #setComparator(Comparator)} later on.\n     * @param a the first child ordered iterator\n     * @param b the second child ordered iterator\n     * @throws NullPointerException if either iterator is null\n     */\n    public CollatingIterator(final Comparator<? super E> comp, final Iterator<? extends E> a,\n                             final Iterator<? extends E> b) {\n        this(comp, 2);\n        addIterator(a);\n        addIterator(b);\n    }\n\n    /**\n     * Constructs a new {@code CollatingIterator} that will use the\n     * specified comparator to provide ordered iteration over the array of\n     * iterators.\n     *\n     * @param comp the comparator to use to sort; must not be null,\n     *   unless you'll be invoking {@link #setComparator(Comparator)} later on.\n     * @param iterators the array of iterators\n     * @throws NullPointerException if iterators array is or contains null\n     */\n    public CollatingIterator(final Comparator<? super E> comp, final Iterator<? extends E>[] iterators) {\n        this(comp, iterators.length);\n        for (final Iterator<? extends E> iterator : iterators) {\n            addIterator(iterator);\n        }\n    }\n\n    /**\n     * Adds the given {@link Iterator} to the iterators being collated.\n     *\n     * @param iterator the iterator to add to the collation, must not be null\n     * @throws IllegalStateException if iteration has started\n     * @throws NullPointerException if the iterator is null\n     */\n    public void addIterator(final Iterator<? extends E> iterator) {\n        checkNotStarted();\n        Objects.requireNonNull(iterator, \"iterator\");\n        iterators.add(iterator);\n    }\n\n    /**\n     * Returns {@code true} iff any {@link Iterator} in the given list has\n     * a next value.\n     */\n    private boolean anyHasNext(final List<Iterator<? extends E>> iterators) {\n        for (final Iterator<? extends E> iterator : iterators) {\n            if (iterator.hasNext()) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Returns {@code true} iff any bit in the given set is\n     * {@code true}.\n     */\n    private boolean anyValueSet(final BitSet set) {\n        for (int i = 0; i < set.size(); i++) {\n            if (set.get(i)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Throws {@link IllegalStateException} if iteration has started via\n     * {@link #start}.\n     *\n     * @throws IllegalStateException if iteration started\n     */\n    private void checkNotStarted() throws IllegalStateException {\n        if (values != null) {\n            throw new IllegalStateException(\"Can't do that after next or hasNext has been called.\");\n        }\n    }\n\n    /**\n     * Clears the {@link #values} and {@link #valueSet} attributes at position\n     * <em>i</em>.\n     */\n    private void clear(final int i) {\n        values.set(i, null);\n        valueSet.clear(i);\n    }\n\n    /**\n     * Gets the {@link Comparator} by which collation occurs.\n     *\n     * @return the {@link Comparator}\n     */\n    public Comparator<? super E> getComparator() {\n        return comparator;\n    }\n\n    /**\n     * Returns the index of the iterator that returned the last element.\n     *\n     * @return the index of the iterator that returned the last element\n     * @throws IllegalStateException if there is no last returned element\n     */\n    public int getIteratorIndex() {\n        if (lastReturned == -1) {\n            throw new IllegalStateException(\"No value has been returned yet\");\n        }\n\n        return lastReturned;\n    }\n\n    /**\n     * Gets the list of Iterators (unmodifiable).\n     *\n     * @return the unmodifiable list of iterators added\n     */\n    public List<Iterator<? extends E>> getIterators() {\n        return UnmodifiableList.unmodifiableList(iterators);\n    }\n\n    /**\n     * Returns {@code true} if any child iterator has remaining elements.\n     *\n     * @return true if this iterator has remaining elements\n     */\n    @Override\n    public boolean hasNext() {\n        start();\n        return anyValueSet(valueSet) || anyHasNext(iterators);\n    }\n\n    /**\n     * Returns the index of the least element in {@link #values},\n     * {@link #set(int) setting} any uninitialized values.\n     *\n     * @throws NullPointerException if no comparator is set\n     */\n    private int least() {\n        int leastIndex = -1;\n        E leastObject = null;\n        for (int i = 0; i < values.size(); i++) {\n            if (!valueSet.get(i)) {\n                set(i);\n            }\n            if (valueSet.get(i)) {\n                if (leastIndex == -1) {\n                    leastIndex = i;\n                    leastObject = values.get(i);\n                } else {\n                    final E curObject = values.get(i);\n                    Objects.requireNonNull(comparator, \"You must invoke setComparator() to set a comparator first.\");\n                    if (comparator.compare(curObject, leastObject) < 0) {\n                        leastObject = curObject;\n                        leastIndex = i;\n                    }\n                }\n            }\n        }\n        return leastIndex;\n    }\n\n    /**\n     * Returns the next ordered element from a child iterator.\n     *\n     * @return the next ordered element\n     * @throws NoSuchElementException if no child iterator has any more elements\n     */\n    @Override\n    public E next() throws NoSuchElementException {\n        if (!hasNext()) {\n            throw new NoSuchElementException();\n        }\n        final int leastIndex = least();\n        if (leastIndex == -1) {\n            throw new NoSuchElementException();\n        }\n        final E val = values.get(leastIndex);\n        clear(leastIndex);\n        lastReturned = leastIndex;\n        return val;\n    }\n\n    /**\n     * Removes the last returned element from the child iterator that produced it.\n     *\n     * @throws IllegalStateException if there is no last returned element, or if\n     * the last returned element has already been removed\n     */\n    @Override\n    public void remove() {\n        if (lastReturned == -1) {\n            throw new IllegalStateException(\"No value can be removed at present\");\n        }\n        iterators.get(lastReturned).remove();\n    }\n\n    /**\n     * Sets the {@link #values} and {@link #valueSet} attributes at position\n     * <em>i</em> to the next value of the {@link #iterators iterator} at position\n     * <em>i</em>, or clear them if the <em>i</em><sup>th</sup> iterator has no next\n     * value.\n     *\n     * @return {@code false} iff there was no value to set\n     */\n    private boolean set(final int index) {\n        final Iterator<? extends E> it = iterators.get(index);\n        if (it.hasNext()) {\n            values.set(index, it.next());\n            valueSet.set(index);\n            return true;\n        }\n        values.set(index, null);\n        valueSet.clear(index);\n        return false;\n    }\n\n    /**\n     * Sets the {@link Comparator} by which collation occurs. If you\n     * would like to use the natural sort order (or, in other words,\n     * if the elements in the iterators are implementing the\n     * {@link Comparable} interface), then use the\n     * {@link org.apache.commons.collections4.comparators.ComparableComparator}.\n     *\n     * @param comp the {@link Comparator} to set\n     * @throws IllegalStateException if iteration has started\n     */\n    public void setComparator(final Comparator<? super E> comp) {\n        checkNotStarted();\n        comparator = comp;\n    }\n\n    /**\n     * Sets the iterator at the given index.\n     *\n     * @param index index of the Iterator to replace\n     * @param iterator Iterator to place at the given index\n     * @throws IndexOutOfBoundsException if index &lt; 0 or index &gt;= size()\n     * @throws IllegalStateException if iteration has started\n     * @throws NullPointerException if the iterator is null\n     */\n    public void setIterator(final int index, final Iterator<? extends E> iterator) {\n        checkNotStarted();\n        Objects.requireNonNull(iterator, \"iterator\");\n        iterators.set(index, iterator);\n    }\n\n    /**\n     * Initializes the collating state if it hasn't been already.\n     */\n    private void start() {\n        if (values == null) {\n            values = new ArrayList<>(iterators.size());\n            valueSet = new BitSet(iterators.size());\n            for (int i = 0; i < iterators.size(); i++) {\n                values.add(null);\n                valueSet.clear(i);\n            }\n        }\n    }\n\n}", "super_interfaces": ["Iterator<E>"], "fields": [{"attribute_expression": "private Comparator<? super E> comparator;", "docstring": " The {@link Comparator} used to evaluate order.", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Comparator<? super E>", "name": "comparator", "syntax_pass": true}, {"attribute_expression": "private final List<Iterator<? extends E>> iterators;", "docstring": " The list of {@link Iterator}s to evaluate.", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<Iterator<? extends E>>", "name": "iterators", "syntax_pass": true}, {"attribute_expression": "private List<E> values;", "docstring": " {@link Iterator#next Next} objects peeked from each iterator.", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "List<E>", "name": "values", "syntax_pass": true}, {"attribute_expression": "private BitSet valueSet;", "docstring": " Whether or not each {@link #values} element has been set.", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "BitSet", "name": "valueSet", "syntax_pass": true}, {"attribute_expression": "private int lastReturned = -1;", "docstring": "\nIndex of the {@link #iterators iterator} from whom the last returned\nvalue was obtained.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "lastReturned = -1", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/iterators/TransformIterator.java.TransformIterator", "name": "TransformIterator", "file_path": "src/main/java/org/apache/commons/collections4/iterators/TransformIterator.java", "superclasses": "", "methods": ["[]TransformIterator()", "[]TransformIterator(Iterator<? extends I>)", "[]TransformIterator(Iterator<? extends I>,Transformer<? super I, ? extends O>)", "[Iterator<? extends I>]getIterator()", "[Transformer<? super I, ? extends O>]getTransformer()", "[boolean]hasNext()", "[O]next()", "[void]remove()", "[void]setIterator(Iterator<? extends I>)", "[void]setTransformer(Transformer<? super I, ? extends O>)", "[O]transform(I)"], "method_uris": ["src/main/java/org/apache/commons/collections4/iterators/TransformIterator.java.TransformIterator.[]TransformIterator()", "src/main/java/org/apache/commons/collections4/iterators/TransformIterator.java.TransformIterator.[]TransformIterator(Iterator<? extends I>)", "src/main/java/org/apache/commons/collections4/iterators/TransformIterator.java.TransformIterator.[]TransformIterator(Iterator<? extends I>,Transformer<? super I, ? extends O>)", "src/main/java/org/apache/commons/collections4/iterators/TransformIterator.java.TransformIterator.[Iterator<? extends I>]getIterator()", "src/main/java/org/apache/commons/collections4/iterators/TransformIterator.java.TransformIterator.[Transformer<? super I, ? extends O>]getTransformer()", "src/main/java/org/apache/commons/collections4/iterators/TransformIterator.java.TransformIterator.[boolean]hasNext()", "src/main/java/org/apache/commons/collections4/iterators/TransformIterator.java.TransformIterator.[O]next()", "src/main/java/org/apache/commons/collections4/iterators/TransformIterator.java.TransformIterator.[void]remove()", "src/main/java/org/apache/commons/collections4/iterators/TransformIterator.java.TransformIterator.[void]setIterator(Iterator<? extends I>)", "src/main/java/org/apache/commons/collections4/iterators/TransformIterator.java.TransformIterator.[void]setTransformer(Transformer<? super I, ? extends O>)", "src/main/java/org/apache/commons/collections4/iterators/TransformIterator.java.TransformIterator.[O]transform(I)"], "overrides": null, "attributes": [], "class_docstring": "\nDecorates an iterator such that each element returned is transformed.\n\n@param <I> the type of the input to the function.\n@param <O> the type of the result of the function.\n@since 1.0\n", "original_string": "public class TransformIterator<I, O> implements Iterator<O> {\n\n    /** The iterator being used */\n    private Iterator<? extends I> iterator;\n    /** The transformer being used */\n    private Transformer<? super I, ? extends O> transformer;\n\n    /**\n     * Constructs a new {@code TransformIterator} that will not function\n     * until the {@link #setIterator(Iterator) setIterator} and\n     * {@link #setTransformer(Transformer)} methods are invoked.\n     */\n    public TransformIterator() {\n    }\n\n    /**\n     * Constructs a new {@code TransformIterator} that won't transform\n     * elements from the given iterator.\n     *\n     * @param iterator  the iterator to use\n     */\n    public TransformIterator(final Iterator<? extends I> iterator) {\n        this.iterator = iterator;\n    }\n\n    /**\n     * Constructs a new {@code TransformIterator} that will use the\n     * given iterator and transformer.  If the given transformer is null,\n     * then objects will not be transformed.\n     *\n     * @param iterator  the iterator to use\n     * @param transformer  the transformer to use\n     */\n    public TransformIterator(final Iterator<? extends I> iterator,\n                             final Transformer<? super I, ? extends O> transformer) {\n        this.iterator = iterator;\n        this.transformer = transformer;\n    }\n\n    /**\n     * Gets the iterator this iterator is using.\n     *\n     * @return the iterator.\n     */\n    public Iterator<? extends I> getIterator() {\n        return iterator;\n    }\n\n    /**\n     * Gets the transformer this iterator is using.\n     *\n     * @return the transformer.\n     */\n    public Transformer<? super I, ? extends O> getTransformer() {\n        return transformer;\n    }\n\n    @Override\n    public boolean hasNext() {\n        return iterator.hasNext();\n    }\n\n    /**\n     * Gets the next object from the iteration, transforming it using the\n     * current transformer. If the transformer is null, no transformation\n     * occurs and the object from the iterator is returned directly.\n     *\n     * @return the next object\n     * @throws java.util.NoSuchElementException if there are no more elements\n     */\n    @Override\n    public O next() {\n        return transform(iterator.next());\n    }\n\n    @Override\n    public void remove() {\n        iterator.remove();\n    }\n\n    /**\n     * Sets the iterator for this iterator to use.\n     * If iteration has started, this effectively resets the iterator.\n     *\n     * @param iterator  the iterator to use\n     */\n    public void setIterator(final Iterator<? extends I> iterator) {\n        this.iterator = iterator;\n    }\n\n    /**\n     * Sets the transformer this the iterator to use.\n     * A null transformer is a no-op transformer.\n     *\n     * @param transformer  the transformer to use\n     */\n    public void setTransformer(final Transformer<? super I, ? extends O> transformer) {\n        this.transformer = transformer;\n    }\n\n    /**\n     * Transforms the given object using the transformer.\n     * If the transformer is null, the original object is returned as-is.\n     *\n     * @param source  the object to transform\n     * @return the transformed object\n     */\n    protected O transform(final I source) {\n        return transformer.apply(source);\n    }\n}", "super_interfaces": ["Iterator<O>"], "fields": [{"attribute_expression": "private Iterator<? extends I> iterator;", "docstring": " The iterator being used", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Iterator<? extends I>", "name": "iterator", "syntax_pass": true}, {"attribute_expression": "private Transformer<? super I, ? extends O> transformer;", "docstring": " The transformer being used", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Transformer<? super I, ? extends O>", "name": "transformer", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/iterators/IteratorChain.java.IteratorChain", "name": "IteratorChain", "file_path": "src/main/java/org/apache/commons/collections4/iterators/IteratorChain.java", "superclasses": "", "methods": ["[]IteratorChain()", "[]IteratorChain(Collection<Iterator<? extends E>>)", "[]IteratorChain(Iterator<? extends E>)", "[]IteratorChain()", "[]IteratorChain(Iterator<? extends E>,Iterator<? extends E>)", "[void]addIterator(Iterator<? extends E>)", "[void]checkLocked()", "[boolean]hasNext()", "[boolean]isLocked()", "[void]lockChain()", "[E]next()", "[void]remove()", "[int]size()", "[void]updateCurrentIterator()"], "method_uris": ["src/main/java/org/apache/commons/collections4/iterators/IteratorChain.java.IteratorChain.[]IteratorChain()", "src/main/java/org/apache/commons/collections4/iterators/IteratorChain.java.IteratorChain.[]IteratorChain(Collection<Iterator<? extends E>>)", "src/main/java/org/apache/commons/collections4/iterators/IteratorChain.java.IteratorChain.[]IteratorChain(Iterator<? extends E>)", "src/main/java/org/apache/commons/collections4/iterators/IteratorChain.java.IteratorChain.[]IteratorChain()", "src/main/java/org/apache/commons/collections4/iterators/IteratorChain.java.IteratorChain.[]IteratorChain(Iterator<? extends E>,Iterator<? extends E>)", "src/main/java/org/apache/commons/collections4/iterators/IteratorChain.java.IteratorChain.[void]addIterator(Iterator<? extends E>)", "src/main/java/org/apache/commons/collections4/iterators/IteratorChain.java.IteratorChain.[void]checkLocked()", "src/main/java/org/apache/commons/collections4/iterators/IteratorChain.java.IteratorChain.[boolean]hasNext()", "src/main/java/org/apache/commons/collections4/iterators/IteratorChain.java.IteratorChain.[boolean]isLocked()", "src/main/java/org/apache/commons/collections4/iterators/IteratorChain.java.IteratorChain.[void]lockChain()", "src/main/java/org/apache/commons/collections4/iterators/IteratorChain.java.IteratorChain.[E]next()", "src/main/java/org/apache/commons/collections4/iterators/IteratorChain.java.IteratorChain.[void]remove()", "src/main/java/org/apache/commons/collections4/iterators/IteratorChain.java.IteratorChain.[int]size()", "src/main/java/org/apache/commons/collections4/iterators/IteratorChain.java.IteratorChain.[void]updateCurrentIterator()"], "overrides": null, "attributes": [], "class_docstring": "\nAn IteratorChain is an Iterator that wraps a number of Iterators.\n<p>\nThis class makes multiple iterators look like one to the caller. When any\nmethod from the Iterator interface is called, the IteratorChain will delegate\nto a single underlying Iterator. The IteratorChain will invoke the Iterators\nin sequence until all Iterators are exhausted.\n<p>\nUnder many circumstances, linking Iterators together in this manner is more\nefficient (and convenient) than reading out the contents of each Iterator\ninto a List and creating a new Iterator.\n<p>\nCalling a method that adds new Iterator <i>after a method in the Iterator\ninterface has been called</i> will result in an UnsupportedOperationException.\n<p>\nNOTE: As from version 3.0, the IteratorChain may contain no iterators. In\nthis case the class will function as an empty iterator.\n<p>\nNOTE: As from version 4.0, the IteratorChain stores the iterators in a queue\nand removes any reference to them as soon as they are not used anymore. Thus,\nthe methods {@code setIterator(Iterator)} and {@code getIterators()} have been\nremoved and {@link #size()} will return the number of remaining iterators in\nthe queue.\n\n@param <E> the type of elements in this iterator.\n@since 2.1\n", "original_string": "public class IteratorChain<E> implements Iterator<E> {\n\n    /** The chain of iterators */\n    private final Queue<Iterator<? extends E>> iteratorChain = new LinkedList<>();\n\n    /** The current iterator */\n    private Iterator<? extends E> currentIterator;\n\n    /**\n     * The \"last used\" Iterator is the Iterator upon which next() or hasNext()\n     * was most recently called used for the remove() operation only\n     */\n    private Iterator<? extends E> lastUsedIterator;\n\n    /**\n     * ComparatorChain is \"locked\" after the first time compare(Object,Object)\n     * is called\n     */\n    private boolean isLocked;\n\n    /**\n     * Constructs an IteratorChain with no Iterators.\n     * <p>\n     * You will normally use {@link #addIterator(Iterator)} to add some\n     * iterators after using this constructor.\n     */\n    public IteratorChain() {\n    }\n\n    /**\n     * Constructs a new {@code IteratorChain} over the collection of\n     * iterators.\n     * <p>\n     * This method takes a collection of iterators. The newly constructed\n     * iterator will iterate through each one of the input iterators in turn.\n     *\n     * @param iteratorChain the collection of iterators, not null\n     * @throws NullPointerException if iterators collection is or contains null\n     * @throws ClassCastException if iterators collection doesn't contain an\n     * iterator\n     */\n    public IteratorChain(final Collection<Iterator<? extends E>> iteratorChain) {\n        for (final Iterator<? extends E> iterator : iteratorChain) {\n            addIterator(iterator);\n        }\n    }\n\n    /**\n     * Constructs an IteratorChain with a single Iterator.\n     * <p>\n     * This method takes one iterator. The newly constructed iterator will\n     * iterate through that iterator. Thus calling this constructor on its own\n     * will have no effect other than decorating the input iterator.\n     * <p>\n     * You will normally use {@link #addIterator(Iterator)} to add some more\n     * iterators after using this constructor.\n     *\n     * @param iterator the first child iterator in the IteratorChain, not null\n     * @throws NullPointerException if the iterator is null\n     */\n    public IteratorChain(final Iterator<? extends E> iterator) {\n        addIterator(iterator);\n    }\n\n    /**\n     * Constructs a new {@code IteratorChain} over the array of iterators.\n     * <p>\n     * This method takes an array of iterators. The newly constructed iterator\n     * will iterate through each one of the input iterators in turn.\n     *\n     * @param iteratorChain the array of iterators, not null\n     * @throws NullPointerException if iterators array is or contains null\n     */\n    public IteratorChain(final Iterator<? extends E>... iteratorChain) {\n        for (final Iterator<? extends E> element : iteratorChain) {\n            addIterator(element);\n        }\n    }\n\n    /**\n     * Constructs a new {@code IteratorChain} over the two given iterators.\n     * <p>\n     * This method takes two iterators. The newly constructed iterator will\n     * iterate through each one of the input iterators in turn.\n     *\n     * @param first the first child iterator in the IteratorChain, not null\n     * @param second the second child iterator in the IteratorChain, not null\n     * @throws NullPointerException if either iterator is null\n     */\n    public IteratorChain(final Iterator<? extends E> first, final Iterator<? extends E> second) {\n        addIterator(first);\n        addIterator(second);\n    }\n\n    /**\n     * Add an Iterator to the end of the chain\n     *\n     * @param iterator Iterator to add\n     * @throws IllegalStateException if I've already started iterating\n     * @throws NullPointerException if the iterator is null\n     */\n    public void addIterator(final Iterator<? extends E> iterator) {\n        checkLocked();\n        iteratorChain.add(Objects.requireNonNull(iterator, \"iterator\"));\n    }\n\n    /**\n     * Checks whether the iterator chain is now locked and in use.\n     */\n    private void checkLocked() {\n        if (isLocked) {\n            throw new UnsupportedOperationException(\n                    \"IteratorChain cannot be changed after the first use of a method from the Iterator interface\");\n        }\n    }\n\n    /**\n     * Return true if any Iterator in the IteratorChain has a remaining element.\n     *\n     * @return true if elements remain\n     */\n    @Override\n    public boolean hasNext() {\n        lockChain();\n        updateCurrentIterator();\n        lastUsedIterator = currentIterator;\n\n        return currentIterator.hasNext();\n    }\n\n    /**\n     * Determine if modifications can still be made to the IteratorChain.\n     * IteratorChains cannot be modified once they have executed a method from\n     * the Iterator interface.\n     *\n     * @return true if IteratorChain cannot be modified, false if it can\n     */\n    public boolean isLocked() {\n        return isLocked;\n    }\n\n    /**\n     * Lock the chain so no more iterators can be added. This must be called\n     * from all Iterator interface methods.\n     */\n    private void lockChain() {\n        if (!isLocked) {\n            isLocked = true;\n        }\n    }\n\n    /**\n     * Returns the next Object of the current Iterator\n     *\n     * @return Object from the current Iterator\n     * @throws java.util.NoSuchElementException if all the Iterators are\n     * exhausted\n     */\n    @Override\n    public E next() {\n        lockChain();\n        updateCurrentIterator();\n        lastUsedIterator = currentIterator;\n\n        return currentIterator.next();\n    }\n\n    /**\n     * Removes from the underlying collection the last element returned by the\n     * Iterator. As with next() and hasNext(), this method calls remove() on the\n     * underlying Iterator. Therefore, this method may throw an\n     * UnsupportedOperationException if the underlying Iterator does not support\n     * this method.\n     *\n     * @throws UnsupportedOperationException if the remove operator is not\n     * supported by the underlying Iterator\n     * @throws IllegalStateException if the next method has not yet been called,\n     * or the remove method has already been called after the last call to the\n     * next method.\n     */\n    @Override\n    public void remove() {\n        lockChain();\n        if (currentIterator == null) {\n            updateCurrentIterator();\n        }\n        lastUsedIterator.remove();\n    }\n\n    /**\n     * Returns the remaining number of Iterators in the current IteratorChain.\n     *\n     * @return Iterator count\n     */\n    public int size() {\n        return iteratorChain.size();\n    }\n\n    /**\n     * Updates the current iterator field to ensure that the current Iterator is\n     * not exhausted\n     */\n    protected void updateCurrentIterator() {\n        if (currentIterator == null) {\n            if (iteratorChain.isEmpty()) {\n                currentIterator = EmptyIterator.<E>emptyIterator();\n            } else {\n                currentIterator = iteratorChain.remove();\n            }\n            // set last used iterator here, in case the user calls remove\n            // before calling hasNext() or next() (although they shouldn't)\n            lastUsedIterator = currentIterator;\n        }\n\n        while (!currentIterator.hasNext() && !iteratorChain.isEmpty()) {\n            currentIterator = iteratorChain.remove();\n        }\n    }\n\n}", "super_interfaces": ["Iterator<E>"], "fields": [{"attribute_expression": "private final Queue<Iterator<? extends E>> iteratorChain = new LinkedList<>();", "docstring": " The chain of iterators", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Queue<Iterator<? extends E>>", "name": "iteratorChain = new LinkedList<>()", "syntax_pass": true}, {"attribute_expression": "private Iterator<? extends E> currentIterator;", "docstring": " The current iterator", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Iterator<? extends E>", "name": "currentIterator", "syntax_pass": true}, {"attribute_expression": "private Iterator<? extends E> lastUsedIterator;", "docstring": "\nThe \"last used\" Iterator is the Iterator upon which next() or hasNext()\nwas most recently called used for the remove() operation only\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Iterator<? extends E>", "name": "lastUsedIterator", "syntax_pass": true}, {"attribute_expression": "private boolean isLocked;", "docstring": "\nComparatorChain is \"locked\" after the first time compare(Object,Object)\nis called\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "isLocked", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/iterators/SingletonListIterator.java.SingletonListIterator", "name": "SingletonListIterator", "file_path": "src/main/java/org/apache/commons/collections4/iterators/SingletonListIterator.java", "superclasses": "", "methods": ["[]SingletonListIterator(E)", "[void]add(E)", "[boolean]hasNext()", "[boolean]hasPrevious()", "[E]next()", "[int]nextIndex()", "[E]previous()", "[int]previousIndex()", "[void]remove()", "[void]reset()", "[void]set(E)"], "method_uris": ["src/main/java/org/apache/commons/collections4/iterators/SingletonListIterator.java.SingletonListIterator.[]SingletonListIterator(E)", "src/main/java/org/apache/commons/collections4/iterators/SingletonListIterator.java.SingletonListIterator.[void]add(E)", "src/main/java/org/apache/commons/collections4/iterators/SingletonListIterator.java.SingletonListIterator.[boolean]hasNext()", "src/main/java/org/apache/commons/collections4/iterators/SingletonListIterator.java.SingletonListIterator.[boolean]hasPrevious()", "src/main/java/org/apache/commons/collections4/iterators/SingletonListIterator.java.SingletonListIterator.[E]next()", "src/main/java/org/apache/commons/collections4/iterators/SingletonListIterator.java.SingletonListIterator.[int]nextIndex()", "src/main/java/org/apache/commons/collections4/iterators/SingletonListIterator.java.SingletonListIterator.[E]previous()", "src/main/java/org/apache/commons/collections4/iterators/SingletonListIterator.java.SingletonListIterator.[int]previousIndex()", "src/main/java/org/apache/commons/collections4/iterators/SingletonListIterator.java.SingletonListIterator.[void]remove()", "src/main/java/org/apache/commons/collections4/iterators/SingletonListIterator.java.SingletonListIterator.[void]reset()", "src/main/java/org/apache/commons/collections4/iterators/SingletonListIterator.java.SingletonListIterator.[void]set(E)"], "overrides": null, "attributes": [], "class_docstring": "\n{@code SingletonIterator} is an {@link java.util.ListIterator} over a single\nobject instance.\n\n@param <E> the type of elements returned by this iterator.\n@since 2.1\n", "original_string": "public class SingletonListIterator<E> implements ResettableListIterator<E> {\n\n    private boolean beforeFirst = true;\n    private boolean nextCalled;\n    private boolean removed;\n    private E object;\n\n    /**\n     * Constructs a new {@code SingletonListIterator}.\n     *\n     * @param object  the single object to return from the iterator\n     */\n    public SingletonListIterator(final E object) {\n        this.object = object;\n    }\n\n    /**\n     * Add always throws {@link UnsupportedOperationException}.\n     *\n     * @param obj  the object to add\n     * @throws UnsupportedOperationException always\n     */\n    @Override\n    public void add(final E obj) {\n        throw new UnsupportedOperationException(\"add() is not supported by this iterator\");\n    }\n\n    /**\n     * Is another object available from the iterator?\n     * <p>\n     * This returns true if the single object hasn't been returned yet.\n     *\n     * @return true if the single object hasn't been returned yet\n     */\n    @Override\n    public boolean hasNext() {\n        return beforeFirst && !removed;\n    }\n\n    /**\n     * Is a previous object available from the iterator?\n     * <p>\n     * This returns true if the single object has been returned.\n     *\n     * @return true if the single object has been returned\n     */\n    @Override\n    public boolean hasPrevious() {\n        return !beforeFirst && !removed;\n    }\n\n    /**\n     * Gets the next object from the iterator.\n     * <p>\n     * This returns the single object if it hasn't been returned yet.\n     *\n     * @return the single object\n     * @throws NoSuchElementException if the single object has already\n     *    been returned\n     */\n    @Override\n    public E next() {\n        if (!beforeFirst || removed) {\n            throw new NoSuchElementException();\n        }\n        beforeFirst = false;\n        nextCalled = true;\n        return object;\n    }\n\n    /**\n     * Returns the index of the element that would be returned by a subsequent\n     * call to {@code next}.\n     *\n     * @return 0 or 1 depending on current state.\n     */\n    @Override\n    public int nextIndex() {\n        return beforeFirst ? 0 : 1;\n    }\n\n    /**\n     * Gets the previous object from the iterator.\n     * <p>\n     * This returns the single object if it has been returned.\n     *\n     * @return the single object\n     * @throws NoSuchElementException if the single object has not already\n     *    been returned\n     */\n    @Override\n    public E previous() {\n        if (beforeFirst || removed) {\n            throw new NoSuchElementException();\n        }\n        beforeFirst = true;\n        return object;\n    }\n\n    /**\n     * Returns the index of the element that would be returned by a subsequent\n     * call to {@code previous}. A return value of -1 indicates that the iterator is currently at\n     * the start.\n     *\n     * @return 0 or -1 depending on current state.\n     */\n    @Override\n    public int previousIndex() {\n        return beforeFirst ? -1 : 0;\n    }\n\n    /**\n     * Remove the object from this iterator.\n     * @throws IllegalStateException if the {@code next} or {@code previous}\n     *        method has not yet been called, or the {@code remove} method\n     *        has already been called after the last call to {@code next}\n     *        or {@code previous}.\n     */\n    @Override\n    public void remove() {\n        if (!nextCalled || removed) {\n            throw new IllegalStateException();\n        }\n        object = null;\n        removed = true;\n    }\n\n    /**\n     * Reset the iterator back to the start.\n     */\n    @Override\n    public void reset() {\n        beforeFirst = true;\n        nextCalled = false;\n    }\n\n    /**\n     * Sets sets the value of the singleton.\n     *\n     * @param object  the object to set\n     * @throws IllegalStateException if {@code next} has not been called\n     *          or the object has been removed\n     */\n    @Override\n    public void set(final E object) {\n        if (!nextCalled || removed) {\n            throw new IllegalStateException();\n        }\n        this.object = object;\n    }\n\n}", "super_interfaces": ["ResettableListIterator<E>"], "fields": [{"attribute_expression": "private boolean beforeFirst = true;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "beforeFirst = true", "syntax_pass": true}, {"attribute_expression": "private boolean nextCalled;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "nextCalled", "syntax_pass": true}, {"attribute_expression": "private boolean removed;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "removed", "syntax_pass": true}, {"attribute_expression": "private E object;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "E", "name": "object", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/iterators/ReverseListIterator.java.ReverseListIterator", "name": "ReverseListIterator", "file_path": "src/main/java/org/apache/commons/collections4/iterators/ReverseListIterator.java", "superclasses": "", "methods": ["[]ReverseListIterator(List<E>)", "[void]add(E)", "[boolean]hasNext()", "[boolean]hasPrevious()", "[E]next()", "[int]nextIndex()", "[E]previous()", "[int]previousIndex()", "[void]remove()", "[void]reset()", "[void]set(E)"], "method_uris": ["src/main/java/org/apache/commons/collections4/iterators/ReverseListIterator.java.ReverseListIterator.[]ReverseListIterator(List<E>)", "src/main/java/org/apache/commons/collections4/iterators/ReverseListIterator.java.ReverseListIterator.[void]add(E)", "src/main/java/org/apache/commons/collections4/iterators/ReverseListIterator.java.ReverseListIterator.[boolean]hasNext()", "src/main/java/org/apache/commons/collections4/iterators/ReverseListIterator.java.ReverseListIterator.[boolean]hasPrevious()", "src/main/java/org/apache/commons/collections4/iterators/ReverseListIterator.java.ReverseListIterator.[E]next()", "src/main/java/org/apache/commons/collections4/iterators/ReverseListIterator.java.ReverseListIterator.[int]nextIndex()", "src/main/java/org/apache/commons/collections4/iterators/ReverseListIterator.java.ReverseListIterator.[E]previous()", "src/main/java/org/apache/commons/collections4/iterators/ReverseListIterator.java.ReverseListIterator.[int]previousIndex()", "src/main/java/org/apache/commons/collections4/iterators/ReverseListIterator.java.ReverseListIterator.[void]remove()", "src/main/java/org/apache/commons/collections4/iterators/ReverseListIterator.java.ReverseListIterator.[void]reset()", "src/main/java/org/apache/commons/collections4/iterators/ReverseListIterator.java.ReverseListIterator.[void]set(E)"], "overrides": null, "attributes": [], "class_docstring": "\nIterates backwards through a List, starting with the last element\nand continuing to the first. This is useful for looping around\na list in reverse order without needing to actually reverse the list.\n<p>\nThe first call to {@code next()} will return the last element\nfrom the list, and so on. The {@code hasNext()} method works\nin concert with the {@code next()} method as expected.\nHowever, the {@code nextIndex()} method returns the correct\nindex in the list, thus it starts high and reduces as the iteration\ncontinues. The previous methods work similarly.\n\n@param <E> the type of elements returned by this iterator.\n@since 3.2\n", "original_string": "public class ReverseListIterator<E> implements ResettableListIterator<E> {\n\n    /** The list being wrapped. */\n    private final List<E> list;\n    /** The list iterator being wrapped. */\n    private ListIterator<E> iterator;\n    /** Flag to indicate if updating is possible at the moment. */\n    private boolean validForUpdate = true;\n\n    /**\n     * Constructor that wraps a list.\n     *\n     * @param list  the list to create a reversed iterator for\n     * @throws NullPointerException if the list is null\n     */\n    public ReverseListIterator(final List<E> list) {\n        this.list = Objects.requireNonNull(list, \"list\");\n        iterator = list.listIterator(list.size());\n    }\n\n    /**\n     * Adds a new element to the list between the next and previous elements.\n     *\n     * @param obj  the object to add\n     * @throws UnsupportedOperationException if the list is unmodifiable\n     * @throws IllegalStateException if the iterator is not in a valid state for set\n     */\n    @Override\n    public void add(final E obj) {\n        // the validForUpdate flag is needed as the necessary previous()\n        // method call re-enables remove and add\n        if (!validForUpdate) {\n            throw new IllegalStateException(\"Cannot add to list until next() or previous() called\");\n        }\n        validForUpdate = false;\n        iterator.add(obj);\n        iterator.previous();\n    }\n\n    /**\n     * Checks whether there is another element.\n     *\n     * @return true if there is another element\n     */\n    @Override\n    public boolean hasNext() {\n        return iterator.hasPrevious();\n    }\n\n    /**\n     * Checks whether there is a previous element.\n     *\n     * @return true if there is a previous element\n     */\n    @Override\n    public boolean hasPrevious() {\n        return iterator.hasNext();\n    }\n\n    /**\n     * Gets the next element.\n     * The next element is the previous in the list.\n     *\n     * @return the next element in the iterator\n     */\n    @Override\n    public E next() {\n        final E obj = iterator.previous();\n        validForUpdate = true;\n        return obj;\n    }\n\n    /**\n     * Gets the index of the next element.\n     *\n     * @return the index of the next element in the iterator\n     */\n    @Override\n    public int nextIndex() {\n        return iterator.previousIndex();\n    }\n\n    /**\n     * Gets the previous element.\n     * The next element is the previous in the list.\n     *\n     * @return the previous element in the iterator\n     */\n    @Override\n    public E previous() {\n        final E obj = iterator.next();\n        validForUpdate = true;\n        return obj;\n    }\n\n    /**\n     * Gets the index of the previous element.\n     *\n     * @return the index of the previous element in the iterator\n     */\n    @Override\n    public int previousIndex() {\n        return iterator.nextIndex();\n    }\n\n    /**\n     * Removes the last returned element.\n     *\n     * @throws UnsupportedOperationException if the list is unmodifiable\n     * @throws IllegalStateException if there is no element to remove\n     */\n    @Override\n    public void remove() {\n        if (!validForUpdate) {\n            throw new IllegalStateException(\"Cannot remove from list until next() or previous() called\");\n        }\n        iterator.remove();\n    }\n\n    /**\n     * Resets the iterator back to the start (which is the\n     * end of the list as this is a reversed iterator)\n     */\n    @Override\n    public void reset() {\n        iterator = list.listIterator(list.size());\n    }\n\n    /**\n     * Replaces the last returned element.\n     *\n     * @param obj  the object to set\n     * @throws UnsupportedOperationException if the list is unmodifiable\n     * @throws IllegalStateException if the iterator is not in a valid state for set\n     */\n    @Override\n    public void set(final E obj) {\n        if (!validForUpdate) {\n            throw new IllegalStateException(\"Cannot set to list until next() or previous() called\");\n        }\n        iterator.set(obj);\n    }\n\n}", "super_interfaces": ["ResettableListIterator<E>"], "fields": [{"attribute_expression": "private final List<E> list;", "docstring": " The list being wrapped.", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<E>", "name": "list", "syntax_pass": true}, {"attribute_expression": "private ListIterator<E> iterator;", "docstring": " The list iterator being wrapped.", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ListIterator<E>", "name": "iterator", "syntax_pass": true}, {"attribute_expression": "private boolean validForUpdate = true;", "docstring": " Flag to indicate if updating is possible at the moment.", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "validForUpdate = true", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/iterators/EmptyIterator.java.EmptyIterator", "name": "EmptyIterator", "file_path": "src/main/java/org/apache/commons/collections4/iterators/EmptyIterator.java", "superclasses": "", "methods": ["[Iterator<E>]emptyIterator()", "[ResettableIterator<E>]resettableEmptyIterator()", "[]EmptyIterator()"], "method_uris": ["src/main/java/org/apache/commons/collections4/iterators/EmptyIterator.java.EmptyIterator.[Iterator<E>]emptyIterator()", "src/main/java/org/apache/commons/collections4/iterators/EmptyIterator.java.EmptyIterator.[ResettableIterator<E>]resettableEmptyIterator()", "src/main/java/org/apache/commons/collections4/iterators/EmptyIterator.java.EmptyIterator.[]EmptyIterator()"], "overrides": null, "attributes": [], "class_docstring": "\nProvides an implementation of an empty iterator.\n<p>\nThis class provides an implementation of an empty iterator.\nThis class provides for binary compatibility between Commons Collections\n2.1.1 and 3.1 due to issues with {@code IteratorUtils}.\n\n@param <E> the type of elements returned by this iterator.\n@since 2.1.1 and 3.1\n", "original_string": "public class EmptyIterator<E> extends AbstractEmptyIterator<E> {\n\n    /**\n     * Singleton instance of the iterator.\n     * @since 3.1\n     */\n    @SuppressWarnings(\"rawtypes\")\n    public static final ResettableIterator RESETTABLE_INSTANCE = new EmptyIterator<>();\n\n    /**\n     * Singleton instance of the iterator.\n     * @since 2.1.1 and 3.1\n     */\n    @SuppressWarnings(\"rawtypes\")\n    public static final Iterator INSTANCE = RESETTABLE_INSTANCE;\n\n    /**\n     * Gets a typed empty iterator instance.\n     * @param <E> the element type\n     * @return Iterator&lt;E&gt;\n     */\n    public static <E> Iterator<E> emptyIterator() {\n        return INSTANCE;\n    }\n\n    /**\n     * Gets a typed resettable empty iterator instance.\n     * @param <E> the element type\n     * @return ResettableIterator&lt;E&gt;\n     */\n    public static <E> ResettableIterator<E> resettableEmptyIterator() {\n        return RESETTABLE_INSTANCE;\n    }\n\n    /**\n     * Constructs a new instance.\n     */\n    protected EmptyIterator() {\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "@SuppressWarnings(\"rawtypes\")\n    public static final ResettableIterator RESETTABLE_INSTANCE = new EmptyIterator<>();", "docstring": "\nSingleton instance of the iterator.\n@since 3.1\n", "modifiers": "@SuppressWarnings(\"rawtypes\")\n    public static final", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"rawtypes\")", "public", "static", "final"], "comments": [], "type": "ResettableIterator", "name": "RESETTABLE_INSTANCE = new EmptyIterator<>()", "syntax_pass": true}, {"attribute_expression": "@SuppressWarnings(\"rawtypes\")\n    public static final Iterator INSTANCE = RESETTABLE_INSTANCE;", "docstring": "\nSingleton instance of the iterator.\n@since 2.1.1 and 3.1\n", "modifiers": "@SuppressWarnings(\"rawtypes\")\n    public static final", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"rawtypes\")", "public", "static", "final"], "comments": [], "type": "Iterator", "name": "INSTANCE = RESETTABLE_INSTANCE", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/iterators/UnmodifiableOrderedMapIterator.java.UnmodifiableOrderedMapIterator", "name": "UnmodifiableOrderedMapIterator", "file_path": "src/main/java/org/apache/commons/collections4/iterators/UnmodifiableOrderedMapIterator.java", "superclasses": "", "methods": ["[OrderedMapIterator<K, V>]unmodifiableOrderedMapIterator(OrderedMapIterator<K, ? extends V>)", "[]UnmodifiableOrderedMapIterator(OrderedMapIterator<K, ? extends V>)", "[K]getKey()", "[V]getValue()", "[boolean]hasNext()", "[boolean]hasPrevious()", "[K]next()", "[K]previous()", "[void]remove()", "[V]setValue(V)"], "method_uris": ["src/main/java/org/apache/commons/collections4/iterators/UnmodifiableOrderedMapIterator.java.UnmodifiableOrderedMapIterator.[OrderedMapIterator<K, V>]unmodifiableOrderedMapIterator(OrderedMapIterator<K, ? extends V>)", "src/main/java/org/apache/commons/collections4/iterators/UnmodifiableOrderedMapIterator.java.UnmodifiableOrderedMapIterator.[]UnmodifiableOrderedMapIterator(OrderedMapIterator<K, ? extends V>)", "src/main/java/org/apache/commons/collections4/iterators/UnmodifiableOrderedMapIterator.java.UnmodifiableOrderedMapIterator.[K]getKey()", "src/main/java/org/apache/commons/collections4/iterators/UnmodifiableOrderedMapIterator.java.UnmodifiableOrderedMapIterator.[V]getValue()", "src/main/java/org/apache/commons/collections4/iterators/UnmodifiableOrderedMapIterator.java.UnmodifiableOrderedMapIterator.[boolean]hasNext()", "src/main/java/org/apache/commons/collections4/iterators/UnmodifiableOrderedMapIterator.java.UnmodifiableOrderedMapIterator.[boolean]hasPrevious()", "src/main/java/org/apache/commons/collections4/iterators/UnmodifiableOrderedMapIterator.java.UnmodifiableOrderedMapIterator.[K]next()", "src/main/java/org/apache/commons/collections4/iterators/UnmodifiableOrderedMapIterator.java.UnmodifiableOrderedMapIterator.[K]previous()", "src/main/java/org/apache/commons/collections4/iterators/UnmodifiableOrderedMapIterator.java.UnmodifiableOrderedMapIterator.[void]remove()", "src/main/java/org/apache/commons/collections4/iterators/UnmodifiableOrderedMapIterator.java.UnmodifiableOrderedMapIterator.[V]setValue(V)"], "overrides": null, "attributes": [], "class_docstring": "\nDecorates an ordered map iterator such that it cannot be modified.\n<p>\nAttempts to modify it will result in an UnsupportedOperationException.\n</p>\n\n@param <K> the type of keys\n@param <V> the type of mapped values\n@since 3.0\n", "original_string": "public final class UnmodifiableOrderedMapIterator<K, V> implements OrderedMapIterator<K, V>,\n        Unmodifiable {\n\n    /**\n     * Decorates the specified iterator such that it cannot be modified.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param iterator  the iterator to decorate\n     * @return a new unmodifiable ordered map iterator\n     * @throws NullPointerException if the iterator is null\n     */\n    public static <K, V> OrderedMapIterator<K, V> unmodifiableOrderedMapIterator(\n            final OrderedMapIterator<K, ? extends V> iterator) {\n        Objects.requireNonNull(iterator, \"iterator\");\n        if (iterator instanceof Unmodifiable) {\n            @SuppressWarnings(\"unchecked\") // safe to upcast\n            final OrderedMapIterator<K, V> tmpIterator = (OrderedMapIterator<K, V>) iterator;\n            return tmpIterator;\n        }\n        return new UnmodifiableOrderedMapIterator<>(iterator);\n    }\n\n    /** The iterator being decorated */\n    private final OrderedMapIterator<? extends K, ? extends V> iterator;\n\n    /**\n     * Constructs a new instance.\n     *\n     * @param iterator  the iterator to decorate\n     */\n    private UnmodifiableOrderedMapIterator(final OrderedMapIterator<K, ? extends V> iterator) {\n        this.iterator = iterator;\n    }\n\n    @Override\n    public K getKey() {\n        return iterator.getKey();\n    }\n\n    @Override\n    public V getValue() {\n        return iterator.getValue();\n    }\n\n    @Override\n    public boolean hasNext() {\n        return iterator.hasNext();\n    }\n\n    @Override\n    public boolean hasPrevious() {\n        return iterator.hasPrevious();\n    }\n\n    @Override\n    public K next() {\n        return iterator.next();\n    }\n\n    @Override\n    public K previous() {\n        return iterator.previous();\n    }\n\n    @Override\n    public void remove() {\n        throw new UnsupportedOperationException(\"remove() is not supported\");\n    }\n\n    @Override\n    public V setValue(final V value) {\n        throw new UnsupportedOperationException(\"setValue() is not supported\");\n    }\n\n}", "super_interfaces": ["OrderedMapIterator<K, V>", "Unmodifiable"], "fields": [{"attribute_expression": "private final OrderedMapIterator<? extends K, ? extends V> iterator;", "docstring": " The iterator being decorated", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "OrderedMapIterator<? extends K, ? extends V>", "name": "iterator", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/iterators/EntrySetMapIterator.java.EntrySetMapIterator", "name": "EntrySetMapIterator", "file_path": "src/main/java/org/apache/commons/collections4/iterators/EntrySetMapIterator.java", "superclasses": "", "methods": ["[]EntrySetMapIterator(Map<K, V>)", "[K]getKey()", "[V]getValue()", "[boolean]hasNext()", "[K]next()", "[void]remove()", "[void]reset()", "[V]setValue(V)", "[String]toString()"], "method_uris": ["src/main/java/org/apache/commons/collections4/iterators/EntrySetMapIterator.java.EntrySetMapIterator.[]EntrySetMapIterator(Map<K, V>)", "src/main/java/org/apache/commons/collections4/iterators/EntrySetMapIterator.java.EntrySetMapIterator.[K]getKey()", "src/main/java/org/apache/commons/collections4/iterators/EntrySetMapIterator.java.EntrySetMapIterator.[V]getValue()", "src/main/java/org/apache/commons/collections4/iterators/EntrySetMapIterator.java.EntrySetMapIterator.[boolean]hasNext()", "src/main/java/org/apache/commons/collections4/iterators/EntrySetMapIterator.java.EntrySetMapIterator.[K]next()", "src/main/java/org/apache/commons/collections4/iterators/EntrySetMapIterator.java.EntrySetMapIterator.[void]remove()", "src/main/java/org/apache/commons/collections4/iterators/EntrySetMapIterator.java.EntrySetMapIterator.[void]reset()", "src/main/java/org/apache/commons/collections4/iterators/EntrySetMapIterator.java.EntrySetMapIterator.[V]setValue(V)", "src/main/java/org/apache/commons/collections4/iterators/EntrySetMapIterator.java.EntrySetMapIterator.[String]toString()"], "overrides": null, "attributes": [], "class_docstring": "\nImplements a {@code MapIterator} using a Map entrySet.\nReverse iteration is not supported.\n<pre>\nMapIterator it = map.mapIterator();\nwhile (it.hasNext()) {\n  Object key = it.next();\n  Object value = it.getValue();\n  it.setValue(newValue);\n}\n</pre>\n\n@param <K> the type of keys\n@param <V> the type of mapped values\n@since 3.0\n", "original_string": "public class EntrySetMapIterator<K, V> implements MapIterator<K, V>, ResettableIterator<K> {\n\n    private final Map<K, V> map;\n    private Iterator<Map.Entry<K, V>> iterator;\n    private Map.Entry<K, V> last;\n    private boolean canRemove;\n\n    /**\n     * Constructs a new instance.\n     *\n     * @param map  the map to iterate over\n     */\n    public EntrySetMapIterator(final Map<K, V> map) {\n        this.map = map;\n        this.iterator = map.entrySet().iterator();\n    }\n\n    /**\n     * Gets the current key, which is the key returned by the last call\n     * to {@code next()}.\n     *\n     * @return the current key\n     * @throws IllegalStateException if {@code next()} has not yet been called\n     */\n    @Override\n    public K getKey() {\n        if (last == null) {\n            throw new IllegalStateException(\"Iterator getKey() can only be called after next() and before remove()\");\n        }\n        return last.getKey();\n    }\n\n    /**\n     * Gets the current value, which is the value associated with the last key\n     * returned by {@code next()}.\n     *\n     * @return the current value\n     * @throws IllegalStateException if {@code next()} has not yet been called\n     */\n    @Override\n    public V getValue() {\n        if (last == null) {\n            throw new IllegalStateException(\"Iterator getValue() can only be called after next() and before remove()\");\n        }\n        return last.getValue();\n    }\n\n    /**\n     * Checks to see if there are more entries still to be iterated.\n     *\n     * @return {@code true} if the iterator has more elements\n     */\n    @Override\n    public boolean hasNext() {\n        return iterator.hasNext();\n    }\n\n    /**\n     * Gets the next <em>key</em> from the {@code Map}.\n     *\n     * @return the next key in the iteration\n     * @throws java.util.NoSuchElementException if the iteration is finished\n     */\n    @Override\n    public K next() {\n        last = iterator.next();\n        canRemove = true;\n        return last.getKey();\n    }\n\n    /**\n     * Removes the last returned key from the underlying {@code Map}.\n     * <p>\n     * This method can be called once per call to {@code next()}.\n     *\n     * @throws UnsupportedOperationException if remove is not supported by the map\n     * @throws IllegalStateException if {@code next()} has not yet been called\n     * @throws IllegalStateException if {@code remove()} has already been called\n     *  since the last call to {@code next()}\n     */\n    @Override\n    public void remove() {\n        if (!canRemove) {\n            throw new IllegalStateException(\"Iterator remove() can only be called once after next()\");\n        }\n        iterator.remove();\n        last = null;\n        canRemove = false;\n    }\n\n    /**\n     * Resets the state of the iterator.\n     */\n    @Override\n    public void reset() {\n        iterator = map.entrySet().iterator();\n        last = null;\n        canRemove = false;\n    }\n\n    /**\n     * Sets the value associated with the current key.\n     *\n     * @param value  the new value\n     * @return the previous value\n     * @throws UnsupportedOperationException if setValue is not supported by the map\n     * @throws IllegalStateException if {@code next()} has not yet been called\n     * @throws IllegalStateException if {@code remove()} has been called since the\n     *  last call to {@code next()}\n     */\n    @Override\n    public V setValue(final V value) {\n        if (last == null) {\n            throw new IllegalStateException(\"Iterator setValue() can only be called after next() and before remove()\");\n        }\n        return last.setValue(value);\n    }\n\n    /**\n     * Gets the iterator as a String.\n     *\n     * @return a string version of the iterator\n     */\n    @Override\n    public String toString() {\n        if (last != null) {\n            return \"MapIterator[\" + getKey() + \"=\" + getValue() + \"]\";\n        }\n        return \"MapIterator[]\";\n    }\n\n}", "super_interfaces": ["MapIterator<K, V>", "ResettableIterator<K>"], "fields": [{"attribute_expression": "private final Map<K, V> map;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Map<K, V>", "name": "map", "syntax_pass": true}, {"attribute_expression": "private Iterator<Map.Entry<K, V>> iterator;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Iterator<Map.Entry<K, V>>", "name": "iterator", "syntax_pass": true}, {"attribute_expression": "private Map.Entry<K, V> last;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Map.Entry<K, V>", "name": "last", "syntax_pass": true}, {"attribute_expression": "private boolean canRemove;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "canRemove", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/iterators/AbstractMapIteratorDecorator.java.AbstractMapIteratorDecorator", "name": "AbstractMapIteratorDecorator", "file_path": "src/main/java/org/apache/commons/collections4/iterators/AbstractMapIteratorDecorator.java", "superclasses": "", "methods": ["[]AbstractMapIteratorDecorator(MapIterator<K, V>)", "[K]getKey()", "[MapIterator<K, V>]getMapIterator()", "[V]getValue()", "[boolean]hasNext()", "[K]next()", "[void]remove()", "[V]setValue(V)"], "method_uris": ["src/main/java/org/apache/commons/collections4/iterators/AbstractMapIteratorDecorator.java.AbstractMapIteratorDecorator.[]AbstractMapIteratorDecorator(MapIterator<K, V>)", "src/main/java/org/apache/commons/collections4/iterators/AbstractMapIteratorDecorator.java.AbstractMapIteratorDecorator.[K]getKey()", "src/main/java/org/apache/commons/collections4/iterators/AbstractMapIteratorDecorator.java.AbstractMapIteratorDecorator.[MapIterator<K, V>]getMapIterator()", "src/main/java/org/apache/commons/collections4/iterators/AbstractMapIteratorDecorator.java.AbstractMapIteratorDecorator.[V]getValue()", "src/main/java/org/apache/commons/collections4/iterators/AbstractMapIteratorDecorator.java.AbstractMapIteratorDecorator.[boolean]hasNext()", "src/main/java/org/apache/commons/collections4/iterators/AbstractMapIteratorDecorator.java.AbstractMapIteratorDecorator.[K]next()", "src/main/java/org/apache/commons/collections4/iterators/AbstractMapIteratorDecorator.java.AbstractMapIteratorDecorator.[void]remove()", "src/main/java/org/apache/commons/collections4/iterators/AbstractMapIteratorDecorator.java.AbstractMapIteratorDecorator.[V]setValue(V)"], "overrides": null, "attributes": [], "class_docstring": "\nProvides basic behavior for decorating a map iterator with extra functionality.\n<p>\nAll methods are forwarded to the decorated map iterator.\n\n@param <K> the type of keys\n@param <V> the type of mapped values\n@since 3.0\n", "original_string": "public class AbstractMapIteratorDecorator<K, V> implements MapIterator<K, V> {\n\n    /** The iterator being decorated */\n    private final MapIterator<K, V> iterator;\n\n    /**\n     * Constructor that decorates the specified iterator.\n     *\n     * @param iterator  the iterator to decorate, must not be null\n     * @throws NullPointerException if the iterator is null\n     */\n    public AbstractMapIteratorDecorator(final MapIterator<K, V> iterator) {\n        this.iterator = Objects.requireNonNull(iterator, \"iterator\");\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public K getKey() {\n        return iterator.getKey();\n    }\n\n    /**\n     * Gets the iterator being decorated.\n     *\n     * @return the decorated iterator\n     */\n    protected MapIterator<K, V> getMapIterator() {\n        return iterator;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public V getValue() {\n        return iterator.getValue();\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean hasNext() {\n        return iterator.hasNext();\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public K next() {\n        return iterator.next();\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void remove() {\n        iterator.remove();\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public V setValue(final V value) {\n        return iterator.setValue(value);\n    }\n\n}", "super_interfaces": ["MapIterator<K, V>"], "fields": [{"attribute_expression": "private final MapIterator<K, V> iterator;", "docstring": " The iterator being decorated", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "MapIterator<K, V>", "name": "iterator", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/iterators/AbstractListIteratorDecorator.java.AbstractListIteratorDecorator", "name": "AbstractListIteratorDecorator", "file_path": "src/main/java/org/apache/commons/collections4/iterators/AbstractListIteratorDecorator.java", "superclasses": "", "methods": ["[]AbstractListIteratorDecorator(ListIterator<E>)", "[void]add(E)", "[ListIterator<E>]getListIterator()", "[boolean]hasNext()", "[boolean]hasPrevious()", "[E]next()", "[int]nextIndex()", "[E]previous()", "[int]previousIndex()", "[void]remove()", "[void]set(E)"], "method_uris": ["src/main/java/org/apache/commons/collections4/iterators/AbstractListIteratorDecorator.java.AbstractListIteratorDecorator.[]AbstractListIteratorDecorator(ListIterator<E>)", "src/main/java/org/apache/commons/collections4/iterators/AbstractListIteratorDecorator.java.AbstractListIteratorDecorator.[void]add(E)", "src/main/java/org/apache/commons/collections4/iterators/AbstractListIteratorDecorator.java.AbstractListIteratorDecorator.[ListIterator<E>]getListIterator()", "src/main/java/org/apache/commons/collections4/iterators/AbstractListIteratorDecorator.java.AbstractListIteratorDecorator.[boolean]hasNext()", "src/main/java/org/apache/commons/collections4/iterators/AbstractListIteratorDecorator.java.AbstractListIteratorDecorator.[boolean]hasPrevious()", "src/main/java/org/apache/commons/collections4/iterators/AbstractListIteratorDecorator.java.AbstractListIteratorDecorator.[E]next()", "src/main/java/org/apache/commons/collections4/iterators/AbstractListIteratorDecorator.java.AbstractListIteratorDecorator.[int]nextIndex()", "src/main/java/org/apache/commons/collections4/iterators/AbstractListIteratorDecorator.java.AbstractListIteratorDecorator.[E]previous()", "src/main/java/org/apache/commons/collections4/iterators/AbstractListIteratorDecorator.java.AbstractListIteratorDecorator.[int]previousIndex()", "src/main/java/org/apache/commons/collections4/iterators/AbstractListIteratorDecorator.java.AbstractListIteratorDecorator.[void]remove()", "src/main/java/org/apache/commons/collections4/iterators/AbstractListIteratorDecorator.java.AbstractListIteratorDecorator.[void]set(E)"], "overrides": null, "attributes": [], "class_docstring": "\nProvides basic behavior for decorating a list iterator with extra functionality.\n<p>\nAll methods are forwarded to the decorated list iterator.\n</p>\n\n@param <E> the type of elements in this iterator.\n@since 3.0\n", "original_string": "public class AbstractListIteratorDecorator<E> implements ListIterator<E> {\n\n    /** The iterator being decorated */\n    private final ListIterator<E> iterator;\n\n    /**\n     * Constructor that decorates the specified iterator.\n     *\n     * @param iterator  the iterator to decorate, must not be null\n     * @throws NullPointerException if the iterator is null\n     */\n    public AbstractListIteratorDecorator(final ListIterator<E> iterator) {\n        this.iterator = Objects.requireNonNull(iterator, \"iterator\");\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void add(final E obj) {\n        iterator.add(obj);\n    }\n\n    /**\n     * Gets the iterator being decorated.\n     *\n     * @return the decorated iterator\n     */\n    protected ListIterator<E> getListIterator() {\n        return iterator;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean hasNext() {\n        return iterator.hasNext();\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public boolean hasPrevious() {\n        return iterator.hasPrevious();\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public E next() {\n        return iterator.next();\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public int nextIndex() {\n        return iterator.nextIndex();\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public E previous() {\n        return iterator.previous();\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public int previousIndex() {\n        return iterator.previousIndex();\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void remove() {\n        iterator.remove();\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public void set(final E obj) {\n        iterator.set(obj);\n    }\n\n}", "super_interfaces": ["ListIterator<E>"], "fields": [{"attribute_expression": "private final ListIterator<E> iterator;", "docstring": " The iterator being decorated", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ListIterator<E>", "name": "iterator", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/iterators/ArrayIterator.java.ArrayIterator", "name": "ArrayIterator", "file_path": "src/main/java/org/apache/commons/collections4/iterators/ArrayIterator.java", "superclasses": "", "methods": ["[]ArrayIterator(Object)", "[]ArrayIterator(Object,int)", "[]ArrayIterator(Object,int,int)", "[void]checkBound(int,int,String)", "[Object]getArray()", "[int]getEndIndex()", "[int]getStartIndex()", "[boolean]hasNext()", "[E]next()", "[void]remove()", "[void]reset()"], "method_uris": ["src/main/java/org/apache/commons/collections4/iterators/ArrayIterator.java.ArrayIterator.[]ArrayIterator(Object)", "src/main/java/org/apache/commons/collections4/iterators/ArrayIterator.java.ArrayIterator.[]ArrayIterator(Object,int)", "src/main/java/org/apache/commons/collections4/iterators/ArrayIterator.java.ArrayIterator.[]ArrayIterator(Object,int,int)", "src/main/java/org/apache/commons/collections4/iterators/ArrayIterator.java.ArrayIterator.[void]checkBound(int,int,String)", "src/main/java/org/apache/commons/collections4/iterators/ArrayIterator.java.ArrayIterator.[Object]getArray()", "src/main/java/org/apache/commons/collections4/iterators/ArrayIterator.java.ArrayIterator.[int]getEndIndex()", "src/main/java/org/apache/commons/collections4/iterators/ArrayIterator.java.ArrayIterator.[int]getStartIndex()", "src/main/java/org/apache/commons/collections4/iterators/ArrayIterator.java.ArrayIterator.[boolean]hasNext()", "src/main/java/org/apache/commons/collections4/iterators/ArrayIterator.java.ArrayIterator.[E]next()", "src/main/java/org/apache/commons/collections4/iterators/ArrayIterator.java.ArrayIterator.[void]remove()", "src/main/java/org/apache/commons/collections4/iterators/ArrayIterator.java.ArrayIterator.[void]reset()"], "overrides": null, "attributes": [], "class_docstring": "\nImplements an {@link java.util.Iterator Iterator} over any array.\n<p>\nThe array can be either an array of object or of primitives. If you know\nthat you have an object array, the\n{@link org.apache.commons.collections4.iterators.ObjectArrayIterator ObjectArrayIterator}\nclass is a better choice, as it will perform better.\n<p>\nThe iterator implements a {@link #reset} method, allowing the reset of\nthe iterator back to the start if required.\n\n@param <E> the type of elements returned by this iterator.\n@since 1.0\n", "original_string": "public class ArrayIterator<E> implements ResettableIterator<E> {\n\n    /** The array to iterate over */\n    final Object array;\n    /** The start index to loop from */\n    final int startIndex;\n    /** The end index to loop to */\n    final int endIndex;\n    /** The current iterator index */\n    int index;\n\n    /**\n     * Constructs an ArrayIterator that will iterate over the values in the\n     * specified array.\n     *\n     * @param array the array to iterate over.\n     * @throws IllegalArgumentException if {@code array} is not an array.\n     * @throws NullPointerException if {@code array} is {@code null}\n     */\n    public ArrayIterator(final Object array) {\n        this(array, 0);\n    }\n\n    /**\n     * Constructs an ArrayIterator that will iterate over the values in the\n     * specified array from a specific start index.\n     *\n     * @param array  the array to iterate over.\n     * @param startIndex  the index to start iterating at.\n     * @throws IllegalArgumentException if {@code array} is not an array.\n     * @throws NullPointerException if {@code array} is {@code null}\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    public ArrayIterator(final Object array, final int startIndex) {\n        this(array, startIndex, Array.getLength(array));\n    }\n\n    /**\n     * Constructs an ArrayIterator that will iterate over a range of values\n     * in the specified array.\n     *\n     * @param array  the array to iterate over.\n     * @param startIndex  the index to start iterating at.\n     * @param endIndex  the index to finish iterating at.\n     * @throws IllegalArgumentException if {@code array} is not an array.\n     * @throws NullPointerException if {@code array} is {@code null}\n     * @throws IndexOutOfBoundsException if either index is invalid\n     */\n    public ArrayIterator(final Object array, final int startIndex, final int endIndex) {\n        this.array = array;\n        this.startIndex = startIndex;\n        this.endIndex = endIndex;\n        this.index = startIndex;\n\n        final int len = Array.getLength(array);\n        checkBound(startIndex, len, \"start\");\n        checkBound(endIndex, len, \"end\");\n        if (endIndex < startIndex) {\n            throw new IllegalArgumentException(\"End index must not be less than start index.\");\n        }\n    }\n\n    /**\n     * Checks whether the index is valid or not.\n     *\n     * @param bound  the index to check\n     * @param len  the length of the array\n     * @param type  the index type (for error messages)\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    protected void checkBound(final int bound, final int len, final String type ) {\n        if (bound > len) {\n            throw new ArrayIndexOutOfBoundsException(\n              \"Attempt to make an ArrayIterator that \" + type +\n              \"s beyond the end of the array. \"\n            );\n        }\n        if (bound < 0) {\n            throw new ArrayIndexOutOfBoundsException(\n              \"Attempt to make an ArrayIterator that \" + type +\n              \"s before the start of the array. \"\n            );\n        }\n    }\n\n    // Properties\n    /**\n     * Gets the array that this iterator is iterating over.\n     *\n     * @return the array this iterator iterates over.\n     */\n    public Object getArray() {\n        return array;\n    }\n\n    /**\n     * Gets the end index to loop to.\n     *\n     * @return the end index\n     * @since 4.0\n     */\n    public int getEndIndex() {\n        return endIndex;\n    }\n\n    /**\n     * Gets the start index to loop from.\n     *\n     * @return the start index\n     * @since 4.0\n     */\n    public int getStartIndex() {\n        return startIndex;\n    }\n\n    // Iterator interface\n    /**\n     * Returns true if there are more elements to return from the array.\n     *\n     * @return true if there is a next element to return\n     */\n    @Override\n    public boolean hasNext() {\n        return index < endIndex;\n    }\n\n    /**\n     * Returns the next element in the array.\n     *\n     * @return the next element in the array\n     * @throws NoSuchElementException if all the elements in the array\n     *  have already been returned\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public E next() {\n        if (!hasNext()) {\n            throw new NoSuchElementException();\n        }\n        return (E) Array.get(array, index++);\n    }\n\n    /**\n     * Throws {@link UnsupportedOperationException}.\n     *\n     * @throws UnsupportedOperationException always\n     */\n    @Override\n    public void remove() {\n        throw new UnsupportedOperationException(\"remove() method is not supported\");\n    }\n\n    /**\n     * Resets the iterator back to the start index.\n     */\n    @Override\n    public void reset() {\n        index = startIndex;\n    }\n\n}", "super_interfaces": ["ResettableIterator<E>"], "fields": [{"attribute_expression": "final Object array;", "docstring": " The array to iterate over", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Object", "name": "array", "syntax_pass": true}, {"attribute_expression": "final int startIndex;", "docstring": " The start index to loop from", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "int", "name": "startIndex", "syntax_pass": true}, {"attribute_expression": "final int endIndex;", "docstring": " The end index to loop to", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "int", "name": "endIndex", "syntax_pass": true}, {"attribute_expression": "int index;", "docstring": " The current iterator index", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int", "name": "index", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/iterators/EmptyOrderedIterator.java.EmptyOrderedIterator", "name": "EmptyOrderedIterator", "file_path": "src/main/java/org/apache/commons/collections4/iterators/EmptyOrderedIterator.java", "superclasses": "", "methods": ["[OrderedIterator<E>]emptyOrderedIterator()", "[]EmptyOrderedIterator()"], "method_uris": ["src/main/java/org/apache/commons/collections4/iterators/EmptyOrderedIterator.java.EmptyOrderedIterator.[OrderedIterator<E>]emptyOrderedIterator()", "src/main/java/org/apache/commons/collections4/iterators/EmptyOrderedIterator.java.EmptyOrderedIterator.[]EmptyOrderedIterator()"], "overrides": null, "attributes": [], "class_docstring": "\nProvides an implementation of an empty ordered iterator.\n\n@param <E> the type of elements returned by this iterator.\n@since 3.1\n", "original_string": "public class EmptyOrderedIterator<E> extends AbstractEmptyIterator<E>\n        implements OrderedIterator<E> {\n\n    /**\n     * Singleton instance of the iterator.\n     *\n     * @since 3.1\n     */\n    @SuppressWarnings(\"rawtypes\")\n    public static final OrderedIterator INSTANCE = new EmptyOrderedIterator<>();\n\n    /**\n     * Typed instance of the iterator.\n     *\n     * @param <E> the element type\n     * @return OrderedIterator&lt;E&gt;\n     */\n    public static <E> OrderedIterator<E> emptyOrderedIterator() {\n        return INSTANCE;\n    }\n\n    /**\n     * Constructs a new instance.\n     */\n    protected EmptyOrderedIterator() {\n    }\n\n}", "super_interfaces": ["OrderedIterator<E>"], "fields": [{"attribute_expression": "@SuppressWarnings(\"rawtypes\")\n    public static final OrderedIterator INSTANCE = new EmptyOrderedIterator<>();", "docstring": "\nSingleton instance of the iterator.\n\n@since 3.1\n", "modifiers": "@SuppressWarnings(\"rawtypes\")\n    public static final", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"rawtypes\")", "public", "static", "final"], "comments": [], "type": "OrderedIterator", "name": "INSTANCE = new EmptyOrderedIterator<>()", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/iterators/LoopingListIterator.java.LoopingListIterator", "name": "LoopingListIterator", "file_path": "src/main/java/org/apache/commons/collections4/iterators/LoopingListIterator.java", "superclasses": "", "methods": ["[]LoopingListIterator(List<E>)", "[void]add(E)", "[boolean]hasNext()", "[boolean]hasPrevious()", "[void]init()", "[E]next()", "[int]nextIndex()", "[E]previous()", "[int]previousIndex()", "[void]remove()", "[void]reset()", "[void]set(E)", "[int]size()"], "method_uris": ["src/main/java/org/apache/commons/collections4/iterators/LoopingListIterator.java.LoopingListIterator.[]LoopingListIterator(List<E>)", "src/main/java/org/apache/commons/collections4/iterators/LoopingListIterator.java.LoopingListIterator.[void]add(E)", "src/main/java/org/apache/commons/collections4/iterators/LoopingListIterator.java.LoopingListIterator.[boolean]hasNext()", "src/main/java/org/apache/commons/collections4/iterators/LoopingListIterator.java.LoopingListIterator.[boolean]hasPrevious()", "src/main/java/org/apache/commons/collections4/iterators/LoopingListIterator.java.LoopingListIterator.[void]init()", "src/main/java/org/apache/commons/collections4/iterators/LoopingListIterator.java.LoopingListIterator.[E]next()", "src/main/java/org/apache/commons/collections4/iterators/LoopingListIterator.java.LoopingListIterator.[int]nextIndex()", "src/main/java/org/apache/commons/collections4/iterators/LoopingListIterator.java.LoopingListIterator.[E]previous()", "src/main/java/org/apache/commons/collections4/iterators/LoopingListIterator.java.LoopingListIterator.[int]previousIndex()", "src/main/java/org/apache/commons/collections4/iterators/LoopingListIterator.java.LoopingListIterator.[void]remove()", "src/main/java/org/apache/commons/collections4/iterators/LoopingListIterator.java.LoopingListIterator.[void]reset()", "src/main/java/org/apache/commons/collections4/iterators/LoopingListIterator.java.LoopingListIterator.[void]set(E)", "src/main/java/org/apache/commons/collections4/iterators/LoopingListIterator.java.LoopingListIterator.[int]size()"], "overrides": null, "attributes": [], "class_docstring": "\nA ListIterator that restarts when it reaches the end or when it\nreaches the beginning.\n<p>\nThe iterator will loop continuously around the provided list,\nunless there are no elements in the collection to begin with, or\nall of the elements have been {@link #remove removed}.\n<p>\nConcurrent modifications are not directly supported, and for most\ncollection implementations will throw a\nConcurrentModificationException.\n\n@param <E> the type of elements returned by this iterator.\n@since 3.2\n", "original_string": "public class LoopingListIterator<E> implements ResettableListIterator<E> {\n\n    /** The list to base the iterator on */\n    private final List<E> list;\n    /** The current list iterator */\n    private ListIterator<E> iterator;\n\n    /**\n     * Constructor that wraps a list.\n     * <p>\n     * There is no way to reset a ListIterator instance without\n     * recreating it from the original source, so the List must be\n     * passed in and a reference to it held.\n     *\n     * @param list the list to wrap\n     * @throws NullPointerException if the list is null\n     */\n    public LoopingListIterator(final List<E> list) {\n        this.list = Objects.requireNonNull(list, \"collection\");\n        init();\n    }\n\n    /**\n     * Inserts the specified element into the underlying list.\n     * <p>\n     * The element is inserted before the next element that would be\n     * returned by {@link #next}, if any, and after the next element\n     * that would be returned by {@link #previous}, if any.\n     * <p>\n     * This feature is only supported if the underlying list's\n     * {@link List#listIterator} method returns an implementation\n     * that supports it.\n     *\n     * @param obj  the element to insert\n     * @throws UnsupportedOperationException if the add method is not\n     *  supported by the iterator implementation of the underlying list\n     */\n    @Override\n    public void add(final E obj) {\n        iterator.add(obj);\n    }\n\n    /**\n     * Returns whether this iterator has any more elements.\n     * <p>\n     * Returns false only if the list originally had zero elements, or\n     * all elements have been {@link #remove removed}.\n     *\n     * @return {@code true} if there are more elements\n     */\n    @Override\n    public boolean hasNext() {\n        return !list.isEmpty();\n    }\n\n    /**\n     * Returns whether this iterator has any more previous elements.\n     * <p>\n     * Returns false only if the list originally had zero elements, or\n     * all elements have been {@link #remove removed}.\n     *\n     * @return {@code true} if there are more elements\n     */\n    @Override\n    public boolean hasPrevious() {\n        return !list.isEmpty();\n    }\n\n    private void init() {\n        iterator = list.listIterator();\n    }\n\n    /**\n     * Returns the next object in the list.\n     * <p>\n     * If at the end of the list, returns the first element.\n     *\n     * @return the object after the last element returned\n     * @throws NoSuchElementException if there are no elements in the list\n     */\n    @Override\n    public E next() {\n        if (list.isEmpty()) {\n            throw new NoSuchElementException(\n                \"There are no elements for this iterator to loop on\");\n        }\n        if (!iterator.hasNext()) {\n            reset();\n        }\n        return iterator.next();\n    }\n\n    /**\n     * Returns the index of the element that would be returned by a\n     * subsequent call to {@link #next}.\n     * <p>\n     * As would be expected, if the iterator is at the physical end of\n     * the underlying list, 0 is returned, signifying the beginning of\n     * the list.\n     *\n     * @return the index of the element that would be returned if next() were called\n     * @throws NoSuchElementException if there are no elements in the list\n     */\n    @Override\n    public int nextIndex() {\n        if (list.isEmpty()) {\n            throw new NoSuchElementException(\n                \"There are no elements for this iterator to loop on\");\n        }\n        if (!iterator.hasNext()) {\n            return 0;\n        }\n        return iterator.nextIndex();\n    }\n\n    /**\n     * Returns the previous object in the list.\n     * <p>\n     * If at the beginning of the list, return the last element. Note\n     * that in this case, traversal to find that element takes linear time.\n     *\n     * @return the object before the last element returned\n     * @throws NoSuchElementException if there are no elements in the list\n     */\n    @Override\n    public E previous() {\n        if (list.isEmpty()) {\n            throw new NoSuchElementException(\n                \"There are no elements for this iterator to loop on\");\n        }\n        if (!iterator.hasPrevious()) {\n            E result = null;\n            while (iterator.hasNext()) {\n                result = iterator.next();\n            }\n            iterator.previous();\n            return result;\n        }\n        return iterator.previous();\n    }\n\n    /**\n     * Returns the index of the element that would be returned by a\n     * subsequent call to {@link #previous}.\n     * <p>\n     * As would be expected, if at the iterator is at the physical\n     * beginning of the underlying list, the list's size minus one is\n     * returned, signifying the end of the list.\n     *\n     * @return the index of the element that would be returned if previous() were called\n     * @throws NoSuchElementException if there are no elements in the list\n     */\n    @Override\n    public int previousIndex() {\n        if (list.isEmpty()) {\n            throw new NoSuchElementException(\n                \"There are no elements for this iterator to loop on\");\n        }\n        if (!iterator.hasPrevious()) {\n            return list.size() - 1;\n        }\n        return iterator.previousIndex();\n    }\n\n    /**\n     * Removes the previously retrieved item from the underlying list.\n     * <p>\n     * This feature is only supported if the underlying list's\n     * {@link List#iterator()} method returns an implementation\n     * that supports it.\n     * <p>\n     * This method can only be called after at least one {@link #next}\n     * or {@link #previous} method call. After a removal, the remove\n     * method may not be called again until another {@link #next} or\n     * {@link #previous} has been performed. If the {@link #reset} is\n     * called, then remove may not be called until {@link #next} or\n     * {@link #previous} is called again.\n     *\n     * @throws UnsupportedOperationException if the remove method is\n     * not supported by the iterator implementation of the underlying\n     * list\n     */\n    @Override\n    public void remove() {\n        iterator.remove();\n    }\n\n    /**\n     * Resets the iterator back to the start of the list.\n     */\n    @Override\n    public void reset() {\n        init();\n    }\n\n    /**\n     * Replaces the last element that was returned by {@link #next} or\n     * {@link #previous}.\n     * <p>\n     * This feature is only supported if the underlying list's\n     * {@link List#listIterator} method returns an implementation\n     * that supports it.\n     *\n     * @param obj  the element with which to replace the last element returned\n     * @throws UnsupportedOperationException if the set method is not\n     *  supported by the iterator implementation of the underlying list\n     */\n    @Override\n    public void set(final E obj) {\n        iterator.set(obj);\n    }\n\n    /**\n     * Gets the size of the list underlying the iterator.\n     *\n     * @return the current list size\n     */\n    public int size() {\n        return list.size();\n    }\n\n}", "super_interfaces": ["ResettableListIterator<E>"], "fields": [{"attribute_expression": "private final List<E> list;", "docstring": " The list to base the iterator on", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<E>", "name": "list", "syntax_pass": true}, {"attribute_expression": "private ListIterator<E> iterator;", "docstring": " The current list iterator", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ListIterator<E>", "name": "iterator", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/iterators/EmptyOrderedMapIterator.java.EmptyOrderedMapIterator", "name": "EmptyOrderedMapIterator", "file_path": "src/main/java/org/apache/commons/collections4/iterators/EmptyOrderedMapIterator.java", "superclasses": "", "methods": ["[OrderedMapIterator<K, V>]emptyOrderedMapIterator()", "[]EmptyOrderedMapIterator()"], "method_uris": ["src/main/java/org/apache/commons/collections4/iterators/EmptyOrderedMapIterator.java.EmptyOrderedMapIterator.[OrderedMapIterator<K, V>]emptyOrderedMapIterator()", "src/main/java/org/apache/commons/collections4/iterators/EmptyOrderedMapIterator.java.EmptyOrderedMapIterator.[]EmptyOrderedMapIterator()"], "overrides": null, "attributes": [], "class_docstring": "\nProvides an implementation of an empty ordered map iterator.\n\n@param <K> the type of keys\n@param <V> the type of mapped values\n@since 3.1\n", "original_string": "public class EmptyOrderedMapIterator<K, V> extends AbstractEmptyMapIterator<K, V>\n        implements OrderedMapIterator<K, V> {\n\n    /**\n     * Singleton instance of the iterator.\n     * @since 3.1\n     */\n    @SuppressWarnings(\"rawtypes\")\n    public static final OrderedMapIterator INSTANCE = new EmptyOrderedMapIterator<>();\n\n    /**\n     * Gets a typed instance of the iterator.\n     * @param <K> the key type\n     * @param <V> the value type\n     * @return {@link OrderedMapIterator}&lt;K, V&gt;\n     */\n    public static <K, V> OrderedMapIterator<K, V> emptyOrderedMapIterator() {\n        return INSTANCE;\n    }\n\n    /**\n     * Constructs a new instance.\n     */\n    protected EmptyOrderedMapIterator() {\n    }\n\n}", "super_interfaces": ["OrderedMapIterator<K, V>"], "fields": [{"attribute_expression": "@SuppressWarnings(\"rawtypes\")\n    public static final OrderedMapIterator INSTANCE = new EmptyOrderedMapIterator<>();", "docstring": "\nSingleton instance of the iterator.\n@since 3.1\n", "modifiers": "@SuppressWarnings(\"rawtypes\")\n    public static final", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"rawtypes\")", "public", "static", "final"], "comments": [], "type": "OrderedMapIterator", "name": "INSTANCE = new EmptyOrderedMapIterator<>()", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/iterators/CartesianProductIterator.java.CartesianProductIterator", "name": "CartesianProductIterator", "file_path": "src/main/java/org/apache/commons/collections4/iterators/CartesianProductIterator.java", "superclasses": "", "methods": ["[]CartesianProductIterator()", "[boolean]hasNext()", "[List<E>]next()", "[void]remove()"], "method_uris": ["src/main/java/org/apache/commons/collections4/iterators/CartesianProductIterator.java.CartesianProductIterator.[]CartesianProductIterator()", "src/main/java/org/apache/commons/collections4/iterators/CartesianProductIterator.java.CartesianProductIterator.[boolean]hasNext()", "src/main/java/org/apache/commons/collections4/iterators/CartesianProductIterator.java.CartesianProductIterator.[List<E>]next()", "src/main/java/org/apache/commons/collections4/iterators/CartesianProductIterator.java.CartesianProductIterator.[void]remove()"], "overrides": null, "attributes": [], "class_docstring": "\nThis iterator creates a Cartesian product of the input iterables,\nequivalent to nested for-loops.\n<p>\nThe iterables provided to the constructor are used in reverse order, each\nuntil exhaustion before proceeding to the next element of the prior iterable\nand repeating. Consider the following example:\n</p>\n<pre>{@code\nList<Character> iterable1 = Arrays.asList('A', 'B', 'C');\nList<Character> iterable2 = Arrays.asList('1', '2', '3');\nCartesianProductIterator<Character> it = new CartesianProductIterator<>(\n        iterable1,\n        iterable2);\nwhile (it.hasNext()) {\n    List<Character> tuple = it.next();\n    System.out.println(tuple.get(0) + \", \" + tuple.get(1));\n}\n}</pre>\n<p>\nThe output will be:\n</p>\n<pre>\nA, 1\nA, 2\nA, 3\nB, 1\nB, 2\nB, 3\nC, 1\nC, 2\nC, 3\n</pre>\n<p>\nThe {@code remove()} operation is not supported, and will throw an\n{@code UnsupportedOperationException}.\n</p>\n<p>\nIf any of the input iterables is empty, the Cartesian product will be empty.\nIf any of the input iterables is infinite, the Cartesian product will be\ninfinite.\n</p>\n\n@param <E> the type of the objects being permuted\n@since 4.5.0\n", "original_string": "public class CartesianProductIterator<E> implements Iterator<List<E>> {\n\n    /**\n     * The iterables to create the Cartesian product from.\n     */\n    private final List<Iterable<? extends E>> iterables;\n\n    /**\n     * The iterators to generate the Cartesian product tuple from.\n     */\n    private final List<Iterator<? extends E>> iterators;\n\n    /**\n     * The previous generated tuple of elements.\n     */\n    private List<E> previousTuple;\n\n    /**\n     * Constructs a new {@code CartesianProductIterator} instance with given iterables.\n     *\n     * @param iterables the iterables to create the Cartesian product from\n     * @throws NullPointerException if any of the iterables is null\n     */\n    @SafeVarargs\n    public CartesianProductIterator(final Iterable<? extends E>... iterables) {\n        Objects.requireNonNull(iterables, \"iterables\");\n        this.iterables = new ArrayList<>(iterables.length);\n        this.iterators = new ArrayList<>(iterables.length);\n        for (final Iterable<? extends E> iterable : iterables) {\n            Objects.requireNonNull(iterable, \"iterable\");\n            this.iterables.add(iterable);\n            final Iterator<? extends E> iterator = iterable.iterator();\n            if (!iterator.hasNext()) {\n                iterators.clear();\n                break;\n            }\n            iterators.add(iterator);\n        }\n    }\n\n    /**\n     * Returns {@code true} if the iteration has more elements.\n     *\n     * @return true if there are more tuples, otherwise false\n     */\n    @Override\n    public boolean hasNext() {\n        return iterators.stream().anyMatch(Iterator::hasNext);\n    }\n\n    /**\n     * Returns the next tuple of the input iterables.\n     *\n     * @return a list of the input iterables' elements\n     * @throws NoSuchElementException if there are no more tuples\n     */\n    @Override\n    public List<E> next() {\n        if (!hasNext()) {\n            throw new NoSuchElementException();\n        }\n        if (previousTuple == null) {\n            previousTuple = new ArrayList<>(iterables.size());\n            for (final Iterator<? extends E> iterator : iterators) {\n                previousTuple.add(iterator.next());\n            }\n            return new ArrayList<>(previousTuple);\n        }\n        for (int i = iterators.size() - 1; i >= 0; i--) {\n            Iterator<? extends E> iterator = iterators.get(i);\n            if (iterator.hasNext()) {\n                previousTuple.set(i, iterator.next());\n                return new ArrayList<>(previousTuple);\n            }\n            iterator = iterables.get(i).iterator();\n            iterators.set(i, iterator);\n            previousTuple.set(i, iterator.next());\n        }\n        throw new IllegalStateException(\"reached unreachable code\");\n    }\n\n    @Override\n    public void remove() {\n        throw new UnsupportedOperationException(\"remove\");\n    }\n}", "super_interfaces": ["Iterator<List<E>>"], "fields": [{"attribute_expression": "private final List<Iterable<? extends E>> iterables;", "docstring": "\nThe iterables to create the Cartesian product from.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<Iterable<? extends E>>", "name": "iterables", "syntax_pass": true}, {"attribute_expression": "private final List<Iterator<? extends E>> iterators;", "docstring": "\nThe iterators to generate the Cartesian product tuple from.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<Iterator<? extends E>>", "name": "iterators", "syntax_pass": true}, {"attribute_expression": "private List<E> previousTuple;", "docstring": "\nThe previous generated tuple of elements.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "List<E>", "name": "previousTuple", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/properties/OrderedProperties.java.OrderedProperties", "name": "OrderedProperties", "file_path": "src/main/java/org/apache/commons/collections4/properties/OrderedProperties.java", "superclasses": "Properties", "methods": ["[void]clear()", "[Object]compute(Object,BiFunction<? super Object, ? super Object, ? extends Object>)", "[Object]computeIfAbsent(Object,Function<? super Object, ? extends Object>)", "[Set<Map.Entry<Object, Object>>]entrySet()", "[void]forEach(BiConsumer<? super Object, ? super Object>)", "[Enumeration<Object>]keys()", "[Set<Object>]keySet()", "[Object]merge(Object,Object,BiFunction<? super Object, ? super Object, ? extends Object>)", "[Enumeration<?>]propertyNames()", "[Object]put(Object,Object)", "[void]putAll(Map<? extends Object, ? extends Object>)", "[Object]putIfAbsent(Object,Object)", "[Object]remove(Object)", "[boolean]remove(Object,Object)", "[String]toString()"], "method_uris": ["src/main/java/org/apache/commons/collections4/properties/OrderedProperties.java.OrderedProperties.[void]clear()", "src/main/java/org/apache/commons/collections4/properties/OrderedProperties.java.OrderedProperties.[Object]compute(Object,BiFunction<? super Object, ? super Object, ? extends Object>)", "src/main/java/org/apache/commons/collections4/properties/OrderedProperties.java.OrderedProperties.[Object]computeIfAbsent(Object,Function<? super Object, ? extends Object>)", "src/main/java/org/apache/commons/collections4/properties/OrderedProperties.java.OrderedProperties.[Set<Map.Entry<Object, Object>>]entrySet()", "src/main/java/org/apache/commons/collections4/properties/OrderedProperties.java.OrderedProperties.[void]forEach(BiConsumer<? super Object, ? super Object>)", "src/main/java/org/apache/commons/collections4/properties/OrderedProperties.java.OrderedProperties.[Enumeration<Object>]keys()", "src/main/java/org/apache/commons/collections4/properties/OrderedProperties.java.OrderedProperties.[Set<Object>]keySet()", "src/main/java/org/apache/commons/collections4/properties/OrderedProperties.java.OrderedProperties.[Object]merge(Object,Object,BiFunction<? super Object, ? super Object, ? extends Object>)", "src/main/java/org/apache/commons/collections4/properties/OrderedProperties.java.OrderedProperties.[Enumeration<?>]propertyNames()", "src/main/java/org/apache/commons/collections4/properties/OrderedProperties.java.OrderedProperties.[Object]put(Object,Object)", "src/main/java/org/apache/commons/collections4/properties/OrderedProperties.java.OrderedProperties.[void]putAll(Map<? extends Object, ? extends Object>)", "src/main/java/org/apache/commons/collections4/properties/OrderedProperties.java.OrderedProperties.[Object]putIfAbsent(Object,Object)", "src/main/java/org/apache/commons/collections4/properties/OrderedProperties.java.OrderedProperties.[Object]remove(Object)", "src/main/java/org/apache/commons/collections4/properties/OrderedProperties.java.OrderedProperties.[boolean]remove(Object,Object)", "src/main/java/org/apache/commons/collections4/properties/OrderedProperties.java.OrderedProperties.[String]toString()"], "overrides": null, "attributes": [], "class_docstring": "\nA drop-in replacement for {@link Properties} for ordered keys.\n<p>\nOverrides methods to keep keys in insertion order. Allows other methods in the superclass to work with ordered keys.\n</p>\n\n@see OrderedPropertiesFactory#INSTANCE\n@since 4.5.0\n", "original_string": "public class OrderedProperties extends Properties {\n\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * Preserves the insertion order.\n     */\n    private final LinkedHashSet<Object> orderedKeys = new LinkedHashSet<>();\n\n    @Override\n    public synchronized void clear() {\n        orderedKeys.clear();\n        super.clear();\n    }\n\n    @Override\n    public synchronized Object compute(final Object key, final BiFunction<? super Object, ? super Object, ? extends Object> remappingFunction) {\n        final Object compute = super.compute(key, remappingFunction);\n        if (compute != null) {\n            orderedKeys.add(key);\n        }\n        return compute;\n    }\n\n    @Override\n    public synchronized Object computeIfAbsent(final Object key, final Function<? super Object, ? extends Object> mappingFunction) {\n        final Object computeIfAbsent = super.computeIfAbsent(key, mappingFunction);\n        if (computeIfAbsent != null) {\n            orderedKeys.add(key);\n        }\n        return computeIfAbsent;\n    }\n\n    @Override\n    public Set<Map.Entry<Object, Object>> entrySet() {\n        return orderedKeys.stream().map(k -> new SimpleEntry<>(k, get(k))).collect(Collectors.toCollection(LinkedHashSet::new));\n    }\n\n    @Override\n    public synchronized void forEach(final BiConsumer<? super Object, ? super Object> action) {\n        Objects.requireNonNull(action);\n        orderedKeys.forEach(k -> action.accept(k, get(k)));\n    }\n\n    @Override\n    public synchronized Enumeration<Object> keys() {\n        return Collections.enumeration(orderedKeys);\n    }\n\n    @Override\n    public Set<Object> keySet() {\n        return orderedKeys;\n    }\n\n    @Override\n    public synchronized Object merge(final Object key, final Object value,\n            final BiFunction<? super Object, ? super Object, ? extends Object> remappingFunction) {\n        orderedKeys.add(key);\n        return super.merge(key, value, remappingFunction);\n    }\n\n    @Override\n    public Enumeration<?> propertyNames() {\n        return Collections.enumeration(orderedKeys);\n    }\n\n    @Override\n    public synchronized Object put(final Object key, final Object value) {\n        final Object put = super.put(key, value);\n        if (put == null) {\n            orderedKeys.add(key);\n        }\n        return put;\n    }\n\n    @Override\n    public synchronized void putAll(final Map<? extends Object, ? extends Object> t) {\n        orderedKeys.addAll(t.keySet());\n        super.putAll(t);\n    }\n\n    @Override\n    public synchronized Object putIfAbsent(final Object key, final Object value) {\n        final Object putIfAbsent = super.putIfAbsent(key, value);\n        if (putIfAbsent == null) {\n            orderedKeys.add(key);\n        }\n        return putIfAbsent;\n    }\n\n    @Override\n    public synchronized Object remove(final Object key) {\n        final Object remove = super.remove(key);\n        if (remove != null) {\n            orderedKeys.remove(key);\n        }\n        return remove;\n    }\n\n    @Override\n    public synchronized boolean remove(final Object key, final Object value) {\n        final boolean remove = super.remove(key, value);\n        if (remove) {\n            orderedKeys.remove(key);\n        }\n        return remove;\n    }\n\n    @Override\n    public synchronized String toString() {\n        // Must override for Java 17 to maintain order since the implementation is based on a map\n        final int max = size() - 1;\n        if (max == -1) {\n            return \"{}\";\n        }\n        final StringBuilder sb = new StringBuilder();\n        final Iterator<Map.Entry<Object, Object>> it = entrySet().iterator();\n        sb.append('{');\n        for (int i = 0;; i++) {\n            final Map.Entry<Object, Object> e = it.next();\n            final Object key = e.getKey();\n            final Object value = e.getValue();\n            sb.append(key == this ? \"(this Map)\" : key.toString());\n            sb.append('=');\n            sb.append(value == this ? \"(this Map)\" : value.toString());\n            if (i == max) {\n                return sb.append('}').toString();\n            }\n            sb.append(\", \");\n        }\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = 1L;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 1L", "syntax_pass": true}, {"attribute_expression": "private final LinkedHashSet<Object> orderedKeys = new LinkedHashSet<>();", "docstring": "\nPreserves the insertion order.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "LinkedHashSet<Object>", "name": "orderedKeys = new LinkedHashSet<>()", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/properties/SortedProperties.java.SortedProperties", "name": "SortedProperties", "file_path": "src/main/java/org/apache/commons/collections4/properties/SortedProperties.java", "superclasses": "Properties", "methods": ["[Set<Map.Entry<Object, Object>>]entrySet()", "[Enumeration<Object>]keys()", "[Stream<String>]sortedKeys()"], "method_uris": ["src/main/java/org/apache/commons/collections4/properties/SortedProperties.java.SortedProperties.[Set<Map.Entry<Object, Object>>]entrySet()", "src/main/java/org/apache/commons/collections4/properties/SortedProperties.java.SortedProperties.[Enumeration<Object>]keys()", "src/main/java/org/apache/commons/collections4/properties/SortedProperties.java.SortedProperties.[Stream<String>]sortedKeys()"], "overrides": null, "attributes": [], "class_docstring": "\nA drop-in replacement for {@link Properties} for sorting keys.\n<p>\nOverrides {@link Properties#keys()} to sort keys. Allows other methods on the superclass to work with sorted keys.\n</p>\n\n@see SortedPropertiesFactory#INSTANCE\n@since 4.2\n", "original_string": "public class SortedProperties extends Properties {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public Set<Map.Entry<Object, Object>> entrySet() {\n        final Stream<SimpleEntry<Object, Object>> stream = sortedKeys().map(k -> new AbstractMap.SimpleEntry<>(k, getProperty(k)));\n        return stream.collect(Collectors.toCollection(LinkedHashSet::new));\n    }\n\n    @Override\n    public synchronized Enumeration<Object> keys() {\n        return new IteratorEnumeration<>(sortedKeys().collect(Collectors.toList()).iterator());\n    }\n\n    private Stream<String> sortedKeys() {\n        return keySet().stream().map(Object::toString).sorted();\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = 1L;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 1L", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/properties/OrderedPropertiesFactory.java.OrderedPropertiesFactory", "name": "OrderedPropertiesFactory", "file_path": "src/main/java/org/apache/commons/collections4/properties/OrderedPropertiesFactory.java", "superclasses": "", "methods": ["[]OrderedPropertiesFactory()", "[OrderedProperties]createProperties()"], "method_uris": ["src/main/java/org/apache/commons/collections4/properties/OrderedPropertiesFactory.java.OrderedPropertiesFactory.[]OrderedPropertiesFactory()", "src/main/java/org/apache/commons/collections4/properties/OrderedPropertiesFactory.java.OrderedPropertiesFactory.[OrderedProperties]createProperties()"], "overrides": null, "attributes": [], "class_docstring": "\nCreates and loads {@link OrderedProperties}.\n\n@see OrderedProperties\n@since 4.5.0\n", "original_string": "public class OrderedPropertiesFactory extends AbstractPropertiesFactory<OrderedProperties> {\n\n    /**\n     * The singleton instance.\n     */\n    public static final OrderedPropertiesFactory INSTANCE = new OrderedPropertiesFactory();\n\n    /**\n     * Constructs an instance.\n     */\n    private OrderedPropertiesFactory() {\n        // There is only one instance.\n    }\n\n    /**\n     * Subclasses override to provide customized properties instances.\n     *\n     * @return a new Properties instance.\n     */\n    @Override\n    protected OrderedProperties createProperties() {\n        return new OrderedProperties();\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final OrderedPropertiesFactory INSTANCE = new OrderedPropertiesFactory();", "docstring": "\nThe singleton instance.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "OrderedPropertiesFactory", "name": "INSTANCE = new OrderedPropertiesFactory()", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/properties/PropertiesFactory.java.PropertiesFactory", "name": "PropertiesFactory", "file_path": "src/main/java/org/apache/commons/collections4/properties/PropertiesFactory.java", "superclasses": "", "methods": ["[]PropertiesFactory()", "[Properties]createProperties()"], "method_uris": ["src/main/java/org/apache/commons/collections4/properties/PropertiesFactory.java.PropertiesFactory.[]PropertiesFactory()", "src/main/java/org/apache/commons/collections4/properties/PropertiesFactory.java.PropertiesFactory.[Properties]createProperties()"], "overrides": null, "attributes": [{"original_string": "    private static final class EmptyProperties extends Properties {\n\n        private static final long serialVersionUID = 1L;\n\n        @Override\n        public synchronized void clear() {\n            // Noop\n        }\n\n        @Override\n        public synchronized Object compute(final Object key,\n            final BiFunction<? super Object, ? super Object, ? extends Object> remappingFunction) {\n            Objects.requireNonNull(key);\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public synchronized Object computeIfAbsent(final Object key,\n            final Function<? super Object, ? extends Object> mappingFunction) {\n            Objects.requireNonNull(key);\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public synchronized Object computeIfPresent(final Object key,\n            final BiFunction<? super Object, ? super Object, ? extends Object> remappingFunction) {\n            Objects.requireNonNull(key);\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public synchronized boolean contains(final Object value) {\n            return false;\n        }\n\n        @Override\n        public synchronized boolean containsKey(final Object key) {\n            return false;\n        }\n\n        @Override\n        public boolean containsValue(final Object value) {\n            return false;\n        }\n\n        @Override\n        public synchronized Enumeration<Object> elements() {\n            return Collections.emptyEnumeration();\n        }\n\n        @Override\n        public Set<Entry<Object, Object>> entrySet() {\n            return Collections.emptySet();\n        }\n\n        @Override\n        public synchronized boolean equals(final Object o) {\n            return o instanceof Properties && ((Properties) o).isEmpty();\n        }\n\n        @Override\n        public synchronized void forEach(final BiConsumer<? super Object, ? super Object> action) {\n            Objects.requireNonNull(action);\n        }\n\n        @Override\n        public synchronized Object get(final Object key) {\n            return null;\n        }\n\n        @Override\n        public synchronized Object getOrDefault(final Object key, final Object defaultValue) {\n            return defaultValue;\n        }\n\n        @Override\n        public String getProperty(final String key) {\n            return null;\n        }\n\n        @Override\n        public String getProperty(final String key, final String defaultValue) {\n            return defaultValue;\n        }\n\n        @Override\n        public synchronized int hashCode() {\n            return 0;\n        }\n\n        @Override\n        public synchronized boolean isEmpty() {\n            return true;\n        }\n\n        @Override\n        public synchronized Enumeration<Object> keys() {\n            return Collections.emptyEnumeration();\n        }\n\n        @Override\n        public Set<Object> keySet() {\n            return Collections.emptySet();\n        }\n\n        /**\n         * Throws {@link UnsupportedOperationException}.\n         * Caller should use try-with-resources statement.\n         */\n        @SuppressWarnings(\"resource\")\n        @Override\n        public synchronized void load(final InputStream inStream) throws IOException {\n            Objects.requireNonNull(inStream);\n            throw new UnsupportedOperationException();\n        }\n\n        /**\n         * Throws {@link UnsupportedOperationException}.\n         * Caller should use try-with-resources statement.\n         */\n        @SuppressWarnings(\"resource\")\n        @Override\n        public synchronized void load(final Reader reader) throws IOException {\n            Objects.requireNonNull(reader);\n            throw new UnsupportedOperationException();\n        }\n\n        /**\n         * Throws {@link UnsupportedOperationException}.\n         * Caller should use try-with-resources statement.\n         */\n        @SuppressWarnings(\"resource\")\n        @Override\n        public synchronized void loadFromXML(final InputStream in)\n            throws IOException, InvalidPropertiesFormatException {\n            Objects.requireNonNull(in);\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public synchronized Object merge(final Object key, final Object value,\n            final BiFunction<? super Object, ? super Object, ? extends Object> remappingFunction) {\n            Objects.requireNonNull(key);\n            Objects.requireNonNull(value);\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public Enumeration<?> propertyNames() {\n            return Collections.emptyEnumeration();\n        }\n\n        @Override\n        public synchronized Object put(final Object key, final Object value) {\n            Objects.requireNonNull(key);\n            Objects.requireNonNull(value);\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public synchronized void putAll(final Map<? extends Object, ? extends Object> t) {\n            Objects.requireNonNull(t);\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public synchronized Object putIfAbsent(final Object key, final Object value) {\n            Objects.requireNonNull(key);\n            Objects.requireNonNull(value);\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        protected void rehash() {\n            // Noop\n        }\n\n        @Override\n        public synchronized Object remove(final Object key) {\n            Objects.requireNonNull(key);\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public synchronized boolean remove(final Object key, final Object value) {\n            Objects.requireNonNull(key);\n            Objects.requireNonNull(value);\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public synchronized Object replace(final Object key, final Object value) {\n            Objects.requireNonNull(key);\n            Objects.requireNonNull(value);\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public synchronized boolean replace(final Object key, final Object oldValue, final Object newValue) {\n            Objects.requireNonNull(key);\n            Objects.requireNonNull(oldValue);\n            Objects.requireNonNull(newValue);\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public synchronized void replaceAll(\n            final BiFunction<? super Object, ? super Object, ? extends Object> function) {\n            Objects.requireNonNull(function);\n            throw new UnsupportedOperationException();\n        }\n\n        @SuppressWarnings(\"deprecation\")\n        @Override\n        public void save(final OutputStream out, final String comments) {\n            // Implement as super\n            super.save(out, comments);\n        }\n\n        @Override\n        public synchronized Object setProperty(final String key, final String value) {\n            Objects.requireNonNull(key);\n            Objects.requireNonNull(value);\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public synchronized int size() {\n            return 0;\n        }\n\n        @Override\n        public Set<String> stringPropertyNames() {\n            return Collections.emptySet();\n        }\n\n        @Override\n        public synchronized String toString() {\n            // Implement as super\n            return super.toString();\n        }\n\n        @Override\n        public Collection<Object> values() {\n            return Collections.emptyList();\n        }\n\n    }", "definition": "    private static final class EmptyProperties extends Properties", "class_docstring": "", "name": "EmptyProperties", "super_interfaces": [], "superclasses": "Properties", "attributes": {"modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = 1L;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 1L", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @Override\n        public synchronized void clear() {\n            // Noop\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public synchronized", "marker_annotations": ["@Override"], "non_marker_annotations": ["public", "synchronized"], "comments": [], "return_type": "void", "classes": []}, "name": "clear", "params": [], "body": "                                         {\n            // Noop\n        }", "signature": "@Override\n        public synchronized void clear()"}, {"syntax_pass": true, "original_string": "        @Override\n        public synchronized Object compute(final Object key,\n            final BiFunction<? super Object, ? super Object, ? extends Object> remappingFunction) {\n            Objects.requireNonNull(key);\n            throw new UnsupportedOperationException();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public synchronized", "marker_annotations": ["@Override"], "non_marker_annotations": ["public", "synchronized"], "comments": [], "return_type": "Object", "classes": []}, "name": "compute", "params": [{"name": "key", "type": "Object"}, {"name": "remappingFunction", "type": "BiFunction<? super Object, ? super Object, ? extends Object>"}], "body": "                                                                                                  {\n            Objects.requireNonNull(key);\n            throw new UnsupportedOperationException();\n        }", "signature": "@Override\n        public synchronized Object compute(final Object key,\n            final BiFunction<? super Object, ? super Object, ? extends Object> remappingFunction)"}, {"syntax_pass": true, "original_string": "        @Override\n        public synchronized Object computeIfAbsent(final Object key,\n            final Function<? super Object, ? extends Object> mappingFunction) {\n            Objects.requireNonNull(key);\n            throw new UnsupportedOperationException();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public synchronized", "marker_annotations": ["@Override"], "non_marker_annotations": ["public", "synchronized"], "comments": [], "return_type": "Object", "classes": []}, "name": "computeIfAbsent", "params": [{"name": "key", "type": "Object"}, {"name": "mappingFunction", "type": "Function<? super Object, ? extends Object>"}], "body": "                                                                              {\n            Objects.requireNonNull(key);\n            throw new UnsupportedOperationException();\n        }", "signature": "@Override\n        public synchronized Object computeIfAbsent(final Object key,\n            final Function<? super Object, ? extends Object> mappingFunction)"}, {"syntax_pass": true, "original_string": "        @Override\n        public synchronized Object computeIfPresent(final Object key,\n            final BiFunction<? super Object, ? super Object, ? extends Object> remappingFunction) {\n            Objects.requireNonNull(key);\n            throw new UnsupportedOperationException();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public synchronized", "marker_annotations": ["@Override"], "non_marker_annotations": ["public", "synchronized"], "comments": [], "return_type": "Object", "classes": []}, "name": "computeIfPresent", "params": [{"name": "key", "type": "Object"}, {"name": "remappingFunction", "type": "BiFunction<? super Object, ? super Object, ? extends Object>"}], "body": "                                                                                                  {\n            Objects.requireNonNull(key);\n            throw new UnsupportedOperationException();\n        }", "signature": "@Override\n        public synchronized Object computeIfPresent(final Object key,\n            final BiFunction<? super Object, ? super Object, ? extends Object> remappingFunction)"}, {"syntax_pass": true, "original_string": "        @Override\n        public synchronized boolean contains(final Object value) {\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public synchronized", "marker_annotations": ["@Override"], "non_marker_annotations": ["public", "synchronized"], "comments": [], "return_type": "boolean", "classes": []}, "name": "contains", "params": [{"name": "value", "type": "Object"}], "body": "                                                                 {\n            return false;\n        }", "signature": "@Override\n        public synchronized boolean contains(final Object value)"}, {"syntax_pass": true, "original_string": "        @Override\n        public synchronized boolean containsKey(final Object key) {\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public synchronized", "marker_annotations": ["@Override"], "non_marker_annotations": ["public", "synchronized"], "comments": [], "return_type": "boolean", "classes": []}, "name": "containsKey", "params": [{"name": "key", "type": "Object"}], "body": "                                                                  {\n            return false;\n        }", "signature": "@Override\n        public synchronized boolean containsKey(final Object key)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean containsValue(final Object value) {\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "containsValue", "params": [{"name": "value", "type": "Object"}], "body": "                                                         {\n            return false;\n        }", "signature": "@Override\n        public boolean containsValue(final Object value)"}, {"syntax_pass": true, "original_string": "        @Override\n        public synchronized Enumeration<Object> elements() {\n            return Collections.emptyEnumeration();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public synchronized", "marker_annotations": ["@Override"], "non_marker_annotations": ["public", "synchronized"], "comments": [], "return_type": "Enumeration<Object>", "classes": []}, "name": "elements", "params": [], "body": "                                                           {\n            return Collections.emptyEnumeration();\n        }", "signature": "@Override\n        public synchronized Enumeration<Object> elements()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Set<Entry<Object, Object>> entrySet() {\n            return Collections.emptySet();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Set<Entry<Object, Object>>", "classes": []}, "name": "entrySet", "params": [], "body": "                                                     {\n            return Collections.emptySet();\n        }", "signature": "@Override\n        public Set<Entry<Object, Object>> entrySet()"}, {"syntax_pass": true, "original_string": "        @Override\n        public synchronized boolean equals(final Object o) {\n            return o instanceof Properties && ((Properties) o).isEmpty();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public synchronized", "marker_annotations": ["@Override"], "non_marker_annotations": ["public", "synchronized"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "o", "type": "Object"}], "body": "                                                           {\n            return o instanceof Properties && ((Properties) o).isEmpty();\n        }", "signature": "@Override\n        public synchronized boolean equals(final Object o)"}, {"syntax_pass": true, "original_string": "        @Override\n        public synchronized void forEach(final BiConsumer<? super Object, ? super Object> action) {\n            Objects.requireNonNull(action);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public synchronized", "marker_annotations": ["@Override"], "non_marker_annotations": ["public", "synchronized"], "comments": [], "return_type": "void", "classes": []}, "name": "forEach", "params": [{"name": "action", "type": "BiConsumer<? super Object, ? super Object>"}], "body": "                                                                                                  {\n            Objects.requireNonNull(action);\n        }", "signature": "@Override\n        public synchronized void forEach(final BiConsumer<? super Object, ? super Object> action)"}, {"syntax_pass": true, "original_string": "        @Override\n        public synchronized Object get(final Object key) {\n            return null;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public synchronized", "marker_annotations": ["@Override"], "non_marker_annotations": ["public", "synchronized"], "comments": [], "return_type": "Object", "classes": []}, "name": "get", "params": [{"name": "key", "type": "Object"}], "body": "                                                         {\n            return null;\n        }", "signature": "@Override\n        public synchronized Object get(final Object key)"}, {"syntax_pass": true, "original_string": "        @Override\n        public synchronized Object getOrDefault(final Object key, final Object defaultValue) {\n            return defaultValue;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public synchronized", "marker_annotations": ["@Override"], "non_marker_annotations": ["public", "synchronized"], "comments": [], "return_type": "Object", "classes": []}, "name": "getOrDefault", "params": [{"name": "key", "type": "Object"}, {"name": "defaultValue", "type": "Object"}], "body": "                                                                                             {\n            return defaultValue;\n        }", "signature": "@Override\n        public synchronized Object getOrDefault(final Object key, final Object defaultValue)"}, {"syntax_pass": true, "original_string": "        @Override\n        public String getProperty(final String key) {\n            return null;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getProperty", "params": [{"name": "key", "type": "String"}], "body": "                                                    {\n            return null;\n        }", "signature": "@Override\n        public String getProperty(final String key)"}, {"syntax_pass": true, "original_string": "        @Override\n        public String getProperty(final String key, final String defaultValue) {\n            return defaultValue;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getProperty", "params": [{"name": "key", "type": "String"}, {"name": "defaultValue", "type": "String"}], "body": "                                                                               {\n            return defaultValue;\n        }", "signature": "@Override\n        public String getProperty(final String key, final String defaultValue)"}, {"syntax_pass": true, "original_string": "        @Override\n        public synchronized int hashCode() {\n            return 0;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public synchronized", "marker_annotations": ["@Override"], "non_marker_annotations": ["public", "synchronized"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                                           {\n            return 0;\n        }", "signature": "@Override\n        public synchronized int hashCode()"}, {"syntax_pass": true, "original_string": "        @Override\n        public synchronized boolean isEmpty() {\n            return true;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public synchronized", "marker_annotations": ["@Override"], "non_marker_annotations": ["public", "synchronized"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isEmpty", "params": [], "body": "                                              {\n            return true;\n        }", "signature": "@Override\n        public synchronized boolean isEmpty()"}, {"syntax_pass": true, "original_string": "        @Override\n        public synchronized Enumeration<Object> keys() {\n            return Collections.emptyEnumeration();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public synchronized", "marker_annotations": ["@Override"], "non_marker_annotations": ["public", "synchronized"], "comments": [], "return_type": "Enumeration<Object>", "classes": []}, "name": "keys", "params": [], "body": "                                                       {\n            return Collections.emptyEnumeration();\n        }", "signature": "@Override\n        public synchronized Enumeration<Object> keys()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Set<Object> keySet() {\n            return Collections.emptySet();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Set<Object>", "classes": []}, "name": "keySet", "params": [], "body": "                                    {\n            return Collections.emptySet();\n        }", "signature": "@Override\n        public Set<Object> keySet()"}, {"syntax_pass": true, "original_string": "        @SuppressWarnings(\"resource\")\n        @Override\n        public synchronized void load(final InputStream inStream) throws IOException {\n            Objects.requireNonNull(inStream);\n            throw new UnsupportedOperationException();\n        }", "docstring": "\nThrows {@link UnsupportedOperationException}.\nCaller should use try-with-resources statement.\n", "attributes": {"modifiers": "@SuppressWarnings(\"resource\")\n        @Override\n        public synchronized", "marker_annotations": ["@Override"], "non_marker_annotations": ["@SuppressWarnings(\"resource\")", "public", "synchronized"], "comments": [], "return_type": "void", "classes": []}, "name": "load", "params": [{"name": "inStream", "type": "InputStream"}], "body": "                                                                                     {\n            Objects.requireNonNull(inStream);\n            throw new UnsupportedOperationException();\n        }", "signature": "@SuppressWarnings(\"resource\")\n        @Override\n        public synchronized void load(final InputStream inStream)"}, {"syntax_pass": true, "original_string": "        @SuppressWarnings(\"resource\")\n        @Override\n        public synchronized void load(final Reader reader) throws IOException {\n            Objects.requireNonNull(reader);\n            throw new UnsupportedOperationException();\n        }", "docstring": "\nThrows {@link UnsupportedOperationException}.\nCaller should use try-with-resources statement.\n", "attributes": {"modifiers": "@SuppressWarnings(\"resource\")\n        @Override\n        public synchronized", "marker_annotations": ["@Override"], "non_marker_annotations": ["@SuppressWarnings(\"resource\")", "public", "synchronized"], "comments": [], "return_type": "void", "classes": []}, "name": "load", "params": [{"name": "reader", "type": "Reader"}], "body": "                                                                              {\n            Objects.requireNonNull(reader);\n            throw new UnsupportedOperationException();\n        }", "signature": "@SuppressWarnings(\"resource\")\n        @Override\n        public synchronized void load(final Reader reader)"}, {"syntax_pass": true, "original_string": "        @SuppressWarnings(\"resource\")\n        @Override\n        public synchronized void loadFromXML(final InputStream in)\n            throws IOException, InvalidPropertiesFormatException {\n            Objects.requireNonNull(in);\n            throw new UnsupportedOperationException();\n        }", "docstring": "\nThrows {@link UnsupportedOperationException}.\nCaller should use try-with-resources statement.\n", "attributes": {"modifiers": "@SuppressWarnings(\"resource\")\n        @Override\n        public synchronized", "marker_annotations": ["@Override"], "non_marker_annotations": ["@SuppressWarnings(\"resource\")", "public", "synchronized"], "comments": [], "return_type": "void", "classes": []}, "name": "loadFromXML", "params": [{"name": "in", "type": "InputStream"}], "body": "                                                                 {\n            Objects.requireNonNull(in);\n            throw new UnsupportedOperationException();\n        }", "signature": "@SuppressWarnings(\"resource\")\n        @Override\n        public synchronized void loadFromXML(final InputStream in)"}, {"syntax_pass": true, "original_string": "        @Override\n        public synchronized Object merge(final Object key, final Object value,\n            final BiFunction<? super Object, ? super Object, ? extends Object> remappingFunction) {\n            Objects.requireNonNull(key);\n            Objects.requireNonNull(value);\n            throw new UnsupportedOperationException();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public synchronized", "marker_annotations": ["@Override"], "non_marker_annotations": ["public", "synchronized"], "comments": [], "return_type": "Object", "classes": []}, "name": "merge", "params": [{"name": "key", "type": "Object"}, {"name": "value", "type": "Object"}, {"name": "remappingFunction", "type": "BiFunction<? super Object, ? super Object, ? extends Object>"}], "body": "                                                                                                  {\n            Objects.requireNonNull(key);\n            Objects.requireNonNull(value);\n            throw new UnsupportedOperationException();\n        }", "signature": "@Override\n        public synchronized Object merge(final Object key, final Object value,\n            final BiFunction<? super Object, ? super Object, ? extends Object> remappingFunction)"}, {"syntax_pass": true, "original_string": "        @Override\n        public Enumeration<?> propertyNames() {\n            return Collections.emptyEnumeration();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Enumeration<?>", "classes": []}, "name": "propertyNames", "params": [], "body": "                                              {\n            return Collections.emptyEnumeration();\n        }", "signature": "@Override\n        public Enumeration<?> propertyNames()"}, {"syntax_pass": true, "original_string": "        @Override\n        public synchronized Object put(final Object key, final Object value) {\n            Objects.requireNonNull(key);\n            Objects.requireNonNull(value);\n            throw new UnsupportedOperationException();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public synchronized", "marker_annotations": ["@Override"], "non_marker_annotations": ["public", "synchronized"], "comments": [], "return_type": "Object", "classes": []}, "name": "put", "params": [{"name": "key", "type": "Object"}, {"name": "value", "type": "Object"}], "body": "                                                                             {\n            Objects.requireNonNull(key);\n            Objects.requireNonNull(value);\n            throw new UnsupportedOperationException();\n        }", "signature": "@Override\n        public synchronized Object put(final Object key, final Object value)"}, {"syntax_pass": true, "original_string": "        @Override\n        public synchronized void putAll(final Map<? extends Object, ? extends Object> t) {\n            Objects.requireNonNull(t);\n            throw new UnsupportedOperationException();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public synchronized", "marker_annotations": ["@Override"], "non_marker_annotations": ["public", "synchronized"], "comments": [], "return_type": "void", "classes": []}, "name": "putAll", "params": [{"name": "t", "type": "Map<? extends Object, ? extends Object>"}], "body": "                                                                                         {\n            Objects.requireNonNull(t);\n            throw new UnsupportedOperationException();\n        }", "signature": "@Override\n        public synchronized void putAll(final Map<? extends Object, ? extends Object> t)"}, {"syntax_pass": true, "original_string": "        @Override\n        public synchronized Object putIfAbsent(final Object key, final Object value) {\n            Objects.requireNonNull(key);\n            Objects.requireNonNull(value);\n            throw new UnsupportedOperationException();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public synchronized", "marker_annotations": ["@Override"], "non_marker_annotations": ["public", "synchronized"], "comments": [], "return_type": "Object", "classes": []}, "name": "putIfAbsent", "params": [{"name": "key", "type": "Object"}, {"name": "value", "type": "Object"}], "body": "                                                                                     {\n            Objects.requireNonNull(key);\n            Objects.requireNonNull(value);\n            throw new UnsupportedOperationException();\n        }", "signature": "@Override\n        public synchronized Object putIfAbsent(final Object key, final Object value)"}, {"syntax_pass": true, "original_string": "        @Override\n        protected void rehash() {\n            // Noop\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "name": "rehash", "params": [], "body": "                                {\n            // Noop\n        }", "signature": "@Override\n        protected void rehash()"}, {"syntax_pass": true, "original_string": "        @Override\n        public synchronized Object remove(final Object key) {\n            Objects.requireNonNull(key);\n            throw new UnsupportedOperationException();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public synchronized", "marker_annotations": ["@Override"], "non_marker_annotations": ["public", "synchronized"], "comments": [], "return_type": "Object", "classes": []}, "name": "remove", "params": [{"name": "key", "type": "Object"}], "body": "                                                            {\n            Objects.requireNonNull(key);\n            throw new UnsupportedOperationException();\n        }", "signature": "@Override\n        public synchronized Object remove(final Object key)"}, {"syntax_pass": true, "original_string": "        @Override\n        public synchronized boolean remove(final Object key, final Object value) {\n            Objects.requireNonNull(key);\n            Objects.requireNonNull(value);\n            throw new UnsupportedOperationException();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public synchronized", "marker_annotations": ["@Override"], "non_marker_annotations": ["public", "synchronized"], "comments": [], "return_type": "boolean", "classes": []}, "name": "remove", "params": [{"name": "key", "type": "Object"}, {"name": "value", "type": "Object"}], "body": "                                                                                 {\n            Objects.requireNonNull(key);\n            Objects.requireNonNull(value);\n            throw new UnsupportedOperationException();\n        }", "signature": "@Override\n        public synchronized boolean remove(final Object key, final Object value)"}, {"syntax_pass": true, "original_string": "        @Override\n        public synchronized Object replace(final Object key, final Object value) {\n            Objects.requireNonNull(key);\n            Objects.requireNonNull(value);\n            throw new UnsupportedOperationException();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public synchronized", "marker_annotations": ["@Override"], "non_marker_annotations": ["public", "synchronized"], "comments": [], "return_type": "Object", "classes": []}, "name": "replace", "params": [{"name": "key", "type": "Object"}, {"name": "value", "type": "Object"}], "body": "                                                                                 {\n            Objects.requireNonNull(key);\n            Objects.requireNonNull(value);\n            throw new UnsupportedOperationException();\n        }", "signature": "@Override\n        public synchronized Object replace(final Object key, final Object value)"}, {"syntax_pass": true, "original_string": "        @Override\n        public synchronized boolean replace(final Object key, final Object oldValue, final Object newValue) {\n            Objects.requireNonNull(key);\n            Objects.requireNonNull(oldValue);\n            Objects.requireNonNull(newValue);\n            throw new UnsupportedOperationException();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public synchronized", "marker_annotations": ["@Override"], "non_marker_annotations": ["public", "synchronized"], "comments": [], "return_type": "boolean", "classes": []}, "name": "replace", "params": [{"name": "key", "type": "Object"}, {"name": "oldValue", "type": "Object"}, {"name": "newValue", "type": "Object"}], "body": "                                                                                                            {\n            Objects.requireNonNull(key);\n            Objects.requireNonNull(oldValue);\n            Objects.requireNonNull(newValue);\n            throw new UnsupportedOperationException();\n        }", "signature": "@Override\n        public synchronized boolean replace(final Object key, final Object oldValue, final Object newValue)"}, {"syntax_pass": true, "original_string": "        @Override\n        public synchronized void replaceAll(\n            final BiFunction<? super Object, ? super Object, ? extends Object> function) {\n            Objects.requireNonNull(function);\n            throw new UnsupportedOperationException();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public synchronized", "marker_annotations": ["@Override"], "non_marker_annotations": ["public", "synchronized"], "comments": [], "return_type": "void", "classes": []}, "name": "replaceAll", "params": [{"name": "function", "type": "BiFunction<? super Object, ? super Object, ? extends Object>"}], "body": "                                                                                         {\n            Objects.requireNonNull(function);\n            throw new UnsupportedOperationException();\n        }", "signature": "@Override\n        public synchronized void replaceAll(\n            final BiFunction<? super Object, ? super Object, ? extends Object> function)"}, {"syntax_pass": true, "original_string": "        @SuppressWarnings(\"deprecation\")\n        @Override\n        public void save(final OutputStream out, final String comments) {\n            // Implement as super\n            super.save(out, comments);\n        }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"deprecation\")\n        @Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["@SuppressWarnings(\"deprecation\")", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "save", "params": [{"name": "out", "type": "OutputStream"}, {"name": "comments", "type": "String"}], "body": "                                                                        {\n            // Implement as super\n            super.save(out, comments);\n        }", "signature": "@SuppressWarnings(\"deprecation\")\n        @Override\n        public void save(final OutputStream out, final String comments)"}, {"syntax_pass": true, "original_string": "        @Override\n        public synchronized Object setProperty(final String key, final String value) {\n            Objects.requireNonNull(key);\n            Objects.requireNonNull(value);\n            throw new UnsupportedOperationException();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public synchronized", "marker_annotations": ["@Override"], "non_marker_annotations": ["public", "synchronized"], "comments": [], "return_type": "Object", "classes": []}, "name": "setProperty", "params": [{"name": "key", "type": "String"}, {"name": "value", "type": "String"}], "body": "                                                                                     {\n            Objects.requireNonNull(key);\n            Objects.requireNonNull(value);\n            throw new UnsupportedOperationException();\n        }", "signature": "@Override\n        public synchronized Object setProperty(final String key, final String value)"}, {"syntax_pass": true, "original_string": "        @Override\n        public synchronized int size() {\n            return 0;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public synchronized", "marker_annotations": ["@Override"], "non_marker_annotations": ["public", "synchronized"], "comments": [], "return_type": "int", "classes": []}, "name": "size", "params": [], "body": "                                       {\n            return 0;\n        }", "signature": "@Override\n        public synchronized int size()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Set<String> stringPropertyNames() {\n            return Collections.emptySet();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Set<String>", "classes": []}, "name": "stringPropertyNames", "params": [], "body": "                                                 {\n            return Collections.emptySet();\n        }", "signature": "@Override\n        public Set<String> stringPropertyNames()"}, {"syntax_pass": true, "original_string": "        @Override\n        public synchronized String toString() {\n            // Implement as super\n            return super.toString();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public synchronized", "marker_annotations": ["@Override"], "non_marker_annotations": ["public", "synchronized"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                              {\n            // Implement as super\n            return super.toString();\n        }", "signature": "@Override\n        public synchronized String toString()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Collection<Object> values() {\n            return Collections.emptyList();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Collection<Object>", "classes": []}, "name": "values", "params": [], "body": "                                           {\n            return Collections.emptyList();\n        }", "signature": "@Override\n        public Collection<Object> values()"}]}], "class_docstring": "\nCreates and loads {@link Properties}.\n\n@see Properties\n@since 4.4\n", "original_string": "public class PropertiesFactory extends AbstractPropertiesFactory<Properties> {\n\n    private static final class EmptyProperties extends Properties {\n\n        private static final long serialVersionUID = 1L;\n\n        @Override\n        public synchronized void clear() {\n            // Noop\n        }\n\n        @Override\n        public synchronized Object compute(final Object key,\n            final BiFunction<? super Object, ? super Object, ? extends Object> remappingFunction) {\n            Objects.requireNonNull(key);\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public synchronized Object computeIfAbsent(final Object key,\n            final Function<? super Object, ? extends Object> mappingFunction) {\n            Objects.requireNonNull(key);\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public synchronized Object computeIfPresent(final Object key,\n            final BiFunction<? super Object, ? super Object, ? extends Object> remappingFunction) {\n            Objects.requireNonNull(key);\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public synchronized boolean contains(final Object value) {\n            return false;\n        }\n\n        @Override\n        public synchronized boolean containsKey(final Object key) {\n            return false;\n        }\n\n        @Override\n        public boolean containsValue(final Object value) {\n            return false;\n        }\n\n        @Override\n        public synchronized Enumeration<Object> elements() {\n            return Collections.emptyEnumeration();\n        }\n\n        @Override\n        public Set<Entry<Object, Object>> entrySet() {\n            return Collections.emptySet();\n        }\n\n        @Override\n        public synchronized boolean equals(final Object o) {\n            return o instanceof Properties && ((Properties) o).isEmpty();\n        }\n\n        @Override\n        public synchronized void forEach(final BiConsumer<? super Object, ? super Object> action) {\n            Objects.requireNonNull(action);\n        }\n\n        @Override\n        public synchronized Object get(final Object key) {\n            return null;\n        }\n\n        @Override\n        public synchronized Object getOrDefault(final Object key, final Object defaultValue) {\n            return defaultValue;\n        }\n\n        @Override\n        public String getProperty(final String key) {\n            return null;\n        }\n\n        @Override\n        public String getProperty(final String key, final String defaultValue) {\n            return defaultValue;\n        }\n\n        @Override\n        public synchronized int hashCode() {\n            return 0;\n        }\n\n        @Override\n        public synchronized boolean isEmpty() {\n            return true;\n        }\n\n        @Override\n        public synchronized Enumeration<Object> keys() {\n            return Collections.emptyEnumeration();\n        }\n\n        @Override\n        public Set<Object> keySet() {\n            return Collections.emptySet();\n        }\n\n        /**\n         * Throws {@link UnsupportedOperationException}.\n         * Caller should use try-with-resources statement.\n         */\n        @SuppressWarnings(\"resource\")\n        @Override\n        public synchronized void load(final InputStream inStream) throws IOException {\n            Objects.requireNonNull(inStream);\n            throw new UnsupportedOperationException();\n        }\n\n        /**\n         * Throws {@link UnsupportedOperationException}.\n         * Caller should use try-with-resources statement.\n         */\n        @SuppressWarnings(\"resource\")\n        @Override\n        public synchronized void load(final Reader reader) throws IOException {\n            Objects.requireNonNull(reader);\n            throw new UnsupportedOperationException();\n        }\n\n        /**\n         * Throws {@link UnsupportedOperationException}.\n         * Caller should use try-with-resources statement.\n         */\n        @SuppressWarnings(\"resource\")\n        @Override\n        public synchronized void loadFromXML(final InputStream in)\n            throws IOException, InvalidPropertiesFormatException {\n            Objects.requireNonNull(in);\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public synchronized Object merge(final Object key, final Object value,\n            final BiFunction<? super Object, ? super Object, ? extends Object> remappingFunction) {\n            Objects.requireNonNull(key);\n            Objects.requireNonNull(value);\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public Enumeration<?> propertyNames() {\n            return Collections.emptyEnumeration();\n        }\n\n        @Override\n        public synchronized Object put(final Object key, final Object value) {\n            Objects.requireNonNull(key);\n            Objects.requireNonNull(value);\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public synchronized void putAll(final Map<? extends Object, ? extends Object> t) {\n            Objects.requireNonNull(t);\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public synchronized Object putIfAbsent(final Object key, final Object value) {\n            Objects.requireNonNull(key);\n            Objects.requireNonNull(value);\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        protected void rehash() {\n            // Noop\n        }\n\n        @Override\n        public synchronized Object remove(final Object key) {\n            Objects.requireNonNull(key);\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public synchronized boolean remove(final Object key, final Object value) {\n            Objects.requireNonNull(key);\n            Objects.requireNonNull(value);\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public synchronized Object replace(final Object key, final Object value) {\n            Objects.requireNonNull(key);\n            Objects.requireNonNull(value);\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public synchronized boolean replace(final Object key, final Object oldValue, final Object newValue) {\n            Objects.requireNonNull(key);\n            Objects.requireNonNull(oldValue);\n            Objects.requireNonNull(newValue);\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public synchronized void replaceAll(\n            final BiFunction<? super Object, ? super Object, ? extends Object> function) {\n            Objects.requireNonNull(function);\n            throw new UnsupportedOperationException();\n        }\n\n        @SuppressWarnings(\"deprecation\")\n        @Override\n        public void save(final OutputStream out, final String comments) {\n            // Implement as super\n            super.save(out, comments);\n        }\n\n        @Override\n        public synchronized Object setProperty(final String key, final String value) {\n            Objects.requireNonNull(key);\n            Objects.requireNonNull(value);\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public synchronized int size() {\n            return 0;\n        }\n\n        @Override\n        public Set<String> stringPropertyNames() {\n            return Collections.emptySet();\n        }\n\n        @Override\n        public synchronized String toString() {\n            // Implement as super\n            return super.toString();\n        }\n\n        @Override\n        public Collection<Object> values() {\n            return Collections.emptyList();\n        }\n\n    }\n\n    /**\n     * The empty map (immutable). This map is serializable.\n     *\n     * @since 4.5.0\n     */\n    public static final Properties EMPTY_PROPERTIES = new EmptyProperties();\n\n    /**\n     * The singleton instance.\n     */\n    public static final PropertiesFactory INSTANCE = new PropertiesFactory();\n\n    /**\n     * Constructs an instance.\n     */\n    private PropertiesFactory() {\n        // There is only one instance.\n    }\n\n    /**\n     * Subclasses override to provide customized properties instances.\n     *\n     * @return a new Properties instance.\n     */\n    @Override\n    protected Properties createProperties() {\n        return new Properties();\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final Properties EMPTY_PROPERTIES = new EmptyProperties();", "docstring": "\nThe empty map (immutable). This map is serializable.\n\n@since 4.5.0\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Properties", "name": "EMPTY_PROPERTIES = new EmptyProperties()", "syntax_pass": true}, {"attribute_expression": "public static final PropertiesFactory INSTANCE = new PropertiesFactory();", "docstring": "\nThe singleton instance.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "PropertiesFactory", "name": "INSTANCE = new PropertiesFactory()", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/properties/SortedPropertiesFactory.java.SortedPropertiesFactory", "name": "SortedPropertiesFactory", "file_path": "src/main/java/org/apache/commons/collections4/properties/SortedPropertiesFactory.java", "superclasses": "", "methods": ["[]SortedPropertiesFactory()", "[SortedProperties]createProperties()"], "method_uris": ["src/main/java/org/apache/commons/collections4/properties/SortedPropertiesFactory.java.SortedPropertiesFactory.[]SortedPropertiesFactory()", "src/main/java/org/apache/commons/collections4/properties/SortedPropertiesFactory.java.SortedPropertiesFactory.[SortedProperties]createProperties()"], "overrides": null, "attributes": [], "class_docstring": "\nCreates and loads {@link SortedProperties}.\n\n@see SortedProperties\n@since 4.4\n", "original_string": "public class SortedPropertiesFactory extends AbstractPropertiesFactory<SortedProperties> {\n\n    /**\n     * The singleton instance.\n     */\n    public static final SortedPropertiesFactory INSTANCE = new SortedPropertiesFactory();\n\n    /**\n     * Constructs an instance.\n     */\n    private SortedPropertiesFactory() {\n        // There is only one instance.\n    }\n\n    /**\n     * Subclasses override to provide customized properties instances.\n     *\n     * @return a new Properties instance.\n     */\n    @Override\n    protected SortedProperties createProperties() {\n        return new SortedProperties();\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final SortedPropertiesFactory INSTANCE = new SortedPropertiesFactory();", "docstring": "\nThe singleton instance.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "SortedPropertiesFactory", "name": "INSTANCE = new SortedPropertiesFactory()", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/bidimap/DualTreeBidiMap.java.DualTreeBidiMap", "name": "DualTreeBidiMap", "file_path": "src/main/java/org/apache/commons/collections4/bidimap/DualTreeBidiMap.java", "superclasses": "", "methods": ["[]DualTreeBidiMap()", "[]DualTreeBidiMap(Comparator<? super K>,Comparator<? super V>)", "[]DualTreeBidiMap(Map<? extends K, ? extends V>)", "[]DualTreeBidiMap(Map<K, V>,Map<V, K>,BidiMap<V, K>)", "[Comparator<? super K>]comparator()", "[DualTreeBidiMap<V, K>]createBidiMap(Map<V, K>,Map<K, V>,BidiMap<K, V>)", "[K]firstKey()", "[SortedMap<K, V>]headMap(K)", "[SortedBidiMap<V, K>]inverseBidiMap()", "[OrderedBidiMap<V, K>]inverseOrderedBidiMap()", "[SortedBidiMap<V, K>]inverseSortedBidiMap()", "[K]lastKey()", "[OrderedMapIterator<K, V>]mapIterator()", "[K]nextKey(K)", "[K]previousKey(K)", "[void]readObject(ObjectInputStream)", "[SortedMap<K, V>]subMap(K,K)", "[SortedMap<K, V>]tailMap(K)", "[Comparator<? super V>]valueComparator()", "[void]writeObject(ObjectOutputStream)"], "method_uris": ["src/main/java/org/apache/commons/collections4/bidimap/DualTreeBidiMap.java.DualTreeBidiMap.[]DualTreeBidiMap()", "src/main/java/org/apache/commons/collections4/bidimap/DualTreeBidiMap.java.DualTreeBidiMap.[]DualTreeBidiMap(Comparator<? super K>,Comparator<? super V>)", "src/main/java/org/apache/commons/collections4/bidimap/DualTreeBidiMap.java.DualTreeBidiMap.[]DualTreeBidiMap(Map<? extends K, ? extends V>)", "src/main/java/org/apache/commons/collections4/bidimap/DualTreeBidiMap.java.DualTreeBidiMap.[]DualTreeBidiMap(Map<K, V>,Map<V, K>,BidiMap<V, K>)", "src/main/java/org/apache/commons/collections4/bidimap/DualTreeBidiMap.java.DualTreeBidiMap.[Comparator<? super K>]comparator()", "src/main/java/org/apache/commons/collections4/bidimap/DualTreeBidiMap.java.DualTreeBidiMap.[DualTreeBidiMap<V, K>]createBidiMap(Map<V, K>,Map<K, V>,BidiMap<K, V>)", "src/main/java/org/apache/commons/collections4/bidimap/DualTreeBidiMap.java.DualTreeBidiMap.[K]firstKey()", "src/main/java/org/apache/commons/collections4/bidimap/DualTreeBidiMap.java.DualTreeBidiMap.[SortedMap<K, V>]headMap(K)", "src/main/java/org/apache/commons/collections4/bidimap/DualTreeBidiMap.java.DualTreeBidiMap.[SortedBidiMap<V, K>]inverseBidiMap()", "src/main/java/org/apache/commons/collections4/bidimap/DualTreeBidiMap.java.DualTreeBidiMap.[OrderedBidiMap<V, K>]inverseOrderedBidiMap()", "src/main/java/org/apache/commons/collections4/bidimap/DualTreeBidiMap.java.DualTreeBidiMap.[SortedBidiMap<V, K>]inverseSortedBidiMap()", "src/main/java/org/apache/commons/collections4/bidimap/DualTreeBidiMap.java.DualTreeBidiMap.[K]lastKey()", "src/main/java/org/apache/commons/collections4/bidimap/DualTreeBidiMap.java.DualTreeBidiMap.[OrderedMapIterator<K, V>]mapIterator()", "src/main/java/org/apache/commons/collections4/bidimap/DualTreeBidiMap.java.DualTreeBidiMap.[K]nextKey(K)", "src/main/java/org/apache/commons/collections4/bidimap/DualTreeBidiMap.java.DualTreeBidiMap.[K]previousKey(K)", "src/main/java/org/apache/commons/collections4/bidimap/DualTreeBidiMap.java.DualTreeBidiMap.[void]readObject(ObjectInputStream)", "src/main/java/org/apache/commons/collections4/bidimap/DualTreeBidiMap.java.DualTreeBidiMap.[SortedMap<K, V>]subMap(K,K)", "src/main/java/org/apache/commons/collections4/bidimap/DualTreeBidiMap.java.DualTreeBidiMap.[SortedMap<K, V>]tailMap(K)", "src/main/java/org/apache/commons/collections4/bidimap/DualTreeBidiMap.java.DualTreeBidiMap.[Comparator<? super V>]valueComparator()", "src/main/java/org/apache/commons/collections4/bidimap/DualTreeBidiMap.java.DualTreeBidiMap.[void]writeObject(ObjectOutputStream)"], "overrides": null, "attributes": [{"original_string": "    protected static class BidiOrderedMapIterator<K, V> implements OrderedMapIterator<K, V>, ResettableIterator<K> {\n\n        /** The parent map */\n        private final AbstractDualBidiMap<K, V> parent;\n\n        /** The iterator being decorated */\n        private ListIterator<Map.Entry<K, V>> iterator;\n\n        /** The last returned entry */\n        private Map.Entry<K, V> last;\n\n        /**\n         * Constructs a new instance.\n         * @param parent  the parent map\n         */\n        protected BidiOrderedMapIterator(final AbstractDualBidiMap<K, V> parent) {\n            this.parent = parent;\n            iterator = new ArrayList<>(parent.entrySet()).listIterator();\n        }\n\n        @Override\n        public K getKey() {\n            if (last == null) {\n                throw new IllegalStateException(\n                        \"Iterator getKey() can only be called after next() and before remove()\");\n            }\n            return last.getKey();\n        }\n\n        @Override\n        public V getValue() {\n            if (last == null) {\n                throw new IllegalStateException(\n                        \"Iterator getValue() can only be called after next() and before remove()\");\n            }\n            return last.getValue();\n        }\n\n        @Override\n        public boolean hasNext() {\n            return iterator.hasNext();\n        }\n\n        @Override\n        public boolean hasPrevious() {\n            return iterator.hasPrevious();\n        }\n\n        @Override\n        public K next() {\n            last = iterator.next();\n            return last.getKey();\n        }\n\n        @Override\n        public K previous() {\n            last = iterator.previous();\n            return last.getKey();\n        }\n\n        @Override\n        public void remove() {\n            iterator.remove();\n            parent.remove(last.getKey());\n            last = null;\n        }\n\n        @Override\n        public void reset() {\n            iterator = new ArrayList<>(parent.entrySet()).listIterator();\n            last = null;\n        }\n\n        @Override\n        public V setValue(final V value) {\n            if (last == null) {\n                throw new IllegalStateException(\n                        \"Iterator setValue() can only be called after next() and before remove()\");\n            }\n            if (parent.reverseMap.containsKey(value) &&\n                parent.reverseMap.get(value) != last.getKey()) {\n                throw new IllegalArgumentException(\n                        \"Cannot use setValue() when the object being set is already in the map\");\n            }\n            final V oldValue = parent.put(last.getKey(), value);\n            // Map.Entry specifies that the behavior is undefined when the backing map\n            // has been modified (as we did with the put), so we also set the value\n            last.setValue(value);\n            return oldValue;\n        }\n\n        @Override\n        public String toString() {\n            if (last != null) {\n                return \"MapIterator[\" + getKey() + \"=\" + getValue() + \"]\";\n            }\n            return \"MapIterator[]\";\n        }\n    }", "definition": "    protected static class BidiOrderedMapIterator<K, V> implements OrderedMapIterator<K, V>, ResettableIterator<K>", "class_docstring": "\nInner class MapIterator.\n\n@param <K> the type of the keys.\n@param <V> the type of the values.\n", "name": "BidiOrderedMapIterator", "super_interfaces": ["OrderedMapIterator<K, V>", "ResettableIterator<K>"], "superclasses": "", "attributes": {"modifiers": "protected static", "marker_annotations": [], "non_marker_annotations": ["protected", "static"], "comments": [], "fields": [{"attribute_expression": "private final AbstractDualBidiMap<K, V> parent;", "docstring": " The parent map", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "AbstractDualBidiMap<K, V>", "name": "parent", "syntax_pass": true}, {"attribute_expression": "private ListIterator<Map.Entry<K, V>> iterator;", "docstring": " The iterator being decorated", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ListIterator<Map.Entry<K, V>>", "name": "iterator", "syntax_pass": true}, {"attribute_expression": "private Map.Entry<K, V> last;", "docstring": " The last returned entry", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Map.Entry<K, V>", "name": "last", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        protected BidiOrderedMapIterator(final AbstractDualBidiMap<K, V> parent) {\n            this.parent = parent;\n            iterator = new ArrayList<>(parent.entrySet()).listIterator();\n        }", "docstring": "\nConstructs a new instance.\n@param parent  the parent map\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "name": "BidiOrderedMapIterator", "params": [{"name": "parent", "type": "AbstractDualBidiMap<K, V>"}], "body": "                                                                                 {\n            this.parent = parent;\n            iterator = new ArrayList<>(parent.entrySet()).listIterator();\n        }", "signature": "protected BidiOrderedMapIterator(final AbstractDualBidiMap<K, V> parent)"}, {"syntax_pass": true, "original_string": "        @Override\n        public K getKey() {\n            if (last == null) {\n                throw new IllegalStateException(\n                        \"Iterator getKey() can only be called after next() and before remove()\");\n            }\n            return last.getKey();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "K", "classes": []}, "name": "getKey", "params": [], "body": "                          {\n            if (last == null) {\n                throw new IllegalStateException(\n                        \"Iterator getKey() can only be called after next() and before remove()\");\n            }\n            return last.getKey();\n        }", "signature": "@Override\n        public K getKey()"}, {"syntax_pass": true, "original_string": "        @Override\n        public V getValue() {\n            if (last == null) {\n                throw new IllegalStateException(\n                        \"Iterator getValue() can only be called after next() and before remove()\");\n            }\n            return last.getValue();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "getValue", "params": [], "body": "                            {\n            if (last == null) {\n                throw new IllegalStateException(\n                        \"Iterator getValue() can only be called after next() and before remove()\");\n            }\n            return last.getValue();\n        }", "signature": "@Override\n        public V getValue()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean hasNext() {\n            return iterator.hasNext();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasNext", "params": [], "body": "                                 {\n            return iterator.hasNext();\n        }", "signature": "@Override\n        public boolean hasNext()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean hasPrevious() {\n            return iterator.hasPrevious();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasPrevious", "params": [], "body": "                                     {\n            return iterator.hasPrevious();\n        }", "signature": "@Override\n        public boolean hasPrevious()"}, {"syntax_pass": true, "original_string": "        @Override\n        public K next() {\n            last = iterator.next();\n            return last.getKey();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "K", "classes": []}, "name": "next", "params": [], "body": "                        {\n            last = iterator.next();\n            return last.getKey();\n        }", "signature": "@Override\n        public K next()"}, {"syntax_pass": true, "original_string": "        @Override\n        public K previous() {\n            last = iterator.previous();\n            return last.getKey();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "K", "classes": []}, "name": "previous", "params": [], "body": "                            {\n            last = iterator.previous();\n            return last.getKey();\n        }", "signature": "@Override\n        public K previous()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void remove() {\n            iterator.remove();\n            parent.remove(last.getKey());\n            last = null;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "remove", "params": [], "body": "                             {\n            iterator.remove();\n            parent.remove(last.getKey());\n            last = null;\n        }", "signature": "@Override\n        public void remove()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void reset() {\n            iterator = new ArrayList<>(parent.entrySet()).listIterator();\n            last = null;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "reset", "params": [], "body": "                            {\n            iterator = new ArrayList<>(parent.entrySet()).listIterator();\n            last = null;\n        }", "signature": "@Override\n        public void reset()"}, {"syntax_pass": true, "original_string": "        @Override\n        public V setValue(final V value) {\n            if (last == null) {\n                throw new IllegalStateException(\n                        \"Iterator setValue() can only be called after next() and before remove()\");\n            }\n            if (parent.reverseMap.containsKey(value) &&\n                parent.reverseMap.get(value) != last.getKey()) {\n                throw new IllegalArgumentException(\n                        \"Cannot use setValue() when the object being set is already in the map\");\n            }\n            final V oldValue = parent.put(last.getKey(), value);\n            // Map.Entry specifies that the behavior is undefined when the backing map\n            // has been modified (as we did with the put), so we also set the value\n            last.setValue(value);\n            return oldValue;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "setValue", "params": [{"name": "value", "type": "V"}], "body": "                                         {\n            if (last == null) {\n                throw new IllegalStateException(\n                        \"Iterator setValue() can only be called after next() and before remove()\");\n            }\n            if (parent.reverseMap.containsKey(value) &&\n                parent.reverseMap.get(value) != last.getKey()) {\n                throw new IllegalArgumentException(\n                        \"Cannot use setValue() when the object being set is already in the map\");\n            }\n            final V oldValue = parent.put(last.getKey(), value);\n            // Map.Entry specifies that the behavior is undefined when the backing map\n            // has been modified (as we did with the put), so we also set the value\n            last.setValue(value);\n            return oldValue;\n        }", "signature": "@Override\n        public V setValue(final V value)"}, {"syntax_pass": true, "original_string": "        @Override\n        public String toString() {\n            if (last != null) {\n                return \"MapIterator[\" + getKey() + \"=\" + getValue() + \"]\";\n            }\n            return \"MapIterator[]\";\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                 {\n            if (last != null) {\n                return \"MapIterator[\" + getKey() + \"=\" + getValue() + \"]\";\n            }\n            return \"MapIterator[]\";\n        }", "signature": "@Override\n        public String toString()"}]}, {"original_string": "    protected static class ViewMap<K, V> extends AbstractSortedMapDecorator<K, V> {\n        /**\n         * Constructs a new instance.\n         * @param bidi  the parent bidi map\n         * @param sm  the subMap sorted map\n         */\n        protected ViewMap(final DualTreeBidiMap<K, V> bidi, final SortedMap<K, V> sm) {\n            // the implementation is not great here...\n            // use the normalMap as the filtered map, but reverseMap as the full map\n            // this forces containsValue and clear to be overridden\n            super(new DualTreeBidiMap<>(sm, bidi.reverseMap, bidi.inverseBidiMap));\n        }\n\n        @Override\n        public void clear() {\n            // override as default implementation uses reverseMap\n            for (final Iterator<K> it = keySet().iterator(); it.hasNext();) {\n                it.next();\n                it.remove();\n            }\n        }\n\n        @Override\n        public boolean containsValue(final Object value) {\n            // override as default implementation uses reverseMap\n            return decorated().normalMap.containsValue(value);\n        }\n\n        @Override\n        protected DualTreeBidiMap<K, V> decorated() {\n            return (DualTreeBidiMap<K, V>) super.decorated();\n        }\n\n        @Override\n        public SortedMap<K, V> headMap(final K toKey) {\n            return new ViewMap<>(decorated(), super.headMap(toKey));\n        }\n\n        @Override\n        public K nextKey(final K key) {\n            return decorated().nextKey(key);\n        }\n\n        @Override\n        public K previousKey(final K key) {\n            return decorated().previousKey(key);\n        }\n\n        @Override\n        public SortedMap<K, V> subMap(final K fromKey, final K toKey) {\n            return new ViewMap<>(decorated(), super.subMap(fromKey, toKey));\n        }\n\n        @Override\n        public SortedMap<K, V> tailMap(final K fromKey) {\n            return new ViewMap<>(decorated(), super.tailMap(fromKey));\n        }\n    }", "definition": "    protected static class ViewMap<K, V> extends AbstractSortedMapDecorator<K, V>", "class_docstring": "\nInternal sorted map view.\n\n@param <K> the type of the keys.\n@param <V> the type of the values.\n", "name": "ViewMap", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "protected static", "marker_annotations": [], "non_marker_annotations": ["protected", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        protected ViewMap(final DualTreeBidiMap<K, V> bidi, final SortedMap<K, V> sm) {\n            // the implementation is not great here...\n            // use the normalMap as the filtered map, but reverseMap as the full map\n            // this forces containsValue and clear to be overridden\n            super(new DualTreeBidiMap<>(sm, bidi.reverseMap, bidi.inverseBidiMap));\n        }", "docstring": "\nConstructs a new instance.\n@param bidi  the parent bidi map\n@param sm  the subMap sorted map\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "name": "ViewMap", "params": [{"name": "bidi", "type": "DualTreeBidiMap<K, V>"}, {"name": "sm", "type": "SortedMap<K, V>"}], "body": "                                                                                      {\n            // the implementation is not great here...\n            // use the normalMap as the filtered map, but reverseMap as the full map\n            // this forces containsValue and clear to be overridden\n            super(new DualTreeBidiMap<>(sm, bidi.reverseMap, bidi.inverseBidiMap));\n        }", "signature": "protected ViewMap(final DualTreeBidiMap<K, V> bidi, final SortedMap<K, V> sm)"}, {"syntax_pass": true, "original_string": "        @Override\n        public void clear() {\n            // override as default implementation uses reverseMap\n            for (final Iterator<K> it = keySet().iterator(); it.hasNext();) {\n                it.next();\n                it.remove();\n            }\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "clear", "params": [], "body": "                            {\n            // override as default implementation uses reverseMap\n            for (final Iterator<K> it = keySet().iterator(); it.hasNext();) {\n                it.next();\n                it.remove();\n            }\n        }", "signature": "@Override\n        public void clear()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean containsValue(final Object value) {\n            // override as default implementation uses reverseMap\n            return decorated().normalMap.containsValue(value);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "containsValue", "params": [{"name": "value", "type": "Object"}], "body": "                                                         {\n            // override as default implementation uses reverseMap\n            return decorated().normalMap.containsValue(value);\n        }", "signature": "@Override\n        public boolean containsValue(final Object value)"}, {"syntax_pass": true, "original_string": "        @Override\n        protected DualTreeBidiMap<K, V> decorated() {\n            return (DualTreeBidiMap<K, V>) super.decorated();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "DualTreeBidiMap<K, V>", "classes": []}, "name": "decorated", "params": [], "body": "                                                    {\n            return (DualTreeBidiMap<K, V>) super.decorated();\n        }", "signature": "@Override\n        protected DualTreeBidiMap<K, V> decorated()"}, {"syntax_pass": true, "original_string": "        @Override\n        public SortedMap<K, V> headMap(final K toKey) {\n            return new ViewMap<>(decorated(), super.headMap(toKey));\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "SortedMap<K, V>", "classes": []}, "name": "headMap", "params": [{"name": "toKey", "type": "K"}], "body": "                                                      {\n            return new ViewMap<>(decorated(), super.headMap(toKey));\n        }", "signature": "@Override\n        public SortedMap<K, V> headMap(final K toKey)"}, {"syntax_pass": true, "original_string": "        @Override\n        public K nextKey(final K key) {\n            return decorated().nextKey(key);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "K", "classes": []}, "name": "nextKey", "params": [{"name": "key", "type": "K"}], "body": "                                      {\n            return decorated().nextKey(key);\n        }", "signature": "@Override\n        public K nextKey(final K key)"}, {"syntax_pass": true, "original_string": "        @Override\n        public K previousKey(final K key) {\n            return decorated().previousKey(key);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "K", "classes": []}, "name": "previousKey", "params": [{"name": "key", "type": "K"}], "body": "                                          {\n            return decorated().previousKey(key);\n        }", "signature": "@Override\n        public K previousKey(final K key)"}, {"syntax_pass": true, "original_string": "        @Override\n        public SortedMap<K, V> subMap(final K fromKey, final K toKey) {\n            return new ViewMap<>(decorated(), super.subMap(fromKey, toKey));\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "SortedMap<K, V>", "classes": []}, "name": "subMap", "params": [{"name": "fromKey", "type": "K"}, {"name": "toKey", "type": "K"}], "body": "                                                                      {\n            return new ViewMap<>(decorated(), super.subMap(fromKey, toKey));\n        }", "signature": "@Override\n        public SortedMap<K, V> subMap(final K fromKey, final K toKey)"}, {"syntax_pass": true, "original_string": "        @Override\n        public SortedMap<K, V> tailMap(final K fromKey) {\n            return new ViewMap<>(decorated(), super.tailMap(fromKey));\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "SortedMap<K, V>", "classes": []}, "name": "tailMap", "params": [{"name": "fromKey", "type": "K"}], "body": "                                                        {\n            return new ViewMap<>(decorated(), super.tailMap(fromKey));\n        }", "signature": "@Override\n        public SortedMap<K, V> tailMap(final K fromKey)"}]}], "class_docstring": "\nImplements {@link BidiMap} with two {@link TreeMap} instances.\n<p>\nThe setValue() method on iterators will succeed only if the new value being set is\nnot already in the bidi map.\n</p>\n<p>\nWhen considering whether to use this class, the {@link TreeBidiMap} class should\nalso be considered. It implements the interface using a dedicated design, and does\nnot store each object twice, which can save on memory use.\n</p>\n<p>\nNOTE: From Commons Collections 3.1, all subclasses will use {@link TreeMap}\nand the flawed {@code createMap} method is ignored.\n</p>\n\n@param <K> the type of the keys in this map\n@param <V> the type of the values in this map\n@since 3.0\n", "original_string": "public class DualTreeBidiMap<K, V> extends AbstractDualBidiMap<K, V>\n        implements SortedBidiMap<K, V>, Serializable {\n\n    /**\n     * Inner class MapIterator.\n     *\n     * @param <K> the type of the keys.\n     * @param <V> the type of the values.\n     */\n    protected static class BidiOrderedMapIterator<K, V> implements OrderedMapIterator<K, V>, ResettableIterator<K> {\n\n        /** The parent map */\n        private final AbstractDualBidiMap<K, V> parent;\n\n        /** The iterator being decorated */\n        private ListIterator<Map.Entry<K, V>> iterator;\n\n        /** The last returned entry */\n        private Map.Entry<K, V> last;\n\n        /**\n         * Constructs a new instance.\n         * @param parent  the parent map\n         */\n        protected BidiOrderedMapIterator(final AbstractDualBidiMap<K, V> parent) {\n            this.parent = parent;\n            iterator = new ArrayList<>(parent.entrySet()).listIterator();\n        }\n\n        @Override\n        public K getKey() {\n            if (last == null) {\n                throw new IllegalStateException(\n                        \"Iterator getKey() can only be called after next() and before remove()\");\n            }\n            return last.getKey();\n        }\n\n        @Override\n        public V getValue() {\n            if (last == null) {\n                throw new IllegalStateException(\n                        \"Iterator getValue() can only be called after next() and before remove()\");\n            }\n            return last.getValue();\n        }\n\n        @Override\n        public boolean hasNext() {\n            return iterator.hasNext();\n        }\n\n        @Override\n        public boolean hasPrevious() {\n            return iterator.hasPrevious();\n        }\n\n        @Override\n        public K next() {\n            last = iterator.next();\n            return last.getKey();\n        }\n\n        @Override\n        public K previous() {\n            last = iterator.previous();\n            return last.getKey();\n        }\n\n        @Override\n        public void remove() {\n            iterator.remove();\n            parent.remove(last.getKey());\n            last = null;\n        }\n\n        @Override\n        public void reset() {\n            iterator = new ArrayList<>(parent.entrySet()).listIterator();\n            last = null;\n        }\n\n        @Override\n        public V setValue(final V value) {\n            if (last == null) {\n                throw new IllegalStateException(\n                        \"Iterator setValue() can only be called after next() and before remove()\");\n            }\n            if (parent.reverseMap.containsKey(value) &&\n                parent.reverseMap.get(value) != last.getKey()) {\n                throw new IllegalArgumentException(\n                        \"Cannot use setValue() when the object being set is already in the map\");\n            }\n            final V oldValue = parent.put(last.getKey(), value);\n            // Map.Entry specifies that the behavior is undefined when the backing map\n            // has been modified (as we did with the put), so we also set the value\n            last.setValue(value);\n            return oldValue;\n        }\n\n        @Override\n        public String toString() {\n            if (last != null) {\n                return \"MapIterator[\" + getKey() + \"=\" + getValue() + \"]\";\n            }\n            return \"MapIterator[]\";\n        }\n    }\n\n    /**\n     * Internal sorted map view.\n     *\n     * @param <K> the type of the keys.\n     * @param <V> the type of the values.\n     */\n    protected static class ViewMap<K, V> extends AbstractSortedMapDecorator<K, V> {\n        /**\n         * Constructs a new instance.\n         * @param bidi  the parent bidi map\n         * @param sm  the subMap sorted map\n         */\n        protected ViewMap(final DualTreeBidiMap<K, V> bidi, final SortedMap<K, V> sm) {\n            // the implementation is not great here...\n            // use the normalMap as the filtered map, but reverseMap as the full map\n            // this forces containsValue and clear to be overridden\n            super(new DualTreeBidiMap<>(sm, bidi.reverseMap, bidi.inverseBidiMap));\n        }\n\n        @Override\n        public void clear() {\n            // override as default implementation uses reverseMap\n            for (final Iterator<K> it = keySet().iterator(); it.hasNext();) {\n                it.next();\n                it.remove();\n            }\n        }\n\n        @Override\n        public boolean containsValue(final Object value) {\n            // override as default implementation uses reverseMap\n            return decorated().normalMap.containsValue(value);\n        }\n\n        @Override\n        protected DualTreeBidiMap<K, V> decorated() {\n            return (DualTreeBidiMap<K, V>) super.decorated();\n        }\n\n        @Override\n        public SortedMap<K, V> headMap(final K toKey) {\n            return new ViewMap<>(decorated(), super.headMap(toKey));\n        }\n\n        @Override\n        public K nextKey(final K key) {\n            return decorated().nextKey(key);\n        }\n\n        @Override\n        public K previousKey(final K key) {\n            return decorated().previousKey(key);\n        }\n\n        @Override\n        public SortedMap<K, V> subMap(final K fromKey, final K toKey) {\n            return new ViewMap<>(decorated(), super.subMap(fromKey, toKey));\n        }\n\n        @Override\n        public SortedMap<K, V> tailMap(final K fromKey) {\n            return new ViewMap<>(decorated(), super.tailMap(fromKey));\n        }\n    }\n\n    /** Ensure serialization compatibility */\n    private static final long serialVersionUID = 721969328361809L;\n\n    /** The key comparator to use */\n    private final Comparator<? super K> comparator;\n\n    /** The value comparator to use */\n    private final Comparator<? super V> valueComparator;\n\n    /**\n     * Creates an empty {@link DualTreeBidiMap}.\n     */\n    public DualTreeBidiMap() {\n        super(new TreeMap<>(), new TreeMap<>());\n        this.comparator = null;\n        this.valueComparator = null;\n    }\n\n    /**\n     * Constructs a {@link DualTreeBidiMap} using the specified {@link Comparator}.\n     *\n     * @param keyComparator  the comparator\n     * @param valueComparator  the values comparator to use\n     */\n    public DualTreeBidiMap(final Comparator<? super K> keyComparator, final Comparator<? super V> valueComparator) {\n        super(new TreeMap<>(keyComparator), new TreeMap<>(valueComparator));\n        this.comparator = keyComparator;\n        this.valueComparator = valueComparator;\n    }\n\n    /**\n     * Constructs a {@link DualTreeBidiMap} and copies the mappings from\n     * specified {@link Map}.\n     *\n     * @param map  the map whose mappings are to be placed in this map\n     */\n    public DualTreeBidiMap(final Map<? extends K, ? extends V> map) {\n        super(new TreeMap<>(), new TreeMap<>());\n        putAll(map);\n        this.comparator = null;\n        this.valueComparator = null;\n    }\n\n    /**\n     * Constructs a {@link DualTreeBidiMap} that decorates the specified maps.\n     *\n     * @param normalMap  the normal direction map\n     * @param reverseMap  the reverse direction map\n     * @param inverseBidiMap  the inverse BidiMap\n     */\n    protected DualTreeBidiMap(final Map<K, V> normalMap, final Map<V, K> reverseMap,\n                              final BidiMap<V, K> inverseBidiMap) {\n        super(normalMap, reverseMap, inverseBidiMap);\n        this.comparator = ((SortedMap<K, V>) normalMap).comparator();\n        this.valueComparator = ((SortedMap<V, K>) reverseMap).comparator();\n    }\n\n    @Override\n    public Comparator<? super K> comparator() {\n        return ((SortedMap<K, V>) normalMap).comparator();\n    }\n\n    /**\n     * Creates a new instance of this object.\n     *\n     * @param normalMap  the normal direction map\n     * @param reverseMap  the reverse direction map\n     * @param inverseMap  the inverse BidiMap\n     * @return new bidi map\n     */\n    @Override\n    protected DualTreeBidiMap<V, K> createBidiMap(final Map<V, K> normalMap, final Map<K, V> reverseMap,\n                                                  final BidiMap<K, V> inverseMap) {\n        return new DualTreeBidiMap<>(normalMap, reverseMap, inverseMap);\n    }\n\n    @Override\n    public K firstKey() {\n        return ((SortedMap<K, V>) normalMap).firstKey();\n    }\n\n    @Override\n    public SortedMap<K, V> headMap(final K toKey) {\n        final SortedMap<K, V> sub = ((SortedMap<K, V>) normalMap).headMap(toKey);\n        return new ViewMap<>(this, sub);\n    }\n\n    @Override\n    public SortedBidiMap<V, K> inverseBidiMap() {\n        return (SortedBidiMap<V, K>) super.inverseBidiMap();\n    }\n\n    /**\n     * Defaults to {@link #inverseBidiMap()}.\n     *\n     * @return Defaults to {@link #inverseBidiMap()}.\n     */\n    public OrderedBidiMap<V, K> inverseOrderedBidiMap() {\n        return inverseBidiMap();\n    }\n\n    /**\n     * Defaults to {@link #inverseBidiMap()}.\n     *\n     * @return Defaults to {@link #inverseBidiMap()}.\n     */\n    public SortedBidiMap<V, K> inverseSortedBidiMap() {\n        return inverseBidiMap();\n    }\n\n    @Override\n    public K lastKey() {\n        return ((SortedMap<K, V>) normalMap).lastKey();\n    }\n\n    /**\n     * Obtains an ordered map iterator.\n     * <p>\n     * This implementation copies the elements to an ArrayList in order to\n     * provide the forward/backward behavior.\n     * </p>\n     *\n     * @return a new ordered map iterator\n     */\n    @Override\n    public OrderedMapIterator<K, V> mapIterator() {\n        return new BidiOrderedMapIterator<>(this);\n    }\n\n    @Override\n    public K nextKey(final K key) {\n        if (isEmpty()) {\n            return null;\n        }\n        if (normalMap instanceof OrderedMap) {\n            return ((OrderedMap<K, ?>) normalMap).nextKey(key);\n        }\n        final SortedMap<K, V> sm = (SortedMap<K, V>) normalMap;\n        final Iterator<K> it = sm.tailMap(key).keySet().iterator();\n        it.next();\n        if (it.hasNext()) {\n            return it.next();\n        }\n        return null;\n    }\n\n    @Override\n    public K previousKey(final K key) {\n        if (isEmpty()) {\n            return null;\n        }\n        if (normalMap instanceof OrderedMap) {\n            return ((OrderedMap<K, V>) normalMap).previousKey(key);\n        }\n        final SortedMap<K, V> sm = (SortedMap<K, V>) normalMap;\n        final SortedMap<K, V> hm = sm.headMap(key);\n        if (hm.isEmpty()) {\n            return null;\n        }\n        return hm.lastKey();\n    }\n\n    /**\n     * Deserializes an instance from an ObjectInputStream.\n     *\n     * @param in The source ObjectInputStream.\n     * @throws IOException            Any of the usual Input/Output related exceptions.\n     * @throws ClassNotFoundException A class of a serialized object cannot be found.\n     */\n    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        normalMap = new TreeMap<>(comparator);\n        reverseMap = new TreeMap<>(valueComparator);\n        @SuppressWarnings(\"unchecked\") // will fail at runtime if the stream is incorrect\n        final Map<K, V> map = (Map<K, V>) in.readObject();\n        putAll(map);\n    }\n\n    @Override\n    public SortedMap<K, V> subMap(final K fromKey, final K toKey) {\n        final SortedMap<K, V> sub = ((SortedMap<K, V>) normalMap).subMap(fromKey, toKey);\n        return new ViewMap<>(this, sub);\n    }\n\n    @Override\n    public SortedMap<K, V> tailMap(final K fromKey) {\n        final SortedMap<K, V> sub = ((SortedMap<K, V>) normalMap).tailMap(fromKey);\n        return new ViewMap<>(this, sub);\n    }\n\n    @Override\n    public Comparator<? super V> valueComparator() {\n        return ((SortedMap<V, K>) reverseMap).comparator();\n    }\n\n    /**\n     * Serializes this object to an ObjectOutputStream.\n     *\n     * @param out the target ObjectOutputStream.\n     * @throws IOException thrown when an I/O errors occur writing to the target stream.\n     */\n    private void writeObject(final ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        out.writeObject(normalMap);\n    }\n\n}", "super_interfaces": ["SortedBidiMap<K, V>", "Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 721969328361809L;", "docstring": " Ensure serialization compatibility", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 721969328361809L", "syntax_pass": true}, {"attribute_expression": "private final Comparator<? super K> comparator;", "docstring": " The key comparator to use", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Comparator<? super K>", "name": "comparator", "syntax_pass": true}, {"attribute_expression": "private final Comparator<? super V> valueComparator;", "docstring": " The value comparator to use", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Comparator<? super V>", "name": "valueComparator", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/bidimap/DualLinkedHashBidiMap.java.DualLinkedHashBidiMap", "name": "DualLinkedHashBidiMap", "file_path": "src/main/java/org/apache/commons/collections4/bidimap/DualLinkedHashBidiMap.java", "superclasses": "", "methods": ["[]DualLinkedHashBidiMap()", "[]DualLinkedHashBidiMap(Map<? extends K, ? extends V>)", "[]DualLinkedHashBidiMap(Map<K, V>,Map<V, K>,BidiMap<V, K>)", "[BidiMap<V, K>]createBidiMap(Map<V, K>,Map<K, V>,BidiMap<K, V>)", "[void]readObject(ObjectInputStream)", "[void]writeObject(ObjectOutputStream)"], "method_uris": ["src/main/java/org/apache/commons/collections4/bidimap/DualLinkedHashBidiMap.java.DualLinkedHashBidiMap.[]DualLinkedHashBidiMap()", "src/main/java/org/apache/commons/collections4/bidimap/DualLinkedHashBidiMap.java.DualLinkedHashBidiMap.[]DualLinkedHashBidiMap(Map<? extends K, ? extends V>)", "src/main/java/org/apache/commons/collections4/bidimap/DualLinkedHashBidiMap.java.DualLinkedHashBidiMap.[]DualLinkedHashBidiMap(Map<K, V>,Map<V, K>,BidiMap<V, K>)", "src/main/java/org/apache/commons/collections4/bidimap/DualLinkedHashBidiMap.java.DualLinkedHashBidiMap.[BidiMap<V, K>]createBidiMap(Map<V, K>,Map<K, V>,BidiMap<K, V>)", "src/main/java/org/apache/commons/collections4/bidimap/DualLinkedHashBidiMap.java.DualLinkedHashBidiMap.[void]readObject(ObjectInputStream)", "src/main/java/org/apache/commons/collections4/bidimap/DualLinkedHashBidiMap.java.DualLinkedHashBidiMap.[void]writeObject(ObjectOutputStream)"], "overrides": null, "attributes": [], "class_docstring": "\nImplements {@link BidiMap} with two {@link LinkedHashMap} instances.\n<p>\nTwo {@link LinkedHashMap} instances are used in this class.\nThis provides fast lookups at the expense of storing two sets of map entries and two linked lists.\n</p>\n\n@param <K> the type of the keys in the map\n@param <V> the type of the values in the map\n\n@since 4.0\n", "original_string": "public class DualLinkedHashBidiMap<K, V> extends AbstractDualBidiMap<K, V> implements Serializable {\n\n    /** Ensure serialization compatibility */\n    private static final long serialVersionUID = 721969328361810L;\n\n    /**\n     * Creates an empty {@code HashBidiMap}.\n     */\n    public DualLinkedHashBidiMap() {\n        super(new LinkedHashMap<>(), new LinkedHashMap<>());\n    }\n\n    /**\n     * Constructs a {@code LinkedHashBidiMap} and copies the mappings from\n     * specified {@link Map}.\n     *\n     * @param map the map whose mappings are to be placed in this map\n     */\n    public DualLinkedHashBidiMap(final Map<? extends K, ? extends V> map) {\n        super(new LinkedHashMap<>(), new LinkedHashMap<>());\n        putAll(map);\n    }\n\n    /**\n     * Constructs a {@code LinkedHashBidiMap} that decorates the specified maps.\n     *\n     * @param normalMap      the normal direction map\n     * @param reverseMap     the reverse direction map\n     * @param inverseBidiMap the inverse BidiMap\n     */\n    protected DualLinkedHashBidiMap(final Map<K, V> normalMap, final Map<V, K> reverseMap,\n                                    final BidiMap<V, K> inverseBidiMap) {\n        super(normalMap, reverseMap, inverseBidiMap);\n    }\n\n    /**\n     * Creates a new instance of this object.\n     *\n     * @param normalMap      the normal direction map\n     * @param reverseMap     the reverse direction map\n     * @param inverseBidiMap the inverse BidiMap\n     * @return new bidi map\n     */\n    @Override\n    protected BidiMap<V, K> createBidiMap(final Map<V, K> normalMap, final Map<K, V> reverseMap,\n            final BidiMap<K, V> inverseBidiMap) {\n        return new DualLinkedHashBidiMap<>(normalMap, reverseMap, inverseBidiMap);\n    }\n\n    /**\n     * Deserializes an instance from an ObjectInputStream.\n     *\n     * @param in The source ObjectInputStream.\n     * @throws IOException            Any of the usual Input/Output related exceptions.\n     * @throws ClassNotFoundException A class of a serialized object cannot be found.\n     */\n    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        normalMap = new LinkedHashMap<>();\n        reverseMap = new LinkedHashMap<>();\n        @SuppressWarnings(\"unchecked\") // will fail at runtime if stream is incorrect\n        final Map<K, V> map = (Map<K, V>) in.readObject();\n        putAll(map);\n    }\n\n    /**\n     * Serializes this object to an ObjectOutputStream.\n     *\n     * @param out the target ObjectOutputStream.\n     * @throws IOException thrown when an I/O errors occur writing to the target stream.\n     */\n    private void writeObject(final ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        out.writeObject(normalMap);\n    }\n}", "super_interfaces": ["Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 721969328361810L;", "docstring": " Ensure serialization compatibility", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 721969328361810L", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/bidimap/UnmodifiableSortedBidiMap.java.UnmodifiableSortedBidiMap", "name": "UnmodifiableSortedBidiMap", "file_path": "src/main/java/org/apache/commons/collections4/bidimap/UnmodifiableSortedBidiMap.java", "superclasses": "", "methods": ["[SortedBidiMap<K, V>]unmodifiableSortedBidiMap(SortedBidiMap<K, ? extends V>)", "[]UnmodifiableSortedBidiMap(SortedBidiMap<K, ? extends V>)", "[void]clear()", "[Set<Map.Entry<K, V>>]entrySet()", "[SortedMap<K, V>]headMap(K)", "[SortedBidiMap<V, K>]inverseBidiMap()", "[Set<K>]keySet()", "[OrderedMapIterator<K, V>]mapIterator()", "[V]put(K,V)", "[void]putAll(Map<? extends K, ? extends V>)", "[V]remove(Object)", "[K]removeValue(Object)", "[SortedMap<K, V>]subMap(K,K)", "[SortedMap<K, V>]tailMap(K)", "[Set<V>]values()"], "method_uris": ["src/main/java/org/apache/commons/collections4/bidimap/UnmodifiableSortedBidiMap.java.UnmodifiableSortedBidiMap.[SortedBidiMap<K, V>]unmodifiableSortedBidiMap(SortedBidiMap<K, ? extends V>)", "src/main/java/org/apache/commons/collections4/bidimap/UnmodifiableSortedBidiMap.java.UnmodifiableSortedBidiMap.[]UnmodifiableSortedBidiMap(SortedBidiMap<K, ? extends V>)", "src/main/java/org/apache/commons/collections4/bidimap/UnmodifiableSortedBidiMap.java.UnmodifiableSortedBidiMap.[void]clear()", "src/main/java/org/apache/commons/collections4/bidimap/UnmodifiableSortedBidiMap.java.UnmodifiableSortedBidiMap.[Set<Map.Entry<K, V>>]entrySet()", "src/main/java/org/apache/commons/collections4/bidimap/UnmodifiableSortedBidiMap.java.UnmodifiableSortedBidiMap.[SortedMap<K, V>]headMap(K)", "src/main/java/org/apache/commons/collections4/bidimap/UnmodifiableSortedBidiMap.java.UnmodifiableSortedBidiMap.[SortedBidiMap<V, K>]inverseBidiMap()", "src/main/java/org/apache/commons/collections4/bidimap/UnmodifiableSortedBidiMap.java.UnmodifiableSortedBidiMap.[Set<K>]keySet()", "src/main/java/org/apache/commons/collections4/bidimap/UnmodifiableSortedBidiMap.java.UnmodifiableSortedBidiMap.[OrderedMapIterator<K, V>]mapIterator()", "src/main/java/org/apache/commons/collections4/bidimap/UnmodifiableSortedBidiMap.java.UnmodifiableSortedBidiMap.[V]put(K,V)", "src/main/java/org/apache/commons/collections4/bidimap/UnmodifiableSortedBidiMap.java.UnmodifiableSortedBidiMap.[void]putAll(Map<? extends K, ? extends V>)", "src/main/java/org/apache/commons/collections4/bidimap/UnmodifiableSortedBidiMap.java.UnmodifiableSortedBidiMap.[V]remove(Object)", "src/main/java/org/apache/commons/collections4/bidimap/UnmodifiableSortedBidiMap.java.UnmodifiableSortedBidiMap.[K]removeValue(Object)", "src/main/java/org/apache/commons/collections4/bidimap/UnmodifiableSortedBidiMap.java.UnmodifiableSortedBidiMap.[SortedMap<K, V>]subMap(K,K)", "src/main/java/org/apache/commons/collections4/bidimap/UnmodifiableSortedBidiMap.java.UnmodifiableSortedBidiMap.[SortedMap<K, V>]tailMap(K)", "src/main/java/org/apache/commons/collections4/bidimap/UnmodifiableSortedBidiMap.java.UnmodifiableSortedBidiMap.[Set<V>]values()"], "overrides": null, "attributes": [], "class_docstring": "\nDecorates another {@link SortedBidiMap} to ensure it can't be altered.\n<p>\nAttempts to modify it will result in an {@link UnsupportedOperationException}.\n</p>\n\n@param <K> the type of the keys in this map\n@param <V> the type of the values in this map\n@since 3.0\n", "original_string": "public final class UnmodifiableSortedBidiMap<K, V>\n        extends AbstractSortedBidiMapDecorator<K, V> implements Unmodifiable {\n\n    /**\n     * Factory method to create an unmodifiable map.\n     * <p>\n     * If the map passed in is already unmodifiable, it is returned.\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param map  the map to decorate, must not be null\n     * @return an unmodifiable SortedBidiMap\n     * @throws NullPointerException if map is null\n     * @since 4.0\n     */\n    public static <K, V> SortedBidiMap<K, V> unmodifiableSortedBidiMap(final SortedBidiMap<K, ? extends V> map) {\n        if (map instanceof Unmodifiable) {\n            @SuppressWarnings(\"unchecked\") // safe to upcast\n            final SortedBidiMap<K, V> tmpMap = (SortedBidiMap<K, V>) map;\n            return tmpMap;\n        }\n        return new UnmodifiableSortedBidiMap<>(map);\n    }\n\n    /** The inverse unmodifiable map */\n    private UnmodifiableSortedBidiMap<V, K> inverse;\n\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param map  the map to decorate, must not be null\n     * @throws NullPointerException if map is null\n     */\n    @SuppressWarnings(\"unchecked\") // safe to upcast\n    private UnmodifiableSortedBidiMap(final SortedBidiMap<K, ? extends V> map) {\n        super((SortedBidiMap<K, V>) map);\n    }\n\n    @Override\n    public void clear() {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public Set<Map.Entry<K, V>> entrySet() {\n        final Set<Map.Entry<K, V>> set = super.entrySet();\n        return UnmodifiableEntrySet.unmodifiableEntrySet(set);\n    }\n\n    @Override\n    public SortedMap<K, V> headMap(final K toKey) {\n        final SortedMap<K, V> sm = decorated().headMap(toKey);\n        return UnmodifiableSortedMap.unmodifiableSortedMap(sm);\n    }\n\n    @Override\n    public SortedBidiMap<V, K> inverseBidiMap() {\n        if (inverse == null) {\n            inverse = new UnmodifiableSortedBidiMap<>(decorated().inverseBidiMap());\n            inverse.inverse = this;\n        }\n        return inverse;\n    }\n\n    @Override\n    public Set<K> keySet() {\n        final Set<K> set = super.keySet();\n        return UnmodifiableSet.unmodifiableSet(set);\n    }\n\n    @Override\n    public OrderedMapIterator<K, V> mapIterator() {\n        final OrderedMapIterator<K, V> it = decorated().mapIterator();\n        return UnmodifiableOrderedMapIterator.unmodifiableOrderedMapIterator(it);\n    }\n\n    @Override\n    public V put(final K key, final V value) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public void putAll(final Map<? extends K, ? extends V> mapToCopy) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public V remove(final Object key) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public K removeValue(final Object value) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public SortedMap<K, V> subMap(final K fromKey, final K toKey) {\n        final SortedMap<K, V> sm = decorated().subMap(fromKey, toKey);\n        return UnmodifiableSortedMap.unmodifiableSortedMap(sm);\n    }\n\n    @Override\n    public SortedMap<K, V> tailMap(final K fromKey) {\n        final SortedMap<K, V> sm = decorated().tailMap(fromKey);\n        return UnmodifiableSortedMap.unmodifiableSortedMap(sm);\n    }\n\n    @Override\n    public Set<V> values() {\n        final Set<V> set = super.values();\n        return UnmodifiableSet.unmodifiableSet(set);\n    }\n\n}", "super_interfaces": ["Unmodifiable"], "fields": [{"attribute_expression": "private UnmodifiableSortedBidiMap<V, K> inverse;", "docstring": " The inverse unmodifiable map", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "UnmodifiableSortedBidiMap<V, K>", "name": "inverse", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/bidimap/UnmodifiableOrderedBidiMap.java.UnmodifiableOrderedBidiMap", "name": "UnmodifiableOrderedBidiMap", "file_path": "src/main/java/org/apache/commons/collections4/bidimap/UnmodifiableOrderedBidiMap.java", "superclasses": "", "methods": ["[OrderedBidiMap<K, V>]unmodifiableOrderedBidiMap(OrderedBidiMap<? extends K, ? extends V>)", "[]UnmodifiableOrderedBidiMap(OrderedBidiMap<? extends K, ? extends V>)", "[void]clear()", "[Set<Map.Entry<K, V>>]entrySet()", "[OrderedBidiMap<V, K>]inverseBidiMap()", "[OrderedBidiMap<V, K>]inverseOrderedBidiMap()", "[Set<K>]keySet()", "[OrderedMapIterator<K, V>]mapIterator()", "[V]put(K,V)", "[void]putAll(Map<? extends K, ? extends V>)", "[V]remove(Object)", "[K]removeValue(Object)", "[Set<V>]values()"], "method_uris": ["src/main/java/org/apache/commons/collections4/bidimap/UnmodifiableOrderedBidiMap.java.UnmodifiableOrderedBidiMap.[OrderedBidiMap<K, V>]unmodifiableOrderedBidiMap(OrderedBidiMap<? extends K, ? extends V>)", "src/main/java/org/apache/commons/collections4/bidimap/UnmodifiableOrderedBidiMap.java.UnmodifiableOrderedBidiMap.[]UnmodifiableOrderedBidiMap(OrderedBidiMap<? extends K, ? extends V>)", "src/main/java/org/apache/commons/collections4/bidimap/UnmodifiableOrderedBidiMap.java.UnmodifiableOrderedBidiMap.[void]clear()", "src/main/java/org/apache/commons/collections4/bidimap/UnmodifiableOrderedBidiMap.java.UnmodifiableOrderedBidiMap.[Set<Map.Entry<K, V>>]entrySet()", "src/main/java/org/apache/commons/collections4/bidimap/UnmodifiableOrderedBidiMap.java.UnmodifiableOrderedBidiMap.[OrderedBidiMap<V, K>]inverseBidiMap()", "src/main/java/org/apache/commons/collections4/bidimap/UnmodifiableOrderedBidiMap.java.UnmodifiableOrderedBidiMap.[OrderedBidiMap<V, K>]inverseOrderedBidiMap()", "src/main/java/org/apache/commons/collections4/bidimap/UnmodifiableOrderedBidiMap.java.UnmodifiableOrderedBidiMap.[Set<K>]keySet()", "src/main/java/org/apache/commons/collections4/bidimap/UnmodifiableOrderedBidiMap.java.UnmodifiableOrderedBidiMap.[OrderedMapIterator<K, V>]mapIterator()", "src/main/java/org/apache/commons/collections4/bidimap/UnmodifiableOrderedBidiMap.java.UnmodifiableOrderedBidiMap.[V]put(K,V)", "src/main/java/org/apache/commons/collections4/bidimap/UnmodifiableOrderedBidiMap.java.UnmodifiableOrderedBidiMap.[void]putAll(Map<? extends K, ? extends V>)", "src/main/java/org/apache/commons/collections4/bidimap/UnmodifiableOrderedBidiMap.java.UnmodifiableOrderedBidiMap.[V]remove(Object)", "src/main/java/org/apache/commons/collections4/bidimap/UnmodifiableOrderedBidiMap.java.UnmodifiableOrderedBidiMap.[K]removeValue(Object)", "src/main/java/org/apache/commons/collections4/bidimap/UnmodifiableOrderedBidiMap.java.UnmodifiableOrderedBidiMap.[Set<V>]values()"], "overrides": null, "attributes": [], "class_docstring": "\nDecorates another {@link OrderedBidiMap} to ensure it can't be altered.\n<p>\nAttempts to modify it will result in an UnsupportedOperationException.\n</p>\n\n@param <K> the type of the keys in this map\n@param <V> the type of the values in this map\n@since 3.0\n", "original_string": "public final class UnmodifiableOrderedBidiMap<K, V>\n        extends AbstractOrderedBidiMapDecorator<K, V> implements Unmodifiable {\n\n    /**\n     * Factory method to create an unmodifiable map.\n     * <p>\n     * If the map passed in is already unmodifiable, it is returned.\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param map  the map to decorate, must not be null\n     * @return an unmodifiable OrderedBidiMap\n     * @throws NullPointerException if map is null\n     * @since 4.0\n     */\n    public static <K, V> OrderedBidiMap<K, V> unmodifiableOrderedBidiMap(\n            final OrderedBidiMap<? extends K, ? extends V> map) {\n        if (map instanceof Unmodifiable) {\n            @SuppressWarnings(\"unchecked\") // safe to upcast\n            final OrderedBidiMap<K, V> tmpMap = (OrderedBidiMap<K, V>) map;\n            return tmpMap;\n        }\n        return new UnmodifiableOrderedBidiMap<>(map);\n    }\n\n    /** The inverse unmodifiable map */\n    private UnmodifiableOrderedBidiMap<V, K> inverse;\n\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param map  the map to decorate, must not be null\n     * @throws NullPointerException if map is null\n     */\n    @SuppressWarnings(\"unchecked\") // safe to upcast\n    private UnmodifiableOrderedBidiMap(final OrderedBidiMap<? extends K, ? extends V> map) {\n        super((OrderedBidiMap<K, V>) map);\n    }\n\n    @Override\n    public void clear() {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public Set<Map.Entry<K, V>> entrySet() {\n        final Set<Map.Entry<K, V>> set = super.entrySet();\n        return UnmodifiableEntrySet.unmodifiableEntrySet(set);\n    }\n\n    @Override\n    public OrderedBidiMap<V, K> inverseBidiMap() {\n        return inverseOrderedBidiMap();\n    }\n\n    /**\n     * Gets an unmodifiable view of this map where the keys and values are reversed.\n     *\n     * @return an inverted unmodifiable bidirectional map\n     */\n    public OrderedBidiMap<V, K> inverseOrderedBidiMap() {\n        if (inverse == null) {\n            inverse = new UnmodifiableOrderedBidiMap<>(decorated().inverseBidiMap());\n            inverse.inverse = this;\n        }\n        return inverse;\n    }\n\n    @Override\n    public Set<K> keySet() {\n        final Set<K> set = super.keySet();\n        return UnmodifiableSet.unmodifiableSet(set);\n    }\n\n    @Override\n    public OrderedMapIterator<K, V> mapIterator() {\n        final OrderedMapIterator<K, V> it = decorated().mapIterator();\n        return UnmodifiableOrderedMapIterator.unmodifiableOrderedMapIterator(it);\n    }\n\n    @Override\n    public V put(final K key, final V value) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public void putAll(final Map<? extends K, ? extends V> mapToCopy) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public V remove(final Object key) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public K removeValue(final Object value) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public Set<V> values() {\n        final Set<V> set = super.values();\n        return UnmodifiableSet.unmodifiableSet(set);\n    }\n\n}", "super_interfaces": ["Unmodifiable"], "fields": [{"attribute_expression": "private UnmodifiableOrderedBidiMap<V, K> inverse;", "docstring": " The inverse unmodifiable map", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "UnmodifiableOrderedBidiMap<V, K>", "name": "inverse", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/bidimap/UnmodifiableBidiMap.java.UnmodifiableBidiMap", "name": "UnmodifiableBidiMap", "file_path": "src/main/java/org/apache/commons/collections4/bidimap/UnmodifiableBidiMap.java", "superclasses": "", "methods": ["[BidiMap<K, V>]unmodifiableBidiMap(BidiMap<? extends K, ? extends V>)", "[]UnmodifiableBidiMap(BidiMap<? extends K, ? extends V>)", "[void]clear()", "[Set<Map.Entry<K, V>>]entrySet()", "[BidiMap<V, K>]inverseBidiMap()", "[Set<K>]keySet()", "[MapIterator<K, V>]mapIterator()", "[V]put(K,V)", "[void]putAll(Map<? extends K, ? extends V>)", "[V]remove(Object)", "[K]removeValue(Object)", "[Set<V>]values()"], "method_uris": ["src/main/java/org/apache/commons/collections4/bidimap/UnmodifiableBidiMap.java.UnmodifiableBidiMap.[BidiMap<K, V>]unmodifiableBidiMap(BidiMap<? extends K, ? extends V>)", "src/main/java/org/apache/commons/collections4/bidimap/UnmodifiableBidiMap.java.UnmodifiableBidiMap.[]UnmodifiableBidiMap(BidiMap<? extends K, ? extends V>)", "src/main/java/org/apache/commons/collections4/bidimap/UnmodifiableBidiMap.java.UnmodifiableBidiMap.[void]clear()", "src/main/java/org/apache/commons/collections4/bidimap/UnmodifiableBidiMap.java.UnmodifiableBidiMap.[Set<Map.Entry<K, V>>]entrySet()", "src/main/java/org/apache/commons/collections4/bidimap/UnmodifiableBidiMap.java.UnmodifiableBidiMap.[BidiMap<V, K>]inverseBidiMap()", "src/main/java/org/apache/commons/collections4/bidimap/UnmodifiableBidiMap.java.UnmodifiableBidiMap.[Set<K>]keySet()", "src/main/java/org/apache/commons/collections4/bidimap/UnmodifiableBidiMap.java.UnmodifiableBidiMap.[MapIterator<K, V>]mapIterator()", "src/main/java/org/apache/commons/collections4/bidimap/UnmodifiableBidiMap.java.UnmodifiableBidiMap.[V]put(K,V)", "src/main/java/org/apache/commons/collections4/bidimap/UnmodifiableBidiMap.java.UnmodifiableBidiMap.[void]putAll(Map<? extends K, ? extends V>)", "src/main/java/org/apache/commons/collections4/bidimap/UnmodifiableBidiMap.java.UnmodifiableBidiMap.[V]remove(Object)", "src/main/java/org/apache/commons/collections4/bidimap/UnmodifiableBidiMap.java.UnmodifiableBidiMap.[K]removeValue(Object)", "src/main/java/org/apache/commons/collections4/bidimap/UnmodifiableBidiMap.java.UnmodifiableBidiMap.[Set<V>]values()"], "overrides": null, "attributes": [], "class_docstring": "\nDecorates another {@link BidiMap} to ensure it can't be altered.\n<p>\nAttempts to modify it will result in an UnsupportedOperationException.\n</p>\n\n@param <K> the type of the keys in this map\n@param <V> the type of the values in this map\n@since 3.0\n", "original_string": "public final class UnmodifiableBidiMap<K, V>\n        extends AbstractBidiMapDecorator<K, V> implements Unmodifiable {\n\n    /**\n     * Factory method to create an unmodifiable map.\n     * <p>\n     * If the map passed in is already unmodifiable, it is returned.\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param map  the map to decorate, must not be null\n     * @return an unmodifiable BidiMap\n     * @throws NullPointerException if map is null\n     * @since 4.0\n     */\n    public static <K, V> BidiMap<K, V> unmodifiableBidiMap(final BidiMap<? extends K, ? extends V> map) {\n        if (map instanceof Unmodifiable) {\n            @SuppressWarnings(\"unchecked\") // safe to upcast\n            final BidiMap<K, V> tmpMap = (BidiMap<K, V>) map;\n            return tmpMap;\n        }\n        return new UnmodifiableBidiMap<>(map);\n    }\n\n    /** The inverse unmodifiable map */\n    private UnmodifiableBidiMap<V, K> inverse;\n\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param map  the map to decorate, must not be null\n     * @throws NullPointerException if map is null\n     */\n    @SuppressWarnings(\"unchecked\") // safe to upcast\n    private UnmodifiableBidiMap(final BidiMap<? extends K, ? extends V> map) {\n        super((BidiMap<K, V>) map);\n    }\n\n    @Override\n    public void clear() {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public Set<Map.Entry<K, V>> entrySet() {\n        final Set<Map.Entry<K, V>> set = super.entrySet();\n        return UnmodifiableEntrySet.unmodifiableEntrySet(set);\n    }\n\n    @Override\n    public synchronized BidiMap<V, K> inverseBidiMap() {\n        if (inverse == null) {\n            inverse = new UnmodifiableBidiMap<>(decorated().inverseBidiMap());\n            inverse.inverse = this;\n        }\n        return inverse;\n    }\n\n    @Override\n    public Set<K> keySet() {\n        final Set<K> set = super.keySet();\n        return UnmodifiableSet.unmodifiableSet(set);\n    }\n\n    @Override\n    public MapIterator<K, V> mapIterator() {\n        final MapIterator<K, V> it = decorated().mapIterator();\n        return UnmodifiableMapIterator.unmodifiableMapIterator(it);\n    }\n\n    @Override\n    public V put(final K key, final V value) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public void putAll(final Map<? extends K, ? extends V> mapToCopy) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public V remove(final Object key) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public K removeValue(final Object value) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public Set<V> values() {\n        final Set<V> set = super.values();\n        return UnmodifiableSet.unmodifiableSet(set);\n    }\n\n}", "super_interfaces": ["Unmodifiable"], "fields": [{"attribute_expression": "private UnmodifiableBidiMap<V, K> inverse;", "docstring": " The inverse unmodifiable map", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "UnmodifiableBidiMap<V, K>", "name": "inverse", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java.TreeBidiMap", "name": "TreeBidiMap", "file_path": "src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java", "superclasses": "", "methods": ["[void]checkKey(Object)", "[void]checkKeyAndValue(Object,Object)", "[void]checkNonNullComparable(Object,DataElement)", "[void]checkValue(Object)", "[int]compare(T,T)", "[boolean]isBlack(Node<?, ?>,DataElement)", "[boolean]isRed(Node<?, ?>,DataElement)", "[void]makeBlack(Node<?, ?>,DataElement)", "[void]makeRed(Node<?, ?>,DataElement)", "[]TreeBidiMap()", "[]TreeBidiMap(Map<? extends K, ? extends V>)", "[void]clear()", "[boolean]containsKey(Object)", "[boolean]containsValue(Object)", "[void]copyColor(Node<K, V>,Node<K, V>,DataElement)", "[boolean]doEquals(Object,DataElement)", "[int]doHashCode(DataElement)", "[void]doPut(K,V)", "[void]doRedBlackDelete(Node<K, V>)", "[void]doRedBlackDeleteFixup(Node<K, V>,DataElement)", "[void]doRedBlackInsert(Node<K, V>,DataElement)", "[V]doRemoveKey(Object)", "[K]doRemoveValue(Object)", "[String]doToString(DataElement)", "[Set<Map.Entry<K, V>>]entrySet()", "[boolean]equals(Object)", "[K]firstKey()", "[V]get(Object)", "[Node<K, V>]getGrandParent(Node<K, V>,DataElement)", "[K]getKey(Object)", "[Node<K, V>]getLeftChild(Node<K, V>,DataElement)", "[MapIterator<?, ?>]getMapIterator(DataElement)", "[Node<K, V>]getParent(Node<K, V>,DataElement)", "[Node<K, V>]getRightChild(Node<K, V>,DataElement)", "[Node<K, V>]greatestNode(Node<K, V>,DataElement)", "[void]grow()", "[int]hashCode()", "[void]insertValue(Node<K, V>)", "[OrderedBidiMap<V, K>]inverseBidiMap()", "[boolean]isEmpty()", "[Set<K>]keySet()", "[K]lastKey()", "[Node<K, V>]leastNode(Node<K, V>,DataElement)", "[Node<K, V>]lookup(Object,DataElement)", "[Node<K, V>]lookupKey(Object)", "[Node<K, V>]lookupValue(Object)", "[OrderedMapIterator<K, V>]mapIterator()", "[void]modify()", "[Node<K, V>]nextGreater(Node<K, V>,DataElement)", "[K]nextKey(K)", "[Node<K, V>]nextSmaller(Node<K, V>,DataElement)", "[K]previousKey(K)", "[V]put(K,V)", "[void]putAll(Map<? extends K, ? extends V>)", "[void]readObject(ObjectInputStream)", "[V]remove(Object)", "[K]removeValue(Object)", "[void]rotateLeft(Node<K, V>,DataElement)", "[void]rotateRight(Node<K, V>,DataElement)", "[void]shrink()", "[int]size()", "[void]swapPosition(Node<K, V>,Node<K, V>,DataElement)", "[String]toString()", "[Set<V>]values()", "[void]writeObject(ObjectOutputStream)"], "method_uris": ["src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java.TreeBidiMap.[void]checkKey(Object)", "src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java.TreeBidiMap.[void]checkKeyAndValue(Object,Object)", "src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java.TreeBidiMap.[void]checkNonNullComparable(Object,DataElement)", "src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java.TreeBidiMap.[void]checkValue(Object)", "src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java.TreeBidiMap.[int]compare(T,T)", "src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java.TreeBidiMap.[boolean]isBlack(Node<?, ?>,DataElement)", "src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java.TreeBidiMap.[boolean]isRed(Node<?, ?>,DataElement)", "src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java.TreeBidiMap.[void]makeBlack(Node<?, ?>,DataElement)", "src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java.TreeBidiMap.[void]makeRed(Node<?, ?>,DataElement)", "src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java.TreeBidiMap.[]TreeBidiMap()", "src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java.TreeBidiMap.[]TreeBidiMap(Map<? extends K, ? extends V>)", "src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java.TreeBidiMap.[void]clear()", "src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java.TreeBidiMap.[boolean]containsKey(Object)", "src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java.TreeBidiMap.[boolean]containsValue(Object)", "src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java.TreeBidiMap.[void]copyColor(Node<K, V>,Node<K, V>,DataElement)", "src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java.TreeBidiMap.[boolean]doEquals(Object,DataElement)", "src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java.TreeBidiMap.[int]doHashCode(DataElement)", "src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java.TreeBidiMap.[void]doPut(K,V)", "src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java.TreeBidiMap.[void]doRedBlackDelete(Node<K, V>)", "src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java.TreeBidiMap.[void]doRedBlackDeleteFixup(Node<K, V>,DataElement)", "src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java.TreeBidiMap.[void]doRedBlackInsert(Node<K, V>,DataElement)", "src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java.TreeBidiMap.[V]doRemoveKey(Object)", "src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java.TreeBidiMap.[K]doRemoveValue(Object)", "src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java.TreeBidiMap.[String]doToString(DataElement)", "src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java.TreeBidiMap.[Set<Map.Entry<K, V>>]entrySet()", "src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java.TreeBidiMap.[boolean]equals(Object)", "src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java.TreeBidiMap.[K]firstKey()", "src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java.TreeBidiMap.[V]get(Object)", "src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java.TreeBidiMap.[Node<K, V>]getGrandParent(Node<K, V>,DataElement)", "src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java.TreeBidiMap.[K]getKey(Object)", "src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java.TreeBidiMap.[Node<K, V>]getLeftChild(Node<K, V>,DataElement)", "src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java.TreeBidiMap.[MapIterator<?, ?>]getMapIterator(DataElement)", "src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java.TreeBidiMap.[Node<K, V>]getParent(Node<K, V>,DataElement)", "src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java.TreeBidiMap.[Node<K, V>]getRightChild(Node<K, V>,DataElement)", "src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java.TreeBidiMap.[Node<K, V>]greatestNode(Node<K, V>,DataElement)", "src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java.TreeBidiMap.[void]grow()", "src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java.TreeBidiMap.[int]hashCode()", "src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java.TreeBidiMap.[void]insertValue(Node<K, V>)", "src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java.TreeBidiMap.[OrderedBidiMap<V, K>]inverseBidiMap()", "src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java.TreeBidiMap.[boolean]isEmpty()", "src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java.TreeBidiMap.[Set<K>]keySet()", "src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java.TreeBidiMap.[K]lastKey()", "src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java.TreeBidiMap.[Node<K, V>]leastNode(Node<K, V>,DataElement)", "src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java.TreeBidiMap.[Node<K, V>]lookup(Object,DataElement)", "src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java.TreeBidiMap.[Node<K, V>]lookupKey(Object)", "src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java.TreeBidiMap.[Node<K, V>]lookupValue(Object)", "src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java.TreeBidiMap.[OrderedMapIterator<K, V>]mapIterator()", "src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java.TreeBidiMap.[void]modify()", "src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java.TreeBidiMap.[Node<K, V>]nextGreater(Node<K, V>,DataElement)", "src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java.TreeBidiMap.[K]nextKey(K)", "src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java.TreeBidiMap.[Node<K, V>]nextSmaller(Node<K, V>,DataElement)", "src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java.TreeBidiMap.[K]previousKey(K)", "src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java.TreeBidiMap.[V]put(K,V)", "src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java.TreeBidiMap.[void]putAll(Map<? extends K, ? extends V>)", "src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java.TreeBidiMap.[void]readObject(ObjectInputStream)", "src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java.TreeBidiMap.[V]remove(Object)", "src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java.TreeBidiMap.[K]removeValue(Object)", "src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java.TreeBidiMap.[void]rotateLeft(Node<K, V>,DataElement)", "src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java.TreeBidiMap.[void]rotateRight(Node<K, V>,DataElement)", "src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java.TreeBidiMap.[void]shrink()", "src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java.TreeBidiMap.[int]size()", "src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java.TreeBidiMap.[void]swapPosition(Node<K, V>,Node<K, V>,DataElement)", "src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java.TreeBidiMap.[String]toString()", "src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java.TreeBidiMap.[Set<V>]values()", "src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java.TreeBidiMap.[void]writeObject(ObjectOutputStream)"], "overrides": null, "attributes": [{"original_string": "    abstract class AbstractView<E> extends AbstractSet<E> {\n\n        /** Whether to return KEY or VALUE order. */\n        final DataElement orderType;\n\n        /**\n         * Constructs a new instance.\n         * @param orderType  the KEY or VALUE int for the order\n         */\n        AbstractView(final DataElement orderType) {\n            this.orderType = orderType;\n        }\n\n        @Override\n        public void clear() {\n            TreeBidiMap.this.clear();\n        }\n\n        @Override\n        public int size() {\n            return TreeBidiMap.this.size();\n        }\n    }", "definition": "    abstract class AbstractView<E> extends AbstractSet<E>", "class_docstring": "\nA view of this map.\n", "name": "AbstractView", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "abstract", "marker_annotations": [], "non_marker_annotations": ["abstract"], "comments": [], "fields": [{"attribute_expression": "final DataElement orderType;", "docstring": " Whether to return KEY or VALUE order.", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "DataElement", "name": "orderType", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        AbstractView(final DataElement orderType) {\n            this.orderType = orderType;\n        }", "docstring": "\nConstructs a new instance.\n@param orderType  the KEY or VALUE int for the order\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "AbstractView", "params": [{"name": "orderType", "type": "DataElement"}], "body": "                                                  {\n            this.orderType = orderType;\n        }", "signature": "AbstractView(final DataElement orderType)"}, {"syntax_pass": true, "original_string": "        @Override\n        public void clear() {\n            TreeBidiMap.this.clear();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "clear", "params": [], "body": "                            {\n            TreeBidiMap.this.clear();\n        }", "signature": "@Override\n        public void clear()"}, {"syntax_pass": true, "original_string": "        @Override\n        public int size() {\n            return TreeBidiMap.this.size();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "size", "params": [], "body": "                          {\n            return TreeBidiMap.this.size();\n        }", "signature": "@Override\n        public int size()"}]}, {"original_string": "    abstract class AbstractViewIterator {\n\n        /** Whether to return KEY or VALUE order. */\n        private final DataElement orderType;\n        /** The last node returned by the iterator. */\n        Node<K, V> lastReturnedNode;\n        /** The next node to be returned by the iterator. */\n        private Node<K, V> nextNode;\n        /** The previous node in the sequence returned by the iterator. */\n        private Node<K, V> previousNode;\n        /** The modification count. */\n        private int expectedModifications;\n\n        /**\n         * Constructs a new instance.\n         * @param orderType  the KEY or VALUE int for the order\n         */\n        AbstractViewIterator(final DataElement orderType) {\n            this.orderType = orderType;\n            expectedModifications = modifications;\n            nextNode = leastNode(rootNode[orderType.ordinal()], orderType);\n            lastReturnedNode = null;\n            previousNode = null;\n        }\n\n        public final boolean hasNext() {\n            return nextNode != null;\n        }\n\n        public boolean hasPrevious() {\n            return previousNode != null;\n        }\n\n        protected Node<K, V> navigateNext() {\n            if (nextNode == null) {\n                throw new NoSuchElementException();\n            }\n            if (modifications != expectedModifications) {\n                throw new ConcurrentModificationException();\n            }\n            lastReturnedNode = nextNode;\n            previousNode = nextNode;\n            nextNode = nextGreater(nextNode, orderType);\n            return lastReturnedNode;\n        }\n\n        protected Node<K, V> navigatePrevious() {\n            if (previousNode == null) {\n                throw new NoSuchElementException();\n            }\n            if (modifications != expectedModifications) {\n                throw new ConcurrentModificationException();\n            }\n            nextNode = lastReturnedNode;\n            if (nextNode == null) {\n                nextNode = nextGreater(previousNode, orderType);\n            }\n            lastReturnedNode = previousNode;\n            previousNode = nextSmaller(previousNode, orderType);\n            return lastReturnedNode;\n        }\n\n        public final void remove() {\n            if (lastReturnedNode == null) {\n                throw new IllegalStateException();\n            }\n            if (modifications != expectedModifications) {\n                throw new ConcurrentModificationException();\n            }\n            doRedBlackDelete(lastReturnedNode);\n            expectedModifications++;\n            lastReturnedNode = null;\n            if (nextNode == null) {\n                previousNode = greatestNode(rootNode[orderType.ordinal()], orderType);\n            } else {\n                previousNode = nextSmaller(nextNode, orderType);\n            }\n        }\n    }", "definition": "    abstract class AbstractViewIterator", "class_docstring": "\nAn iterator over the map.\n", "name": "AbstractViewIterator", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "abstract", "marker_annotations": [], "non_marker_annotations": ["abstract"], "comments": [], "fields": [{"attribute_expression": "private final DataElement orderType;", "docstring": " Whether to return KEY or VALUE order.", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "DataElement", "name": "orderType", "syntax_pass": true}, {"attribute_expression": "Node<K, V> lastReturnedNode;", "docstring": " The last node returned by the iterator.", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "Node<K, V>", "name": "lastReturnedNode", "syntax_pass": true}, {"attribute_expression": "private Node<K, V> nextNode;", "docstring": " The next node to be returned by the iterator.", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Node<K, V>", "name": "nextNode", "syntax_pass": true}, {"attribute_expression": "private Node<K, V> previousNode;", "docstring": " The previous node in the sequence returned by the iterator.", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Node<K, V>", "name": "previousNode", "syntax_pass": true}, {"attribute_expression": "private int expectedModifications;", "docstring": " The modification count.", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "expectedModifications", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        AbstractViewIterator(final DataElement orderType) {\n            this.orderType = orderType;\n            expectedModifications = modifications;\n            nextNode = leastNode(rootNode[orderType.ordinal()], orderType);\n            lastReturnedNode = null;\n            previousNode = null;\n        }", "docstring": "\nConstructs a new instance.\n@param orderType  the KEY or VALUE int for the order\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "AbstractViewIterator", "params": [{"name": "orderType", "type": "DataElement"}], "body": "                                                          {\n            this.orderType = orderType;\n            expectedModifications = modifications;\n            nextNode = leastNode(rootNode[orderType.ordinal()], orderType);\n            lastReturnedNode = null;\n            previousNode = null;\n        }", "signature": "AbstractViewIterator(final DataElement orderType)"}, {"syntax_pass": true, "original_string": "        public final boolean hasNext() {\n            return nextNode != null;\n        }", "docstring": "", "attributes": {"modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasNext", "params": [], "body": "                                       {\n            return nextNode != null;\n        }", "signature": "public final boolean hasNext()"}, {"syntax_pass": true, "original_string": "        public boolean hasPrevious() {\n            return previousNode != null;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasPrevious", "params": [], "body": "                                     {\n            return previousNode != null;\n        }", "signature": "public boolean hasPrevious()"}, {"syntax_pass": true, "original_string": "        protected Node<K, V> navigateNext() {\n            if (nextNode == null) {\n                throw new NoSuchElementException();\n            }\n            if (modifications != expectedModifications) {\n                throw new ConcurrentModificationException();\n            }\n            lastReturnedNode = nextNode;\n            previousNode = nextNode;\n            nextNode = nextGreater(nextNode, orderType);\n            return lastReturnedNode;\n        }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Node<K, V>", "classes": []}, "name": "navigateNext", "params": [], "body": "                                            {\n            if (nextNode == null) {\n                throw new NoSuchElementException();\n            }\n            if (modifications != expectedModifications) {\n                throw new ConcurrentModificationException();\n            }\n            lastReturnedNode = nextNode;\n            previousNode = nextNode;\n            nextNode = nextGreater(nextNode, orderType);\n            return lastReturnedNode;\n        }", "signature": "protected Node<K, V> navigateNext()"}, {"syntax_pass": true, "original_string": "        protected Node<K, V> navigatePrevious() {\n            if (previousNode == null) {\n                throw new NoSuchElementException();\n            }\n            if (modifications != expectedModifications) {\n                throw new ConcurrentModificationException();\n            }\n            nextNode = lastReturnedNode;\n            if (nextNode == null) {\n                nextNode = nextGreater(previousNode, orderType);\n            }\n            lastReturnedNode = previousNode;\n            previousNode = nextSmaller(previousNode, orderType);\n            return lastReturnedNode;\n        }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Node<K, V>", "classes": []}, "name": "navigatePrevious", "params": [], "body": "                                                {\n            if (previousNode == null) {\n                throw new NoSuchElementException();\n            }\n            if (modifications != expectedModifications) {\n                throw new ConcurrentModificationException();\n            }\n            nextNode = lastReturnedNode;\n            if (nextNode == null) {\n                nextNode = nextGreater(previousNode, orderType);\n            }\n            lastReturnedNode = previousNode;\n            previousNode = nextSmaller(previousNode, orderType);\n            return lastReturnedNode;\n        }", "signature": "protected Node<K, V> navigatePrevious()"}, {"syntax_pass": true, "original_string": "        public final void remove() {\n            if (lastReturnedNode == null) {\n                throw new IllegalStateException();\n            }\n            if (modifications != expectedModifications) {\n                throw new ConcurrentModificationException();\n            }\n            doRedBlackDelete(lastReturnedNode);\n            expectedModifications++;\n            lastReturnedNode = null;\n            if (nextNode == null) {\n                previousNode = greatestNode(rootNode[orderType.ordinal()], orderType);\n            } else {\n                previousNode = nextSmaller(nextNode, orderType);\n            }\n        }", "docstring": "", "attributes": {"modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "remove", "params": [], "body": "                                   {\n            if (lastReturnedNode == null) {\n                throw new IllegalStateException();\n            }\n            if (modifications != expectedModifications) {\n                throw new ConcurrentModificationException();\n            }\n            doRedBlackDelete(lastReturnedNode);\n            expectedModifications++;\n            lastReturnedNode = null;\n            if (nextNode == null) {\n                previousNode = greatestNode(rootNode[orderType.ordinal()], orderType);\n            } else {\n                previousNode = nextSmaller(nextNode, orderType);\n            }\n        }", "signature": "public final void remove()"}]}, {"original_string": "    final class EntryView extends AbstractView<Map.Entry<K, V>> {\n\n        EntryView() {\n            super(KEY);\n        }\n\n        @Override\n        public boolean contains(final Object obj) {\n            if (!(obj instanceof Map.Entry)) {\n                return false;\n            }\n            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n            final Object value = entry.getValue();\n            final Node<K, V> node = lookupKey(entry.getKey());\n            return node != null && node.getValue().equals(value);\n        }\n\n        @Override\n        public Iterator<Map.Entry<K, V>> iterator() {\n            return new ViewMapEntryIterator();\n        }\n\n        @Override\n        public boolean remove(final Object obj) {\n            if (!(obj instanceof Map.Entry)) {\n                return false;\n            }\n            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n            final Object value = entry.getValue();\n            final Node<K, V> node = lookupKey(entry.getKey());\n            if (node != null && node.getValue().equals(value)) {\n                doRedBlackDelete(node);\n                return true;\n            }\n            return false;\n        }\n    }", "definition": "    final class EntryView extends AbstractView<Map.Entry<K, V>>", "class_docstring": "\nA view of this map.\n", "name": "EntryView", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        EntryView() {\n            super(KEY);\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "EntryView", "params": [], "body": "                    {\n            super(KEY);\n        }", "signature": "EntryView()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean contains(final Object obj) {\n            if (!(obj instanceof Map.Entry)) {\n                return false;\n            }\n            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n            final Object value = entry.getValue();\n            final Node<K, V> node = lookupKey(entry.getKey());\n            return node != null && node.getValue().equals(value);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "contains", "params": [{"name": "obj", "type": "Object"}], "body": "                                                  {\n            if (!(obj instanceof Map.Entry)) {\n                return false;\n            }\n            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n            final Object value = entry.getValue();\n            final Node<K, V> node = lookupKey(entry.getKey());\n            return node != null && node.getValue().equals(value);\n        }", "signature": "@Override\n        public boolean contains(final Object obj)"}, {"syntax_pass": true, "original_string": "        @Override\n        public Iterator<Map.Entry<K, V>> iterator() {\n            return new ViewMapEntryIterator();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Iterator<Map.Entry<K, V>>", "classes": []}, "name": "iterator", "params": [], "body": "                                                    {\n            return new ViewMapEntryIterator();\n        }", "signature": "@Override\n        public Iterator<Map.Entry<K, V>> iterator()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean remove(final Object obj) {\n            if (!(obj instanceof Map.Entry)) {\n                return false;\n            }\n            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n            final Object value = entry.getValue();\n            final Node<K, V> node = lookupKey(entry.getKey());\n            if (node != null && node.getValue().equals(value)) {\n                doRedBlackDelete(node);\n                return true;\n            }\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "remove", "params": [{"name": "obj", "type": "Object"}], "body": "                                                {\n            if (!(obj instanceof Map.Entry)) {\n                return false;\n            }\n            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n            final Object value = entry.getValue();\n            final Node<K, V> node = lookupKey(entry.getKey());\n            if (node != null && node.getValue().equals(value)) {\n                doRedBlackDelete(node);\n                return true;\n            }\n            return false;\n        }", "signature": "@Override\n        public boolean remove(final Object obj)"}]}, {"original_string": "    final class Inverse implements OrderedBidiMap<V, K> {\n\n        /** Store the keySet once created. */\n        private Set<V> inverseKeySet;\n        /** Store the valuesSet once created. */\n        private Set<K> inverseValuesSet;\n        /** Store the entrySet once created. */\n        private Set<Map.Entry<V, K>> inverseEntrySet;\n\n        @Override\n        public void clear() {\n            TreeBidiMap.this.clear();\n        }\n\n        @Override\n        public boolean containsKey(final Object key) {\n            return TreeBidiMap.this.containsValue(key);\n        }\n\n        @Override\n        public boolean containsValue(final Object value) {\n            return TreeBidiMap.this.containsKey(value);\n        }\n\n        @Override\n        public Set<Map.Entry<V, K>> entrySet() {\n            if (inverseEntrySet == null) {\n                inverseEntrySet = new InverseEntryView();\n            }\n            return inverseEntrySet;\n        }\n\n        @Override\n        public boolean equals(final Object obj) {\n            return TreeBidiMap.this.doEquals(obj, VALUE);\n        }\n\n        @Override\n        public V firstKey() {\n            if (TreeBidiMap.this.nodeCount == 0) {\n                throw new NoSuchElementException(\"Map is empty\");\n            }\n            return leastNode(TreeBidiMap.this.rootNode[VALUE.ordinal()], VALUE).getValue();\n        }\n\n        @Override\n        public K get(final Object key) {\n            return TreeBidiMap.this.getKey(key);\n        }\n\n        @Override\n        public V getKey(final Object value) {\n            return TreeBidiMap.this.get(value);\n        }\n\n        @Override\n        public int hashCode() {\n            return TreeBidiMap.this.doHashCode(VALUE);\n        }\n\n        @Override\n        public OrderedBidiMap<K, V> inverseBidiMap() {\n            return TreeBidiMap.this;\n        }\n\n        @Override\n        public boolean isEmpty() {\n            return TreeBidiMap.this.isEmpty();\n        }\n\n        @Override\n        public Set<V> keySet() {\n            if (inverseKeySet == null) {\n                inverseKeySet = new ValueView(VALUE);\n            }\n            return inverseKeySet;\n        }\n\n        @Override\n        public V lastKey() {\n            if (TreeBidiMap.this.nodeCount == 0) {\n                throw new NoSuchElementException(\"Map is empty\");\n            }\n            return greatestNode(TreeBidiMap.this.rootNode[VALUE.ordinal()], VALUE).getValue();\n        }\n\n        @Override\n        public OrderedMapIterator<V, K> mapIterator() {\n            if (isEmpty()) {\n                return EmptyOrderedMapIterator.<V, K>emptyOrderedMapIterator();\n            }\n            return new InverseViewMapIterator(VALUE);\n        }\n\n        @Override\n        public V nextKey(final V key) {\n            checkKey(key);\n            final Node<K, V> node = nextGreater(TreeBidiMap.this.<V>lookup(key, VALUE), VALUE);\n            return node == null ? null : node.getValue();\n        }\n\n        @Override\n        public V previousKey(final V key) {\n            checkKey(key);\n            final Node<K, V> node = TreeBidiMap.this.nextSmaller(TreeBidiMap.this.<V>lookup(key, VALUE), VALUE);\n            return node == null ? null : node.getValue();\n        }\n\n        @Override\n        public K put(final V key, final K value) {\n            final K result = get(key);\n            TreeBidiMap.this.doPut(value, key);\n            return result;\n        }\n\n        @Override\n        public void putAll(final Map<? extends V, ? extends K> map) {\n            for (final Map.Entry<? extends V, ? extends K> e : map.entrySet()) {\n                put(e.getKey(), e.getValue());\n            }\n        }\n\n        @Override\n        public K remove(final Object key) {\n            return TreeBidiMap.this.removeValue(key);\n        }\n\n        @Override\n        public V removeValue(final Object value) {\n            return TreeBidiMap.this.remove(value);\n        }\n\n        @Override\n        public int size() {\n            return TreeBidiMap.this.size();\n        }\n\n        @Override\n        public String toString() {\n            return TreeBidiMap.this.doToString(VALUE);\n        }\n\n        @Override\n        public Set<K> values() {\n            if (inverseValuesSet == null) {\n                inverseValuesSet = new KeyView(VALUE);\n            }\n            return inverseValuesSet;\n        }\n    }", "definition": "    final class Inverse implements OrderedBidiMap<V, K>", "class_docstring": "\nThe inverse map implementation.\n", "name": "Inverse", "super_interfaces": ["OrderedBidiMap<V, K>"], "superclasses": "", "attributes": {"modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "fields": [{"attribute_expression": "private Set<V> inverseKeySet;", "docstring": " Store the keySet once created.", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Set<V>", "name": "inverseKeySet", "syntax_pass": true}, {"attribute_expression": "private Set<K> inverseValuesSet;", "docstring": " Store the valuesSet once created.", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Set<K>", "name": "inverseValuesSet", "syntax_pass": true}, {"attribute_expression": "private Set<Map.Entry<V, K>> inverseEntrySet;", "docstring": " Store the entrySet once created.", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Set<Map.Entry<V, K>>", "name": "inverseEntrySet", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @Override\n        public void clear() {\n            TreeBidiMap.this.clear();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "clear", "params": [], "body": "                            {\n            TreeBidiMap.this.clear();\n        }", "signature": "@Override\n        public void clear()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean containsKey(final Object key) {\n            return TreeBidiMap.this.containsValue(key);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "containsKey", "params": [{"name": "key", "type": "Object"}], "body": "                                                     {\n            return TreeBidiMap.this.containsValue(key);\n        }", "signature": "@Override\n        public boolean containsKey(final Object key)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean containsValue(final Object value) {\n            return TreeBidiMap.this.containsKey(value);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "containsValue", "params": [{"name": "value", "type": "Object"}], "body": "                                                         {\n            return TreeBidiMap.this.containsKey(value);\n        }", "signature": "@Override\n        public boolean containsValue(final Object value)"}, {"syntax_pass": true, "original_string": "        @Override\n        public Set<Map.Entry<V, K>> entrySet() {\n            if (inverseEntrySet == null) {\n                inverseEntrySet = new InverseEntryView();\n            }\n            return inverseEntrySet;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Set<Map.Entry<V, K>>", "classes": []}, "name": "entrySet", "params": [], "body": "                                               {\n            if (inverseEntrySet == null) {\n                inverseEntrySet = new InverseEntryView();\n            }\n            return inverseEntrySet;\n        }", "signature": "@Override\n        public Set<Map.Entry<V, K>> entrySet()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean equals(final Object obj) {\n            return TreeBidiMap.this.doEquals(obj, VALUE);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "obj", "type": "Object"}], "body": "                                                {\n            return TreeBidiMap.this.doEquals(obj, VALUE);\n        }", "signature": "@Override\n        public boolean equals(final Object obj)"}, {"syntax_pass": true, "original_string": "        @Override\n        public V firstKey() {\n            if (TreeBidiMap.this.nodeCount == 0) {\n                throw new NoSuchElementException(\"Map is empty\");\n            }\n            return leastNode(TreeBidiMap.this.rootNode[VALUE.ordinal()], VALUE).getValue();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "firstKey", "params": [], "body": "                            {\n            if (TreeBidiMap.this.nodeCount == 0) {\n                throw new NoSuchElementException(\"Map is empty\");\n            }\n            return leastNode(TreeBidiMap.this.rootNode[VALUE.ordinal()], VALUE).getValue();\n        }", "signature": "@Override\n        public V firstKey()"}, {"syntax_pass": true, "original_string": "        @Override\n        public K get(final Object key) {\n            return TreeBidiMap.this.getKey(key);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "K", "classes": []}, "name": "get", "params": [{"name": "key", "type": "Object"}], "body": "                                       {\n            return TreeBidiMap.this.getKey(key);\n        }", "signature": "@Override\n        public K get(final Object key)"}, {"syntax_pass": true, "original_string": "        @Override\n        public V getKey(final Object value) {\n            return TreeBidiMap.this.get(value);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "getKey", "params": [{"name": "value", "type": "Object"}], "body": "                                            {\n            return TreeBidiMap.this.get(value);\n        }", "signature": "@Override\n        public V getKey(final Object value)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int hashCode() {\n            return TreeBidiMap.this.doHashCode(VALUE);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                              {\n            return TreeBidiMap.this.doHashCode(VALUE);\n        }", "signature": "@Override\n        public int hashCode()"}, {"syntax_pass": true, "original_string": "        @Override\n        public OrderedBidiMap<K, V> inverseBidiMap() {\n            return TreeBidiMap.this;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "OrderedBidiMap<K, V>", "classes": []}, "name": "inverseBidiMap", "params": [], "body": "                                                     {\n            return TreeBidiMap.this;\n        }", "signature": "@Override\n        public OrderedBidiMap<K, V> inverseBidiMap()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isEmpty() {\n            return TreeBidiMap.this.isEmpty();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isEmpty", "params": [], "body": "                                 {\n            return TreeBidiMap.this.isEmpty();\n        }", "signature": "@Override\n        public boolean isEmpty()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Set<V> keySet() {\n            if (inverseKeySet == null) {\n                inverseKeySet = new ValueView(VALUE);\n            }\n            return inverseKeySet;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Set<V>", "classes": []}, "name": "keySet", "params": [], "body": "                               {\n            if (inverseKeySet == null) {\n                inverseKeySet = new ValueView(VALUE);\n            }\n            return inverseKeySet;\n        }", "signature": "@Override\n        public Set<V> keySet()"}, {"syntax_pass": true, "original_string": "        @Override\n        public V lastKey() {\n            if (TreeBidiMap.this.nodeCount == 0) {\n                throw new NoSuchElementException(\"Map is empty\");\n            }\n            return greatestNode(TreeBidiMap.this.rootNode[VALUE.ordinal()], VALUE).getValue();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "lastKey", "params": [], "body": "                           {\n            if (TreeBidiMap.this.nodeCount == 0) {\n                throw new NoSuchElementException(\"Map is empty\");\n            }\n            return greatestNode(TreeBidiMap.this.rootNode[VALUE.ordinal()], VALUE).getValue();\n        }", "signature": "@Override\n        public V lastKey()"}, {"syntax_pass": true, "original_string": "        @Override\n        public OrderedMapIterator<V, K> mapIterator() {\n            if (isEmpty()) {\n                return EmptyOrderedMapIterator.<V, K>emptyOrderedMapIterator();\n            }\n            return new InverseViewMapIterator(VALUE);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "OrderedMapIterator<V, K>", "classes": []}, "name": "mapIterator", "params": [], "body": "                                                      {\n            if (isEmpty()) {\n                return EmptyOrderedMapIterator.<V, K>emptyOrderedMapIterator();\n            }\n            return new InverseViewMapIterator(VALUE);\n        }", "signature": "@Override\n        public OrderedMapIterator<V, K> mapIterator()"}, {"syntax_pass": true, "original_string": "        @Override\n        public V nextKey(final V key) {\n            checkKey(key);\n            final Node<K, V> node = nextGreater(TreeBidiMap.this.<V>lookup(key, VALUE), VALUE);\n            return node == null ? null : node.getValue();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "nextKey", "params": [{"name": "key", "type": "V"}], "body": "                                      {\n            checkKey(key);\n            final Node<K, V> node = nextGreater(TreeBidiMap.this.<V>lookup(key, VALUE), VALUE);\n            return node == null ? null : node.getValue();\n        }", "signature": "@Override\n        public V nextKey(final V key)"}, {"syntax_pass": true, "original_string": "        @Override\n        public V previousKey(final V key) {\n            checkKey(key);\n            final Node<K, V> node = TreeBidiMap.this.nextSmaller(TreeBidiMap.this.<V>lookup(key, VALUE), VALUE);\n            return node == null ? null : node.getValue();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "previousKey", "params": [{"name": "key", "type": "V"}], "body": "                                          {\n            checkKey(key);\n            final Node<K, V> node = TreeBidiMap.this.nextSmaller(TreeBidiMap.this.<V>lookup(key, VALUE), VALUE);\n            return node == null ? null : node.getValue();\n        }", "signature": "@Override\n        public V previousKey(final V key)"}, {"syntax_pass": true, "original_string": "        @Override\n        public K put(final V key, final K value) {\n            final K result = get(key);\n            TreeBidiMap.this.doPut(value, key);\n            return result;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "K", "classes": []}, "name": "put", "params": [{"name": "key", "type": "V"}, {"name": "value", "type": "K"}], "body": "                                                 {\n            final K result = get(key);\n            TreeBidiMap.this.doPut(value, key);\n            return result;\n        }", "signature": "@Override\n        public K put(final V key, final K value)"}, {"syntax_pass": true, "original_string": "        @Override\n        public void putAll(final Map<? extends V, ? extends K> map) {\n            for (final Map.Entry<? extends V, ? extends K> e : map.entrySet()) {\n                put(e.getKey(), e.getValue());\n            }\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "putAll", "params": [{"name": "map", "type": "Map<? extends V, ? extends K>"}], "body": "                                                                    {\n            for (final Map.Entry<? extends V, ? extends K> e : map.entrySet()) {\n                put(e.getKey(), e.getValue());\n            }\n        }", "signature": "@Override\n        public void putAll(final Map<? extends V, ? extends K> map)"}, {"syntax_pass": true, "original_string": "        @Override\n        public K remove(final Object key) {\n            return TreeBidiMap.this.removeValue(key);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "K", "classes": []}, "name": "remove", "params": [{"name": "key", "type": "Object"}], "body": "                                          {\n            return TreeBidiMap.this.removeValue(key);\n        }", "signature": "@Override\n        public K remove(final Object key)"}, {"syntax_pass": true, "original_string": "        @Override\n        public V removeValue(final Object value) {\n            return TreeBidiMap.this.remove(value);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "removeValue", "params": [{"name": "value", "type": "Object"}], "body": "                                                 {\n            return TreeBidiMap.this.remove(value);\n        }", "signature": "@Override\n        public V removeValue(final Object value)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int size() {\n            return TreeBidiMap.this.size();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "size", "params": [], "body": "                          {\n            return TreeBidiMap.this.size();\n        }", "signature": "@Override\n        public int size()"}, {"syntax_pass": true, "original_string": "        @Override\n        public String toString() {\n            return TreeBidiMap.this.doToString(VALUE);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                 {\n            return TreeBidiMap.this.doToString(VALUE);\n        }", "signature": "@Override\n        public String toString()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Set<K> values() {\n            if (inverseValuesSet == null) {\n                inverseValuesSet = new KeyView(VALUE);\n            }\n            return inverseValuesSet;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Set<K>", "classes": []}, "name": "values", "params": [], "body": "                               {\n            if (inverseValuesSet == null) {\n                inverseValuesSet = new KeyView(VALUE);\n            }\n            return inverseValuesSet;\n        }", "signature": "@Override\n        public Set<K> values()"}]}, {"original_string": "    final class InverseEntryView extends AbstractView<Map.Entry<V, K>> {\n\n        InverseEntryView() {\n            super(VALUE);\n        }\n\n        @Override\n        public boolean contains(final Object obj) {\n            if (!(obj instanceof Map.Entry)) {\n                return false;\n            }\n            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n            final Object value = entry.getValue();\n            final Node<K, V> node = lookupValue(entry.getKey());\n            return node != null && node.getKey().equals(value);\n        }\n\n        @Override\n        public Iterator<Map.Entry<V, K>> iterator() {\n            return new InverseViewMapEntryIterator();\n        }\n\n        @Override\n        public boolean remove(final Object obj) {\n            if (!(obj instanceof Map.Entry)) {\n                return false;\n            }\n            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n            final Object value = entry.getValue();\n            final Node<K, V> node = lookupValue(entry.getKey());\n            if (node != null && node.getKey().equals(value)) {\n                doRedBlackDelete(node);\n                return true;\n            }\n            return false;\n        }\n    }", "definition": "    final class InverseEntryView extends AbstractView<Map.Entry<V, K>>", "class_docstring": "\nA view of this map.\n", "name": "InverseEntryView", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        InverseEntryView() {\n            super(VALUE);\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "InverseEntryView", "params": [], "body": "                           {\n            super(VALUE);\n        }", "signature": "InverseEntryView()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean contains(final Object obj) {\n            if (!(obj instanceof Map.Entry)) {\n                return false;\n            }\n            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n            final Object value = entry.getValue();\n            final Node<K, V> node = lookupValue(entry.getKey());\n            return node != null && node.getKey().equals(value);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "contains", "params": [{"name": "obj", "type": "Object"}], "body": "                                                  {\n            if (!(obj instanceof Map.Entry)) {\n                return false;\n            }\n            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n            final Object value = entry.getValue();\n            final Node<K, V> node = lookupValue(entry.getKey());\n            return node != null && node.getKey().equals(value);\n        }", "signature": "@Override\n        public boolean contains(final Object obj)"}, {"syntax_pass": true, "original_string": "        @Override\n        public Iterator<Map.Entry<V, K>> iterator() {\n            return new InverseViewMapEntryIterator();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Iterator<Map.Entry<V, K>>", "classes": []}, "name": "iterator", "params": [], "body": "                                                    {\n            return new InverseViewMapEntryIterator();\n        }", "signature": "@Override\n        public Iterator<Map.Entry<V, K>> iterator()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean remove(final Object obj) {\n            if (!(obj instanceof Map.Entry)) {\n                return false;\n            }\n            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n            final Object value = entry.getValue();\n            final Node<K, V> node = lookupValue(entry.getKey());\n            if (node != null && node.getKey().equals(value)) {\n                doRedBlackDelete(node);\n                return true;\n            }\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "remove", "params": [{"name": "obj", "type": "Object"}], "body": "                                                {\n            if (!(obj instanceof Map.Entry)) {\n                return false;\n            }\n            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n            final Object value = entry.getValue();\n            final Node<K, V> node = lookupValue(entry.getKey());\n            if (node != null && node.getKey().equals(value)) {\n                doRedBlackDelete(node);\n                return true;\n            }\n            return false;\n        }", "signature": "@Override\n        public boolean remove(final Object obj)"}]}, {"original_string": "    final class InverseViewMapEntryIterator extends AbstractViewIterator implements OrderedIterator<Map.Entry<V, K>> {\n\n        /**\n         * Constructs a new instance.\n         */\n        InverseViewMapEntryIterator() {\n            super(VALUE);\n        }\n\n        private Map.Entry<V, K> createEntry(final Node<K, V> node) {\n            return new UnmodifiableMapEntry<>(node.getValue(), node.getKey());\n        }\n\n        @Override\n        public Map.Entry<V, K> next() {\n            return createEntry(navigateNext());\n        }\n\n        @Override\n        public Map.Entry<V, K> previous() {\n            return createEntry(navigatePrevious());\n        }\n    }", "definition": "    final class InverseViewMapEntryIterator extends AbstractViewIterator implements OrderedIterator<Map.Entry<V, K>>", "class_docstring": "\nAn iterator over the inverse map entries.\n", "name": "InverseViewMapEntryIterator", "super_interfaces": ["OrderedIterator<Map.Entry<V, K>>"], "superclasses": "AbstractViewIterator", "attributes": {"modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        InverseViewMapEntryIterator() {\n            super(VALUE);\n        }", "docstring": "\nConstructs a new instance.\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "InverseViewMapEntryIterator", "params": [], "body": "                                      {\n            super(VALUE);\n        }", "signature": "InverseViewMapEntryIterator()"}, {"syntax_pass": true, "original_string": "        private Map.Entry<V, K> createEntry(final Node<K, V> node) {\n            return new UnmodifiableMapEntry<>(node.getValue(), node.getKey());\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Map.Entry<V, K>", "classes": []}, "name": "createEntry", "params": [{"name": "node", "type": "Node<K, V>"}], "body": "                                                                   {\n            return new UnmodifiableMapEntry<>(node.getValue(), node.getKey());\n        }", "signature": "private Map.Entry<V, K> createEntry(final Node<K, V> node)"}, {"syntax_pass": true, "original_string": "        @Override\n        public Map.Entry<V, K> next() {\n            return createEntry(navigateNext());\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map.Entry<V, K>", "classes": []}, "name": "next", "params": [], "body": "                                      {\n            return createEntry(navigateNext());\n        }", "signature": "@Override\n        public Map.Entry<V, K> next()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Map.Entry<V, K> previous() {\n            return createEntry(navigatePrevious());\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map.Entry<V, K>", "classes": []}, "name": "previous", "params": [], "body": "                                          {\n            return createEntry(navigatePrevious());\n        }", "signature": "@Override\n        public Map.Entry<V, K> previous()"}]}, {"original_string": "    final class InverseViewMapIterator extends AbstractViewIterator implements OrderedMapIterator<V, K> {\n\n        /**\n         * Creates a new TreeBidiMap.InverseViewMapIterator.\n         */\n        InverseViewMapIterator(final DataElement orderType) {\n            super(orderType);\n        }\n\n        @Override\n        public V getKey() {\n            if (lastReturnedNode == null) {\n                throw new IllegalStateException(\n                        \"Iterator getKey() can only be called after next() and before remove()\");\n            }\n            return lastReturnedNode.getValue();\n        }\n\n        @Override\n        public K getValue() {\n            if (lastReturnedNode == null) {\n                throw new IllegalStateException(\n                        \"Iterator getValue() can only be called after next() and before remove()\");\n            }\n            return lastReturnedNode.getKey();\n        }\n\n        @Override\n        public V next() {\n            return navigateNext().getValue();\n        }\n\n        @Override\n        public V previous() {\n            return navigatePrevious().getValue();\n        }\n\n        @Override\n        public K setValue(final K value) {\n            throw new UnsupportedOperationException();\n        }\n    }", "definition": "    final class InverseViewMapIterator extends AbstractViewIterator implements OrderedMapIterator<V, K>", "class_docstring": "\nAn iterator over the map.\n", "name": "InverseViewMapIterator", "super_interfaces": ["OrderedMapIterator<V, K>"], "superclasses": "AbstractViewIterator", "attributes": {"modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        InverseViewMapIterator(final DataElement orderType) {\n            super(orderType);\n        }", "docstring": "\nCreates a new TreeBidiMap.InverseViewMapIterator.\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "InverseViewMapIterator", "params": [{"name": "orderType", "type": "DataElement"}], "body": "                                                            {\n            super(orderType);\n        }", "signature": "InverseViewMapIterator(final DataElement orderType)"}, {"syntax_pass": true, "original_string": "        @Override\n        public V getKey() {\n            if (lastReturnedNode == null) {\n                throw new IllegalStateException(\n                        \"Iterator getKey() can only be called after next() and before remove()\");\n            }\n            return lastReturnedNode.getValue();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "getKey", "params": [], "body": "                          {\n            if (lastReturnedNode == null) {\n                throw new IllegalStateException(\n                        \"Iterator getKey() can only be called after next() and before remove()\");\n            }\n            return lastReturnedNode.getValue();\n        }", "signature": "@Override\n        public V getKey()"}, {"syntax_pass": true, "original_string": "        @Override\n        public K getValue() {\n            if (lastReturnedNode == null) {\n                throw new IllegalStateException(\n                        \"Iterator getValue() can only be called after next() and before remove()\");\n            }\n            return lastReturnedNode.getKey();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "K", "classes": []}, "name": "getValue", "params": [], "body": "                            {\n            if (lastReturnedNode == null) {\n                throw new IllegalStateException(\n                        \"Iterator getValue() can only be called after next() and before remove()\");\n            }\n            return lastReturnedNode.getKey();\n        }", "signature": "@Override\n        public K getValue()"}, {"syntax_pass": true, "original_string": "        @Override\n        public V next() {\n            return navigateNext().getValue();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "next", "params": [], "body": "                        {\n            return navigateNext().getValue();\n        }", "signature": "@Override\n        public V next()"}, {"syntax_pass": true, "original_string": "        @Override\n        public V previous() {\n            return navigatePrevious().getValue();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "previous", "params": [], "body": "                            {\n            return navigatePrevious().getValue();\n        }", "signature": "@Override\n        public V previous()"}, {"syntax_pass": true, "original_string": "        @Override\n        public K setValue(final K value) {\n            throw new UnsupportedOperationException();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "K", "classes": []}, "name": "setValue", "params": [{"name": "value", "type": "K"}], "body": "                                         {\n            throw new UnsupportedOperationException();\n        }", "signature": "@Override\n        public K setValue(final K value)"}]}, {"original_string": "    final class KeyView extends AbstractView<K> {\n\n        /**\n         * Creates a new TreeBidiMap.KeyView.\n         */\n        KeyView(final DataElement orderType) {\n            super(orderType);\n        }\n\n        @Override\n        public boolean contains(final Object obj) {\n            checkNonNullComparable(obj, KEY);\n            return lookupKey(obj) != null;\n        }\n\n        @Override\n        public Iterator<K> iterator() {\n            return new ViewMapIterator(orderType);\n        }\n\n        @Override\n        public boolean remove(final Object o) {\n            return doRemoveKey(o) != null;\n        }\n\n    }", "definition": "    final class KeyView extends AbstractView<K>", "class_docstring": "", "name": "KeyView", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        KeyView(final DataElement orderType) {\n            super(orderType);\n        }", "docstring": "\nCreates a new TreeBidiMap.KeyView.\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "KeyView", "params": [{"name": "orderType", "type": "DataElement"}], "body": "                                             {\n            super(orderType);\n        }", "signature": "KeyView(final DataElement orderType)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean contains(final Object obj) {\n            checkNonNullComparable(obj, KEY);\n            return lookupKey(obj) != null;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "contains", "params": [{"name": "obj", "type": "Object"}], "body": "                                                  {\n            checkNonNullComparable(obj, KEY);\n            return lookupKey(obj) != null;\n        }", "signature": "@Override\n        public boolean contains(final Object obj)"}, {"syntax_pass": true, "original_string": "        @Override\n        public Iterator<K> iterator() {\n            return new ViewMapIterator(orderType);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Iterator<K>", "classes": []}, "name": "iterator", "params": [], "body": "                                      {\n            return new ViewMapIterator(orderType);\n        }", "signature": "@Override\n        public Iterator<K> iterator()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean remove(final Object o) {\n            return doRemoveKey(o) != null;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "remove", "params": [{"name": "o", "type": "Object"}], "body": "                                              {\n            return doRemoveKey(o) != null;\n        }", "signature": "@Override\n        public boolean remove(final Object o)"}]}, {"original_string": "    static class Node<K extends Comparable<K>, V extends Comparable<V>> implements Map.Entry<K, V>, KeyValue<K, V> {\n\n        private final K key;\n        private final V value;\n        private final Node<K, V>[] leftNode;\n        private final Node<K, V>[] rightNode;\n        private final Node<K, V>[] parentNode;\n        private final boolean[] blackColor;\n        private int hashCodeValue;\n        private boolean calculatedHashCode;\n\n        /**\n         * Makes a new cell with given key and value, and with null\n         * links, and black (true) colors.\n         *\n         * @param key the key of this node\n         * @param value the value of this node\n         */\n        @SuppressWarnings(\"unchecked\")\n        Node(final K key, final V value) {\n            this.key = key;\n            this.value = value;\n            leftNode = new Node[2];\n            rightNode = new Node[2];\n            parentNode = new Node[2];\n            blackColor = new boolean[] { true, true };\n            calculatedHashCode = false;\n        }\n\n        /**\n         * Makes this node the same color as another.\n         *\n         * @param node  the node whose color we're adopting\n         * @param dataElement  either the {@link DataElement#KEY key}\n         *                     or the {@link DataElement#VALUE value}.\n         */\n        private void copyColor(final Node<K, V> node, final DataElement dataElement) {\n            blackColor[dataElement.ordinal()] = node.blackColor[dataElement.ordinal()];\n        }\n\n        /**\n         * Compares the specified object with this entry for equality.\n         * Returns true if the given object is also a map entry and\n         * the two entries represent the same mapping.\n         *\n         * @param obj  the object to be compared for equality with this entry.\n         * @return true if the specified object is equal to this entry.\n         */\n        @Override\n        public boolean equals(final Object obj) {\n            if (obj == this) {\n                return true;\n            }\n            if (!(obj instanceof Map.Entry)) {\n                return false;\n            }\n            final Map.Entry<?, ?> e = (Map.Entry<?, ?>) obj;\n            return getKey().equals(e.getKey()) && getValue().equals(e.getValue());\n        }\n\n        private Object getData(final DataElement dataElement) {\n            switch (dataElement) {\n            case KEY:\n                return getKey();\n            case VALUE:\n                return getValue();\n            default:\n                throw new IllegalArgumentException();\n            }\n        }\n\n        /**\n         * Gets the key.\n         *\n         * @return the key corresponding to this entry.\n         */\n        @Override\n        public K getKey() {\n            return key;\n        }\n\n        private Node<K, V> getLeft(final DataElement dataElement) {\n            return leftNode[dataElement.ordinal()];\n        }\n\n        /**\n         * Gets the parent node.\n         *\n         * @param dataElement  either the {@link DataElement#KEY key}\n         *                     or the {@link DataElement#VALUE value}.\n         * @return the parent node, may be null\n         */\n        private Node<K, V> getParent(final DataElement dataElement) {\n            return parentNode[dataElement.ordinal()];\n        }\n\n        private Node<K, V> getRight(final DataElement dataElement) {\n            return rightNode[dataElement.ordinal()];\n        }\n\n        /**\n         * Gets the value.\n         *\n         * @return the value corresponding to this entry.\n         */\n        @Override\n        public V getValue() {\n            return value;\n        }\n\n        /**\n         * @return the hash code value for this map entry.\n         */\n        @Override\n        public int hashCode() {\n            if (!calculatedHashCode) {\n                hashCodeValue = getKey().hashCode() ^ getValue().hashCode();\n                calculatedHashCode = true;\n            }\n            return hashCodeValue;\n        }\n\n        /**\n         * Is this node black?\n         *\n         * @param dataElement  either the {@link DataElement#KEY key}\n         *                     or the {@link DataElement#VALUE value}.\n         * @return true if black (which is represented as a true boolean)\n         */\n        private boolean isBlack(final DataElement dataElement) {\n            return blackColor[dataElement.ordinal()];\n        }\n\n        private boolean isLeftChild(final DataElement dataElement) {\n            return parentNode[dataElement.ordinal()] != null\n                    && parentNode[dataElement.ordinal()].leftNode[dataElement.ordinal()] == this;\n        }\n\n        /**\n         * Is this node red?\n         *\n         * @param dataElement  either the {@link DataElement#KEY key}\n         *                     or the {@link DataElement#VALUE value}.\n         * @return true if non-black\n         */\n        private boolean isRed(final DataElement dataElement) {\n            return !blackColor[dataElement.ordinal()];\n        }\n\n        private boolean isRightChild(final DataElement dataElement) {\n            return parentNode[dataElement.ordinal()] != null\n                    && parentNode[dataElement.ordinal()].rightNode[dataElement.ordinal()] == this;\n        }\n\n        /**\n         * Makes this node black.\n         *\n         * @param dataElement  either the {@link DataElement#KEY key}\n         *                     or the {@link DataElement#VALUE value}.\n         */\n        private void setBlack(final DataElement dataElement) {\n            blackColor[dataElement.ordinal()] = true;\n        }\n\n        private void setLeft(final Node<K, V> node, final DataElement dataElement) {\n            leftNode[dataElement.ordinal()] = node;\n        }\n\n        /**\n         * Sets this node's parent node.\n         *\n         * @param node  the new parent node\n         * @param dataElement  either the {@link DataElement#KEY key}\n         *                     or the {@link DataElement#VALUE value}.\n         */\n        private void setParent(final Node<K, V> node, final DataElement dataElement) {\n            parentNode[dataElement.ordinal()] = node;\n        }\n\n        /**\n         * Makes this node red.\n         *\n         * @param dataElement  either the {@link DataElement#KEY key}\n         *                     or the {@link DataElement#VALUE value}.\n         */\n        private void setRed(final DataElement dataElement) {\n            blackColor[dataElement.ordinal()] = false;\n        }\n\n        private void setRight(final Node<K, V> node, final DataElement dataElement) {\n            rightNode[dataElement.ordinal()] = node;\n        }\n\n        /**\n         * Optional operation that is not permitted in this implementation.\n         *\n         * @param ignored this parameter is ignored.\n         * @return does not return\n         * @throws UnsupportedOperationException always\n         */\n        @Override\n        public V setValue(final V ignored) throws UnsupportedOperationException {\n            throw new UnsupportedOperationException(\"Map.Entry.setValue is not supported\");\n        }\n\n        /**\n         * Exchanges colors with another node.\n         *\n         * @param node  the node to swap with\n         * @param dataElement  either the {@link DataElement#KEY key}\n         *                     or the {@link DataElement#VALUE value}.\n         */\n        private void swapColors(final Node<K, V> node, final DataElement dataElement) {\n            // Swap colors -- old hacker's trick\n            blackColor[dataElement.ordinal()]      ^= node.blackColor[dataElement.ordinal()];\n            node.blackColor[dataElement.ordinal()] ^= blackColor[dataElement.ordinal()];\n            blackColor[dataElement.ordinal()]      ^= node.blackColor[dataElement.ordinal()];\n        }\n    }", "definition": "    static class Node<K extends Comparable<K>, V extends Comparable<V>> implements Map.Entry<K, V>, KeyValue<K, V>", "class_docstring": "\nA node used to store the data.\n", "name": "Node", "super_interfaces": ["Map.Entry<K, V>", "KeyValue<K, V>"], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "private final K key;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "K", "name": "key", "syntax_pass": true}, {"attribute_expression": "private final V value;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "V", "name": "value", "syntax_pass": true}, {"attribute_expression": "private final Node<K, V>[] leftNode;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Node<K, V>[]", "name": "leftNode", "syntax_pass": true}, {"attribute_expression": "private final Node<K, V>[] rightNode;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Node<K, V>[]", "name": "rightNode", "syntax_pass": true}, {"attribute_expression": "private final Node<K, V>[] parentNode;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Node<K, V>[]", "name": "parentNode", "syntax_pass": true}, {"attribute_expression": "private final boolean[] blackColor;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "boolean[]", "name": "blackColor", "syntax_pass": true}, {"attribute_expression": "private int hashCodeValue;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "hashCodeValue", "syntax_pass": true}, {"attribute_expression": "private boolean calculatedHashCode;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "calculatedHashCode", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @SuppressWarnings(\"unchecked\")\n        Node(final K key, final V value) {\n            this.key = key;\n            this.value = value;\n            leftNode = new Node[2];\n            rightNode = new Node[2];\n            parentNode = new Node[2];\n            blackColor = new boolean[] { true, true };\n            calculatedHashCode = false;\n        }", "docstring": "\nMakes a new cell with given key and value, and with null\nlinks, and black (true) colors.\n\n@param key the key of this node\n@param value the value of this node\n", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")"], "comments": [], "return_type": "", "classes": []}, "name": "Node", "params": [{"name": "key", "type": "K"}, {"name": "value", "type": "V"}], "body": "                                         {\n            this.key = key;\n            this.value = value;\n            leftNode = new Node[2];\n            rightNode = new Node[2];\n            parentNode = new Node[2];\n            blackColor = new boolean[] { true, true };\n            calculatedHashCode = false;\n        }", "signature": "@SuppressWarnings(\"unchecked\")\n        Node(final K key, final V value)"}, {"syntax_pass": true, "original_string": "        private void copyColor(final Node<K, V> node, final DataElement dataElement) {\n            blackColor[dataElement.ordinal()] = node.blackColor[dataElement.ordinal()];\n        }", "docstring": "\nMakes this node the same color as another.\n\n@param node  the node whose color we're adopting\n@param dataElement  either the {@link DataElement#KEY key}\n                    or the {@link DataElement#VALUE value}.\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "copyColor", "params": [{"name": "node", "type": "Node<K, V>"}, {"name": "dataElement", "type": "DataElement"}], "body": "                                                                                     {\n            blackColor[dataElement.ordinal()] = node.blackColor[dataElement.ordinal()];\n        }", "signature": "private void copyColor(final Node<K, V> node, final DataElement dataElement)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean equals(final Object obj) {\n            if (obj == this) {\n                return true;\n            }\n            if (!(obj instanceof Map.Entry)) {\n                return false;\n            }\n            final Map.Entry<?, ?> e = (Map.Entry<?, ?>) obj;\n            return getKey().equals(e.getKey()) && getValue().equals(e.getValue());\n        }", "docstring": "\nCompares the specified object with this entry for equality.\nReturns true if the given object is also a map entry and\nthe two entries represent the same mapping.\n\n@param obj  the object to be compared for equality with this entry.\n@return true if the specified object is equal to this entry.\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "obj", "type": "Object"}], "body": "                                                {\n            if (obj == this) {\n                return true;\n            }\n            if (!(obj instanceof Map.Entry)) {\n                return false;\n            }\n            final Map.Entry<?, ?> e = (Map.Entry<?, ?>) obj;\n            return getKey().equals(e.getKey()) && getValue().equals(e.getValue());\n        }", "signature": "@Override\n        public boolean equals(final Object obj)"}, {"syntax_pass": true, "original_string": "        private Object getData(final DataElement dataElement) {\n            switch (dataElement) {\n            case KEY:\n                return getKey();\n            case VALUE:\n                return getValue();\n            default:\n                throw new IllegalArgumentException();\n            }\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Object", "classes": []}, "name": "getData", "params": [{"name": "dataElement", "type": "DataElement"}], "body": "                                                              {\n            switch (dataElement) {\n            case KEY:\n                return getKey();\n            case VALUE:\n                return getValue();\n            default:\n                throw new IllegalArgumentException();\n            }\n        }", "signature": "private Object getData(final DataElement dataElement)"}, {"syntax_pass": true, "original_string": "        @Override\n        public K getKey() {\n            return key;\n        }", "docstring": "\nGets the key.\n\n@return the key corresponding to this entry.\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "K", "classes": []}, "name": "getKey", "params": [], "body": "                          {\n            return key;\n        }", "signature": "@Override\n        public K getKey()"}, {"syntax_pass": true, "original_string": "        private Node<K, V> getLeft(final DataElement dataElement) {\n            return leftNode[dataElement.ordinal()];\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Node<K, V>", "classes": []}, "name": "getLeft", "params": [{"name": "dataElement", "type": "DataElement"}], "body": "                                                                  {\n            return leftNode[dataElement.ordinal()];\n        }", "signature": "private Node<K, V> getLeft(final DataElement dataElement)"}, {"syntax_pass": true, "original_string": "        private Node<K, V> getParent(final DataElement dataElement) {\n            return parentNode[dataElement.ordinal()];\n        }", "docstring": "\nGets the parent node.\n\n@param dataElement  either the {@link DataElement#KEY key}\n                    or the {@link DataElement#VALUE value}.\n@return the parent node, may be null\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Node<K, V>", "classes": []}, "name": "getParent", "params": [{"name": "dataElement", "type": "DataElement"}], "body": "                                                                    {\n            return parentNode[dataElement.ordinal()];\n        }", "signature": "private Node<K, V> getParent(final DataElement dataElement)"}, {"syntax_pass": true, "original_string": "        private Node<K, V> getRight(final DataElement dataElement) {\n            return rightNode[dataElement.ordinal()];\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Node<K, V>", "classes": []}, "name": "getRight", "params": [{"name": "dataElement", "type": "DataElement"}], "body": "                                                                   {\n            return rightNode[dataElement.ordinal()];\n        }", "signature": "private Node<K, V> getRight(final DataElement dataElement)"}, {"syntax_pass": true, "original_string": "        @Override\n        public V getValue() {\n            return value;\n        }", "docstring": "\nGets the value.\n\n@return the value corresponding to this entry.\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "getValue", "params": [], "body": "                            {\n            return value;\n        }", "signature": "@Override\n        public V getValue()"}, {"syntax_pass": true, "original_string": "        @Override\n        public int hashCode() {\n            if (!calculatedHashCode) {\n                hashCodeValue = getKey().hashCode() ^ getValue().hashCode();\n                calculatedHashCode = true;\n            }\n            return hashCodeValue;\n        }", "docstring": "\n@return the hash code value for this map entry.\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                              {\n            if (!calculatedHashCode) {\n                hashCodeValue = getKey().hashCode() ^ getValue().hashCode();\n                calculatedHashCode = true;\n            }\n            return hashCodeValue;\n        }", "signature": "@Override\n        public int hashCode()"}, {"syntax_pass": true, "original_string": "        private boolean isBlack(final DataElement dataElement) {\n            return blackColor[dataElement.ordinal()];\n        }", "docstring": "\nIs this node black?\n\n@param dataElement  either the {@link DataElement#KEY key}\n                    or the {@link DataElement#VALUE value}.\n@return true if black (which is represented as a true boolean)\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isBlack", "params": [{"name": "dataElement", "type": "DataElement"}], "body": "                                                               {\n            return blackColor[dataElement.ordinal()];\n        }", "signature": "private boolean isBlack(final DataElement dataElement)"}, {"syntax_pass": true, "original_string": "        private boolean isLeftChild(final DataElement dataElement) {\n            return parentNode[dataElement.ordinal()] != null\n                    && parentNode[dataElement.ordinal()].leftNode[dataElement.ordinal()] == this;\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isLeftChild", "params": [{"name": "dataElement", "type": "DataElement"}], "body": "                                                                   {\n            return parentNode[dataElement.ordinal()] != null\n                    && parentNode[dataElement.ordinal()].leftNode[dataElement.ordinal()] == this;\n        }", "signature": "private boolean isLeftChild(final DataElement dataElement)"}, {"syntax_pass": true, "original_string": "        private boolean isRed(final DataElement dataElement) {\n            return !blackColor[dataElement.ordinal()];\n        }", "docstring": "\nIs this node red?\n\n@param dataElement  either the {@link DataElement#KEY key}\n                    or the {@link DataElement#VALUE value}.\n@return true if non-black\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isRed", "params": [{"name": "dataElement", "type": "DataElement"}], "body": "                                                             {\n            return !blackColor[dataElement.ordinal()];\n        }", "signature": "private boolean isRed(final DataElement dataElement)"}, {"syntax_pass": true, "original_string": "        private boolean isRightChild(final DataElement dataElement) {\n            return parentNode[dataElement.ordinal()] != null\n                    && parentNode[dataElement.ordinal()].rightNode[dataElement.ordinal()] == this;\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isRightChild", "params": [{"name": "dataElement", "type": "DataElement"}], "body": "                                                                    {\n            return parentNode[dataElement.ordinal()] != null\n                    && parentNode[dataElement.ordinal()].rightNode[dataElement.ordinal()] == this;\n        }", "signature": "private boolean isRightChild(final DataElement dataElement)"}, {"syntax_pass": true, "original_string": "        private void setBlack(final DataElement dataElement) {\n            blackColor[dataElement.ordinal()] = true;\n        }", "docstring": "\nMakes this node black.\n\n@param dataElement  either the {@link DataElement#KEY key}\n                    or the {@link DataElement#VALUE value}.\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "setBlack", "params": [{"name": "dataElement", "type": "DataElement"}], "body": "                                                             {\n            blackColor[dataElement.ordinal()] = true;\n        }", "signature": "private void setBlack(final DataElement dataElement)"}, {"syntax_pass": true, "original_string": "        private void setLeft(final Node<K, V> node, final DataElement dataElement) {\n            leftNode[dataElement.ordinal()] = node;\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "setLeft", "params": [{"name": "node", "type": "Node<K, V>"}, {"name": "dataElement", "type": "DataElement"}], "body": "                                                                                   {\n            leftNode[dataElement.ordinal()] = node;\n        }", "signature": "private void setLeft(final Node<K, V> node, final DataElement dataElement)"}, {"syntax_pass": true, "original_string": "        private void setParent(final Node<K, V> node, final DataElement dataElement) {\n            parentNode[dataElement.ordinal()] = node;\n        }", "docstring": "\nSets this node's parent node.\n\n@param node  the new parent node\n@param dataElement  either the {@link DataElement#KEY key}\n                    or the {@link DataElement#VALUE value}.\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "setParent", "params": [{"name": "node", "type": "Node<K, V>"}, {"name": "dataElement", "type": "DataElement"}], "body": "                                                                                     {\n            parentNode[dataElement.ordinal()] = node;\n        }", "signature": "private void setParent(final Node<K, V> node, final DataElement dataElement)"}, {"syntax_pass": true, "original_string": "        private void setRed(final DataElement dataElement) {\n            blackColor[dataElement.ordinal()] = false;\n        }", "docstring": "\nMakes this node red.\n\n@param dataElement  either the {@link DataElement#KEY key}\n                    or the {@link DataElement#VALUE value}.\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "setRed", "params": [{"name": "dataElement", "type": "DataElement"}], "body": "                                                           {\n            blackColor[dataElement.ordinal()] = false;\n        }", "signature": "private void setRed(final DataElement dataElement)"}, {"syntax_pass": true, "original_string": "        private void setRight(final Node<K, V> node, final DataElement dataElement) {\n            rightNode[dataElement.ordinal()] = node;\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "setRight", "params": [{"name": "node", "type": "Node<K, V>"}, {"name": "dataElement", "type": "DataElement"}], "body": "                                                                                    {\n            rightNode[dataElement.ordinal()] = node;\n        }", "signature": "private void setRight(final Node<K, V> node, final DataElement dataElement)"}, {"syntax_pass": true, "original_string": "        @Override\n        public V setValue(final V ignored) throws UnsupportedOperationException {\n            throw new UnsupportedOperationException(\"Map.Entry.setValue is not supported\");\n        }", "docstring": "\nOptional operation that is not permitted in this implementation.\n\n@param ignored this parameter is ignored.\n@return does not return\n@throws UnsupportedOperationException always\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "setValue", "params": [{"name": "ignored", "type": "V"}], "body": "                                                                                {\n            throw new UnsupportedOperationException(\"Map.Entry.setValue is not supported\");\n        }", "signature": "@Override\n        public V setValue(final V ignored)"}, {"syntax_pass": true, "original_string": "        private void swapColors(final Node<K, V> node, final DataElement dataElement) {\n            // Swap colors -- old hacker's trick\n            blackColor[dataElement.ordinal()]      ^= node.blackColor[dataElement.ordinal()];\n            node.blackColor[dataElement.ordinal()] ^= blackColor[dataElement.ordinal()];\n            blackColor[dataElement.ordinal()]      ^= node.blackColor[dataElement.ordinal()];\n        }", "docstring": "\nExchanges colors with another node.\n\n@param node  the node to swap with\n@param dataElement  either the {@link DataElement#KEY key}\n                    or the {@link DataElement#VALUE value}.\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "swapColors", "params": [{"name": "node", "type": "Node<K, V>"}, {"name": "dataElement", "type": "DataElement"}], "body": "                                                                                      {\n            // Swap colors -- old hacker's trick\n            blackColor[dataElement.ordinal()]      ^= node.blackColor[dataElement.ordinal()];\n            node.blackColor[dataElement.ordinal()] ^= blackColor[dataElement.ordinal()];\n            blackColor[dataElement.ordinal()]      ^= node.blackColor[dataElement.ordinal()];\n        }", "signature": "private void swapColors(final Node<K, V> node, final DataElement dataElement)"}]}, {"original_string": "    final class ValueView extends AbstractView<V> {\n\n        /**\n         * Creates a new TreeBidiMap.ValueView.\n         */\n        ValueView(final DataElement orderType) {\n            super(orderType);\n        }\n\n        @Override\n        public boolean contains(final Object obj) {\n            checkNonNullComparable(obj, VALUE);\n            return lookupValue(obj) != null;\n        }\n\n        @Override\n        public Iterator<V> iterator() {\n            return new InverseViewMapIterator(orderType);\n        }\n\n        @Override\n        public boolean remove(final Object o) {\n            return doRemoveValue(o) != null;\n        }\n\n    }", "definition": "    final class ValueView extends AbstractView<V>", "class_docstring": "", "name": "ValueView", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        ValueView(final DataElement orderType) {\n            super(orderType);\n        }", "docstring": "\nCreates a new TreeBidiMap.ValueView.\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "ValueView", "params": [{"name": "orderType", "type": "DataElement"}], "body": "                                               {\n            super(orderType);\n        }", "signature": "ValueView(final DataElement orderType)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean contains(final Object obj) {\n            checkNonNullComparable(obj, VALUE);\n            return lookupValue(obj) != null;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "contains", "params": [{"name": "obj", "type": "Object"}], "body": "                                                  {\n            checkNonNullComparable(obj, VALUE);\n            return lookupValue(obj) != null;\n        }", "signature": "@Override\n        public boolean contains(final Object obj)"}, {"syntax_pass": true, "original_string": "        @Override\n        public Iterator<V> iterator() {\n            return new InverseViewMapIterator(orderType);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Iterator<V>", "classes": []}, "name": "iterator", "params": [], "body": "                                      {\n            return new InverseViewMapIterator(orderType);\n        }", "signature": "@Override\n        public Iterator<V> iterator()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean remove(final Object o) {\n            return doRemoveValue(o) != null;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "remove", "params": [{"name": "o", "type": "Object"}], "body": "                                              {\n            return doRemoveValue(o) != null;\n        }", "signature": "@Override\n        public boolean remove(final Object o)"}]}, {"original_string": "    final class ViewMapEntryIterator extends AbstractViewIterator implements OrderedIterator<Map.Entry<K, V>> {\n\n        /**\n         * Constructs a new instance.\n         */\n        ViewMapEntryIterator() {\n            super(KEY);\n        }\n\n        @Override\n        public Map.Entry<K, V> next() {\n            return navigateNext();\n        }\n\n        @Override\n        public Map.Entry<K, V> previous() {\n            return navigatePrevious();\n        }\n    }", "definition": "    final class ViewMapEntryIterator extends AbstractViewIterator implements OrderedIterator<Map.Entry<K, V>>", "class_docstring": "\nAn iterator over the map entries.\n", "name": "ViewMapEntryIterator", "super_interfaces": ["OrderedIterator<Map.Entry<K, V>>"], "superclasses": "AbstractViewIterator", "attributes": {"modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        ViewMapEntryIterator() {\n            super(KEY);\n        }", "docstring": "\nConstructs a new instance.\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "ViewMapEntryIterator", "params": [], "body": "                               {\n            super(KEY);\n        }", "signature": "ViewMapEntryIterator()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Map.Entry<K, V> next() {\n            return navigateNext();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map.Entry<K, V>", "classes": []}, "name": "next", "params": [], "body": "                                      {\n            return navigateNext();\n        }", "signature": "@Override\n        public Map.Entry<K, V> next()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Map.Entry<K, V> previous() {\n            return navigatePrevious();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map.Entry<K, V>", "classes": []}, "name": "previous", "params": [], "body": "                                          {\n            return navigatePrevious();\n        }", "signature": "@Override\n        public Map.Entry<K, V> previous()"}]}, {"original_string": "    final class ViewMapIterator extends AbstractViewIterator implements OrderedMapIterator<K, V> {\n\n        /**\n         * Constructs a new instance.\n         */\n        ViewMapIterator(final DataElement orderType) {\n            super(orderType);\n        }\n\n        @Override\n        public K getKey() {\n            if (lastReturnedNode == null) {\n                throw new IllegalStateException(\n                        \"Iterator getKey() can only be called after next() and before remove()\");\n            }\n            return lastReturnedNode.getKey();\n        }\n\n        @Override\n        public V getValue() {\n            if (lastReturnedNode == null) {\n                throw new IllegalStateException(\n                        \"Iterator getValue() can only be called after next() and before remove()\");\n            }\n            return lastReturnedNode.getValue();\n        }\n\n        @Override\n        public K next() {\n            return navigateNext().getKey();\n        }\n\n        @Override\n        public K previous() {\n            return navigatePrevious().getKey();\n        }\n\n        @Override\n        public V setValue(final V value) {\n            throw new UnsupportedOperationException();\n        }\n    }", "definition": "    final class ViewMapIterator extends AbstractViewIterator implements OrderedMapIterator<K, V>", "class_docstring": "\nAn iterator over the map.\n", "name": "ViewMapIterator", "super_interfaces": ["OrderedMapIterator<K, V>"], "superclasses": "AbstractViewIterator", "attributes": {"modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        ViewMapIterator(final DataElement orderType) {\n            super(orderType);\n        }", "docstring": "\nConstructs a new instance.\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "ViewMapIterator", "params": [{"name": "orderType", "type": "DataElement"}], "body": "                                                     {\n            super(orderType);\n        }", "signature": "ViewMapIterator(final DataElement orderType)"}, {"syntax_pass": true, "original_string": "        @Override\n        public K getKey() {\n            if (lastReturnedNode == null) {\n                throw new IllegalStateException(\n                        \"Iterator getKey() can only be called after next() and before remove()\");\n            }\n            return lastReturnedNode.getKey();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "K", "classes": []}, "name": "getKey", "params": [], "body": "                          {\n            if (lastReturnedNode == null) {\n                throw new IllegalStateException(\n                        \"Iterator getKey() can only be called after next() and before remove()\");\n            }\n            return lastReturnedNode.getKey();\n        }", "signature": "@Override\n        public K getKey()"}, {"syntax_pass": true, "original_string": "        @Override\n        public V getValue() {\n            if (lastReturnedNode == null) {\n                throw new IllegalStateException(\n                        \"Iterator getValue() can only be called after next() and before remove()\");\n            }\n            return lastReturnedNode.getValue();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "getValue", "params": [], "body": "                            {\n            if (lastReturnedNode == null) {\n                throw new IllegalStateException(\n                        \"Iterator getValue() can only be called after next() and before remove()\");\n            }\n            return lastReturnedNode.getValue();\n        }", "signature": "@Override\n        public V getValue()"}, {"syntax_pass": true, "original_string": "        @Override\n        public K next() {\n            return navigateNext().getKey();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "K", "classes": []}, "name": "next", "params": [], "body": "                        {\n            return navigateNext().getKey();\n        }", "signature": "@Override\n        public K next()"}, {"syntax_pass": true, "original_string": "        @Override\n        public K previous() {\n            return navigatePrevious().getKey();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "K", "classes": []}, "name": "previous", "params": [], "body": "                            {\n            return navigatePrevious().getKey();\n        }", "signature": "@Override\n        public K previous()"}, {"syntax_pass": true, "original_string": "        @Override\n        public V setValue(final V value) {\n            throw new UnsupportedOperationException();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "setValue", "params": [{"name": "value", "type": "V"}], "body": "                                         {\n            throw new UnsupportedOperationException();\n        }", "signature": "@Override\n        public V setValue(final V value)"}]}], "class_docstring": "\nRed-Black tree-based implementation of BidiMap where all objects added\nimplement the {@code Comparable} interface.\n<p>\nThis class guarantees that the map will be in both ascending key order\nand ascending value order, sorted according to the natural order for\nthe key's and value's classes.\n</p>\n<p>\nThis Map is intended for applications that need to be able to look\nup a key-value pairing by either key or value, and need to do so\nwith equal efficiency.\n</p>\n<p>\nWhile that goal could be accomplished by taking a pair of TreeMaps\nand redirecting requests to the appropriate TreeMap (e.g.,\ncontainsKey would be directed to the TreeMap that maps values to\nkeys, containsValue would be directed to the TreeMap that maps keys\nto values), there are problems with that implementation.\nIf the data contained in the TreeMaps is large, the cost of redundant\nstorage becomes significant. The {@link DualTreeBidiMap} and\n{@link DualHashBidiMap} implementations use this approach.\n</p>\n<p>\nThis solution keeps minimizes the data storage by holding data only once.\nThe red-black algorithm is based on {@link java.util.TreeMap}, but has been modified\nto simultaneously map a tree node by key and by value. This doubles the\ncost of put operations (but so does using two TreeMaps), and nearly doubles\nthe cost of remove operations (there is a savings in that the lookup of the\nnode to be removed only has to be performed once). And since only one node\ncontains the key and value, storage is significantly less than that\nrequired by two TreeMaps.\n</p>\n<p>\nThe Map.Entry instances returned by the appropriate methods will\nnot allow setValue() and will throw an\nUnsupportedOperationException on attempts to call that method.\n</p>\n\n@param <K> the type of the keys in this map\n@param <V> the type of the values in this map\n\n@since 3.0 (previously DoubleOrderedMap v2.0)\n", "original_string": "public class TreeBidiMap<K extends Comparable<K>, V extends Comparable<V>>\n    implements OrderedBidiMap<K, V>, Serializable {\n\n    /**\n     * A view of this map.\n     */\n    abstract class AbstractView<E> extends AbstractSet<E> {\n\n        /** Whether to return KEY or VALUE order. */\n        final DataElement orderType;\n\n        /**\n         * Constructs a new instance.\n         * @param orderType  the KEY or VALUE int for the order\n         */\n        AbstractView(final DataElement orderType) {\n            this.orderType = orderType;\n        }\n\n        @Override\n        public void clear() {\n            TreeBidiMap.this.clear();\n        }\n\n        @Override\n        public int size() {\n            return TreeBidiMap.this.size();\n        }\n    }\n\n    /**\n     * An iterator over the map.\n     */\n    abstract class AbstractViewIterator {\n\n        /** Whether to return KEY or VALUE order. */\n        private final DataElement orderType;\n        /** The last node returned by the iterator. */\n        Node<K, V> lastReturnedNode;\n        /** The next node to be returned by the iterator. */\n        private Node<K, V> nextNode;\n        /** The previous node in the sequence returned by the iterator. */\n        private Node<K, V> previousNode;\n        /** The modification count. */\n        private int expectedModifications;\n\n        /**\n         * Constructs a new instance.\n         * @param orderType  the KEY or VALUE int for the order\n         */\n        AbstractViewIterator(final DataElement orderType) {\n            this.orderType = orderType;\n            expectedModifications = modifications;\n            nextNode = leastNode(rootNode[orderType.ordinal()], orderType);\n            lastReturnedNode = null;\n            previousNode = null;\n        }\n\n        public final boolean hasNext() {\n            return nextNode != null;\n        }\n\n        public boolean hasPrevious() {\n            return previousNode != null;\n        }\n\n        protected Node<K, V> navigateNext() {\n            if (nextNode == null) {\n                throw new NoSuchElementException();\n            }\n            if (modifications != expectedModifications) {\n                throw new ConcurrentModificationException();\n            }\n            lastReturnedNode = nextNode;\n            previousNode = nextNode;\n            nextNode = nextGreater(nextNode, orderType);\n            return lastReturnedNode;\n        }\n\n        protected Node<K, V> navigatePrevious() {\n            if (previousNode == null) {\n                throw new NoSuchElementException();\n            }\n            if (modifications != expectedModifications) {\n                throw new ConcurrentModificationException();\n            }\n            nextNode = lastReturnedNode;\n            if (nextNode == null) {\n                nextNode = nextGreater(previousNode, orderType);\n            }\n            lastReturnedNode = previousNode;\n            previousNode = nextSmaller(previousNode, orderType);\n            return lastReturnedNode;\n        }\n\n        public final void remove() {\n            if (lastReturnedNode == null) {\n                throw new IllegalStateException();\n            }\n            if (modifications != expectedModifications) {\n                throw new ConcurrentModificationException();\n            }\n            doRedBlackDelete(lastReturnedNode);\n            expectedModifications++;\n            lastReturnedNode = null;\n            if (nextNode == null) {\n                previousNode = greatestNode(rootNode[orderType.ordinal()], orderType);\n            } else {\n                previousNode = nextSmaller(nextNode, orderType);\n            }\n        }\n    }\n\n    enum DataElement {\n        KEY(\"key\"), VALUE(\"value\");\n\n        private final String description;\n\n        /**\n         * Creates a new TreeBidiMap.DataElement.\n         *\n         * @param description  the description for the element\n         */\n        DataElement(final String description) {\n            this.description = description;\n        }\n\n        @Override\n        public String toString() {\n            return description;\n        }\n    }\n    /**\n     * A view of this map.\n     */\n    final class EntryView extends AbstractView<Map.Entry<K, V>> {\n\n        EntryView() {\n            super(KEY);\n        }\n\n        @Override\n        public boolean contains(final Object obj) {\n            if (!(obj instanceof Map.Entry)) {\n                return false;\n            }\n            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n            final Object value = entry.getValue();\n            final Node<K, V> node = lookupKey(entry.getKey());\n            return node != null && node.getValue().equals(value);\n        }\n\n        @Override\n        public Iterator<Map.Entry<K, V>> iterator() {\n            return new ViewMapEntryIterator();\n        }\n\n        @Override\n        public boolean remove(final Object obj) {\n            if (!(obj instanceof Map.Entry)) {\n                return false;\n            }\n            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n            final Object value = entry.getValue();\n            final Node<K, V> node = lookupKey(entry.getKey());\n            if (node != null && node.getValue().equals(value)) {\n                doRedBlackDelete(node);\n                return true;\n            }\n            return false;\n        }\n    }\n    /**\n     * The inverse map implementation.\n     */\n    final class Inverse implements OrderedBidiMap<V, K> {\n\n        /** Store the keySet once created. */\n        private Set<V> inverseKeySet;\n        /** Store the valuesSet once created. */\n        private Set<K> inverseValuesSet;\n        /** Store the entrySet once created. */\n        private Set<Map.Entry<V, K>> inverseEntrySet;\n\n        @Override\n        public void clear() {\n            TreeBidiMap.this.clear();\n        }\n\n        @Override\n        public boolean containsKey(final Object key) {\n            return TreeBidiMap.this.containsValue(key);\n        }\n\n        @Override\n        public boolean containsValue(final Object value) {\n            return TreeBidiMap.this.containsKey(value);\n        }\n\n        @Override\n        public Set<Map.Entry<V, K>> entrySet() {\n            if (inverseEntrySet == null) {\n                inverseEntrySet = new InverseEntryView();\n            }\n            return inverseEntrySet;\n        }\n\n        @Override\n        public boolean equals(final Object obj) {\n            return TreeBidiMap.this.doEquals(obj, VALUE);\n        }\n\n        @Override\n        public V firstKey() {\n            if (TreeBidiMap.this.nodeCount == 0) {\n                throw new NoSuchElementException(\"Map is empty\");\n            }\n            return leastNode(TreeBidiMap.this.rootNode[VALUE.ordinal()], VALUE).getValue();\n        }\n\n        @Override\n        public K get(final Object key) {\n            return TreeBidiMap.this.getKey(key);\n        }\n\n        @Override\n        public V getKey(final Object value) {\n            return TreeBidiMap.this.get(value);\n        }\n\n        @Override\n        public int hashCode() {\n            return TreeBidiMap.this.doHashCode(VALUE);\n        }\n\n        @Override\n        public OrderedBidiMap<K, V> inverseBidiMap() {\n            return TreeBidiMap.this;\n        }\n\n        @Override\n        public boolean isEmpty() {\n            return TreeBidiMap.this.isEmpty();\n        }\n\n        @Override\n        public Set<V> keySet() {\n            if (inverseKeySet == null) {\n                inverseKeySet = new ValueView(VALUE);\n            }\n            return inverseKeySet;\n        }\n\n        @Override\n        public V lastKey() {\n            if (TreeBidiMap.this.nodeCount == 0) {\n                throw new NoSuchElementException(\"Map is empty\");\n            }\n            return greatestNode(TreeBidiMap.this.rootNode[VALUE.ordinal()], VALUE).getValue();\n        }\n\n        @Override\n        public OrderedMapIterator<V, K> mapIterator() {\n            if (isEmpty()) {\n                return EmptyOrderedMapIterator.<V, K>emptyOrderedMapIterator();\n            }\n            return new InverseViewMapIterator(VALUE);\n        }\n\n        @Override\n        public V nextKey(final V key) {\n            checkKey(key);\n            final Node<K, V> node = nextGreater(TreeBidiMap.this.<V>lookup(key, VALUE), VALUE);\n            return node == null ? null : node.getValue();\n        }\n\n        @Override\n        public V previousKey(final V key) {\n            checkKey(key);\n            final Node<K, V> node = TreeBidiMap.this.nextSmaller(TreeBidiMap.this.<V>lookup(key, VALUE), VALUE);\n            return node == null ? null : node.getValue();\n        }\n\n        @Override\n        public K put(final V key, final K value) {\n            final K result = get(key);\n            TreeBidiMap.this.doPut(value, key);\n            return result;\n        }\n\n        @Override\n        public void putAll(final Map<? extends V, ? extends K> map) {\n            for (final Map.Entry<? extends V, ? extends K> e : map.entrySet()) {\n                put(e.getKey(), e.getValue());\n            }\n        }\n\n        @Override\n        public K remove(final Object key) {\n            return TreeBidiMap.this.removeValue(key);\n        }\n\n        @Override\n        public V removeValue(final Object value) {\n            return TreeBidiMap.this.remove(value);\n        }\n\n        @Override\n        public int size() {\n            return TreeBidiMap.this.size();\n        }\n\n        @Override\n        public String toString() {\n            return TreeBidiMap.this.doToString(VALUE);\n        }\n\n        @Override\n        public Set<K> values() {\n            if (inverseValuesSet == null) {\n                inverseValuesSet = new KeyView(VALUE);\n            }\n            return inverseValuesSet;\n        }\n    }\n    /**\n     * A view of this map.\n     */\n    final class InverseEntryView extends AbstractView<Map.Entry<V, K>> {\n\n        InverseEntryView() {\n            super(VALUE);\n        }\n\n        @Override\n        public boolean contains(final Object obj) {\n            if (!(obj instanceof Map.Entry)) {\n                return false;\n            }\n            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n            final Object value = entry.getValue();\n            final Node<K, V> node = lookupValue(entry.getKey());\n            return node != null && node.getKey().equals(value);\n        }\n\n        @Override\n        public Iterator<Map.Entry<V, K>> iterator() {\n            return new InverseViewMapEntryIterator();\n        }\n\n        @Override\n        public boolean remove(final Object obj) {\n            if (!(obj instanceof Map.Entry)) {\n                return false;\n            }\n            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n            final Object value = entry.getValue();\n            final Node<K, V> node = lookupValue(entry.getKey());\n            if (node != null && node.getKey().equals(value)) {\n                doRedBlackDelete(node);\n                return true;\n            }\n            return false;\n        }\n    }\n    /**\n     * An iterator over the inverse map entries.\n     */\n    final class InverseViewMapEntryIterator extends AbstractViewIterator implements OrderedIterator<Map.Entry<V, K>> {\n\n        /**\n         * Constructs a new instance.\n         */\n        InverseViewMapEntryIterator() {\n            super(VALUE);\n        }\n\n        private Map.Entry<V, K> createEntry(final Node<K, V> node) {\n            return new UnmodifiableMapEntry<>(node.getValue(), node.getKey());\n        }\n\n        @Override\n        public Map.Entry<V, K> next() {\n            return createEntry(navigateNext());\n        }\n\n        @Override\n        public Map.Entry<V, K> previous() {\n            return createEntry(navigatePrevious());\n        }\n    }\n    /**\n     * An iterator over the map.\n     */\n    final class InverseViewMapIterator extends AbstractViewIterator implements OrderedMapIterator<V, K> {\n\n        /**\n         * Creates a new TreeBidiMap.InverseViewMapIterator.\n         */\n        InverseViewMapIterator(final DataElement orderType) {\n            super(orderType);\n        }\n\n        @Override\n        public V getKey() {\n            if (lastReturnedNode == null) {\n                throw new IllegalStateException(\n                        \"Iterator getKey() can only be called after next() and before remove()\");\n            }\n            return lastReturnedNode.getValue();\n        }\n\n        @Override\n        public K getValue() {\n            if (lastReturnedNode == null) {\n                throw new IllegalStateException(\n                        \"Iterator getValue() can only be called after next() and before remove()\");\n            }\n            return lastReturnedNode.getKey();\n        }\n\n        @Override\n        public V next() {\n            return navigateNext().getValue();\n        }\n\n        @Override\n        public V previous() {\n            return navigatePrevious().getValue();\n        }\n\n        @Override\n        public K setValue(final K value) {\n            throw new UnsupportedOperationException();\n        }\n    }\n    final class KeyView extends AbstractView<K> {\n\n        /**\n         * Creates a new TreeBidiMap.KeyView.\n         */\n        KeyView(final DataElement orderType) {\n            super(orderType);\n        }\n\n        @Override\n        public boolean contains(final Object obj) {\n            checkNonNullComparable(obj, KEY);\n            return lookupKey(obj) != null;\n        }\n\n        @Override\n        public Iterator<K> iterator() {\n            return new ViewMapIterator(orderType);\n        }\n\n        @Override\n        public boolean remove(final Object o) {\n            return doRemoveKey(o) != null;\n        }\n\n    }\n\n    /**\n     * A node used to store the data.\n     */\n    static class Node<K extends Comparable<K>, V extends Comparable<V>> implements Map.Entry<K, V>, KeyValue<K, V> {\n\n        private final K key;\n        private final V value;\n        private final Node<K, V>[] leftNode;\n        private final Node<K, V>[] rightNode;\n        private final Node<K, V>[] parentNode;\n        private final boolean[] blackColor;\n        private int hashCodeValue;\n        private boolean calculatedHashCode;\n\n        /**\n         * Makes a new cell with given key and value, and with null\n         * links, and black (true) colors.\n         *\n         * @param key the key of this node\n         * @param value the value of this node\n         */\n        @SuppressWarnings(\"unchecked\")\n        Node(final K key, final V value) {\n            this.key = key;\n            this.value = value;\n            leftNode = new Node[2];\n            rightNode = new Node[2];\n            parentNode = new Node[2];\n            blackColor = new boolean[] { true, true };\n            calculatedHashCode = false;\n        }\n\n        /**\n         * Makes this node the same color as another.\n         *\n         * @param node  the node whose color we're adopting\n         * @param dataElement  either the {@link DataElement#KEY key}\n         *                     or the {@link DataElement#VALUE value}.\n         */\n        private void copyColor(final Node<K, V> node, final DataElement dataElement) {\n            blackColor[dataElement.ordinal()] = node.blackColor[dataElement.ordinal()];\n        }\n\n        /**\n         * Compares the specified object with this entry for equality.\n         * Returns true if the given object is also a map entry and\n         * the two entries represent the same mapping.\n         *\n         * @param obj  the object to be compared for equality with this entry.\n         * @return true if the specified object is equal to this entry.\n         */\n        @Override\n        public boolean equals(final Object obj) {\n            if (obj == this) {\n                return true;\n            }\n            if (!(obj instanceof Map.Entry)) {\n                return false;\n            }\n            final Map.Entry<?, ?> e = (Map.Entry<?, ?>) obj;\n            return getKey().equals(e.getKey()) && getValue().equals(e.getValue());\n        }\n\n        private Object getData(final DataElement dataElement) {\n            switch (dataElement) {\n            case KEY:\n                return getKey();\n            case VALUE:\n                return getValue();\n            default:\n                throw new IllegalArgumentException();\n            }\n        }\n\n        /**\n         * Gets the key.\n         *\n         * @return the key corresponding to this entry.\n         */\n        @Override\n        public K getKey() {\n            return key;\n        }\n\n        private Node<K, V> getLeft(final DataElement dataElement) {\n            return leftNode[dataElement.ordinal()];\n        }\n\n        /**\n         * Gets the parent node.\n         *\n         * @param dataElement  either the {@link DataElement#KEY key}\n         *                     or the {@link DataElement#VALUE value}.\n         * @return the parent node, may be null\n         */\n        private Node<K, V> getParent(final DataElement dataElement) {\n            return parentNode[dataElement.ordinal()];\n        }\n\n        private Node<K, V> getRight(final DataElement dataElement) {\n            return rightNode[dataElement.ordinal()];\n        }\n\n        /**\n         * Gets the value.\n         *\n         * @return the value corresponding to this entry.\n         */\n        @Override\n        public V getValue() {\n            return value;\n        }\n\n        /**\n         * @return the hash code value for this map entry.\n         */\n        @Override\n        public int hashCode() {\n            if (!calculatedHashCode) {\n                hashCodeValue = getKey().hashCode() ^ getValue().hashCode();\n                calculatedHashCode = true;\n            }\n            return hashCodeValue;\n        }\n\n        /**\n         * Is this node black?\n         *\n         * @param dataElement  either the {@link DataElement#KEY key}\n         *                     or the {@link DataElement#VALUE value}.\n         * @return true if black (which is represented as a true boolean)\n         */\n        private boolean isBlack(final DataElement dataElement) {\n            return blackColor[dataElement.ordinal()];\n        }\n\n        private boolean isLeftChild(final DataElement dataElement) {\n            return parentNode[dataElement.ordinal()] != null\n                    && parentNode[dataElement.ordinal()].leftNode[dataElement.ordinal()] == this;\n        }\n\n        /**\n         * Is this node red?\n         *\n         * @param dataElement  either the {@link DataElement#KEY key}\n         *                     or the {@link DataElement#VALUE value}.\n         * @return true if non-black\n         */\n        private boolean isRed(final DataElement dataElement) {\n            return !blackColor[dataElement.ordinal()];\n        }\n\n        private boolean isRightChild(final DataElement dataElement) {\n            return parentNode[dataElement.ordinal()] != null\n                    && parentNode[dataElement.ordinal()].rightNode[dataElement.ordinal()] == this;\n        }\n\n        /**\n         * Makes this node black.\n         *\n         * @param dataElement  either the {@link DataElement#KEY key}\n         *                     or the {@link DataElement#VALUE value}.\n         */\n        private void setBlack(final DataElement dataElement) {\n            blackColor[dataElement.ordinal()] = true;\n        }\n\n        private void setLeft(final Node<K, V> node, final DataElement dataElement) {\n            leftNode[dataElement.ordinal()] = node;\n        }\n\n        /**\n         * Sets this node's parent node.\n         *\n         * @param node  the new parent node\n         * @param dataElement  either the {@link DataElement#KEY key}\n         *                     or the {@link DataElement#VALUE value}.\n         */\n        private void setParent(final Node<K, V> node, final DataElement dataElement) {\n            parentNode[dataElement.ordinal()] = node;\n        }\n\n        /**\n         * Makes this node red.\n         *\n         * @param dataElement  either the {@link DataElement#KEY key}\n         *                     or the {@link DataElement#VALUE value}.\n         */\n        private void setRed(final DataElement dataElement) {\n            blackColor[dataElement.ordinal()] = false;\n        }\n\n        private void setRight(final Node<K, V> node, final DataElement dataElement) {\n            rightNode[dataElement.ordinal()] = node;\n        }\n\n        /**\n         * Optional operation that is not permitted in this implementation.\n         *\n         * @param ignored this parameter is ignored.\n         * @return does not return\n         * @throws UnsupportedOperationException always\n         */\n        @Override\n        public V setValue(final V ignored) throws UnsupportedOperationException {\n            throw new UnsupportedOperationException(\"Map.Entry.setValue is not supported\");\n        }\n\n        /**\n         * Exchanges colors with another node.\n         *\n         * @param node  the node to swap with\n         * @param dataElement  either the {@link DataElement#KEY key}\n         *                     or the {@link DataElement#VALUE value}.\n         */\n        private void swapColors(final Node<K, V> node, final DataElement dataElement) {\n            // Swap colors -- old hacker's trick\n            blackColor[dataElement.ordinal()]      ^= node.blackColor[dataElement.ordinal()];\n            node.blackColor[dataElement.ordinal()] ^= blackColor[dataElement.ordinal()];\n            blackColor[dataElement.ordinal()]      ^= node.blackColor[dataElement.ordinal()];\n        }\n    }\n\n    final class ValueView extends AbstractView<V> {\n\n        /**\n         * Creates a new TreeBidiMap.ValueView.\n         */\n        ValueView(final DataElement orderType) {\n            super(orderType);\n        }\n\n        @Override\n        public boolean contains(final Object obj) {\n            checkNonNullComparable(obj, VALUE);\n            return lookupValue(obj) != null;\n        }\n\n        @Override\n        public Iterator<V> iterator() {\n            return new InverseViewMapIterator(orderType);\n        }\n\n        @Override\n        public boolean remove(final Object o) {\n            return doRemoveValue(o) != null;\n        }\n\n    }\n\n    /**\n     * An iterator over the map entries.\n     */\n    final class ViewMapEntryIterator extends AbstractViewIterator implements OrderedIterator<Map.Entry<K, V>> {\n\n        /**\n         * Constructs a new instance.\n         */\n        ViewMapEntryIterator() {\n            super(KEY);\n        }\n\n        @Override\n        public Map.Entry<K, V> next() {\n            return navigateNext();\n        }\n\n        @Override\n        public Map.Entry<K, V> previous() {\n            return navigatePrevious();\n        }\n    }\n\n    /**\n     * An iterator over the map.\n     */\n    final class ViewMapIterator extends AbstractViewIterator implements OrderedMapIterator<K, V> {\n\n        /**\n         * Constructs a new instance.\n         */\n        ViewMapIterator(final DataElement orderType) {\n            super(orderType);\n        }\n\n        @Override\n        public K getKey() {\n            if (lastReturnedNode == null) {\n                throw new IllegalStateException(\n                        \"Iterator getKey() can only be called after next() and before remove()\");\n            }\n            return lastReturnedNode.getKey();\n        }\n\n        @Override\n        public V getValue() {\n            if (lastReturnedNode == null) {\n                throw new IllegalStateException(\n                        \"Iterator getValue() can only be called after next() and before remove()\");\n            }\n            return lastReturnedNode.getValue();\n        }\n\n        @Override\n        public K next() {\n            return navigateNext().getKey();\n        }\n\n        @Override\n        public K previous() {\n            return navigatePrevious().getKey();\n        }\n\n        @Override\n        public V setValue(final V value) {\n            throw new UnsupportedOperationException();\n        }\n    }\n\n    private static final long serialVersionUID = 721969328361807L;\n\n    /**\n     * Checks a key for validity (non-null and implements Comparable)\n     *\n     * @param key the key to be checked\n     *\n     * @throws NullPointerException if key is null\n     * @throws ClassCastException if key is not Comparable\n     */\n    private static void checkKey(final Object key) {\n        checkNonNullComparable(key, KEY);\n    }\n\n    /**\n     * Checks a key and a value for validity (non-null and implements\n     * Comparable)\n     *\n     * @param key the key to be checked\n     * @param value the value to be checked\n     *\n     * @throws NullPointerException if key or value is null\n     * @throws ClassCastException if key or value is not Comparable\n     */\n    private static void checkKeyAndValue(final Object key, final Object value) {\n        checkKey(key);\n        checkValue(value);\n    }\n\n    /**\n     * Checks if an object is fit to be proper input ... has to be\n     * Comparable and non-null.\n     *\n     * @param obj the object being checked\n     * @param dataElement  either the {@link DataElement#KEY key}\n     *                     or the {@link DataElement#VALUE value}.\n     *\n     * @throws NullPointerException if o is null\n     * @throws ClassCastException if o is not Comparable\n     */\n    private static void checkNonNullComparable(final Object obj, final DataElement dataElement) {\n        Objects.requireNonNull(obj, Objects.toString(dataElement));\n        if (!(obj instanceof Comparable)) {\n            throw new ClassCastException(dataElement + \" must be Comparable\");\n        }\n    }\n\n    /**\n     * Checks a value for validity (non-null and implements Comparable)\n     *\n     * @param value the value to be checked\n     *\n     * @throws NullPointerException if value is null\n     * @throws ClassCastException if value is not Comparable\n     */\n    private static void checkValue(final Object value) {\n        checkNonNullComparable(value, VALUE);\n    }\n\n    /**\n     * Compares two objects.\n     *\n     * @param o1  the first object\n     * @param o2  the second object\n     *\n     * @return negative value if o1 &lt; o2; 0 if o1 == o2; positive\n     *         value if o1 &gt; o2\n     */\n    private static <T extends Comparable<T>> int compare(final T o1, final T o2) {\n        return o1.compareTo(o2);\n    }\n\n    /**\n     * Is the specified black red? If the node does not exist, sure,\n     * it's black, thank you.\n     *\n     * @param node the node (may be null) in question\n     * @param dataElement  either the {@link DataElement#KEY key}\n     *                     or the {@link DataElement#VALUE value}.\n     */\n    private static boolean isBlack(final Node<?, ?> node, final DataElement dataElement) {\n        return node == null || node.isBlack(dataElement);\n    }\n\n    /**\n     * Is the specified node red? If the node does not exist, no, it's\n     * black, thank you.\n     *\n     * @param node the node (may be null) in question\n     * @param dataElement  either the {@link DataElement#KEY key}\n     *                     or the {@link DataElement#VALUE value}.\n     */\n    private static boolean isRed(final Node<?, ?> node, final DataElement dataElement) {\n        return node != null && node.isRed(dataElement);\n    }\n\n    /**\n     * Forces a node (if it exists) black.\n     *\n     * @param node the node (may be null) in question\n     * @param dataElement  either the {@link DataElement#KEY key}\n     *                     or the {@link DataElement#VALUE value}.\n     */\n    private static void makeBlack(final Node<?, ?> node, final DataElement dataElement) {\n        if (node != null) {\n            node.setBlack(dataElement);\n        }\n    }\n\n    /**\n     * Forces a node (if it exists) red.\n     *\n     * @param node the node (may be null) in question\n     * @param dataElement  either the {@link DataElement#KEY key}\n     *                     or the {@link DataElement#VALUE value}.\n     */\n    private static void makeRed(final Node<?, ?> node, final DataElement dataElement) {\n        if (node != null) {\n            node.setRed(dataElement);\n        }\n    }\n\n    private transient Node<K, V>[] rootNode;\n\n    private transient int nodeCount;\n\n    private transient int modifications;\n\n    private transient Set<K> keySet;\n\n    private transient Set<V> valuesSet;\n\n    private transient Set<Map.Entry<K, V>> entrySet;\n\n    private transient Inverse inverse;\n\n    /**\n     * Constructs a new empty TreeBidiMap.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public TreeBidiMap() {\n        rootNode = new Node[2];\n    }\n\n    /**\n     * Constructs a new TreeBidiMap by copying an existing Map.\n     *\n     * @param map  the map to copy\n     * @throws ClassCastException if the keys/values in the map are\n     *  not Comparable or are not mutually comparable\n     * @throws NullPointerException if any key or value in the map is null\n     */\n    public TreeBidiMap(final Map<? extends K, ? extends V> map) {\n        this();\n        putAll(map);\n    }\n\n    /**\n     * Removes all mappings from this map.\n     */\n    @Override\n    public void clear() {\n        modify();\n\n        nodeCount = 0;\n        rootNode[KEY.ordinal()] = null;\n        rootNode[VALUE.ordinal()] = null;\n    }\n\n    /**\n     * Checks whether this map contains a mapping for the specified key.\n     * <p>\n     * The key must implement {@code Comparable}.\n     *\n     * @param key  key whose presence in this map is to be tested\n     * @return true if this map contains a mapping for the specified key\n     * @throws ClassCastException if the key is of an inappropriate type\n     * @throws NullPointerException if the key is null\n     */\n    @Override\n    public boolean containsKey(final Object key) {\n        checkKey(key);\n        return lookupKey(key) != null;\n    }\n\n    /**\n     * Checks whether this map contains a mapping for the specified value.\n     * <p>\n     * The value must implement {@code Comparable}.\n     *\n     * @param value  value whose presence in this map is to be tested\n     * @return true if this map contains a mapping for the specified value\n     * @throws ClassCastException if the value is of an inappropriate type\n     * @throws NullPointerException if the value is null\n     */\n    @Override\n    public boolean containsValue(final Object value) {\n        checkValue(value);\n        return lookupValue(value) != null;\n    }\n\n    /**\n     * Copies the color from one node to another, dealing with the fact\n     * that one or both nodes may, in fact, be null.\n     *\n     * @param from the node whose color we're copying; may be null\n     * @param to the node whose color we're changing; may be null\n     * @param dataElement  either the {@link DataElement#KEY key}\n     *                     or the {@link DataElement#VALUE value}.\n     */\n    private void copyColor(final Node<K, V> from, final Node<K, V> to, final DataElement dataElement) {\n        if (to != null) {\n            if (from == null) {\n                // by default, make it black\n                to.setBlack(dataElement);\n            } else {\n                to.copyColor(from, dataElement);\n            }\n        }\n    }\n\n    /**\n     * Compares for equals as per the API.\n     *\n     * @param obj  the object to compare to\n     * @param dataElement  either the {@link DataElement#KEY key}\n     *                     or the {@link DataElement#VALUE value}.\n     * @return true if equal\n     */\n    private boolean doEquals(final Object obj, final DataElement dataElement) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof Map)) {\n            return false;\n        }\n        final Map<?, ?> other = (Map<?, ?>) obj;\n        if (other.size() != size()) {\n            return false;\n        }\n\n        if (nodeCount > 0) {\n            try {\n                for (final MapIterator<?, ?> it = getMapIterator(dataElement); it.hasNext(); ) {\n                    final Object key = it.next();\n                    final Object value = it.getValue();\n                    if (!value.equals(other.get(key))) {\n                        return false;\n                    }\n                }\n            } catch (final ClassCastException | NullPointerException ex) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Gets the hash code value for this map as per the API.\n     *\n     * @param dataElement  either the {@link DataElement#KEY key}\n     *                     or the {@link DataElement#VALUE value}.\n     * @return the hash code value for this map\n     */\n    private int doHashCode(final DataElement dataElement) {\n        int total = 0;\n        if (nodeCount > 0) {\n            for (final MapIterator<?, ?> it = getMapIterator(dataElement); it.hasNext(); ) {\n                final Object key = it.next();\n                final Object value = it.getValue();\n                total += key.hashCode() ^ value.hashCode();\n            }\n        }\n        return total;\n    }\n\n    /**\n     * Puts logic.\n     *\n     * @param key  the key, always the main map key\n     * @param value  the value, always the main map value\n     */\n    private void doPut(final K key, final V value) {\n        checkKeyAndValue(key, value);\n\n        // store previous and remove previous mappings\n        doRemoveKey(key);\n        doRemoveValue(value);\n\n        Node<K, V> node = rootNode[KEY.ordinal()];\n        if (node == null) {\n            // map is empty\n            final Node<K, V> root = new Node<>(key, value);\n            rootNode[KEY.ordinal()] = root;\n            rootNode[VALUE.ordinal()] = root;\n            grow();\n\n        } else {\n            // add new mapping\n            while (true) {\n                final int cmp = compare(key, node.getKey());\n\n                if (cmp == 0) {\n                    // shouldn't happen\n                    throw new IllegalArgumentException(\"Cannot store a duplicate key (\\\"\" + key + \"\\\") in this Map\");\n                }\n                if (cmp < 0) {\n                    if (node.getLeft(KEY) == null) {\n                        final Node<K, V> newNode = new Node<>(key, value);\n\n                        insertValue(newNode);\n                        node.setLeft(newNode, KEY);\n                        newNode.setParent(node, KEY);\n                        doRedBlackInsert(newNode, KEY);\n                        grow();\n\n                        break;\n                    }\n                    node = node.getLeft(KEY);\n                } else { // cmp > 0\n                    if (node.getRight(KEY) == null) {\n                        final Node<K, V> newNode = new Node<>(key, value);\n\n                        insertValue(newNode);\n                        node.setRight(newNode, KEY);\n                        newNode.setParent(node, KEY);\n                        doRedBlackInsert(newNode, KEY);\n                        grow();\n\n                        break;\n                    }\n                    node = node.getRight(KEY);\n                }\n            }\n        }\n    }\n\n    /**\n     * Complicated red-black delete stuff. Based on Sun's TreeMap\n     * implementation, though it's barely recognizable anymore.\n     *\n     * @param deletedNode the node to be deleted\n     */\n    private void doRedBlackDelete(final Node<K, V> deletedNode) {\n        for (final DataElement dataElement : DataElement.values()) {\n            // if deleted node has both left and children, swap with\n            // the next greater node\n            if (deletedNode.getLeft(dataElement) != null && deletedNode.getRight(dataElement) != null) {\n                swapPosition(nextGreater(deletedNode, dataElement), deletedNode, dataElement);\n            }\n\n            final Node<K, V> replacement = deletedNode.getLeft(dataElement) != null ?\n                    deletedNode.getLeft(dataElement) : deletedNode.getRight(dataElement);\n\n            if (replacement != null) {\n                replacement.setParent(deletedNode.getParent(dataElement), dataElement);\n\n                if (deletedNode.getParent(dataElement) == null) {\n                    rootNode[dataElement.ordinal()] = replacement;\n                } else if (deletedNode == deletedNode.getParent(dataElement).getLeft(dataElement)) {\n                    deletedNode.getParent(dataElement).setLeft(replacement, dataElement);\n                } else {\n                    deletedNode.getParent(dataElement).setRight(replacement, dataElement);\n                }\n\n                deletedNode.setLeft(null, dataElement);\n                deletedNode.setRight(null, dataElement);\n                deletedNode.setParent(null, dataElement);\n\n                if (isBlack(deletedNode, dataElement)) {\n                    doRedBlackDeleteFixup(replacement, dataElement);\n                }\n            } else {\n\n                // replacement is null\n                if (deletedNode.getParent(dataElement) == null) {\n\n                    // empty tree\n                    rootNode[dataElement.ordinal()] = null;\n                } else {\n\n                    // deleted node had no children\n                    if (isBlack(deletedNode, dataElement)) {\n                        doRedBlackDeleteFixup(deletedNode, dataElement);\n                    }\n\n                    if (deletedNode.getParent(dataElement) != null) {\n                        if (deletedNode == deletedNode.getParent(dataElement).getLeft(dataElement)) {\n                            deletedNode.getParent(dataElement).setLeft(null, dataElement);\n                        } else {\n                            deletedNode.getParent(dataElement).setRight(null, dataElement);\n                        }\n\n                        deletedNode.setParent(null, dataElement);\n                    }\n                }\n            }\n        }\n        shrink();\n    }\n\n    /**\n     * Complicated red-black delete stuff. Based on Sun's TreeMap\n     * implementation, though it's barely recognizable anymore. This\n     * rebalances the tree (somewhat, as red-black trees are not\n     * perfectly balanced -- perfect balancing takes longer)\n     *\n     * @param replacementNode the node being replaced\n     * @param dataElement  the KEY or VALUE int\n     */\n    private void doRedBlackDeleteFixup(final Node<K, V> replacementNode, final DataElement dataElement) {\n        Node<K, V> currentNode = replacementNode;\n\n        while (currentNode != rootNode[dataElement.ordinal()] && isBlack(currentNode, dataElement)) {\n            if (currentNode.isLeftChild(dataElement)) {\n                Node<K, V> siblingNode = getRightChild(getParent(currentNode, dataElement), dataElement);\n\n                if (isRed(siblingNode, dataElement)) {\n                    makeBlack(siblingNode, dataElement);\n                    makeRed(getParent(currentNode, dataElement), dataElement);\n                    rotateLeft(getParent(currentNode, dataElement), dataElement);\n\n                    siblingNode = getRightChild(getParent(currentNode, dataElement), dataElement);\n                }\n\n                if (isBlack(getLeftChild(siblingNode, dataElement), dataElement)\n                    && isBlack(getRightChild(siblingNode, dataElement), dataElement)) {\n                    makeRed(siblingNode, dataElement);\n\n                    currentNode = getParent(currentNode, dataElement);\n                } else {\n                    if (isBlack(getRightChild(siblingNode, dataElement), dataElement)) {\n                        makeBlack(getLeftChild(siblingNode, dataElement), dataElement);\n                        makeRed(siblingNode, dataElement);\n                        rotateRight(siblingNode, dataElement);\n\n                        siblingNode = getRightChild(getParent(currentNode, dataElement), dataElement);\n                    }\n\n                    copyColor(getParent(currentNode, dataElement), siblingNode, dataElement);\n                    makeBlack(getParent(currentNode, dataElement), dataElement);\n                    makeBlack(getRightChild(siblingNode, dataElement), dataElement);\n                    rotateLeft(getParent(currentNode, dataElement), dataElement);\n\n                    currentNode = rootNode[dataElement.ordinal()];\n                }\n            } else {\n                Node<K, V> siblingNode = getLeftChild(getParent(currentNode, dataElement), dataElement);\n\n                if (isRed(siblingNode, dataElement)) {\n                    makeBlack(siblingNode, dataElement);\n                    makeRed(getParent(currentNode, dataElement), dataElement);\n                    rotateRight(getParent(currentNode, dataElement), dataElement);\n\n                    siblingNode = getLeftChild(getParent(currentNode, dataElement), dataElement);\n                }\n\n                if (isBlack(getRightChild(siblingNode, dataElement), dataElement)\n                    && isBlack(getLeftChild(siblingNode, dataElement), dataElement)) {\n                    makeRed(siblingNode, dataElement);\n\n                    currentNode = getParent(currentNode, dataElement);\n                } else {\n                    if (isBlack(getLeftChild(siblingNode, dataElement), dataElement)) {\n                        makeBlack(getRightChild(siblingNode, dataElement), dataElement);\n                        makeRed(siblingNode, dataElement);\n                        rotateLeft(siblingNode, dataElement);\n\n                        siblingNode = getLeftChild(getParent(currentNode, dataElement), dataElement);\n                    }\n\n                    copyColor(getParent(currentNode, dataElement), siblingNode, dataElement);\n                    makeBlack(getParent(currentNode, dataElement), dataElement);\n                    makeBlack(getLeftChild(siblingNode, dataElement), dataElement);\n                    rotateRight(getParent(currentNode, dataElement), dataElement);\n\n                    currentNode = rootNode[dataElement.ordinal()];\n                }\n            }\n        }\n\n        makeBlack(currentNode, dataElement);\n    }\n\n    /**\n     * Complicated red-black insert stuff. Based on Sun's TreeMap\n     * implementation, though it's barely recognizable anymore.\n     *\n     * @param insertedNode the node to be inserted\n     * @param dataElement  the KEY or VALUE int\n     */\n    private void doRedBlackInsert(final Node<K, V> insertedNode, final DataElement dataElement) {\n        Node<K, V> currentNode = insertedNode;\n        makeRed(currentNode, dataElement);\n\n        while (currentNode != null\n            && currentNode != rootNode[dataElement.ordinal()]\n            && isRed(currentNode.getParent(dataElement), dataElement)) {\n            if (currentNode.isLeftChild(dataElement)) {\n                final Node<K, V> y = getRightChild(getGrandParent(currentNode, dataElement), dataElement);\n\n                if (isRed(y, dataElement)) {\n                    makeBlack(getParent(currentNode, dataElement), dataElement);\n                    makeBlack(y, dataElement);\n                    makeRed(getGrandParent(currentNode, dataElement), dataElement);\n\n                    currentNode = getGrandParent(currentNode, dataElement);\n                } else {\n                    //dead code?\n                    if (currentNode.isRightChild(dataElement)) {\n                        currentNode = getParent(currentNode, dataElement);\n\n                        rotateLeft(currentNode, dataElement);\n                    }\n\n                    makeBlack(getParent(currentNode, dataElement), dataElement);\n                    makeRed(getGrandParent(currentNode, dataElement), dataElement);\n\n                    if (getGrandParent(currentNode, dataElement) != null) {\n                        rotateRight(getGrandParent(currentNode, dataElement), dataElement);\n                    }\n                }\n            } else {\n\n                // just like clause above, except swap left for right\n                final Node<K, V> y = getLeftChild(getGrandParent(currentNode, dataElement), dataElement);\n\n                if (isRed(y, dataElement)) {\n                    makeBlack(getParent(currentNode, dataElement), dataElement);\n                    makeBlack(y, dataElement);\n                    makeRed(getGrandParent(currentNode, dataElement), dataElement);\n\n                    currentNode = getGrandParent(currentNode, dataElement);\n                } else {\n                    //dead code?\n                    if (currentNode.isLeftChild(dataElement)) {\n                        currentNode = getParent(currentNode, dataElement);\n\n                        rotateRight(currentNode, dataElement);\n                    }\n\n                    makeBlack(getParent(currentNode, dataElement), dataElement);\n                    makeRed(getGrandParent(currentNode, dataElement), dataElement);\n\n                    if (getGrandParent(currentNode, dataElement) != null) {\n                        rotateLeft(getGrandParent(currentNode, dataElement), dataElement);\n                    }\n                }\n            }\n        }\n\n        makeBlack(rootNode[dataElement.ordinal()], dataElement);\n    }\n\n    private V doRemoveKey(final Object key) {\n        final Node<K, V> node = lookupKey(key);\n        if (node == null) {\n            return null;\n        }\n        doRedBlackDelete(node);\n        return node.getValue();\n    }\n\n    private K doRemoveValue(final Object value) {\n        final Node<K, V> node = lookupValue(value);\n        if (node == null) {\n            return null;\n        }\n        doRedBlackDelete(node);\n        return node.getKey();\n    }\n\n    /**\n     * Gets the string form of this map as per AbstractMap.\n     *\n     * @param dataElement  either the {@link DataElement#KEY key}\n     *                     or the {@link DataElement#VALUE value}.\n     * @return the string form of this map\n     */\n    private String doToString(final DataElement dataElement) {\n        if (nodeCount == 0) {\n            return \"{}\";\n        }\n        final StringBuilder buf = new StringBuilder(nodeCount * 32);\n        buf.append('{');\n        final MapIterator<?, ?> it = getMapIterator(dataElement);\n        boolean hasNext = it.hasNext();\n        while (hasNext) {\n            final Object key = it.next();\n            final Object value = it.getValue();\n            buf.append(key == this ? \"(this Map)\" : key)\n                .append('=')\n                .append(value == this ? \"(this Map)\" : value);\n\n            hasNext = it.hasNext();\n            if (hasNext) {\n                buf.append(\", \");\n            }\n        }\n\n        buf.append('}');\n        return buf.toString();\n    }\n\n    /**\n     * Returns a set view of the entries contained in this map in key order.\n     * For simple iteration through the map, the MapIterator is quicker.\n     * <p>\n     * The set is backed by the map, so changes to the map are reflected in\n     * the set, and vice-versa. If the map is modified while an iteration over\n     * the set is in progress, the results of the iteration are undefined.\n     * <p>\n     * The set supports element removal, which removes the corresponding mapping\n     * from the map. It does not support the add or addAll operations.\n     * The returned MapEntry objects do not support setValue.\n     *\n     * @return a set view of the values contained in this map.\n     */\n    @Override\n    public Set<Map.Entry<K, V>> entrySet() {\n        if (entrySet == null) {\n            entrySet = new EntryView();\n        }\n        return entrySet;\n    }\n\n    /**\n     * Compares for equals as per the API.\n     *\n     * @param obj  the object to compare to\n     * @return true if equal\n     */\n    @Override\n    public boolean equals(final Object obj) {\n        return this.doEquals(obj, KEY);\n    }\n\n    /**\n     * Gets the first (lowest) key currently in this map.\n     *\n     * @return the first (lowest) key currently in this sorted map\n     * @throws NoSuchElementException if this map is empty\n     */\n    @Override\n    public K firstKey() {\n        if (nodeCount == 0) {\n            throw new NoSuchElementException(\"Map is empty\");\n        }\n        return leastNode(rootNode[KEY.ordinal()], KEY).getKey();\n    }\n\n    /**\n     * Gets the value to which this map maps the specified key.\n     * Returns null if the map contains no mapping for this key.\n     * <p>\n     * The key must implement {@code Comparable}.\n     *\n     * @param key  key whose associated value is to be returned\n     * @return the value to which this map maps the specified key,\n     *  or null if the map contains no mapping for this key\n     * @throws ClassCastException if the key is of an inappropriate type\n     * @throws NullPointerException if the key is null\n     */\n    @Override\n    public V get(final Object key) {\n        checkKey(key);\n        final Node<K, V> node = lookupKey(key);\n        return node == null ? null : node.getValue();\n    }\n\n    /**\n     * Gets a node's grandparent. mind you, the node, its parent, or\n     * its grandparent may not exist. No problem.\n     *\n     * @param node the node (may be null) in question\n     * @param dataElement  either the {@link DataElement#KEY key}\n     *                     or the {@link DataElement#VALUE value}.\n     */\n    private Node<K, V> getGrandParent(final Node<K, V> node, final DataElement dataElement) {\n        return getParent(getParent(node, dataElement), dataElement);\n    }\n\n    /**\n     * Returns the key to which this map maps the specified value.\n     * Returns null if the map contains no mapping for this value.\n     * <p>\n     * The value must implement {@code Comparable}.\n     *\n     * @param value  value whose associated key is to be returned.\n     * @return the key to which this map maps the specified value,\n     *  or null if the map contains no mapping for this value.\n     * @throws ClassCastException if the value is of an inappropriate type\n     * @throws NullPointerException if the value is null\n     */\n    @Override\n    public K getKey(final Object value) {\n        checkValue(value);\n        final Node<K, V> node = lookupValue(value);\n        return node == null ? null : node.getKey();\n    }\n\n    /**\n     * Gets a node's left child. mind you, the node may not exist. no\n     * problem.\n     *\n     * @param node the node (may be null) in question\n     * @param dataElement  either the {@link DataElement#KEY key}\n     *                     or the {@link DataElement#VALUE value}.\n     */\n    private Node<K, V> getLeftChild(final Node<K, V> node, final DataElement dataElement) {\n        return node == null ? null : node.getLeft(dataElement);\n    }\n\n    private MapIterator<?, ?> getMapIterator(final DataElement dataElement) {\n        switch (dataElement) {\n        case KEY:\n            return new ViewMapIterator(KEY);\n        case VALUE:\n            return new InverseViewMapIterator(VALUE);\n        default:\n            throw new IllegalArgumentException();\n        }\n    }\n\n    /**\n     * Gets a node's parent. mind you, the node, or its parent, may not\n     * exist. no problem.\n     *\n     * @param node the node (may be null) in question\n     * @param dataElement  either the {@link DataElement#KEY key}\n     *                     or the {@link DataElement#VALUE value}.\n     */\n    private Node<K, V> getParent(final Node<K, V> node, final DataElement dataElement) {\n        return node == null ? null : node.getParent(dataElement);\n    }\n\n    /**\n     * Gets a node's right child. mind you, the node may not exist. no\n     * problem.\n     *\n     * @param node the node (may be null) in question\n     * @param dataElement  either the {@link DataElement#KEY key}\n     *                     or the {@link DataElement#VALUE value}.\n     */\n    private Node<K, V> getRightChild(final Node<K, V> node, final DataElement dataElement) {\n        return node == null ? null : node.getRight(dataElement);\n    }\n\n    /**\n     * Finds the greatest node from a given node.\n     *\n     * @param node  the node from which we will start searching\n     * @param dataElement  either the {@link DataElement#KEY key}\n     *                     or the {@link DataElement#VALUE value}.\n     * @return the greatest node, from the specified node\n     */\n    private Node<K, V> greatestNode(final Node<K, V> node, final DataElement dataElement) {\n        Node<K, V> rval = node;\n        if (rval != null) {\n            while (rval.getRight(dataElement) != null) {\n                rval = rval.getRight(dataElement);\n            }\n        }\n        return rval;\n    }\n\n    /**\n     * Bumps up the size and note that the map has changed.\n     */\n    private void grow() {\n        modify();\n        nodeCount++;\n    }\n\n    /**\n     * Gets the hash code value for this map as per the API.\n     *\n     * @return the hash code value for this map\n     */\n    @Override\n    public int hashCode() {\n        return this.doHashCode(KEY);\n    }\n\n    /**\n     * Inserts a node by its value.\n     *\n     * @param newNode the node to be inserted\n     *\n     * @throws IllegalArgumentException if the node already exists\n     *                                     in the value mapping\n     */\n    private void insertValue(final Node<K, V> newNode) throws IllegalArgumentException {\n        Node<K, V> node = rootNode[VALUE.ordinal()];\n\n        while (true) {\n            final int cmp = compare(newNode.getValue(), node.getValue());\n\n            if (cmp == 0) {\n                throw new IllegalArgumentException(\n                    \"Cannot store a duplicate value (\\\"\" + newNode.getData(VALUE) + \"\\\") in this Map\");\n            }\n            if (cmp < 0) {\n                if (node.getLeft(VALUE) == null) {\n                    node.setLeft(newNode, VALUE);\n                    newNode.setParent(node, VALUE);\n                    doRedBlackInsert(newNode, VALUE);\n\n                    break;\n                }\n                node = node.getLeft(VALUE);\n            } else { // cmp > 0\n                if (node.getRight(VALUE) == null) {\n                    node.setRight(newNode, VALUE);\n                    newNode.setParent(node, VALUE);\n                    doRedBlackInsert(newNode, VALUE);\n\n                    break;\n                }\n                node = node.getRight(VALUE);\n            }\n        }\n    }\n\n    /**\n     * Gets the inverse map for comparison.\n     *\n     * @return the inverse map\n     */\n    @Override\n    public OrderedBidiMap<V, K> inverseBidiMap() {\n        if (inverse == null) {\n            inverse = new Inverse();\n        }\n        return inverse;\n    }\n\n    /**\n     * Checks whether the map is empty or not.\n     *\n     * @return true if the map is empty\n     */\n    @Override\n    public boolean isEmpty() {\n        return nodeCount == 0;\n    }\n\n    /**\n     * Returns a set view of the keys contained in this map in key order.\n     * <p>\n     * The set is backed by the map, so changes to the map are reflected in\n     * the set, and vice-versa. If the map is modified while an iteration over\n     * the set is in progress, the results of the iteration are undefined.\n     * <p>\n     * The set supports element removal, which removes the corresponding mapping\n     * from the map. It does not support the add or addAll operations.\n     *\n     * @return a set view of the keys contained in this map.\n     */\n    @Override\n    public Set<K> keySet() {\n        if (keySet == null) {\n            keySet = new KeyView(KEY);\n        }\n        return keySet;\n    }\n\n    /**\n     * Gets the last (highest) key currently in this map.\n     *\n     * @return the last (highest) key currently in this sorted map\n     * @throws NoSuchElementException if this map is empty\n     */\n    @Override\n    public K lastKey() {\n        if (nodeCount == 0) {\n            throw new NoSuchElementException(\"Map is empty\");\n        }\n        return greatestNode(rootNode[KEY.ordinal()], KEY).getKey();\n    }\n\n    /**\n     * Finds the least node from a given node.\n     *\n     * @param node  the node from which we will start searching\n     * @param dataElement  either the {@link DataElement#KEY key}\n     *                     or the {@link DataElement#VALUE value}.\n     * @return the smallest node, from the specified node, in the\n     *         specified mapping\n     */\n    private Node<K, V> leastNode(final Node<K, V> node, final DataElement dataElement) {\n        Node<K, V> rval = node;\n        if (rval != null) {\n            while (rval.getLeft(dataElement) != null) {\n                rval = rval.getLeft(dataElement);\n            }\n        }\n        return rval;\n    }\n\n    /**\n     * Does the actual lookup of a piece of data.\n     *\n     * @param data the key or value to be looked up\n     * @param dataElement  either the {@link DataElement#KEY key}\n     *                     or the {@link DataElement#VALUE value}.\n     * @return the desired Node, or null if there is no mapping of the\n     *         specified data\n     */\n    @SuppressWarnings(\"unchecked\")\n    private <T extends Comparable<T>> Node<K, V> lookup(final Object data, final DataElement dataElement) {\n        Node<K, V> rval = null;\n        Node<K, V> node = rootNode[dataElement.ordinal()];\n\n        while (node != null) {\n            final int cmp = compare((T) data, (T) node.getData(dataElement));\n            if (cmp == 0) {\n                rval = node;\n                break;\n            }\n            node = cmp < 0 ? node.getLeft(dataElement) : node.getRight(dataElement);\n        }\n\n        return rval;\n    }\n\n    private Node<K, V> lookupKey(final Object key) {\n        return this.<K>lookup(key, KEY);\n    }\n\n    private Node<K, V> lookupValue(final Object value) {\n        return this.<V>lookup(value, VALUE);\n    }\n\n    @Override\n    public OrderedMapIterator<K, V> mapIterator() {\n        if (isEmpty()) {\n            return EmptyOrderedMapIterator.<K, V>emptyOrderedMapIterator();\n        }\n        return new ViewMapIterator(KEY);\n    }\n\n    /**\n     * Increments the modification count -- used to check for\n     * concurrent modification of the map through the map and through\n     * an Iterator from one of its Set or Collection views.\n     */\n    private void modify() {\n        modifications++;\n    }\n\n    /**\n     * Gets the next larger node from the specified node.\n     *\n     * @param node the node to be searched from\n     * @param dataElement  either the {@link DataElement#KEY key}\n     *                     or the {@link DataElement#VALUE value}.\n     * @return the specified node\n     */\n    private Node<K, V> nextGreater(final Node<K, V> node, final DataElement dataElement) {\n        final Node<K, V> rval;\n        if (node == null) {\n            rval = null;\n        } else if (node.getRight(dataElement) != null) {\n            // everything to the node's right is larger. The least of\n            // the right node's descendants is the next larger node\n            rval = leastNode(node.getRight(dataElement), dataElement);\n        } else {\n            // traverse up our ancestry until we find an ancestor that\n            // is null or one whose left child is our ancestor. If we\n            // find a null, then this node IS the largest node in the\n            // tree, and there is no greater node. Otherwise, we are\n            // the largest node in the subtree on that ancestor's left\n            // ... and that ancestor is the next greatest node\n            Node<K, V> parent = node.getParent(dataElement);\n            Node<K, V> child = node;\n\n            while (parent != null && child == parent.getRight(dataElement)) {\n                child = parent;\n                parent = parent.getParent(dataElement);\n            }\n            rval = parent;\n        }\n        return rval;\n    }\n\n    /**\n     * Gets the next key after the one specified.\n     * <p>\n     * The key must implement {@code Comparable}.\n     *\n     * @param key the key to search for next from\n     * @return the next key, null if no match or at end\n     */\n    @Override\n    public K nextKey(final K key) {\n        checkKey(key);\n        final Node<K, V> node = nextGreater(lookupKey(key), KEY);\n        return node == null ? null : node.getKey();\n    }\n\n    /**\n     * Gets the next smaller node from the specified node.\n     *\n     * @param node the node to be searched from\n     * @param dataElement  either the {@link DataElement#KEY key}\n     *                     or the {@link DataElement#VALUE value}.\n     * @return the specified node\n     */\n    private Node<K, V> nextSmaller(final Node<K, V> node, final DataElement dataElement) {\n        final Node<K, V> rval;\n        if (node == null) {\n            rval = null;\n        } else if (node.getLeft(dataElement) != null) {\n            // everything to the node's left is smaller. The greatest of\n            // the left node's descendants is the next smaller node\n            rval = greatestNode(node.getLeft(dataElement), dataElement);\n        } else {\n            // traverse up our ancestry until we find an ancestor that\n            // is null or one whose right child is our ancestor. If we\n            // find a null, then this node IS the largest node in the\n            // tree, and there is no greater node. Otherwise, we are\n            // the largest node in the subtree on that ancestor's right\n            // ... and that ancestor is the next greatest node\n            Node<K, V> parent = node.getParent(dataElement);\n            Node<K, V> child = node;\n\n            while (parent != null && child == parent.getLeft(dataElement)) {\n                child = parent;\n                parent = parent.getParent(dataElement);\n            }\n            rval = parent;\n        }\n        return rval;\n    }\n\n    /**\n     * Gets the previous key before the one specified.\n     * <p>\n     * The key must implement {@code Comparable}.\n     *\n     * @param key the key to search for previous from\n     * @return the previous key, null if no match or at start\n     */\n    @Override\n    public K previousKey(final K key) {\n        checkKey(key);\n        final Node<K, V> node = nextSmaller(lookupKey(key), KEY);\n        return node == null ? null : node.getKey();\n    }\n\n    /**\n     * Puts the key-value pair into the map, replacing any previous pair.\n     * <p>\n     * When adding a key-value pair, the value may already exist in the map\n     * against a different key. That mapping is removed, to ensure that the\n     * value only occurs once in the inverse map.\n     * <pre>\n     *  BidiMap map1 = new TreeBidiMap();\n     *  map.put(\"A\",\"B\");  // contains A mapped to B, as per Map\n     *  map.put(\"A\",\"C\");  // contains A mapped to C, as per Map\n     *\n     *  BidiMap map2 = new TreeBidiMap();\n     *  map.put(\"A\",\"B\");  // contains A mapped to B, as per Map\n     *  map.put(\"C\",\"B\");  // contains C mapped to B, key A is removed\n     * </pre>\n     * <p>\n     * Both key and value must implement {@code Comparable}.\n     *\n     * @param key  key with which the specified value is to be  associated\n     * @param value  value to be associated with the specified key\n     * @return the previous value for the key\n     * @throws ClassCastException if the key is of an inappropriate type\n     * @throws NullPointerException if the key is null\n     */\n    @Override\n    public V put(final K key, final V value) {\n        final V result = get(key);\n        doPut(key, value);\n        return result;\n    }\n\n    /**\n     * Puts all the mappings from the specified map into this map.\n     * <p>\n     * All keys and values must implement {@code Comparable}.\n     *\n     * @param map  the map to copy from\n     */\n    @Override\n    public void putAll(final Map<? extends K, ? extends V> map) {\n        for (final Map.Entry<? extends K, ? extends V> e : map.entrySet()) {\n            put(e.getKey(), e.getValue());\n        }\n    }\n\n    /**\n     * Deserializes the content of the stream.\n     *\n     * @param stream the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded\n     */\n    @SuppressWarnings(\"unchecked\") // This will fail at runtime if the stream is incorrect\n    private void readObject(final ObjectInputStream stream) throws IOException, ClassNotFoundException {\n        stream.defaultReadObject();\n        rootNode = new Node[2];\n        final int size = stream.readInt();\n        for (int i = 0; i < size; i++) {\n            final K k = (K) stream.readObject();\n            final V v = (V) stream.readObject();\n            put(k, v);\n        }\n    }\n\n    /**\n     * Removes the mapping for this key from this map if present.\n     * <p>\n     * The key must implement {@code Comparable}.\n     *\n     * @param key  key whose mapping is to be removed from the map.\n     * @return previous value associated with specified key,\n     *  or null if there was no mapping for key.\n     * @throws ClassCastException if the key is of an inappropriate type\n     * @throws NullPointerException if the key is null\n     */\n    @Override\n    public V remove(final Object key) {\n        return doRemoveKey(key);\n    }\n\n    /**\n     * Removes the mapping for this value from this map if present.\n     * <p>\n     * The value must implement {@code Comparable}.\n     *\n     * @param value  value whose mapping is to be removed from the map\n     * @return previous key associated with specified value,\n     *  or null if there was no mapping for value.\n     * @throws ClassCastException if the value is of an inappropriate type\n     * @throws NullPointerException if the value is null\n     */\n    @Override\n    public K removeValue(final Object value) {\n        return doRemoveValue(value);\n    }\n\n    /**\n     * Does a rotate left. standard fare in the world of balanced trees.\n     *\n     * @param node the node to be rotated\n     * @param dataElement  either the {@link DataElement#KEY key}\n     *                     or the {@link DataElement#VALUE value}.\n     */\n    private void rotateLeft(final Node<K, V> node, final DataElement dataElement) {\n        final Node<K, V> rightChild = node.getRight(dataElement);\n        node.setRight(rightChild.getLeft(dataElement), dataElement);\n\n        if (rightChild.getLeft(dataElement) != null) {\n            rightChild.getLeft(dataElement).setParent(node, dataElement);\n        }\n        rightChild.setParent(node.getParent(dataElement), dataElement);\n\n        if (node.getParent(dataElement) == null) {\n            // node was the root ... now its right child is the root\n            rootNode[dataElement.ordinal()] = rightChild;\n        } else if (node.getParent(dataElement).getLeft(dataElement) == node) {\n            node.getParent(dataElement).setLeft(rightChild, dataElement);\n        } else {\n            node.getParent(dataElement).setRight(rightChild, dataElement);\n        }\n\n        rightChild.setLeft(node, dataElement);\n        node.setParent(rightChild, dataElement);\n    }\n\n    /**\n     * Does a rotate right. standard fare in the world of balanced trees.\n     *\n     * @param node the node to be rotated\n     * @param dataElement  either the {@link DataElement#KEY key}\n     *                     or the {@link DataElement#VALUE value}.\n     */\n    private void rotateRight(final Node<K, V> node, final DataElement dataElement) {\n        final Node<K, V> leftChild = node.getLeft(dataElement);\n        node.setLeft(leftChild.getRight(dataElement), dataElement);\n        if (leftChild.getRight(dataElement) != null) {\n            leftChild.getRight(dataElement).setParent(node, dataElement);\n        }\n        leftChild.setParent(node.getParent(dataElement), dataElement);\n\n        if (node.getParent(dataElement) == null) {\n            // node was the root ... now its left child is the root\n            rootNode[dataElement.ordinal()] = leftChild;\n        } else if (node.getParent(dataElement).getRight(dataElement) == node) {\n            node.getParent(dataElement).setRight(leftChild, dataElement);\n        } else {\n            node.getParent(dataElement).setLeft(leftChild, dataElement);\n        }\n\n        leftChild.setRight(node, dataElement);\n        node.setParent(leftChild, dataElement);\n    }\n\n    /**\n     * Decrements the size and note that the map has changed.\n     */\n    private void shrink() {\n        modify();\n        nodeCount--;\n    }\n\n    /**\n     * Returns the number of key-value mappings in this map.\n     *\n     * @return the number of key-value mappings in this map\n     */\n    @Override\n    public int size() {\n        return nodeCount;\n    }\n\n    /**\n     * Swaps two nodes (except for their content), taking care of\n     * special cases where one is the other's parent ... hey, it\n     * happens.\n     *\n     * @param x one node\n     * @param y another node\n     * @param dataElement  the KEY or VALUE int\n     */\n    private void swapPosition(final Node<K, V> x, final Node<K, V> y, final DataElement dataElement) {\n        // Save initial values.\n        final Node<K, V> xFormerParent = x.getParent(dataElement);\n        final Node<K, V> xFormerLeftChild = x.getLeft(dataElement);\n        final Node<K, V> xFormerRightChild = x.getRight(dataElement);\n        final Node<K, V> yFormerParent = y.getParent(dataElement);\n        final Node<K, V> yFormerLeftChild = y.getLeft(dataElement);\n        final Node<K, V> yFormerRightChild = y.getRight(dataElement);\n        final boolean xWasLeftChild =\n                x.getParent(dataElement) != null && x == x.getParent(dataElement).getLeft(dataElement);\n        final boolean yWasLeftChild =\n                y.getParent(dataElement) != null && y == y.getParent(dataElement).getLeft(dataElement);\n\n        // Swap, handling special cases of one being the other's parent.\n        if (x == yFormerParent) { // x was y's parent\n            x.setParent(y, dataElement);\n\n            if (yWasLeftChild) {\n                y.setLeft(x, dataElement);\n                y.setRight(xFormerRightChild, dataElement);\n            } else {\n                y.setRight(x, dataElement);\n                y.setLeft(xFormerLeftChild, dataElement);\n            }\n        } else {\n            x.setParent(yFormerParent, dataElement);\n\n            if (yFormerParent != null) {\n                if (yWasLeftChild) {\n                    yFormerParent.setLeft(x, dataElement);\n                } else {\n                    yFormerParent.setRight(x, dataElement);\n                }\n            }\n\n            y.setLeft(xFormerLeftChild, dataElement);\n            y.setRight(xFormerRightChild, dataElement);\n        }\n\n        if (y == xFormerParent) { // y was x's parent\n            y.setParent(x, dataElement);\n\n            if (xWasLeftChild) {\n                x.setLeft(y, dataElement);\n                x.setRight(yFormerRightChild, dataElement);\n            } else {\n                x.setRight(y, dataElement);\n                x.setLeft(yFormerLeftChild, dataElement);\n            }\n        } else {\n            y.setParent(xFormerParent, dataElement);\n\n            if (xFormerParent != null) {\n                if (xWasLeftChild) {\n                    xFormerParent.setLeft(y, dataElement);\n                } else {\n                    xFormerParent.setRight(y, dataElement);\n                }\n            }\n\n            x.setLeft(yFormerLeftChild, dataElement);\n            x.setRight(yFormerRightChild, dataElement);\n        }\n\n        // Fix children's parent pointers\n        if (x.getLeft(dataElement) != null) {\n            x.getLeft(dataElement).setParent(x, dataElement);\n        }\n\n        if (x.getRight(dataElement) != null) {\n            x.getRight(dataElement).setParent(x, dataElement);\n        }\n\n        if (y.getLeft(dataElement) != null) {\n            y.getLeft(dataElement).setParent(y, dataElement);\n        }\n\n        if (y.getRight(dataElement) != null) {\n            y.getRight(dataElement).setParent(y, dataElement);\n        }\n\n        x.swapColors(y, dataElement);\n\n        // Check if root changed\n        if (rootNode[dataElement.ordinal()] == x) {\n            rootNode[dataElement.ordinal()] = y;\n        } else if (rootNode[dataElement.ordinal()] == y) {\n            rootNode[dataElement.ordinal()] = x;\n        }\n    }\n\n    /**\n     * Returns a string version of this Map in standard format.\n     *\n     * @return a standard format string version of the map\n     */\n    @Override\n    public String toString() {\n        return this.doToString(KEY);\n    }\n\n    /**\n     * Returns a set view of the values contained in this map in key order.\n     * The returned object can be cast to a Set.\n     * <p>\n     * The set is backed by the map, so changes to the map are reflected in\n     * the set, and vice-versa. If the map is modified while an iteration over\n     * the set is in progress, the results of the iteration are undefined.\n     * <p>\n     * The set supports element removal, which removes the corresponding mapping\n     * from the map. It does not support the add or addAll operations.\n     *\n     * @return a set view of the values contained in this map.\n     */\n    @Override\n    public Set<V> values() {\n        if (valuesSet == null) {\n            valuesSet = new ValueView(KEY);\n        }\n        return valuesSet;\n    }\n\n    /**\n     * Serializes this object to an ObjectOutputStream.\n     *\n     * @param out the target ObjectOutputStream.\n     * @throws IOException thrown when an I/O errors occur writing to the target stream.\n     */\n    private void writeObject(final ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        out.writeInt(this.size());\n        for (final Entry<K, V> entry : entrySet()) {\n            out.writeObject(entry.getKey());\n            out.writeObject(entry.getValue());\n        }\n    }\n\n}", "super_interfaces": ["OrderedBidiMap<K, V>", "Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 721969328361807L;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 721969328361807L", "syntax_pass": true}, {"attribute_expression": "private transient Node<K, V>[] rootNode;", "docstring": "", "modifiers": "private transient", "marker_annotations": [], "non_marker_annotations": ["private", "transient"], "comments": [], "type": "Node<K, V>[]", "name": "rootNode", "syntax_pass": true}, {"attribute_expression": "private transient int nodeCount;", "docstring": "", "modifiers": "private transient", "marker_annotations": [], "non_marker_annotations": ["private", "transient"], "comments": [], "type": "int", "name": "nodeCount", "syntax_pass": true}, {"attribute_expression": "private transient int modifications;", "docstring": "", "modifiers": "private transient", "marker_annotations": [], "non_marker_annotations": ["private", "transient"], "comments": [], "type": "int", "name": "modifications", "syntax_pass": true}, {"attribute_expression": "private transient Set<K> keySet;", "docstring": "", "modifiers": "private transient", "marker_annotations": [], "non_marker_annotations": ["private", "transient"], "comments": [], "type": "Set<K>", "name": "keySet", "syntax_pass": true}, {"attribute_expression": "private transient Set<V> valuesSet;", "docstring": "", "modifiers": "private transient", "marker_annotations": [], "non_marker_annotations": ["private", "transient"], "comments": [], "type": "Set<V>", "name": "valuesSet", "syntax_pass": true}, {"attribute_expression": "private transient Set<Map.Entry<K, V>> entrySet;", "docstring": "", "modifiers": "private transient", "marker_annotations": [], "non_marker_annotations": ["private", "transient"], "comments": [], "type": "Set<Map.Entry<K, V>>", "name": "entrySet", "syntax_pass": true}, {"attribute_expression": "private transient Inverse inverse;", "docstring": "", "modifiers": "private transient", "marker_annotations": [], "non_marker_annotations": ["private", "transient"], "comments": [], "type": "Inverse", "name": "inverse", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/bidimap/DualHashBidiMap.java.DualHashBidiMap", "name": "DualHashBidiMap", "file_path": "src/main/java/org/apache/commons/collections4/bidimap/DualHashBidiMap.java", "superclasses": "", "methods": ["[]DualHashBidiMap()", "[]DualHashBidiMap(Map<? extends K, ? extends V>)", "[]DualHashBidiMap(Map<K, V>,Map<V, K>,BidiMap<V, K>)", "[BidiMap<V, K>]createBidiMap(Map<V, K>,Map<K, V>,BidiMap<K, V>)", "[void]readObject(ObjectInputStream)", "[void]writeObject(ObjectOutputStream)"], "method_uris": ["src/main/java/org/apache/commons/collections4/bidimap/DualHashBidiMap.java.DualHashBidiMap.[]DualHashBidiMap()", "src/main/java/org/apache/commons/collections4/bidimap/DualHashBidiMap.java.DualHashBidiMap.[]DualHashBidiMap(Map<? extends K, ? extends V>)", "src/main/java/org/apache/commons/collections4/bidimap/DualHashBidiMap.java.DualHashBidiMap.[]DualHashBidiMap(Map<K, V>,Map<V, K>,BidiMap<V, K>)", "src/main/java/org/apache/commons/collections4/bidimap/DualHashBidiMap.java.DualHashBidiMap.[BidiMap<V, K>]createBidiMap(Map<V, K>,Map<K, V>,BidiMap<K, V>)", "src/main/java/org/apache/commons/collections4/bidimap/DualHashBidiMap.java.DualHashBidiMap.[void]readObject(ObjectInputStream)", "src/main/java/org/apache/commons/collections4/bidimap/DualHashBidiMap.java.DualHashBidiMap.[void]writeObject(ObjectOutputStream)"], "overrides": null, "attributes": [], "class_docstring": "\nImplements {@link BidiMap} with two {@link HashMap} instances.\n<p>\nTwo {@link HashMap} instances are used in this class.\nThis provides fast lookups at the expense of storing two sets of map entries.\nCommons Collections would welcome the addition of a direct hash-based\nimplementation of the {@link BidiMap} interface.\n</p>\n<p>\nNOTE: From Commons Collections 3.1, all subclasses will use {@link HashMap}\nand the flawed {@code createMap} method is ignored.\n</p>\n\n@param <K> the type of the keys in the map\n@param <V> the type of the values in the map\n\n@since 3.0\n", "original_string": "public class DualHashBidiMap<K, V> extends AbstractDualBidiMap<K, V> implements Serializable {\n\n    /** Ensure serialization compatibility */\n    private static final long serialVersionUID = 721969328361808L;\n\n    /**\n     * Creates an empty {@code HashBidiMap}.\n     */\n    public DualHashBidiMap() {\n        super(new HashMap<>(), new HashMap<>());\n    }\n\n    /**\n     * Constructs a {@code HashBidiMap} and copies the mappings from\n     * specified {@code Map}.\n     *\n     * @param map  the map whose mappings are to be placed in this map\n     */\n    public DualHashBidiMap(final Map<? extends K, ? extends V> map) {\n        super(new HashMap<>(), new HashMap<>());\n        putAll(map);\n    }\n\n    /**\n     * Constructs a {@code HashBidiMap} that decorates the specified maps.\n     *\n     * @param normalMap  the normal direction map\n     * @param reverseMap  the reverse direction map\n     * @param inverseBidiMap  the inverse BidiMap\n     */\n    protected DualHashBidiMap(final Map<K, V> normalMap, final Map<V, K> reverseMap,\n                              final BidiMap<V, K> inverseBidiMap) {\n        super(normalMap, reverseMap, inverseBidiMap);\n    }\n\n    /**\n     * Creates a new instance of this object.\n     *\n     * @param normalMap  the normal direction map\n     * @param reverseMap  the reverse direction map\n     * @param inverseBidiMap  the inverse BidiMap\n     * @return new bidi map\n     */\n    @Override\n    protected BidiMap<V, K> createBidiMap(final Map<V, K> normalMap, final Map<K, V> reverseMap,\n                                          final BidiMap<K, V> inverseBidiMap) {\n        return new DualHashBidiMap<>(normalMap, reverseMap, inverseBidiMap);\n    }\n\n    /**\n     * Deserializes an instance from an ObjectInputStream.\n     *\n     * @param in The source ObjectInputStream.\n     * @throws IOException            Any of the usual Input/Output related exceptions.\n     * @throws ClassNotFoundException A class of a serialized object cannot be found.\n     */\n    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        normalMap = new HashMap<>();\n        reverseMap = new HashMap<>();\n        @SuppressWarnings(\"unchecked\") // will fail at runtime if stream is incorrect\n        final Map<K, V> map = (Map<K, V>) in.readObject();\n        putAll(map);\n    }\n\n    /**\n     * Serializes this object to an ObjectOutputStream.\n     *\n     * @param out the target ObjectOutputStream.\n     * @throws IOException thrown when an I/O errors occur writing to the target stream.\n     */\n    private void writeObject(final ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        out.writeObject(normalMap);\n    }\n\n}", "super_interfaces": ["Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 721969328361808L;", "docstring": " Ensure serialization compatibility", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 721969328361808L", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/set/PredicatedNavigableSet.java.PredicatedNavigableSet", "name": "PredicatedNavigableSet", "file_path": "src/main/java/org/apache/commons/collections4/set/PredicatedNavigableSet.java", "superclasses": "", "methods": ["[PredicatedNavigableSet<E>]predicatedNavigableSet(NavigableSet<E>,Predicate<? super E>)", "[]PredicatedNavigableSet(NavigableSet<E>,Predicate<? super E>)", "[E]ceiling(E)", "[NavigableSet<E>]decorated()", "[Iterator<E>]descendingIterator()", "[NavigableSet<E>]descendingSet()", "[E]floor(E)", "[NavigableSet<E>]headSet(E,boolean)", "[E]higher(E)", "[E]lower(E)", "[E]pollFirst()", "[E]pollLast()", "[NavigableSet<E>]subSet(E,boolean,E,boolean)", "[NavigableSet<E>]tailSet(E,boolean)"], "method_uris": ["src/main/java/org/apache/commons/collections4/set/PredicatedNavigableSet.java.PredicatedNavigableSet.[PredicatedNavigableSet<E>]predicatedNavigableSet(NavigableSet<E>,Predicate<? super E>)", "src/main/java/org/apache/commons/collections4/set/PredicatedNavigableSet.java.PredicatedNavigableSet.[]PredicatedNavigableSet(NavigableSet<E>,Predicate<? super E>)", "src/main/java/org/apache/commons/collections4/set/PredicatedNavigableSet.java.PredicatedNavigableSet.[E]ceiling(E)", "src/main/java/org/apache/commons/collections4/set/PredicatedNavigableSet.java.PredicatedNavigableSet.[NavigableSet<E>]decorated()", "src/main/java/org/apache/commons/collections4/set/PredicatedNavigableSet.java.PredicatedNavigableSet.[Iterator<E>]descendingIterator()", "src/main/java/org/apache/commons/collections4/set/PredicatedNavigableSet.java.PredicatedNavigableSet.[NavigableSet<E>]descendingSet()", "src/main/java/org/apache/commons/collections4/set/PredicatedNavigableSet.java.PredicatedNavigableSet.[E]floor(E)", "src/main/java/org/apache/commons/collections4/set/PredicatedNavigableSet.java.PredicatedNavigableSet.[NavigableSet<E>]headSet(E,boolean)", "src/main/java/org/apache/commons/collections4/set/PredicatedNavigableSet.java.PredicatedNavigableSet.[E]higher(E)", "src/main/java/org/apache/commons/collections4/set/PredicatedNavigableSet.java.PredicatedNavigableSet.[E]lower(E)", "src/main/java/org/apache/commons/collections4/set/PredicatedNavigableSet.java.PredicatedNavigableSet.[E]pollFirst()", "src/main/java/org/apache/commons/collections4/set/PredicatedNavigableSet.java.PredicatedNavigableSet.[E]pollLast()", "src/main/java/org/apache/commons/collections4/set/PredicatedNavigableSet.java.PredicatedNavigableSet.[NavigableSet<E>]subSet(E,boolean,E,boolean)", "src/main/java/org/apache/commons/collections4/set/PredicatedNavigableSet.java.PredicatedNavigableSet.[NavigableSet<E>]tailSet(E,boolean)"], "overrides": null, "attributes": [], "class_docstring": "\nDecorates another {@code NavigableSet} to validate that all additions\nmatch a specified predicate.\n<p>\nThis set exists to provide validation for the decorated set.\nIt is normally created to decorate an empty set.\nIf an object cannot be added to the set, an IllegalArgumentException is thrown.\n</p>\n<p>\nOne usage would be to ensure that no null entries are added to the set.\n</p>\n<pre>\nNavigableSet set =\n  PredicatedSortedSet.predicatedNavigableSet(new TreeSet(),\n                                             NotNullPredicate.notNullPredicate());\n</pre>\n\n@param <E> the type of the elements in this set\n@since 4.1\n", "original_string": "public class PredicatedNavigableSet<E> extends PredicatedSortedSet<E> implements NavigableSet<E> {\n\n    /** Serialization version */\n    private static final long serialVersionUID = 20150528L;\n\n    /**\n     * Factory method to create a predicated (validating) navigable set.\n     * <p>\n     * If there are any elements already in the set being decorated, they\n     * are validated.\n     *\n     * @param <E> the element type\n     * @param set  the set to decorate, must not be null\n     * @param predicate  the predicate to use for validation, must not be null\n     * @return a new predicated navigable set.\n     * @throws NullPointerException if set or predicate is null\n     * @throws IllegalArgumentException if the set contains invalid elements\n     * @since 4.0\n     */\n    public static <E> PredicatedNavigableSet<E> predicatedNavigableSet(final NavigableSet<E> set,\n                                                                       final Predicate<? super E> predicate) {\n        return new PredicatedNavigableSet<>(set, predicate);\n    }\n\n    /**\n     * Constructor that wraps (not copies).\n     * <p>\n     * If there are any elements already in the set being decorated, they\n     * are validated.\n     *\n     * @param set  the set to decorate, must not be null\n     * @param predicate  the predicate to use for validation, must not be null\n     * @throws NullPointerException if set or predicate is null\n     * @throws IllegalArgumentException if the set contains invalid elements\n     */\n    protected PredicatedNavigableSet(final NavigableSet<E> set, final Predicate<? super E> predicate) {\n        super(set, predicate);\n    }\n\n    @Override\n    public E ceiling(final E e) {\n        return decorated().ceiling(e);\n    }\n\n    /**\n     * Gets the navigable set being decorated.\n     *\n     * @return the decorated navigable set\n     */\n    @Override\n    protected NavigableSet<E> decorated() {\n        return (NavigableSet<E>) super.decorated();\n    }\n\n    @Override\n    public Iterator<E> descendingIterator() {\n        return decorated().descendingIterator();\n    }\n\n    @Override\n    public NavigableSet<E> descendingSet() {\n        return predicatedNavigableSet(decorated().descendingSet(), predicate);\n    }\n\n    @Override\n    public E floor(final E e) {\n        return decorated().floor(e);\n    }\n\n    @Override\n    public NavigableSet<E> headSet(final E toElement, final boolean inclusive) {\n        final NavigableSet<E> head = decorated().headSet(toElement, inclusive);\n        return predicatedNavigableSet(head, predicate);\n    }\n\n    @Override\n    public E higher(final E e) {\n        return decorated().higher(e);\n    }\n\n    @Override\n    public E lower(final E e) {\n        return decorated().lower(e);\n    }\n\n    @Override\n    public E pollFirst() {\n        return decorated().pollFirst();\n    }\n\n    @Override\n    public E pollLast() {\n        return decorated().pollLast();\n    }\n\n    @Override\n    public NavigableSet<E> subSet(final E fromElement, final boolean fromInclusive, final E toElement,\n            final boolean toInclusive) {\n        final NavigableSet<E> sub = decorated().subSet(fromElement, fromInclusive, toElement, toInclusive);\n        return predicatedNavigableSet(sub, predicate);\n    }\n\n    @Override\n    public NavigableSet<E> tailSet(final E fromElement, final boolean inclusive) {\n        final NavigableSet<E> tail = decorated().tailSet(fromElement, inclusive);\n        return predicatedNavigableSet(tail, predicate);\n    }\n\n}", "super_interfaces": ["NavigableSet<E>"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 20150528L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 20150528L", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/set/TransformedSet.java.TransformedSet", "name": "TransformedSet", "file_path": "src/main/java/org/apache/commons/collections4/set/TransformedSet.java", "superclasses": "", "methods": ["[Set<E>]transformedSet(Set<E>,Transformer<? super E, ? extends E>)", "[TransformedSet<E>]transformingSet(Set<E>,Transformer<? super E, ? extends E>)", "[]TransformedSet(Set<E>,Transformer<? super E, ? extends E>)", "[boolean]equals(Object)", "[int]hashCode()"], "method_uris": ["src/main/java/org/apache/commons/collections4/set/TransformedSet.java.TransformedSet.[Set<E>]transformedSet(Set<E>,Transformer<? super E, ? extends E>)", "src/main/java/org/apache/commons/collections4/set/TransformedSet.java.TransformedSet.[TransformedSet<E>]transformingSet(Set<E>,Transformer<? super E, ? extends E>)", "src/main/java/org/apache/commons/collections4/set/TransformedSet.java.TransformedSet.[]TransformedSet(Set<E>,Transformer<? super E, ? extends E>)", "src/main/java/org/apache/commons/collections4/set/TransformedSet.java.TransformedSet.[boolean]equals(Object)", "src/main/java/org/apache/commons/collections4/set/TransformedSet.java.TransformedSet.[int]hashCode()"], "overrides": null, "attributes": [], "class_docstring": "\nDecorates another {@code Set} to transform objects that are added.\n<p>\nThe add methods are affected by this class.\nThus objects must be removed or searched for using their transformed form.\nFor example, if the transformation converts Strings to Integers, you must\nuse the Integer form to remove objects.\n</p>\n<p>\nThis class is Serializable from Commons Collections 3.1.\n</p>\n\n@param <E> the type of the elements in this set\n@since 3.0\n", "original_string": "public class TransformedSet<E> extends TransformedCollection<E> implements Set<E> {\n\n    /** Serialization version */\n    private static final long serialVersionUID = 306127383500410386L;\n\n    /**\n     * Factory method to create a transforming set that will transform\n     * existing contents of the specified set.\n     * <p>\n     * If there are any elements already in the set being decorated, they\n     * will be transformed by this method.\n     * Contrast this with {@link #transformingSet(Set, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param set  the set to decorate, must not be null\n     * @param transformer  the transformer to use for conversion, must not be null\n     * @return a new transformed set\n     * @throws NullPointerException if set or transformer is null\n     * @since 4.0\n     */\n    public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer) {\n        final TransformedSet<E> decorated = new TransformedSet<>(set, transformer);\n        if (!set.isEmpty()) {\n            @SuppressWarnings(\"unchecked\") // set is type E\n            final E[] values = (E[]) set.toArray(); // NOPMD - false positive for generics\n            set.clear();\n            for (final E value : values) {\n                decorated.decorated().add(transformer.apply(value));\n            }\n        }\n        return decorated;\n    }\n\n    /**\n     * Factory method to create a transforming set.\n     * <p>\n     * If there are any elements already in the set being decorated, they\n     * are NOT transformed.\n     * Contrast this with {@link #transformedSet(Set, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param set  the set to decorate, must not be null\n     * @param transformer  the transformer to use for conversion, must not be null\n     * @return a new transformed set\n     * @throws NullPointerException if set or transformer is null\n     * @since 4.0\n     */\n    public static <E> TransformedSet<E> transformingSet(final Set<E> set,\n            final Transformer<? super E, ? extends E> transformer) {\n        return new TransformedSet<>(set, transformer);\n    }\n\n    /**\n     * Constructor that wraps (not copies).\n     * <p>\n     * If there are any elements already in the set being decorated, they\n     * are NOT transformed.\n     *\n     * @param set  the set to decorate, must not be null\n     * @param transformer  the transformer to use for conversion, must not be null\n     * @throws NullPointerException if set or transformer is null\n     */\n    protected TransformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer) {\n        super(set, transformer);\n    }\n\n    @Override\n    public boolean equals(final Object object) {\n        return object == this || decorated().equals(object);\n    }\n\n    @Override\n    public int hashCode() {\n        return decorated().hashCode();\n    }\n\n}", "super_interfaces": ["Set<E>"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 306127383500410386L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 306127383500410386L", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/set/UnmodifiableNavigableSet.java.UnmodifiableNavigableSet", "name": "UnmodifiableNavigableSet", "file_path": "src/main/java/org/apache/commons/collections4/set/UnmodifiableNavigableSet.java", "superclasses": "", "methods": ["[NavigableSet<E>]unmodifiableNavigableSet(NavigableSet<E>)", "[]UnmodifiableNavigableSet(NavigableSet<E>)", "[boolean]add(E)", "[boolean]addAll(Collection<? extends E>)", "[void]clear()", "[Iterator<E>]descendingIterator()", "[NavigableSet<E>]descendingSet()", "[SortedSet<E>]headSet(E)", "[NavigableSet<E>]headSet(E,boolean)", "[Iterator<E>]iterator()", "[E]pollFirst()", "[E]pollLast()", "[void]readObject(ObjectInputStream)", "[boolean]remove(Object)", "[boolean]removeAll(Collection<?>)", "[boolean]removeIf(Predicate<? super E>)", "[boolean]retainAll(Collection<?>)", "[NavigableSet<E>]subSet(E,boolean,E,boolean)", "[SortedSet<E>]subSet(E,E)", "[SortedSet<E>]tailSet(E)", "[NavigableSet<E>]tailSet(E,boolean)", "[void]writeObject(ObjectOutputStream)"], "method_uris": ["src/main/java/org/apache/commons/collections4/set/UnmodifiableNavigableSet.java.UnmodifiableNavigableSet.[NavigableSet<E>]unmodifiableNavigableSet(NavigableSet<E>)", "src/main/java/org/apache/commons/collections4/set/UnmodifiableNavigableSet.java.UnmodifiableNavigableSet.[]UnmodifiableNavigableSet(NavigableSet<E>)", "src/main/java/org/apache/commons/collections4/set/UnmodifiableNavigableSet.java.UnmodifiableNavigableSet.[boolean]add(E)", "src/main/java/org/apache/commons/collections4/set/UnmodifiableNavigableSet.java.UnmodifiableNavigableSet.[boolean]addAll(Collection<? extends E>)", "src/main/java/org/apache/commons/collections4/set/UnmodifiableNavigableSet.java.UnmodifiableNavigableSet.[void]clear()", "src/main/java/org/apache/commons/collections4/set/UnmodifiableNavigableSet.java.UnmodifiableNavigableSet.[Iterator<E>]descendingIterator()", "src/main/java/org/apache/commons/collections4/set/UnmodifiableNavigableSet.java.UnmodifiableNavigableSet.[NavigableSet<E>]descendingSet()", "src/main/java/org/apache/commons/collections4/set/UnmodifiableNavigableSet.java.UnmodifiableNavigableSet.[SortedSet<E>]headSet(E)", "src/main/java/org/apache/commons/collections4/set/UnmodifiableNavigableSet.java.UnmodifiableNavigableSet.[NavigableSet<E>]headSet(E,boolean)", "src/main/java/org/apache/commons/collections4/set/UnmodifiableNavigableSet.java.UnmodifiableNavigableSet.[Iterator<E>]iterator()", "src/main/java/org/apache/commons/collections4/set/UnmodifiableNavigableSet.java.UnmodifiableNavigableSet.[E]pollFirst()", "src/main/java/org/apache/commons/collections4/set/UnmodifiableNavigableSet.java.UnmodifiableNavigableSet.[E]pollLast()", "src/main/java/org/apache/commons/collections4/set/UnmodifiableNavigableSet.java.UnmodifiableNavigableSet.[void]readObject(ObjectInputStream)", "src/main/java/org/apache/commons/collections4/set/UnmodifiableNavigableSet.java.UnmodifiableNavigableSet.[boolean]remove(Object)", "src/main/java/org/apache/commons/collections4/set/UnmodifiableNavigableSet.java.UnmodifiableNavigableSet.[boolean]removeAll(Collection<?>)", "src/main/java/org/apache/commons/collections4/set/UnmodifiableNavigableSet.java.UnmodifiableNavigableSet.[boolean]removeIf(Predicate<? super E>)", "src/main/java/org/apache/commons/collections4/set/UnmodifiableNavigableSet.java.UnmodifiableNavigableSet.[boolean]retainAll(Collection<?>)", "src/main/java/org/apache/commons/collections4/set/UnmodifiableNavigableSet.java.UnmodifiableNavigableSet.[NavigableSet<E>]subSet(E,boolean,E,boolean)", "src/main/java/org/apache/commons/collections4/set/UnmodifiableNavigableSet.java.UnmodifiableNavigableSet.[SortedSet<E>]subSet(E,E)", "src/main/java/org/apache/commons/collections4/set/UnmodifiableNavigableSet.java.UnmodifiableNavigableSet.[SortedSet<E>]tailSet(E)", "src/main/java/org/apache/commons/collections4/set/UnmodifiableNavigableSet.java.UnmodifiableNavigableSet.[NavigableSet<E>]tailSet(E,boolean)", "src/main/java/org/apache/commons/collections4/set/UnmodifiableNavigableSet.java.UnmodifiableNavigableSet.[void]writeObject(ObjectOutputStream)"], "overrides": null, "attributes": [], "class_docstring": "\nDecorates another {@code NavigableSet} to ensure it can't be altered.\n<p>\nAttempts to modify it will result in an UnsupportedOperationException.\n</p>\n\n@param <E> the type of the elements in this set\n@since 4.1\n", "original_string": "public final class UnmodifiableNavigableSet<E>\n        extends AbstractNavigableSetDecorator<E>\n        implements Unmodifiable {\n\n    /** Serialization version */\n    private static final long serialVersionUID = 20150528L;\n\n    /**\n     * Factory method to create an unmodifiable set.\n     *\n     * @param <E> the element type\n     * @param set  the set to decorate, must not be null\n     * @return a new unmodifiable {@link NavigableSet}\n     * @throws NullPointerException if set is null\n     */\n    public static <E> NavigableSet<E> unmodifiableNavigableSet(final NavigableSet<E> set) {\n        if (set instanceof Unmodifiable) {\n            return set;\n        }\n        return new UnmodifiableNavigableSet<>(set);\n    }\n\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param set  the set to decorate, must not be null\n     * @throws NullPointerException if set is null\n     */\n    private UnmodifiableNavigableSet(final NavigableSet<E> set) {\n        super(set);\n    }\n\n    @Override\n    public boolean add(final E object) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public boolean addAll(final Collection<? extends E> coll) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public void clear() {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public Iterator<E> descendingIterator() {\n        return UnmodifiableIterator.unmodifiableIterator(decorated().descendingIterator());\n    }\n\n    // NavigableSet\n    @Override\n    public NavigableSet<E> descendingSet() {\n        return unmodifiableNavigableSet(decorated().descendingSet());\n    }\n\n    @Override\n    public SortedSet<E> headSet(final E toElement) {\n        final SortedSet<E> head = decorated().headSet(toElement);\n        return UnmodifiableSortedSet.unmodifiableSortedSet(head);\n    }\n\n    @Override\n    public NavigableSet<E> headSet(final E toElement, final boolean inclusive) {\n        final NavigableSet<E> head = decorated().headSet(toElement, inclusive);\n        return unmodifiableNavigableSet(head);\n    }\n\n    @Override\n    public Iterator<E> iterator() {\n        return UnmodifiableIterator.unmodifiableIterator(decorated().iterator());\n    }\n\n    /**\n     * @since 4.5.0\n     */\n    @Override\n    public E pollFirst() {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * @since 4.5.0\n     */\n    @Override\n    public E pollLast() {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * Deserializes the collection in using a custom routine.\n     *\n     * @param in  the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded\n     */\n    @SuppressWarnings(\"unchecked\") // (1) should only fail if input stream is incorrect\n    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        setCollection((Collection<E>) in.readObject()); // (1)\n    }\n\n    @Override\n    public boolean remove(final Object object) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public boolean removeAll(final Collection<?> coll) {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * @since 4.4\n     */\n    @Override\n    public boolean removeIf(final Predicate<? super E> filter) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public boolean retainAll(final Collection<?> coll) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public NavigableSet<E> subSet(final E fromElement, final boolean fromInclusive, final E toElement,\n            final boolean toInclusive) {\n        final NavigableSet<E> sub = decorated().subSet(fromElement, fromInclusive, toElement, toInclusive);\n        return unmodifiableNavigableSet(sub);\n    }\n\n    // SortedSet\n    @Override\n    public SortedSet<E> subSet(final E fromElement, final E toElement) {\n        final SortedSet<E> sub = decorated().subSet(fromElement, toElement);\n        return UnmodifiableSortedSet.unmodifiableSortedSet(sub);\n    }\n\n    @Override\n    public SortedSet<E> tailSet(final E fromElement) {\n        final SortedSet<E> tail = decorated().tailSet(fromElement);\n        return UnmodifiableSortedSet.unmodifiableSortedSet(tail);\n    }\n\n    @Override\n    public NavigableSet<E> tailSet(final E fromElement, final boolean inclusive) {\n        final NavigableSet<E> tail = decorated().tailSet(fromElement, inclusive);\n        return unmodifiableNavigableSet(tail);\n    }\n\n    /**\n     * Serializes this object to an ObjectOutputStream.\n     *\n     * @param out the target ObjectOutputStream.\n     * @throws IOException thrown when an I/O errors occur writing to the target stream.\n     */\n    private void writeObject(final ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        out.writeObject(decorated());\n    }\n\n}", "super_interfaces": ["Unmodifiable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 20150528L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 20150528L", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/set/TransformedSortedSet.java.TransformedSortedSet", "name": "TransformedSortedSet", "file_path": "src/main/java/org/apache/commons/collections4/set/TransformedSortedSet.java", "superclasses": "", "methods": ["[TransformedSortedSet<E>]transformedSortedSet(SortedSet<E>,Transformer<? super E, ? extends E>)", "[TransformedSortedSet<E>]transformingSortedSet(SortedSet<E>,Transformer<? super E, ? extends E>)", "[]TransformedSortedSet(SortedSet<E>,Transformer<? super E, ? extends E>)", "[Comparator<? super E>]comparator()", "[E]first()", "[SortedSet<E>]getSortedSet()", "[SortedSet<E>]headSet(E)", "[E]last()", "[SortedSet<E>]subSet(E,E)", "[SortedSet<E>]tailSet(E)"], "method_uris": ["src/main/java/org/apache/commons/collections4/set/TransformedSortedSet.java.TransformedSortedSet.[TransformedSortedSet<E>]transformedSortedSet(SortedSet<E>,Transformer<? super E, ? extends E>)", "src/main/java/org/apache/commons/collections4/set/TransformedSortedSet.java.TransformedSortedSet.[TransformedSortedSet<E>]transformingSortedSet(SortedSet<E>,Transformer<? super E, ? extends E>)", "src/main/java/org/apache/commons/collections4/set/TransformedSortedSet.java.TransformedSortedSet.[]TransformedSortedSet(SortedSet<E>,Transformer<? super E, ? extends E>)", "src/main/java/org/apache/commons/collections4/set/TransformedSortedSet.java.TransformedSortedSet.[Comparator<? super E>]comparator()", "src/main/java/org/apache/commons/collections4/set/TransformedSortedSet.java.TransformedSortedSet.[E]first()", "src/main/java/org/apache/commons/collections4/set/TransformedSortedSet.java.TransformedSortedSet.[SortedSet<E>]getSortedSet()", "src/main/java/org/apache/commons/collections4/set/TransformedSortedSet.java.TransformedSortedSet.[SortedSet<E>]headSet(E)", "src/main/java/org/apache/commons/collections4/set/TransformedSortedSet.java.TransformedSortedSet.[E]last()", "src/main/java/org/apache/commons/collections4/set/TransformedSortedSet.java.TransformedSortedSet.[SortedSet<E>]subSet(E,E)", "src/main/java/org/apache/commons/collections4/set/TransformedSortedSet.java.TransformedSortedSet.[SortedSet<E>]tailSet(E)"], "overrides": null, "attributes": [], "class_docstring": "\nDecorates another {@code SortedSet} to transform objects that are added.\n<p>\nThe add methods are affected by this class.\nThus objects must be removed or searched for using their transformed form.\nFor example, if the transformation converts Strings to Integers, you must\nuse the Integer form to remove objects.\n</p>\n<p>\nThis class is Serializable from Commons Collections 3.1.\n</p>\n\n@param <E> the type of the elements in this set\n@since 3.0\n", "original_string": "public class TransformedSortedSet<E> extends TransformedSet<E> implements SortedSet<E> {\n\n    /** Serialization version */\n    private static final long serialVersionUID = -1675486811351124386L;\n\n    /**\n     * Factory method to create a transforming sorted set that will transform\n     * existing contents of the specified sorted set.\n     * <p>\n     * If there are any elements already in the set being decorated, they\n     * will be transformed by this method.\n     * Contrast this with {@link #transformingSortedSet(SortedSet, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param set  the set to decorate, must not be null\n     * @param transformer  the transformer to use for conversion, must not be null\n     * @return a new transformed {@link SortedSet}\n     * @throws NullPointerException if set or transformer is null\n     * @since 4.0\n     */\n    public static <E> TransformedSortedSet<E> transformedSortedSet(final SortedSet<E> set,\n            final Transformer<? super E, ? extends E> transformer) {\n\n        final TransformedSortedSet<E> decorated = new TransformedSortedSet<>(set, transformer);\n        if (!set.isEmpty()) {\n            @SuppressWarnings(\"unchecked\") // set is type E\n            final E[] values = (E[]) set.toArray(); // NOPMD - false positive for generics\n            set.clear();\n            for (final E value : values) {\n                decorated.decorated().add(transformer.apply(value));\n            }\n        }\n        return decorated;\n    }\n\n    /**\n     * Factory method to create a transforming sorted set.\n     * <p>\n     * If there are any elements already in the set being decorated, they\n     * are NOT transformed.\n     * Contrast this with {@link #transformedSortedSet(SortedSet, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param set  the set to decorate, must not be null\n     * @param transformer  the transformer to use for conversion, must not be null\n     * @return a new transformed {@link SortedSet}\n     * @throws NullPointerException if set or transformer is null\n     * @since 4.0\n     */\n    public static <E> TransformedSortedSet<E> transformingSortedSet(final SortedSet<E> set,\n            final Transformer<? super E, ? extends E> transformer) {\n        return new TransformedSortedSet<>(set, transformer);\n    }\n\n    /**\n     * Constructor that wraps (not copies).\n     * <p>\n     * If there are any elements already in the set being decorated, they\n     * are NOT transformed.\n     *\n     * @param set  the set to decorate, must not be null\n     * @param transformer  the transformer to use for conversion, must not be null\n     * @throws NullPointerException if set or transformer is null\n     */\n    protected TransformedSortedSet(final SortedSet<E> set, final Transformer<? super E, ? extends E> transformer) {\n        super(set, transformer);\n    }\n\n    @Override\n    public Comparator<? super E> comparator() {\n        return getSortedSet().comparator();\n    }\n\n    @Override\n    public E first() {\n        return getSortedSet().first();\n    }\n\n    /**\n     * Gets the decorated set.\n     *\n     * @return the decorated set\n     */\n    protected SortedSet<E> getSortedSet() {\n        return (SortedSet<E>) decorated();\n    }\n\n    @Override\n    public SortedSet<E> headSet(final E toElement) {\n        final SortedSet<E> set = getSortedSet().headSet(toElement);\n        return new TransformedSortedSet<>(set, transformer);\n    }\n\n    @Override\n    public E last() {\n        return getSortedSet().last();\n    }\n\n    @Override\n    public SortedSet<E> subSet(final E fromElement, final E toElement) {\n        final SortedSet<E> set = getSortedSet().subSet(fromElement, toElement);\n        return new TransformedSortedSet<>(set, transformer);\n    }\n\n    @Override\n    public SortedSet<E> tailSet(final E fromElement) {\n        final SortedSet<E> set = getSortedSet().tailSet(fromElement);\n        return new TransformedSortedSet<>(set, transformer);\n    }\n\n}", "super_interfaces": ["SortedSet<E>"], "fields": [{"attribute_expression": "private static final long serialVersionUID = -1675486811351124386L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -1675486811351124386L", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/set/CompositeSet.java.CompositeSet", "name": "CompositeSet", "file_path": "src/main/java/org/apache/commons/collections4/set/CompositeSet.java", "superclasses": "", "methods": ["[]CompositeSet()", "[]CompositeSet(Set<E>)", "[]CompositeSet()", "[boolean]add(E)", "[boolean]addAll(Collection<? extends E>)", "[void]addComposited(Set<E>)", "[void]addComposited()", "[void]addComposited(Set<E>,Set<E>)", "[void]clear()", "[boolean]contains(Object)", "[boolean]containsAll(Collection<?>)", "[boolean]equals(Object)", "[SetMutator<E>]getMutator()", "[List<Set<E>>]getSets()", "[int]hashCode()", "[boolean]isEmpty()", "[Iterator<E>]iterator()", "[boolean]remove(Object)", "[boolean]removeAll(Collection<?>)", "[void]removeComposited(Set<E>)", "[boolean]removeIf(Predicate<? super E>)", "[boolean]retainAll(Collection<?>)", "[void]setMutator(SetMutator<E>)", "[int]size()", "[Object[]]toArray()", "[T[]]toArray(T[])", "[Set<E>]toSet()"], "method_uris": ["src/main/java/org/apache/commons/collections4/set/CompositeSet.java.CompositeSet.[]CompositeSet()", "src/main/java/org/apache/commons/collections4/set/CompositeSet.java.CompositeSet.[]CompositeSet(Set<E>)", "src/main/java/org/apache/commons/collections4/set/CompositeSet.java.CompositeSet.[]CompositeSet()", "src/main/java/org/apache/commons/collections4/set/CompositeSet.java.CompositeSet.[boolean]add(E)", "src/main/java/org/apache/commons/collections4/set/CompositeSet.java.CompositeSet.[boolean]addAll(Collection<? extends E>)", "src/main/java/org/apache/commons/collections4/set/CompositeSet.java.CompositeSet.[void]addComposited(Set<E>)", "src/main/java/org/apache/commons/collections4/set/CompositeSet.java.CompositeSet.[void]addComposited()", "src/main/java/org/apache/commons/collections4/set/CompositeSet.java.CompositeSet.[void]addComposited(Set<E>,Set<E>)", "src/main/java/org/apache/commons/collections4/set/CompositeSet.java.CompositeSet.[void]clear()", "src/main/java/org/apache/commons/collections4/set/CompositeSet.java.CompositeSet.[boolean]contains(Object)", "src/main/java/org/apache/commons/collections4/set/CompositeSet.java.CompositeSet.[boolean]containsAll(Collection<?>)", "src/main/java/org/apache/commons/collections4/set/CompositeSet.java.CompositeSet.[boolean]equals(Object)", "src/main/java/org/apache/commons/collections4/set/CompositeSet.java.CompositeSet.[SetMutator<E>]getMutator()", "src/main/java/org/apache/commons/collections4/set/CompositeSet.java.CompositeSet.[List<Set<E>>]getSets()", "src/main/java/org/apache/commons/collections4/set/CompositeSet.java.CompositeSet.[int]hashCode()", "src/main/java/org/apache/commons/collections4/set/CompositeSet.java.CompositeSet.[boolean]isEmpty()", "src/main/java/org/apache/commons/collections4/set/CompositeSet.java.CompositeSet.[Iterator<E>]iterator()", "src/main/java/org/apache/commons/collections4/set/CompositeSet.java.CompositeSet.[boolean]remove(Object)", "src/main/java/org/apache/commons/collections4/set/CompositeSet.java.CompositeSet.[boolean]removeAll(Collection<?>)", "src/main/java/org/apache/commons/collections4/set/CompositeSet.java.CompositeSet.[void]removeComposited(Set<E>)", "src/main/java/org/apache/commons/collections4/set/CompositeSet.java.CompositeSet.[boolean]removeIf(Predicate<? super E>)", "src/main/java/org/apache/commons/collections4/set/CompositeSet.java.CompositeSet.[boolean]retainAll(Collection<?>)", "src/main/java/org/apache/commons/collections4/set/CompositeSet.java.CompositeSet.[void]setMutator(SetMutator<E>)", "src/main/java/org/apache/commons/collections4/set/CompositeSet.java.CompositeSet.[int]size()", "src/main/java/org/apache/commons/collections4/set/CompositeSet.java.CompositeSet.[Object[]]toArray()", "src/main/java/org/apache/commons/collections4/set/CompositeSet.java.CompositeSet.[T[]]toArray(T[])", "src/main/java/org/apache/commons/collections4/set/CompositeSet.java.CompositeSet.[Set<E>]toSet()"], "overrides": null, "attributes": [], "class_docstring": "\nDecorates a set of other sets to provide a single unified view.\n<p>\nChanges made to this set will actually be made on the decorated set.\nAdd operations require the use of a pluggable strategy.\nIf no strategy is provided then add is unsupported.\n</p>\n<p>\nFrom version 4.0, this class does not extend\n{@link org.apache.commons.collections4.collection.CompositeCollection CompositeCollection}\nanymore due to its input restrictions (only accepts Sets).\nSee <a href=\"https://issues.apache.org/jira/browse/COLLECTIONS-424\">COLLECTIONS-424</a>\nfor more details.\n</p>\n\n@param <E> the type of the elements in this set\n@since 3.0\n", "original_string": "public class CompositeSet<E> implements Set<E>, Serializable {\n\n    /**\n     * Defines callbacks for mutation operations.\n     *\n     * @param <E> the type of the elements in this instance.\n     */\n    public interface SetMutator<E> extends Serializable {\n\n        /**\n         * Called when an object is to be added to the composite.\n         *\n         * @param composite  the CompositeSet being changed\n         * @param sets  all of the Set instances in this CompositeSet\n         * @param obj  the object being added\n         * @return true if the collection is changed\n         * @throws UnsupportedOperationException if add is unsupported\n         * @throws ClassCastException if the object cannot be added due to its type\n         * @throws NullPointerException if the object cannot be added because its null\n         * @throws IllegalArgumentException if the object cannot be added\n         */\n        boolean add(CompositeSet<E> composite, List<Set<E>> sets, E obj);\n\n        /**\n         * Called when a collection is to be added to the composite.\n         *\n         * @param composite  the CompositeSet being changed\n         * @param sets  all of the Set instances in this CompositeSet\n         * @param coll  the collection being added\n         * @return true if the collection is changed\n         * @throws UnsupportedOperationException if add is unsupported\n         * @throws ClassCastException if the object cannot be added due to its type\n         * @throws NullPointerException if the object cannot be added because its null\n         * @throws IllegalArgumentException if the object cannot be added\n         */\n        boolean addAll(CompositeSet<E> composite,\n                              List<Set<E>> sets,\n                              Collection<? extends E> coll);\n\n        /**\n         * Called when a Set is added to the CompositeSet and there is a\n         * collision between existing and added sets.\n         * <p>\n         * If {@code added} and {@code existing} still have any intersects\n         * after this method returns an IllegalArgumentException will be thrown.\n         *\n         * @param comp  the CompositeSet being modified\n         * @param existing  the Set already existing in the composite\n         * @param added  the Set being added to the composite\n         * @param intersects  the intersection of the existing and added sets\n         */\n        void resolveCollision(CompositeSet<E> comp,\n                                     Set<E> existing,\n                                     Set<E> added,\n                                     Collection<E> intersects);\n    }\n\n    /** Serialization version */\n    private static final long serialVersionUID = 5185069727540378940L;\n\n    /** SetMutator to handle changes to the collection */\n    private SetMutator<E> mutator;\n\n    /** Sets in the composite */\n    private final List<Set<E>> all = new ArrayList<>();\n\n    /**\n     * Creates an empty CompositeSet.\n     */\n    public CompositeSet() {\n    }\n\n    /**\n     * Creates a CompositeSet with just {@code set} composited.\n     *\n     * @param set  the initial set in the composite\n     */\n    public CompositeSet(final Set<E> set) {\n        addComposited(set);\n    }\n\n    /**\n     * Creates a composite set with sets as the initial set of composited Sets.\n     *\n     * @param sets  the initial sets in the composite\n     */\n    public CompositeSet(final Set<E>... sets) {\n        addComposited(sets);\n    }\n\n    /**\n     * Adds an object to the collection, throwing UnsupportedOperationException\n     * unless a SetMutator strategy is specified.\n     *\n     * @param obj  the object to add\n     * @return {@code true} if the collection was modified\n     * @throws UnsupportedOperationException if SetMutator hasn't been set or add is unsupported\n     * @throws ClassCastException if the object cannot be added due to its type\n     * @throws NullPointerException if the object cannot be added because its null\n     * @throws IllegalArgumentException if the object cannot be added\n     */\n    @Override\n    public boolean add(final E obj) {\n        if (mutator == null) {\n            throw new UnsupportedOperationException(\n                \"add() is not supported on CompositeSet without a SetMutator strategy\");\n        }\n        return mutator.add(this, all, obj);\n    }\n\n    /**\n     * Adds a collection of elements to this composite, throwing\n     * UnsupportedOperationException unless a SetMutator strategy is specified.\n     *\n     * @param coll  the collection to add\n     * @return true if the composite was modified\n     * @throws UnsupportedOperationException if SetMutator hasn't been set or add is unsupported\n     * @throws ClassCastException if the object cannot be added due to its type\n     * @throws NullPointerException if the object cannot be added because its null\n     * @throws IllegalArgumentException if the object cannot be added\n     */\n    @Override\n    public boolean addAll(final Collection<? extends E> coll) {\n        if (mutator == null) {\n            throw new UnsupportedOperationException(\n                \"addAll() is not supported on CompositeSet without a SetMutator strategy\");\n        }\n        return mutator.addAll(this, all, coll);\n    }\n\n    /**\n     * Adds a Set to this composite.\n     *\n     * @param set  the set to add\n     * @throws IllegalArgumentException if a SetMutator is set, but fails to resolve a collision\n     * @throws UnsupportedOperationException if there is no SetMutator set\n     * @throws NullPointerException if {@code set} is null\n     * @see SetMutator\n     */\n    public synchronized void addComposited(final Set<E> set) {\n        if (set != null) {\n            for (final Set<E> existingSet : getSets()) {\n                final Collection<E> intersects = CollectionUtils.intersection(existingSet, set);\n                if (!intersects.isEmpty()) {\n                    if (mutator == null) {\n                        throw new UnsupportedOperationException(\n                                \"Collision adding composited set with no SetMutator set\");\n                    }\n                    getMutator().resolveCollision(this, existingSet, set, intersects);\n                    if (!CollectionUtils.intersection(existingSet, set).isEmpty()) {\n                        throw new IllegalArgumentException(\n                                \"Attempt to add illegal entry unresolved by SetMutator.resolveCollision()\");\n                    }\n                }\n            }\n            all.add(set);\n        }\n    }\n\n    /**\n     * Adds these Sets to the list of sets in this composite\n     *\n     * @param sets  the Sets to be appended to the composite\n     */\n    public void addComposited(final Set<E>... sets) {\n        if (sets != null) {\n            for (final Set<E> set : sets) {\n                addComposited(set);\n            }\n        }\n    }\n\n    /**\n     * Adds these Sets to the list of sets in this composite.\n     *\n     * @param set1  the first Set to be appended to the composite\n     * @param set2  the second Set to be appended to the composite\n     */\n    public void addComposited(final Set<E> set1, final Set<E> set2) {\n        addComposited(set1);\n        addComposited(set2);\n    }\n\n    /**\n     * Removes all of the elements from this composite set.\n     * <p>\n     * This implementation calls {@code clear()} on each set.\n     *\n     * @throws UnsupportedOperationException if clear is unsupported\n     */\n    @Override\n    public void clear() {\n        for (final Collection<E> coll : all) {\n            coll.clear();\n        }\n    }\n\n    /**\n     * Checks whether this composite set contains the object.\n     * <p>\n     * This implementation calls {@code contains()} on each set.\n     *\n     * @param obj  the object to search for\n     * @return true if obj is contained in any of the contained sets\n     */\n    @Override\n    public boolean contains(final Object obj) {\n        for (final Set<E> item : all) {\n            if (item.contains(obj)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Checks whether this composite contains all the elements in the specified collection.\n     * <p>\n     * This implementation calls {@code contains()} for each element in the\n     * specified collection.\n     *\n     * @param coll  the collection to check for\n     * @return true if all elements contained\n     */\n    @Override\n    public boolean containsAll(final Collection<?> coll) {\n        if (coll == null) {\n            return false;\n        }\n        for (final Object item : coll) {\n            if (!contains(item)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * {@inheritDoc}\n     * @see java.util.Set#equals\n     */\n    @Override\n    public boolean equals(final Object obj) {\n        if (obj instanceof Set) {\n            final Set<?> set = (Set<?>) obj;\n            return set.size() == this.size() && set.containsAll(this);\n        }\n        return false;\n    }\n\n    /**\n     * Gets the set mutator to be used for this CompositeSet.\n     * @return the set mutator\n     */\n    protected SetMutator<E> getMutator() {\n        return mutator;\n    }\n\n    /**\n     * Gets the sets being decorated.\n     *\n     * @return Unmodifiable list of all sets in this composite.\n     */\n    public List<Set<E>> getSets() {\n        return UnmodifiableList.unmodifiableList(all);\n    }\n\n    /**\n     * {@inheritDoc}\n     * @see java.util.Set#hashCode\n     */\n    @Override\n    public int hashCode() {\n        int code = 0;\n        for (final E e : this) {\n            code += e == null ? 0 : e.hashCode();\n        }\n        return code;\n    }\n\n    /**\n     * Checks whether this composite set is empty.\n     * <p>\n     * This implementation calls {@code isEmpty()} on each set.\n     *\n     * @return true if all of the contained sets are empty\n     */\n    @Override\n    public boolean isEmpty() {\n        for (final Set<E> item : all) {\n            if (!item.isEmpty()) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Gets an iterator over all the sets in this composite.\n     * <p>\n     * This implementation uses an {@code IteratorChain}.\n     *\n     * @return an {@code IteratorChain} instance which supports\n     *  {@code remove()}. Iteration occurs over contained collections in\n     *  the order they were added, but this behavior should not be relied upon.\n     * @see IteratorChain\n     */\n    @Override\n    public Iterator<E> iterator() {\n        if (all.isEmpty()) {\n            return EmptyIterator.<E>emptyIterator();\n        }\n        final IteratorChain<E> chain = new IteratorChain<>();\n        all.forEach(item -> chain.addIterator(item.iterator()));\n        return chain;\n    }\n\n    /**\n     * If a {@code CollectionMutator} is defined for this CompositeSet then this\n     * method will be called anyway.\n     *\n     * @param obj  object to be removed\n     * @return true if the object is removed, false otherwise\n     */\n    @Override\n    public boolean remove(final Object obj) {\n        for (final Set<E> set : getSets()) {\n            if (set.contains(obj)) {\n                return set.remove(obj);\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Removes the elements in the specified collection from this composite set.\n     * <p>\n     * This implementation calls {@code removeAll} on each collection.\n     *\n     * @param coll  the collection to remove\n     * @return true if the composite was modified\n     * @throws UnsupportedOperationException if removeAll is unsupported\n     */\n    @Override\n    public boolean removeAll(final Collection<?> coll) {\n        if (CollectionUtils.isEmpty(coll)) {\n            return false;\n        }\n        boolean changed = false;\n        for (final Collection<E> item : all) {\n            changed |= item.removeAll(coll);\n        }\n        return changed;\n    }\n\n    /**\n     * Removes a set from those being decorated in this composite.\n     *\n     * @param set  set to be removed\n     */\n    public void removeComposited(final Set<E> set) {\n        all.remove(set);\n    }\n\n    /**\n     * @since 4.4\n     */\n    @Override\n    public boolean removeIf(final Predicate<? super E> filter) {\n        if (Objects.isNull(filter)) {\n            return false;\n        }\n        boolean changed = false;\n        for (final Collection<E> item : all) {\n            changed |= item.removeIf(filter);\n        }\n        return changed;\n    }\n\n    /**\n     * Retains all the elements in the specified collection in this composite set,\n     * removing all others.\n     * <p>\n     * This implementation calls {@code retainAll()} on each collection.\n     *\n     * @param coll  the collection to remove\n     * @return true if the composite was modified\n     * @throws UnsupportedOperationException if retainAll is unsupported\n     */\n    @Override\n    public boolean retainAll(final Collection<?> coll) {\n        boolean changed = false;\n        for (final Collection<E> item : all) {\n            changed |= item.retainAll(coll);\n        }\n        return changed;\n    }\n\n    /**\n     * Specify a SetMutator strategy instance to handle changes.\n     *\n     * @param mutator  the mutator to use\n     */\n    public void setMutator(final SetMutator<E> mutator) {\n        this.mutator = mutator;\n    }\n\n    /**\n     * Gets the size of this composite set.\n     * <p>\n     * This implementation calls {@code size()} on each set.\n     *\n     * @return total number of elements in all contained containers\n     */\n    @Override\n    public int size() {\n        int size = 0;\n        for (final Set<E> item : all) {\n            size += item.size();\n        }\n        return size;\n    }\n\n    /**\n     * Returns an array containing all of the elements in this composite.\n     *\n     * @return an object array of all the elements in the collection\n     */\n    @Override\n    public Object[] toArray() {\n        final Object[] result = new Object[size()];\n        int i = 0;\n        for (final Iterator<E> it = iterator(); it.hasNext(); i++) {\n            result[i] = it.next();\n        }\n        return result;\n    }\n\n    /**\n     * Returns an object array, populating the supplied array if possible.\n     * See {@code Collection} interface for full details.\n     *\n     * @param <T>  the type of the elements in the collection\n     * @param array  the array to use, populating if possible\n     * @return an array of all the elements in the collection\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public <T> T[] toArray(final T[] array) {\n        final int size = size();\n        Object[] result = null;\n        if (array.length >= size) {\n            result = array;\n        } else {\n            result = (Object[]) Array.newInstance(array.getClass().getComponentType(), size);\n        }\n\n        int offset = 0;\n        for (final Collection<E> item : all) {\n            for (final E e : item) {\n                result[offset++] = e;\n            }\n        }\n        if (result.length > size) {\n            result[size] = null;\n        }\n        return (T[]) result;\n    }\n\n    /**\n     * Returns a new Set containing all of the elements.\n     *\n     * @return A new HashSet containing all of the elements in this composite.\n     *   The new collection is <em>not</em> backed by this composite.\n     */\n    public Set<E> toSet() {\n        return new HashSet<>(this);\n    }\n}", "super_interfaces": ["Set<E>", "Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 5185069727540378940L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 5185069727540378940L", "syntax_pass": true}, {"attribute_expression": "private SetMutator<E> mutator;", "docstring": " SetMutator to handle changes to the collection", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "SetMutator<E>", "name": "mutator", "syntax_pass": true}, {"attribute_expression": "private final List<Set<E>> all = new ArrayList<>();", "docstring": " Sets in the composite", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<Set<E>>", "name": "all = new ArrayList<>()", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/set/PredicatedSet.java.PredicatedSet", "name": "PredicatedSet", "file_path": "src/main/java/org/apache/commons/collections4/set/PredicatedSet.java", "superclasses": "", "methods": ["[PredicatedSet<E>]predicatedSet(Set<E>,Predicate<? super E>)", "[]PredicatedSet(Set<E>,Predicate<? super E>)", "[Set<E>]decorated()", "[boolean]equals(Object)", "[int]hashCode()"], "method_uris": ["src/main/java/org/apache/commons/collections4/set/PredicatedSet.java.PredicatedSet.[PredicatedSet<E>]predicatedSet(Set<E>,Predicate<? super E>)", "src/main/java/org/apache/commons/collections4/set/PredicatedSet.java.PredicatedSet.[]PredicatedSet(Set<E>,Predicate<? super E>)", "src/main/java/org/apache/commons/collections4/set/PredicatedSet.java.PredicatedSet.[Set<E>]decorated()", "src/main/java/org/apache/commons/collections4/set/PredicatedSet.java.PredicatedSet.[boolean]equals(Object)", "src/main/java/org/apache/commons/collections4/set/PredicatedSet.java.PredicatedSet.[int]hashCode()"], "overrides": null, "attributes": [], "class_docstring": "\nDecorates another {@code Set} to validate that all additions\nmatch a specified predicate.\n<p>\nThis set exists to provide validation for the decorated set.\nIt is normally created to decorate an empty set.\nIf an object cannot be added to the set, an IllegalArgumentException is thrown.\n</p>\n<p>\nOne usage would be to ensure that no null entries are added to the set.\n</p>\n<pre>Set set = PredicatedSet.decorate(new HashSet(), NotNullPredicate.INSTANCE);</pre>\n<p>\nThis class is Serializable from Commons Collections 3.1.\n</p>\n\n@param <E> the type of the elements in this set\n@since 3.0\n", "original_string": "public class PredicatedSet<E> extends PredicatedCollection<E> implements Set<E> {\n\n    /** Serialization version */\n    private static final long serialVersionUID = -684521469108685117L;\n\n    /**\n     * Factory method to create a predicated (validating) set.\n     * <p>\n     * If there are any elements already in the set being decorated, they\n     * are validated.\n     *\n     * @param <E> the element type\n     * @param set  the set to decorate, must not be null\n     * @param predicate  the predicate to use for validation, must not be null\n     * @return a decorated set\n     * @throws NullPointerException if set or predicate is null\n     * @throws IllegalArgumentException if the set contains invalid elements\n     * @since 4.0\n     */\n    public static <E> PredicatedSet<E> predicatedSet(final Set<E> set, final Predicate<? super E> predicate) {\n        return new PredicatedSet<>(set, predicate);\n    }\n\n    /**\n     * Constructor that wraps (not copies).\n     * <p>\n     * If there are any elements already in the set being decorated, they\n     * are validated.\n     *\n     * @param set  the set to decorate, must not be null\n     * @param predicate  the predicate to use for validation, must not be null\n     * @throws NullPointerException if set or predicate is null\n     * @throws IllegalArgumentException if the set contains invalid elements\n     */\n    protected PredicatedSet(final Set<E> set, final Predicate<? super E> predicate) {\n        super(set, predicate);\n    }\n\n    /**\n     * Gets the set being decorated.\n     *\n     * @return the decorated set\n     */\n    @Override\n    protected Set<E> decorated() {\n        return (Set<E>) super.decorated();\n    }\n\n    @Override\n    public boolean equals(final Object object) {\n        return object == this || decorated().equals(object);\n    }\n\n    @Override\n    public int hashCode() {\n        return decorated().hashCode();\n    }\n\n}", "super_interfaces": ["Set<E>"], "fields": [{"attribute_expression": "private static final long serialVersionUID = -684521469108685117L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -684521469108685117L", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/set/TransformedNavigableSet.java.TransformedNavigableSet", "name": "TransformedNavigableSet", "file_path": "src/main/java/org/apache/commons/collections4/set/TransformedNavigableSet.java", "superclasses": "", "methods": ["[TransformedNavigableSet<E>]transformedNavigableSet(NavigableSet<E>,Transformer<? super E, ? extends E>)", "[TransformedNavigableSet<E>]transformingNavigableSet(NavigableSet<E>,Transformer<? super E, ? extends E>)", "[]TransformedNavigableSet(NavigableSet<E>,Transformer<? super E, ? extends E>)", "[E]ceiling(E)", "[NavigableSet<E>]decorated()", "[Iterator<E>]descendingIterator()", "[NavigableSet<E>]descendingSet()", "[E]floor(E)", "[NavigableSet<E>]headSet(E,boolean)", "[E]higher(E)", "[E]lower(E)", "[E]pollFirst()", "[E]pollLast()", "[NavigableSet<E>]subSet(E,boolean,E,boolean)", "[NavigableSet<E>]tailSet(E,boolean)"], "method_uris": ["src/main/java/org/apache/commons/collections4/set/TransformedNavigableSet.java.TransformedNavigableSet.[TransformedNavigableSet<E>]transformedNavigableSet(NavigableSet<E>,Transformer<? super E, ? extends E>)", "src/main/java/org/apache/commons/collections4/set/TransformedNavigableSet.java.TransformedNavigableSet.[TransformedNavigableSet<E>]transformingNavigableSet(NavigableSet<E>,Transformer<? super E, ? extends E>)", "src/main/java/org/apache/commons/collections4/set/TransformedNavigableSet.java.TransformedNavigableSet.[]TransformedNavigableSet(NavigableSet<E>,Transformer<? super E, ? extends E>)", "src/main/java/org/apache/commons/collections4/set/TransformedNavigableSet.java.TransformedNavigableSet.[E]ceiling(E)", "src/main/java/org/apache/commons/collections4/set/TransformedNavigableSet.java.TransformedNavigableSet.[NavigableSet<E>]decorated()", "src/main/java/org/apache/commons/collections4/set/TransformedNavigableSet.java.TransformedNavigableSet.[Iterator<E>]descendingIterator()", "src/main/java/org/apache/commons/collections4/set/TransformedNavigableSet.java.TransformedNavigableSet.[NavigableSet<E>]descendingSet()", "src/main/java/org/apache/commons/collections4/set/TransformedNavigableSet.java.TransformedNavigableSet.[E]floor(E)", "src/main/java/org/apache/commons/collections4/set/TransformedNavigableSet.java.TransformedNavigableSet.[NavigableSet<E>]headSet(E,boolean)", "src/main/java/org/apache/commons/collections4/set/TransformedNavigableSet.java.TransformedNavigableSet.[E]higher(E)", "src/main/java/org/apache/commons/collections4/set/TransformedNavigableSet.java.TransformedNavigableSet.[E]lower(E)", "src/main/java/org/apache/commons/collections4/set/TransformedNavigableSet.java.TransformedNavigableSet.[E]pollFirst()", "src/main/java/org/apache/commons/collections4/set/TransformedNavigableSet.java.TransformedNavigableSet.[E]pollLast()", "src/main/java/org/apache/commons/collections4/set/TransformedNavigableSet.java.TransformedNavigableSet.[NavigableSet<E>]subSet(E,boolean,E,boolean)", "src/main/java/org/apache/commons/collections4/set/TransformedNavigableSet.java.TransformedNavigableSet.[NavigableSet<E>]tailSet(E,boolean)"], "overrides": null, "attributes": [], "class_docstring": "\nDecorates another {@code NavigableSet} to transform objects that are added.\n<p>\nThe add methods are affected by this class.\nThus objects must be removed or searched for using their transformed form.\nFor example, if the transformation converts Strings to Integers, you must\nuse the Integer form to remove objects.\n</p>\n\n@param <E> the type of the elements in this set\n@since 4.1\n", "original_string": "public class TransformedNavigableSet<E> extends TransformedSortedSet<E> implements NavigableSet<E> {\n\n    /** Serialization version */\n    private static final long serialVersionUID = 20150528L;\n\n    /**\n     * Factory method to create a transforming navigable set that will transform\n     * existing contents of the specified navigable set.\n     * <p>\n     * If there are any elements already in the set being decorated, they\n     * will be transformed by this method.\n     * Contrast this with {@link #transformingNavigableSet(NavigableSet, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param set  the set to decorate, must not be null\n     * @param transformer  the transformer to use for conversion, must not be null\n     * @return a new transformed {@link NavigableSet}\n     * @throws NullPointerException if set or transformer is null\n     */\n    public static <E> TransformedNavigableSet<E> transformedNavigableSet(final NavigableSet<E> set,\n            final Transformer<? super E, ? extends E> transformer) {\n\n        final TransformedNavigableSet<E> decorated = new TransformedNavigableSet<>(set, transformer);\n        if (!set.isEmpty()) {\n            @SuppressWarnings(\"unchecked\") // set is type E\n            final E[] values = (E[]) set.toArray(); // NOPMD - false positive for generics\n            set.clear();\n            for (final E value : values) {\n                decorated.decorated().add(transformer.apply(value));\n            }\n        }\n        return decorated;\n    }\n\n    /**\n     * Factory method to create a transforming navigable set.\n     * <p>\n     * If there are any elements already in the set being decorated, they\n     * are NOT transformed.\n     * Contrast this with {@link #transformedNavigableSet(NavigableSet, Transformer)}.\n     *\n     * @param <E> the element type\n     * @param set  the set to decorate, must not be null\n     * @param transformer  the transformer to use for conversion, must not be null\n     * @return a new transformed {@link NavigableSet}\n     * @throws NullPointerException if set or transformer is null\n     */\n    public static <E> TransformedNavigableSet<E> transformingNavigableSet(final NavigableSet<E> set,\n            final Transformer<? super E, ? extends E> transformer) {\n        return new TransformedNavigableSet<>(set, transformer);\n    }\n\n    /**\n     * Constructor that wraps (not copies).\n     * <p>\n     * If there are any elements already in the set being decorated, they\n     * are NOT transformed.\n     *\n     * @param set  the set to decorate, must not be null\n     * @param transformer  the transformer to use for conversion, must not be null\n     * @throws NullPointerException if set or transformer is null\n     */\n    protected TransformedNavigableSet(final NavigableSet<E> set,\n                                      final Transformer<? super E, ? extends E> transformer) {\n        super(set, transformer);\n    }\n\n    @Override\n    public E ceiling(final E e) {\n        return decorated().ceiling(e);\n    }\n\n    /**\n     * Gets the decorated navigable set.\n     *\n     * @return the decorated navigable set\n     */\n    @Override\n    protected NavigableSet<E> decorated() {\n        return (NavigableSet<E>) super.decorated();\n    }\n\n    @Override\n    public Iterator<E> descendingIterator() {\n        return decorated().descendingIterator();\n    }\n\n    @Override\n    public NavigableSet<E> descendingSet() {\n        return transformingNavigableSet(decorated().descendingSet(), transformer);\n    }\n\n    @Override\n    public E floor(final E e) {\n        return decorated().floor(e);\n    }\n\n    @Override\n    public NavigableSet<E> headSet(final E toElement, final boolean inclusive) {\n        final NavigableSet<E> head = decorated().headSet(toElement, inclusive);\n        return transformingNavigableSet(head, transformer);\n    }\n\n    @Override\n    public E higher(final E e) {\n        return decorated().higher(e);\n    }\n\n    @Override\n    public E lower(final E e) {\n        return decorated().lower(e);\n    }\n\n    @Override\n    public E pollFirst() {\n        return decorated().pollFirst();\n    }\n\n    @Override\n    public E pollLast() {\n        return decorated().pollLast();\n    }\n\n    @Override\n    public NavigableSet<E> subSet(final E fromElement, final boolean fromInclusive, final E toElement,\n            final boolean toInclusive) {\n        final NavigableSet<E> sub = decorated().subSet(fromElement, fromInclusive, toElement, toInclusive);\n        return transformingNavigableSet(sub, transformer);\n    }\n\n    @Override\n    public NavigableSet<E> tailSet(final E fromElement, final boolean inclusive) {\n        final NavigableSet<E> tail = decorated().tailSet(fromElement, inclusive);\n        return transformingNavigableSet(tail, transformer);\n    }\n\n}", "super_interfaces": ["NavigableSet<E>"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 20150528L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 20150528L", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/set/ListOrderedSet.java.ListOrderedSet", "name": "ListOrderedSet", "file_path": "src/main/java/org/apache/commons/collections4/set/ListOrderedSet.java", "superclasses": "", "methods": ["[ListOrderedSet<E>]listOrderedSet(List<E>)", "[ListOrderedSet<E>]listOrderedSet(Set<E>)", "[ListOrderedSet<E>]listOrderedSet(Set<E>,List<E>)", "[]ListOrderedSet()", "[]ListOrderedSet(Set<E>)", "[]ListOrderedSet(Set<E>,List<E>)", "[boolean]add(E)", "[void]add(int,E)", "[boolean]addAll(Collection<? extends E>)", "[boolean]addAll(int,Collection<? extends E>)", "[List<E>]asList()", "[void]clear()", "[E]get(int)", "[int]indexOf(Object)", "[OrderedIterator<E>]iterator()", "[E]remove(int)", "[boolean]remove(Object)", "[boolean]removeAll(Collection<?>)", "[boolean]removeIf(Predicate<? super E>)", "[boolean]retainAll(Collection<?>)", "[Object[]]toArray()", "[T[]]toArray(T[])", "[String]toString()"], "method_uris": ["src/main/java/org/apache/commons/collections4/set/ListOrderedSet.java.ListOrderedSet.[ListOrderedSet<E>]listOrderedSet(List<E>)", "src/main/java/org/apache/commons/collections4/set/ListOrderedSet.java.ListOrderedSet.[ListOrderedSet<E>]listOrderedSet(Set<E>)", "src/main/java/org/apache/commons/collections4/set/ListOrderedSet.java.ListOrderedSet.[ListOrderedSet<E>]listOrderedSet(Set<E>,List<E>)", "src/main/java/org/apache/commons/collections4/set/ListOrderedSet.java.ListOrderedSet.[]ListOrderedSet()", "src/main/java/org/apache/commons/collections4/set/ListOrderedSet.java.ListOrderedSet.[]ListOrderedSet(Set<E>)", "src/main/java/org/apache/commons/collections4/set/ListOrderedSet.java.ListOrderedSet.[]ListOrderedSet(Set<E>,List<E>)", "src/main/java/org/apache/commons/collections4/set/ListOrderedSet.java.ListOrderedSet.[boolean]add(E)", "src/main/java/org/apache/commons/collections4/set/ListOrderedSet.java.ListOrderedSet.[void]add(int,E)", "src/main/java/org/apache/commons/collections4/set/ListOrderedSet.java.ListOrderedSet.[boolean]addAll(Collection<? extends E>)", "src/main/java/org/apache/commons/collections4/set/ListOrderedSet.java.ListOrderedSet.[boolean]addAll(int,Collection<? extends E>)", "src/main/java/org/apache/commons/collections4/set/ListOrderedSet.java.ListOrderedSet.[List<E>]asList()", "src/main/java/org/apache/commons/collections4/set/ListOrderedSet.java.ListOrderedSet.[void]clear()", "src/main/java/org/apache/commons/collections4/set/ListOrderedSet.java.ListOrderedSet.[E]get(int)", "src/main/java/org/apache/commons/collections4/set/ListOrderedSet.java.ListOrderedSet.[int]indexOf(Object)", "src/main/java/org/apache/commons/collections4/set/ListOrderedSet.java.ListOrderedSet.[OrderedIterator<E>]iterator()", "src/main/java/org/apache/commons/collections4/set/ListOrderedSet.java.ListOrderedSet.[E]remove(int)", "src/main/java/org/apache/commons/collections4/set/ListOrderedSet.java.ListOrderedSet.[boolean]remove(Object)", "src/main/java/org/apache/commons/collections4/set/ListOrderedSet.java.ListOrderedSet.[boolean]removeAll(Collection<?>)", "src/main/java/org/apache/commons/collections4/set/ListOrderedSet.java.ListOrderedSet.[boolean]removeIf(Predicate<? super E>)", "src/main/java/org/apache/commons/collections4/set/ListOrderedSet.java.ListOrderedSet.[boolean]retainAll(Collection<?>)", "src/main/java/org/apache/commons/collections4/set/ListOrderedSet.java.ListOrderedSet.[Object[]]toArray()", "src/main/java/org/apache/commons/collections4/set/ListOrderedSet.java.ListOrderedSet.[T[]]toArray(T[])", "src/main/java/org/apache/commons/collections4/set/ListOrderedSet.java.ListOrderedSet.[String]toString()"], "overrides": null, "attributes": [{"original_string": "    static class OrderedSetIterator<E>\n        extends AbstractIteratorDecorator<E>\n        implements OrderedIterator<E> {\n\n        /** Object we iterate on */\n        private final Collection<E> set;\n\n        /** Last object retrieved */\n        private E last;\n\n        private OrderedSetIterator(final ListIterator<E> iterator, final Collection<E> set) {\n            super(iterator);\n            this.set = set;\n        }\n\n        @Override\n        public boolean hasPrevious() {\n            return ((ListIterator<E>) getIterator()).hasPrevious();\n        }\n\n        @Override\n        public E next() {\n            last = getIterator().next();\n            return last;\n        }\n\n        @Override\n        public E previous() {\n            last = ((ListIterator<E>) getIterator()).previous();\n            return last;\n        }\n\n        @Override\n        public void remove() {\n            set.remove(last);\n            getIterator().remove();\n            last = null;\n        }\n    }", "definition": "    static class OrderedSetIterator<E>\n        extends AbstractIteratorDecorator<E>\n        implements OrderedIterator<E>", "class_docstring": "\nInternal iterator handle remove.\n", "name": "OrderedSetIterator", "super_interfaces": ["OrderedIterator<E>"], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "private final Collection<E> set;", "docstring": " Object we iterate on", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Collection<E>", "name": "set", "syntax_pass": true}, {"attribute_expression": "private E last;", "docstring": " Last object retrieved", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "E", "name": "last", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        private OrderedSetIterator(final ListIterator<E> iterator, final Collection<E> set) {\n            super(iterator);\n            this.set = set;\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "OrderedSetIterator", "params": [{"name": "iterator", "type": "ListIterator<E>"}, {"name": "set", "type": "Collection<E>"}], "body": "                                                                                            {\n            super(iterator);\n            this.set = set;\n        }", "signature": "private OrderedSetIterator(final ListIterator<E> iterator, final Collection<E> set)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean hasPrevious() {\n            return ((ListIterator<E>) getIterator()).hasPrevious();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasPrevious", "params": [], "body": "                                     {\n            return ((ListIterator<E>) getIterator()).hasPrevious();\n        }", "signature": "@Override\n        public boolean hasPrevious()"}, {"syntax_pass": true, "original_string": "        @Override\n        public E next() {\n            last = getIterator().next();\n            return last;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "E", "classes": []}, "name": "next", "params": [], "body": "                        {\n            last = getIterator().next();\n            return last;\n        }", "signature": "@Override\n        public E next()"}, {"syntax_pass": true, "original_string": "        @Override\n        public E previous() {\n            last = ((ListIterator<E>) getIterator()).previous();\n            return last;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "E", "classes": []}, "name": "previous", "params": [], "body": "                            {\n            last = ((ListIterator<E>) getIterator()).previous();\n            return last;\n        }", "signature": "@Override\n        public E previous()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void remove() {\n            set.remove(last);\n            getIterator().remove();\n            last = null;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "remove", "params": [], "body": "                             {\n            set.remove(last);\n            getIterator().remove();\n            last = null;\n        }", "signature": "@Override\n        public void remove()"}]}], "class_docstring": "\nDecorates another {@code Set} to ensure that the order of addition is\nretained and used by the iterator.\n<p>\nIf an object is added to the set for a second time, it will remain in the\noriginal position in the iteration. The order can be observed from the set\nvia the iterator or toArray methods.\n</p>\n<p>\nThe ListOrderedSet also has various useful direct methods. These include many\nfrom {@code List}, such as {@code get(int)},\n{@code remove(int)} and {@code indexOf(int)}. An unmodifiable\n{@code List} view of the set can be obtained via {@code asList()}.\n</p>\n<p>\nThis class cannot implement the {@code List} interface directly as\nvarious interface methods (notably equals/hashCode) are incompatible with a\nset.\n</p>\n<p>\nThis class is Serializable from Commons Collections 3.1.\n</p>\n\n@param <E> the type of the elements in this set\n@since 3.0\n", "original_string": "public class ListOrderedSet<E>\n    extends AbstractSerializableSetDecorator<E> {\n\n    /**\n     * Internal iterator handle remove.\n     */\n    static class OrderedSetIterator<E>\n        extends AbstractIteratorDecorator<E>\n        implements OrderedIterator<E> {\n\n        /** Object we iterate on */\n        private final Collection<E> set;\n\n        /** Last object retrieved */\n        private E last;\n\n        private OrderedSetIterator(final ListIterator<E> iterator, final Collection<E> set) {\n            super(iterator);\n            this.set = set;\n        }\n\n        @Override\n        public boolean hasPrevious() {\n            return ((ListIterator<E>) getIterator()).hasPrevious();\n        }\n\n        @Override\n        public E next() {\n            last = getIterator().next();\n            return last;\n        }\n\n        @Override\n        public E previous() {\n            last = ((ListIterator<E>) getIterator()).previous();\n            return last;\n        }\n\n        @Override\n        public void remove() {\n            set.remove(last);\n            getIterator().remove();\n            last = null;\n        }\n    }\n\n    /** Serialization version */\n    private static final long serialVersionUID = -228664372470420141L;\n\n    /**\n     * Factory method to create an ordered set using the supplied list to retain order.\n     * <p>\n     * A {@code HashSet} is used for the set behavior.\n     * <p>\n     * NOTE: If the list contains duplicates, the duplicates are removed,\n     * altering the specified list.\n     *\n     * @param <E> the element type\n     * @param list the list to decorate, must not be null\n     * @return a new ordered set\n     * @throws NullPointerException if list is null\n     * @since 4.0\n     */\n    public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list) {\n        Objects.requireNonNull(list, \"list\");\n        CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n        final Set<E> set = new HashSet<>(list);\n\n        return new ListOrderedSet<>(set, list);\n    }\n\n    /**\n     * Factory method to create an ordered set.\n     * <p>\n     * An {@code ArrayList} is used to retain order.\n     *\n     * @param <E> the element type\n     * @param set the set to decorate, must not be null\n     * @return a new ordered set\n     * @throws NullPointerException if set is null\n     * @since 4.0\n     */\n    public static <E> ListOrderedSet<E> listOrderedSet(final Set<E> set) {\n        return new ListOrderedSet<>(set);\n    }\n\n    /**\n     * Factory method to create an ordered set specifying the list and set to use.\n     * <p>\n     * The list and set must both be empty.\n     *\n     * @param <E> the element type\n     * @param set the set to decorate, must be empty and not null\n     * @param list the list to decorate, must be empty and not null\n     * @return a new ordered set\n     * @throws NullPointerException if set or list is null\n     * @throws IllegalArgumentException if either the set or list is not empty\n     * @since 4.0\n     */\n    public static <E> ListOrderedSet<E> listOrderedSet(final Set<E> set, final List<E> list) {\n        Objects.requireNonNull(set, \"set\");\n        Objects.requireNonNull(list, \"list\");\n        if (!set.isEmpty() || !list.isEmpty()) {\n            throw new IllegalArgumentException(\"Set and List must be empty\");\n        }\n        return new ListOrderedSet<>(set, list);\n    }\n\n    /** Internal list to hold the sequence of objects */\n    private final List<E> setOrder;\n\n    /**\n     * Constructs a new empty {@code ListOrderedSet} using a\n     * {@code HashSet} and an {@code ArrayList} internally.\n     *\n     * @since 3.1\n     */\n    public ListOrderedSet() {\n        super(new HashSet<>());\n        setOrder = new ArrayList<>();\n    }\n\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param set the set to decorate, must not be null\n     * @throws NullPointerException if set is null\n     */\n    protected ListOrderedSet(final Set<E> set) {\n        super(set);\n        setOrder = new ArrayList<>(set);\n    }\n\n    /**\n     * Constructor that wraps (not copies) the Set and specifies the list to\n     * use.\n     * <p>\n     * The set and list must both be correctly initialized to the same elements.\n     *\n     * @param set the set to decorate, must not be null\n     * @param list the list to decorate, must not be null\n     * @throws NullPointerException if set or list is null\n     */\n    protected ListOrderedSet(final Set<E> set, final List<E> list) {\n        super(set);\n        setOrder = Objects.requireNonNull(list, \"list\");\n    }\n\n    @Override\n    public boolean add(final E object) {\n        if (decorated().add(object)) {\n            setOrder.add(object);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Inserts the specified element at the specified position if it is not yet\n     * contained in this ordered set (optional operation). Shifts the element\n     * currently at this position and any subsequent elements to the right.\n     *\n     * @param index the index at which the element is to be inserted\n     * @param object the element to be inserted\n     * @see List#add(int, Object)\n     */\n    public void add(final int index, final E object) {\n        if (!contains(object)) {\n            decorated().add(object);\n            setOrder.add(index, object);\n        }\n    }\n\n    @Override\n    public boolean addAll(final Collection<? extends E> coll) {\n        boolean result = false;\n        for (final E e : coll) {\n            result |= add(e);\n        }\n        return result;\n    }\n\n    /**\n     * Inserts all elements in the specified collection not yet contained in the\n     * ordered set at the specified position (optional operation). Shifts the\n     * element currently at the position and all subsequent elements to the\n     * right.\n     *\n     * @param index the position to insert the elements\n     * @param coll the collection containing the elements to be inserted\n     * @return {@code true} if this ordered set changed as a result of the call\n     * @see List#addAll(int, Collection)\n     */\n    public boolean addAll(final int index, final Collection<? extends E> coll) {\n        boolean changed = false;\n        // collect all elements to be added for performance reasons\n        final List<E> toAdd = new ArrayList<>();\n        for (final E e : coll) {\n            if (contains(e)) {\n                continue;\n            }\n            decorated().add(e);\n            toAdd.add(e);\n            changed = true;\n        }\n\n        if (changed) {\n            setOrder.addAll(index, toAdd);\n        }\n\n        return changed;\n    }\n\n    /**\n     * Gets an unmodifiable view of the order of the Set.\n     *\n     * @return an unmodifiable list view\n     */\n    public List<E> asList() {\n        return UnmodifiableList.unmodifiableList(setOrder);\n    }\n\n    @Override\n    public void clear() {\n        decorated().clear();\n        setOrder.clear();\n    }\n\n    /**\n     * Returns the element at the specified position in this ordered set.\n     *\n     * @param index the position of the element in the ordered {@link Set}.\n     * @return the element at position {@code index}\n     * @see List#get(int)\n     */\n    public E get(final int index) {\n        return setOrder.get(index);\n    }\n\n    /**\n     * Returns the index of the first occurrence of the specified element in\n     * ordered set.\n     *\n     * @param object the element to search for\n     * @return the index of the first occurrence of the object, or {@code -1} if\n     *         this ordered set does not contain this object\n     * @see List#indexOf(Object)\n     */\n    public int indexOf(final Object object) {\n        return setOrder.indexOf(object);\n    }\n\n    @Override\n    public OrderedIterator<E> iterator() {\n        return new OrderedSetIterator<>(setOrder.listIterator(), decorated());\n    }\n\n    /**\n     * Removes the element at the specified position from the ordered set.\n     * Shifts any subsequent elements to the left.\n     *\n     * @param index the index of the element to be removed\n     * @return the element that has been remove from the ordered set\n     * @see List#remove(int)\n     */\n    public E remove(final int index) {\n        final E obj = setOrder.remove(index);\n        remove(obj);\n        return obj;\n    }\n\n    @Override\n    public boolean remove(final Object object) {\n        final boolean result = decorated().remove(object);\n        if (result) {\n            setOrder.remove(object);\n        }\n        return result;\n    }\n\n    @Override\n    public boolean removeAll(final Collection<?> coll) {\n        boolean result = false;\n        for (final Object name : coll) {\n            result |= remove(name);\n        }\n        return result;\n    }\n\n    /**\n     * @since 4.4\n     */\n    @Override\n    public boolean removeIf(final Predicate<? super E> filter) {\n        if (Objects.isNull(filter)) {\n            return false;\n        }\n        final boolean result = decorated().removeIf(filter);\n        if (result) {\n            setOrder.removeIf(filter);\n        }\n        return result;\n    }\n\n    /**\n     * {@inheritDoc}\n     * <p>\n     * This implementation iterates over the elements of this set, checking\n     * each element in turn to see if it's contained in {@code coll}.\n     * If it's not contained, it's removed from this set. As a consequence,\n     * it is advised to use a collection type for {@code coll} that provides\n     * a fast (e.g. O(1)) implementation of {@link Collection#contains(Object)}.\n     */\n    @Override\n    public boolean retainAll(final Collection<?> coll) {\n        final boolean result = decorated().retainAll(coll);\n        if (!result) {\n            return false;\n        }\n        if (decorated().isEmpty()) {\n            setOrder.clear();\n        } else {\n            setOrder.removeIf(e -> !decorated().contains(e));\n        }\n        return result;\n    }\n\n    @Override\n    public Object[] toArray() {\n        return setOrder.toArray();\n    }\n\n    @Override\n    public <T> T[] toArray(final T[] a) {\n        return setOrder.toArray(a);\n    }\n\n    /**\n     * Uses the underlying List's toString so that order is achieved. This means\n     * that the decorated Set's toString is not used, so any custom toStrings\n     * will be ignored.\n     *\n     * @return a string representation of the ordered set\n     */\n    // Fortunately List.toString and Set.toString look the same\n    @Override\n    public String toString() {\n        return setOrder.toString();\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = -228664372470420141L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -228664372470420141L", "syntax_pass": true}, {"attribute_expression": "private final List<E> setOrder;", "docstring": " Internal list to hold the sequence of objects", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<E>", "name": "setOrder", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/set/PredicatedSortedSet.java.PredicatedSortedSet", "name": "PredicatedSortedSet", "file_path": "src/main/java/org/apache/commons/collections4/set/PredicatedSortedSet.java", "superclasses": "", "methods": ["[PredicatedSortedSet<E>]predicatedSortedSet(SortedSet<E>,Predicate<? super E>)", "[]PredicatedSortedSet(SortedSet<E>,Predicate<? super E>)", "[Comparator<? super E>]comparator()", "[SortedSet<E>]decorated()", "[E]first()", "[SortedSet<E>]headSet(E)", "[E]last()", "[SortedSet<E>]subSet(E,E)", "[SortedSet<E>]tailSet(E)"], "method_uris": ["src/main/java/org/apache/commons/collections4/set/PredicatedSortedSet.java.PredicatedSortedSet.[PredicatedSortedSet<E>]predicatedSortedSet(SortedSet<E>,Predicate<? super E>)", "src/main/java/org/apache/commons/collections4/set/PredicatedSortedSet.java.PredicatedSortedSet.[]PredicatedSortedSet(SortedSet<E>,Predicate<? super E>)", "src/main/java/org/apache/commons/collections4/set/PredicatedSortedSet.java.PredicatedSortedSet.[Comparator<? super E>]comparator()", "src/main/java/org/apache/commons/collections4/set/PredicatedSortedSet.java.PredicatedSortedSet.[SortedSet<E>]decorated()", "src/main/java/org/apache/commons/collections4/set/PredicatedSortedSet.java.PredicatedSortedSet.[E]first()", "src/main/java/org/apache/commons/collections4/set/PredicatedSortedSet.java.PredicatedSortedSet.[SortedSet<E>]headSet(E)", "src/main/java/org/apache/commons/collections4/set/PredicatedSortedSet.java.PredicatedSortedSet.[E]last()", "src/main/java/org/apache/commons/collections4/set/PredicatedSortedSet.java.PredicatedSortedSet.[SortedSet<E>]subSet(E,E)", "src/main/java/org/apache/commons/collections4/set/PredicatedSortedSet.java.PredicatedSortedSet.[SortedSet<E>]tailSet(E)"], "overrides": null, "attributes": [], "class_docstring": "\nDecorates another {@code SortedSet} to validate that all additions\nmatch a specified predicate.\n<p>\nThis set exists to provide validation for the decorated set.\nIt is normally created to decorate an empty set.\nIf an object cannot be added to the set, an IllegalArgumentException is thrown.\n</p>\n<p>\nOne usage would be to ensure that no null entries are added to the set.\n</p>\n<pre>\nSortedSet set =\n  PredicatedSortedSet.predicatedSortedSet(new TreeSet(),\n                                          NotNullPredicate.notNullPredicate());\n</pre>\n<p>\nThis class is Serializable from Commons Collections 3.1.\n</p>\n\n@param <E> the type of the elements in this set\n@since 3.0\n", "original_string": "public class PredicatedSortedSet<E> extends PredicatedSet<E> implements SortedSet<E> {\n\n    /** Serialization version */\n    private static final long serialVersionUID = -9110948148132275052L;\n\n    /**\n     * Factory method to create a predicated (validating) sorted set.\n     * <p>\n     * If there are any elements already in the set being decorated, they\n     * are validated.\n     *\n     * @param <E> the element type\n     * @param set  the set to decorate, must not be null\n     * @param predicate  the predicate to use for validation, must not be null\n     * @return a new predicated sorted set.\n     * @throws NullPointerException if set or predicate is null\n     * @throws IllegalArgumentException if the set contains invalid elements\n     * @since 4.0\n     */\n    public static <E> PredicatedSortedSet<E> predicatedSortedSet(final SortedSet<E> set,\n                                                                 final Predicate<? super E> predicate) {\n        return new PredicatedSortedSet<>(set, predicate);\n    }\n\n    /**\n     * Constructor that wraps (not copies).\n     * <p>\n     * If there are any elements already in the set being decorated, they\n     * are validated.\n     *\n     * @param set  the set to decorate, must not be null\n     * @param predicate  the predicate to use for validation, must not be null\n     * @throws NullPointerException if set or predicate is null\n     * @throws IllegalArgumentException if the set contains invalid elements\n     */\n    protected PredicatedSortedSet(final SortedSet<E> set, final Predicate<? super E> predicate) {\n        super(set, predicate);\n    }\n\n    @Override\n    public Comparator<? super E> comparator() {\n        return decorated().comparator();\n    }\n\n    /**\n     * Gets the sorted set being decorated.\n     *\n     * @return the decorated sorted set\n     */\n    @Override\n    protected SortedSet<E> decorated() {\n        return (SortedSet<E>) super.decorated();\n    }\n\n    @Override\n    public E first() {\n        return decorated().first();\n    }\n\n    @Override\n    public SortedSet<E> headSet(final E toElement) {\n        final SortedSet<E> head = decorated().headSet(toElement);\n        return new PredicatedSortedSet<>(head, predicate);\n    }\n\n    @Override\n    public E last() {\n        return decorated().last();\n    }\n\n    @Override\n    public SortedSet<E> subSet(final E fromElement, final E toElement) {\n        final SortedSet<E> sub = decorated().subSet(fromElement, toElement);\n        return new PredicatedSortedSet<>(sub, predicate);\n    }\n\n    @Override\n    public SortedSet<E> tailSet(final E fromElement) {\n        final SortedSet<E> tail = decorated().tailSet(fromElement);\n        return new PredicatedSortedSet<>(tail, predicate);\n    }\n\n}", "super_interfaces": ["SortedSet<E>"], "fields": [{"attribute_expression": "private static final long serialVersionUID = -9110948148132275052L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -9110948148132275052L", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/set/MapBackedSet.java.MapBackedSet", "name": "MapBackedSet", "file_path": "src/main/java/org/apache/commons/collections4/set/MapBackedSet.java", "superclasses": "", "methods": ["[MapBackedSet<E, V>]mapBackedSet(Map<E, ? super V>)", "[MapBackedSet<E, V>]mapBackedSet(Map<E, ? super V>,V)", "[]MapBackedSet(Map<E, ? super V>,V)", "[boolean]add(E)", "[boolean]addAll(Collection<? extends E>)", "[void]clear()", "[boolean]contains(Object)", "[boolean]containsAll(Collection<?>)", "[boolean]equals(Object)", "[int]hashCode()", "[boolean]isEmpty()", "[Iterator<E>]iterator()", "[boolean]remove(Object)", "[boolean]removeAll(Collection<?>)", "[boolean]removeIf(Predicate<? super E>)", "[boolean]retainAll(Collection<?>)", "[int]size()", "[Object[]]toArray()", "[T[]]toArray(T[])"], "method_uris": ["src/main/java/org/apache/commons/collections4/set/MapBackedSet.java.MapBackedSet.[MapBackedSet<E, V>]mapBackedSet(Map<E, ? super V>)", "src/main/java/org/apache/commons/collections4/set/MapBackedSet.java.MapBackedSet.[MapBackedSet<E, V>]mapBackedSet(Map<E, ? super V>,V)", "src/main/java/org/apache/commons/collections4/set/MapBackedSet.java.MapBackedSet.[]MapBackedSet(Map<E, ? super V>,V)", "src/main/java/org/apache/commons/collections4/set/MapBackedSet.java.MapBackedSet.[boolean]add(E)", "src/main/java/org/apache/commons/collections4/set/MapBackedSet.java.MapBackedSet.[boolean]addAll(Collection<? extends E>)", "src/main/java/org/apache/commons/collections4/set/MapBackedSet.java.MapBackedSet.[void]clear()", "src/main/java/org/apache/commons/collections4/set/MapBackedSet.java.MapBackedSet.[boolean]contains(Object)", "src/main/java/org/apache/commons/collections4/set/MapBackedSet.java.MapBackedSet.[boolean]containsAll(Collection<?>)", "src/main/java/org/apache/commons/collections4/set/MapBackedSet.java.MapBackedSet.[boolean]equals(Object)", "src/main/java/org/apache/commons/collections4/set/MapBackedSet.java.MapBackedSet.[int]hashCode()", "src/main/java/org/apache/commons/collections4/set/MapBackedSet.java.MapBackedSet.[boolean]isEmpty()", "src/main/java/org/apache/commons/collections4/set/MapBackedSet.java.MapBackedSet.[Iterator<E>]iterator()", "src/main/java/org/apache/commons/collections4/set/MapBackedSet.java.MapBackedSet.[boolean]remove(Object)", "src/main/java/org/apache/commons/collections4/set/MapBackedSet.java.MapBackedSet.[boolean]removeAll(Collection<?>)", "src/main/java/org/apache/commons/collections4/set/MapBackedSet.java.MapBackedSet.[boolean]removeIf(Predicate<? super E>)", "src/main/java/org/apache/commons/collections4/set/MapBackedSet.java.MapBackedSet.[boolean]retainAll(Collection<?>)", "src/main/java/org/apache/commons/collections4/set/MapBackedSet.java.MapBackedSet.[int]size()", "src/main/java/org/apache/commons/collections4/set/MapBackedSet.java.MapBackedSet.[Object[]]toArray()", "src/main/java/org/apache/commons/collections4/set/MapBackedSet.java.MapBackedSet.[T[]]toArray(T[])"], "overrides": null, "attributes": [], "class_docstring": "\nDecorates a {@code Map} to obtain {@code Set} behavior.\n<p>\nThis class is used to create a {@code Set} with the same properties as\nthe key set of any map. Thus, a ReferenceSet can be created by wrapping a\n{@code ReferenceMap} in an instance of this class.\n</p>\n<p>\nMost map implementation can be used to create a set by passing in dummy values.\nExceptions include {@code BidiMap} implementations, as they require unique values.\n</p>\n\n@param <E> the type of the elements in this set\n@param <V> the dummy value type in this map\n@since 3.1\n", "original_string": "public final class MapBackedSet<E, V> implements Set<E>, Serializable {\n\n    /** Serialization version */\n    private static final long serialVersionUID = 6723912213766056587L;\n\n    /**\n     * Factory method to create a set from a map.\n     *\n     * @param <E> the element type\n     * @param <V> the dummy value type in the map\n     * @param map  the map to decorate, must not be null\n     * @return a new map backed set\n     * @throws NullPointerException if map is null\n     * @since 4.0\n     */\n    public static <E, V> MapBackedSet<E, V> mapBackedSet(final Map<E, ? super V> map) {\n        return mapBackedSet(map, null);\n    }\n\n    /**\n     * Factory method to create a set from a map.\n     *\n     * @param <E> the element type\n     * @param <V> the dummy value type in the map\n     * @param map  the map to decorate, must not be null\n     * @param dummyValue  the dummy value to use\n     * @return a new map backed set\n     * @throws NullPointerException if map is null\n     * @since 4.0\n     */\n    public static <E, V> MapBackedSet<E, V> mapBackedSet(final Map<E, ? super V> map, final V dummyValue) {\n        return new MapBackedSet<>(map, dummyValue);\n    }\n\n    /** The map being used as the backing store */\n    private final Map<E, ? super V> map;\n\n    /** The dummyValue to use */\n    private final V dummyValue;\n\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param map  the map to decorate, must not be null\n     * @param dummyValue  the dummy value to use\n     * @throws NullPointerException if map is null\n     */\n    private MapBackedSet(final Map<E, ? super V> map, final V dummyValue) {\n        this.map = Objects.requireNonNull(map, \"map\");\n        this.dummyValue = dummyValue;\n    }\n\n    @Override\n    public boolean add(final E obj) {\n        final int size = map.size();\n        map.put(obj, dummyValue);\n        return map.size() != size;\n    }\n\n    @Override\n    public boolean addAll(final Collection<? extends E> coll) {\n        final int size = map.size();\n        for (final E e : coll) {\n            map.put(e, dummyValue);\n        }\n        return map.size() != size;\n    }\n\n    @Override\n    public void clear() {\n        map.clear();\n    }\n\n    @Override\n    public boolean contains(final Object obj) {\n        return map.containsKey(obj);\n    }\n\n    @Override\n    public boolean containsAll(final Collection<?> coll) {\n        return map.keySet().containsAll(coll);\n    }\n\n    @Override\n    public boolean equals(final Object obj) {\n        return map.keySet().equals(obj);\n    }\n\n    @Override\n    public int hashCode() {\n        return map.keySet().hashCode();\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return map.isEmpty();\n    }\n\n    @Override\n    public Iterator<E> iterator() {\n        return map.keySet().iterator();\n    }\n\n    @Override\n    public boolean remove(final Object obj) {\n        final int size = map.size();\n        map.remove(obj);\n        return map.size() != size;\n    }\n\n    @Override\n    public boolean removeAll(final Collection<?> coll) {\n        return map.keySet().removeAll(coll);\n    }\n\n    /**\n     * @since 4.4\n     */\n    @Override\n    public boolean removeIf(final Predicate<? super E> filter) {\n        return map.keySet().removeIf(filter);\n    }\n\n    @Override\n    public boolean retainAll(final Collection<?> coll) {\n        return map.keySet().retainAll(coll);\n    }\n\n    @Override\n    public int size() {\n        return map.size();\n    }\n\n    @Override\n    public Object[] toArray() {\n        return map.keySet().toArray();\n    }\n\n    @Override\n    public <T> T[] toArray(final T[] array) {\n        return map.keySet().toArray(array);\n    }\n\n}", "super_interfaces": ["Set<E>", "Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 6723912213766056587L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 6723912213766056587L", "syntax_pass": true}, {"attribute_expression": "private final Map<E, ? super V> map;", "docstring": " The map being used as the backing store", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Map<E, ? super V>", "name": "map", "syntax_pass": true}, {"attribute_expression": "private final V dummyValue;", "docstring": " The dummyValue to use", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "V", "name": "dummyValue", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/set/UnmodifiableSortedSet.java.UnmodifiableSortedSet", "name": "UnmodifiableSortedSet", "file_path": "src/main/java/org/apache/commons/collections4/set/UnmodifiableSortedSet.java", "superclasses": "", "methods": ["[SortedSet<E>]unmodifiableSortedSet(SortedSet<E>)", "[]UnmodifiableSortedSet(SortedSet<E>)", "[boolean]add(E)", "[boolean]addAll(Collection<? extends E>)", "[void]clear()", "[SortedSet<E>]headSet(E)", "[Iterator<E>]iterator()", "[void]readObject(ObjectInputStream)", "[boolean]remove(Object)", "[boolean]removeAll(Collection<?>)", "[boolean]removeIf(Predicate<? super E>)", "[boolean]retainAll(Collection<?>)", "[SortedSet<E>]subSet(E,E)", "[SortedSet<E>]tailSet(E)", "[void]writeObject(ObjectOutputStream)"], "method_uris": ["src/main/java/org/apache/commons/collections4/set/UnmodifiableSortedSet.java.UnmodifiableSortedSet.[SortedSet<E>]unmodifiableSortedSet(SortedSet<E>)", "src/main/java/org/apache/commons/collections4/set/UnmodifiableSortedSet.java.UnmodifiableSortedSet.[]UnmodifiableSortedSet(SortedSet<E>)", "src/main/java/org/apache/commons/collections4/set/UnmodifiableSortedSet.java.UnmodifiableSortedSet.[boolean]add(E)", "src/main/java/org/apache/commons/collections4/set/UnmodifiableSortedSet.java.UnmodifiableSortedSet.[boolean]addAll(Collection<? extends E>)", "src/main/java/org/apache/commons/collections4/set/UnmodifiableSortedSet.java.UnmodifiableSortedSet.[void]clear()", "src/main/java/org/apache/commons/collections4/set/UnmodifiableSortedSet.java.UnmodifiableSortedSet.[SortedSet<E>]headSet(E)", "src/main/java/org/apache/commons/collections4/set/UnmodifiableSortedSet.java.UnmodifiableSortedSet.[Iterator<E>]iterator()", "src/main/java/org/apache/commons/collections4/set/UnmodifiableSortedSet.java.UnmodifiableSortedSet.[void]readObject(ObjectInputStream)", "src/main/java/org/apache/commons/collections4/set/UnmodifiableSortedSet.java.UnmodifiableSortedSet.[boolean]remove(Object)", "src/main/java/org/apache/commons/collections4/set/UnmodifiableSortedSet.java.UnmodifiableSortedSet.[boolean]removeAll(Collection<?>)", "src/main/java/org/apache/commons/collections4/set/UnmodifiableSortedSet.java.UnmodifiableSortedSet.[boolean]removeIf(Predicate<? super E>)", "src/main/java/org/apache/commons/collections4/set/UnmodifiableSortedSet.java.UnmodifiableSortedSet.[boolean]retainAll(Collection<?>)", "src/main/java/org/apache/commons/collections4/set/UnmodifiableSortedSet.java.UnmodifiableSortedSet.[SortedSet<E>]subSet(E,E)", "src/main/java/org/apache/commons/collections4/set/UnmodifiableSortedSet.java.UnmodifiableSortedSet.[SortedSet<E>]tailSet(E)", "src/main/java/org/apache/commons/collections4/set/UnmodifiableSortedSet.java.UnmodifiableSortedSet.[void]writeObject(ObjectOutputStream)"], "overrides": null, "attributes": [], "class_docstring": "\nDecorates another {@code SortedSet} to ensure it can't be altered.\n<p>\nThis class is Serializable from Commons Collections 3.1.\n</p>\n<p>\nAttempts to modify it will result in an UnsupportedOperationException.\n</p>\n\n@param <E> the type of the elements in this set\n@since 3.0\n", "original_string": "public final class UnmodifiableSortedSet<E>\n        extends AbstractSortedSetDecorator<E>\n        implements Unmodifiable {\n\n    /** Serialization version */\n    private static final long serialVersionUID = -725356885467962424L;\n\n    /**\n     * Factory method to create an unmodifiable set.\n     *\n     * @param <E> the element type\n     * @param set  the set to decorate, must not be null\n     * @return a new unmodifiable {@link SortedSet}\n     * @throws NullPointerException if set is null\n     * @since 4.0\n     */\n    public static <E> SortedSet<E> unmodifiableSortedSet(final SortedSet<E> set) {\n        if (set instanceof Unmodifiable) {\n            return set;\n        }\n        return new UnmodifiableSortedSet<>(set);\n    }\n\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param set  the set to decorate, must not be null\n     * @throws NullPointerException if set is null\n     */\n    private UnmodifiableSortedSet(final SortedSet<E> set) {\n        super(set);\n    }\n\n    @Override\n    public boolean add(final E object) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public boolean addAll(final Collection<? extends E> coll) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public void clear() {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public SortedSet<E> headSet(final E toElement) {\n        final SortedSet<E> head = decorated().headSet(toElement);\n        return unmodifiableSortedSet(head);\n    }\n\n    @Override\n    public Iterator<E> iterator() {\n        return UnmodifiableIterator.unmodifiableIterator(decorated().iterator());\n    }\n\n    /**\n     * Deserializes the collection in using a custom routine.\n     *\n     * @param in  the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded\n     */\n    @SuppressWarnings(\"unchecked\") // (1) should only fail if input stream is incorrect\n    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        setCollection((Collection<E>) in.readObject()); // (1)\n    }\n\n    @Override\n    public boolean remove(final Object object) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public boolean removeAll(final Collection<?> coll) {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * @since 4.4\n     */\n    @Override\n    public boolean removeIf(final Predicate<? super E> filter) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public boolean retainAll(final Collection<?> coll) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public SortedSet<E> subSet(final E fromElement, final E toElement) {\n        final SortedSet<E> sub = decorated().subSet(fromElement, toElement);\n        return unmodifiableSortedSet(sub);\n    }\n\n    @Override\n    public SortedSet<E> tailSet(final E fromElement) {\n        final SortedSet<E> tail = decorated().tailSet(fromElement);\n        return unmodifiableSortedSet(tail);\n    }\n\n    /**\n     * Serializes this object to an ObjectOutputStream.\n     *\n     * @param out the target ObjectOutputStream.\n     * @throws IOException thrown when an I/O errors occur writing to the target stream.\n     */\n    private void writeObject(final ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        out.writeObject(decorated());\n    }\n\n}", "super_interfaces": ["Unmodifiable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = -725356885467962424L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -725356885467962424L", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/set/UnmodifiableSet.java.UnmodifiableSet", "name": "UnmodifiableSet", "file_path": "src/main/java/org/apache/commons/collections4/set/UnmodifiableSet.java", "superclasses": "", "methods": ["[Set<E>]unmodifiableSet(Set<? extends E>)", "[]UnmodifiableSet(Set<? extends E>)", "[boolean]add(E)", "[boolean]addAll(Collection<? extends E>)", "[void]clear()", "[Iterator<E>]iterator()", "[boolean]remove(Object)", "[boolean]removeAll(Collection<?>)", "[boolean]removeIf(Predicate<? super E>)", "[boolean]retainAll(Collection<?>)"], "method_uris": ["src/main/java/org/apache/commons/collections4/set/UnmodifiableSet.java.UnmodifiableSet.[Set<E>]unmodifiableSet(Set<? extends E>)", "src/main/java/org/apache/commons/collections4/set/UnmodifiableSet.java.UnmodifiableSet.[]UnmodifiableSet(Set<? extends E>)", "src/main/java/org/apache/commons/collections4/set/UnmodifiableSet.java.UnmodifiableSet.[boolean]add(E)", "src/main/java/org/apache/commons/collections4/set/UnmodifiableSet.java.UnmodifiableSet.[boolean]addAll(Collection<? extends E>)", "src/main/java/org/apache/commons/collections4/set/UnmodifiableSet.java.UnmodifiableSet.[void]clear()", "src/main/java/org/apache/commons/collections4/set/UnmodifiableSet.java.UnmodifiableSet.[Iterator<E>]iterator()", "src/main/java/org/apache/commons/collections4/set/UnmodifiableSet.java.UnmodifiableSet.[boolean]remove(Object)", "src/main/java/org/apache/commons/collections4/set/UnmodifiableSet.java.UnmodifiableSet.[boolean]removeAll(Collection<?>)", "src/main/java/org/apache/commons/collections4/set/UnmodifiableSet.java.UnmodifiableSet.[boolean]removeIf(Predicate<? super E>)", "src/main/java/org/apache/commons/collections4/set/UnmodifiableSet.java.UnmodifiableSet.[boolean]retainAll(Collection<?>)"], "overrides": null, "attributes": [], "class_docstring": "\nDecorates another {@code Set} to ensure it can't be altered.\n<p>\nThis class is Serializable from Commons Collections 3.1.\n</p>\n<p>\nAttempts to modify it will result in an UnsupportedOperationException.\n</p>\n\n@param <E> the type of the elements in this set\n@since 3.0\n", "original_string": "public final class UnmodifiableSet<E>\n        extends AbstractSerializableSetDecorator<E>\n        implements Unmodifiable {\n\n    /** Serialization version */\n    private static final long serialVersionUID = 6499119872185240161L;\n\n    /**\n     * Factory method to create an unmodifiable set.\n     *\n     * @param <E> the element type\n     * @param set  the set to decorate, must not be null\n     * @return a new unmodifiable set\n     * @throws NullPointerException if set is null\n     * @since 4.0\n     */\n    public static <E> Set<E> unmodifiableSet(final Set<? extends E> set) {\n        if (set instanceof Unmodifiable) {\n            @SuppressWarnings(\"unchecked\") // safe to upcast\n            final Set<E> tmpSet = (Set<E>) set;\n            return tmpSet;\n        }\n        return new UnmodifiableSet<>(set);\n    }\n\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param set  the set to decorate, must not be null\n     * @throws NullPointerException if set is null\n     */\n    @SuppressWarnings(\"unchecked\") // safe to upcast\n    private UnmodifiableSet(final Set<? extends E> set) {\n        super((Set<E>) set);\n    }\n\n    @Override\n    public boolean add(final E object) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public boolean addAll(final Collection<? extends E> coll) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public void clear() {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public Iterator<E> iterator() {\n        return UnmodifiableIterator.unmodifiableIterator(decorated().iterator());\n    }\n\n    @Override\n    public boolean remove(final Object object) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public boolean removeAll(final Collection<?> coll) {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * @since 4.4\n     */\n    @Override\n    public boolean removeIf(final Predicate<? super E> filter) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public boolean retainAll(final Collection<?> coll) {\n        throw new UnsupportedOperationException();\n    }\n\n}", "super_interfaces": ["Unmodifiable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 6499119872185240161L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 6499119872185240161L", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/list/FixedSizeList.java.FixedSizeList", "name": "FixedSizeList", "file_path": "src/main/java/org/apache/commons/collections4/list/FixedSizeList.java", "superclasses": "", "methods": ["[FixedSizeList<E>]fixedSizeList(List<E>)", "[UnsupportedOperationException]unsupportedOperationException()", "[]FixedSizeList(List<E>)", "[boolean]add(E)", "[void]add(int,E)", "[boolean]addAll(Collection<? extends E>)", "[boolean]addAll(int,Collection<? extends E>)", "[void]clear()", "[E]get(int)", "[int]indexOf(Object)", "[boolean]isFull()", "[Iterator<E>]iterator()", "[int]lastIndexOf(Object)", "[ListIterator<E>]listIterator()", "[ListIterator<E>]listIterator(int)", "[int]maxSize()", "[E]remove(int)", "[boolean]remove(Object)", "[boolean]removeAll(Collection<?>)", "[boolean]removeIf(Predicate<? super E>)", "[boolean]retainAll(Collection<?>)", "[E]set(int,E)", "[List<E>]subList(int,int)"], "method_uris": ["src/main/java/org/apache/commons/collections4/list/FixedSizeList.java.FixedSizeList.[FixedSizeList<E>]fixedSizeList(List<E>)", "src/main/java/org/apache/commons/collections4/list/FixedSizeList.java.FixedSizeList.[UnsupportedOperationException]unsupportedOperationException()", "src/main/java/org/apache/commons/collections4/list/FixedSizeList.java.FixedSizeList.[]FixedSizeList(List<E>)", "src/main/java/org/apache/commons/collections4/list/FixedSizeList.java.FixedSizeList.[boolean]add(E)", "src/main/java/org/apache/commons/collections4/list/FixedSizeList.java.FixedSizeList.[void]add(int,E)", "src/main/java/org/apache/commons/collections4/list/FixedSizeList.java.FixedSizeList.[boolean]addAll(Collection<? extends E>)", "src/main/java/org/apache/commons/collections4/list/FixedSizeList.java.FixedSizeList.[boolean]addAll(int,Collection<? extends E>)", "src/main/java/org/apache/commons/collections4/list/FixedSizeList.java.FixedSizeList.[void]clear()", "src/main/java/org/apache/commons/collections4/list/FixedSizeList.java.FixedSizeList.[E]get(int)", "src/main/java/org/apache/commons/collections4/list/FixedSizeList.java.FixedSizeList.[int]indexOf(Object)", "src/main/java/org/apache/commons/collections4/list/FixedSizeList.java.FixedSizeList.[boolean]isFull()", "src/main/java/org/apache/commons/collections4/list/FixedSizeList.java.FixedSizeList.[Iterator<E>]iterator()", "src/main/java/org/apache/commons/collections4/list/FixedSizeList.java.FixedSizeList.[int]lastIndexOf(Object)", "src/main/java/org/apache/commons/collections4/list/FixedSizeList.java.FixedSizeList.[ListIterator<E>]listIterator()", "src/main/java/org/apache/commons/collections4/list/FixedSizeList.java.FixedSizeList.[ListIterator<E>]listIterator(int)", "src/main/java/org/apache/commons/collections4/list/FixedSizeList.java.FixedSizeList.[int]maxSize()", "src/main/java/org/apache/commons/collections4/list/FixedSizeList.java.FixedSizeList.[E]remove(int)", "src/main/java/org/apache/commons/collections4/list/FixedSizeList.java.FixedSizeList.[boolean]remove(Object)", "src/main/java/org/apache/commons/collections4/list/FixedSizeList.java.FixedSizeList.[boolean]removeAll(Collection<?>)", "src/main/java/org/apache/commons/collections4/list/FixedSizeList.java.FixedSizeList.[boolean]removeIf(Predicate<? super E>)", "src/main/java/org/apache/commons/collections4/list/FixedSizeList.java.FixedSizeList.[boolean]retainAll(Collection<?>)", "src/main/java/org/apache/commons/collections4/list/FixedSizeList.java.FixedSizeList.[E]set(int,E)", "src/main/java/org/apache/commons/collections4/list/FixedSizeList.java.FixedSizeList.[List<E>]subList(int,int)"], "overrides": null, "attributes": [{"original_string": "    private final class FixedSizeListIterator extends AbstractListIteratorDecorator<E> {\n        protected FixedSizeListIterator(final ListIterator<E> iterator) {\n            super(iterator);\n        }\n        @Override\n        public void add(final Object object) {\n            throw unsupportedOperationException();\n        }\n        @Override\n        public void remove() {\n            throw unsupportedOperationException();\n        }\n    }", "definition": "    private final class FixedSizeListIterator extends AbstractListIteratorDecorator<E>", "class_docstring": "\nList iterator that only permits changes via set()\n", "name": "FixedSizeListIterator", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        protected FixedSizeListIterator(final ListIterator<E> iterator) {\n            super(iterator);\n        }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "name": "FixedSizeListIterator", "params": [{"name": "iterator", "type": "ListIterator<E>"}], "body": "                                                                        {\n            super(iterator);\n        }", "signature": "protected FixedSizeListIterator(final ListIterator<E> iterator)"}, {"syntax_pass": true, "original_string": "        @Override\n        public void add(final Object object) {\n            throw unsupportedOperationException();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "add", "params": [{"name": "object", "type": "Object"}], "body": "                                             {\n            throw unsupportedOperationException();\n        }", "signature": "@Override\n        public void add(final Object object)"}, {"syntax_pass": true, "original_string": "        @Override\n        public void remove() {\n            throw unsupportedOperationException();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "remove", "params": [], "body": "                             {\n            throw unsupportedOperationException();\n        }", "signature": "@Override\n        public void remove()"}]}], "class_docstring": "\nDecorates another {@code List} to fix the size preventing add/remove.\n<p>\nThe add, remove, clear and retain operations are unsupported.\nThe set method is allowed (as it doesn't change the list size).\n</p>\n<p>\nNOTE:\nModifying the decorated list directly would results in influencing the outcome\nof method calls on this object. For example, the bounds of this list would reflect\na newly added object to the underlying list.\n</p>\n<p>\nThis class is Serializable from Commons Collections 3.1.\n</p>\n\n@param <E> the type of elements in this collection\n@since 3.0\n", "original_string": "public class FixedSizeList<E>\n        extends AbstractSerializableListDecorator<E>\n        implements BoundedCollection<E> {\n\n    /**\n     * List iterator that only permits changes via set()\n     */\n    private final class FixedSizeListIterator extends AbstractListIteratorDecorator<E> {\n        protected FixedSizeListIterator(final ListIterator<E> iterator) {\n            super(iterator);\n        }\n        @Override\n        public void add(final Object object) {\n            throw unsupportedOperationException();\n        }\n        @Override\n        public void remove() {\n            throw unsupportedOperationException();\n        }\n    }\n\n    /** Serialization version */\n    private static final long serialVersionUID = -2218010673611160319L;\n\n    /**\n     * Factory method to create a fixed size list.\n     *\n     * @param <E> the type of the elements in the list\n     * @param list  the list to decorate, must not be null\n     * @return a new fixed size list\n     * @throws NullPointerException if list is null\n     * @since 4.0\n     */\n    public static <E> FixedSizeList<E> fixedSizeList(final List<E> list) {\n        return new FixedSizeList<>(list);\n    }\n\n    private static UnsupportedOperationException unsupportedOperationException() {\n        return new UnsupportedOperationException(\"List is fixed size\");\n    }\n\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param list  the list to decorate, must not be null\n     * @throws NullPointerException if list is null\n     */\n    protected FixedSizeList(final List<E> list) {\n        super(list);\n    }\n\n    @Override\n    public boolean add(final E object) {\n        throw unsupportedOperationException();\n    }\n\n    @Override\n    public void add(final int index, final E object) {\n        throw unsupportedOperationException();\n    }\n\n    @Override\n    public boolean addAll(final Collection<? extends E> coll) {\n        throw unsupportedOperationException();\n    }\n\n    @Override\n    public boolean addAll(final int index, final Collection<? extends E> coll) {\n        throw unsupportedOperationException();\n    }\n\n    @Override\n    public void clear() {\n        throw unsupportedOperationException();\n    }\n\n    @Override\n    public E get(final int index) {\n        return decorated().get(index);\n    }\n\n    @Override\n    public int indexOf(final Object object) {\n        return decorated().indexOf(object);\n    }\n\n    @Override\n    public boolean isFull() {\n        return true;\n    }\n\n    @Override\n    public Iterator<E> iterator() {\n        return UnmodifiableIterator.unmodifiableIterator(decorated().iterator());\n    }\n\n    @Override\n    public int lastIndexOf(final Object object) {\n        return decorated().lastIndexOf(object);\n    }\n\n    @Override\n    public ListIterator<E> listIterator() {\n        return new FixedSizeListIterator(decorated().listIterator(0));\n    }\n\n    @Override\n    public ListIterator<E> listIterator(final int index) {\n        return new FixedSizeListIterator(decorated().listIterator(index));\n    }\n\n    @Override\n    public int maxSize() {\n        return size();\n    }\n\n    @Override\n    public E remove(final int index) {\n        throw unsupportedOperationException();\n    }\n\n    @Override\n    public boolean remove(final Object object) {\n        throw unsupportedOperationException();\n    }\n\n    @Override\n    public boolean removeAll(final Collection<?> coll) {\n        throw unsupportedOperationException();\n    }\n\n    /**\n     * @since 4.4\n     */\n    @Override\n    public boolean removeIf(final Predicate<? super E> filter) {\n        throw unsupportedOperationException();\n    }\n\n    @Override\n    public boolean retainAll(final Collection<?> coll) {\n        throw unsupportedOperationException();\n    }\n\n    @Override\n    public E set(final int index, final E object) {\n        return decorated().set(index, object);\n    }\n\n    @Override\n    public List<E> subList(final int fromIndex, final int toIndex) {\n        final List<E> sub = decorated().subList(fromIndex, toIndex);\n        return new FixedSizeList<>(sub);\n    }\n\n}", "super_interfaces": ["BoundedCollection<E>"], "fields": [{"attribute_expression": "private static final long serialVersionUID = -2218010673611160319L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -2218010673611160319L", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/list/LazyList.java.LazyList", "name": "LazyList", "file_path": "src/main/java/org/apache/commons/collections4/list/LazyList.java", "superclasses": "", "methods": ["[LazyList<E>]lazyList(List<E>,Factory<? extends E>)", "[LazyList<E>]lazyList(List<E>,Transformer<Integer, ? extends E>)", "[]LazyList(List<E>,Factory<? extends E>)", "[]LazyList(List<E>,Transformer<Integer, ? extends E>)", "[E]element(int)", "[E]get(int)", "[List<E>]subList(int,int)"], "method_uris": ["src/main/java/org/apache/commons/collections4/list/LazyList.java.LazyList.[LazyList<E>]lazyList(List<E>,Factory<? extends E>)", "src/main/java/org/apache/commons/collections4/list/LazyList.java.LazyList.[LazyList<E>]lazyList(List<E>,Transformer<Integer, ? extends E>)", "src/main/java/org/apache/commons/collections4/list/LazyList.java.LazyList.[]LazyList(List<E>,Factory<? extends E>)", "src/main/java/org/apache/commons/collections4/list/LazyList.java.LazyList.[]LazyList(List<E>,Transformer<Integer, ? extends E>)", "src/main/java/org/apache/commons/collections4/list/LazyList.java.LazyList.[E]element(int)", "src/main/java/org/apache/commons/collections4/list/LazyList.java.LazyList.[E]get(int)", "src/main/java/org/apache/commons/collections4/list/LazyList.java.LazyList.[List<E>]subList(int,int)"], "overrides": null, "attributes": [], "class_docstring": "\nDecorates another {@code List} to create objects in the list on demand.\n<p>\nWhen the {@link #get(int)} method is called with an index greater than\nthe size of the list, the list will automatically grow in size and return\na new object from the specified factory or transformer. The gaps will be\nfilled by null. If a get method call encounters a null, it will be replaced\nwith a new object from the factory. Thus this list is unsuitable for\nstoring null objects.\n</p>\n<p>\nFor instance:\n</p>\n\n<pre>\nFactory&lt;Date&gt; factory = new Factory&lt;Date&gt;() {\n    public Date create() {\n        return new Date();\n    }\n}\nList&lt;Date&gt; lazy = LazyList.decorate(new ArrayList&lt;Date&gt;(), factory);\nDate date = lazy.get(3);\n</pre>\n\n<p>\nAfter the above code is executed, {@code date} will contain\na new {@code Date} instance.  Furthermore, that {@code Date}\ninstance is the fourth element in the list.  The first, second,\nand third element are all set to {@code null}.\n</p>\n<p>\nThis class differs from {@link GrowthList} because here growth occurs on\nget, where {@code GrowthList} grows on set and add. However, they\ncould easily be used together by decorating twice.\n</p>\n<p>\nThis class is Serializable from Commons Collections 3.1.\n</p>\n\n@param <E> the type of the elements in the list.\n@see GrowthList\n@since 3.0\n", "original_string": "public class LazyList<E> extends AbstractSerializableListDecorator<E> {\n\n    /** Serialization version */\n    private static final long serialVersionUID = -3677737457567429713L;\n\n    /**\n     * Factory method to create a lazily instantiating list.\n     *\n     * @param <E> the type of the elements in the list\n     * @param list  the list to decorate, must not be null\n     * @param factory  the factory to use for creation, must not be null\n     * @return a new lazy list\n     * @throws NullPointerException if list or factory is null\n     * @since 4.0\n     */\n    public static <E> LazyList<E> lazyList(final List<E> list, final Factory<? extends E> factory) {\n        return new LazyList<>(list, factory);\n    }\n\n    /**\n     * Transformer method to create a lazily instantiating list.\n     *\n     * @param <E> the type of the elements in the list\n     * @param list  the list to decorate, must not be null\n     * @param transformer  the transformer to use for creation, must not be null\n     * @return a new lazy list\n     * @throws NullPointerException if list or transformer is null\n     * @since 4.4\n     */\n    public static <E> LazyList<E> lazyList(final List<E> list, final Transformer<Integer, ? extends E> transformer) {\n        return new LazyList<>(list, transformer);\n    }\n\n    /** The factory to use to lazily instantiate the objects */\n    private final Factory<? extends E> factory;\n\n    /** The transformer to use to lazily instantiate the objects */\n    private final Transformer<Integer, ? extends E> transformer;\n\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param list  the list to decorate, must not be null\n     * @param factory  the factory to use for creation, must not be null\n     * @throws NullPointerException if list or factory is null\n     */\n    protected LazyList(final List<E> list, final Factory<? extends E> factory) {\n        super(list);\n        this.factory = Objects.requireNonNull(factory);\n        this.transformer = null;\n    }\n\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param list  the list to decorate, must not be null\n     * @param transformer  the transformer to use for creation, must not be null\n     * @throws NullPointerException if list or transformer is null\n     */\n    protected LazyList(final List<E> list, final Transformer<Integer, ? extends E> transformer) {\n        super(list);\n        this.factory = null;\n        this.transformer = Objects.requireNonNull(transformer);\n    }\n\n    private E element(final int index) {\n        if (factory != null) {\n            return factory.get();\n        }\n        if (transformer != null) {\n            return transformer.apply(index);\n        }\n        throw new IllegalStateException(\"Factory and Transformer are both null!\");\n    }\n\n    /**\n     * Decorate the get method to perform the lazy behavior.\n     * <p>\n     * If the requested index is greater than the current size, the list will\n     * grow to the new size and a new object will be returned from the factory\n     * or transformer. Indexes in-between the old size and the requested size\n     * are left with a placeholder that is replaced with a factory or\n     * transformer object when requested.\n     *\n     * @param index  the index to retrieve\n     * @return the element at the given index\n     */\n    @Override\n    public E get(final int index) {\n        final int size = decorated().size();\n        if (index < size) {\n            // within bounds, get the object\n            E object = decorated().get(index);\n            if (object == null) {\n                // item is a placeholder, create new one, set and return\n                object = element(index);\n                decorated().set(index, object);\n            }\n            // good and ready to go\n            return object;\n        }\n        // we have to grow the list\n        for (int i = size; i < index; i++) {\n            decorated().add(null);\n        }\n        // create our last object, set and return\n        final E object = element(index);\n        decorated().add(object);\n        return object;\n    }\n\n    @Override\n    public List<E> subList(final int fromIndex, final int toIndex) {\n        final List<E> sub = decorated().subList(fromIndex, toIndex);\n        if (factory != null) {\n            return new LazyList<>(sub, factory);\n        }\n        if (transformer != null) {\n            return new LazyList<>(sub, transformer);\n        }\n        throw new IllegalStateException(\"Factory and Transformer are both null!\");\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = -3677737457567429713L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -3677737457567429713L", "syntax_pass": true}, {"attribute_expression": "private final Factory<? extends E> factory;", "docstring": " The factory to use to lazily instantiate the objects", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Factory<? extends E>", "name": "factory", "syntax_pass": true}, {"attribute_expression": "private final Transformer<Integer, ? extends E> transformer;", "docstring": " The transformer to use to lazily instantiate the objects", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Transformer<Integer, ? extends E>", "name": "transformer", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/list/CursorableLinkedList.java.CursorableLinkedList", "name": "CursorableLinkedList", "file_path": "src/main/java/org/apache/commons/collections4/list/CursorableLinkedList.java", "superclasses": "", "methods": ["[]CursorableLinkedList()", "[]CursorableLinkedList(Collection<? extends E>)", "[void]addNode(Node<E>,Node<E>)", "[void]broadcastNodeChanged(Node<E>)", "[void]broadcastNodeInserted(Node<E>)", "[void]broadcastNodeRemoved(Node<E>)", "[ListIterator<E>]createSubListListIterator(LinkedSubList<E>,int)", "[CursorableLinkedList.Cursor<E>]cursor()", "[CursorableLinkedList.Cursor<E>]cursor(int)", "[void]init()", "[Iterator<E>]iterator()", "[ListIterator<E>]listIterator()", "[ListIterator<E>]listIterator(int)", "[void]readObject(ObjectInputStream)", "[void]registerCursor(Cursor<E>)", "[void]removeAllNodes()", "[void]removeNode(Node<E>)", "[void]unregisterCursor(Cursor<E>)", "[void]updateNode(Node<E>,E)", "[void]writeObject(ObjectOutputStream)"], "method_uris": ["src/main/java/org/apache/commons/collections4/list/CursorableLinkedList.java.CursorableLinkedList.[]CursorableLinkedList()", "src/main/java/org/apache/commons/collections4/list/CursorableLinkedList.java.CursorableLinkedList.[]CursorableLinkedList(Collection<? extends E>)", "src/main/java/org/apache/commons/collections4/list/CursorableLinkedList.java.CursorableLinkedList.[void]addNode(Node<E>,Node<E>)", "src/main/java/org/apache/commons/collections4/list/CursorableLinkedList.java.CursorableLinkedList.[void]broadcastNodeChanged(Node<E>)", "src/main/java/org/apache/commons/collections4/list/CursorableLinkedList.java.CursorableLinkedList.[void]broadcastNodeInserted(Node<E>)", "src/main/java/org/apache/commons/collections4/list/CursorableLinkedList.java.CursorableLinkedList.[void]broadcastNodeRemoved(Node<E>)", "src/main/java/org/apache/commons/collections4/list/CursorableLinkedList.java.CursorableLinkedList.[ListIterator<E>]createSubListListIterator(LinkedSubList<E>,int)", "src/main/java/org/apache/commons/collections4/list/CursorableLinkedList.java.CursorableLinkedList.[CursorableLinkedList.Cursor<E>]cursor()", "src/main/java/org/apache/commons/collections4/list/CursorableLinkedList.java.CursorableLinkedList.[CursorableLinkedList.Cursor<E>]cursor(int)", "src/main/java/org/apache/commons/collections4/list/CursorableLinkedList.java.CursorableLinkedList.[void]init()", "src/main/java/org/apache/commons/collections4/list/CursorableLinkedList.java.CursorableLinkedList.[Iterator<E>]iterator()", "src/main/java/org/apache/commons/collections4/list/CursorableLinkedList.java.CursorableLinkedList.[ListIterator<E>]listIterator()", "src/main/java/org/apache/commons/collections4/list/CursorableLinkedList.java.CursorableLinkedList.[ListIterator<E>]listIterator(int)", "src/main/java/org/apache/commons/collections4/list/CursorableLinkedList.java.CursorableLinkedList.[void]readObject(ObjectInputStream)", "src/main/java/org/apache/commons/collections4/list/CursorableLinkedList.java.CursorableLinkedList.[void]registerCursor(Cursor<E>)", "src/main/java/org/apache/commons/collections4/list/CursorableLinkedList.java.CursorableLinkedList.[void]removeAllNodes()", "src/main/java/org/apache/commons/collections4/list/CursorableLinkedList.java.CursorableLinkedList.[void]removeNode(Node<E>)", "src/main/java/org/apache/commons/collections4/list/CursorableLinkedList.java.CursorableLinkedList.[void]unregisterCursor(Cursor<E>)", "src/main/java/org/apache/commons/collections4/list/CursorableLinkedList.java.CursorableLinkedList.[void]updateNode(Node<E>,E)", "src/main/java/org/apache/commons/collections4/list/CursorableLinkedList.java.CursorableLinkedList.[void]writeObject(ObjectOutputStream)"], "overrides": null, "attributes": [{"original_string": "    public static class Cursor<E> extends AbstractLinkedList.LinkedListIterator<E> {\n        /** Is the cursor valid (not closed) */\n        boolean valid = true;\n        /** Is the next index valid */\n        boolean nextIndexValid = true;\n        /** Flag to indicate if the current element was removed by another object. */\n        boolean currentRemovedByAnother;\n\n        /**\n         * Constructs a new cursor.\n         *\n         * @param parent  the parent list\n         * @param index  the index to start from\n         */\n        protected Cursor(final CursorableLinkedList<E> parent, final int index) {\n            super(parent, index);\n            valid = true;\n        }\n\n        /**\n         * Adds an object to the list.\n         * The object added here will be the new 'previous' in the iterator.\n         *\n         * @param obj  the object to add\n         */\n        @Override\n        public void add(final E obj) {\n            // overridden, as the nodeInserted() method updates the iterator state\n            super.add(obj);\n            // matches the (next.previous == node) clause in nodeInserted()\n            // thus next gets changed - reset it again here\n            next = next.next;\n        }\n\n        /**\n         * Override superclass modCount check, and replace it with our valid flag.\n         */\n        @Override\n        protected void checkModCount() {\n            if (!valid) {\n                throw new ConcurrentModificationException(\"Cursor closed\");\n            }\n        }\n\n        // set is not overridden, as it works ok\n        // note that we want it to throw an exception if the element being\n        // set has been removed from the real list (compare this with the\n        // remove method where we silently ignore this case)\n\n        /**\n         * Mark this cursor as no longer being needed. Any resources\n         * associated with this cursor are immediately released.\n         * In previous versions of this class, it was mandatory to close\n         * all cursor objects to avoid memory leaks. It is <em>no longer</em>\n         * necessary to call this close method; an instance of this class\n         * can now be treated exactly like a normal iterator.\n         */\n        public void close() {\n            if (valid) {\n                ((CursorableLinkedList<E>) parent).unregisterCursor(this);\n                valid = false;\n            }\n        }\n\n        /**\n         * Gets the index of the next element to be returned.\n         *\n         * @return the next index\n         */\n        @Override\n        public int nextIndex() {\n            if (!nextIndexValid) {\n                if (next == parent.header) {\n                    nextIndex = parent.size();\n                } else {\n                    int pos = 0;\n                    Node<E> temp = parent.header.next;\n                    while (temp != next) {\n                        pos++;\n                        temp = temp.next;\n                    }\n                    nextIndex = pos;\n                }\n                nextIndexValid = true;\n            }\n            return nextIndex;\n        }\n\n        /**\n         * Handle event from the list when a node has changed.\n         *\n         * @param node  the node that changed\n         */\n        protected void nodeChanged(final Node<E> node) {\n            // do nothing\n        }\n\n        /**\n         * Handle event from the list when a node has been added.\n         *\n         * @param node  the node that was added\n         */\n        protected void nodeInserted(final Node<E> node) {\n            if (node.previous == current || next.previous == node) {\n                next = node;\n            } else {\n                nextIndexValid = false;\n            }\n        }\n\n        /**\n         * Handle event from the list when a node has been removed.\n         *\n         * @param node  the node that was removed\n         */\n        protected void nodeRemoved(final Node<E> node) {\n            if (node == next && node == current) {\n                // state where next() followed by previous()\n                next = node.next;\n                current = null;\n                currentRemovedByAnother = true;\n            } else if (node == next) {\n                // state where next() not followed by previous()\n                // and we are matching next node\n                next = node.next;\n                currentRemovedByAnother = false;\n            } else if (node == current) {\n                // state where next() not followed by previous()\n                // and we are matching current (last returned) node\n                current = null;\n                currentRemovedByAnother = true;\n                nextIndex--;\n            } else {\n                nextIndexValid = false;\n                currentRemovedByAnother = false;\n            }\n        }\n\n        /**\n         * Removes the item last returned by this iterator.\n         * <p>\n         * There may have been subsequent alterations to the list\n         * since you obtained this item, however you can still remove it.\n         * You can even remove it if the item is no longer in the main list.\n         * However, you can't call this method on the same iterator more\n         * than once without calling next() or previous().\n         *\n         * @throws IllegalStateException if there is no item to remove\n         */\n        @Override\n        public void remove() {\n            // overridden, as the nodeRemoved() method updates the iterator\n            // state in the parent.removeNode() call below\n            if (current == null && currentRemovedByAnother) { // NOPMD\n                // quietly ignore, as the last returned node was removed\n                // by the list or some other iterator\n                // by ignoring it, we keep this iterator independent of\n                // other changes as much as possible\n            } else {\n                checkModCount();\n                parent.removeNode(getLastNodeReturned());\n            }\n            currentRemovedByAnother = false;\n        }\n    }", "definition": "    public static class Cursor<E> extends AbstractLinkedList.LinkedListIterator<E>", "class_docstring": "\nAn extended {@code ListIterator} that allows concurrent changes to\nthe underlying list.\n\n@param <E> the type of elements in this cursor.\n", "name": "Cursor", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "boolean valid = true;", "docstring": " Is the cursor valid (not closed)", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "boolean", "name": "valid = true", "syntax_pass": true}, {"attribute_expression": "boolean nextIndexValid = true;", "docstring": " Is the next index valid", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "boolean", "name": "nextIndexValid = true", "syntax_pass": true}, {"attribute_expression": "boolean currentRemovedByAnother;", "docstring": " Flag to indicate if the current element was removed by another object.", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "boolean", "name": "currentRemovedByAnother", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        protected Cursor(final CursorableLinkedList<E> parent, final int index) {\n            super(parent, index);\n            valid = true;\n        }", "docstring": "\nConstructs a new cursor.\n\n@param parent  the parent list\n@param index  the index to start from\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "name": "Cursor", "params": [{"name": "parent", "type": "CursorableLinkedList<E>"}, {"name": "index", "type": "int"}], "body": "                                                                                {\n            super(parent, index);\n            valid = true;\n        }", "signature": "protected Cursor(final CursorableLinkedList<E> parent, final int index)"}, {"syntax_pass": true, "original_string": "        @Override\n        public void add(final E obj) {\n            // overridden, as the nodeInserted() method updates the iterator state\n            super.add(obj);\n            // matches the (next.previous == node) clause in nodeInserted()\n            // thus next gets changed - reset it again here\n            next = next.next;\n        }", "docstring": "\nAdds an object to the list.\nThe object added here will be the new 'previous' in the iterator.\n\n@param obj  the object to add\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "add", "params": [{"name": "obj", "type": "E"}], "body": "                                     {\n            // overridden, as the nodeInserted() method updates the iterator state\n            super.add(obj);\n            // matches the (next.previous == node) clause in nodeInserted()\n            // thus next gets changed - reset it again here\n            next = next.next;\n        }", "signature": "@Override\n        public void add(final E obj)"}, {"syntax_pass": true, "original_string": "        @Override\n        protected void checkModCount() {\n            if (!valid) {\n                throw new ConcurrentModificationException(\"Cursor closed\");\n            }\n        }", "docstring": "\nOverride superclass modCount check, and replace it with our valid flag.\n", "attributes": {"modifiers": "@Override\n        protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "name": "checkModCount", "params": [], "body": "                                       {\n            if (!valid) {\n                throw new ConcurrentModificationException(\"Cursor closed\");\n            }\n        }", "signature": "@Override\n        protected void checkModCount()"}, {"syntax_pass": true, "original_string": "        public void close() {\n            if (valid) {\n                ((CursorableLinkedList<E>) parent).unregisterCursor(this);\n                valid = false;\n            }\n        }", "docstring": "\nMark this cursor as no longer being needed. Any resources\nassociated with this cursor are immediately released.\nIn previous versions of this class, it was mandatory to close\nall cursor objects to avoid memory leaks. It is <em>no longer</em>\nnecessary to call this close method; an instance of this class\ncan now be treated exactly like a normal iterator.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "close", "params": [], "body": "                            {\n            if (valid) {\n                ((CursorableLinkedList<E>) parent).unregisterCursor(this);\n                valid = false;\n            }\n        }", "signature": "public void close()"}, {"syntax_pass": true, "original_string": "        @Override\n        public int nextIndex() {\n            if (!nextIndexValid) {\n                if (next == parent.header) {\n                    nextIndex = parent.size();\n                } else {\n                    int pos = 0;\n                    Node<E> temp = parent.header.next;\n                    while (temp != next) {\n                        pos++;\n                        temp = temp.next;\n                    }\n                    nextIndex = pos;\n                }\n                nextIndexValid = true;\n            }\n            return nextIndex;\n        }", "docstring": "\nGets the index of the next element to be returned.\n\n@return the next index\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "nextIndex", "params": [], "body": "                               {\n            if (!nextIndexValid) {\n                if (next == parent.header) {\n                    nextIndex = parent.size();\n                } else {\n                    int pos = 0;\n                    Node<E> temp = parent.header.next;\n                    while (temp != next) {\n                        pos++;\n                        temp = temp.next;\n                    }\n                    nextIndex = pos;\n                }\n                nextIndexValid = true;\n            }\n            return nextIndex;\n        }", "signature": "@Override\n        public int nextIndex()"}, {"syntax_pass": true, "original_string": "        protected void nodeChanged(final Node<E> node) {\n            // do nothing\n        }", "docstring": "\nHandle event from the list when a node has changed.\n\n@param node  the node that changed\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "name": "nodeChanged", "params": [{"name": "node", "type": "Node<E>"}], "body": "                                                       {\n            // do nothing\n        }", "signature": "protected void nodeChanged(final Node<E> node)"}, {"syntax_pass": true, "original_string": "        protected void nodeInserted(final Node<E> node) {\n            if (node.previous == current || next.previous == node) {\n                next = node;\n            } else {\n                nextIndexValid = false;\n            }\n        }", "docstring": "\nHandle event from the list when a node has been added.\n\n@param node  the node that was added\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "name": "nodeInserted", "params": [{"name": "node", "type": "Node<E>"}], "body": "                                                        {\n            if (node.previous == current || next.previous == node) {\n                next = node;\n            } else {\n                nextIndexValid = false;\n            }\n        }", "signature": "protected void nodeInserted(final Node<E> node)"}, {"syntax_pass": true, "original_string": "        protected void nodeRemoved(final Node<E> node) {\n            if (node == next && node == current) {\n                // state where next() followed by previous()\n                next = node.next;\n                current = null;\n                currentRemovedByAnother = true;\n            } else if (node == next) {\n                // state where next() not followed by previous()\n                // and we are matching next node\n                next = node.next;\n                currentRemovedByAnother = false;\n            } else if (node == current) {\n                // state where next() not followed by previous()\n                // and we are matching current (last returned) node\n                current = null;\n                currentRemovedByAnother = true;\n                nextIndex--;\n            } else {\n                nextIndexValid = false;\n                currentRemovedByAnother = false;\n            }\n        }", "docstring": "\nHandle event from the list when a node has been removed.\n\n@param node  the node that was removed\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "name": "nodeRemoved", "params": [{"name": "node", "type": "Node<E>"}], "body": "                                                       {\n            if (node == next && node == current) {\n                // state where next() followed by previous()\n                next = node.next;\n                current = null;\n                currentRemovedByAnother = true;\n            } else if (node == next) {\n                // state where next() not followed by previous()\n                // and we are matching next node\n                next = node.next;\n                currentRemovedByAnother = false;\n            } else if (node == current) {\n                // state where next() not followed by previous()\n                // and we are matching current (last returned) node\n                current = null;\n                currentRemovedByAnother = true;\n                nextIndex--;\n            } else {\n                nextIndexValid = false;\n                currentRemovedByAnother = false;\n            }\n        }", "signature": "protected void nodeRemoved(final Node<E> node)"}, {"syntax_pass": true, "original_string": "        @Override\n        public void remove() {\n            // overridden, as the nodeRemoved() method updates the iterator\n            // state in the parent.removeNode() call below\n            if (current == null && currentRemovedByAnother) { // NOPMD\n                // quietly ignore, as the last returned node was removed\n                // by the list or some other iterator\n                // by ignoring it, we keep this iterator independent of\n                // other changes as much as possible\n            } else {\n                checkModCount();\n                parent.removeNode(getLastNodeReturned());\n            }\n            currentRemovedByAnother = false;\n        }", "docstring": "\nRemoves the item last returned by this iterator.\n<p>\nThere may have been subsequent alterations to the list\nsince you obtained this item, however you can still remove it.\nYou can even remove it if the item is no longer in the main list.\nHowever, you can't call this method on the same iterator more\nthan once without calling next() or previous().\n\n@throws IllegalStateException if there is no item to remove\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "remove", "params": [], "body": "                             {\n            // overridden, as the nodeRemoved() method updates the iterator\n            // state in the parent.removeNode() call below\n            if (current == null && currentRemovedByAnother) { // NOPMD\n                // quietly ignore, as the last returned node was removed\n                // by the list or some other iterator\n                // by ignoring it, we keep this iterator independent of\n                // other changes as much as possible\n            } else {\n                checkModCount();\n                parent.removeNode(getLastNodeReturned());\n            }\n            currentRemovedByAnother = false;\n        }", "signature": "@Override\n        public void remove()"}]}, {"original_string": "    protected static class SubCursor<E> extends Cursor<E> {\n\n        /** The parent list */\n        protected final LinkedSubList<E> sub;\n\n        /**\n         * Constructs a new cursor.\n         *\n         * @param sub  the sub list\n         * @param index  the index to start from\n         */\n        protected SubCursor(final LinkedSubList<E> sub, final int index) {\n            super((CursorableLinkedList<E>) sub.parent, index + sub.offset);\n            this.sub = sub;\n        }\n\n        @Override\n        public void add(final E obj) {\n            super.add(obj);\n            sub.expectedModCount = parent.modCount;\n            sub.size++;\n        }\n\n        @Override\n        public boolean hasNext() {\n            return nextIndex() < sub.size;\n        }\n\n        @Override\n        public boolean hasPrevious() {\n            return previousIndex() >= 0;\n        }\n\n        @Override\n        public int nextIndex() {\n            return super.nextIndex() - sub.offset;\n        }\n\n        @Override\n        public void remove() {\n            super.remove();\n            sub.expectedModCount = parent.modCount;\n            sub.size--;\n        }\n    }", "definition": "    protected static class SubCursor<E> extends Cursor<E>", "class_docstring": "\nA cursor for the sublist based on LinkedSubListIterator.\n\n@param <E> the type of elements in this cursor.\n@since 3.2\n", "name": "SubCursor", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "protected static", "marker_annotations": [], "non_marker_annotations": ["protected", "static"], "comments": [], "fields": [{"attribute_expression": "protected final LinkedSubList<E> sub;", "docstring": " The parent list", "modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "type": "LinkedSubList<E>", "name": "sub", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        protected SubCursor(final LinkedSubList<E> sub, final int index) {\n            super((CursorableLinkedList<E>) sub.parent, index + sub.offset);\n            this.sub = sub;\n        }", "docstring": "\nConstructs a new cursor.\n\n@param sub  the sub list\n@param index  the index to start from\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "name": "SubCursor", "params": [{"name": "sub", "type": "LinkedSubList<E>"}, {"name": "index", "type": "int"}], "body": "                                                                         {\n            super((CursorableLinkedList<E>) sub.parent, index + sub.offset);\n            this.sub = sub;\n        }", "signature": "protected SubCursor(final LinkedSubList<E> sub, final int index)"}, {"syntax_pass": true, "original_string": "        @Override\n        public void add(final E obj) {\n            super.add(obj);\n            sub.expectedModCount = parent.modCount;\n            sub.size++;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "add", "params": [{"name": "obj", "type": "E"}], "body": "                                     {\n            super.add(obj);\n            sub.expectedModCount = parent.modCount;\n            sub.size++;\n        }", "signature": "@Override\n        public void add(final E obj)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean hasNext() {\n            return nextIndex() < sub.size;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasNext", "params": [], "body": "                                 {\n            return nextIndex() < sub.size;\n        }", "signature": "@Override\n        public boolean hasNext()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean hasPrevious() {\n            return previousIndex() >= 0;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasPrevious", "params": [], "body": "                                     {\n            return previousIndex() >= 0;\n        }", "signature": "@Override\n        public boolean hasPrevious()"}, {"syntax_pass": true, "original_string": "        @Override\n        public int nextIndex() {\n            return super.nextIndex() - sub.offset;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "nextIndex", "params": [], "body": "                               {\n            return super.nextIndex() - sub.offset;\n        }", "signature": "@Override\n        public int nextIndex()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void remove() {\n            super.remove();\n            sub.expectedModCount = parent.modCount;\n            sub.size--;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "remove", "params": [], "body": "                             {\n            super.remove();\n            sub.expectedModCount = parent.modCount;\n            sub.size--;\n        }", "signature": "@Override\n        public void remove()"}]}], "class_docstring": "\nA {@code List} implementation with a {@code ListIterator} that\nallows concurrent modifications to the underlying list.\n<p>\nThis implementation supports all of the optional {@link List} operations.\nIt extends {@code AbstractLinkedList} and thus provides the\nstack/queue/dequeue operations available in {@link java.util.LinkedList}.\n</p>\n<p>\nThe main feature of this class is the ability to modify the list and the\niterator at the same time. Both the {@link #listIterator()} and {@link #cursor()}\nmethods provides access to a {@code Cursor} instance which extends\n{@code ListIterator}. The cursor allows changes to the list concurrent\nwith changes to the iterator. Note that the {@link #iterator()} method and\nsublists do <b>not</b> provide this cursor behavior.\n</p>\n<p>\nThe {@code Cursor} class is provided partly for backwards compatibility\nand partly because it allows the cursor to be directly closed. Closing the\ncursor is optional because references are held via a {@code WeakReference}.\nFor most purposes, simply modify the iterator and list at will, and then let\nthe garbage collector to the rest.\n</p>\n<p>\n<b>Note that this implementation is not synchronized.</b>\n</p>\n\n@param <E> the type of the elements in the list.\n@see java.util.LinkedList\n@since 1.0\n@deprecated parent {@link AbstractLinkedList} is source incompatible with List methods added in Java 21\n", "original_string": "@Deprecated\npublic class CursorableLinkedList<E> extends AbstractLinkedList<E> implements Serializable {\n\n    /**\n     * An extended {@code ListIterator} that allows concurrent changes to\n     * the underlying list.\n     *\n     * @param <E> the type of elements in this cursor.\n     */\n    public static class Cursor<E> extends AbstractLinkedList.LinkedListIterator<E> {\n        /** Is the cursor valid (not closed) */\n        boolean valid = true;\n        /** Is the next index valid */\n        boolean nextIndexValid = true;\n        /** Flag to indicate if the current element was removed by another object. */\n        boolean currentRemovedByAnother;\n\n        /**\n         * Constructs a new cursor.\n         *\n         * @param parent  the parent list\n         * @param index  the index to start from\n         */\n        protected Cursor(final CursorableLinkedList<E> parent, final int index) {\n            super(parent, index);\n            valid = true;\n        }\n\n        /**\n         * Adds an object to the list.\n         * The object added here will be the new 'previous' in the iterator.\n         *\n         * @param obj  the object to add\n         */\n        @Override\n        public void add(final E obj) {\n            // overridden, as the nodeInserted() method updates the iterator state\n            super.add(obj);\n            // matches the (next.previous == node) clause in nodeInserted()\n            // thus next gets changed - reset it again here\n            next = next.next;\n        }\n\n        /**\n         * Override superclass modCount check, and replace it with our valid flag.\n         */\n        @Override\n        protected void checkModCount() {\n            if (!valid) {\n                throw new ConcurrentModificationException(\"Cursor closed\");\n            }\n        }\n\n        // set is not overridden, as it works ok\n        // note that we want it to throw an exception if the element being\n        // set has been removed from the real list (compare this with the\n        // remove method where we silently ignore this case)\n\n        /**\n         * Mark this cursor as no longer being needed. Any resources\n         * associated with this cursor are immediately released.\n         * In previous versions of this class, it was mandatory to close\n         * all cursor objects to avoid memory leaks. It is <em>no longer</em>\n         * necessary to call this close method; an instance of this class\n         * can now be treated exactly like a normal iterator.\n         */\n        public void close() {\n            if (valid) {\n                ((CursorableLinkedList<E>) parent).unregisterCursor(this);\n                valid = false;\n            }\n        }\n\n        /**\n         * Gets the index of the next element to be returned.\n         *\n         * @return the next index\n         */\n        @Override\n        public int nextIndex() {\n            if (!nextIndexValid) {\n                if (next == parent.header) {\n                    nextIndex = parent.size();\n                } else {\n                    int pos = 0;\n                    Node<E> temp = parent.header.next;\n                    while (temp != next) {\n                        pos++;\n                        temp = temp.next;\n                    }\n                    nextIndex = pos;\n                }\n                nextIndexValid = true;\n            }\n            return nextIndex;\n        }\n\n        /**\n         * Handle event from the list when a node has changed.\n         *\n         * @param node  the node that changed\n         */\n        protected void nodeChanged(final Node<E> node) {\n            // do nothing\n        }\n\n        /**\n         * Handle event from the list when a node has been added.\n         *\n         * @param node  the node that was added\n         */\n        protected void nodeInserted(final Node<E> node) {\n            if (node.previous == current || next.previous == node) {\n                next = node;\n            } else {\n                nextIndexValid = false;\n            }\n        }\n\n        /**\n         * Handle event from the list when a node has been removed.\n         *\n         * @param node  the node that was removed\n         */\n        protected void nodeRemoved(final Node<E> node) {\n            if (node == next && node == current) {\n                // state where next() followed by previous()\n                next = node.next;\n                current = null;\n                currentRemovedByAnother = true;\n            } else if (node == next) {\n                // state where next() not followed by previous()\n                // and we are matching next node\n                next = node.next;\n                currentRemovedByAnother = false;\n            } else if (node == current) {\n                // state where next() not followed by previous()\n                // and we are matching current (last returned) node\n                current = null;\n                currentRemovedByAnother = true;\n                nextIndex--;\n            } else {\n                nextIndexValid = false;\n                currentRemovedByAnother = false;\n            }\n        }\n\n        /**\n         * Removes the item last returned by this iterator.\n         * <p>\n         * There may have been subsequent alterations to the list\n         * since you obtained this item, however you can still remove it.\n         * You can even remove it if the item is no longer in the main list.\n         * However, you can't call this method on the same iterator more\n         * than once without calling next() or previous().\n         *\n         * @throws IllegalStateException if there is no item to remove\n         */\n        @Override\n        public void remove() {\n            // overridden, as the nodeRemoved() method updates the iterator\n            // state in the parent.removeNode() call below\n            if (current == null && currentRemovedByAnother) { // NOPMD\n                // quietly ignore, as the last returned node was removed\n                // by the list or some other iterator\n                // by ignoring it, we keep this iterator independent of\n                // other changes as much as possible\n            } else {\n                checkModCount();\n                parent.removeNode(getLastNodeReturned());\n            }\n            currentRemovedByAnother = false;\n        }\n    }\n\n    /**\n     * A cursor for the sublist based on LinkedSubListIterator.\n     *\n     * @param <E> the type of elements in this cursor.\n     * @since 3.2\n     */\n    protected static class SubCursor<E> extends Cursor<E> {\n\n        /** The parent list */\n        protected final LinkedSubList<E> sub;\n\n        /**\n         * Constructs a new cursor.\n         *\n         * @param sub  the sub list\n         * @param index  the index to start from\n         */\n        protected SubCursor(final LinkedSubList<E> sub, final int index) {\n            super((CursorableLinkedList<E>) sub.parent, index + sub.offset);\n            this.sub = sub;\n        }\n\n        @Override\n        public void add(final E obj) {\n            super.add(obj);\n            sub.expectedModCount = parent.modCount;\n            sub.size++;\n        }\n\n        @Override\n        public boolean hasNext() {\n            return nextIndex() < sub.size;\n        }\n\n        @Override\n        public boolean hasPrevious() {\n            return previousIndex() >= 0;\n        }\n\n        @Override\n        public int nextIndex() {\n            return super.nextIndex() - sub.offset;\n        }\n\n        @Override\n        public void remove() {\n            super.remove();\n            sub.expectedModCount = parent.modCount;\n            sub.size--;\n        }\n    }\n\n    /** Ensure serialization compatibility */\n    private static final long serialVersionUID = 8836393098519411393L;\n\n    /** A list of the cursor currently open on this list */\n    private transient List<WeakReference<Cursor<E>>> cursors;\n\n    /**\n     * Constructor that creates.\n     */\n    public CursorableLinkedList() {\n        init(); // must call init() as use super();\n    }\n\n    /**\n     * Constructor that copies the specified collection\n     *\n     * @param coll  the collection to copy\n     */\n    public CursorableLinkedList(final Collection<? extends E> coll) {\n        super(coll);\n    }\n\n    /**\n     * Inserts a new node into the list.\n     *\n     * @param nodeToInsert  new node to insert\n     * @param insertBeforeNode  node to insert before\n     * @throws NullPointerException if either node is null\n     */\n    @Override\n    protected void addNode(final Node<E> nodeToInsert, final Node<E> insertBeforeNode) {\n        super.addNode(nodeToInsert, insertBeforeNode);\n        broadcastNodeInserted(nodeToInsert);\n    }\n\n    /**\n     * Informs all of my registered cursors that the specified\n     * element was changed.\n     *\n     * @param node  the node that was changed\n     */\n    protected void broadcastNodeChanged(final Node<E> node) {\n        final Iterator<WeakReference<Cursor<E>>> it = cursors.iterator();\n        while (it.hasNext()) {\n            final WeakReference<Cursor<E>> ref = it.next();\n            final Cursor<E> cursor = ref.get();\n            if (cursor == null) {\n                it.remove(); // clean up list\n            } else {\n                cursor.nodeChanged(node);\n            }\n        }\n    }\n\n    /**\n     * Informs all of my registered cursors that the specified\n     * element was just added to my list.\n     *\n     * @param node  the node that was changed\n     */\n    protected void broadcastNodeInserted(final Node<E> node) {\n        final Iterator<WeakReference<Cursor<E>>> it = cursors.iterator();\n        while (it.hasNext()) {\n            final WeakReference<Cursor<E>> ref = it.next();\n            final Cursor<E> cursor = ref.get();\n            if (cursor == null) {\n                it.remove(); // clean up list\n            } else {\n                cursor.nodeInserted(node);\n            }\n        }\n    }\n\n    /**\n     * Informs all of my registered cursors that the specified\n     * element was just removed from my list.\n     *\n     * @param node  the node that was changed\n     */\n    protected void broadcastNodeRemoved(final Node<E> node) {\n        final Iterator<WeakReference<Cursor<E>>> it = cursors.iterator();\n        while (it.hasNext()) {\n            final WeakReference<Cursor<E>> ref = it.next();\n            final Cursor<E> cursor = ref.get();\n            if (cursor == null) {\n                it.remove(); // clean up list\n            } else {\n                cursor.nodeRemoved(node);\n            }\n        }\n    }\n\n    /**\n     * Creates a list iterator for the sublist.\n     *\n     * @param subList  the sublist to get an iterator for\n     * @param fromIndex  the index to start from, relative to the sublist\n     * @return the list iterator for the sublist\n     */\n    @Override\n    protected ListIterator<E> createSubListListIterator(final LinkedSubList<E> subList, final int fromIndex) {\n        final SubCursor<E> cursor = new SubCursor<>(subList, fromIndex);\n        registerCursor(cursor);\n        return cursor;\n    }\n\n    /**\n     * Returns a {@link Cursor} for iterating through the elements of this list.\n     * <p>\n     * A {@code Cursor} is a {@code ListIterator} with an additional\n     * {@code close()} method. Calling this method immediately discards the\n     * references to the cursor. If it is not called, then the garbage collector\n     * will still remove the reference as it is held via a {@code WeakReference}.\n     * <p>\n     * The cursor enables iteration and list changes to occur in any order without\n     * invalidating the iterator (from one thread). When elements are added to the\n     * list, an event is fired to all active cursors enabling them to adjust to the\n     * change in the list.\n     * <p>\n     * When the \"current\" (i.e., last returned by {@link ListIterator#next}\n     * or {@link ListIterator#previous}) element of the list is removed,\n     * the cursor automatically adjusts to the change (invalidating the\n     * last returned value such that it cannot be removed).\n     * <p>\n     * The {@link #listIterator()} method returns the same as this method, and can\n     * be cast to a {@code Cursor} if the {@code close} method is required.\n     *\n     * @return a new cursor iterator\n     */\n    public CursorableLinkedList.Cursor<E> cursor() {\n        return cursor(0);\n    }\n\n    /**\n     * Returns a {@link Cursor} for iterating through the elements of this list\n     * starting from a specified index.\n     * <p>\n     * A {@code Cursor} is a {@code ListIterator} with an additional\n     * {@code close()} method. Calling this method immediately discards the\n     * references to the cursor. If it is not called, then the garbage collector\n     * will still remove the reference as it is held via a {@code WeakReference}.\n     * <p>\n     * The cursor enables iteration and list changes to occur in any order without\n     * invalidating the iterator (from one thread). When elements are added to the\n     * list, an event is fired to all active cursors enabling them to adjust to the\n     * change in the list.\n     * <p>\n     * When the \"current\" (i.e., last returned by {@link ListIterator#next}\n     * or {@link ListIterator#previous}) element of the list is removed,\n     * the cursor automatically adjusts to the change (invalidating the\n     * last returned value such that it cannot be removed).\n     * <p>\n     * The {@link #listIterator(int)} method returns the same as this method, and can\n     * be cast to a {@code Cursor} if the {@code close} method is required.\n     *\n     * @param fromIndex  the index to start from\n     * @return a new cursor iterator\n     * @throws IndexOutOfBoundsException if the index is out of range\n     *      (index &lt; 0 || index &gt; size()).\n     */\n    public CursorableLinkedList.Cursor<E> cursor(final int fromIndex) {\n        final Cursor<E> cursor = new Cursor<>(this, fromIndex);\n        registerCursor(cursor);\n        return cursor;\n    }\n\n    /**\n     * The equivalent of a default constructor called\n     * by any constructor and by {@code readObject}.\n     */\n    @Override\n    protected void init() {\n        super.init();\n        cursors = new ArrayList<>();\n    }\n\n    /**\n     * Returns an iterator that does <b>not</b> support concurrent modification.\n     * <p>\n     * If the underlying list is modified while iterating using this iterator\n     * a ConcurrentModificationException will occur.\n     * The cursor behavior is available via {@link #listIterator()}.\n     *\n     * @return a new iterator that does <b>not</b> support concurrent modification\n     */\n    @Override\n    public Iterator<E> iterator() {\n        return super.listIterator(0);\n    }\n\n    /**\n     * Returns a cursor iterator that allows changes to the underlying list in parallel.\n     * <p>\n     * The cursor enables iteration and list changes to occur in any order without\n     * invalidating the iterator (from one thread). When elements are added to the\n     * list, an event is fired to all active cursors enabling them to adjust to the\n     * change in the list.\n     * <p>\n     * When the \"current\" (i.e., last returned by {@link ListIterator#next}\n     * or {@link ListIterator#previous}) element of the list is removed,\n     * the cursor automatically adjusts to the change (invalidating the\n     * last returned value such that it cannot be removed).\n     *\n     * @return a new cursor iterator\n     */\n    @Override\n    public ListIterator<E> listIterator() {\n        return cursor(0);\n    }\n\n    /**\n     * Returns a cursor iterator that allows changes to the underlying list in parallel.\n     * <p>\n     * The cursor enables iteration and list changes to occur in any order without\n     * invalidating the iterator (from one thread). When elements are added to the\n     * list, an event is fired to all active cursors enabling them to adjust to the\n     * change in the list.\n     * <p>\n     * When the \"current\" (i.e., last returned by {@link ListIterator#next}\n     * or {@link ListIterator#previous}) element of the list is removed,\n     * the cursor automatically adjusts to the change (invalidating the\n     * last returned value such that it cannot be removed).\n     *\n     * @param fromIndex  the index to start from\n     * @return a new cursor iterator\n     */\n    @Override\n    public ListIterator<E> listIterator(final int fromIndex) {\n        return cursor(fromIndex);\n    }\n\n    /**\n     * Deserializes the data held in this object to the stream specified.\n     *\n     * @param in  the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded\n     */\n    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        doReadObject(in);\n    }\n\n    /**\n     * Registers a cursor to be notified of changes to this list.\n     *\n     * @param cursor  the cursor to register\n     */\n    protected void registerCursor(final Cursor<E> cursor) {\n        // We take this opportunity to clean the cursors list\n        // of WeakReference objects to garbage-collected cursors.\n        cursors.removeIf(ref -> ref.get() == null);\n        cursors.add(new WeakReference<>(cursor));\n    }\n\n    /**\n     * Removes all nodes by iteration.\n     */\n    @Override\n    protected void removeAllNodes() {\n        if (!isEmpty()) {\n            // superclass implementation would break all the iterators\n            final Iterator<E> it = iterator();\n            while (it.hasNext()) {\n                it.next();\n                it.remove();\n            }\n        }\n    }\n\n    /**\n     * Removes the specified node from the list.\n     *\n     * @param node  the node to remove\n     * @throws NullPointerException if {@code node} is null\n     */\n    @Override\n    protected void removeNode(final Node<E> node) {\n        super.removeNode(node);\n        broadcastNodeRemoved(node);\n    }\n\n    /**\n     * Deregisters a cursor from the list to be notified of changes.\n     *\n     * @param cursor  the cursor to deregister\n     */\n    protected void unregisterCursor(final Cursor<E> cursor) {\n        for (final Iterator<WeakReference<Cursor<E>>> it = cursors.iterator(); it.hasNext();) {\n            final WeakReference<Cursor<E>> ref = it.next();\n            final Cursor<E> cur = ref.get();\n            if (cur == null) {\n                // some other unrelated cursor object has been\n                // garbage-collected; let's take the opportunity to\n                // clean up the cursors list anyway.\n                it.remove();\n            } else if (cur == cursor) {\n                ref.clear();\n                it.remove();\n                break;\n            }\n        }\n    }\n\n    /**\n     * Updates the node with a new value.\n     * This implementation sets the value on the node.\n     * Subclasses can override this to record the change.\n     *\n     * @param node  node to update\n     * @param value  new value of the node\n     */\n    @Override\n    protected void updateNode(final Node<E> node, final E value) {\n        super.updateNode(node, value);\n        broadcastNodeChanged(node);\n    }\n\n    /**\n     * Serializes this object to an ObjectOutputStream.\n     *\n     * @param out the target ObjectOutputStream.\n     * @throws IOException thrown when an I/O errors occur writing to the target stream.\n     */\n    private void writeObject(final ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        doWriteObject(out);\n    }\n\n}", "super_interfaces": ["Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 8836393098519411393L;", "docstring": " Ensure serialization compatibility", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 8836393098519411393L", "syntax_pass": true}, {"attribute_expression": "private transient List<WeakReference<Cursor<E>>> cursors;", "docstring": " A list of the cursor currently open on this list", "modifiers": "private transient", "marker_annotations": [], "non_marker_annotations": ["private", "transient"], "comments": [], "type": "List<WeakReference<Cursor<E>>>", "name": "cursors", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/list/TreeList.java.TreeList", "name": "TreeList", "file_path": "src/main/java/org/apache/commons/collections4/list/TreeList.java", "superclasses": "", "methods": ["[]TreeList()", "[]TreeList(Collection<? extends E>)", "[void]add(int,E)", "[boolean]addAll(Collection<? extends E>)", "[void]checkInterval(int,int,int)", "[void]clear()", "[boolean]contains(Object)", "[E]get(int)", "[int]indexOf(Object)", "[Iterator<E>]iterator()", "[ListIterator<E>]listIterator()", "[ListIterator<E>]listIterator(int)", "[E]remove(int)", "[E]set(int,E)", "[int]size()", "[Object[]]toArray()"], "method_uris": ["src/main/java/org/apache/commons/collections4/list/TreeList.java.TreeList.[]TreeList()", "src/main/java/org/apache/commons/collections4/list/TreeList.java.TreeList.[]TreeList(Collection<? extends E>)", "src/main/java/org/apache/commons/collections4/list/TreeList.java.TreeList.[void]add(int,E)", "src/main/java/org/apache/commons/collections4/list/TreeList.java.TreeList.[boolean]addAll(Collection<? extends E>)", "src/main/java/org/apache/commons/collections4/list/TreeList.java.TreeList.[void]checkInterval(int,int,int)", "src/main/java/org/apache/commons/collections4/list/TreeList.java.TreeList.[void]clear()", "src/main/java/org/apache/commons/collections4/list/TreeList.java.TreeList.[boolean]contains(Object)", "src/main/java/org/apache/commons/collections4/list/TreeList.java.TreeList.[E]get(int)", "src/main/java/org/apache/commons/collections4/list/TreeList.java.TreeList.[int]indexOf(Object)", "src/main/java/org/apache/commons/collections4/list/TreeList.java.TreeList.[Iterator<E>]iterator()", "src/main/java/org/apache/commons/collections4/list/TreeList.java.TreeList.[ListIterator<E>]listIterator()", "src/main/java/org/apache/commons/collections4/list/TreeList.java.TreeList.[ListIterator<E>]listIterator(int)", "src/main/java/org/apache/commons/collections4/list/TreeList.java.TreeList.[E]remove(int)", "src/main/java/org/apache/commons/collections4/list/TreeList.java.TreeList.[E]set(int,E)", "src/main/java/org/apache/commons/collections4/list/TreeList.java.TreeList.[int]size()", "src/main/java/org/apache/commons/collections4/list/TreeList.java.TreeList.[Object[]]toArray()"], "overrides": null, "attributes": [{"original_string": "    static class AVLNode<E> {\n        /** The left child node or the predecessor if {@link #leftIsPrevious}.*/\n        private AVLNode<E> left;\n        /** Flag indicating that left reference is not a subtree but the predecessor. */\n        private boolean leftIsPrevious;\n        /** The right child node or the successor if {@link #rightIsNext}. */\n        private AVLNode<E> right;\n        /** Flag indicating that right reference is not a subtree but the successor. */\n        private boolean rightIsNext;\n        /** How many levels of left/right are below this one. */\n        private int height;\n        /** The relative position, root holds absolute position. */\n        private int relativePosition;\n        /** The stored element. */\n        private E value;\n\n        /**\n         * Constructs a new AVL tree from a collection.\n         * <p>\n         * The collection must be nonempty.\n         *\n         * @param coll  a nonempty collection\n         */\n        private AVLNode(final Collection<? extends E> coll) {\n            this(coll.iterator(), 0, coll.size() - 1, 0, null, null);\n        }\n\n        /**\n         * Constructs a new node with a relative position.\n         *\n         * @param relativePosition  the relative position of the node\n         * @param obj  the value for the node\n         * @param rightFollower the node with the value following this one\n         * @param leftFollower the node with the value leading this one\n         */\n        private AVLNode(final int relativePosition, final E obj,\n                        final AVLNode<E> rightFollower, final AVLNode<E> leftFollower) {\n            this.relativePosition = relativePosition;\n            value = obj;\n            rightIsNext = true;\n            leftIsPrevious = true;\n            right = rightFollower;\n            left = leftFollower;\n        }\n\n        /**\n         * Constructs a new AVL tree from a collection.\n         * <p>\n         * This is a recursive helper for {@link #AVLNode(Collection)}. A call\n         * to this method will construct the subtree for elements {@code start}\n         * through {@code end} of the collection, assuming the iterator\n         * {@code e} already points at element {@code start}.\n         *\n         * @param iterator  an iterator over the collection, which should already point\n         *          to the element at index {@code start} within the collection\n         * @param start  the index of the first element in the collection that\n         *          should be in this subtree\n         * @param end  the index of the last element in the collection that\n         *          should be in this subtree\n         * @param absolutePositionOfParent  absolute position of this node's\n         *          parent, or 0 if this node is the root\n         * @param prev  the {@code AVLNode} corresponding to element (start - 1)\n         *          of the collection, or null if start is 0\n         * @param next  the {@code AVLNode} corresponding to element (end + 1)\n         *          of the collection, or null if end is the last element of the collection\n         */\n        private AVLNode(final Iterator<? extends E> iterator, final int start, final int end,\n                        final int absolutePositionOfParent, final AVLNode<E> prev, final AVLNode<E> next) {\n            final int mid = start + (end - start) / 2;\n            if (start < mid) {\n                left = new AVLNode<>(iterator, start, mid - 1, mid, prev, this);\n            } else {\n                leftIsPrevious = true;\n                left = prev;\n            }\n            value = iterator.next();\n            relativePosition = mid - absolutePositionOfParent;\n            if (mid < end) {\n                right = new AVLNode<>(iterator, mid + 1, end, mid, this, next);\n            } else {\n                rightIsNext = true;\n                right = next;\n            }\n            recalcHeight();\n        }\n\n        /**\n         * Appends the elements of another tree list to this tree list by efficiently\n         * merging the two AVL trees. This operation is destructive to both trees and\n         * runs in O(log(m + n)) time.\n         *\n         * @param otherTree\n         *            the root of the AVL tree to merge with this one\n         * @param currentSize\n         *            the number of elements in this AVL tree\n         * @return the root of the new, merged AVL tree\n         */\n        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\n            otherTreeMin.relativePosition = currentSize - sParentAbsolutePosition;\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }\n\n        /**\n         * Balances according to the AVL algorithm.\n         */\n        private AVLNode<E> balance() {\n            switch (heightRightMinusLeft()) {\n            case 1 :\n            case 0 :\n            case -1 :\n                return this;\n            case -2 :\n                if (left.heightRightMinusLeft() > 0) {\n                    setLeft(left.rotateLeft(), null);\n                }\n                return rotateRight();\n            case 2 :\n                if (right.heightRightMinusLeft() < 0) {\n                    setRight(right.rotateRight(), null);\n                }\n                return rotateLeft();\n            default :\n                throw new IllegalStateException(\"tree inconsistent!\");\n            }\n        }\n\n        /**\n         * Locate the element with the given index relative to the\n         * offset of the parent of this node.\n         */\n        AVLNode<E> get(final int index) {\n            final int indexRelativeToMe = index - relativePosition;\n\n            if (indexRelativeToMe == 0) {\n                return this;\n            }\n\n            final AVLNode<E> nextNode = indexRelativeToMe < 0 ? getLeftSubTree() : getRightSubTree();\n            if (nextNode == null) {\n                return null;\n            }\n            return nextNode.get(indexRelativeToMe);\n        }\n\n        /**\n         * Returns the height of the node or -1 if the node is null.\n         */\n        private int getHeight(final AVLNode<E> node) {\n            return node == null ? -1 : node.height;\n        }\n\n        /**\n         * Gets the left node, returning null if it's a faedelung.\n         */\n        private AVLNode<E> getLeftSubTree() {\n            return leftIsPrevious ? null : left;\n        }\n\n        /**\n         * Gets the relative position.\n         */\n        private int getOffset(final AVLNode<E> node) {\n            if (node == null) {\n                return 0;\n            }\n            return node.relativePosition;\n        }\n\n        /**\n         * Gets the right node, returning null if it's a faedelung.\n         */\n        private AVLNode<E> getRightSubTree() {\n            return rightIsNext ? null : right;\n        }\n\n        /**\n         * Gets the value.\n         *\n         * @return the value of this node\n         */\n        E getValue() {\n            return value;\n        }\n\n        /**\n         * Returns the height difference right - left\n         */\n        private int heightRightMinusLeft() {\n            return getHeight(getRightSubTree()) - getHeight(getLeftSubTree());\n        }\n\n        /**\n         * Locate the index that contains the specified object.\n         */\n        int indexOf(final Object object, final int index) {\n            if (getLeftSubTree() != null) {\n                final int result = left.indexOf(object, index + left.relativePosition);\n                if (result != -1) {\n                    return result;\n                }\n            }\n            if (Objects.equals(value, object)) {\n                return index;\n            }\n            if (getRightSubTree() != null) {\n                return right.indexOf(object, index + right.relativePosition);\n            }\n            return -1;\n        }\n\n        /**\n         * Inserts a node at the position index.\n         *\n         * @param index is the index of the position relative to the position of\n         * the parent node.\n         * @param obj is the object to be stored in the position.\n         */\n        AVLNode<E> insert(final int index, final E obj) {\n            final int indexRelativeToMe = index - relativePosition;\n\n            if (indexRelativeToMe <= 0) {\n                return insertOnLeft(indexRelativeToMe, obj);\n            }\n            return insertOnRight(indexRelativeToMe, obj);\n        }\n\n        private AVLNode<E> insertOnLeft(final int indexRelativeToMe, final E obj) {\n            if (getLeftSubTree() == null) {\n                setLeft(new AVLNode<>(-1, obj, this, left), null);\n            } else {\n                setLeft(left.insert(indexRelativeToMe, obj), null);\n            }\n\n            if (relativePosition >= 0) {\n                relativePosition++;\n            }\n            final AVLNode<E> ret = balance();\n            recalcHeight();\n            return ret;\n        }\n\n        private AVLNode<E> insertOnRight(final int indexRelativeToMe, final E obj) {\n            if (getRightSubTree() == null) {\n                setRight(new AVLNode<>(+1, obj, right, this), null);\n            } else {\n                setRight(right.insert(indexRelativeToMe, obj), null);\n            }\n            if (relativePosition < 0) {\n                relativePosition--;\n            }\n            final AVLNode<E> ret = balance();\n            recalcHeight();\n            return ret;\n        }\n\n        /**\n         * Gets the rightmost child of this node.\n         *\n         * @return the rightmost child (greatest index)\n         */\n        private AVLNode<E> max() {\n            return getRightSubTree() == null ? this : right.max();\n        }\n\n        /**\n         * Gets the leftmost child of this node.\n         *\n         * @return the leftmost child (smallest index)\n         */\n        private AVLNode<E> min() {\n            return getLeftSubTree() == null ? this : left.min();\n        }\n\n        /**\n         * Gets the next node in the list after this one.\n         *\n         * @return the next node\n         */\n        AVLNode<E> next() {\n            if (rightIsNext || right == null) {\n                return right;\n            }\n            return right.min();\n        }\n\n        /**\n         * Gets the node in the list before this one.\n         *\n         * @return the previous node\n         */\n        AVLNode<E> previous() {\n            if (leftIsPrevious || left == null) {\n                return left;\n            }\n            return left.max();\n        }\n\n        /**\n         * Sets the height by calculation.\n         */\n        private void recalcHeight() {\n            height = Math.max(\n                getLeftSubTree() == null ? -1 : getLeftSubTree().height,\n                getRightSubTree() == null ? -1 : getRightSubTree().height) + 1;\n        }\n\n        /**\n         * Removes the node at a given position.\n         *\n         * @param index is the index of the element to be removed relative to the position of\n         * the parent node of the current node.\n         */\n        AVLNode<E> remove(final int index) {\n            final int indexRelativeToMe = index - relativePosition;\n\n            if (indexRelativeToMe == 0) {\n                return removeSelf();\n            }\n            if (indexRelativeToMe > 0) {\n                setRight(right.remove(indexRelativeToMe), right.right);\n                if (relativePosition < 0) {\n                    relativePosition++;\n                }\n            } else {\n                setLeft(left.remove(indexRelativeToMe), left.left);\n                if (relativePosition > 0) {\n                    relativePosition--;\n                }\n            }\n            recalcHeight();\n            return balance();\n        }\n\n        private AVLNode<E> removeMax() {\n            if (getRightSubTree() == null) {\n                return removeSelf();\n            }\n            setRight(right.removeMax(), right.right);\n            if (relativePosition < 0) {\n                relativePosition++;\n            }\n            recalcHeight();\n            return balance();\n        }\n\n        private AVLNode<E> removeMin() {\n            if (getLeftSubTree() == null) {\n                return removeSelf();\n            }\n            setLeft(left.removeMin(), left.left);\n            if (relativePosition > 0) {\n                relativePosition--;\n            }\n            recalcHeight();\n            return balance();\n        }\n\n        /**\n         * Removes this node from the tree.\n         *\n         * @return the node that replaces this one in the parent\n         */\n        private AVLNode<E> removeSelf() {\n            if (getRightSubTree() == null && getLeftSubTree() == null) {\n                return null;\n            }\n            if (getRightSubTree() == null) {\n                if (relativePosition > 0) {\n                    left.relativePosition += relativePosition;\n                }\n                left.max().setRight(null, right);\n                return left;\n            }\n            if (getLeftSubTree() == null) {\n                right.relativePosition += relativePosition - (relativePosition < 0 ? 0 : 1);\n                right.min().setLeft(null, left);\n                return right;\n            }\n\n            if (heightRightMinusLeft() > 0) {\n                // more on the right, so delete from the right\n                final AVLNode<E> rightMin = right.min();\n                value = rightMin.value;\n                if (leftIsPrevious) {\n                    left = rightMin.left;\n                }\n                right = right.removeMin();\n                if (relativePosition < 0) {\n                    relativePosition++;\n                }\n            } else {\n                // more on the left or equal, so delete from the left\n                final AVLNode<E> leftMax = left.max();\n                value = leftMax.value;\n                if (rightIsNext) {\n                    right = leftMax.right;\n                }\n                final AVLNode<E> leftPrevious = left.left;\n                left = left.removeMax();\n                if (left == null) {\n                    // special case where left that was deleted was a double link\n                    // only occurs when height difference is equal\n                    left = leftPrevious;\n                    leftIsPrevious = true;\n                }\n                if (relativePosition > 0) {\n                    relativePosition--;\n                }\n            }\n            recalcHeight();\n            return this;\n        }\n\n        private AVLNode<E> rotateLeft() {\n            final AVLNode<E> newTop = right; // can't be faedelung!\n            final AVLNode<E> movedNode = getRightSubTree().getLeftSubTree();\n\n            final int newTopPosition = relativePosition + getOffset(newTop);\n            final int myNewPosition = -newTop.relativePosition;\n            final int movedPosition = getOffset(newTop) + getOffset(movedNode);\n\n            setRight(movedNode, newTop);\n            newTop.setLeft(this, null);\n\n            setOffset(newTop, newTopPosition);\n            setOffset(this, myNewPosition);\n            setOffset(movedNode, movedPosition);\n            return newTop;\n        }\n\n        private AVLNode<E> rotateRight() {\n            final AVLNode<E> newTop = left; // can't be faedelung\n            final AVLNode<E> movedNode = getLeftSubTree().getRightSubTree();\n\n            final int newTopPosition = relativePosition + getOffset(newTop);\n            final int myNewPosition = -newTop.relativePosition;\n            final int movedPosition = getOffset(newTop) + getOffset(movedNode);\n\n            setLeft(movedNode, newTop);\n            newTop.setRight(this, null);\n\n            setOffset(newTop, newTopPosition);\n            setOffset(this, myNewPosition);\n            setOffset(movedNode, movedPosition);\n            return newTop;\n        }\n\n        /**\n         * Sets the left field to the node, or the previous node if that is null\n         *\n         * @param node  the new left subtree node\n         * @param previous  the previous node in the linked list\n         */\n        private void setLeft(final AVLNode<E> node, final AVLNode<E> previous) {\n            leftIsPrevious = node == null;\n            left = leftIsPrevious ? previous : node;\n            recalcHeight();\n        }\n\n        /**\n         * Sets the relative position.\n         */\n        private int setOffset(final AVLNode<E> node, final int newOffset) {\n            if (node == null) {\n                return 0;\n            }\n            final int oldOffset = getOffset(node);\n            node.relativePosition = newOffset;\n            return oldOffset;\n        }\n\n        /**\n         * Sets the right field to the node, or the next node if that is null\n         *\n         * @param node  the new left subtree node\n         * @param next  the next node in the linked list\n         */\n        private void setRight(final AVLNode<E> node, final AVLNode<E> next) {\n            rightIsNext = node == null;\n            right = rightIsNext ? next : node;\n            recalcHeight();\n        }\n\n        /**\n         * Sets the value.\n         *\n         * @param obj  the value to store\n         */\n        void setValue(final E obj) {\n            this.value = obj;\n        }\n\n        /**\n         * Stores the node and its children into the array specified.\n         *\n         * @param array the array to be filled\n         * @param index the index of this node\n         */\n        void toArray(final Object[] array, final int index) {\n            array[index] = value;\n            if (getLeftSubTree() != null) {\n                left.toArray(array, index + left.relativePosition);\n            }\n            if (getRightSubTree() != null) {\n                right.toArray(array, index + right.relativePosition);\n            }\n        }\n\n//      private void checkFaedelung() {\n//          AVLNode maxNode = left.max();\n//          if (!maxNode.rightIsFaedelung || maxNode.right != this) {\n//              throw new RuntimeException(maxNode + \" should right-faedel to \" + this);\n//          }\n//          AVLNode minNode = right.min();\n//          if (!minNode.leftIsFaedelung || minNode.left != this) {\n//              throw new RuntimeException(maxNode + \" should left-faedel to \" + this);\n//          }\n//      }\n//\n//        private int checkTreeDepth() {\n//            int hright = (getRightSubTree() == null ? -1 : getRightSubTree().checkTreeDepth());\n//            //          System.out.print(\"checkTreeDepth\");\n//            //          System.out.print(this);\n//            //          System.out.print(\" left: \");\n//            //          System.out.print(_left);\n//            //          System.out.print(\" right: \");\n//            //          System.out.println(_right);\n//\n//            int hleft = (left == null ? -1 : left.checkTreeDepth());\n//            if (height != Math.max(hright, hleft) + 1) {\n//                throw new RuntimeException(\n//                    \"height should be max\" + hleft + \",\" + hright + \" but is \" + height);\n//            }\n//            return height;\n//        }\n//\n//        private int checkLeftSubNode() {\n//            if (getLeftSubTree() == null) {\n//                return 0;\n//            }\n//            int count = 1 + left.checkRightSubNode();\n//            if (left.relativePosition != -count) {\n//                throw new RuntimeException();\n//            }\n//            return count + left.checkLeftSubNode();\n//        }\n//\n//        private int checkRightSubNode() {\n//            AVLNode right = getRightSubTree();\n//            if (right == null) {\n//                return 0;\n//            }\n//            int count = 1;\n//            count += right.checkLeftSubNode();\n//            if (right.relativePosition != count) {\n//                throw new RuntimeException();\n//            }\n//            return count + right.checkRightSubNode();\n//        }\n\n        /**\n         * Used for debugging.\n         */\n        @Override\n        public String toString() {\n            return new StringBuilder()\n                .append(\"AVLNode(\")\n                .append(relativePosition)\n                .append(CollectionUtils.COMMA)\n                .append(left != null)\n                .append(CollectionUtils.COMMA)\n                .append(value)\n                .append(CollectionUtils.COMMA)\n                .append(getRightSubTree() != null)\n                .append(rightIsNext)\n                .append(\")\")\n                .toString();\n        }\n    }", "definition": "    static class AVLNode<E>", "class_docstring": "\nImplements an AVLNode which keeps the offset updated.\n<p>\nThis node contains the real work.\nTreeList is just there to implement {@link java.util.List}.\nThe nodes don't know the index of the object they are holding.  They\ndo know however their position relative to their parent node.\nThis allows to calculate the index of a node while traversing the tree.\n<p>\nThe Faedelung calculation stores a flag for both the left and right child\nto indicate if they are a child (false) or a link as in linked list (true).\n", "name": "AVLNode", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "private AVLNode<E> left;", "docstring": " The left child node or the predecessor if {@link #leftIsPrevious}.", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "AVLNode<E>", "name": "left", "syntax_pass": true}, {"attribute_expression": "private boolean leftIsPrevious;", "docstring": " Flag indicating that left reference is not a subtree but the predecessor.", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "leftIsPrevious", "syntax_pass": true}, {"attribute_expression": "private AVLNode<E> right;", "docstring": " The right child node or the successor if {@link #rightIsNext}.", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "AVLNode<E>", "name": "right", "syntax_pass": true}, {"attribute_expression": "private boolean rightIsNext;", "docstring": " Flag indicating that right reference is not a subtree but the successor.", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "rightIsNext", "syntax_pass": true}, {"attribute_expression": "private int height;", "docstring": " How many levels of left/right are below this one.", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "height", "syntax_pass": true}, {"attribute_expression": "private int relativePosition;", "docstring": " The relative position, root holds absolute position.", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "relativePosition", "syntax_pass": true}, {"attribute_expression": "private E value;", "docstring": " The stored element.", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "E", "name": "value", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        private AVLNode(final Collection<? extends E> coll) {\n            this(coll.iterator(), 0, coll.size() - 1, 0, null, null);\n        }", "docstring": "\nConstructs a new AVL tree from a collection.\n<p>\nThe collection must be nonempty.\n\n@param coll  a nonempty collection\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "AVLNode", "params": [{"name": "coll", "type": "Collection<? extends E>"}], "body": "                                                            {\n            this(coll.iterator(), 0, coll.size() - 1, 0, null, null);\n        }", "signature": "private AVLNode(final Collection<? extends E> coll)"}, {"syntax_pass": true, "original_string": "        private AVLNode(final int relativePosition, final E obj,\n                        final AVLNode<E> rightFollower, final AVLNode<E> leftFollower) {\n            this.relativePosition = relativePosition;\n            value = obj;\n            rightIsNext = true;\n            leftIsPrevious = true;\n            right = rightFollower;\n            left = leftFollower;\n        }", "docstring": "\nConstructs a new node with a relative position.\n\n@param relativePosition  the relative position of the node\n@param obj  the value for the node\n@param rightFollower the node with the value following this one\n@param leftFollower the node with the value leading this one\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "AVLNode", "params": [{"name": "relativePosition", "type": "int"}, {"name": "obj", "type": "E"}, {"name": "rightFollower", "type": "AVLNode<E>"}, {"name": "leftFollower", "type": "AVLNode<E>"}], "body": "                                                                                       {\n            this.relativePosition = relativePosition;\n            value = obj;\n            rightIsNext = true;\n            leftIsPrevious = true;\n            right = rightFollower;\n            left = leftFollower;\n        }", "signature": "private AVLNode(final int relativePosition, final E obj,\n                        final AVLNode<E> rightFollower, final AVLNode<E> leftFollower)"}, {"syntax_pass": true, "original_string": "        private AVLNode(final Iterator<? extends E> iterator, final int start, final int end,\n                        final int absolutePositionOfParent, final AVLNode<E> prev, final AVLNode<E> next) {\n            final int mid = start + (end - start) / 2;\n            if (start < mid) {\n                left = new AVLNode<>(iterator, start, mid - 1, mid, prev, this);\n            } else {\n                leftIsPrevious = true;\n                left = prev;\n            }\n            value = iterator.next();\n            relativePosition = mid - absolutePositionOfParent;\n            if (mid < end) {\n                right = new AVLNode<>(iterator, mid + 1, end, mid, this, next);\n            } else {\n                rightIsNext = true;\n                right = next;\n            }\n            recalcHeight();\n        }", "docstring": "\nConstructs a new AVL tree from a collection.\n<p>\nThis is a recursive helper for {@link #AVLNode(Collection)}. A call\nto this method will construct the subtree for elements {@code start}\nthrough {@code end} of the collection, assuming the iterator\n{@code e} already points at element {@code start}.\n\n@param iterator  an iterator over the collection, which should already point\n         to the element at index {@code start} within the collection\n@param start  the index of the first element in the collection that\n         should be in this subtree\n@param end  the index of the last element in the collection that\n         should be in this subtree\n@param absolutePositionOfParent  absolute position of this node's\n         parent, or 0 if this node is the root\n@param prev  the {@code AVLNode} corresponding to element (start - 1)\n         of the collection, or null if start is 0\n@param next  the {@code AVLNode} corresponding to element (end + 1)\n         of the collection, or null if end is the last element of the collection\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "AVLNode", "params": [{"name": "iterator", "type": "Iterator<? extends E>"}, {"name": "start", "type": "int"}, {"name": "end", "type": "int"}, {"name": "absolutePositionOfParent", "type": "int"}, {"name": "prev", "type": "AVLNode<E>"}, {"name": "next", "type": "AVLNode<E>"}], "body": "                                                                                                          {\n            final int mid = start + (end - start) / 2;\n            if (start < mid) {\n                left = new AVLNode<>(iterator, start, mid - 1, mid, prev, this);\n            } else {\n                leftIsPrevious = true;\n                left = prev;\n            }\n            value = iterator.next();\n            relativePosition = mid - absolutePositionOfParent;\n            if (mid < end) {\n                right = new AVLNode<>(iterator, mid + 1, end, mid, this, next);\n            } else {\n                rightIsNext = true;\n                right = next;\n            }\n            recalcHeight();\n        }", "signature": "private AVLNode(final Iterator<? extends E> iterator, final int start, final int end,\n                        final int absolutePositionOfParent, final AVLNode<E> prev, final AVLNode<E> next)"}, {"syntax_pass": true, "original_string": "        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\n            otherTreeMin.relativePosition = currentSize - sParentAbsolutePosition;\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }", "docstring": "\nAppends the elements of another tree list to this tree list by efficiently\nmerging the two AVL trees. This operation is destructive to both trees and\nruns in O(log(m + n)) time.\n\n@param otherTree\n           the root of the AVL tree to merge with this one\n@param currentSize\n           the number of elements in this AVL tree\n@return the root of the new, merged AVL tree\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "AVLNode<E>", "classes": []}, "name": "addAll", "params": [{"name": "otherTree", "type": "AVLNode<E>"}, {"name": "currentSize", "type": "int"}], "body": "                                                                               {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\n            otherTreeMin.relativePosition = currentSize - sParentAbsolutePosition;\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }", "signature": "private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize)"}, {"syntax_pass": true, "original_string": "        private AVLNode<E> balance() {\n            switch (heightRightMinusLeft()) {\n            case 1 :\n            case 0 :\n            case -1 :\n                return this;\n            case -2 :\n                if (left.heightRightMinusLeft() > 0) {\n                    setLeft(left.rotateLeft(), null);\n                }\n                return rotateRight();\n            case 2 :\n                if (right.heightRightMinusLeft() < 0) {\n                    setRight(right.rotateRight(), null);\n                }\n                return rotateLeft();\n            default :\n                throw new IllegalStateException(\"tree inconsistent!\");\n            }\n        }", "docstring": "\nBalances according to the AVL algorithm.\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "AVLNode<E>", "classes": []}, "name": "balance", "params": [], "body": "                                     {\n            switch (heightRightMinusLeft()) {\n            case 1 :\n            case 0 :\n            case -1 :\n                return this;\n            case -2 :\n                if (left.heightRightMinusLeft() > 0) {\n                    setLeft(left.rotateLeft(), null);\n                }\n                return rotateRight();\n            case 2 :\n                if (right.heightRightMinusLeft() < 0) {\n                    setRight(right.rotateRight(), null);\n                }\n                return rotateLeft();\n            default :\n                throw new IllegalStateException(\"tree inconsistent!\");\n            }\n        }", "signature": "private AVLNode<E> balance()"}, {"syntax_pass": true, "original_string": "        AVLNode<E> get(final int index) {\n            final int indexRelativeToMe = index - relativePosition;\n\n            if (indexRelativeToMe == 0) {\n                return this;\n            }\n\n            final AVLNode<E> nextNode = indexRelativeToMe < 0 ? getLeftSubTree() : getRightSubTree();\n            if (nextNode == null) {\n                return null;\n            }\n            return nextNode.get(indexRelativeToMe);\n        }", "docstring": "\nLocate the element with the given index relative to the\noffset of the parent of this node.\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "AVLNode<E>", "classes": []}, "name": "get", "params": [{"name": "index", "type": "int"}], "body": "                                        {\n            final int indexRelativeToMe = index - relativePosition;\n\n            if (indexRelativeToMe == 0) {\n                return this;\n            }\n\n            final AVLNode<E> nextNode = indexRelativeToMe < 0 ? getLeftSubTree() : getRightSubTree();\n            if (nextNode == null) {\n                return null;\n            }\n            return nextNode.get(indexRelativeToMe);\n        }", "signature": "AVLNode<E> get(final int index)"}, {"syntax_pass": true, "original_string": "        private int getHeight(final AVLNode<E> node) {\n            return node == null ? -1 : node.height;\n        }", "docstring": "\nReturns the height of the node or -1 if the node is null.\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "int", "classes": []}, "name": "getHeight", "params": [{"name": "node", "type": "AVLNode<E>"}], "body": "                                                     {\n            return node == null ? -1 : node.height;\n        }", "signature": "private int getHeight(final AVLNode<E> node)"}, {"syntax_pass": true, "original_string": "        private AVLNode<E> getLeftSubTree() {\n            return leftIsPrevious ? null : left;\n        }", "docstring": "\nGets the left node, returning null if it's a faedelung.\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "AVLNode<E>", "classes": []}, "name": "getLeftSubTree", "params": [], "body": "                                            {\n            return leftIsPrevious ? null : left;\n        }", "signature": "private AVLNode<E> getLeftSubTree()"}, {"syntax_pass": true, "original_string": "        private int getOffset(final AVLNode<E> node) {\n            if (node == null) {\n                return 0;\n            }\n            return node.relativePosition;\n        }", "docstring": "\nGets the relative position.\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "int", "classes": []}, "name": "getOffset", "params": [{"name": "node", "type": "AVLNode<E>"}], "body": "                                                     {\n            if (node == null) {\n                return 0;\n            }\n            return node.relativePosition;\n        }", "signature": "private int getOffset(final AVLNode<E> node)"}, {"syntax_pass": true, "original_string": "        private AVLNode<E> getRightSubTree() {\n            return rightIsNext ? null : right;\n        }", "docstring": "\nGets the right node, returning null if it's a faedelung.\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "AVLNode<E>", "classes": []}, "name": "getRightSubTree", "params": [], "body": "                                             {\n            return rightIsNext ? null : right;\n        }", "signature": "private AVLNode<E> getRightSubTree()"}, {"syntax_pass": true, "original_string": "        E getValue() {\n            return value;\n        }", "docstring": "\nGets the value.\n\n@return the value of this node\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "E", "classes": []}, "name": "getValue", "params": [], "body": "                     {\n            return value;\n        }", "signature": "E getValue()"}, {"syntax_pass": true, "original_string": "        private int heightRightMinusLeft() {\n            return getHeight(getRightSubTree()) - getHeight(getLeftSubTree());\n        }", "docstring": "\nReturns the height difference right - left\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "int", "classes": []}, "name": "heightRightMinusLeft", "params": [], "body": "                                           {\n            return getHeight(getRightSubTree()) - getHeight(getLeftSubTree());\n        }", "signature": "private int heightRightMinusLeft()"}, {"syntax_pass": true, "original_string": "        int indexOf(final Object object, final int index) {\n            if (getLeftSubTree() != null) {\n                final int result = left.indexOf(object, index + left.relativePosition);\n                if (result != -1) {\n                    return result;\n                }\n            }\n            if (Objects.equals(value, object)) {\n                return index;\n            }\n            if (getRightSubTree() != null) {\n                return right.indexOf(object, index + right.relativePosition);\n            }\n            return -1;\n        }", "docstring": "\nLocate the index that contains the specified object.\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "int", "classes": []}, "name": "indexOf", "params": [{"name": "object", "type": "Object"}, {"name": "index", "type": "int"}], "body": "                                                          {\n            if (getLeftSubTree() != null) {\n                final int result = left.indexOf(object, index + left.relativePosition);\n                if (result != -1) {\n                    return result;\n                }\n            }\n            if (Objects.equals(value, object)) {\n                return index;\n            }\n            if (getRightSubTree() != null) {\n                return right.indexOf(object, index + right.relativePosition);\n            }\n            return -1;\n        }", "signature": "int indexOf(final Object object, final int index)"}, {"syntax_pass": true, "original_string": "        AVLNode<E> insert(final int index, final E obj) {\n            final int indexRelativeToMe = index - relativePosition;\n\n            if (indexRelativeToMe <= 0) {\n                return insertOnLeft(indexRelativeToMe, obj);\n            }\n            return insertOnRight(indexRelativeToMe, obj);\n        }", "docstring": "\nInserts a node at the position index.\n\n@param index is the index of the position relative to the position of\nthe parent node.\n@param obj is the object to be stored in the position.\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "AVLNode<E>", "classes": []}, "name": "insert", "params": [{"name": "index", "type": "int"}, {"name": "obj", "type": "E"}], "body": "                                                        {\n            final int indexRelativeToMe = index - relativePosition;\n\n            if (indexRelativeToMe <= 0) {\n                return insertOnLeft(indexRelativeToMe, obj);\n            }\n            return insertOnRight(indexRelativeToMe, obj);\n        }", "signature": "AVLNode<E> insert(final int index, final E obj)"}, {"syntax_pass": true, "original_string": "        private AVLNode<E> insertOnLeft(final int indexRelativeToMe, final E obj) {\n            if (getLeftSubTree() == null) {\n                setLeft(new AVLNode<>(-1, obj, this, left), null);\n            } else {\n                setLeft(left.insert(indexRelativeToMe, obj), null);\n            }\n\n            if (relativePosition >= 0) {\n                relativePosition++;\n            }\n            final AVLNode<E> ret = balance();\n            recalcHeight();\n            return ret;\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "AVLNode<E>", "classes": []}, "name": "insertOnLeft", "params": [{"name": "indexRelativeToMe", "type": "int"}, {"name": "obj", "type": "E"}], "body": "                                                                                  {\n            if (getLeftSubTree() == null) {\n                setLeft(new AVLNode<>(-1, obj, this, left), null);\n            } else {\n                setLeft(left.insert(indexRelativeToMe, obj), null);\n            }\n\n            if (relativePosition >= 0) {\n                relativePosition++;\n            }\n            final AVLNode<E> ret = balance();\n            recalcHeight();\n            return ret;\n        }", "signature": "private AVLNode<E> insertOnLeft(final int indexRelativeToMe, final E obj)"}, {"syntax_pass": true, "original_string": "        private AVLNode<E> insertOnRight(final int indexRelativeToMe, final E obj) {\n            if (getRightSubTree() == null) {\n                setRight(new AVLNode<>(+1, obj, right, this), null);\n            } else {\n                setRight(right.insert(indexRelativeToMe, obj), null);\n            }\n            if (relativePosition < 0) {\n                relativePosition--;\n            }\n            final AVLNode<E> ret = balance();\n            recalcHeight();\n            return ret;\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "AVLNode<E>", "classes": []}, "name": "insertOnRight", "params": [{"name": "indexRelativeToMe", "type": "int"}, {"name": "obj", "type": "E"}], "body": "                                                                                   {\n            if (getRightSubTree() == null) {\n                setRight(new AVLNode<>(+1, obj, right, this), null);\n            } else {\n                setRight(right.insert(indexRelativeToMe, obj), null);\n            }\n            if (relativePosition < 0) {\n                relativePosition--;\n            }\n            final AVLNode<E> ret = balance();\n            recalcHeight();\n            return ret;\n        }", "signature": "private AVLNode<E> insertOnRight(final int indexRelativeToMe, final E obj)"}, {"syntax_pass": true, "original_string": "        private AVLNode<E> max() {\n            return getRightSubTree() == null ? this : right.max();\n        }", "docstring": "\nGets the rightmost child of this node.\n\n@return the rightmost child (greatest index)\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "AVLNode<E>", "classes": []}, "name": "max", "params": [], "body": "                                 {\n            return getRightSubTree() == null ? this : right.max();\n        }", "signature": "private AVLNode<E> max()"}, {"syntax_pass": true, "original_string": "        private AVLNode<E> min() {\n            return getLeftSubTree() == null ? this : left.min();\n        }", "docstring": "\nGets the leftmost child of this node.\n\n@return the leftmost child (smallest index)\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "AVLNode<E>", "classes": []}, "name": "min", "params": [], "body": "                                 {\n            return getLeftSubTree() == null ? this : left.min();\n        }", "signature": "private AVLNode<E> min()"}, {"syntax_pass": true, "original_string": "        AVLNode<E> next() {\n            if (rightIsNext || right == null) {\n                return right;\n            }\n            return right.min();\n        }", "docstring": "\nGets the next node in the list after this one.\n\n@return the next node\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "AVLNode<E>", "classes": []}, "name": "next", "params": [], "body": "                          {\n            if (rightIsNext || right == null) {\n                return right;\n            }\n            return right.min();\n        }", "signature": "AVLNode<E> next()"}, {"syntax_pass": true, "original_string": "        AVLNode<E> previous() {\n            if (leftIsPrevious || left == null) {\n                return left;\n            }\n            return left.max();\n        }", "docstring": "\nGets the node in the list before this one.\n\n@return the previous node\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "AVLNode<E>", "classes": []}, "name": "previous", "params": [], "body": "                              {\n            if (leftIsPrevious || left == null) {\n                return left;\n            }\n            return left.max();\n        }", "signature": "AVLNode<E> previous()"}, {"syntax_pass": true, "original_string": "        private void recalcHeight() {\n            height = Math.max(\n                getLeftSubTree() == null ? -1 : getLeftSubTree().height,\n                getRightSubTree() == null ? -1 : getRightSubTree().height) + 1;\n        }", "docstring": "\nSets the height by calculation.\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "recalcHeight", "params": [], "body": "                                    {\n            height = Math.max(\n                getLeftSubTree() == null ? -1 : getLeftSubTree().height,\n                getRightSubTree() == null ? -1 : getRightSubTree().height) + 1;\n        }", "signature": "private void recalcHeight()"}, {"syntax_pass": true, "original_string": "        AVLNode<E> remove(final int index) {\n            final int indexRelativeToMe = index - relativePosition;\n\n            if (indexRelativeToMe == 0) {\n                return removeSelf();\n            }\n            if (indexRelativeToMe > 0) {\n                setRight(right.remove(indexRelativeToMe), right.right);\n                if (relativePosition < 0) {\n                    relativePosition++;\n                }\n            } else {\n                setLeft(left.remove(indexRelativeToMe), left.left);\n                if (relativePosition > 0) {\n                    relativePosition--;\n                }\n            }\n            recalcHeight();\n            return balance();\n        }", "docstring": "\nRemoves the node at a given position.\n\n@param index is the index of the element to be removed relative to the position of\nthe parent node of the current node.\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "AVLNode<E>", "classes": []}, "name": "remove", "params": [{"name": "index", "type": "int"}], "body": "                                           {\n            final int indexRelativeToMe = index - relativePosition;\n\n            if (indexRelativeToMe == 0) {\n                return removeSelf();\n            }\n            if (indexRelativeToMe > 0) {\n                setRight(right.remove(indexRelativeToMe), right.right);\n                if (relativePosition < 0) {\n                    relativePosition++;\n                }\n            } else {\n                setLeft(left.remove(indexRelativeToMe), left.left);\n                if (relativePosition > 0) {\n                    relativePosition--;\n                }\n            }\n            recalcHeight();\n            return balance();\n        }", "signature": "AVLNode<E> remove(final int index)"}, {"syntax_pass": true, "original_string": "        private AVLNode<E> removeMax() {\n            if (getRightSubTree() == null) {\n                return removeSelf();\n            }\n            setRight(right.removeMax(), right.right);\n            if (relativePosition < 0) {\n                relativePosition++;\n            }\n            recalcHeight();\n            return balance();\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "AVLNode<E>", "classes": []}, "name": "removeMax", "params": [], "body": "                                       {\n            if (getRightSubTree() == null) {\n                return removeSelf();\n            }\n            setRight(right.removeMax(), right.right);\n            if (relativePosition < 0) {\n                relativePosition++;\n            }\n            recalcHeight();\n            return balance();\n        }", "signature": "private AVLNode<E> removeMax()"}, {"syntax_pass": true, "original_string": "        private AVLNode<E> removeMin() {\n            if (getLeftSubTree() == null) {\n                return removeSelf();\n            }\n            setLeft(left.removeMin(), left.left);\n            if (relativePosition > 0) {\n                relativePosition--;\n            }\n            recalcHeight();\n            return balance();\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "AVLNode<E>", "classes": []}, "name": "removeMin", "params": [], "body": "                                       {\n            if (getLeftSubTree() == null) {\n                return removeSelf();\n            }\n            setLeft(left.removeMin(), left.left);\n            if (relativePosition > 0) {\n                relativePosition--;\n            }\n            recalcHeight();\n            return balance();\n        }", "signature": "private AVLNode<E> removeMin()"}, {"syntax_pass": true, "original_string": "        private AVLNode<E> removeSelf() {\n            if (getRightSubTree() == null && getLeftSubTree() == null) {\n                return null;\n            }\n            if (getRightSubTree() == null) {\n                if (relativePosition > 0) {\n                    left.relativePosition += relativePosition;\n                }\n                left.max().setRight(null, right);\n                return left;\n            }\n            if (getLeftSubTree() == null) {\n                right.relativePosition += relativePosition - (relativePosition < 0 ? 0 : 1);\n                right.min().setLeft(null, left);\n                return right;\n            }\n\n            if (heightRightMinusLeft() > 0) {\n                // more on the right, so delete from the right\n                final AVLNode<E> rightMin = right.min();\n                value = rightMin.value;\n                if (leftIsPrevious) {\n                    left = rightMin.left;\n                }\n                right = right.removeMin();\n                if (relativePosition < 0) {\n                    relativePosition++;\n                }\n            } else {\n                // more on the left or equal, so delete from the left\n                final AVLNode<E> leftMax = left.max();\n                value = leftMax.value;\n                if (rightIsNext) {\n                    right = leftMax.right;\n                }\n                final AVLNode<E> leftPrevious = left.left;\n                left = left.removeMax();\n                if (left == null) {\n                    // special case where left that was deleted was a double link\n                    // only occurs when height difference is equal\n                    left = leftPrevious;\n                    leftIsPrevious = true;\n                }\n                if (relativePosition > 0) {\n                    relativePosition--;\n                }\n            }\n            recalcHeight();\n            return this;\n        }", "docstring": "\nRemoves this node from the tree.\n\n@return the node that replaces this one in the parent\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "AVLNode<E>", "classes": []}, "name": "removeSelf", "params": [], "body": "                                        {\n            if (getRightSubTree() == null && getLeftSubTree() == null) {\n                return null;\n            }\n            if (getRightSubTree() == null) {\n                if (relativePosition > 0) {\n                    left.relativePosition += relativePosition;\n                }\n                left.max().setRight(null, right);\n                return left;\n            }\n            if (getLeftSubTree() == null) {\n                right.relativePosition += relativePosition - (relativePosition < 0 ? 0 : 1);\n                right.min().setLeft(null, left);\n                return right;\n            }\n\n            if (heightRightMinusLeft() > 0) {\n                // more on the right, so delete from the right\n                final AVLNode<E> rightMin = right.min();\n                value = rightMin.value;\n                if (leftIsPrevious) {\n                    left = rightMin.left;\n                }\n                right = right.removeMin();\n                if (relativePosition < 0) {\n                    relativePosition++;\n                }\n            } else {\n                // more on the left or equal, so delete from the left\n                final AVLNode<E> leftMax = left.max();\n                value = leftMax.value;\n                if (rightIsNext) {\n                    right = leftMax.right;\n                }\n                final AVLNode<E> leftPrevious = left.left;\n                left = left.removeMax();\n                if (left == null) {\n                    // special case where left that was deleted was a double link\n                    // only occurs when height difference is equal\n                    left = leftPrevious;\n                    leftIsPrevious = true;\n                }\n                if (relativePosition > 0) {\n                    relativePosition--;\n                }\n            }\n            recalcHeight();\n            return this;\n        }", "signature": "private AVLNode<E> removeSelf()"}, {"syntax_pass": true, "original_string": "        private AVLNode<E> rotateLeft() {\n            final AVLNode<E> newTop = right; // can't be faedelung!\n            final AVLNode<E> movedNode = getRightSubTree().getLeftSubTree();\n\n            final int newTopPosition = relativePosition + getOffset(newTop);\n            final int myNewPosition = -newTop.relativePosition;\n            final int movedPosition = getOffset(newTop) + getOffset(movedNode);\n\n            setRight(movedNode, newTop);\n            newTop.setLeft(this, null);\n\n            setOffset(newTop, newTopPosition);\n            setOffset(this, myNewPosition);\n            setOffset(movedNode, movedPosition);\n            return newTop;\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "AVLNode<E>", "classes": []}, "name": "rotateLeft", "params": [], "body": "                                        {\n            final AVLNode<E> newTop = right; // can't be faedelung!\n            final AVLNode<E> movedNode = getRightSubTree().getLeftSubTree();\n\n            final int newTopPosition = relativePosition + getOffset(newTop);\n            final int myNewPosition = -newTop.relativePosition;\n            final int movedPosition = getOffset(newTop) + getOffset(movedNode);\n\n            setRight(movedNode, newTop);\n            newTop.setLeft(this, null);\n\n            setOffset(newTop, newTopPosition);\n            setOffset(this, myNewPosition);\n            setOffset(movedNode, movedPosition);\n            return newTop;\n        }", "signature": "private AVLNode<E> rotateLeft()"}, {"syntax_pass": true, "original_string": "        private AVLNode<E> rotateRight() {\n            final AVLNode<E> newTop = left; // can't be faedelung\n            final AVLNode<E> movedNode = getLeftSubTree().getRightSubTree();\n\n            final int newTopPosition = relativePosition + getOffset(newTop);\n            final int myNewPosition = -newTop.relativePosition;\n            final int movedPosition = getOffset(newTop) + getOffset(movedNode);\n\n            setLeft(movedNode, newTop);\n            newTop.setRight(this, null);\n\n            setOffset(newTop, newTopPosition);\n            setOffset(this, myNewPosition);\n            setOffset(movedNode, movedPosition);\n            return newTop;\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "AVLNode<E>", "classes": []}, "name": "rotateRight", "params": [], "body": "                                         {\n            final AVLNode<E> newTop = left; // can't be faedelung\n            final AVLNode<E> movedNode = getLeftSubTree().getRightSubTree();\n\n            final int newTopPosition = relativePosition + getOffset(newTop);\n            final int myNewPosition = -newTop.relativePosition;\n            final int movedPosition = getOffset(newTop) + getOffset(movedNode);\n\n            setLeft(movedNode, newTop);\n            newTop.setRight(this, null);\n\n            setOffset(newTop, newTopPosition);\n            setOffset(this, myNewPosition);\n            setOffset(movedNode, movedPosition);\n            return newTop;\n        }", "signature": "private AVLNode<E> rotateRight()"}, {"syntax_pass": true, "original_string": "        private void setLeft(final AVLNode<E> node, final AVLNode<E> previous) {\n            leftIsPrevious = node == null;\n            left = leftIsPrevious ? previous : node;\n            recalcHeight();\n        }", "docstring": "\nSets the left field to the node, or the previous node if that is null\n\n@param node  the new left subtree node\n@param previous  the previous node in the linked list\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "setLeft", "params": [{"name": "node", "type": "AVLNode<E>"}, {"name": "previous", "type": "AVLNode<E>"}], "body": "                                                                               {\n            leftIsPrevious = node == null;\n            left = leftIsPrevious ? previous : node;\n            recalcHeight();\n        }", "signature": "private void setLeft(final AVLNode<E> node, final AVLNode<E> previous)"}, {"syntax_pass": true, "original_string": "        private int setOffset(final AVLNode<E> node, final int newOffset) {\n            if (node == null) {\n                return 0;\n            }\n            final int oldOffset = getOffset(node);\n            node.relativePosition = newOffset;\n            return oldOffset;\n        }", "docstring": "\nSets the relative position.\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "int", "classes": []}, "name": "setOffset", "params": [{"name": "node", "type": "AVLNode<E>"}, {"name": "newOffset", "type": "int"}], "body": "                                                                          {\n            if (node == null) {\n                return 0;\n            }\n            final int oldOffset = getOffset(node);\n            node.relativePosition = newOffset;\n            return oldOffset;\n        }", "signature": "private int setOffset(final AVLNode<E> node, final int newOffset)"}, {"syntax_pass": true, "original_string": "        private void setRight(final AVLNode<E> node, final AVLNode<E> next) {\n            rightIsNext = node == null;\n            right = rightIsNext ? next : node;\n            recalcHeight();\n        }", "docstring": "\nSets the right field to the node, or the next node if that is null\n\n@param node  the new left subtree node\n@param next  the next node in the linked list\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "setRight", "params": [{"name": "node", "type": "AVLNode<E>"}, {"name": "next", "type": "AVLNode<E>"}], "body": "                                                                            {\n            rightIsNext = node == null;\n            right = rightIsNext ? next : node;\n            recalcHeight();\n        }", "signature": "private void setRight(final AVLNode<E> node, final AVLNode<E> next)"}, {"syntax_pass": true, "original_string": "        void setValue(final E obj) {\n            this.value = obj;\n        }", "docstring": "\nSets the value.\n\n@param obj  the value to store\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "setValue", "params": [{"name": "obj", "type": "E"}], "body": "                                   {\n            this.value = obj;\n        }", "signature": "void setValue(final E obj)"}, {"syntax_pass": true, "original_string": "        void toArray(final Object[] array, final int index) {\n            array[index] = value;\n            if (getLeftSubTree() != null) {\n                left.toArray(array, index + left.relativePosition);\n            }\n            if (getRightSubTree() != null) {\n                right.toArray(array, index + right.relativePosition);\n            }\n        }", "docstring": "\nStores the node and its children into the array specified.\n\n@param array the array to be filled\n@param index the index of this node\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "toArray", "params": [{"name": "array", "type": "Object[]"}, {"name": "index", "type": "int"}], "body": "                                                            {\n            array[index] = value;\n            if (getLeftSubTree() != null) {\n                left.toArray(array, index + left.relativePosition);\n            }\n            if (getRightSubTree() != null) {\n                right.toArray(array, index + right.relativePosition);\n            }\n        }", "signature": "void toArray(final Object[] array, final int index)"}, {"syntax_pass": true, "original_string": "        @Override\n        public String toString() {\n            return new StringBuilder()\n                .append(\"AVLNode(\")\n                .append(relativePosition)\n                .append(CollectionUtils.COMMA)\n                .append(left != null)\n                .append(CollectionUtils.COMMA)\n                .append(value)\n                .append(CollectionUtils.COMMA)\n                .append(getRightSubTree() != null)\n                .append(rightIsNext)\n                .append(\")\")\n                .toString();\n        }", "docstring": "\nUsed for debugging.\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                 {\n            return new StringBuilder()\n                .append(\"AVLNode(\")\n                .append(relativePosition)\n                .append(CollectionUtils.COMMA)\n                .append(left != null)\n                .append(CollectionUtils.COMMA)\n                .append(value)\n                .append(CollectionUtils.COMMA)\n                .append(getRightSubTree() != null)\n                .append(rightIsNext)\n                .append(\")\")\n                .toString();\n        }", "signature": "@Override\n        public String toString()"}]}, {"original_string": "    static class TreeListIterator<E> implements ListIterator<E>, OrderedIterator<E> {\n        /** The parent list */\n        private final TreeList<E> parent;\n        /**\n         * Cache of the next node that will be returned by {@link #next()}.\n         */\n        private AVLNode<E> next;\n        /**\n         * The index of the next node to be returned.\n         */\n        private int nextIndex;\n        /**\n         * Cache of the last node that was returned by {@link #next()}\n         * or {@link #previous()}.\n         */\n        private AVLNode<E> current;\n        /**\n         * The index of the last node that was returned.\n         */\n        private int currentIndex;\n        /**\n         * The modification count that the list is expected to have. If the list\n         * doesn't have this count, then a\n         * {@link java.util.ConcurrentModificationException} may be thrown by\n         * the operations.\n         */\n        private int expectedModCount;\n\n        /**\n         * Create a ListIterator for a list.\n         *\n         * @param parent  the parent list\n         * @param fromIndex  the index to start at\n         */\n        protected TreeListIterator(final TreeList<E> parent, final int fromIndex) {\n            this.parent = parent;\n            this.expectedModCount = parent.modCount;\n            this.next = parent.root == null ? null : parent.root.get(fromIndex);\n            this.nextIndex = fromIndex;\n            this.currentIndex = -1;\n        }\n\n        @Override\n        public void add(final E obj) {\n            checkModCount();\n            parent.add(nextIndex, obj);\n            current = null;\n            currentIndex = -1;\n            nextIndex++;\n            expectedModCount++;\n        }\n\n        /**\n         * Checks the modification count of the list is the value that this\n         * object expects.\n         *\n         * @throws ConcurrentModificationException If the list's modification\n         * count isn't the value that was expected.\n         */\n        protected void checkModCount() {\n            if (parent.modCount != expectedModCount) {\n                throw new ConcurrentModificationException();\n            }\n        }\n\n        @Override\n        public boolean hasNext() {\n            return nextIndex < parent.size();\n        }\n\n        @Override\n        public boolean hasPrevious() {\n            return nextIndex > 0;\n        }\n\n        @Override\n        public E next() {\n            checkModCount();\n            if (!hasNext()) {\n                throw new NoSuchElementException(\"No element at index \" + nextIndex + \".\");\n            }\n            if (next == null) {\n                next = parent.root.get(nextIndex);\n            }\n            final E value = next.getValue();\n            current = next;\n            currentIndex = nextIndex++;\n            next = next.next();\n            return value;\n        }\n\n        @Override\n        public int nextIndex() {\n            return nextIndex;\n        }\n\n        @Override\n        public E previous() {\n            checkModCount();\n            if (!hasPrevious()) {\n                throw new NoSuchElementException(\"Already at start of list.\");\n            }\n            if (next == null) {\n                next = parent.root.get(nextIndex - 1);\n            } else {\n                next = next.previous();\n            }\n            final E value = next.getValue();\n            current = next;\n            currentIndex = --nextIndex;\n            return value;\n        }\n\n        @Override\n        public int previousIndex() {\n            return nextIndex() - 1;\n        }\n\n        @Override\n        public void remove() {\n            checkModCount();\n            if (currentIndex == -1) {\n                throw new IllegalStateException();\n            }\n            parent.remove(currentIndex);\n            if (nextIndex != currentIndex) {\n                // remove() following next()\n                nextIndex--;\n            }\n            // the AVL node referenced by next may have become stale after a remove\n            // reset it now: will be retrieved by next call to next()/previous() via nextIndex\n            next = null;\n            current = null;\n            currentIndex = -1;\n            expectedModCount++;\n        }\n\n        @Override\n        public void set(final E obj) {\n            checkModCount();\n            if (current == null) {\n                throw new IllegalStateException();\n            }\n            current.setValue(obj);\n        }\n    }", "definition": "    static class TreeListIterator<E> implements ListIterator<E>, OrderedIterator<E>", "class_docstring": "\nA list iterator over the linked list.\n", "name": "TreeListIterator", "super_interfaces": ["ListIterator<E>", "OrderedIterator<E>"], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "private final TreeList<E> parent;", "docstring": " The parent list", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "TreeList<E>", "name": "parent", "syntax_pass": true}, {"attribute_expression": "private AVLNode<E> next;", "docstring": "\nCache of the next node that will be returned by {@link #next()}.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "AVLNode<E>", "name": "next", "syntax_pass": true}, {"attribute_expression": "private int nextIndex;", "docstring": "\nThe index of the next node to be returned.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "nextIndex", "syntax_pass": true}, {"attribute_expression": "private AVLNode<E> current;", "docstring": "\nCache of the last node that was returned by {@link #next()}\nor {@link #previous()}.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "AVLNode<E>", "name": "current", "syntax_pass": true}, {"attribute_expression": "private int currentIndex;", "docstring": "\nThe index of the last node that was returned.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "currentIndex", "syntax_pass": true}, {"attribute_expression": "private int expectedModCount;", "docstring": "\nThe modification count that the list is expected to have. If the list\ndoesn't have this count, then a\n{@link java.util.ConcurrentModificationException} may be thrown by\nthe operations.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "expectedModCount", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        protected TreeListIterator(final TreeList<E> parent, final int fromIndex) {\n            this.parent = parent;\n            this.expectedModCount = parent.modCount;\n            this.next = parent.root == null ? null : parent.root.get(fromIndex);\n            this.nextIndex = fromIndex;\n            this.currentIndex = -1;\n        }", "docstring": "\nCreate a ListIterator for a list.\n\n@param parent  the parent list\n@param fromIndex  the index to start at\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "name": "TreeListIterator", "params": [{"name": "parent", "type": "TreeList<E>"}, {"name": "fromIndex", "type": "int"}], "body": "                                                                                  {\n            this.parent = parent;\n            this.expectedModCount = parent.modCount;\n            this.next = parent.root == null ? null : parent.root.get(fromIndex);\n            this.nextIndex = fromIndex;\n            this.currentIndex = -1;\n        }", "signature": "protected TreeListIterator(final TreeList<E> parent, final int fromIndex)"}, {"syntax_pass": true, "original_string": "        @Override\n        public void add(final E obj) {\n            checkModCount();\n            parent.add(nextIndex, obj);\n            current = null;\n            currentIndex = -1;\n            nextIndex++;\n            expectedModCount++;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "add", "params": [{"name": "obj", "type": "E"}], "body": "                                     {\n            checkModCount();\n            parent.add(nextIndex, obj);\n            current = null;\n            currentIndex = -1;\n            nextIndex++;\n            expectedModCount++;\n        }", "signature": "@Override\n        public void add(final E obj)"}, {"syntax_pass": true, "original_string": "        protected void checkModCount() {\n            if (parent.modCount != expectedModCount) {\n                throw new ConcurrentModificationException();\n            }\n        }", "docstring": "\nChecks the modification count of the list is the value that this\nobject expects.\n\n@throws ConcurrentModificationException If the list's modification\ncount isn't the value that was expected.\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "name": "checkModCount", "params": [], "body": "                                       {\n            if (parent.modCount != expectedModCount) {\n                throw new ConcurrentModificationException();\n            }\n        }", "signature": "protected void checkModCount()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean hasNext() {\n            return nextIndex < parent.size();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasNext", "params": [], "body": "                                 {\n            return nextIndex < parent.size();\n        }", "signature": "@Override\n        public boolean hasNext()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean hasPrevious() {\n            return nextIndex > 0;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasPrevious", "params": [], "body": "                                     {\n            return nextIndex > 0;\n        }", "signature": "@Override\n        public boolean hasPrevious()"}, {"syntax_pass": true, "original_string": "        @Override\n        public E next() {\n            checkModCount();\n            if (!hasNext()) {\n                throw new NoSuchElementException(\"No element at index \" + nextIndex + \".\");\n            }\n            if (next == null) {\n                next = parent.root.get(nextIndex);\n            }\n            final E value = next.getValue();\n            current = next;\n            currentIndex = nextIndex++;\n            next = next.next();\n            return value;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "E", "classes": []}, "name": "next", "params": [], "body": "                        {\n            checkModCount();\n            if (!hasNext()) {\n                throw new NoSuchElementException(\"No element at index \" + nextIndex + \".\");\n            }\n            if (next == null) {\n                next = parent.root.get(nextIndex);\n            }\n            final E value = next.getValue();\n            current = next;\n            currentIndex = nextIndex++;\n            next = next.next();\n            return value;\n        }", "signature": "@Override\n        public E next()"}, {"syntax_pass": true, "original_string": "        @Override\n        public int nextIndex() {\n            return nextIndex;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "nextIndex", "params": [], "body": "                               {\n            return nextIndex;\n        }", "signature": "@Override\n        public int nextIndex()"}, {"syntax_pass": true, "original_string": "        @Override\n        public E previous() {\n            checkModCount();\n            if (!hasPrevious()) {\n                throw new NoSuchElementException(\"Already at start of list.\");\n            }\n            if (next == null) {\n                next = parent.root.get(nextIndex - 1);\n            } else {\n                next = next.previous();\n            }\n            final E value = next.getValue();\n            current = next;\n            currentIndex = --nextIndex;\n            return value;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "E", "classes": []}, "name": "previous", "params": [], "body": "                            {\n            checkModCount();\n            if (!hasPrevious()) {\n                throw new NoSuchElementException(\"Already at start of list.\");\n            }\n            if (next == null) {\n                next = parent.root.get(nextIndex - 1);\n            } else {\n                next = next.previous();\n            }\n            final E value = next.getValue();\n            current = next;\n            currentIndex = --nextIndex;\n            return value;\n        }", "signature": "@Override\n        public E previous()"}, {"syntax_pass": true, "original_string": "        @Override\n        public int previousIndex() {\n            return nextIndex() - 1;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "previousIndex", "params": [], "body": "                                   {\n            return nextIndex() - 1;\n        }", "signature": "@Override\n        public int previousIndex()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void remove() {\n            checkModCount();\n            if (currentIndex == -1) {\n                throw new IllegalStateException();\n            }\n            parent.remove(currentIndex);\n            if (nextIndex != currentIndex) {\n                // remove() following next()\n                nextIndex--;\n            }\n            // the AVL node referenced by next may have become stale after a remove\n            // reset it now: will be retrieved by next call to next()/previous() via nextIndex\n            next = null;\n            current = null;\n            currentIndex = -1;\n            expectedModCount++;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "remove", "params": [], "body": "                             {\n            checkModCount();\n            if (currentIndex == -1) {\n                throw new IllegalStateException();\n            }\n            parent.remove(currentIndex);\n            if (nextIndex != currentIndex) {\n                // remove() following next()\n                nextIndex--;\n            }\n            // the AVL node referenced by next may have become stale after a remove\n            // reset it now: will be retrieved by next call to next()/previous() via nextIndex\n            next = null;\n            current = null;\n            currentIndex = -1;\n            expectedModCount++;\n        }", "signature": "@Override\n        public void remove()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void set(final E obj) {\n            checkModCount();\n            if (current == null) {\n                throw new IllegalStateException();\n            }\n            current.setValue(obj);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "set", "params": [{"name": "obj", "type": "E"}], "body": "                                     {\n            checkModCount();\n            if (current == null) {\n                throw new IllegalStateException();\n            }\n            current.setValue(obj);\n        }", "signature": "@Override\n        public void set(final E obj)"}]}], "class_docstring": "\nA {@code List} implementation that is optimized for fast insertions and\nremovals at any index in the list.\n<p>\nThis list implementation utilises a tree structure internally to ensure that\nall insertions and removals are O(log n). This provides much faster performance\nthan both an {@code ArrayList} and a {@code LinkedList} where elements\nare inserted and removed repeatedly from anywhere in the list.\n</p>\n<p>\nThe following relative performance statistics are indicative of this class:\n</p>\n<pre>\n             get  add  insert  iterate  remove\nTreeList       3    5       1       2       1\nArrayList      1    1      40       1      40\nLinkedList  5800    1     350       2     325\n</pre>\n<p>\n{@code ArrayList} is a good general purpose list implementation.\nIt is faster than {@code TreeList} for most operations except inserting\nand removing in the middle of the list. {@code ArrayList} also uses less\nmemory as {@code TreeList} uses one object per entry.\n</p>\n<p>\n{@code LinkedList} is rarely a good choice of implementation.\n{@code TreeList} is almost always a good replacement for it, although it\ndoes use slightly more memory.\n</p>\n\n@param <E> the type of the elements in the list.\n@since 3.1\n", "original_string": "public class TreeList<E> extends AbstractList<E> {\n//    add; toArray; iterator; insert; get; indexOf; remove\n//    TreeList = 1260;7360;3080;  160;   170;3400;  170;\n//   ArrayList =  220;1480;1760; 6870;    50;1540; 7200;\n//  LinkedList =  270;7360;3350;55860;290720;2910;55200;\n\n    /**\n     * Implements an AVLNode which keeps the offset updated.\n     * <p>\n     * This node contains the real work.\n     * TreeList is just there to implement {@link java.util.List}.\n     * The nodes don't know the index of the object they are holding.  They\n     * do know however their position relative to their parent node.\n     * This allows to calculate the index of a node while traversing the tree.\n     * <p>\n     * The Faedelung calculation stores a flag for both the left and right child\n     * to indicate if they are a child (false) or a link as in linked list (true).\n     */\n    static class AVLNode<E> {\n        /** The left child node or the predecessor if {@link #leftIsPrevious}.*/\n        private AVLNode<E> left;\n        /** Flag indicating that left reference is not a subtree but the predecessor. */\n        private boolean leftIsPrevious;\n        /** The right child node or the successor if {@link #rightIsNext}. */\n        private AVLNode<E> right;\n        /** Flag indicating that right reference is not a subtree but the successor. */\n        private boolean rightIsNext;\n        /** How many levels of left/right are below this one. */\n        private int height;\n        /** The relative position, root holds absolute position. */\n        private int relativePosition;\n        /** The stored element. */\n        private E value;\n\n        /**\n         * Constructs a new AVL tree from a collection.\n         * <p>\n         * The collection must be nonempty.\n         *\n         * @param coll  a nonempty collection\n         */\n        private AVLNode(final Collection<? extends E> coll) {\n            this(coll.iterator(), 0, coll.size() - 1, 0, null, null);\n        }\n\n        /**\n         * Constructs a new node with a relative position.\n         *\n         * @param relativePosition  the relative position of the node\n         * @param obj  the value for the node\n         * @param rightFollower the node with the value following this one\n         * @param leftFollower the node with the value leading this one\n         */\n        private AVLNode(final int relativePosition, final E obj,\n                        final AVLNode<E> rightFollower, final AVLNode<E> leftFollower) {\n            this.relativePosition = relativePosition;\n            value = obj;\n            rightIsNext = true;\n            leftIsPrevious = true;\n            right = rightFollower;\n            left = leftFollower;\n        }\n\n        /**\n         * Constructs a new AVL tree from a collection.\n         * <p>\n         * This is a recursive helper for {@link #AVLNode(Collection)}. A call\n         * to this method will construct the subtree for elements {@code start}\n         * through {@code end} of the collection, assuming the iterator\n         * {@code e} already points at element {@code start}.\n         *\n         * @param iterator  an iterator over the collection, which should already point\n         *          to the element at index {@code start} within the collection\n         * @param start  the index of the first element in the collection that\n         *          should be in this subtree\n         * @param end  the index of the last element in the collection that\n         *          should be in this subtree\n         * @param absolutePositionOfParent  absolute position of this node's\n         *          parent, or 0 if this node is the root\n         * @param prev  the {@code AVLNode} corresponding to element (start - 1)\n         *          of the collection, or null if start is 0\n         * @param next  the {@code AVLNode} corresponding to element (end + 1)\n         *          of the collection, or null if end is the last element of the collection\n         */\n        private AVLNode(final Iterator<? extends E> iterator, final int start, final int end,\n                        final int absolutePositionOfParent, final AVLNode<E> prev, final AVLNode<E> next) {\n            final int mid = start + (end - start) / 2;\n            if (start < mid) {\n                left = new AVLNode<>(iterator, start, mid - 1, mid, prev, this);\n            } else {\n                leftIsPrevious = true;\n                left = prev;\n            }\n            value = iterator.next();\n            relativePosition = mid - absolutePositionOfParent;\n            if (mid < end) {\n                right = new AVLNode<>(iterator, mid + 1, end, mid, this, next);\n            } else {\n                rightIsNext = true;\n                right = next;\n            }\n            recalcHeight();\n        }\n\n        /**\n         * Appends the elements of another tree list to this tree list by efficiently\n         * merging the two AVL trees. This operation is destructive to both trees and\n         * runs in O(log(m + n)) time.\n         *\n         * @param otherTree\n         *            the root of the AVL tree to merge with this one\n         * @param currentSize\n         *            the number of elements in this AVL tree\n         * @return the root of the new, merged AVL tree\n         */\n        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n            final AVLNode<E> maxNode = max();\n            final AVLNode<E> otherTreeMin = otherTree.min();\n\n            // We need to efficiently merge the two AVL trees while keeping them\n            // balanced (or nearly balanced). To do this, we take the shorter\n            // tree and combine it with a similar-height subtree of the taller\n            // tree. There are two symmetric cases:\n            //   * this tree is taller, or\n            //   * otherTree is taller.\n            if (otherTree.height > height) {\n                // CASE 1: The other tree is taller than this one. We will thus\n                // merge this tree into otherTree.\n\n                // STEP 1: Remove the maximum element from this tree.\n                final AVLNode<E> leftSubTree = removeMax();\n\n                // STEP 2: Navigate left from the root of otherTree until we\n                // find a subtree, s, that is no taller than me. (While we are\n                // navigating left, we store the nodes we encounter in a stack\n                // so that we can re-balance them in step 4.)\n                final Deque<AVLNode<E>> sAncestors = new ArrayDeque<>();\n                AVLNode<E> s = otherTree;\n                int sAbsolutePosition = s.relativePosition + currentSize;\n                int sParentAbsolutePosition = 0;\n                while (s != null && s.height > getHeight(leftSubTree)) {\n                    sParentAbsolutePosition = sAbsolutePosition;\n                    sAncestors.push(s);\n                    s = s.left;\n                    if (s != null) {\n                        sAbsolutePosition += s.relativePosition;\n                    }\n                }\n\n                // STEP 3: Replace s with a newly constructed subtree whose root\n                // is maxNode, whose left subtree is leftSubTree, and whose right\n                // subtree is s.\n                maxNode.setLeft(leftSubTree, null);\n                maxNode.setRight(s, otherTreeMin);\n                if (leftSubTree != null) {\n                    leftSubTree.max().setRight(null, maxNode);\n                    leftSubTree.relativePosition -= currentSize - 1;\n                }\n                if (s != null) {\n                    s.min().setLeft(null, maxNode);\n                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n                }\n                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n                otherTree.relativePosition += currentSize;\n\n                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n                s = maxNode;\n                while (!sAncestors.isEmpty()) {\n                    final AVLNode<E> sAncestor = sAncestors.pop();\n                    sAncestor.setLeft(s, null);\n                    s = sAncestor.balance();\n                }\n                return s;\n            }\n            otherTree = otherTree.removeMin();\n\n            final Deque<AVLNode<E>> sAncestors = new ArrayDeque<>();\n            AVLNode<E> s = this;\n            int sAbsolutePosition = s.relativePosition;\n            int sParentAbsolutePosition = 0;\n            while (s != null && s.height > getHeight(otherTree)) {\n                sParentAbsolutePosition = sAbsolutePosition;\n                sAncestors.push(s);\n                s = s.right;\n                if (s != null) {\n                    sAbsolutePosition += s.relativePosition;\n                }\n            }\n\n            otherTreeMin.setRight(otherTree, null);\n            otherTreeMin.setLeft(s, maxNode);\n            if (otherTree != null) {\n                otherTree.min().setLeft(null, otherTreeMin);\n                otherTree.relativePosition++;\n            }\n            if (s != null) {\n                s.max().setRight(null, otherTreeMin);\n                s.relativePosition = sAbsolutePosition - currentSize;\n            }\n            otherTreeMin.relativePosition = currentSize - sParentAbsolutePosition;\n\n            s = otherTreeMin;\n            while (!sAncestors.isEmpty()) {\n                final AVLNode<E> sAncestor = sAncestors.pop();\n                sAncestor.setRight(s, null);\n                s = sAncestor.balance();\n            }\n            return s;\n        }\n\n        /**\n         * Balances according to the AVL algorithm.\n         */\n        private AVLNode<E> balance() {\n            switch (heightRightMinusLeft()) {\n            case 1 :\n            case 0 :\n            case -1 :\n                return this;\n            case -2 :\n                if (left.heightRightMinusLeft() > 0) {\n                    setLeft(left.rotateLeft(), null);\n                }\n                return rotateRight();\n            case 2 :\n                if (right.heightRightMinusLeft() < 0) {\n                    setRight(right.rotateRight(), null);\n                }\n                return rotateLeft();\n            default :\n                throw new IllegalStateException(\"tree inconsistent!\");\n            }\n        }\n\n        /**\n         * Locate the element with the given index relative to the\n         * offset of the parent of this node.\n         */\n        AVLNode<E> get(final int index) {\n            final int indexRelativeToMe = index - relativePosition;\n\n            if (indexRelativeToMe == 0) {\n                return this;\n            }\n\n            final AVLNode<E> nextNode = indexRelativeToMe < 0 ? getLeftSubTree() : getRightSubTree();\n            if (nextNode == null) {\n                return null;\n            }\n            return nextNode.get(indexRelativeToMe);\n        }\n\n        /**\n         * Returns the height of the node or -1 if the node is null.\n         */\n        private int getHeight(final AVLNode<E> node) {\n            return node == null ? -1 : node.height;\n        }\n\n        /**\n         * Gets the left node, returning null if it's a faedelung.\n         */\n        private AVLNode<E> getLeftSubTree() {\n            return leftIsPrevious ? null : left;\n        }\n\n        /**\n         * Gets the relative position.\n         */\n        private int getOffset(final AVLNode<E> node) {\n            if (node == null) {\n                return 0;\n            }\n            return node.relativePosition;\n        }\n\n        /**\n         * Gets the right node, returning null if it's a faedelung.\n         */\n        private AVLNode<E> getRightSubTree() {\n            return rightIsNext ? null : right;\n        }\n\n        /**\n         * Gets the value.\n         *\n         * @return the value of this node\n         */\n        E getValue() {\n            return value;\n        }\n\n        /**\n         * Returns the height difference right - left\n         */\n        private int heightRightMinusLeft() {\n            return getHeight(getRightSubTree()) - getHeight(getLeftSubTree());\n        }\n\n        /**\n         * Locate the index that contains the specified object.\n         */\n        int indexOf(final Object object, final int index) {\n            if (getLeftSubTree() != null) {\n                final int result = left.indexOf(object, index + left.relativePosition);\n                if (result != -1) {\n                    return result;\n                }\n            }\n            if (Objects.equals(value, object)) {\n                return index;\n            }\n            if (getRightSubTree() != null) {\n                return right.indexOf(object, index + right.relativePosition);\n            }\n            return -1;\n        }\n\n        /**\n         * Inserts a node at the position index.\n         *\n         * @param index is the index of the position relative to the position of\n         * the parent node.\n         * @param obj is the object to be stored in the position.\n         */\n        AVLNode<E> insert(final int index, final E obj) {\n            final int indexRelativeToMe = index - relativePosition;\n\n            if (indexRelativeToMe <= 0) {\n                return insertOnLeft(indexRelativeToMe, obj);\n            }\n            return insertOnRight(indexRelativeToMe, obj);\n        }\n\n        private AVLNode<E> insertOnLeft(final int indexRelativeToMe, final E obj) {\n            if (getLeftSubTree() == null) {\n                setLeft(new AVLNode<>(-1, obj, this, left), null);\n            } else {\n                setLeft(left.insert(indexRelativeToMe, obj), null);\n            }\n\n            if (relativePosition >= 0) {\n                relativePosition++;\n            }\n            final AVLNode<E> ret = balance();\n            recalcHeight();\n            return ret;\n        }\n\n        private AVLNode<E> insertOnRight(final int indexRelativeToMe, final E obj) {\n            if (getRightSubTree() == null) {\n                setRight(new AVLNode<>(+1, obj, right, this), null);\n            } else {\n                setRight(right.insert(indexRelativeToMe, obj), null);\n            }\n            if (relativePosition < 0) {\n                relativePosition--;\n            }\n            final AVLNode<E> ret = balance();\n            recalcHeight();\n            return ret;\n        }\n\n        /**\n         * Gets the rightmost child of this node.\n         *\n         * @return the rightmost child (greatest index)\n         */\n        private AVLNode<E> max() {\n            return getRightSubTree() == null ? this : right.max();\n        }\n\n        /**\n         * Gets the leftmost child of this node.\n         *\n         * @return the leftmost child (smallest index)\n         */\n        private AVLNode<E> min() {\n            return getLeftSubTree() == null ? this : left.min();\n        }\n\n        /**\n         * Gets the next node in the list after this one.\n         *\n         * @return the next node\n         */\n        AVLNode<E> next() {\n            if (rightIsNext || right == null) {\n                return right;\n            }\n            return right.min();\n        }\n\n        /**\n         * Gets the node in the list before this one.\n         *\n         * @return the previous node\n         */\n        AVLNode<E> previous() {\n            if (leftIsPrevious || left == null) {\n                return left;\n            }\n            return left.max();\n        }\n\n        /**\n         * Sets the height by calculation.\n         */\n        private void recalcHeight() {\n            height = Math.max(\n                getLeftSubTree() == null ? -1 : getLeftSubTree().height,\n                getRightSubTree() == null ? -1 : getRightSubTree().height) + 1;\n        }\n\n        /**\n         * Removes the node at a given position.\n         *\n         * @param index is the index of the element to be removed relative to the position of\n         * the parent node of the current node.\n         */\n        AVLNode<E> remove(final int index) {\n            final int indexRelativeToMe = index - relativePosition;\n\n            if (indexRelativeToMe == 0) {\n                return removeSelf();\n            }\n            if (indexRelativeToMe > 0) {\n                setRight(right.remove(indexRelativeToMe), right.right);\n                if (relativePosition < 0) {\n                    relativePosition++;\n                }\n            } else {\n                setLeft(left.remove(indexRelativeToMe), left.left);\n                if (relativePosition > 0) {\n                    relativePosition--;\n                }\n            }\n            recalcHeight();\n            return balance();\n        }\n\n        private AVLNode<E> removeMax() {\n            if (getRightSubTree() == null) {\n                return removeSelf();\n            }\n            setRight(right.removeMax(), right.right);\n            if (relativePosition < 0) {\n                relativePosition++;\n            }\n            recalcHeight();\n            return balance();\n        }\n\n        private AVLNode<E> removeMin() {\n            if (getLeftSubTree() == null) {\n                return removeSelf();\n            }\n            setLeft(left.removeMin(), left.left);\n            if (relativePosition > 0) {\n                relativePosition--;\n            }\n            recalcHeight();\n            return balance();\n        }\n\n        /**\n         * Removes this node from the tree.\n         *\n         * @return the node that replaces this one in the parent\n         */\n        private AVLNode<E> removeSelf() {\n            if (getRightSubTree() == null && getLeftSubTree() == null) {\n                return null;\n            }\n            if (getRightSubTree() == null) {\n                if (relativePosition > 0) {\n                    left.relativePosition += relativePosition;\n                }\n                left.max().setRight(null, right);\n                return left;\n            }\n            if (getLeftSubTree() == null) {\n                right.relativePosition += relativePosition - (relativePosition < 0 ? 0 : 1);\n                right.min().setLeft(null, left);\n                return right;\n            }\n\n            if (heightRightMinusLeft() > 0) {\n                // more on the right, so delete from the right\n                final AVLNode<E> rightMin = right.min();\n                value = rightMin.value;\n                if (leftIsPrevious) {\n                    left = rightMin.left;\n                }\n                right = right.removeMin();\n                if (relativePosition < 0) {\n                    relativePosition++;\n                }\n            } else {\n                // more on the left or equal, so delete from the left\n                final AVLNode<E> leftMax = left.max();\n                value = leftMax.value;\n                if (rightIsNext) {\n                    right = leftMax.right;\n                }\n                final AVLNode<E> leftPrevious = left.left;\n                left = left.removeMax();\n                if (left == null) {\n                    // special case where left that was deleted was a double link\n                    // only occurs when height difference is equal\n                    left = leftPrevious;\n                    leftIsPrevious = true;\n                }\n                if (relativePosition > 0) {\n                    relativePosition--;\n                }\n            }\n            recalcHeight();\n            return this;\n        }\n\n        private AVLNode<E> rotateLeft() {\n            final AVLNode<E> newTop = right; // can't be faedelung!\n            final AVLNode<E> movedNode = getRightSubTree().getLeftSubTree();\n\n            final int newTopPosition = relativePosition + getOffset(newTop);\n            final int myNewPosition = -newTop.relativePosition;\n            final int movedPosition = getOffset(newTop) + getOffset(movedNode);\n\n            setRight(movedNode, newTop);\n            newTop.setLeft(this, null);\n\n            setOffset(newTop, newTopPosition);\n            setOffset(this, myNewPosition);\n            setOffset(movedNode, movedPosition);\n            return newTop;\n        }\n\n        private AVLNode<E> rotateRight() {\n            final AVLNode<E> newTop = left; // can't be faedelung\n            final AVLNode<E> movedNode = getLeftSubTree().getRightSubTree();\n\n            final int newTopPosition = relativePosition + getOffset(newTop);\n            final int myNewPosition = -newTop.relativePosition;\n            final int movedPosition = getOffset(newTop) + getOffset(movedNode);\n\n            setLeft(movedNode, newTop);\n            newTop.setRight(this, null);\n\n            setOffset(newTop, newTopPosition);\n            setOffset(this, myNewPosition);\n            setOffset(movedNode, movedPosition);\n            return newTop;\n        }\n\n        /**\n         * Sets the left field to the node, or the previous node if that is null\n         *\n         * @param node  the new left subtree node\n         * @param previous  the previous node in the linked list\n         */\n        private void setLeft(final AVLNode<E> node, final AVLNode<E> previous) {\n            leftIsPrevious = node == null;\n            left = leftIsPrevious ? previous : node;\n            recalcHeight();\n        }\n\n        /**\n         * Sets the relative position.\n         */\n        private int setOffset(final AVLNode<E> node, final int newOffset) {\n            if (node == null) {\n                return 0;\n            }\n            final int oldOffset = getOffset(node);\n            node.relativePosition = newOffset;\n            return oldOffset;\n        }\n\n        /**\n         * Sets the right field to the node, or the next node if that is null\n         *\n         * @param node  the new left subtree node\n         * @param next  the next node in the linked list\n         */\n        private void setRight(final AVLNode<E> node, final AVLNode<E> next) {\n            rightIsNext = node == null;\n            right = rightIsNext ? next : node;\n            recalcHeight();\n        }\n\n        /**\n         * Sets the value.\n         *\n         * @param obj  the value to store\n         */\n        void setValue(final E obj) {\n            this.value = obj;\n        }\n\n        /**\n         * Stores the node and its children into the array specified.\n         *\n         * @param array the array to be filled\n         * @param index the index of this node\n         */\n        void toArray(final Object[] array, final int index) {\n            array[index] = value;\n            if (getLeftSubTree() != null) {\n                left.toArray(array, index + left.relativePosition);\n            }\n            if (getRightSubTree() != null) {\n                right.toArray(array, index + right.relativePosition);\n            }\n        }\n\n//      private void checkFaedelung() {\n//          AVLNode maxNode = left.max();\n//          if (!maxNode.rightIsFaedelung || maxNode.right != this) {\n//              throw new RuntimeException(maxNode + \" should right-faedel to \" + this);\n//          }\n//          AVLNode minNode = right.min();\n//          if (!minNode.leftIsFaedelung || minNode.left != this) {\n//              throw new RuntimeException(maxNode + \" should left-faedel to \" + this);\n//          }\n//      }\n//\n//        private int checkTreeDepth() {\n//            int hright = (getRightSubTree() == null ? -1 : getRightSubTree().checkTreeDepth());\n//            //          System.out.print(\"checkTreeDepth\");\n//            //          System.out.print(this);\n//            //          System.out.print(\" left: \");\n//            //          System.out.print(_left);\n//            //          System.out.print(\" right: \");\n//            //          System.out.println(_right);\n//\n//            int hleft = (left == null ? -1 : left.checkTreeDepth());\n//            if (height != Math.max(hright, hleft) + 1) {\n//                throw new RuntimeException(\n//                    \"height should be max\" + hleft + \",\" + hright + \" but is \" + height);\n//            }\n//            return height;\n//        }\n//\n//        private int checkLeftSubNode() {\n//            if (getLeftSubTree() == null) {\n//                return 0;\n//            }\n//            int count = 1 + left.checkRightSubNode();\n//            if (left.relativePosition != -count) {\n//                throw new RuntimeException();\n//            }\n//            return count + left.checkLeftSubNode();\n//        }\n//\n//        private int checkRightSubNode() {\n//            AVLNode right = getRightSubTree();\n//            if (right == null) {\n//                return 0;\n//            }\n//            int count = 1;\n//            count += right.checkLeftSubNode();\n//            if (right.relativePosition != count) {\n//                throw new RuntimeException();\n//            }\n//            return count + right.checkRightSubNode();\n//        }\n\n        /**\n         * Used for debugging.\n         */\n        @Override\n        public String toString() {\n            return new StringBuilder()\n                .append(\"AVLNode(\")\n                .append(relativePosition)\n                .append(CollectionUtils.COMMA)\n                .append(left != null)\n                .append(CollectionUtils.COMMA)\n                .append(value)\n                .append(CollectionUtils.COMMA)\n                .append(getRightSubTree() != null)\n                .append(rightIsNext)\n                .append(\")\")\n                .toString();\n        }\n    }\n\n    /**\n     * A list iterator over the linked list.\n     */\n    static class TreeListIterator<E> implements ListIterator<E>, OrderedIterator<E> {\n        /** The parent list */\n        private final TreeList<E> parent;\n        /**\n         * Cache of the next node that will be returned by {@link #next()}.\n         */\n        private AVLNode<E> next;\n        /**\n         * The index of the next node to be returned.\n         */\n        private int nextIndex;\n        /**\n         * Cache of the last node that was returned by {@link #next()}\n         * or {@link #previous()}.\n         */\n        private AVLNode<E> current;\n        /**\n         * The index of the last node that was returned.\n         */\n        private int currentIndex;\n        /**\n         * The modification count that the list is expected to have. If the list\n         * doesn't have this count, then a\n         * {@link java.util.ConcurrentModificationException} may be thrown by\n         * the operations.\n         */\n        private int expectedModCount;\n\n        /**\n         * Create a ListIterator for a list.\n         *\n         * @param parent  the parent list\n         * @param fromIndex  the index to start at\n         */\n        protected TreeListIterator(final TreeList<E> parent, final int fromIndex) {\n            this.parent = parent;\n            this.expectedModCount = parent.modCount;\n            this.next = parent.root == null ? null : parent.root.get(fromIndex);\n            this.nextIndex = fromIndex;\n            this.currentIndex = -1;\n        }\n\n        @Override\n        public void add(final E obj) {\n            checkModCount();\n            parent.add(nextIndex, obj);\n            current = null;\n            currentIndex = -1;\n            nextIndex++;\n            expectedModCount++;\n        }\n\n        /**\n         * Checks the modification count of the list is the value that this\n         * object expects.\n         *\n         * @throws ConcurrentModificationException If the list's modification\n         * count isn't the value that was expected.\n         */\n        protected void checkModCount() {\n            if (parent.modCount != expectedModCount) {\n                throw new ConcurrentModificationException();\n            }\n        }\n\n        @Override\n        public boolean hasNext() {\n            return nextIndex < parent.size();\n        }\n\n        @Override\n        public boolean hasPrevious() {\n            return nextIndex > 0;\n        }\n\n        @Override\n        public E next() {\n            checkModCount();\n            if (!hasNext()) {\n                throw new NoSuchElementException(\"No element at index \" + nextIndex + \".\");\n            }\n            if (next == null) {\n                next = parent.root.get(nextIndex);\n            }\n            final E value = next.getValue();\n            current = next;\n            currentIndex = nextIndex++;\n            next = next.next();\n            return value;\n        }\n\n        @Override\n        public int nextIndex() {\n            return nextIndex;\n        }\n\n        @Override\n        public E previous() {\n            checkModCount();\n            if (!hasPrevious()) {\n                throw new NoSuchElementException(\"Already at start of list.\");\n            }\n            if (next == null) {\n                next = parent.root.get(nextIndex - 1);\n            } else {\n                next = next.previous();\n            }\n            final E value = next.getValue();\n            current = next;\n            currentIndex = --nextIndex;\n            return value;\n        }\n\n        @Override\n        public int previousIndex() {\n            return nextIndex() - 1;\n        }\n\n        @Override\n        public void remove() {\n            checkModCount();\n            if (currentIndex == -1) {\n                throw new IllegalStateException();\n            }\n            parent.remove(currentIndex);\n            if (nextIndex != currentIndex) {\n                // remove() following next()\n                nextIndex--;\n            }\n            // the AVL node referenced by next may have become stale after a remove\n            // reset it now: will be retrieved by next call to next()/previous() via nextIndex\n            next = null;\n            current = null;\n            currentIndex = -1;\n            expectedModCount++;\n        }\n\n        @Override\n        public void set(final E obj) {\n            checkModCount();\n            if (current == null) {\n                throw new IllegalStateException();\n            }\n            current.setValue(obj);\n        }\n    }\n\n    /** The root node in the AVL tree */\n    private AVLNode<E> root;\n\n    /** The current size of the list */\n    private int size;\n\n    /**\n     * Constructs a new empty list.\n     */\n    public TreeList() {\n    }\n\n    /**\n     * Constructs a new empty list that copies the specified collection.\n     *\n     * @param coll  the collection to copy\n     * @throws NullPointerException if the collection is null\n     */\n    public TreeList(final Collection<? extends E> coll) {\n        if (!coll.isEmpty()) {\n            root = new AVLNode<>(coll);\n            size = coll.size();\n        }\n    }\n\n    /**\n     * Adds a new element to the list.\n     *\n     * @param index  the index to add before\n     * @param obj  the element to add\n     */\n    @Override\n    public void add(final int index, final E obj) {\n        modCount++;\n        checkInterval(index, 0, size());\n        if (root == null) {\n            root = new AVLNode<>(index, obj, null, null);\n        } else {\n            root = root.insert(index, obj);\n        }\n        size++;\n    }\n\n    /**\n     * Appends all the elements in the specified collection to the end of this list,\n     * in the order that they are returned by the specified collection's Iterator.\n     * <p>\n     * This method runs in O(n + log m) time, where m is\n     * the size of this list and n is the size of {@code c}.\n     *\n     * @param c  the collection to be added to this list\n     * @return {@code true} if this list changed as a result of the call\n     * @throws NullPointerException {@inheritDoc}\n     */\n    @Override\n    public boolean addAll(final Collection<? extends E> c) {\n        if (c.isEmpty()) {\n            return false;\n        }\n        modCount += c.size();\n        final AVLNode<E> cTree = new AVLNode<>(c);\n        root = root == null ? cTree : root.addAll(cTree, size);\n        size += c.size();\n        return true;\n    }\n\n    /**\n     * Checks whether the index is valid.\n     *\n     * @param index  the index to check\n     * @param startIndex  the first allowed index\n     * @param endIndex  the last allowed index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    private void checkInterval(final int index, final int startIndex, final int endIndex) {\n        if (index < startIndex || index > endIndex) {\n            throw new IndexOutOfBoundsException(\"Invalid index:\" + index + \", size=\" + size());\n        }\n    }\n\n    /**\n     * Clears the list, removing all entries.\n     */\n    @Override\n    public void clear() {\n        modCount++;\n        root = null;\n        size = 0;\n    }\n\n    /**\n     * Searches for the presence of an object in the list.\n     *\n     * @param object  the object to check\n     * @return true if the object is found\n     */\n    @Override\n    public boolean contains(final Object object) {\n        return indexOf(object) >= 0;\n    }\n\n    /**\n     * Gets the element at the specified index.\n     *\n     * @param index  the index to retrieve\n     * @return the element at the specified index\n     */\n    @Override\n    public E get(final int index) {\n        checkInterval(index, 0, size() - 1);\n        return root.get(index).getValue();\n    }\n\n    /**\n     * Searches for the index of an object in the list.\n     *\n     * @param object  the object to search\n     * @return the index of the object, -1 if not found\n     */\n    @Override\n    public int indexOf(final Object object) {\n        // override to go 75% faster\n        if (root == null) {\n            return -1;\n        }\n        return root.indexOf(object, root.relativePosition);\n    }\n\n    /**\n     * Gets an iterator over the list.\n     *\n     * @return an iterator over the list\n     */\n    @Override\n    public Iterator<E> iterator() {\n        // override to go 75% faster\n        return listIterator(0);\n    }\n\n    /**\n     * Gets a ListIterator over the list.\n     *\n     * @return the new iterator\n     */\n    @Override\n    public ListIterator<E> listIterator() {\n        // override to go 75% faster\n        return listIterator(0);\n    }\n\n    /**\n     * Gets a ListIterator over the list.\n     *\n     * @param fromIndex  the index to start from\n     * @return the new iterator\n     */\n    @Override\n    public ListIterator<E> listIterator(final int fromIndex) {\n        // override to go 75% faster\n        // cannot use EmptyIterator as iterator.add() must work\n        checkInterval(fromIndex, 0, size());\n        return new TreeListIterator<>(this, fromIndex);\n    }\n\n    /**\n     * Removes the element at the specified index.\n     *\n     * @param index  the index to remove\n     * @return the previous object at that index\n     */\n    @Override\n    public E remove(final int index) {\n        modCount++;\n        checkInterval(index, 0, size() - 1);\n        final E result = get(index);\n        root = root.remove(index);\n        size--;\n        return result;\n    }\n\n    /**\n     * Sets the element at the specified index.\n     *\n     * @param index  the index to set\n     * @param obj  the object to store at the specified index\n     * @return the previous object at that index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    @Override\n    public E set(final int index, final E obj) {\n        checkInterval(index, 0, size() - 1);\n        final AVLNode<E> node = root.get(index);\n        final E result = node.value;\n        node.setValue(obj);\n        return result;\n    }\n\n    /**\n     * Gets the current size of the list.\n     *\n     * @return the current size\n     */\n    @Override\n    public int size() {\n        return size;\n    }\n\n    /**\n     * Converts the list into an array.\n     *\n     * @return the list as an array\n     */\n    @Override\n    public Object[] toArray() {\n        // override to go 20% faster\n        final Object[] array = new Object[size()];\n        if (root != null) {\n            root.toArray(array, root.relativePosition);\n        }\n        return array;\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private AVLNode<E> root;", "docstring": " The root node in the AVL tree", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "AVLNode<E>", "name": "root", "syntax_pass": true}, {"attribute_expression": "private int size;", "docstring": " The current size of the list", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "size", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/list/NodeCachingLinkedList.java.NodeCachingLinkedList", "name": "NodeCachingLinkedList", "file_path": "src/main/java/org/apache/commons/collections4/list/NodeCachingLinkedList.java", "superclasses": "", "methods": ["[]NodeCachingLinkedList()", "[]NodeCachingLinkedList(Collection<? extends E>)", "[]NodeCachingLinkedList(int)", "[void]addNodeToCache(Node<E>)", "[Node<E>]createNode(E)", "[int]getMaximumCacheSize()", "[Node<E>]getNodeFromCache()", "[boolean]isCacheFull()", "[void]readObject(ObjectInputStream)", "[void]removeAllNodes()", "[void]removeNode(Node<E>)", "[void]setMaximumCacheSize(int)", "[void]shrinkCacheToMaximumSize()", "[void]writeObject(ObjectOutputStream)"], "method_uris": ["src/main/java/org/apache/commons/collections4/list/NodeCachingLinkedList.java.NodeCachingLinkedList.[]NodeCachingLinkedList()", "src/main/java/org/apache/commons/collections4/list/NodeCachingLinkedList.java.NodeCachingLinkedList.[]NodeCachingLinkedList(Collection<? extends E>)", "src/main/java/org/apache/commons/collections4/list/NodeCachingLinkedList.java.NodeCachingLinkedList.[]NodeCachingLinkedList(int)", "src/main/java/org/apache/commons/collections4/list/NodeCachingLinkedList.java.NodeCachingLinkedList.[void]addNodeToCache(Node<E>)", "src/main/java/org/apache/commons/collections4/list/NodeCachingLinkedList.java.NodeCachingLinkedList.[Node<E>]createNode(E)", "src/main/java/org/apache/commons/collections4/list/NodeCachingLinkedList.java.NodeCachingLinkedList.[int]getMaximumCacheSize()", "src/main/java/org/apache/commons/collections4/list/NodeCachingLinkedList.java.NodeCachingLinkedList.[Node<E>]getNodeFromCache()", "src/main/java/org/apache/commons/collections4/list/NodeCachingLinkedList.java.NodeCachingLinkedList.[boolean]isCacheFull()", "src/main/java/org/apache/commons/collections4/list/NodeCachingLinkedList.java.NodeCachingLinkedList.[void]readObject(ObjectInputStream)", "src/main/java/org/apache/commons/collections4/list/NodeCachingLinkedList.java.NodeCachingLinkedList.[void]removeAllNodes()", "src/main/java/org/apache/commons/collections4/list/NodeCachingLinkedList.java.NodeCachingLinkedList.[void]removeNode(Node<E>)", "src/main/java/org/apache/commons/collections4/list/NodeCachingLinkedList.java.NodeCachingLinkedList.[void]setMaximumCacheSize(int)", "src/main/java/org/apache/commons/collections4/list/NodeCachingLinkedList.java.NodeCachingLinkedList.[void]shrinkCacheToMaximumSize()", "src/main/java/org/apache/commons/collections4/list/NodeCachingLinkedList.java.NodeCachingLinkedList.[void]writeObject(ObjectOutputStream)"], "overrides": null, "attributes": [], "class_docstring": "\nA {@code List} implementation that stores a cache of internal Node objects\nin an effort to reduce wasteful object creation.\n<p>\nA linked list creates one Node for each item of data added. This can result in\na lot of object creation and garbage collection. This implementation seeks to\navoid that by maintaining a store of cached nodes.\n</p>\n<p>\nThis implementation is suitable for long-lived lists where both add and remove\nare used. Short-lived lists, or lists which only grow will have worse performance\nusing this class.\n</p>\n<p>\n<b>Note that this implementation is not synchronized.</b>\n</p>\n\n@param <E> the type of the elements in the list.\n@since 3.0\n@deprecated parent {@link AbstractLinkedList} is source incompatible with List methods added in Java 21\n", "original_string": "@Deprecated\npublic class NodeCachingLinkedList<E> extends AbstractLinkedList<E> implements Serializable {\n\n    /** Serialization version */\n    private static final long serialVersionUID = 6897789178562232073L;\n\n    /**\n     * The default value for {@link #maximumCacheSize}.\n     */\n    private static final int DEFAULT_MAXIMUM_CACHE_SIZE = 20;\n\n    /**\n     * The first cached node, or {@code null} if no nodes are cached.\n     * Cached nodes are stored in a singly-linked list with\n     * {@code next} pointing to the next element.\n     */\n    private transient Node<E> firstCachedNode;\n\n    /**\n     * The size of the cache.\n     */\n    private transient int cacheSize;\n\n    /**\n     * The maximum size of the cache.\n     */\n    private int maximumCacheSize;\n\n    /**\n     * Constructor that creates.\n     */\n    public NodeCachingLinkedList() {\n        this(DEFAULT_MAXIMUM_CACHE_SIZE);\n    }\n\n    /**\n     * Constructor that copies the specified collection\n     *\n     * @param coll  the collection to copy\n     */\n    public NodeCachingLinkedList(final Collection<? extends E> coll) {\n        super(coll);\n        this.maximumCacheSize = DEFAULT_MAXIMUM_CACHE_SIZE;\n    }\n\n    /**\n     * Constructor that species the maximum cache size.\n     *\n     * @param maximumCacheSize  the maximum cache size\n     */\n    public NodeCachingLinkedList(final int maximumCacheSize) {\n        this.maximumCacheSize = maximumCacheSize;\n        init();  // must call init() as use super();\n    }\n\n    /**\n     * Adds a node to the cache, if the cache isn't full.\n     * The node's contents are cleared, so they can be garbage collected.\n     *\n     * @param node  the node to add to the cache\n     */\n    protected void addNodeToCache(final Node<E> node) {\n        if (isCacheFull()) {\n            // don't cache the node.\n            return;\n        }\n        // clear the node's contents and add it to the cache.\n        final Node<E> nextCachedNode = firstCachedNode;\n        node.previous = null;\n        node.next = nextCachedNode;\n        node.setValue(null);\n        firstCachedNode = node;\n        cacheSize++;\n    }\n\n    /**\n     * Creates a new node, either by reusing one from the cache or creating\n     * a new one.\n     *\n     * @param value  value of the new node\n     * @return the newly created node\n     */\n    @Override\n    protected Node<E> createNode(final E value) {\n        final Node<E> cachedNode = getNodeFromCache();\n        if (cachedNode == null) {\n            return super.createNode(value);\n        }\n        cachedNode.setValue(value);\n        return cachedNode;\n    }\n\n    /**\n     * Gets the maximum size of the cache.\n     *\n     * @return the maximum cache size\n     */\n    protected int getMaximumCacheSize() {\n        return maximumCacheSize;\n    }\n\n    /**\n     * Gets a node from the cache. If a node is returned, then the value of\n     * {@link #cacheSize} is decreased accordingly. The node that is returned\n     * will have {@code null} values for next, previous and element.\n     *\n     * @return a node, or {@code null} if there are no nodes in the cache.\n     */\n    protected Node<E> getNodeFromCache() {\n        if (cacheSize == 0) {\n            return null;\n        }\n        final Node<E> cachedNode = firstCachedNode;\n        firstCachedNode = cachedNode.next;\n        cachedNode.next = null; // This should be changed anyway, but defensively\n                                // set it to null.\n        cacheSize--;\n        return cachedNode;\n    }\n\n    /**\n     * Checks whether the cache is full.\n     *\n     * @return true if the cache is full\n     */\n    protected boolean isCacheFull() {\n        return cacheSize >= maximumCacheSize;\n    }\n\n    /**\n     * Deserializes the data held in this object to the stream specified.\n     *\n     * @param in  the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded\n     */\n    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        doReadObject(in);\n    }\n\n    /**\n     * Removes all the nodes from the list, storing as many as required in the\n     * cache for reuse.\n     */\n    @Override\n    protected void removeAllNodes() {\n        // Add the removed nodes to the cache, then remove the rest.\n        // We can add them to the cache before removing them, since\n        // {@link AbstractLinkedList.removeAllNodes()} removes the\n        // nodes by removing references directly from {@link #header}.\n        final int numberOfNodesToCache = Math.min(size, maximumCacheSize - cacheSize);\n        Node<E> node = header.next;\n        for (int currentIndex = 0; currentIndex < numberOfNodesToCache; currentIndex++) {\n            final Node<E> oldNode = node;\n            node = node.next;\n            addNodeToCache(oldNode);\n        }\n        super.removeAllNodes();\n    }\n\n    /**\n     * Removes the node from the list, storing it in the cache for reuse\n     * if the cache is not yet full.\n     *\n     * @param node  the node to remove\n     */\n    @Override\n    protected void removeNode(final Node<E> node) {\n        super.removeNode(node);\n        addNodeToCache(node);\n    }\n\n    /**\n     * Sets the maximum size of the cache.\n     *\n     * @param maximumCacheSize  the new maximum cache size\n     */\n    protected void setMaximumCacheSize(final int maximumCacheSize) {\n        this.maximumCacheSize = maximumCacheSize;\n        shrinkCacheToMaximumSize();\n    }\n\n    /**\n     * Reduce the size of the cache to the maximum, if necessary.\n     */\n    protected void shrinkCacheToMaximumSize() {\n        // Rich Dougherty: This could be more efficient.\n        while (cacheSize > maximumCacheSize) {\n            getNodeFromCache();\n        }\n    }\n\n    /**\n     * Serializes this object to an ObjectOutputStream.\n     *\n     * @param out the target ObjectOutputStream.\n     * @throws IOException thrown when an I/O errors occur writing to the target stream.\n     */\n    private void writeObject(final ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        doWriteObject(out);\n    }\n\n}", "super_interfaces": ["Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 6897789178562232073L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 6897789178562232073L", "syntax_pass": true}, {"attribute_expression": "private static final int DEFAULT_MAXIMUM_CACHE_SIZE = 20;", "docstring": "\nThe default value for {@link #maximumCacheSize}.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "int", "name": "DEFAULT_MAXIMUM_CACHE_SIZE = 20", "syntax_pass": true}, {"attribute_expression": "private transient Node<E> firstCachedNode;", "docstring": "\nThe first cached node, or {@code null} if no nodes are cached.\nCached nodes are stored in a singly-linked list with\n{@code next} pointing to the next element.\n", "modifiers": "private transient", "marker_annotations": [], "non_marker_annotations": ["private", "transient"], "comments": [], "type": "Node<E>", "name": "firstCachedNode", "syntax_pass": true}, {"attribute_expression": "private transient int cacheSize;", "docstring": "\nThe size of the cache.\n", "modifiers": "private transient", "marker_annotations": [], "non_marker_annotations": ["private", "transient"], "comments": [], "type": "int", "name": "cacheSize", "syntax_pass": true}, {"attribute_expression": "private int maximumCacheSize;", "docstring": "\nThe maximum size of the cache.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "maximumCacheSize", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/list/PredicatedList.java.PredicatedList", "name": "PredicatedList", "file_path": "src/main/java/org/apache/commons/collections4/list/PredicatedList.java", "superclasses": "", "methods": ["[PredicatedList<T>]predicatedList(List<T>,Predicate<? super T>)", "[]PredicatedList(List<E>,Predicate<? super E>)", "[void]add(int,E)", "[boolean]addAll(int,Collection<? extends E>)", "[List<E>]decorated()", "[boolean]equals(Object)", "[E]get(int)", "[int]hashCode()", "[int]indexOf(Object)", "[int]lastIndexOf(Object)", "[ListIterator<E>]listIterator()", "[ListIterator<E>]listIterator(int)", "[E]remove(int)", "[E]set(int,E)", "[List<E>]subList(int,int)"], "method_uris": ["src/main/java/org/apache/commons/collections4/list/PredicatedList.java.PredicatedList.[PredicatedList<T>]predicatedList(List<T>,Predicate<? super T>)", "src/main/java/org/apache/commons/collections4/list/PredicatedList.java.PredicatedList.[]PredicatedList(List<E>,Predicate<? super E>)", "src/main/java/org/apache/commons/collections4/list/PredicatedList.java.PredicatedList.[void]add(int,E)", "src/main/java/org/apache/commons/collections4/list/PredicatedList.java.PredicatedList.[boolean]addAll(int,Collection<? extends E>)", "src/main/java/org/apache/commons/collections4/list/PredicatedList.java.PredicatedList.[List<E>]decorated()", "src/main/java/org/apache/commons/collections4/list/PredicatedList.java.PredicatedList.[boolean]equals(Object)", "src/main/java/org/apache/commons/collections4/list/PredicatedList.java.PredicatedList.[E]get(int)", "src/main/java/org/apache/commons/collections4/list/PredicatedList.java.PredicatedList.[int]hashCode()", "src/main/java/org/apache/commons/collections4/list/PredicatedList.java.PredicatedList.[int]indexOf(Object)", "src/main/java/org/apache/commons/collections4/list/PredicatedList.java.PredicatedList.[int]lastIndexOf(Object)", "src/main/java/org/apache/commons/collections4/list/PredicatedList.java.PredicatedList.[ListIterator<E>]listIterator()", "src/main/java/org/apache/commons/collections4/list/PredicatedList.java.PredicatedList.[ListIterator<E>]listIterator(int)", "src/main/java/org/apache/commons/collections4/list/PredicatedList.java.PredicatedList.[E]remove(int)", "src/main/java/org/apache/commons/collections4/list/PredicatedList.java.PredicatedList.[E]set(int,E)", "src/main/java/org/apache/commons/collections4/list/PredicatedList.java.PredicatedList.[List<E>]subList(int,int)"], "overrides": null, "attributes": [{"original_string": "    protected class PredicatedListIterator extends AbstractListIteratorDecorator<E> {\n\n        /**\n         * Create a new predicated list iterator.\n         *\n         * @param iterator  the list iterator to decorate\n         */\n        protected PredicatedListIterator(final ListIterator<E> iterator) {\n            super(iterator);\n        }\n\n        @Override\n        public void add(final E object) {\n            validate(object);\n            getListIterator().add(object);\n        }\n\n        @Override\n        public void set(final E object) {\n            validate(object);\n            getListIterator().set(object);\n        }\n    }", "definition": "    protected class PredicatedListIterator extends AbstractListIteratorDecorator<E>", "class_docstring": "\nInner class Iterator for the PredicatedList\n", "name": "PredicatedListIterator", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        protected PredicatedListIterator(final ListIterator<E> iterator) {\n            super(iterator);\n        }", "docstring": "\nCreate a new predicated list iterator.\n\n@param iterator  the list iterator to decorate\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "name": "PredicatedListIterator", "params": [{"name": "iterator", "type": "ListIterator<E>"}], "body": "                                                                         {\n            super(iterator);\n        }", "signature": "protected PredicatedListIterator(final ListIterator<E> iterator)"}, {"syntax_pass": true, "original_string": "        @Override\n        public void add(final E object) {\n            validate(object);\n            getListIterator().add(object);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "add", "params": [{"name": "object", "type": "E"}], "body": "                                        {\n            validate(object);\n            getListIterator().add(object);\n        }", "signature": "@Override\n        public void add(final E object)"}, {"syntax_pass": true, "original_string": "        @Override\n        public void set(final E object) {\n            validate(object);\n            getListIterator().set(object);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "set", "params": [{"name": "object", "type": "E"}], "body": "                                        {\n            validate(object);\n            getListIterator().set(object);\n        }", "signature": "@Override\n        public void set(final E object)"}]}], "class_docstring": "\nDecorates another {@code List} to validate that all additions\nmatch a specified predicate.\n<p>\nThis list exists to provide validation for the decorated list.\nIt is normally created to decorate an empty list.\nIf an object cannot be added to the list, an IllegalArgumentException is thrown.\n</p>\n<p>\nOne usage would be to ensure that no null entries are added to the list.\n</p>\n<pre>\n{@code\nList<String> list =\n  PredicatedList.predicatedList(new ArrayList<String>(), PredicateUtils.notNullPredicate());\n}\n</pre>\n<p>\nThis class is Serializable from Commons Collections 3.1.\n</p>\n\n@param <E> the type of the elements in the list.\n@since 3.0\n", "original_string": "public class PredicatedList<E> extends PredicatedCollection<E> implements List<E> {\n\n    /**\n     * Inner class Iterator for the PredicatedList\n     */\n    protected class PredicatedListIterator extends AbstractListIteratorDecorator<E> {\n\n        /**\n         * Create a new predicated list iterator.\n         *\n         * @param iterator  the list iterator to decorate\n         */\n        protected PredicatedListIterator(final ListIterator<E> iterator) {\n            super(iterator);\n        }\n\n        @Override\n        public void add(final E object) {\n            validate(object);\n            getListIterator().add(object);\n        }\n\n        @Override\n        public void set(final E object) {\n            validate(object);\n            getListIterator().set(object);\n        }\n    }\n\n    /** Serialization version */\n    private static final long serialVersionUID = -5722039223898659102L;\n\n    /**\n     * Factory method to create a predicated (validating) list.\n     * <p>\n     * If there are any elements already in the list being decorated, they\n     * are validated.\n     *\n     * @param <T> the type of the elements in the list\n     * @param list  the list to decorate, must not be null\n     * @param predicate  the predicate to use for validation, must not be null\n     * @return a new predicated list\n     * @throws NullPointerException if list or predicate is null\n     * @throws IllegalArgumentException if the list contains invalid elements\n     * @since 4.0\n     */\n    public static <T> PredicatedList<T> predicatedList(final List<T> list, final Predicate<? super T> predicate) {\n        return new PredicatedList<>(list, predicate);\n    }\n\n    /**\n     * Constructor that wraps (not copies).\n     * <p>\n     * If there are any elements already in the list being decorated, they\n     * are validated.\n     *\n     * @param list  the list to decorate, must not be null\n     * @param predicate  the predicate to use for validation, must not be null\n     * @throws NullPointerException if list or predicate is null\n     * @throws IllegalArgumentException if the list contains invalid elements\n     */\n    protected PredicatedList(final List<E> list, final Predicate<? super E> predicate) {\n        super(list, predicate);\n    }\n\n    @Override\n    public void add(final int index, final E object) {\n        validate(object);\n        decorated().add(index, object);\n    }\n\n    @Override\n    public boolean addAll(final int index, final Collection<? extends E> coll) {\n        for (final E aColl : coll) {\n            validate(aColl);\n        }\n        return decorated().addAll(index, coll);\n    }\n\n    /**\n     * Gets the list being decorated.\n     *\n     * @return the decorated list\n     */\n    @Override\n    protected List<E> decorated() {\n        return (List<E>) super.decorated();\n    }\n\n    @Override\n    public boolean equals(final Object object) {\n        return object == this || decorated().equals(object);\n    }\n\n    @Override\n    public E get(final int index) {\n        return decorated().get(index);\n    }\n\n    @Override\n    public int hashCode() {\n        return decorated().hashCode();\n    }\n\n    @Override\n    public int indexOf(final Object object) {\n        return decorated().indexOf(object);\n    }\n\n    @Override\n    public int lastIndexOf(final Object object) {\n        return decorated().lastIndexOf(object);\n    }\n\n    @Override\n    public ListIterator<E> listIterator() {\n        return listIterator(0);\n    }\n\n    @Override\n    public ListIterator<E> listIterator(final int i) {\n        return new PredicatedListIterator(decorated().listIterator(i));\n    }\n\n    @Override\n    public E remove(final int index) {\n        return decorated().remove(index);\n    }\n\n    @Override\n    public E set(final int index, final E object) {\n        validate(object);\n        return decorated().set(index, object);\n    }\n\n    @Override\n    public List<E> subList(final int fromIndex, final int toIndex) {\n        final List<E> sub = decorated().subList(fromIndex, toIndex);\n        return new PredicatedList<>(sub, predicate);\n    }\n\n}", "super_interfaces": ["List<E>"], "fields": [{"attribute_expression": "private static final long serialVersionUID = -5722039223898659102L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -5722039223898659102L", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/list/GrowthList.java.GrowthList", "name": "GrowthList", "file_path": "src/main/java/org/apache/commons/collections4/list/GrowthList.java", "superclasses": "", "methods": ["[GrowthList<E>]growthList(List<E>)", "[]GrowthList()", "[]GrowthList(int)", "[]GrowthList(List<E>)", "[void]add(int,E)", "[boolean]addAll(int,Collection<? extends E>)", "[E]set(int,E)"], "method_uris": ["src/main/java/org/apache/commons/collections4/list/GrowthList.java.GrowthList.[GrowthList<E>]growthList(List<E>)", "src/main/java/org/apache/commons/collections4/list/GrowthList.java.GrowthList.[]GrowthList()", "src/main/java/org/apache/commons/collections4/list/GrowthList.java.GrowthList.[]GrowthList(int)", "src/main/java/org/apache/commons/collections4/list/GrowthList.java.GrowthList.[]GrowthList(List<E>)", "src/main/java/org/apache/commons/collections4/list/GrowthList.java.GrowthList.[void]add(int,E)", "src/main/java/org/apache/commons/collections4/list/GrowthList.java.GrowthList.[boolean]addAll(int,Collection<? extends E>)", "src/main/java/org/apache/commons/collections4/list/GrowthList.java.GrowthList.[E]set(int,E)"], "overrides": null, "attributes": [], "class_docstring": "\nDecorates another {@code List} to make it seamlessly grow when\nindices larger than the list size are used on add and set,\navoiding most IndexOutOfBoundsExceptions.\n<p>\nThis class avoids errors by growing when a set or add method would\nnormally throw an IndexOutOfBoundsException.\nNote that IndexOutOfBoundsException IS returned for invalid negative indices.\n</p>\n<p>\nTrying to set or add to an index larger than the size will cause the list\nto grow (using {@code null} elements). Clearly, care must be taken\nnot to use excessively large indices, as the internal list will grow to\nmatch.\n</p>\n<p>\nTrying to use any method other than add or set with an invalid index will\ncall the underlying list and probably result in an IndexOutOfBoundsException.\n</p>\n<p>\nTake care when using this list with {@code null} values, as\n{@code null} is the value added when growing the list.\n</p>\n<p>\nAll sub-lists will access the underlying list directly, and will throw\nIndexOutOfBoundsExceptions.\n</p>\n<p>\nThis class differs from {@link LazyList} because here growth occurs on\nset and add, where {@code LazyList} grows on get. However, they\ncan be used together by decorating twice.\n</p>\n\n@param <E> the type of the elements in the list.\n@see LazyList\n@since 3.2\n", "original_string": "public class GrowthList<E> extends AbstractSerializableListDecorator<E> {\n\n    /** Serialization version */\n    private static final long serialVersionUID = -3620001881672L;\n\n    /**\n     * Factory method to create a growth list.\n     *\n     * @param <E> the type of the elements in the list\n     * @param list  the list to decorate, must not be null\n     * @return a new growth list\n     * @throws NullPointerException if list is null\n     * @since 4.0\n     */\n    public static <E> GrowthList<E> growthList(final List<E> list) {\n        return new GrowthList<>(list);\n    }\n\n    /**\n     * Constructor that uses an ArrayList internally.\n     */\n    public GrowthList() {\n        super(new ArrayList<>());\n    }\n\n    /**\n     * Constructor that uses an ArrayList internally.\n     *\n     * @param initialCapacity  the initial capacity of the ArrayList\n     * @throws IllegalArgumentException if initial capacity is invalid\n     */\n    public GrowthList(final int initialCapacity) {\n        super(new ArrayList<>(initialCapacity));\n    }\n\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param list  the list to decorate, must not be null\n     * @throws NullPointerException if list is null\n     */\n    protected GrowthList(final List<E> list) {\n        super(list);\n    }\n\n    /**\n     * Decorate the add method to perform the growth behavior.\n     * <p>\n     * If the requested index is greater than the current size, the list will\n     * grow to the new size. Indices between the old size and the requested\n     * size will be filled with {@code null}.\n     * <p>\n     * If the index is less than the current size, the value will be added to\n     * the underlying list directly.\n     * If the index is less than zero, the underlying list is called, which\n     * will probably throw an IndexOutOfBoundsException.\n     *\n     * @param index  the index to add at\n     * @param element  the object to add at the specified index\n     * @throws UnsupportedOperationException if the underlying list doesn't implement set\n     * @throws ClassCastException if the underlying list rejects the element\n     * @throws IllegalArgumentException if the underlying list rejects the element\n     */\n    @Override\n    public void add(final int index, final E element) {\n        final int size = decorated().size();\n        if (index > size) {\n            decorated().addAll(Collections.<E>nCopies(index - size, null));\n        }\n        decorated().add(index, element);\n    }\n\n    /**\n     * Decorate the addAll method to perform the growth behavior.\n     * <p>\n     * If the requested index is greater than the current size, the list will\n     * grow to the new size. Indices between the old size and the requested\n     * size will be filled with {@code null}.\n     * <p>\n     * If the index is less than the current size, the values will be added to\n     * the underlying list directly.\n     * If the index is less than zero, the underlying list is called, which\n     * will probably throw an IndexOutOfBoundsException.\n     *\n     * @param index  the index to add at\n     * @param coll  the collection to add at the specified index\n     * @return true if the list changed\n     * @throws UnsupportedOperationException if the underlying list doesn't implement set\n     * @throws ClassCastException if the underlying list rejects the element\n     * @throws IllegalArgumentException if the underlying list rejects the element\n     */\n    @Override\n    public boolean addAll(final int index, final Collection<? extends E> coll) {\n        final int size = decorated().size();\n        boolean result = false;\n        if (index > size) {\n            decorated().addAll(Collections.<E>nCopies(index - size, null));\n            result = true;\n        }\n        return decorated().addAll(index, coll) || result;\n    }\n\n    /**\n     * Decorate the set method to perform the growth behavior.\n     * <p>\n     * If the requested index is greater than the current size, the list will\n     * grow to the new size. Indices between the old size and the requested\n     * size will be filled with {@code null}.\n     * <p>\n     * If the index is less than the current size, the value will be set onto\n     * the underlying list directly.\n     * If the index is less than zero, the underlying list is called, which\n     * will probably throw an IndexOutOfBoundsException.\n     *\n     * @param index  the index to set\n     * @param element  the object to set at the specified index\n     * @return the object previously at that index\n     * @throws UnsupportedOperationException if the underlying list doesn't implement set\n     * @throws ClassCastException if the underlying list rejects the element\n     * @throws IllegalArgumentException if the underlying list rejects the element\n     */\n    @Override\n    public E set(final int index, final E element) {\n        final int size = decorated().size();\n        if (index >= size) {\n            decorated().addAll(Collections.<E>nCopies(index - size + 1, null));\n        }\n        return decorated().set(index, element);\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = -3620001881672L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -3620001881672L", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/list/TransformedList.java.TransformedList", "name": "TransformedList", "file_path": "src/main/java/org/apache/commons/collections4/list/TransformedList.java", "superclasses": "", "methods": ["[TransformedList<E>]transformedList(List<E>,Transformer<? super E, ? extends E>)", "[TransformedList<E>]transformingList(List<E>,Transformer<? super E, ? extends E>)", "[]TransformedList(List<E>,Transformer<? super E, ? extends E>)", "[void]add(int,E)", "[boolean]addAll(int,Collection<? extends E>)", "[boolean]equals(Object)", "[E]get(int)", "[List<E>]getList()", "[int]hashCode()", "[int]indexOf(Object)", "[int]lastIndexOf(Object)", "[ListIterator<E>]listIterator()", "[ListIterator<E>]listIterator(int)", "[E]remove(int)", "[E]set(int,E)", "[List<E>]subList(int,int)"], "method_uris": ["src/main/java/org/apache/commons/collections4/list/TransformedList.java.TransformedList.[TransformedList<E>]transformedList(List<E>,Transformer<? super E, ? extends E>)", "src/main/java/org/apache/commons/collections4/list/TransformedList.java.TransformedList.[TransformedList<E>]transformingList(List<E>,Transformer<? super E, ? extends E>)", "src/main/java/org/apache/commons/collections4/list/TransformedList.java.TransformedList.[]TransformedList(List<E>,Transformer<? super E, ? extends E>)", "src/main/java/org/apache/commons/collections4/list/TransformedList.java.TransformedList.[void]add(int,E)", "src/main/java/org/apache/commons/collections4/list/TransformedList.java.TransformedList.[boolean]addAll(int,Collection<? extends E>)", "src/main/java/org/apache/commons/collections4/list/TransformedList.java.TransformedList.[boolean]equals(Object)", "src/main/java/org/apache/commons/collections4/list/TransformedList.java.TransformedList.[E]get(int)", "src/main/java/org/apache/commons/collections4/list/TransformedList.java.TransformedList.[List<E>]getList()", "src/main/java/org/apache/commons/collections4/list/TransformedList.java.TransformedList.[int]hashCode()", "src/main/java/org/apache/commons/collections4/list/TransformedList.java.TransformedList.[int]indexOf(Object)", "src/main/java/org/apache/commons/collections4/list/TransformedList.java.TransformedList.[int]lastIndexOf(Object)", "src/main/java/org/apache/commons/collections4/list/TransformedList.java.TransformedList.[ListIterator<E>]listIterator()", "src/main/java/org/apache/commons/collections4/list/TransformedList.java.TransformedList.[ListIterator<E>]listIterator(int)", "src/main/java/org/apache/commons/collections4/list/TransformedList.java.TransformedList.[E]remove(int)", "src/main/java/org/apache/commons/collections4/list/TransformedList.java.TransformedList.[E]set(int,E)", "src/main/java/org/apache/commons/collections4/list/TransformedList.java.TransformedList.[List<E>]subList(int,int)"], "overrides": null, "attributes": [{"original_string": "    protected class TransformedListIterator extends AbstractListIteratorDecorator<E> {\n\n        /**\n         * Create a new transformed list iterator.\n         *\n         * @param iterator  the list iterator to decorate\n         */\n        protected TransformedListIterator(final ListIterator<E> iterator) {\n            super(iterator);\n        }\n\n        @Override\n        public void add(E object) {\n            object = transform(object);\n            getListIterator().add(object);\n        }\n\n        @Override\n        public void set(final E object) {\n            getListIterator().set(transform(object));\n        }\n    }", "definition": "    protected class TransformedListIterator extends AbstractListIteratorDecorator<E>", "class_docstring": "\nInner class Iterator for the TransformedList\n", "name": "TransformedListIterator", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        protected TransformedListIterator(final ListIterator<E> iterator) {\n            super(iterator);\n        }", "docstring": "\nCreate a new transformed list iterator.\n\n@param iterator  the list iterator to decorate\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "name": "TransformedListIterator", "params": [{"name": "iterator", "type": "ListIterator<E>"}], "body": "                                                                          {\n            super(iterator);\n        }", "signature": "protected TransformedListIterator(final ListIterator<E> iterator)"}, {"syntax_pass": true, "original_string": "        @Override\n        public void add(E object) {\n            object = transform(object);\n            getListIterator().add(object);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "add", "params": [{"name": "object", "type": "E"}], "body": "                                  {\n            object = transform(object);\n            getListIterator().add(object);\n        }", "signature": "@Override\n        public void add(E object)"}, {"syntax_pass": true, "original_string": "        @Override\n        public void set(final E object) {\n            getListIterator().set(transform(object));\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "set", "params": [{"name": "object", "type": "E"}], "body": "                                        {\n            getListIterator().set(transform(object));\n        }", "signature": "@Override\n        public void set(final E object)"}]}], "class_docstring": "\nDecorates another {@code List} to transform objects that are added.\n<p>\nThe add and set methods are affected by this class.\nThus objects must be removed or searched for using their transformed form.\nFor example, if the transformation converts Strings to Integers, you must\nuse the Integer form to remove objects.\n</p>\n<p>\nThis class is Serializable from Commons Collections 3.1.\n</p>\n\n@param <E> the type of the elements in the list.\n@since 3.0\n", "original_string": "public class TransformedList<E> extends TransformedCollection<E> implements List<E> {\n\n    /**\n     * Inner class Iterator for the TransformedList\n     */\n    protected class TransformedListIterator extends AbstractListIteratorDecorator<E> {\n\n        /**\n         * Create a new transformed list iterator.\n         *\n         * @param iterator  the list iterator to decorate\n         */\n        protected TransformedListIterator(final ListIterator<E> iterator) {\n            super(iterator);\n        }\n\n        @Override\n        public void add(E object) {\n            object = transform(object);\n            getListIterator().add(object);\n        }\n\n        @Override\n        public void set(final E object) {\n            getListIterator().set(transform(object));\n        }\n    }\n\n    /** Serialization version */\n    private static final long serialVersionUID = 1077193035000013141L;\n\n    /**\n     * Factory method to create a transforming list that will transform\n     * existing contents of the specified list.\n     * <p>\n     * If there are any elements already in the list being decorated, they\n     * will be transformed by this method.\n     * Contrast this with {@link #transformingList(List, Transformer)}.\n     *\n     * @param <E> the type of the elements in the list\n     * @param list  the list to decorate, must not be null\n     * @param transformer  the transformer to use for conversion, must not be null\n     * @return a new transformed List\n     * @throws NullPointerException if list or transformer is null\n     * @since 4.0\n     */\n    public static <E> TransformedList<E> transformedList(final List<E> list,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n        final TransformedList<E> decorated = new TransformedList<>(list, transformer);\n        if (!list.isEmpty()) {\n            @SuppressWarnings(\"unchecked\") // list is of type E\n            final E[] values = (E[]) list.toArray(); // NOPMD - false positive for generics\n            list.clear();\n            for (final E value : values) {\n                decorated.decorated().add(transformer.apply(value));\n            }\n        }\n        return decorated;\n    }\n\n    /**\n     * Factory method to create a transforming list.\n     * <p>\n     * If there are any elements already in the list being decorated, they\n     * are NOT transformed.\n     * Contrast this with {@link #transformedList(List, Transformer)}.\n     *\n     * @param <E> the type of the elements in the list\n     * @param list  the list to decorate, must not be null\n     * @param transformer  the transformer to use for conversion, must not be null\n     * @return a new transformed list\n     * @throws NullPointerException if list or transformer is null\n     * @since 4.0\n     */\n    public static <E> TransformedList<E> transformingList(final List<E> list,\n                                                          final Transformer<? super E, ? extends E> transformer) {\n        return new TransformedList<>(list, transformer);\n    }\n\n    /**\n     * Constructor that wraps (not copies).\n     * <p>\n     * If there are any elements already in the list being decorated, they\n     * are NOT transformed.\n     *\n     * @param list  the list to decorate, must not be null\n     * @param transformer  the transformer to use for conversion, must not be null\n     * @throws NullPointerException if list or transformer is null\n     */\n    protected TransformedList(final List<E> list, final Transformer<? super E, ? extends E> transformer) {\n        super(list, transformer);\n    }\n\n    @Override\n    public void add(final int index, E object) {\n        object = transform(object);\n        getList().add(index, object);\n    }\n\n    @Override\n    public boolean addAll(final int index, Collection<? extends E> coll) {\n        coll = transform(coll);\n        return getList().addAll(index, coll);\n    }\n\n    @Override\n    public boolean equals(final Object object) {\n        return object == this || decorated().equals(object);\n    }\n\n    @Override\n    public E get(final int index) {\n        return getList().get(index);\n    }\n\n    /**\n     * Gets the decorated list.\n     *\n     * @return the decorated list\n     */\n    protected List<E> getList() {\n        return (List<E>) decorated();\n    }\n\n    @Override\n    public int hashCode() {\n        return decorated().hashCode();\n    }\n\n    @Override\n    public int indexOf(final Object object) {\n        return getList().indexOf(object);\n    }\n\n    @Override\n    public int lastIndexOf(final Object object) {\n        return getList().lastIndexOf(object);\n    }\n\n    @Override\n    public ListIterator<E> listIterator() {\n        return listIterator(0);\n    }\n\n    @Override\n    public ListIterator<E> listIterator(final int i) {\n        return new TransformedListIterator(getList().listIterator(i));\n    }\n\n    @Override\n    public E remove(final int index) {\n        return getList().remove(index);\n    }\n\n    @Override\n    public E set(final int index, E object) {\n        object = transform(object);\n        return getList().set(index, object);\n    }\n\n    @Override\n    public List<E> subList(final int fromIndex, final int toIndex) {\n        final List<E> sub = getList().subList(fromIndex, toIndex);\n        return new TransformedList<>(sub, transformer);\n    }\n\n}", "super_interfaces": ["List<E>"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 1077193035000013141L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 1077193035000013141L", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/list/SetUniqueList.java.SetUniqueList", "name": "SetUniqueList", "file_path": "src/main/java/org/apache/commons/collections4/list/SetUniqueList.java", "superclasses": "", "methods": ["[SetUniqueList<E>]setUniqueList(List<E>)", "[]SetUniqueList(List<E>,Set<E>)", "[boolean]add(E)", "[void]add(int,E)", "[boolean]addAll(Collection<? extends E>)", "[boolean]addAll(int,Collection<? extends E>)", "[Set<E>]asSet()", "[void]clear()", "[boolean]contains(Object)", "[boolean]containsAll(Collection<?>)", "[Set<E>]createSetBasedOnList(Set<E>,List<E>)", "[Iterator<E>]iterator()", "[ListIterator<E>]listIterator()", "[ListIterator<E>]listIterator(int)", "[E]remove(int)", "[boolean]remove(Object)", "[boolean]removeAll(Collection<?>)", "[boolean]removeIf(Predicate<? super E>)", "[boolean]retainAll(Collection<?>)", "[E]set(int,E)", "[List<E>]subList(int,int)"], "method_uris": ["src/main/java/org/apache/commons/collections4/list/SetUniqueList.java.SetUniqueList.[SetUniqueList<E>]setUniqueList(List<E>)", "src/main/java/org/apache/commons/collections4/list/SetUniqueList.java.SetUniqueList.[]SetUniqueList(List<E>,Set<E>)", "src/main/java/org/apache/commons/collections4/list/SetUniqueList.java.SetUniqueList.[boolean]add(E)", "src/main/java/org/apache/commons/collections4/list/SetUniqueList.java.SetUniqueList.[void]add(int,E)", "src/main/java/org/apache/commons/collections4/list/SetUniqueList.java.SetUniqueList.[boolean]addAll(Collection<? extends E>)", "src/main/java/org/apache/commons/collections4/list/SetUniqueList.java.SetUniqueList.[boolean]addAll(int,Collection<? extends E>)", "src/main/java/org/apache/commons/collections4/list/SetUniqueList.java.SetUniqueList.[Set<E>]asSet()", "src/main/java/org/apache/commons/collections4/list/SetUniqueList.java.SetUniqueList.[void]clear()", "src/main/java/org/apache/commons/collections4/list/SetUniqueList.java.SetUniqueList.[boolean]contains(Object)", "src/main/java/org/apache/commons/collections4/list/SetUniqueList.java.SetUniqueList.[boolean]containsAll(Collection<?>)", "src/main/java/org/apache/commons/collections4/list/SetUniqueList.java.SetUniqueList.[Set<E>]createSetBasedOnList(Set<E>,List<E>)", "src/main/java/org/apache/commons/collections4/list/SetUniqueList.java.SetUniqueList.[Iterator<E>]iterator()", "src/main/java/org/apache/commons/collections4/list/SetUniqueList.java.SetUniqueList.[ListIterator<E>]listIterator()", "src/main/java/org/apache/commons/collections4/list/SetUniqueList.java.SetUniqueList.[ListIterator<E>]listIterator(int)", "src/main/java/org/apache/commons/collections4/list/SetUniqueList.java.SetUniqueList.[E]remove(int)", "src/main/java/org/apache/commons/collections4/list/SetUniqueList.java.SetUniqueList.[boolean]remove(Object)", "src/main/java/org/apache/commons/collections4/list/SetUniqueList.java.SetUniqueList.[boolean]removeAll(Collection<?>)", "src/main/java/org/apache/commons/collections4/list/SetUniqueList.java.SetUniqueList.[boolean]removeIf(Predicate<? super E>)", "src/main/java/org/apache/commons/collections4/list/SetUniqueList.java.SetUniqueList.[boolean]retainAll(Collection<?>)", "src/main/java/org/apache/commons/collections4/list/SetUniqueList.java.SetUniqueList.[E]set(int,E)", "src/main/java/org/apache/commons/collections4/list/SetUniqueList.java.SetUniqueList.[List<E>]subList(int,int)"], "overrides": null, "attributes": [{"original_string": "    static class SetListIterator<E> extends AbstractIteratorDecorator<E> {\n\n        private final Set<E> set;\n        private E last;\n\n        protected SetListIterator(final Iterator<E> it, final Set<E> set) {\n            super(it);\n            this.set = set;\n        }\n\n        @Override\n        public E next() {\n            last = super.next();\n            return last;\n        }\n\n        @Override\n        public void remove() {\n            super.remove();\n            set.remove(last);\n            last = null;\n        }\n    }", "definition": "    static class SetListIterator<E> extends AbstractIteratorDecorator<E>", "class_docstring": "\nInner class iterator.\n", "name": "SetListIterator", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "private final Set<E> set;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Set<E>", "name": "set", "syntax_pass": true}, {"attribute_expression": "private E last;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "E", "name": "last", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        protected SetListIterator(final Iterator<E> it, final Set<E> set) {\n            super(it);\n            this.set = set;\n        }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "name": "SetListIterator", "params": [{"name": "it", "type": "Iterator<E>"}, {"name": "set", "type": "Set<E>"}], "body": "                                                                          {\n            super(it);\n            this.set = set;\n        }", "signature": "protected SetListIterator(final Iterator<E> it, final Set<E> set)"}, {"syntax_pass": true, "original_string": "        @Override\n        public E next() {\n            last = super.next();\n            return last;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "E", "classes": []}, "name": "next", "params": [], "body": "                        {\n            last = super.next();\n            return last;\n        }", "signature": "@Override\n        public E next()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void remove() {\n            super.remove();\n            set.remove(last);\n            last = null;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "remove", "params": [], "body": "                             {\n            super.remove();\n            set.remove(last);\n            last = null;\n        }", "signature": "@Override\n        public void remove()"}]}, {"original_string": "    static class SetListListIterator<E> extends\n            AbstractListIteratorDecorator<E> {\n\n        private final Set<E> set;\n        private E last;\n\n        protected SetListListIterator(final ListIterator<E> it, final Set<E> set) {\n            super(it);\n            this.set = set;\n        }\n\n        @Override\n        public void add(final E object) {\n            if (!set.contains(object)) {\n                super.add(object);\n                set.add(object);\n            }\n        }\n\n        @Override\n        public E next() {\n            last = super.next();\n            return last;\n        }\n\n        @Override\n        public E previous() {\n            last = super.previous();\n            return last;\n        }\n\n        @Override\n        public void remove() {\n            super.remove();\n            set.remove(last);\n            last = null;\n        }\n\n        @Override\n        public void set(final E object) {\n            throw new UnsupportedOperationException(\"ListIterator does not support set\");\n        }\n    }", "definition": "    static class SetListListIterator<E> extends\n            AbstractListIteratorDecorator<E>", "class_docstring": "\nInner class iterator.\n", "name": "SetListListIterator", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "private final Set<E> set;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Set<E>", "name": "set", "syntax_pass": true}, {"attribute_expression": "private E last;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "E", "name": "last", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        protected SetListListIterator(final ListIterator<E> it, final Set<E> set) {\n            super(it);\n            this.set = set;\n        }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "name": "SetListListIterator", "params": [{"name": "it", "type": "ListIterator<E>"}, {"name": "set", "type": "Set<E>"}], "body": "                                                                                  {\n            super(it);\n            this.set = set;\n        }", "signature": "protected SetListListIterator(final ListIterator<E> it, final Set<E> set)"}, {"syntax_pass": true, "original_string": "        @Override\n        public void add(final E object) {\n            if (!set.contains(object)) {\n                super.add(object);\n                set.add(object);\n            }\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "add", "params": [{"name": "object", "type": "E"}], "body": "                                        {\n            if (!set.contains(object)) {\n                super.add(object);\n                set.add(object);\n            }\n        }", "signature": "@Override\n        public void add(final E object)"}, {"syntax_pass": true, "original_string": "        @Override\n        public E next() {\n            last = super.next();\n            return last;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "E", "classes": []}, "name": "next", "params": [], "body": "                        {\n            last = super.next();\n            return last;\n        }", "signature": "@Override\n        public E next()"}, {"syntax_pass": true, "original_string": "        @Override\n        public E previous() {\n            last = super.previous();\n            return last;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "E", "classes": []}, "name": "previous", "params": [], "body": "                            {\n            last = super.previous();\n            return last;\n        }", "signature": "@Override\n        public E previous()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void remove() {\n            super.remove();\n            set.remove(last);\n            last = null;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "remove", "params": [], "body": "                             {\n            super.remove();\n            set.remove(last);\n            last = null;\n        }", "signature": "@Override\n        public void remove()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void set(final E object) {\n            throw new UnsupportedOperationException(\"ListIterator does not support set\");\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "set", "params": [{"name": "object", "type": "E"}], "body": "                                        {\n            throw new UnsupportedOperationException(\"ListIterator does not support set\");\n        }", "signature": "@Override\n        public void set(final E object)"}]}], "class_docstring": "\nDecorates a {@code List} to ensure that no duplicates are present much\nlike a {@code Set}.\n<p>\nThe {@code List} interface makes certain assumptions/requirements. This\nimplementation breaks these in certain ways, but this is merely the result of\nrejecting duplicates. Each violation is explained in the method, but it\nshould not affect you. Bear in mind that Sets require immutable objects to\nfunction correctly.\n</p>\n<p>\nThe {@link org.apache.commons.collections4.set.ListOrderedSet ListOrderedSet}\nclass provides an alternative approach, by wrapping an existing Set and\nretaining insertion order in the iterator.\n</p>\n<p>\nThis class is Serializable from Commons Collections 3.1.\n</p>\n\n@param <E> the type of the elements in the list.\n@since 3.0\n", "original_string": "public class SetUniqueList<E> extends AbstractSerializableListDecorator<E> {\n\n    /**\n     * Inner class iterator.\n     */\n    static class SetListIterator<E> extends AbstractIteratorDecorator<E> {\n\n        private final Set<E> set;\n        private E last;\n\n        protected SetListIterator(final Iterator<E> it, final Set<E> set) {\n            super(it);\n            this.set = set;\n        }\n\n        @Override\n        public E next() {\n            last = super.next();\n            return last;\n        }\n\n        @Override\n        public void remove() {\n            super.remove();\n            set.remove(last);\n            last = null;\n        }\n    }\n\n    /**\n     * Inner class iterator.\n     */\n    static class SetListListIterator<E> extends\n            AbstractListIteratorDecorator<E> {\n\n        private final Set<E> set;\n        private E last;\n\n        protected SetListListIterator(final ListIterator<E> it, final Set<E> set) {\n            super(it);\n            this.set = set;\n        }\n\n        @Override\n        public void add(final E object) {\n            if (!set.contains(object)) {\n                super.add(object);\n                set.add(object);\n            }\n        }\n\n        @Override\n        public E next() {\n            last = super.next();\n            return last;\n        }\n\n        @Override\n        public E previous() {\n            last = super.previous();\n            return last;\n        }\n\n        @Override\n        public void remove() {\n            super.remove();\n            set.remove(last);\n            last = null;\n        }\n\n        @Override\n        public void set(final E object) {\n            throw new UnsupportedOperationException(\"ListIterator does not support set\");\n        }\n    }\n\n    /** Serialization version. */\n    private static final long serialVersionUID = 7196982186153478694L;\n\n    /**\n     * Factory method to create a SetList using the supplied list to retain order.\n     * <p>\n     * If the list contains duplicates, these are removed (first indexed one\n     * kept). A {@code HashSet} is used for the set behavior.\n     *\n     * @param <E>  the element type\n     * @param list  the list to decorate, must not be null\n     * @return a new {@link SetUniqueList}\n     * @throws NullPointerException if list is null\n     * @since 4.0\n     */\n    public static <E> SetUniqueList<E> setUniqueList(final List<E> list) {\n        Objects.requireNonNull(list, \"list\");\n        if (list.isEmpty()) {\n            return new SetUniqueList<>(list, new HashSet<>());\n        }\n        final List<E> temp = new ArrayList<>(list);\n        list.clear();\n        final SetUniqueList<E> sl = new SetUniqueList<>(list, new HashSet<>());\n        sl.addAll(temp);\n        return sl;\n    }\n\n    /** Internal Set to maintain uniqueness. */\n    private final Set<E> set;\n\n    /**\n     * Constructor that wraps (not copies) the List and specifies the set to use.\n     * <p>\n     * The set and list must both be correctly initialized to the same elements.\n     *\n     * @param set  the set to decorate, must not be null\n     * @param list  the list to decorate, must not be null\n     * @throws NullPointerException if set or list is null\n     */\n    protected SetUniqueList(final List<E> list, final Set<E> set) {\n        super(list);\n        this.set = Objects.requireNonNull(set, \"set\");\n    }\n\n    /**\n     * Adds an element to the list if it is not already present.\n     * <p>\n     * <em>(Violation)</em> The {@code List} interface requires that this\n     * method returns {@code true} always. However, this class may return\n     * {@code false} because of the {@code Set} behavior.\n     *\n     * @param object  the object to add\n     * @return true if object was added\n     */\n    @Override\n    public boolean add(final E object) {\n        // gets initial size\n        final int sizeBefore = size();\n\n        // adds element if unique\n        add(size(), object);\n\n        // compares sizes to detect if collection changed\n        return sizeBefore != size();\n    }\n\n    /**\n     * Adds an element to a specific index in the list if it is not already\n     * present.\n     * <p>\n     * <em>(Violation)</em> The {@code List} interface makes the assumption\n     * that the element is always inserted. This may not happen with this\n     * implementation.\n     *\n     * @param index  the index to insert at\n     * @param object  the object to add\n     */\n    @Override\n    public void add(final int index, final E object) {\n        // adds element if it is not contained already\n        if (!set.contains(object)) {\n            set.add(object);\n            super.add(index, object);\n        }\n    }\n\n    /**\n     * Adds a collection of objects to the end of the list avoiding duplicates.\n     * <p>\n     * Only elements that are not already in this list will be added, and\n     * duplicates from the specified collection will be ignored.\n     * <p>\n     * <em>(Violation)</em> The {@code List} interface makes the assumption\n     * that the elements are always inserted. This may not happen with this\n     * implementation.\n     *\n     * @param coll  the collection to add in iterator order\n     * @return true if this collection changed\n     */\n    @Override\n    public boolean addAll(final Collection<? extends E> coll) {\n        return addAll(size(), coll);\n    }\n\n    /**\n     * Adds a collection of objects a specific index in the list avoiding\n     * duplicates.\n     * <p>\n     * Only elements that are not already in this list will be added, and\n     * duplicates from the specified collection will be ignored.\n     * <p>\n     * <em>(Violation)</em> The {@code List} interface makes the assumption\n     * that the elements are always inserted. This may not happen with this\n     * implementation.\n     *\n     * @param index  the index to insert at\n     * @param coll  the collection to add in iterator order\n     * @return true if this collection changed\n     */\n    @Override\n    public boolean addAll(final int index, final Collection<? extends E> coll) {\n        final List<E> temp = new ArrayList<>();\n        for (final E e : coll) {\n            if (set.add(e)) {\n                temp.add(e);\n            }\n        }\n        return super.addAll(index, temp);\n    }\n\n    /**\n     * Gets an unmodifiable view as a Set.\n     *\n     * @return an unmodifiable set view\n     */\n    public Set<E> asSet() {\n        return UnmodifiableSet.unmodifiableSet(set);\n    }\n\n    @Override\n    public void clear() {\n        super.clear();\n        set.clear();\n    }\n\n    @Override\n    public boolean contains(final Object object) {\n        return set.contains(object);\n    }\n\n    @Override\n    public boolean containsAll(final Collection<?> coll) {\n        return set.containsAll(coll);\n    }\n\n    /**\n     * Create a new {@link Set} with the same type as the provided {@code set}\n     * and populate it with all elements of {@code list}.\n     *\n     * @param set  the {@link Set} to be used as return type, must not be null\n     * @param list  the {@link List} to populate the {@link Set}\n     * @return a new {@link Set} populated with all elements of the provided\n     *   {@link List}\n     */\n    protected Set<E> createSetBasedOnList(final Set<E> set, final List<E> list) {\n        Set<E> subSet;\n        if (set.getClass().equals(HashSet.class)) {\n            subSet = new HashSet<>(list.size());\n        } else {\n            try {\n                subSet = set.getClass().getDeclaredConstructor(set.getClass()).newInstance(set);\n            } catch (final InstantiationException\n                    | IllegalAccessException\n                    | InvocationTargetException\n                    | NoSuchMethodException ie) {\n                subSet = new HashSet<>();\n            }\n        }\n        subSet.addAll(list);\n        return subSet;\n    }\n\n    @Override\n    public Iterator<E> iterator() {\n        return new SetListIterator<>(super.iterator(), set);\n    }\n\n    @Override\n    public ListIterator<E> listIterator() {\n        return new SetListListIterator<>(super.listIterator(), set);\n    }\n\n    @Override\n    public ListIterator<E> listIterator(final int index) {\n        return new SetListListIterator<>(super.listIterator(index), set);\n    }\n\n    @Override\n    public E remove(final int index) {\n        final E result = super.remove(index);\n        set.remove(result);\n        return result;\n    }\n\n    @Override\n    public boolean remove(final Object object) {\n        final boolean result = set.remove(object);\n        if (result) {\n            super.remove(object);\n        }\n        return result;\n    }\n\n    @Override\n    public boolean removeAll(final Collection<?> coll) {\n        boolean result = false;\n        for (final Object name : coll) {\n            result |= remove(name);\n        }\n        return result;\n    }\n\n    /**\n     * @since 4.4\n     */\n    @Override\n    public boolean removeIf(final Predicate<? super E> filter) {\n        final boolean result = super.removeIf(filter);\n        set.removeIf(filter);\n        return result;\n    }\n\n    /**\n     * {@inheritDoc}\n     * <p>\n     * This implementation iterates over the elements of this list, checking\n     * each element in turn to see if it's contained in {@code coll}.\n     * If it's not contained, it's removed from this list. As a consequence,\n     * it is advised to use a collection type for {@code coll} that provides\n     * a fast (e.g. O(1)) implementation of {@link Collection#contains(Object)}.\n     */\n    @Override\n    public boolean retainAll(final Collection<?> coll) {\n        final boolean result = set.retainAll(coll);\n        if (!result) {\n            return false;\n        }\n        if (set.isEmpty()) {\n            super.clear();\n        } else {\n            // use the set as parameter for the call to retainAll to improve performance\n            super.retainAll(set);\n        }\n        return result;\n    }\n\n    /**\n     * Sets the value at the specified index avoiding duplicates.\n     * <p>\n     * The object is set into the specified index. Afterwards, any previous\n     * duplicate is removed. If the object is not already in the list then a\n     * normal set occurs. If it is present, then the old version is removed.\n     *\n     * @param index  the index to insert at\n     * @param object  the object to set\n     * @return the previous object\n     */\n    @Override\n    public E set(final int index, final E object) {\n        final int pos = indexOf(object);\n        final E removed = super.set(index, object);\n\n        if (pos != -1 && pos != index) {\n            // the object is already in the unique list\n            // (and it hasn't been swapped with itself)\n            super.remove(pos); // remove the duplicate by index\n        }\n\n        set.remove(removed); // remove the item deleted by the set\n        set.add(object); // add the new item to the unique set\n\n        return removed; // return the item deleted by the set\n    }\n\n    /**\n     * {@inheritDoc}\n     * <p>\n     * NOTE: from 4.0, an unmodifiable list will be returned, as changes to the\n     * subList can invalidate the parent list.\n     */\n    @Override\n    public List<E> subList(final int fromIndex, final int toIndex) {\n        final List<E> superSubList = super.subList(fromIndex, toIndex);\n        final Set<E> subSet = createSetBasedOnList(set, superSubList);\n        return ListUtils.unmodifiableList(new SetUniqueList<>(superSubList, subSet));\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = 7196982186153478694L;", "docstring": " Serialization version.", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 7196982186153478694L", "syntax_pass": true}, {"attribute_expression": "private final Set<E> set;", "docstring": " Internal Set to maintain uniqueness.", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Set<E>", "name": "set", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/list/UnmodifiableList.java.UnmodifiableList", "name": "UnmodifiableList", "file_path": "src/main/java/org/apache/commons/collections4/list/UnmodifiableList.java", "superclasses": "", "methods": ["[List<E>]unmodifiableList(List<? extends E>)", "[]UnmodifiableList(List<? extends E>)", "[void]add(int,E)", "[boolean]add(Object)", "[boolean]addAll(Collection<? extends E>)", "[boolean]addAll(int,Collection<? extends E>)", "[void]clear()", "[Iterator<E>]iterator()", "[ListIterator<E>]listIterator()", "[ListIterator<E>]listIterator(int)", "[E]remove(int)", "[boolean]remove(Object)", "[boolean]removeAll(Collection<?>)", "[boolean]removeIf(Predicate<? super E>)", "[boolean]retainAll(Collection<?>)", "[E]set(int,E)", "[List<E>]subList(int,int)"], "method_uris": ["src/main/java/org/apache/commons/collections4/list/UnmodifiableList.java.UnmodifiableList.[List<E>]unmodifiableList(List<? extends E>)", "src/main/java/org/apache/commons/collections4/list/UnmodifiableList.java.UnmodifiableList.[]UnmodifiableList(List<? extends E>)", "src/main/java/org/apache/commons/collections4/list/UnmodifiableList.java.UnmodifiableList.[void]add(int,E)", "src/main/java/org/apache/commons/collections4/list/UnmodifiableList.java.UnmodifiableList.[boolean]add(Object)", "src/main/java/org/apache/commons/collections4/list/UnmodifiableList.java.UnmodifiableList.[boolean]addAll(Collection<? extends E>)", "src/main/java/org/apache/commons/collections4/list/UnmodifiableList.java.UnmodifiableList.[boolean]addAll(int,Collection<? extends E>)", "src/main/java/org/apache/commons/collections4/list/UnmodifiableList.java.UnmodifiableList.[void]clear()", "src/main/java/org/apache/commons/collections4/list/UnmodifiableList.java.UnmodifiableList.[Iterator<E>]iterator()", "src/main/java/org/apache/commons/collections4/list/UnmodifiableList.java.UnmodifiableList.[ListIterator<E>]listIterator()", "src/main/java/org/apache/commons/collections4/list/UnmodifiableList.java.UnmodifiableList.[ListIterator<E>]listIterator(int)", "src/main/java/org/apache/commons/collections4/list/UnmodifiableList.java.UnmodifiableList.[E]remove(int)", "src/main/java/org/apache/commons/collections4/list/UnmodifiableList.java.UnmodifiableList.[boolean]remove(Object)", "src/main/java/org/apache/commons/collections4/list/UnmodifiableList.java.UnmodifiableList.[boolean]removeAll(Collection<?>)", "src/main/java/org/apache/commons/collections4/list/UnmodifiableList.java.UnmodifiableList.[boolean]removeIf(Predicate<? super E>)", "src/main/java/org/apache/commons/collections4/list/UnmodifiableList.java.UnmodifiableList.[boolean]retainAll(Collection<?>)", "src/main/java/org/apache/commons/collections4/list/UnmodifiableList.java.UnmodifiableList.[E]set(int,E)", "src/main/java/org/apache/commons/collections4/list/UnmodifiableList.java.UnmodifiableList.[List<E>]subList(int,int)"], "overrides": null, "attributes": [], "class_docstring": "\nDecorates another {@code List} to ensure it can't be altered.\n<p>\nThis class is Serializable from Commons Collections 3.1.\n</p>\n<p>\nAttempts to modify it will result in an UnsupportedOperationException.\n</p>\n\n@param <E> the type of the elements in the list.\n@since 3.0\n", "original_string": "public final class UnmodifiableList<E>\n        extends AbstractSerializableListDecorator<E>\n        implements Unmodifiable {\n\n    /** Serialization version */\n    private static final long serialVersionUID = 6595182819922443652L;\n\n    /**\n     * Factory method to create an unmodifiable list.\n     *\n     * @param <E> the type of the elements in the list\n     * @param list  the list to decorate, must not be null\n     * @return a new unmodifiable list\n     * @throws NullPointerException if list is null\n     * @since 4.0\n     */\n    public static <E> List<E> unmodifiableList(final List<? extends E> list) {\n        if (list instanceof Unmodifiable) {\n            @SuppressWarnings(\"unchecked\") // safe to upcast\n            final List<E> tmpList = (List<E>) list;\n            return tmpList;\n        }\n        return new UnmodifiableList<>(list);\n    }\n\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param list  the list to decorate, must not be null\n     * @throws NullPointerException if list is null\n     */\n    @SuppressWarnings(\"unchecked\") // safe to upcast\n    public UnmodifiableList(final List<? extends E> list) {\n        super((List<E>) list);\n    }\n\n    @Override\n    public void add(final int index, final E object) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public boolean add(final Object object) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public boolean addAll(final Collection<? extends E> coll) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public boolean addAll(final int index, final Collection<? extends E> coll) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public void clear() {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public Iterator<E> iterator() {\n        return UnmodifiableIterator.unmodifiableIterator(decorated().iterator());\n    }\n\n    @Override\n    public ListIterator<E> listIterator() {\n        return UnmodifiableListIterator.unmodifiableListIterator(decorated().listIterator());\n    }\n\n    @Override\n    public ListIterator<E> listIterator(final int index) {\n        return UnmodifiableListIterator.unmodifiableListIterator(decorated().listIterator(index));\n    }\n\n    @Override\n    public E remove(final int index) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public boolean remove(final Object object) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public boolean removeAll(final Collection<?> coll) {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * @since 4.4\n     */\n    @Override\n    public boolean removeIf(final Predicate<? super E> filter) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public boolean retainAll(final Collection<?> coll) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public E set(final int index, final E object) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public List<E> subList(final int fromIndex, final int toIndex) {\n        final List<E> sub = decorated().subList(fromIndex, toIndex);\n        return new UnmodifiableList<>(sub);\n    }\n\n}", "super_interfaces": ["Unmodifiable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 6595182819922443652L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 6595182819922443652L", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilter.java.LayeredBloomFilter", "name": "LayeredBloomFilter", "file_path": "src/main/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilter.java", "superclasses": "", "methods": ["[]LayeredBloomFilter(Shape,LayerManager<T>)", "[int]cardinality()", "[int]characteristics()", "[void]cleanup()", "[void]clear()", "[boolean]contains(BitMapExtractor)", "[boolean]contains(BloomFilter)", "[boolean]contains(BloomFilterExtractor)", "[boolean]contains(Hasher)", "[boolean]contains(IndexExtractor)", "[LayeredBloomFilter<T>]copy()", "[BloomFilter]createFilter(BitMapExtractor)", "[BloomFilter]createFilter(Hasher)", "[BloomFilter]createFilter(IndexExtractor)", "[int]estimateN()", "[int]estimateUnion(BloomFilter)", "[int[]]find(BitMapExtractor)", "[int[]]find(BloomFilter)", "[int[]]find(Hasher)", "[int[]]find(IndexExtractor)", "[BloomFilter]flatten()", "[T]get(int)", "[int]getDepth()", "[Shape]getShape()", "[boolean]isEmpty()", "[boolean]merge(BitMapExtractor)", "[boolean]merge(BloomFilter)", "[boolean]merge(IndexExtractor)", "[void]next()", "[boolean]processBitMaps(LongPredicate)", "[boolean]processBloomFilters(Predicate<BloomFilter>)", "[boolean]processIndices(IntPredicate)"], "method_uris": ["src/main/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilter.java.LayeredBloomFilter.[]LayeredBloomFilter(Shape,LayerManager<T>)", "src/main/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilter.java.LayeredBloomFilter.[int]cardinality()", "src/main/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilter.java.LayeredBloomFilter.[int]characteristics()", "src/main/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilter.java.LayeredBloomFilter.[void]cleanup()", "src/main/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilter.java.LayeredBloomFilter.[void]clear()", "src/main/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilter.java.LayeredBloomFilter.[boolean]contains(BitMapExtractor)", "src/main/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilter.java.LayeredBloomFilter.[boolean]contains(BloomFilter)", "src/main/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilter.java.LayeredBloomFilter.[boolean]contains(BloomFilterExtractor)", "src/main/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilter.java.LayeredBloomFilter.[boolean]contains(Hasher)", "src/main/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilter.java.LayeredBloomFilter.[boolean]contains(IndexExtractor)", "src/main/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilter.java.LayeredBloomFilter.[LayeredBloomFilter<T>]copy()", "src/main/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilter.java.LayeredBloomFilter.[BloomFilter]createFilter(BitMapExtractor)", "src/main/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilter.java.LayeredBloomFilter.[BloomFilter]createFilter(Hasher)", "src/main/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilter.java.LayeredBloomFilter.[BloomFilter]createFilter(IndexExtractor)", "src/main/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilter.java.LayeredBloomFilter.[int]estimateN()", "src/main/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilter.java.LayeredBloomFilter.[int]estimateUnion(BloomFilter)", "src/main/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilter.java.LayeredBloomFilter.[int[]]find(BitMapExtractor)", "src/main/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilter.java.LayeredBloomFilter.[int[]]find(BloomFilter)", "src/main/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilter.java.LayeredBloomFilter.[int[]]find(Hasher)", "src/main/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilter.java.LayeredBloomFilter.[int[]]find(IndexExtractor)", "src/main/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilter.java.LayeredBloomFilter.[BloomFilter]flatten()", "src/main/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilter.java.LayeredBloomFilter.[T]get(int)", "src/main/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilter.java.LayeredBloomFilter.[int]getDepth()", "src/main/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilter.java.LayeredBloomFilter.[Shape]getShape()", "src/main/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilter.java.LayeredBloomFilter.[boolean]isEmpty()", "src/main/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilter.java.LayeredBloomFilter.[boolean]merge(BitMapExtractor)", "src/main/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilter.java.LayeredBloomFilter.[boolean]merge(BloomFilter)", "src/main/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilter.java.LayeredBloomFilter.[boolean]merge(IndexExtractor)", "src/main/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilter.java.LayeredBloomFilter.[void]next()", "src/main/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilter.java.LayeredBloomFilter.[boolean]processBitMaps(LongPredicate)", "src/main/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilter.java.LayeredBloomFilter.[boolean]processBloomFilters(Predicate<BloomFilter>)", "src/main/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilter.java.LayeredBloomFilter.[boolean]processIndices(IntPredicate)"], "overrides": null, "attributes": [{"original_string": "    private class Finder implements Predicate<BloomFilter> {\n        int[] result = new int[layerManager.getDepth()];\n        int bfIdx;\n        int resultIdx;\n        BloomFilter bf;\n\n        Finder(final BloomFilter bf) {\n            this.bf = bf;\n        }\n\n        int[] getResult() {\n            return Arrays.copyOf(result, resultIdx);\n        }\n\n        @Override\n        public boolean test(final BloomFilter x) {\n            if (x.contains(bf)) {\n                result[resultIdx++] = bfIdx;\n            }\n            bfIdx++;\n            return true;\n        }\n    }", "definition": "    private class Finder implements Predicate<BloomFilter>", "class_docstring": "\nA class used to locate matching filters across all the layers.\n", "name": "Finder", "super_interfaces": ["Predicate<BloomFilter>"], "superclasses": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "fields": [{"attribute_expression": "int[] result = new int[layerManager.getDepth()];", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int[]", "name": "result = new int[layerManager.getDepth()]", "syntax_pass": true}, {"attribute_expression": "int bfIdx;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int", "name": "bfIdx", "syntax_pass": true}, {"attribute_expression": "int resultIdx;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int", "name": "resultIdx", "syntax_pass": true}, {"attribute_expression": "BloomFilter bf;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "BloomFilter", "name": "bf", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        Finder(final BloomFilter bf) {\n            this.bf = bf;\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Finder", "params": [{"name": "bf", "type": "BloomFilter"}], "body": "                                     {\n            this.bf = bf;\n        }", "signature": "Finder(final BloomFilter bf)"}, {"syntax_pass": true, "original_string": "        int[] getResult() {\n            return Arrays.copyOf(result, resultIdx);\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "int[]", "classes": []}, "name": "getResult", "params": [], "body": "                          {\n            return Arrays.copyOf(result, resultIdx);\n        }", "signature": "int[] getResult()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean test(final BloomFilter x) {\n            if (x.contains(bf)) {\n                result[resultIdx++] = bfIdx;\n            }\n            bfIdx++;\n            return true;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "test", "params": [{"name": "x", "type": "BloomFilter"}], "body": "                                                 {\n            if (x.contains(bf)) {\n                result[resultIdx++] = bfIdx;\n            }\n            bfIdx++;\n            return true;\n        }", "signature": "@Override\n        public boolean test(final BloomFilter x)"}]}], "class_docstring": "\nLayered Bloom filters are described in Zhiwang, Cen; Jungang, Xu; Jian, Sun\n(2010), \"A multi-layer Bloom filter for duplicated URL detection\", Proc. 3rd\nInternational Conference on Advanced Computer Theory and Engineering (ICACTE\n2010), vol. 1, pp. V1-586-V1-591, doi:10.1109/ICACTE.2010.5578947, ISBN\n978-1-4244-6539-2, S2CID 3108985\n<p>\nIn short, Layered Bloom filter contains several bloom filters arranged in\nlayers.\n</p>\n<ul>\n<li>When membership in the filter is checked each layer in turn is checked\nand if a match is found {@code true} is returned.</li>\n<li>When merging each bloom filter is merged into the newest filter in the\nlist of layers.</li>\n<li>When questions of cardinality are asked the cardinality of the union of\nthe enclosed Bloom filters is used.</li>\n</ul>\n<p>\nThe net result is that the layered Bloom filter can be populated with more\nitems than the Shape would indicate and yet still return a false positive\nrate in line with the Shape and not the over population.\n</p>\n<p>\nThis implementation uses a LayerManager to handle the manipulation of the\nlayers.\n</p>\n<ul>\n<li>Level 0 is the oldest layer and the highest level is the newest.</li>\n<li>There is always at least one enclosed filter.</li>\n<li>The newest filter is the {@code target} into which merges are performed.\n<li>Whenever the target is retrieved, or a {@code merge} operation is\nperformed the code checks if any older layers should be removed, and if so\nremoves them. It also checks it a new layer should be added, and if so adds\nit and sets the {@code target} before the operation.</li>\n</ul>\n@param <T> The type of Bloom Filter that is used for the layers.\n@since 4.5.0\n", "original_string": "public class LayeredBloomFilter<T extends BloomFilter> implements BloomFilter, BloomFilterExtractor {\n    /**\n     * A class used to locate matching filters across all the layers.\n     */\n    private class Finder implements Predicate<BloomFilter> {\n        int[] result = new int[layerManager.getDepth()];\n        int bfIdx;\n        int resultIdx;\n        BloomFilter bf;\n\n        Finder(final BloomFilter bf) {\n            this.bf = bf;\n        }\n\n        int[] getResult() {\n            return Arrays.copyOf(result, resultIdx);\n        }\n\n        @Override\n        public boolean test(final BloomFilter x) {\n            if (x.contains(bf)) {\n                result[resultIdx++] = bfIdx;\n            }\n            bfIdx++;\n            return true;\n        }\n    }\n\n    private final Shape shape;\n\n    private final LayerManager<T> layerManager;\n\n    /**\n     * Constructor.\n     *\n     * @param shape        the Shape of the enclosed Bloom filters\n     * @param layerManager the LayerManager to manage the layers.\n     */\n    public LayeredBloomFilter(final Shape shape, final LayerManager<T> layerManager) {\n        this.shape = shape;\n        this.layerManager = layerManager;\n    }\n\n    @Override\n    public int cardinality() {\n        return SetOperations.cardinality(this);\n    }\n\n    @Override\n    public int characteristics() {\n        return 0;\n    }\n\n    /**\n     * Forces the execution of the cleanup Consumer that was provided when the associated LayerManager\n     * was built.\n     *\n     * @see LayerManager.Builder#setCleanup(java.util.function.Consumer)\n     */\n    public void cleanup() {\n        layerManager.cleanup();\n    }\n\n    @Override\n    public final void clear() {\n        layerManager.clear();\n    }\n\n    @Override\n    public boolean contains(final BitMapExtractor bitMapExtractor) {\n        return contains(createFilter(bitMapExtractor));\n    }\n\n    /**\n     * Returns {@code true} if this any layer contained by this filter contains the\n     * specified filter.\n     * <p>\n     * If the {@code other} is a BloomFilterExtractor each filter within the\n     * {@code other} is checked to see if it exits within this filter.\n     * </p>\n     *\n     * @param other the other Bloom filter\n     * @return {@code true} if this filter contains the other filter.\n     */\n    @Override\n    public boolean contains(final BloomFilter other) {\n        return other instanceof BloomFilterExtractor ? contains((BloomFilterExtractor) other)\n                : !processBloomFilters(x -> !x.contains(other));\n    }\n\n    /**\n     * Returns {@code true} if each filter within the {@code bloomFilterExtractor} exits within\n     * this filter.\n     *\n     * @param bloomFilterExtractor the BloomFilterExtractor that provides the filters to check\n     *                 for.\n     * @return {@code true} if this filter contains all of the filters contained in\n     *         the {@code bloomFilterExtractor}.\n     */\n    public boolean contains(final BloomFilterExtractor bloomFilterExtractor) {\n        final boolean[] result = { true };\n        // return false when we have found a match to short circuit checks\n        return bloomFilterExtractor.processBloomFilters(x -> {\n            result[0] &= contains(x);\n            return result[0];\n        });\n    }\n\n    @Override\n    public boolean contains(final Hasher hasher) {\n        return contains(createFilter(hasher));\n    }\n\n    @Override\n    public boolean contains(final IndexExtractor indexExtractor) {\n        return contains(createFilter(indexExtractor));\n    }\n\n    @Override\n    public LayeredBloomFilter<T> copy() {\n        return new LayeredBloomFilter<>(shape, layerManager.copy());\n    }\n\n    /**\n     * Creates a Bloom filter from a BitMapExtractor.\n     *\n     * @param bitMapExtractor the BitMapExtractor to create the filter from.\n     * @return the BloomFilter.\n     */\n    private BloomFilter createFilter(final BitMapExtractor bitMapExtractor) {\n        final SimpleBloomFilter bf = new SimpleBloomFilter(shape);\n        bf.merge(bitMapExtractor);\n        return bf;\n    }\n\n    /**\n     * Creates a Bloom filter from a Hasher.\n     *\n     * @param hasher the hasher to create the filter from.\n     * @return the BloomFilter.\n     */\n    private BloomFilter createFilter(final Hasher hasher) {\n        final SimpleBloomFilter bf = new SimpleBloomFilter(shape);\n        bf.merge(hasher);\n        return bf;\n    }\n\n    /**\n     * Creates a Bloom filter from an IndexExtractor.\n     *\n     * @param indexExtractor the IndexExtractor to create the filter from.\n     * @return the BloomFilter.\n     */\n    private BloomFilter createFilter(final IndexExtractor indexExtractor) {\n        final SimpleBloomFilter bf = new SimpleBloomFilter(shape);\n        bf.merge(indexExtractor);\n        return bf;\n    }\n\n    @Override\n    public int estimateN() {\n        return flatten().estimateN();\n    }\n\n    @Override\n    public int estimateUnion(final BloomFilter other) {\n        Objects.requireNonNull(other, \"other\");\n        final BloomFilter cpy = this.flatten();\n        cpy.merge(other);\n        return cpy.estimateN();\n    }\n\n    /**\n     * Finds the layers in which the BitMapExtractor is found.\n     *\n     * @param bitMapExtractor the BitMapExtractor to search for.\n     * @return an array of layer indices in which the Bloom filter is found.\n     */\n    public int[] find(final BitMapExtractor bitMapExtractor) {\n        final SimpleBloomFilter bf = new SimpleBloomFilter(shape);\n        bf.merge(bitMapExtractor);\n        return find(bf);\n    }\n\n    /**\n     * Finds the layers in which the Bloom filter is found.\n     *\n     * @param bf the Bloom filter to search for.\n     * @return an array of layer indices in which the Bloom filter is found.\n     */\n    public int[] find(final BloomFilter bf) {\n        final Finder finder = new Finder(bf);\n        processBloomFilters(finder);\n        return finder.getResult();\n    }\n\n    /**\n     * Finds the layers in which the Hasher is found.\n     *\n     * @param hasher the Hasher to search for.\n     * @return an array of layer indices in which the Bloom filter is found.\n     */\n    public int[] find(final Hasher hasher) {\n        final SimpleBloomFilter bf = new SimpleBloomFilter(shape);\n        bf.merge(hasher);\n        return find(bf);\n    }\n\n    /**\n     * Finds the layers in which the IndexExtractor is found.\n     *\n     * @param indexExtractor the Index extractor to search for.\n     * @return an array of layer indices in which the Bloom filter is found.\n     */\n    public int[] find(final IndexExtractor indexExtractor) {\n        final SimpleBloomFilter bf = new SimpleBloomFilter(shape);\n        bf.merge(indexExtractor);\n        return find(bf);\n    }\n\n    /**\n     * Create a standard (non-layered) Bloom filter by merging all of the layers. If\n     * the filter is empty this method will return an empty Bloom filter.\n     *\n     * @return the merged bloom filter.\n     */\n    @Override\n    public BloomFilter flatten() {\n        final BloomFilter bf = new SimpleBloomFilter(shape);\n        processBloomFilters(bf::merge);\n        return bf;\n    }\n\n    /**\n     * Gets the Bloom filter at the specified depth\n     *\n     * @param depth the depth of the filter to return.\n     * @return the Bloom filter at the specified depth.\n     * @throws NoSuchElementException if depth is not in the range [0,getDepth())\n     */\n    public T get(final int depth) {\n        return layerManager.get(depth);\n    }\n\n    /**\n     * Gets the depth of the deepest layer. The minimum value returned by this\n     * method is 1.\n     *\n     * @return the depth of the deepest layer.\n     */\n    public final int getDepth() {\n        return layerManager.getDepth();\n    }\n\n    @Override\n    public final Shape getShape() {\n        return shape;\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return processBloomFilters(BloomFilter::isEmpty);\n    }\n\n    @Override\n    public boolean merge(final BitMapExtractor bitMapExtractor) {\n        return layerManager.getTarget().merge(bitMapExtractor);\n    }\n\n    @Override\n    public boolean merge(final BloomFilter bf) {\n        return layerManager.getTarget().merge(bf);\n    }\n\n    @Override\n    public boolean merge(final IndexExtractor indexExtractor) {\n        return layerManager.getTarget().merge(indexExtractor);\n    }\n\n    /**\n     * Forces and advance to the next layer. This method will clean-up the current\n     * layers and generate a new filter layer. In most cases is it unnecessary to\n     * call this method directly.\n     *\n     * @see LayerManager.Builder#setCleanup(java.util.function.Consumer)\n     * @see LayerManager.Builder#setExtendCheck(Predicate)\n     */\n    public void next() {\n        layerManager.next();\n    }\n\n    @Override\n    public boolean processBitMaps(final LongPredicate predicate) {\n        return flatten().processBitMaps(predicate);\n    }\n\n    /**\n     * Processes the Bloom filters in depth order with the most recent filters\n     * first. Each filter is passed to the predicate in turn. The function exits on\n     * the first {@code false} returned by the predicate.\n     *\n     * @param bloomFilterPredicate the predicate to execute.\n     * @return {@code true} if all filters passed the predicate, {@code false}\n     *         otherwise.\n     */\n    @Override\n    public final boolean processBloomFilters(final Predicate<BloomFilter> bloomFilterPredicate) {\n        return layerManager.processBloomFilters(bloomFilterPredicate);\n    }\n\n    @Override\n    public boolean processIndices(final IntPredicate predicate) {\n        return processBloomFilters(bf -> bf.processIndices(predicate));\n    }\n\n}", "super_interfaces": ["BloomFilter", "BloomFilterExtractor"], "fields": [{"attribute_expression": "private final Shape shape;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Shape", "name": "shape", "syntax_pass": true}, {"attribute_expression": "private final LayerManager<T> layerManager;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "LayerManager<T>", "name": "layerManager", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/bloomfilter/BitMaps.java.BitMaps", "name": "BitMaps", "file_path": "src/main/java/org/apache/commons/collections4/bloomfilter/BitMaps.java", "superclasses": "", "methods": ["[boolean]contains(long[],int)", "[long]getLongBit(int)", "[int]getLongIndex(int)", "[int]mod(long,int)", "[int]numberOfBitMaps(int)", "[void]set(long[],int)", "[]BitMaps()"], "method_uris": ["src/main/java/org/apache/commons/collections4/bloomfilter/BitMaps.java.BitMaps.[boolean]contains(long[],int)", "src/main/java/org/apache/commons/collections4/bloomfilter/BitMaps.java.BitMaps.[long]getLongBit(int)", "src/main/java/org/apache/commons/collections4/bloomfilter/BitMaps.java.BitMaps.[int]getLongIndex(int)", "src/main/java/org/apache/commons/collections4/bloomfilter/BitMaps.java.BitMaps.[int]mod(long,int)", "src/main/java/org/apache/commons/collections4/bloomfilter/BitMaps.java.BitMaps.[int]numberOfBitMaps(int)", "src/main/java/org/apache/commons/collections4/bloomfilter/BitMaps.java.BitMaps.[void]set(long[],int)", "src/main/java/org/apache/commons/collections4/bloomfilter/BitMaps.java.BitMaps.[]BitMaps()"], "overrides": null, "attributes": [], "class_docstring": "\nContains functions to convert {@code int} indices into Bloom filter bit positions and visa versa.\n\n<p>The functions view an array of longs as a collection of bit maps each containing 64 bits. The bits are arranged\nin memory as a little-endian long value. This matches the requirements of the BitMapExtractor interface.</p>\n\n@since 4.5.0\n", "original_string": "public class BitMaps {\n    /** A bit shift to apply to an integer to divided by 64 (2^6). */\n    private static final int DIVIDE_BY_64 = 6;\n\n    /**\n     * Checks if the specified index bit is enabled in the array of bit maps.\n     *\n     * If the bit specified by bitIndex is not in the bit map false is returned.\n     *\n     * @param bitMaps  The array of bit maps.\n     * @param bitIndex the index of the bit to locate.\n     * @return {@code true} if the bit is enabled, {@code false} otherwise.\n     * @throws IndexOutOfBoundsException if bitIndex specifies a bit not in the range being tracked.\n     */\n    public static boolean contains(final long[] bitMaps, final int bitIndex) {\n        return (bitMaps[getLongIndex(bitIndex)] & getLongBit(bitIndex)) != 0;\n    }\n\n    /**\n     * Gets the filter bit mask for the specified bit index assuming the filter is using 64-bit\n     * longs to store bits starting at index 0. The returned value is a {@code long} with only\n     * 1 bit set.\n     *\n     * <p>The index is assumed to be positive. For a positive index the result will match\n     * {@code 1L << (bitIndex % 64)}.</p>\n     *\n     * <p><em>If the input is negative the behavior is not defined.</em></p>\n     *\n     * @param bitIndex the bit index (assumed to be positive)\n     * @return the filter bit\n     */\n    public static long getLongBit(final int bitIndex) {\n        // Bit shifts only use the first 6 bits. Thus it is not necessary to mask this\n        // using 0x3f (63) or compute bitIndex % 64.\n        // Note: If the index is negative the shift will be (64 - (bitIndex & 0x3f)) and\n        // this will identify an incorrect bit.\n        return 1L << bitIndex;\n    }\n\n    /**\n     * Gets the filter index for the specified bit index assuming the filter is using 64-bit longs\n     * to store bits starting at index 0.\n     *\n     * <p>The index is assumed to be positive. For a positive index the result will match\n     * {@code bitIndex / 64}.</p>\n     *\n     * <p><em>The divide is performed using bit shifts. If the input is negative the behavior\n     * is not defined.</em></p>\n     *\n     * @param bitIndex the bit index (assumed to be positive)\n     * @return the index of the bit map in an array of bit maps.\n     */\n    public static int getLongIndex(final int bitIndex) {\n        // An integer divide by 64 is equivalent to a shift of 6 bits if the integer is\n        // positive.\n        // We do not explicitly check for a negative here. Instead we use a\n        // signed shift. Any negative index will produce a negative value\n        // by sign-extension and if used as an index into an array it will throw an\n        // exception.\n        return bitIndex >> DIVIDE_BY_64;\n    }\n\n    /**\n     * Performs a modulus calculation on an unsigned long and a positive integer divisor.\n     *\n     * <p>This method computes the same result as {@link Long#remainderUnsigned(long, long)}\n     * but assumes that the divisor is an integer in the range 1 to 2<sup>31</sup> - 1 inclusive,\n     * that is a strictly positive integer size.\n     *\n     * <p><em>If the divisor is negative the behavior is not defined.</em></p>\n     *\n     * @param dividend an unsigned long value to calculate the modulus of.\n     * @param divisor the divisor for the modulus calculation, must be strictly positive.\n     * @return the remainder or modulus value.\n     * @throws ArithmeticException if the divisor is zero\n     * @see Long#remainderUnsigned(long, long)\n     */\n    public static int mod(final long dividend, final int divisor) {\n        // See Hacker's Delight (2nd ed), section 9.3.\n        // Assume divisor is positive.\n        // Divide half the unsigned number and then double the quotient result.\n        final long quotient = (dividend >>> 1) / divisor << 1;\n        final long remainder = dividend - quotient * divisor;\n        // remainder in [0, 2 * divisor)\n        return (int) (remainder >= divisor ? remainder - divisor : remainder);\n    }\n\n    /**\n     * Calculates the number of bit maps (longs) required for the numberOfBits parameter.\n     *\n     * <p><em>If the input is negative the behavior is not defined.</em></p>\n     *\n     * @param numberOfBits the number of bits to store in the array of bit maps.\n     * @return the number of bit maps necessary.\n     */\n    public static int numberOfBitMaps(final int numberOfBits) {\n        return (numberOfBits - 1 >> DIVIDE_BY_64) + 1;\n    }\n\n    /**\n     * Sets the bit in the bit maps.\n     * <p><em>Does not perform range checking</em></p>\n     *\n     * @param bitMaps  The array of bit maps.\n     * @param bitIndex the index of the bit to set.\n     * @throws IndexOutOfBoundsException if bitIndex specifies a bit not in the range being tracked.\n     */\n    public static void set(final long[] bitMaps, final int bitIndex) {\n        bitMaps[getLongIndex(bitIndex)] |= getLongBit(bitIndex);\n    }\n\n    /** Do not instantiate. */\n    private BitMaps() {\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final int DIVIDE_BY_64 = 6;", "docstring": " A bit shift to apply to an integer to divided by 64 (2^6).", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "int", "name": "DIVIDE_BY_64 = 6", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/bloomfilter/ArrayCountingBloomFilter.java.ArrayCountingBloomFilter", "name": "ArrayCountingBloomFilter", "file_path": "src/main/java/org/apache/commons/collections4/bloomfilter/ArrayCountingBloomFilter.java", "superclasses": "", "methods": ["[]ArrayCountingBloomFilter(ArrayCountingBloomFilter)", "[]ArrayCountingBloomFilter(Shape)", "[boolean]add(CellExtractor)", "[boolean]add(int,int)", "[int[]]asIndexArray()", "[int]cardinality()", "[int]characteristics()", "[void]clear()", "[boolean]contains(BitMapExtractor)", "[boolean]contains(IndexExtractor)", "[ArrayCountingBloomFilter]copy()", "[int]getMaxCell()", "[int]getMaxInsert(CellExtractor)", "[Shape]getShape()", "[boolean]isValid()", "[boolean]processBitMaps(LongPredicate)", "[boolean]processCells(CellPredicate)", "[boolean]processIndices(IntPredicate)", "[boolean]subtract(CellExtractor)", "[boolean]subtract(int,int)"], "method_uris": ["src/main/java/org/apache/commons/collections4/bloomfilter/ArrayCountingBloomFilter.java.ArrayCountingBloomFilter.[]ArrayCountingBloomFilter(ArrayCountingBloomFilter)", "src/main/java/org/apache/commons/collections4/bloomfilter/ArrayCountingBloomFilter.java.ArrayCountingBloomFilter.[]ArrayCountingBloomFilter(Shape)", "src/main/java/org/apache/commons/collections4/bloomfilter/ArrayCountingBloomFilter.java.ArrayCountingBloomFilter.[boolean]add(CellExtractor)", "src/main/java/org/apache/commons/collections4/bloomfilter/ArrayCountingBloomFilter.java.ArrayCountingBloomFilter.[boolean]add(int,int)", "src/main/java/org/apache/commons/collections4/bloomfilter/ArrayCountingBloomFilter.java.ArrayCountingBloomFilter.[int[]]asIndexArray()", "src/main/java/org/apache/commons/collections4/bloomfilter/ArrayCountingBloomFilter.java.ArrayCountingBloomFilter.[int]cardinality()", "src/main/java/org/apache/commons/collections4/bloomfilter/ArrayCountingBloomFilter.java.ArrayCountingBloomFilter.[int]characteristics()", "src/main/java/org/apache/commons/collections4/bloomfilter/ArrayCountingBloomFilter.java.ArrayCountingBloomFilter.[void]clear()", "src/main/java/org/apache/commons/collections4/bloomfilter/ArrayCountingBloomFilter.java.ArrayCountingBloomFilter.[boolean]contains(BitMapExtractor)", "src/main/java/org/apache/commons/collections4/bloomfilter/ArrayCountingBloomFilter.java.ArrayCountingBloomFilter.[boolean]contains(IndexExtractor)", "src/main/java/org/apache/commons/collections4/bloomfilter/ArrayCountingBloomFilter.java.ArrayCountingBloomFilter.[ArrayCountingBloomFilter]copy()", "src/main/java/org/apache/commons/collections4/bloomfilter/ArrayCountingBloomFilter.java.ArrayCountingBloomFilter.[int]getMaxCell()", "src/main/java/org/apache/commons/collections4/bloomfilter/ArrayCountingBloomFilter.java.ArrayCountingBloomFilter.[int]getMaxInsert(CellExtractor)", "src/main/java/org/apache/commons/collections4/bloomfilter/ArrayCountingBloomFilter.java.ArrayCountingBloomFilter.[Shape]getShape()", "src/main/java/org/apache/commons/collections4/bloomfilter/ArrayCountingBloomFilter.java.ArrayCountingBloomFilter.[boolean]isValid()", "src/main/java/org/apache/commons/collections4/bloomfilter/ArrayCountingBloomFilter.java.ArrayCountingBloomFilter.[boolean]processBitMaps(LongPredicate)", "src/main/java/org/apache/commons/collections4/bloomfilter/ArrayCountingBloomFilter.java.ArrayCountingBloomFilter.[boolean]processCells(CellPredicate)", "src/main/java/org/apache/commons/collections4/bloomfilter/ArrayCountingBloomFilter.java.ArrayCountingBloomFilter.[boolean]processIndices(IntPredicate)", "src/main/java/org/apache/commons/collections4/bloomfilter/ArrayCountingBloomFilter.java.ArrayCountingBloomFilter.[boolean]subtract(CellExtractor)", "src/main/java/org/apache/commons/collections4/bloomfilter/ArrayCountingBloomFilter.java.ArrayCountingBloomFilter.[boolean]subtract(int,int)"], "overrides": null, "attributes": [], "class_docstring": "\nA counting Bloom filter using an int array to track cells for each enabled bit.\n\n<p>Any operation that results in negative counts or integer overflow of\ncounts will mark this filter as invalid. This transition is not reversible.\nThe operation is completed in full, no exception is raised and the state is\nset to invalid. This allows the cells for the filter immediately prior to the\noperation that created the invalid state to be recovered. See the documentation\nin {@link #isValid()} for details.</p>\n\n<p>All the operations in the filter assume the cells are currently valid,\nfor example {@code cardinality} or {@code contains} operations. Behavior of an invalid\nfilter is undefined. It will no longer function identically to a standard\nBloom filter that is the merge of all the Bloom filters that have been added\nto and not later subtracted from the counting Bloom filter.</p>\n\n<p>The maximum supported number of items that can be stored in the filter is\nlimited by the maximum array size combined with the {@link Shape}. For\nexample an implementation using a {@link Shape} with a false-positive\nprobability of 1e-6 and {@link Integer#MAX_VALUE} bits can reversibly store\napproximately 75 million items using 20 hash functions per item with a memory\nconsumption of approximately 8 GB.\n\n@see Shape\n@see CellExtractor\n@since 4.5.0\n", "original_string": "public final class ArrayCountingBloomFilter implements CountingBloomFilter {\n\n    /**\n     * The shape of this Bloom filter.\n     */\n    private final Shape shape;\n\n    /**\n     * The cell for each bit index in the filter.\n     */\n    private final int[] cells;\n\n    /**\n     * The state flag. This is a bitwise {@code OR} of the entire history of all updated\n     * cells. If negative then a negative cell or integer overflow has occurred on\n     * one or more cells in the history of the filter and the state is invalid.\n     *\n     * <p>Maintenance of this state flag is branch-free for improved performance. It\n     * eliminates a conditional check for a negative cell during remove/subtract\n     * operations and a conditional check for integer overflow during merge/add\n     * operations.</p>\n     *\n     * <p>Note: Integer overflow is unlikely in realistic usage scenarios. A cell\n     * that overflows indicates that the number of items in the filter exceeds the\n     * maximum possible size (number of bits) of any Bloom filter constrained by\n     * integer indices. At this point the filter is most likely full (all bits are\n     * non-zero) and thus useless.</p>\n     *\n     * <p>Negative cells are a concern if the filter is used incorrectly by\n     * removing an item that was never added. It is expected that a user of a\n     * counting Bloom filter will not perform this action as it is a mistake.\n     * Enabling an explicit recovery path for negative or overflow cells is a major\n     * performance burden not deemed necessary for the unlikely scenarios when an\n     * invalid state is created. Maintenance of the state flag is a concession to\n     * flag improper use that should not have a major performance impact.</p>\n     */\n    private int state;\n\n    private ArrayCountingBloomFilter(final ArrayCountingBloomFilter source) {\n        this.shape = source.shape;\n        this.state = source.state;\n        this.cells = source.cells.clone();\n    }\n\n    /**\n     * Constructs an empty counting Bloom filter with the specified shape.\n     *\n     * @param shape the shape of the filter\n     */\n    public ArrayCountingBloomFilter(final Shape shape) {\n        Objects.requireNonNull(shape, \"shape\");\n        this.shape = shape;\n        cells = new int[shape.getNumberOfBits()];\n    }\n\n    @Override\n    public boolean add(final CellExtractor other) {\n        Objects.requireNonNull(other, \"other\");\n        other.processCells(this::add);\n        return isValid();\n    }\n\n    /**\n     * Add to the cell for the bit index.\n     *\n     * @param idx the index\n     * @param addend the amount to add\n     * @return {@code true} always.\n     */\n    private boolean add(final int idx, final int addend) {\n        try {\n            final int updated = cells[idx] + addend;\n            state |= updated;\n            cells[idx] = updated;\n            return true;\n        } catch (final IndexOutOfBoundsException e) {\n            throw new IllegalArgumentException(\n                    String.format(\"Filter only accepts values in the [0,%d) range\", getShape().getNumberOfBits()), e);\n        }\n    }\n\n    @Override\n    public int[] asIndexArray() {\n        return IntStream.range(0, cells.length).filter(i -> cells[i] > 0).toArray();\n    }\n\n    @Override\n    public int cardinality() {\n        return (int) IntStream.range(0, cells.length).filter(i -> cells[i] > 0).count();\n    }\n\n    @Override\n    public int characteristics() {\n        return SPARSE;\n    }\n\n    @Override\n    public void clear() {\n        Arrays.fill(cells, 0);\n    }\n\n    @Override\n    public boolean contains(final BitMapExtractor bitMapExtractor) {\n        return contains(IndexExtractor.fromBitMapExtractor(bitMapExtractor));\n    }\n\n    @Override\n    public boolean contains(final IndexExtractor indexExtractor) {\n        return indexExtractor.processIndices(idx -> cells[idx] != 0);\n    }\n\n    @Override\n    public ArrayCountingBloomFilter copy() {\n        return new ArrayCountingBloomFilter(this);\n    }\n\n    @Override\n    public int getMaxCell() {\n        return Integer.MAX_VALUE;\n    }\n\n    @Override\n    public int getMaxInsert(final CellExtractor cellExtractor) {\n        final int[] max = {Integer.MAX_VALUE};\n        cellExtractor.processCells( (x, y) -> {\n            final int count = cells[x] / y;\n            if (count < max[0]) {\n                max[0] = count;\n            }\n            return max[0] > 0;\n        });\n        return max[0];\n    }\n\n    @Override\n    public Shape getShape() {\n        return shape;\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * <p><em>Implementation note</em>\n     *\n     * <p>The state transition to invalid is permanent.</p>\n     *\n     * <p>This implementation does not correct negative cells to zero or integer\n     * overflow cells to {@link Integer#MAX_VALUE}. Thus the operation that\n     * generated invalid cells can be reversed by using the complement of the\n     * original operation with the same Bloom filter. This will restore the cells\n     * to the state prior to the invalid operation. Cells can then be extracted\n     * using {@link #processCells(CellPredicate)}.</p>\n     */\n    @Override\n    public boolean isValid() {\n        return state >= 0;\n    }\n\n    @Override\n    public boolean processBitMaps(final LongPredicate consumer) {\n        Objects.requireNonNull(consumer, \"consumer\");\n        final int blocksm1 = BitMaps.numberOfBitMaps(cells.length) - 1;\n        int i = 0;\n        long value;\n        // must break final block separate as the number of bits may not fall on the long boundary\n        for (int j = 0; j < blocksm1; j++) {\n            value = 0;\n            for (int k = 0; k < Long.SIZE; k++) {\n                if (cells[i++] != 0) {\n                    value |= BitMaps.getLongBit(k);\n                }\n            }\n            if (!consumer.test(value)) {\n                return false;\n            }\n        }\n        // Final block\n        value = 0;\n        for (int k = 0; i < cells.length; k++) {\n            if (cells[i++] != 0) {\n                value |= BitMaps.getLongBit(k);\n            }\n        }\n        return consumer.test(value);\n    }\n\n    @Override\n    public boolean processCells(final CellPredicate consumer) {\n        Objects.requireNonNull(consumer, \"consumer\");\n        for (int i = 0; i < cells.length; i++) {\n            if (cells[i] != 0 && !consumer.test(i, cells[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    @Override\n    public boolean processIndices(final IntPredicate consumer) {\n        Objects.requireNonNull(consumer, \"consumer\");\n        for (int i = 0; i < cells.length; i++) {\n            if (cells[i] != 0 && !consumer.test(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    @Override\n    public boolean subtract(final CellExtractor other) {\n        Objects.requireNonNull(other, \"other\");\n        other.processCells(this::subtract);\n        return isValid();\n    }\n\n    /**\n     * Subtract from the cell for the bit index.\n     *\n     * @param idx the index\n     * @param subtrahend the amount to subtract\n     * @return {@code true} always.\n     */\n    private boolean subtract(final int idx, final int subtrahend) {\n        try {\n            final int updated = cells[idx] - subtrahend;\n            state |= updated;\n            cells[idx] = updated;\n            return true;\n        } catch (final IndexOutOfBoundsException e) {\n            throw new IllegalArgumentException(\n                    String.format(\"Filter only accepts values in the [0,%d) range\", getShape().getNumberOfBits()), e);\n        }\n    }\n}", "super_interfaces": ["CountingBloomFilter"], "fields": [{"attribute_expression": "private final Shape shape;", "docstring": "\nThe shape of this Bloom filter.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Shape", "name": "shape", "syntax_pass": true}, {"attribute_expression": "private final int[] cells;", "docstring": "\nThe cell for each bit index in the filter.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int[]", "name": "cells", "syntax_pass": true}, {"attribute_expression": "private int state;", "docstring": "\nThe state flag. This is a bitwise {@code OR} of the entire history of all updated\ncells. If negative then a negative cell or integer overflow has occurred on\none or more cells in the history of the filter and the state is invalid.\n\n<p>Maintenance of this state flag is branch-free for improved performance. It\neliminates a conditional check for a negative cell during remove/subtract\noperations and a conditional check for integer overflow during merge/add\noperations.</p>\n\n<p>Note: Integer overflow is unlikely in realistic usage scenarios. A cell\nthat overflows indicates that the number of items in the filter exceeds the\nmaximum possible size (number of bits) of any Bloom filter constrained by\ninteger indices. At this point the filter is most likely full (all bits are\nnon-zero) and thus useless.</p>\n\n<p>Negative cells are a concern if the filter is used incorrectly by\nremoving an item that was never added. It is expected that a user of a\ncounting Bloom filter will not perform this action as it is a mistake.\nEnabling an explicit recovery path for negative or overflow cells is a major\nperformance burden not deemed necessary for the unlikely scenarios when an\ninvalid state is created. Maintenance of the state flag is a concession to\nflag improper use that should not have a major performance impact.</p>\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "state", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/bloomfilter/IndexUtils.java.IndexUtils", "name": "IndexUtils", "file_path": "src/main/java/org/apache/commons/collections4/bloomfilter/IndexUtils.java", "superclasses": "", "methods": ["[int[]]ensureCapacityForAdd(int[],int)", "[]IndexUtils()"], "method_uris": ["src/main/java/org/apache/commons/collections4/bloomfilter/IndexUtils.java.IndexUtils.[int[]]ensureCapacityForAdd(int[],int)", "src/main/java/org/apache/commons/collections4/bloomfilter/IndexUtils.java.IndexUtils.[]IndexUtils()"], "overrides": null, "attributes": [], "class_docstring": "\nProvides functions to assist in IndexExtractor creation and manipulation.\n@see IndexExtractor\n", "original_string": "final class IndexUtils {\n\n    /**\n     * The maximum array size for the methods in this class.\n     */\n    static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n\n    /**\n     * Ensure the array can add an element at the specified index.\n     * @param array the array to check.\n     * @param index the index to add at.\n     * @return the array or a newly allocated copy of the array.\n     */\n    static int[] ensureCapacityForAdd(final int[] array, final int index) {\n        if (index >= array.length) {\n            return Arrays.copyOf(array, (int) Math.min(MAX_ARRAY_SIZE, Math.max(array.length * 2L, index + 1)));\n        }\n        return array;\n    }\n\n    /**\n     *  Don't instantiate.\n     */\n    private IndexUtils() {\n        // empty\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;", "docstring": "\nThe maximum array size for the methods in this class.\n", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "int", "name": "MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/bloomfilter/CountingLongPredicate.java.CountingLongPredicate", "name": "CountingLongPredicate", "file_path": "src/main/java/org/apache/commons/collections4/bloomfilter/CountingLongPredicate.java", "superclasses": "", "methods": ["[]CountingLongPredicate(long[],LongBiPredicate)", "[boolean]processRemaining()", "[boolean]test(long)"], "method_uris": ["src/main/java/org/apache/commons/collections4/bloomfilter/CountingLongPredicate.java.CountingLongPredicate.[]CountingLongPredicate(long[],LongBiPredicate)", "src/main/java/org/apache/commons/collections4/bloomfilter/CountingLongPredicate.java.CountingLongPredicate.[boolean]processRemaining()", "src/main/java/org/apache/commons/collections4/bloomfilter/CountingLongPredicate.java.CountingLongPredicate.[boolean]test(long)"], "overrides": null, "attributes": [], "class_docstring": "\nA long predicate that applies the test func to each member of the {@code ary} in sequence for each call to {@code test()}.\nif the {@code ary} is exhausted, the subsequent calls to {@code test} are executed with a zero value.\nIf the calls to {@code test} do not exhaust the {@code ary} the {@code processRemaining} method can be called to\nexecute the @{code test} with a zero value for each remaining {@code idx} value.\n@since 4.5.0\n", "original_string": "class CountingLongPredicate implements LongPredicate {\n    private int idx;\n    private final long[] ary;\n    private final LongBiPredicate func;\n\n    /**\n     * Constructs an instance that will compare the elements in {@code ary} with the elements returned by {@code func}.\n     * function is called as {@code func.test( idxValue, otherValue )}. If there are more {@code otherValue} values than\n     * {@code idxValues} then {@code func} is called as {@code func.test( 0, otherValue )}.\n     * @param ary The array of long values to compare.\n     * @param func The function to apply to the pairs of long values.\n     */\n    CountingLongPredicate(final long[] ary, final LongBiPredicate func) {\n        this.ary = ary;\n        this.func = func;\n    }\n\n    /**\n     * Call the long-long consuming bi-predicate for each remaining unpaired long in\n     * the input array. This method should be invoked after the predicate has been\n     * passed to {@link BitMapExtractor#processBitMaps(LongPredicate)} to consume any\n     * unpaired bitmaps. The second argument to the bi-predicate will be zero.\n     *\n     * @return true if all calls to the predicate were successful\n     */\n    boolean processRemaining() {\n        // uses local references for optimization benefit.\n        int i = idx;\n        final long[] a = ary;\n        final int limit = a.length;\n        while (i != limit && func.test(a[i], 0)) {\n            i++;\n        }\n        return i == limit;\n    }\n\n    @Override\n    public boolean test(final long other) {\n        return func.test(idx == ary.length ? 0 : ary[idx++], other);\n    }\n}", "super_interfaces": ["LongPredicate"], "fields": [{"attribute_expression": "private int idx;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "idx", "syntax_pass": true}, {"attribute_expression": "private final long[] ary;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "long[]", "name": "ary", "syntax_pass": true}, {"attribute_expression": "private final LongBiPredicate func;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "LongBiPredicate", "name": "func", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/bloomfilter/LayerManager.java.LayerManager", "name": "LayerManager", "file_path": "src/main/java/org/apache/commons/collections4/bloomfilter/LayerManager.java", "superclasses": "", "methods": ["[Builder<T>]builder()", "[]LayerManager(Supplier<T>,Predicate<LayerManager<T>>,Consumer<Deque<T>>,boolean)", "[void]addFilter()", "[void]cleanup()", "[void]clear()", "[LayerManager<T>]copy()", "[T]first()", "[T]get(int)", "[int]getDepth()", "[T]getTarget()", "[T]last()", "[void]next()", "[boolean]processBloomFilters(Predicate<BloomFilter>)"], "method_uris": ["src/main/java/org/apache/commons/collections4/bloomfilter/LayerManager.java.LayerManager.[Builder<T>]builder()", "src/main/java/org/apache/commons/collections4/bloomfilter/LayerManager.java.LayerManager.[]LayerManager(Supplier<T>,Predicate<LayerManager<T>>,Consumer<Deque<T>>,boolean)", "src/main/java/org/apache/commons/collections4/bloomfilter/LayerManager.java.LayerManager.[void]addFilter()", "src/main/java/org/apache/commons/collections4/bloomfilter/LayerManager.java.LayerManager.[void]cleanup()", "src/main/java/org/apache/commons/collections4/bloomfilter/LayerManager.java.LayerManager.[void]clear()", "src/main/java/org/apache/commons/collections4/bloomfilter/LayerManager.java.LayerManager.[LayerManager<T>]copy()", "src/main/java/org/apache/commons/collections4/bloomfilter/LayerManager.java.LayerManager.[T]first()", "src/main/java/org/apache/commons/collections4/bloomfilter/LayerManager.java.LayerManager.[T]get(int)", "src/main/java/org/apache/commons/collections4/bloomfilter/LayerManager.java.LayerManager.[int]getDepth()", "src/main/java/org/apache/commons/collections4/bloomfilter/LayerManager.java.LayerManager.[T]getTarget()", "src/main/java/org/apache/commons/collections4/bloomfilter/LayerManager.java.LayerManager.[T]last()", "src/main/java/org/apache/commons/collections4/bloomfilter/LayerManager.java.LayerManager.[void]next()", "src/main/java/org/apache/commons/collections4/bloomfilter/LayerManager.java.LayerManager.[boolean]processBloomFilters(Predicate<BloomFilter>)"], "overrides": null, "attributes": [{"original_string": "    public static class Builder<T extends BloomFilter> implements Supplier<LayerManager<T>> {\n\n        private Predicate<LayerManager<T>> extendCheck;\n        private Supplier<T> supplier;\n        private Consumer<Deque<T>> cleanup;\n\n        private Builder() {\n            extendCheck = ExtendCheck.neverAdvance();\n            cleanup = Cleanup.noCleanup();\n        }\n\n        /**\n         * Builds the layer manager with the specified properties.\n         *\n         * @return a new LayerManager.\n         */\n        @Override\n        public LayerManager<T> get() {\n            return new LayerManager<>(supplier, extendCheck, cleanup, true);\n        }\n\n        /**\n         * Sets the Consumer that cleans the list of Bloom filters.\n         *\n         * @param cleanup the Consumer that will modify the list of filters removing out\n         *                dated or stale filters.\n         * @return {@code this} instance.\n         */\n        public Builder<T> setCleanup(final Consumer<Deque<T>> cleanup) {\n            this.cleanup = cleanup;\n            return this;\n        }\n\n        /**\n         * Sets the extendCheck predicate. When the predicate returns {@code true} a new\n         * target will be created.\n         *\n         * @param extendCheck The predicate to determine if a new target should be\n         *                    created.\n         * @return {@code this} instance.\n         */\n        public Builder<T> setExtendCheck(final Predicate<LayerManager<T>> extendCheck) {\n            this.extendCheck = extendCheck;\n            return this;\n        }\n\n        /**\n         * Sets the supplier of Bloom filters. When extendCheck creates a new target,\n         * the supplier provides the instance of the Bloom filter.\n         *\n         * @param supplier The supplier of new Bloom filter instances.\n         * @return {@code this} instance.\n         */\n        public Builder<T> setSupplier(final Supplier<T> supplier) {\n            this.supplier = supplier;\n            return this;\n        }\n    }", "definition": "    public static class Builder<T extends BloomFilter> implements Supplier<LayerManager<T>>", "class_docstring": "\nBuilds new instances of {@link LayerManager}.\n\n@param <T> the {@link BloomFilter} type.\n", "name": "Builder", "super_interfaces": ["Supplier<LayerManager<T>>"], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "private Predicate<LayerManager<T>> extendCheck;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Predicate<LayerManager<T>>", "name": "extendCheck", "syntax_pass": true}, {"attribute_expression": "private Supplier<T> supplier;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Supplier<T>", "name": "supplier", "syntax_pass": true}, {"attribute_expression": "private Consumer<Deque<T>> cleanup;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Consumer<Deque<T>>", "name": "cleanup", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        private Builder() {\n            extendCheck = ExtendCheck.neverAdvance();\n            cleanup = Cleanup.noCleanup();\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "Builder", "params": [], "body": "                          {\n            extendCheck = ExtendCheck.neverAdvance();\n            cleanup = Cleanup.noCleanup();\n        }", "signature": "private Builder()"}, {"syntax_pass": true, "original_string": "        @Override\n        public LayerManager<T> get() {\n            return new LayerManager<>(supplier, extendCheck, cleanup, true);\n        }", "docstring": "\nBuilds the layer manager with the specified properties.\n\n@return a new LayerManager.\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "LayerManager<T>", "classes": []}, "name": "get", "params": [], "body": "                                     {\n            return new LayerManager<>(supplier, extendCheck, cleanup, true);\n        }", "signature": "@Override\n        public LayerManager<T> get()"}, {"syntax_pass": true, "original_string": "        public Builder<T> setCleanup(final Consumer<Deque<T>> cleanup) {\n            this.cleanup = cleanup;\n            return this;\n        }", "docstring": "\nSets the Consumer that cleans the list of Bloom filters.\n\n@param cleanup the Consumer that will modify the list of filters removing out\n               dated or stale filters.\n@return {@code this} instance.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder<T>", "classes": []}, "name": "setCleanup", "params": [{"name": "cleanup", "type": "Consumer<Deque<T>>"}], "body": "                                                                       {\n            this.cleanup = cleanup;\n            return this;\n        }", "signature": "public Builder<T> setCleanup(final Consumer<Deque<T>> cleanup)"}, {"syntax_pass": true, "original_string": "        public Builder<T> setExtendCheck(final Predicate<LayerManager<T>> extendCheck) {\n            this.extendCheck = extendCheck;\n            return this;\n        }", "docstring": "\nSets the extendCheck predicate. When the predicate returns {@code true} a new\ntarget will be created.\n\n@param extendCheck The predicate to determine if a new target should be\n                   created.\n@return {@code this} instance.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder<T>", "classes": []}, "name": "setExtendCheck", "params": [{"name": "extendCheck", "type": "Predicate<LayerManager<T>>"}], "body": "                                                                                       {\n            this.extendCheck = extendCheck;\n            return this;\n        }", "signature": "public Builder<T> setExtendCheck(final Predicate<LayerManager<T>> extendCheck)"}, {"syntax_pass": true, "original_string": "        public Builder<T> setSupplier(final Supplier<T> supplier) {\n            this.supplier = supplier;\n            return this;\n        }", "docstring": "\nSets the supplier of Bloom filters. When extendCheck creates a new target,\nthe supplier provides the instance of the Bloom filter.\n\n@param supplier The supplier of new Bloom filter instances.\n@return {@code this} instance.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder<T>", "classes": []}, "name": "setSupplier", "params": [{"name": "supplier", "type": "Supplier<T>"}], "body": "                                                                  {\n            this.supplier = supplier;\n            return this;\n        }", "signature": "public Builder<T> setSupplier(final Supplier<T> supplier)"}]}, {"original_string": "    public static final class Cleanup {\n\n        /**\n         * A Cleanup that never removes anything.\n         *\n         * @param <T> Type of BloomFilter.\n         * @return A Consumer suitable for the LayerManager {@code cleanup} parameter.\n         */\n        public static <T extends BloomFilter> Consumer<Deque<T>> noCleanup() {\n            return x -> {\n                // empty\n            };\n        }\n\n        /**\n         * Removes the earliest filters in the list when the the number of filters\n         * exceeds maxSize.\n         *\n         * @param <T> Type of BloomFilter.\n         * @param maxSize the maximum number of filters for the list. Must be greater\n         *                than 0\n         * @return A Consumer suitable for the LayerManager {@code cleanup} parameter.\n         * @throws IllegalArgumentException if {@code maxSize <= 0}.\n         */\n        public static <T extends BloomFilter> Consumer<Deque<T>> onMaxSize(final int maxSize) {\n            if (maxSize <= 0) {\n                throw new IllegalArgumentException(\"'maxSize' must be greater than 0\");\n            }\n            return ll -> {\n                while (ll.size() > maxSize) {\n                    ll.removeFirst();\n                }\n            };\n        }\n\n        /**\n         * Removes the last added target if it is empty.  Useful as the first in a chain\n         * of cleanup consumers.  (e.g. {@code Cleanup.removeEmptyTarget.andThen( otherConsumer )})\n         *\n         * @param <T> Type of BloomFilter.\n         * @return A Consumer suitable for the LayerManager {@code cleanup} parameter.\n         */\n        public static <T extends BloomFilter> Consumer<Deque<T>> removeEmptyTarget() {\n            return x -> {\n                if (!x.isEmpty() && x.getLast().isEmpty()) {\n                    x.removeLast();\n                }\n            };\n        }\n\n        /**\n         * Removes any layer identified by the predicate.\n         *\n         * @param <T> Type of BloomFilter.\n         * @param test Predicate.\n         * @return A Consumer suitable for the LayerManager {@code cleanup} parameter.\n         */\n        public static <T extends BloomFilter> Consumer<Deque<T>> removeIf(final Predicate<? super T> test) {\n            return x -> x.removeIf(test);\n        }\n\n        private Cleanup() {\n        }\n    }", "definition": "    public static final class Cleanup", "class_docstring": "\nStatic methods to create a Consumer of a List of BloomFilter perform\ntests on whether to reduce the collection of Bloom filters.\n", "name": "Cleanup", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public static <T extends BloomFilter> Consumer<Deque<T>> noCleanup() {\n            return x -> {\n                // empty\n            };\n        }", "docstring": "\nA Cleanup that never removes anything.\n\n@param <T> Type of BloomFilter.\n@return A Consumer suitable for the LayerManager {@code cleanup} parameter.\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Consumer<Deque<T>>", "classes": []}, "name": "noCleanup", "params": [], "body": "                                                                             {\n            return x -> {\n                // empty\n            };\n        }", "signature": "public static <T extends BloomFilter> Consumer<Deque<T>> noCleanup()"}, {"syntax_pass": true, "original_string": "        public static <T extends BloomFilter> Consumer<Deque<T>> onMaxSize(final int maxSize) {\n            if (maxSize <= 0) {\n                throw new IllegalArgumentException(\"'maxSize' must be greater than 0\");\n            }\n            return ll -> {\n                while (ll.size() > maxSize) {\n                    ll.removeFirst();\n                }\n            };\n        }", "docstring": "\nRemoves the earliest filters in the list when the the number of filters\nexceeds maxSize.\n\n@param <T> Type of BloomFilter.\n@param maxSize the maximum number of filters for the list. Must be greater\n               than 0\n@return A Consumer suitable for the LayerManager {@code cleanup} parameter.\n@throws IllegalArgumentException if {@code maxSize <= 0}.\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Consumer<Deque<T>>", "classes": []}, "name": "onMaxSize", "params": [{"name": "maxSize", "type": "int"}], "body": "                                                                                              {\n            if (maxSize <= 0) {\n                throw new IllegalArgumentException(\"'maxSize' must be greater than 0\");\n            }\n            return ll -> {\n                while (ll.size() > maxSize) {\n                    ll.removeFirst();\n                }\n            };\n        }", "signature": "public static <T extends BloomFilter> Consumer<Deque<T>> onMaxSize(final int maxSize)"}, {"syntax_pass": true, "original_string": "        public static <T extends BloomFilter> Consumer<Deque<T>> removeEmptyTarget() {\n            return x -> {\n                if (!x.isEmpty() && x.getLast().isEmpty()) {\n                    x.removeLast();\n                }\n            };\n        }", "docstring": "\nRemoves the last added target if it is empty.  Useful as the first in a chain\nof cleanup consumers.  (e.g. {@code Cleanup.removeEmptyTarget.andThen( otherConsumer )})\n\n@param <T> Type of BloomFilter.\n@return A Consumer suitable for the LayerManager {@code cleanup} parameter.\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Consumer<Deque<T>>", "classes": []}, "name": "removeEmptyTarget", "params": [], "body": "                                                                                     {\n            return x -> {\n                if (!x.isEmpty() && x.getLast().isEmpty()) {\n                    x.removeLast();\n                }\n            };\n        }", "signature": "public static <T extends BloomFilter> Consumer<Deque<T>> removeEmptyTarget()"}, {"syntax_pass": true, "original_string": "        public static <T extends BloomFilter> Consumer<Deque<T>> removeIf(final Predicate<? super T> test) {\n            return x -> x.removeIf(test);\n        }", "docstring": "\nRemoves any layer identified by the predicate.\n\n@param <T> Type of BloomFilter.\n@param test Predicate.\n@return A Consumer suitable for the LayerManager {@code cleanup} parameter.\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Consumer<Deque<T>>", "classes": []}, "name": "removeIf", "params": [{"name": "test", "type": "Predicate<? super T>"}], "body": "                                                                                                           {\n            return x -> x.removeIf(test);\n        }", "signature": "public static <T extends BloomFilter> Consumer<Deque<T>> removeIf(final Predicate<? super T> test)"}, {"syntax_pass": true, "original_string": "        private Cleanup() {\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "Cleanup", "params": [], "body": "                          {\n        }", "signature": "private Cleanup()"}]}, {"original_string": "    public static final class ExtendCheck {\n        /**\n         * Creates a new target after a specific number of filters have been added to\n         * the current target.\n         *\n         * @param <T> Type of BloomFilter.\n         * @param breakAt the number of filters to merge into each filter in the list.\n         * @return A Predicate suitable for the LayerManager {@code extendCheck} parameter.\n         * @throws IllegalArgumentException if {@code breakAt <= 0}\n         */\n        public static <T extends BloomFilter> Predicate<LayerManager<T>> advanceOnCount(final int breakAt) {\n            if (breakAt <= 0) {\n                throw new IllegalArgumentException(\"'breakAt' must be greater than 0\");\n            }\n            return new Predicate<LayerManager<T>>() {\n                int count;\n\n                @Override\n                public boolean test(final LayerManager<T> filter) {\n                    if (++count == breakAt) {\n                        count = 0;\n                        return true;\n                    }\n                    return false;\n                }\n            };\n        }\n\n        /**\n         * Advances the target once a merge has been performed.\n         *\n         * @param <T> Type of BloomFilter.\n         * @return A Predicate suitable for the LayerManager {@code extendCheck} parameter.\n         */\n        public static <T extends BloomFilter> Predicate<LayerManager<T>> advanceOnPopulated() {\n            return lm -> !lm.last().isEmpty();\n        }\n\n        /**\n         * Creates a new target after the current target is saturated. Saturation is\n         * defined as the {@code Bloom filter estimated N >= maxN}.\n         *\n         * <p>An example usage is advancing on a calculated saturation by calling:\n         * {@code ExtendCheck.advanceOnSaturation(shape.estimateMaxN()) }</p>\n         *\n         * @param <T> Type of BloomFilter.\n         * @param maxN the maximum number of estimated items in the filter.\n         * @return A Predicate suitable for the LayerManager {@code extendCheck} parameter.\n         * @throws IllegalArgumentException if {@code maxN <= 0}\n         */\n        public static <T extends BloomFilter> Predicate<LayerManager<T>> advanceOnSaturation(final double maxN) {\n            if (maxN <= 0) {\n                throw new IllegalArgumentException(\"'maxN' must be greater than 0\");\n            }\n            return manager -> {\n                final BloomFilter bf = manager.last();\n                return maxN <= bf.getShape().estimateN(bf.cardinality());\n            };\n        }\n\n        /**\n         * Does not automatically advance the target. @{code next()} must be called directly to\n         * perform the advance.\n         *\n         * @param <T> Type of BloomFilter.\n         * @return A Predicate suitable for the LayerManager {@code extendCheck} parameter.\n         */\n        public static <T extends BloomFilter> Predicate<LayerManager<T>> neverAdvance() {\n            return x -> false;\n        }\n\n        private ExtendCheck() {\n        }\n    }", "definition": "    public static final class ExtendCheck", "class_docstring": "\nA collection of common ExtendCheck implementations to test whether to extend\nthe depth of a LayerManager.\n", "name": "ExtendCheck", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public static <T extends BloomFilter> Predicate<LayerManager<T>> advanceOnCount(final int breakAt) {\n            if (breakAt <= 0) {\n                throw new IllegalArgumentException(\"'breakAt' must be greater than 0\");\n            }\n            return new Predicate<LayerManager<T>>() {\n                int count;\n\n                @Override\n                public boolean test(final LayerManager<T> filter) {\n                    if (++count == breakAt) {\n                        count = 0;\n                        return true;\n                    }\n                    return false;\n                }\n            };\n        }", "docstring": "\nCreates a new target after a specific number of filters have been added to\nthe current target.\n\n@param <T> Type of BloomFilter.\n@param breakAt the number of filters to merge into each filter in the list.\n@return A Predicate suitable for the LayerManager {@code extendCheck} parameter.\n@throws IllegalArgumentException if {@code breakAt <= 0}\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Predicate<LayerManager<T>>", "classes": []}, "name": "advanceOnCount", "params": [{"name": "breakAt", "type": "int"}], "body": "                                                                                                           {\n            if (breakAt <= 0) {\n                throw new IllegalArgumentException(\"'breakAt' must be greater than 0\");\n            }\n            return new Predicate<LayerManager<T>>() {\n                int count;\n\n                @Override\n                public boolean test(final LayerManager<T> filter) {\n                    if (++count == breakAt) {\n                        count = 0;\n                        return true;\n                    }\n                    return false;\n                }\n            };\n        }", "signature": "public static <T extends BloomFilter> Predicate<LayerManager<T>> advanceOnCount(final int breakAt)"}, {"syntax_pass": true, "original_string": "        public static <T extends BloomFilter> Predicate<LayerManager<T>> advanceOnPopulated() {\n            return lm -> !lm.last().isEmpty();\n        }", "docstring": "\nAdvances the target once a merge has been performed.\n\n@param <T> Type of BloomFilter.\n@return A Predicate suitable for the LayerManager {@code extendCheck} parameter.\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Predicate<LayerManager<T>>", "classes": []}, "name": "advanceOnPopulated", "params": [], "body": "                                                                                              {\n            return lm -> !lm.last().isEmpty();\n        }", "signature": "public static <T extends BloomFilter> Predicate<LayerManager<T>> advanceOnPopulated()"}, {"syntax_pass": true, "original_string": "        public static <T extends BloomFilter> Predicate<LayerManager<T>> advanceOnSaturation(final double maxN) {\n            if (maxN <= 0) {\n                throw new IllegalArgumentException(\"'maxN' must be greater than 0\");\n            }\n            return manager -> {\n                final BloomFilter bf = manager.last();\n                return maxN <= bf.getShape().estimateN(bf.cardinality());\n            };\n        }", "docstring": "\nCreates a new target after the current target is saturated. Saturation is\ndefined as the {@code Bloom filter estimated N >= maxN}.\n\n<p>An example usage is advancing on a calculated saturation by calling:\n{@code ExtendCheck.advanceOnSaturation(shape.estimateMaxN()) }</p>\n\n@param <T> Type of BloomFilter.\n@param maxN the maximum number of estimated items in the filter.\n@return A Predicate suitable for the LayerManager {@code extendCheck} parameter.\n@throws IllegalArgumentException if {@code maxN <= 0}\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Predicate<LayerManager<T>>", "classes": []}, "name": "advanceOnSaturation", "params": [{"name": "maxN", "type": "double"}], "body": "                                                                                                                {\n            if (maxN <= 0) {\n                throw new IllegalArgumentException(\"'maxN' must be greater than 0\");\n            }\n            return manager -> {\n                final BloomFilter bf = manager.last();\n                return maxN <= bf.getShape().estimateN(bf.cardinality());\n            };\n        }", "signature": "public static <T extends BloomFilter> Predicate<LayerManager<T>> advanceOnSaturation(final double maxN)"}, {"syntax_pass": true, "original_string": "        public static <T extends BloomFilter> Predicate<LayerManager<T>> neverAdvance() {\n            return x -> false;\n        }", "docstring": "\nDoes not automatically advance the target. @{code next()} must be called directly to\nperform the advance.\n\n@param <T> Type of BloomFilter.\n@return A Predicate suitable for the LayerManager {@code extendCheck} parameter.\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Predicate<LayerManager<T>>", "classes": []}, "name": "neverAdvance", "params": [], "body": "                                                                                        {\n            return x -> false;\n        }", "signature": "public static <T extends BloomFilter> Predicate<LayerManager<T>> neverAdvance()"}, {"syntax_pass": true, "original_string": "        private ExtendCheck() {\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "ExtendCheck", "params": [], "body": "                              {\n        }", "signature": "private ExtendCheck()"}]}], "class_docstring": "\nImplementation of the methods to manage the layers in a layered Bloom filter.\n<p>\nThe manager comprises a list of Bloom filters that are managed based on\nvarious rules. The last filter in the list is known as the {@code target} and\nis the filter into which merges are performed. The Layered manager utilizes\nthree methods to manage the list.\n</p>\n<ul>\n<li>ExtendCheck - A Predicate that if true causes a new Bloom filter to be\ncreated as the new target.</li>\n<li>FilterSupplier - A Supplier that produces empty Bloom filters to be used\nas a new target.</li>\n<li>Cleanup - A Consumer of a {@code LinkedList} of BloomFilter that removes any\nexpired or out dated filters from the list.</li>\n</ul>\n<p>\nWhen extendCheck returns {@code true} the following steps are taken:\n</p>\n<ol>\n<li>{@code Cleanup} is called</li>\n<li>{@code FilterSuplier} is executed and the new filter added to the list as\nthe {@code target} filter.</li>\n</ol>\n\n\n@param <T> the {@link BloomFilter} type.\n@since 4.5.0\n", "original_string": "public class LayerManager<T extends BloomFilter> implements BloomFilterExtractor {\n\n    /**\n     * Builds new instances of {@link LayerManager}.\n     *\n     * @param <T> the {@link BloomFilter} type.\n     */\n    public static class Builder<T extends BloomFilter> implements Supplier<LayerManager<T>> {\n\n        private Predicate<LayerManager<T>> extendCheck;\n        private Supplier<T> supplier;\n        private Consumer<Deque<T>> cleanup;\n\n        private Builder() {\n            extendCheck = ExtendCheck.neverAdvance();\n            cleanup = Cleanup.noCleanup();\n        }\n\n        /**\n         * Builds the layer manager with the specified properties.\n         *\n         * @return a new LayerManager.\n         */\n        @Override\n        public LayerManager<T> get() {\n            return new LayerManager<>(supplier, extendCheck, cleanup, true);\n        }\n\n        /**\n         * Sets the Consumer that cleans the list of Bloom filters.\n         *\n         * @param cleanup the Consumer that will modify the list of filters removing out\n         *                dated or stale filters.\n         * @return {@code this} instance.\n         */\n        public Builder<T> setCleanup(final Consumer<Deque<T>> cleanup) {\n            this.cleanup = cleanup;\n            return this;\n        }\n\n        /**\n         * Sets the extendCheck predicate. When the predicate returns {@code true} a new\n         * target will be created.\n         *\n         * @param extendCheck The predicate to determine if a new target should be\n         *                    created.\n         * @return {@code this} instance.\n         */\n        public Builder<T> setExtendCheck(final Predicate<LayerManager<T>> extendCheck) {\n            this.extendCheck = extendCheck;\n            return this;\n        }\n\n        /**\n         * Sets the supplier of Bloom filters. When extendCheck creates a new target,\n         * the supplier provides the instance of the Bloom filter.\n         *\n         * @param supplier The supplier of new Bloom filter instances.\n         * @return {@code this} instance.\n         */\n        public Builder<T> setSupplier(final Supplier<T> supplier) {\n            this.supplier = supplier;\n            return this;\n        }\n    }\n\n    /**\n     * Static methods to create a Consumer of a List of BloomFilter perform\n     * tests on whether to reduce the collection of Bloom filters.\n     */\n    public static final class Cleanup {\n\n        /**\n         * A Cleanup that never removes anything.\n         *\n         * @param <T> Type of BloomFilter.\n         * @return A Consumer suitable for the LayerManager {@code cleanup} parameter.\n         */\n        public static <T extends BloomFilter> Consumer<Deque<T>> noCleanup() {\n            return x -> {\n                // empty\n            };\n        }\n\n        /**\n         * Removes the earliest filters in the list when the the number of filters\n         * exceeds maxSize.\n         *\n         * @param <T> Type of BloomFilter.\n         * @param maxSize the maximum number of filters for the list. Must be greater\n         *                than 0\n         * @return A Consumer suitable for the LayerManager {@code cleanup} parameter.\n         * @throws IllegalArgumentException if {@code maxSize <= 0}.\n         */\n        public static <T extends BloomFilter> Consumer<Deque<T>> onMaxSize(final int maxSize) {\n            if (maxSize <= 0) {\n                throw new IllegalArgumentException(\"'maxSize' must be greater than 0\");\n            }\n            return ll -> {\n                while (ll.size() > maxSize) {\n                    ll.removeFirst();\n                }\n            };\n        }\n\n        /**\n         * Removes the last added target if it is empty.  Useful as the first in a chain\n         * of cleanup consumers.  (e.g. {@code Cleanup.removeEmptyTarget.andThen( otherConsumer )})\n         *\n         * @param <T> Type of BloomFilter.\n         * @return A Consumer suitable for the LayerManager {@code cleanup} parameter.\n         */\n        public static <T extends BloomFilter> Consumer<Deque<T>> removeEmptyTarget() {\n            return x -> {\n                if (!x.isEmpty() && x.getLast().isEmpty()) {\n                    x.removeLast();\n                }\n            };\n        }\n\n        /**\n         * Removes any layer identified by the predicate.\n         *\n         * @param <T> Type of BloomFilter.\n         * @param test Predicate.\n         * @return A Consumer suitable for the LayerManager {@code cleanup} parameter.\n         */\n        public static <T extends BloomFilter> Consumer<Deque<T>> removeIf(final Predicate<? super T> test) {\n            return x -> x.removeIf(test);\n        }\n\n        private Cleanup() {\n        }\n    }\n\n    /**\n     * A collection of common ExtendCheck implementations to test whether to extend\n     * the depth of a LayerManager.\n     */\n    public static final class ExtendCheck {\n        /**\n         * Creates a new target after a specific number of filters have been added to\n         * the current target.\n         *\n         * @param <T> Type of BloomFilter.\n         * @param breakAt the number of filters to merge into each filter in the list.\n         * @return A Predicate suitable for the LayerManager {@code extendCheck} parameter.\n         * @throws IllegalArgumentException if {@code breakAt <= 0}\n         */\n        public static <T extends BloomFilter> Predicate<LayerManager<T>> advanceOnCount(final int breakAt) {\n            if (breakAt <= 0) {\n                throw new IllegalArgumentException(\"'breakAt' must be greater than 0\");\n            }\n            return new Predicate<LayerManager<T>>() {\n                int count;\n\n                @Override\n                public boolean test(final LayerManager<T> filter) {\n                    if (++count == breakAt) {\n                        count = 0;\n                        return true;\n                    }\n                    return false;\n                }\n            };\n        }\n\n        /**\n         * Advances the target once a merge has been performed.\n         *\n         * @param <T> Type of BloomFilter.\n         * @return A Predicate suitable for the LayerManager {@code extendCheck} parameter.\n         */\n        public static <T extends BloomFilter> Predicate<LayerManager<T>> advanceOnPopulated() {\n            return lm -> !lm.last().isEmpty();\n        }\n\n        /**\n         * Creates a new target after the current target is saturated. Saturation is\n         * defined as the {@code Bloom filter estimated N >= maxN}.\n         *\n         * <p>An example usage is advancing on a calculated saturation by calling:\n         * {@code ExtendCheck.advanceOnSaturation(shape.estimateMaxN()) }</p>\n         *\n         * @param <T> Type of BloomFilter.\n         * @param maxN the maximum number of estimated items in the filter.\n         * @return A Predicate suitable for the LayerManager {@code extendCheck} parameter.\n         * @throws IllegalArgumentException if {@code maxN <= 0}\n         */\n        public static <T extends BloomFilter> Predicate<LayerManager<T>> advanceOnSaturation(final double maxN) {\n            if (maxN <= 0) {\n                throw new IllegalArgumentException(\"'maxN' must be greater than 0\");\n            }\n            return manager -> {\n                final BloomFilter bf = manager.last();\n                return maxN <= bf.getShape().estimateN(bf.cardinality());\n            };\n        }\n\n        /**\n         * Does not automatically advance the target. @{code next()} must be called directly to\n         * perform the advance.\n         *\n         * @param <T> Type of BloomFilter.\n         * @return A Predicate suitable for the LayerManager {@code extendCheck} parameter.\n         */\n        public static <T extends BloomFilter> Predicate<LayerManager<T>> neverAdvance() {\n            return x -> false;\n        }\n\n        private ExtendCheck() {\n        }\n    }\n    /**\n     * Creates a new Builder with defaults of {@code ExtendCheck.neverAdvance()} and\n     * {@code Cleanup.noCleanup()}.\n     *\n     * @param <T> Type of BloomFilter.\n     * @return A builder.\n     * @see ExtendCheck#neverAdvance()\n     * @see Cleanup#noCleanup()\n     */\n    public static <T extends BloomFilter> Builder<T> builder() {\n        return new Builder<>();\n    }\n\n    private final LinkedList<T> filters = new LinkedList<>();\n\n    private final Consumer<Deque<T>> filterCleanup;\n\n    private final Predicate<LayerManager<T>> extendCheck;\n\n    private final Supplier<T> filterSupplier;\n\n    /**\n     * Constructs a new instance.\n     *\n     * @param filterSupplier the non-null supplier of new Bloom filters to add the the list\n     *                       when necessary.\n     * @param extendCheck    The non-null predicate that checks if a new filter should be\n     *                       added to the list.\n     * @param filterCleanup  the non-null consumer that removes any old filters from the\n     *                       list.\n     * @param initialize     true if the filter list should be initialized.\n     */\n    private LayerManager(final Supplier<T> filterSupplier, final Predicate<LayerManager<T>> extendCheck,\n            final Consumer<Deque<T>> filterCleanup, final boolean initialize) {\n        this.filterSupplier = Objects.requireNonNull(filterSupplier, \"filterSupplier\");\n        this.extendCheck = Objects.requireNonNull(extendCheck, \"extendCheck\");\n        this.filterCleanup = Objects.requireNonNull(filterCleanup, \"filterCleanup\");\n        if (initialize) {\n            addFilter();\n        }\n    }\n\n    /**\n     * Adds a new Bloom filter to the list.\n     */\n    private void addFilter() {\n        filters.add(Objects.requireNonNull(filterSupplier.get(), \"filterSupplier.get() returned null.\"));\n    }\n\n    /**\n     * Forces execution the configured cleanup without creating a new filter except in cases\n     * where the cleanup removes all the layers.\n     * @see LayerManager.Builder#setCleanup(Consumer)\n     */\n    void cleanup() {\n        filterCleanup.accept(filters);\n        if (filters.isEmpty()) {\n            addFilter();\n        }\n    }\n\n    /**\n     * Removes all the filters from the layer manager, and sets up a new one as the\n     * target.\n     */\n    public final void clear() {\n        filters.clear();\n        addFilter();\n    }\n\n    /**\n     * Creates a deep copy of this LayerManager.\n     * <p><em>Filters in the copy are deep copies, not references, so changes in the copy\n     * are NOT reflected in the original.</em></p>\n     * <p>The {@code filterSupplier}, {@code extendCheck}, and the {@code filterCleanup} are shared between\n     * the copy and this instance.</p>\n     *\n     * @return a copy of this layer Manager.\n     */\n    public LayerManager<T> copy() {\n        final LayerManager<T> newMgr = new LayerManager<>(filterSupplier, extendCheck, filterCleanup, false);\n        for (final T bf : filters) {\n            newMgr.filters.add(bf.copy());\n        }\n        return newMgr;\n    }\n\n    /**\n     * Gets the Bloom filter from the first layer.\n     * No extension check is performed during this call.\n     * @return The Bloom filter from the first layer.\n     * @see #getTarget()\n     */\n    public final T first() {\n        return filters.getFirst();\n    }\n\n    /**\n     * Gets the Bloom filter at the specified depth. The filter at depth 0 is the\n     * oldest filter.\n     *\n     * @param depth the depth at which the desired filter is to be found.\n     * @return the filter.\n     * @throws NoSuchElementException if depth is not in the range\n     *                                [0,filters.size())\n     */\n    public final T get(final int depth) {\n        if (depth < 0 || depth >= filters.size()) {\n            throw new NoSuchElementException(String.format(\"Depth must be in the range [0,%s)\", filters.size()));\n        }\n        return filters.get(depth);\n    }\n\n    /**\n     * Returns the number of filters in the LayerManager.  In the default LayerManager implementation\n     * there is always at least one layer.\n     *\n     * @return the current depth.\n     */\n    public final int getDepth() {\n        return filters.size();\n    }\n\n    /**\n     * Returns the current target filter. If a new filter should be created based on\n     * {@code extendCheck} it will be created before this method returns.\n     *\n     * @return the current target filter after any extension.\n     */\n    public final T getTarget() {\n        if (extendCheck.test(this)) {\n            next();\n        }\n        return last();\n    }\n\n    /**\n     * Gets the Bloom filter from the last layer.\n     * No extension check is performed during this call.\n     * @return The Bloom filter from the last layer.\n     * @see #getTarget()\n     */\n    public final T last() {\n        return filters.getLast();\n    }\n\n    /**\n     * Forces an advance to the next depth. This method will clean-up the current\n     * layers and generate a new filter layer. In most cases is it unnecessary to\n     * call this method directly.\n     * <p>\n     * Ths method is used within {@link #getTarget()} when the configured\n     * {@code ExtendCheck} returns {@code true}.\n     * </p>\n     * @see LayerManager.Builder#setExtendCheck(Predicate)\n     * @see LayerManager.Builder#setCleanup(Consumer)\n     */\n    void next() {\n        filterCleanup.accept(filters);\n        addFilter();\n    }\n\n    /**\n     * Executes a Bloom filter Predicate on each Bloom filter in the manager in\n     * depth order. Oldest filter first.\n     *\n     * @param bloomFilterPredicate the predicate to evaluate each Bloom filter with.\n     * @return {@code false} when the a filter fails the predicate test. Returns\n     *         {@code true} if all filters pass the test.\n     */\n    @Override\n    public boolean processBloomFilters(final Predicate<BloomFilter> bloomFilterPredicate) {\n        for (final BloomFilter bf : filters) {\n            if (!bloomFilterPredicate.test(bf)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}", "super_interfaces": ["BloomFilterExtractor"], "fields": [{"attribute_expression": "private final LinkedList<T> filters = new LinkedList<>();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "LinkedList<T>", "name": "filters = new LinkedList<>()", "syntax_pass": true}, {"attribute_expression": "private final Consumer<Deque<T>> filterCleanup;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Consumer<Deque<T>>", "name": "filterCleanup", "syntax_pass": true}, {"attribute_expression": "private final Predicate<LayerManager<T>> extendCheck;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Predicate<LayerManager<T>>", "name": "extendCheck", "syntax_pass": true}, {"attribute_expression": "private final Supplier<T> filterSupplier;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Supplier<T>", "name": "filterSupplier", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/bloomfilter/EnhancedDoubleHasher.java.EnhancedDoubleHasher", "name": "EnhancedDoubleHasher", "file_path": "src/main/java/org/apache/commons/collections4/bloomfilter/EnhancedDoubleHasher.java", "superclasses": "", "methods": ["[long]toLong(byte[],int,int)", "[]EnhancedDoubleHasher(byte[])", "[]EnhancedDoubleHasher(long,long)", "[long]getIncrement()", "[long]getInitial()", "[IndexExtractor]indices(Shape)"], "method_uris": ["src/main/java/org/apache/commons/collections4/bloomfilter/EnhancedDoubleHasher.java.EnhancedDoubleHasher.[long]toLong(byte[],int,int)", "src/main/java/org/apache/commons/collections4/bloomfilter/EnhancedDoubleHasher.java.EnhancedDoubleHasher.[]EnhancedDoubleHasher(byte[])", "src/main/java/org/apache/commons/collections4/bloomfilter/EnhancedDoubleHasher.java.EnhancedDoubleHasher.[]EnhancedDoubleHasher(long,long)", "src/main/java/org/apache/commons/collections4/bloomfilter/EnhancedDoubleHasher.java.EnhancedDoubleHasher.[long]getIncrement()", "src/main/java/org/apache/commons/collections4/bloomfilter/EnhancedDoubleHasher.java.EnhancedDoubleHasher.[long]getInitial()", "src/main/java/org/apache/commons/collections4/bloomfilter/EnhancedDoubleHasher.java.EnhancedDoubleHasher.[IndexExtractor]indices(Shape)"], "overrides": null, "attributes": [], "class_docstring": "\nA Hasher that implements combinatorial hashing as described by\n<a href=\"https://www.eecs.harvard.edu/~michaelm/postscripts/tr-02-05.pdf\">Krisch and Mitzenmacher</a> using the enhanced double hashing technique\ndescribed in the wikipedia article  <a href=\"https://en.wikipedia.org/wiki/Double_hashing#Enhanced_double_hashing\">Double Hashing</a>.\n<p>\nCommon use for this hasher is to generate bit indices from a byte array output of a hashing\nor MessageDigest algorithm.</p>\n\n<h2>Thoughts on the hasher input</h2>\n\n<p>Note that it is worse to create smaller numbers for the {@code initial} and {@code increment}. If the {@code initial} is smaller than\nthe number of bits in a filter then hashing will start at the same point when the size increases; likewise the {@code increment} will be\nthe same if it remains smaller than the number of bits in the filter and so the first few indices will be the same if the number of bits\nchanges (but is still larger than the {@code increment}). In a worse case scenario with small {@code initial} and {@code increment} for\nall items, hashing may not create indices that fill the full region within a much larger filter. Imagine hashers created with {@code initial}\nand {@code increment} values less than 255 with a filter size of 30000 and number of hash functions as 5. Ignoring the\ntetrahedral addition (a maximum of 20 for k=5) the max index is 255 * 4 + 255 = 1275, this covers 4.25% of the filter. This also\nignores the negative wrapping but the behavior is the same, some bits cannot be reached.\n</p><p>\nSo this needs to be avoided as the filter probability assumptions will be void. If the {@code initial} and {@code increment} are larger\nthan the number of bits then the modulus will create a 'random' position and increment within the size.\n</p>\n\n@since 4.5.0\n", "original_string": "public class EnhancedDoubleHasher implements Hasher {\n\n    /**\n     * Convert bytes to big-endian long filling with zero bytes as necessary.\n     * @param byteArray the byte array to extract the values from.\n     * @param offset the offset to start extraction from.\n     * @param len the length of the extraction, may be longer than 8.\n     * @return\n     */\n    private static long toLong(final byte[] byteArray, final int offset, final int len) {\n        long val = 0;\n        int shift = Long.SIZE;\n        final int end = offset + Math.min(len, Long.BYTES);\n        for (int i = offset; i < end; i++) {\n            shift -= Byte.SIZE;\n            val |= (long) (byteArray[i] & 0xFF) << shift;\n        }\n        return val;\n    }\n\n    /**\n     * The initial hash value.\n     */\n    private final long initial;\n\n    /**\n     * The value to increment the hash value by.\n     */\n    private final long increment;\n\n    /**\n     * Constructs the EnhancedDoubleHasher from a byte array.\n     * <p>\n     * This method simplifies the conversion from a Digest or hasher algorithm output\n     * to the two values used by the EnhancedDoubleHasher.</p>\n     * <p>The byte array is split in 2 and the first 8 bytes of each half are interpreted as a big-endian long value.\n     * Excess bytes are ignored.\n     * If there are fewer than 16 bytes the following conversions are made.\n     *</p>\n     * <ol>\n     * <li>If there is an odd number of bytes the excess byte is assigned to the increment value</li>\n     * <li>The bytes allotted are read in big-endian order any byte not populated is set to zero.</li>\n     * </ol>\n     * <p>\n     * This ensures that small arrays generate the largest possible increment and initial values.\n     * </p>\n     * @param buffer the buffer to extract the longs from.\n     * @throws IllegalArgumentException is buffer length is zero.\n     */\n    public EnhancedDoubleHasher(final byte[] buffer) {\n        if (buffer.length == 0) {\n            throw new IllegalArgumentException(\"buffer length must be greater than 0\");\n        }\n        // divide by 2\n        final int segment = buffer.length / 2;\n        this.initial = toLong(buffer, 0, segment);\n        this.increment = toLong(buffer, segment, buffer.length - segment);\n    }\n\n    /**\n     * Constructs the EnhancedDoubleHasher from 2 longs. The long values will be interpreted as unsigned values.\n     * @param initial The initial value for the hasher.\n     * @param increment The value to increment the hash by on each iteration.\n     */\n    public EnhancedDoubleHasher(final long initial, final long increment) {\n        this.initial = initial;\n        this.increment = increment;\n    }\n\n    /**\n     * Gets the increment value for the hash calculation.\n     * @return the increment value for the hash calculation.\n     */\n    long getIncrement() {\n        return increment;\n    }\n\n    /**\n     * Gets the initial value for the hash calculation.\n     * @return the initial value for the hash calculation.\n     */\n    long getInitial() {\n        return initial;\n    }\n\n    @Override\n    public IndexExtractor indices(final Shape shape) {\n        Objects.requireNonNull(shape, \"shape\");\n\n        return new IndexExtractor() {\n\n            @Override\n            public int[] asIndexArray() {\n                final int[] result = new int[shape.getNumberOfHashFunctions()];\n                final int[] idx = new int[1];\n\n                // This method needs to return duplicate indices\n\n                processIndices(i -> {\n                    result[idx[0]++] = i;\n                    return true;\n                });\n                return result;\n            }\n\n            @Override\n            public boolean processIndices(final IntPredicate consumer) {\n                Objects.requireNonNull(consumer, \"consumer\");\n                final int bits = shape.getNumberOfBits();\n                // Enhanced double hashing:\n                // hash[i] = ( h1(x) + i*h2(x) + (i*i*i - i)/6 ) mod bits\n                // See: https://en.wikipedia.org/wiki/Double_hashing#Enhanced_double_hashing\n                //\n                // Essentially this is computing a wrapped modulus from a start point and an\n                // increment and an additional term as a tetrahedral number.\n                // You only need two modulus operations before the loop. Within the loop\n                // the modulus is handled using the sign bit to detect wrapping to ensure:\n                // 0 <= index < bits\n                // 0 <= inc < bits\n                // The final hash is:\n                // hash[i] = ( h1(x) - i*h2(x) - (i*i*i - i)/6 ) wrapped in [0, bits)\n\n                int index = BitMaps.mod(initial, bits);\n                if (!consumer.test(index)) {\n                    return false;\n                }\n                int inc = BitMaps.mod(increment, bits);\n\n                final int k = shape.getNumberOfHashFunctions();\n\n                if (k >= bits) {\n                    // the tetraheadral incrementer.  We need to ensure that this\n                    // number does not exceed bits-1 or we may end up with an index > bits.\n                    int tet = 1;\n                    for (int i = 1; i < k; i++) {\n                        // Update index and handle wrapping\n                        index -= inc;\n                        index = index < 0 ? index + bits : index;\n                        if (!consumer.test(index)) {\n                            return false;\n                        }\n\n                        // Incorporate the counter into the increment to create a\n                        // tetrahedral number additional term, and handle wrapping.\n                        inc -= tet;\n                        inc = inc < 0 ? inc + bits : inc;\n                        if (++tet == bits) {\n                            tet = 0;\n                        }\n                    }\n                } else {\n                    for (int i = 1; i < k; i++) {\n                        // Update index and handle wrapping\n                        index -= inc;\n                        index = index < 0 ? index + bits : index;\n                        if (!consumer.test(index)) {\n                            return false;\n                        }\n\n                        // Incorporate the counter into the increment to create a\n                        // tetrahedral number additional term, and handle wrapping.\n                        inc -= i;\n                        inc = inc < 0 ? inc + bits : inc;\n                    }\n\n                }\n                return true;\n            }\n        };\n    }\n}", "super_interfaces": ["Hasher"], "fields": [{"attribute_expression": "private final long initial;", "docstring": "\nThe initial hash value.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "long", "name": "initial", "syntax_pass": true}, {"attribute_expression": "private final long increment;", "docstring": "\nThe value to increment the hash value by.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "long", "name": "increment", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/bloomfilter/CountingPredicate.java.CountingPredicate", "name": "CountingPredicate", "file_path": "src/main/java/org/apache/commons/collections4/bloomfilter/CountingPredicate.java", "superclasses": "", "methods": ["[]CountingPredicate(T[],BiPredicate<T, T>)", "[boolean]processRemaining()", "[boolean]test(T)"], "method_uris": ["src/main/java/org/apache/commons/collections4/bloomfilter/CountingPredicate.java.CountingPredicate.[]CountingPredicate(T[],BiPredicate<T, T>)", "src/main/java/org/apache/commons/collections4/bloomfilter/CountingPredicate.java.CountingPredicate.[boolean]processRemaining()", "src/main/java/org/apache/commons/collections4/bloomfilter/CountingPredicate.java.CountingPredicate.[boolean]test(T)"], "overrides": null, "attributes": [], "class_docstring": "\nA predicate that applies the test {@code func} to each member of the {@code ary} in\nsequence for each call to {@code test()}. if the {@code ary} is exhausted,\nthe subsequent calls to {@code test} are executed with a {@code null} value.\nIf the calls to {@code test} do not exhaust the {@code ary} the {@code\nprocessRemaining} method can be called to execute the @{code test} with a\n{@code null} value for each remaining {@code idx} value.\n\n@param <T> the type of object being compared.\n@since 4.5.0\n", "original_string": "class CountingPredicate<T> implements Predicate<T> {\n    private int idx;\n    private final T[] ary;\n    private final BiPredicate<T, T> func;\n\n    /**\n     * Constructs an instance that will compare the elements in {@code ary} with the\n     * elements returned by {@code func}. function is called as {@code func.test(\n     * idxValue, otherValue )}. If there are more {@code otherValue} values than\n     * {@code idxValues} then {@code func} is called as {@code func.test(null, otherValue)}.\n     *\n     * @param ary  The array of long values to compare.\n     * @param func The function to apply to the pairs of long values.\n     */\n    CountingPredicate(final T[] ary, final BiPredicate<T, T> func) {\n        this.ary = ary;\n        this.func = func;\n    }\n\n    /**\n     * Call {@code BiPredicate<T, T>} for each remaining unpaired {@code <T>} in the\n     * input array. This method should be invoked after the predicate has been\n     * passed to a {@code Extractor.forEach<T>(BiPredicate<T, T>)} to consume any\n     * unpaired {@code <T>}s. The second argument to the BiPredicate will be {@code null}.\n     *\n     * @return true if all calls to the predicate were successful\n     */\n    boolean processRemaining() {\n        // uses local references for optimization benefit.\n        int i = idx;\n        final T[] a = ary;\n        final int limit = a.length;\n        while (i != limit && func.test(a[i], null)) {\n            i++;\n        }\n        return i == limit;\n    }\n\n    @Override\n    public boolean test(final T other) {\n        return func.test(idx == ary.length ? null : ary[idx++], other);\n    }\n}", "super_interfaces": ["Predicate<T>"], "fields": [{"attribute_expression": "private int idx;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "idx", "syntax_pass": true}, {"attribute_expression": "private final T[] ary;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "T[]", "name": "ary", "syntax_pass": true}, {"attribute_expression": "private final BiPredicate<T, T> func;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "BiPredicate<T, T>", "name": "func", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/bloomfilter/SparseBloomFilter.java.SparseBloomFilter", "name": "SparseBloomFilter", "file_path": "src/main/java/org/apache/commons/collections4/bloomfilter/SparseBloomFilter.java", "superclasses": "", "methods": ["[]SparseBloomFilter(Shape)", "[]SparseBloomFilter(SparseBloomFilter)", "[boolean]add(int)", "[long[]]asBitMapArray()", "[int]cardinality()", "[int]characteristics()", "[void]clear()", "[boolean]contains(BitMapExtractor)", "[boolean]contains(IndexExtractor)", "[SparseBloomFilter]copy()", "[Shape]getShape()", "[boolean]isEmpty()", "[boolean]merge(BitMapExtractor)", "[boolean]merge(BloomFilter)", "[boolean]merge(Hasher)", "[boolean]merge(IndexExtractor)", "[boolean]processBitMaps(LongPredicate)", "[boolean]processIndices(IntPredicate)"], "method_uris": ["src/main/java/org/apache/commons/collections4/bloomfilter/SparseBloomFilter.java.SparseBloomFilter.[]SparseBloomFilter(Shape)", "src/main/java/org/apache/commons/collections4/bloomfilter/SparseBloomFilter.java.SparseBloomFilter.[]SparseBloomFilter(SparseBloomFilter)", "src/main/java/org/apache/commons/collections4/bloomfilter/SparseBloomFilter.java.SparseBloomFilter.[boolean]add(int)", "src/main/java/org/apache/commons/collections4/bloomfilter/SparseBloomFilter.java.SparseBloomFilter.[long[]]asBitMapArray()", "src/main/java/org/apache/commons/collections4/bloomfilter/SparseBloomFilter.java.SparseBloomFilter.[int]cardinality()", "src/main/java/org/apache/commons/collections4/bloomfilter/SparseBloomFilter.java.SparseBloomFilter.[int]characteristics()", "src/main/java/org/apache/commons/collections4/bloomfilter/SparseBloomFilter.java.SparseBloomFilter.[void]clear()", "src/main/java/org/apache/commons/collections4/bloomfilter/SparseBloomFilter.java.SparseBloomFilter.[boolean]contains(BitMapExtractor)", "src/main/java/org/apache/commons/collections4/bloomfilter/SparseBloomFilter.java.SparseBloomFilter.[boolean]contains(IndexExtractor)", "src/main/java/org/apache/commons/collections4/bloomfilter/SparseBloomFilter.java.SparseBloomFilter.[SparseBloomFilter]copy()", "src/main/java/org/apache/commons/collections4/bloomfilter/SparseBloomFilter.java.SparseBloomFilter.[Shape]getShape()", "src/main/java/org/apache/commons/collections4/bloomfilter/SparseBloomFilter.java.SparseBloomFilter.[boolean]isEmpty()", "src/main/java/org/apache/commons/collections4/bloomfilter/SparseBloomFilter.java.SparseBloomFilter.[boolean]merge(BitMapExtractor)", "src/main/java/org/apache/commons/collections4/bloomfilter/SparseBloomFilter.java.SparseBloomFilter.[boolean]merge(BloomFilter)", "src/main/java/org/apache/commons/collections4/bloomfilter/SparseBloomFilter.java.SparseBloomFilter.[boolean]merge(Hasher)", "src/main/java/org/apache/commons/collections4/bloomfilter/SparseBloomFilter.java.SparseBloomFilter.[boolean]merge(IndexExtractor)", "src/main/java/org/apache/commons/collections4/bloomfilter/SparseBloomFilter.java.SparseBloomFilter.[boolean]processBitMaps(LongPredicate)", "src/main/java/org/apache/commons/collections4/bloomfilter/SparseBloomFilter.java.SparseBloomFilter.[boolean]processIndices(IntPredicate)"], "overrides": null, "attributes": [], "class_docstring": "\nA bloom filter using a TreeSet of integers to track enabled bits. This is a standard\nimplementation and should work well for most low cardinality Bloom filters.\n@since 4.5.0\n", "original_string": "public final class SparseBloomFilter implements BloomFilter {\n\n    /**\n     * The bitSet that defines this BloomFilter.\n     */\n    private final TreeSet<Integer> indices;\n\n    /**\n     * The shape of this BloomFilter.\n     */\n    private final Shape shape;\n\n    /**\n     * Constructs an empty BitSetBloomFilter.\n     *\n     * @param shape The shape of the filter.\n     */\n    public SparseBloomFilter(final Shape shape) {\n        Objects.requireNonNull(shape, \"shape\");\n        this.shape = shape;\n        this.indices = new TreeSet<>();\n    }\n\n    private SparseBloomFilter(final SparseBloomFilter source) {\n        shape = source.shape;\n        indices = new TreeSet<>(source.indices);\n    }\n\n    /**\n     * Adds the index to the indices.\n     * @param idx the index to add.\n     * @return {@code true} always\n     */\n    private boolean add(final int idx) {\n        indices.add(idx);\n        return true;\n    }\n\n    @Override\n    public long[] asBitMapArray() {\n        final long[] result = new long[BitMaps.numberOfBitMaps(shape.getNumberOfBits())];\n        for (final int i : indices) {\n            BitMaps.set(result, i);\n        }\n        return result;\n    }\n\n    @Override\n    public int cardinality() {\n        return indices.size();\n    }\n\n    @Override\n    public int characteristics() {\n        return SPARSE;\n    }\n\n    @Override\n    public void clear() {\n        indices.clear();\n    }\n\n    @Override\n    public boolean contains(final BitMapExtractor bitMapExtractor) {\n        return contains(IndexExtractor.fromBitMapExtractor(bitMapExtractor));\n    }\n\n    @Override\n    public boolean contains(final IndexExtractor indexExtractor) {\n        return indexExtractor.processIndices(indices::contains);\n    }\n\n    @Override\n    public SparseBloomFilter copy() {\n        return new SparseBloomFilter(this);\n    }\n\n    @Override\n    public Shape getShape() {\n        return shape;\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return indices.isEmpty();\n    }\n\n    @Override\n    public boolean merge(final BitMapExtractor bitMapExtractor) {\n        Objects.requireNonNull(bitMapExtractor, \"bitMapExtractor\");\n        return this.merge(IndexExtractor.fromBitMapExtractor(bitMapExtractor));\n    }\n\n    @Override\n    public boolean merge(final BloomFilter other) {\n        Objects.requireNonNull(other, \"other\");\n        final IndexExtractor indexExtractor = (other.characteristics() & SPARSE) != 0 ? (IndexExtractor) other : IndexExtractor.fromBitMapExtractor(other);\n        merge(indexExtractor);\n        return true;\n    }\n\n    @Override\n    public boolean merge(final Hasher hasher) {\n        Objects.requireNonNull(hasher, \"hasher\");\n        merge(hasher.indices(shape));\n        return true;\n    }\n\n    @Override\n    public boolean merge(final IndexExtractor indexExtractor) {\n        Objects.requireNonNull(indexExtractor, \"indexExtractor\");\n        indexExtractor.processIndices(this::add);\n        if (!indices.isEmpty()) {\n            if (indices.last() >= shape.getNumberOfBits()) {\n                throw new IllegalArgumentException(String.format(\"Value in list %s is greater than maximum value (%s)\",\n                        indices.last(), shape.getNumberOfBits() - 1));\n            }\n            if (indices.first() < 0) {\n                throw new IllegalArgumentException(\n                        String.format(\"Value in list %s is less than 0\", indices.first()));\n            }\n        }\n        return true;\n    }\n\n    @Override\n    public boolean processBitMaps(final LongPredicate consumer) {\n        Objects.requireNonNull(consumer, \"consumer\");\n        final int limit = BitMaps.numberOfBitMaps(shape.getNumberOfBits());\n        /*\n         * because our indices are always in order we can shorten the time necessary to\n         * create the longs for the consumer\n         */\n        // the currently constructed bitMap\n        long bitMap = 0;\n        // the bitmap we are working on\n        int idx = 0;\n        for (final int i : indices) {\n            while (BitMaps.getLongIndex(i) != idx) {\n                if (!consumer.test(bitMap)) {\n                    return false;\n                }\n                bitMap = 0;\n                idx++;\n            }\n            bitMap |= BitMaps.getLongBit(i);\n        }\n        // we fall through with data in the bitMap\n        if (!consumer.test(bitMap)) {\n            return false;\n        }\n        // account for hte bitMap in the previous block + the next one\n        idx++;\n        // while there are more blocks to generate send zero to the consumer.\n        while (idx < limit) {\n            if (!consumer.test(0L)) {\n                return false;\n            }\n            idx++;\n        }\n        return true;\n    }\n\n    @Override\n    public boolean processIndices(final IntPredicate consumer) {\n        Objects.requireNonNull(consumer, \"consumer\");\n        for (final int value : indices) {\n            if (!consumer.test(value)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}", "super_interfaces": ["BloomFilter"], "fields": [{"attribute_expression": "private final TreeSet<Integer> indices;", "docstring": "\nThe bitSet that defines this BloomFilter.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "TreeSet<Integer>", "name": "indices", "syntax_pass": true}, {"attribute_expression": "private final Shape shape;", "docstring": "\nThe shape of this BloomFilter.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Shape", "name": "shape", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/bloomfilter/Shape.java.Shape", "name": "Shape", "file_path": "src/main/java/org/apache/commons/collections4/bloomfilter/Shape.java", "superclasses": "", "methods": ["[int]calculateNumberOfHashFunctions(int,int)", "[void]checkCalculatedProbability(double)", "[int]checkNumberOfBits(int)", "[int]checkNumberOfHashFunctions(int)", "[int]checkNumberOfItems(int)", "[void]checkProbability(double)", "[Shape]fromKM(int,int)", "[Shape]fromNM(int,int)", "[Shape]fromNMK(int,int,int)", "[Shape]fromNP(int,double)", "[Shape]fromPMK(double,int,int)", "[]Shape(int,int)", "[boolean]equals(Object)", "[double]estimateMaxN()", "[double]estimateN(int)", "[int]getNumberOfBits()", "[int]getNumberOfHashFunctions()", "[double]getProbability(int)", "[int]hashCode()", "[boolean]isSparse(int)", "[String]toString()"], "method_uris": ["src/main/java/org/apache/commons/collections4/bloomfilter/Shape.java.Shape.[int]calculateNumberOfHashFunctions(int,int)", "src/main/java/org/apache/commons/collections4/bloomfilter/Shape.java.Shape.[void]checkCalculatedProbability(double)", "src/main/java/org/apache/commons/collections4/bloomfilter/Shape.java.Shape.[int]checkNumberOfBits(int)", "src/main/java/org/apache/commons/collections4/bloomfilter/Shape.java.Shape.[int]checkNumberOfHashFunctions(int)", "src/main/java/org/apache/commons/collections4/bloomfilter/Shape.java.Shape.[int]checkNumberOfItems(int)", "src/main/java/org/apache/commons/collections4/bloomfilter/Shape.java.Shape.[void]checkProbability(double)", "src/main/java/org/apache/commons/collections4/bloomfilter/Shape.java.Shape.[Shape]fromKM(int,int)", "src/main/java/org/apache/commons/collections4/bloomfilter/Shape.java.Shape.[Shape]fromNM(int,int)", "src/main/java/org/apache/commons/collections4/bloomfilter/Shape.java.Shape.[Shape]fromNMK(int,int,int)", "src/main/java/org/apache/commons/collections4/bloomfilter/Shape.java.Shape.[Shape]fromNP(int,double)", "src/main/java/org/apache/commons/collections4/bloomfilter/Shape.java.Shape.[Shape]fromPMK(double,int,int)", "src/main/java/org/apache/commons/collections4/bloomfilter/Shape.java.Shape.[]Shape(int,int)", "src/main/java/org/apache/commons/collections4/bloomfilter/Shape.java.Shape.[boolean]equals(Object)", "src/main/java/org/apache/commons/collections4/bloomfilter/Shape.java.Shape.[double]estimateMaxN()", "src/main/java/org/apache/commons/collections4/bloomfilter/Shape.java.Shape.[double]estimateN(int)", "src/main/java/org/apache/commons/collections4/bloomfilter/Shape.java.Shape.[int]getNumberOfBits()", "src/main/java/org/apache/commons/collections4/bloomfilter/Shape.java.Shape.[int]getNumberOfHashFunctions()", "src/main/java/org/apache/commons/collections4/bloomfilter/Shape.java.Shape.[double]getProbability(int)", "src/main/java/org/apache/commons/collections4/bloomfilter/Shape.java.Shape.[int]hashCode()", "src/main/java/org/apache/commons/collections4/bloomfilter/Shape.java.Shape.[boolean]isSparse(int)", "src/main/java/org/apache/commons/collections4/bloomfilter/Shape.java.Shape.[String]toString()"], "overrides": null, "attributes": [], "class_docstring": "\nThe definition of a Bloom filter shape.\n\n<p>This class contains the values for the filter configuration and is used to\nconvert a Hasher into a BloomFilter as well as verify that two Bloom filters are\ncompatible. (i.e. can be compared or merged)</p>\n\n<h2>Interrelatedness of values</h2>\n\n<dl>\n<dt>Number of Items ({@code n})</dt>\n<dd>{@code n = ceil(m / (-k / ln(1 - exp(ln(p) / k))))}</dd>\n<dt>Probability of False Positives ({@code p})</dt>\n<dd>{@code p = pow(1 - exp(-k / (m / n)), k)}</dd>\n<dt>Number of Bits ({@code m})</dt>\n<dd>{@code m = ceil((n * ln(p)) / ln(1 / pow(2, ln(2))))}</dd>\n<dt>Number of Functions ({@code k})</dt>\n<dd>{@code k = round((m / n) * ln(2))}</dd>\n</dl>\n\n<h2>Estimations from cardinality based on shape</h2>\n\n<p>Several estimates can be calculated from the Shape and the cardinality of a Bloom filter.</p>\n\n<p>In the calculation below the following values are used:</p>\n<ul>\n<li>double c = the cardinality of the Bloom filter.</li>\n<li>double m = numberOfBits as specified in the shape.</li>\n<li>double k = numberOfHashFunctions as specified in the shape.</li>\n</ul>\n\n<h3>Estimate N - n()</h3>\n\n<p>The calculation for the estimate of N is: {@code -(m/k) * ln(1 - (c/m))}.  This is the calculation\nperformed by the {@code Shape.estimateN(cardinality)} method below.  This estimate is roughly equivalent to the\nnumber of hashers that have been merged into a filter to create the cardinality specified.</p>\n\n<p><em>Note:</em></p>\n<ul>\n<li>if cardinality == numberOfBits, then result is infinity.</li>\n<li>if cardinality &gt; numberOfBits, then result is NaN.</li>\n</ul>\n\n<h3>Estimate N of Union - n(A &cup; B)</h3>\n\n<p>To estimate the number of items in the union of two Bloom filters with the same shape, merge them together and\ncalculate the estimated N from the result.</p>\n\n<h3>Estimate N of the Intersection - n(A &cap; B)</h3>\n\n<p>To estimate the number of items in the intersection of two Bloom filters A and B with the same shape the calculation is:\nn(A) + n(b) - n(A &cup; B).</p>\n\n<p>Care must be taken when any of the n(x) returns infinity.  In general the following assumptions are true:\n\n<ul>\n<li>If n(A) = &infin; and n(B) &lt; &infin; then n(A &cap; B) = n(B)</li>\n<li>If n(A) &lt; &infin; and n(B) = &infin; then n(A &cap; B) = n(A)</li>\n<li>If n(A) = &infin; and n(B) = &infin; then n(A &cap; B) = &infin;</li>\n<li>If n(A) &lt; &infin; and n(B) &lt; &infin; and n(A &cup; B) = &infin; then n(A &cap; B) is undefined.</li>\n</ul>\n\n@see <a href=\"https://hur.st/bloomfilter\">Bloom Filter calculator</a>\n@see <a href=\"https://en.wikipedia.org/wiki/Bloom_filter\">Bloom filter\n[Wikipedia]</a>\n@since 4.5.0\n", "original_string": "public final class Shape {\n\n    /**\n     * The natural logarithm of 2. Used in several calculations. Approximately 0.693147180559945.\n     */\n    private static final double LN_2 = Math.log(2.0);\n\n    /**\n     * ln(1 / 2^ln(2)). Used in calculating the number of bits. Approximately -0.480453013918201.\n     *\n     * <p>ln(1 / 2^ln(2)) = ln(1) - ln(2^ln(2)) = -ln(2) * ln(2)\n     */\n    private static final double DENOMINATOR = -LN_2 * LN_2;\n\n    /**\n     * Calculates the number of hash functions given numberOfItems and numberOfBits.\n     * This is a method so that the calculation is consistent across all constructors.\n     *\n     * @param numberOfItems the number of items in the filter.\n     * @param numberOfBits the number of bits in the filter.\n     * @return the optimal number of hash functions.\n     * @throws IllegalArgumentException if the calculated number of hash function is {@code < 1}\n     */\n    private static int calculateNumberOfHashFunctions(final int numberOfItems, final int numberOfBits) {\n        // k = round((m / n) * ln(2)) We change order so that we use real math rather\n        // than integer math.\n        final long k = Math.round(LN_2 * numberOfBits / numberOfItems);\n        if (k < 1) {\n            throw new IllegalArgumentException(String.format(\"Filter too small: Calculated number of hash functions (%s) was less than 1\", k));\n        }\n        // Normally we would check that numberOfHashFunctions <= Integer.MAX_VALUE but\n        // since numberOfBits is at most Integer.MAX_VALUE the numerator of\n        // numberOfHashFunctions is ln(2) * Integer.MAX_VALUE = 646456992.9449 the\n        // value of k can not be above Integer.MAX_VALUE.\n        return (int) k;\n    }\n\n    /**\n     * Check the calculated probability is {@code < 1.0}.\n     *\n     * <p>This function is used to verify that the dynamically calculated probability for the\n     * Shape is in the valid range 0 to 1 exclusive. This need only be performed once upon\n     * construction.\n     *\n     * @param probability the probability\n     * @throws IllegalArgumentException if the probability is {@code >= 1.0}.\n     */\n    private static void checkCalculatedProbability(final double probability) {\n        // We do not need to check for p <= 0.0 since we only allow positive values for\n        // parameters and the closest we can come to exp(-kn/m) == 1 is\n        // exp(-1/Integer.MAX_INT) approx 0.9999999995343387 so Math.pow( x, y ) will\n        // always be 0<x<1 and y>0\n        if (probability >= 1.0) {\n            throw new IllegalArgumentException(\"Calculated probability is greater than or equal to 1: \" + probability);\n        }\n    }\n\n    /**\n     * Check number of bits is strictly positive.\n     *\n     * @param numberOfBits the number of bits\n     * @return the number of bits\n     * @throws IllegalArgumentException if the number of bits is {@code < 1}.\n     */\n    private static int checkNumberOfBits(final int numberOfBits) {\n        if (numberOfBits < 1) {\n            throw new IllegalArgumentException(\"Number of bits must be greater than 0: \" + numberOfBits);\n        }\n        return numberOfBits;\n    }\n\n    /**\n     * Check number of hash functions is strictly positive.\n     *\n     * @param numberOfHashFunctions the number of hash functions\n     * @return the number of hash functions\n     * @throws IllegalArgumentException if the number of hash functions is {@code < 1}.\n     */\n    private static int checkNumberOfHashFunctions(final int numberOfHashFunctions) {\n        if (numberOfHashFunctions < 1) {\n            throw new IllegalArgumentException(\"Number of hash functions must be greater than 0: \" + numberOfHashFunctions);\n        }\n        return numberOfHashFunctions;\n    }\n\n    /**\n     * Check number of items is strictly positive.\n     *\n     * @param numberOfItems the number of items\n     * @return the number of items\n     * @throws IllegalArgumentException if the number of items is {@code < 1}.\n     */\n    private static int checkNumberOfItems(final int numberOfItems) {\n        if (numberOfItems < 1) {\n            throw new IllegalArgumentException(\"Number of items must be greater than 0: \" + numberOfItems);\n        }\n        return numberOfItems;\n    }\n\n    /**\n     * Check the probability is in the range 0.0, exclusive, to 1.0, exclusive.\n     *\n     * @param probability the probability\n     * @throws IllegalArgumentException if the probability is not in the range {@code (0, 1)}\n     */\n    private static void checkProbability(final double probability) {\n        // Using the negation of within the desired range will catch NaN\n        if (!(probability > 0.0 && probability < 1.0)) {\n            throw new IllegalArgumentException(\"Probability must be greater than 0 and less than 1: \" + probability);\n        }\n    }\n\n    /**\n     * Constructs a filter configuration with the specified number of hashFunctions ({@code k}) and\n     * bits ({@code m}).\n     *\n     * @param numberOfHashFunctions Number of hash functions to use for each item placed in the filter.\n     * @param numberOfBits The number of bits in the filter\n     * @return a valid Shape.\n     * @throws IllegalArgumentException if {@code numberOfHashFunctions < 1} or {@code numberOfBits < 1}\n     */\n    public static Shape fromKM(final int numberOfHashFunctions, final int numberOfBits) {\n        return new Shape(numberOfHashFunctions, numberOfBits);\n    }\n\n    /**\n     * Constructs a filter configuration with the specified number of items ({@code n}) and\n     * bits ({@code m}).\n     *\n     * <p>The optimal number of hash functions ({@code k}) is computed.\n     * <pre>k = round((m / n) * ln(2))</pre>\n     *\n     * <p>The false-positive probability is computed using the number of items, bits and hash\n     * functions. An exception is raised if this is greater than or equal to 1 (i.e. the\n     * shape is invalid for use as a Bloom filter).\n     *\n     * @param numberOfItems Number of items to be placed in the filter\n     * @param numberOfBits The number of bits in the filter\n     * @return a valid Shape.\n     * @throws IllegalArgumentException if {@code numberOfItems < 1}, {@code numberOfBits < 1},\n     * the calculated number of hash function is {@code < 1}, or if the actual probability is {@code >= 1.0}\n     */\n    public static Shape fromNM(final int numberOfItems, final int numberOfBits) {\n        checkNumberOfItems(numberOfItems);\n        checkNumberOfBits(numberOfBits);\n        final int numberOfHashFunctions = calculateNumberOfHashFunctions(numberOfItems, numberOfBits);\n        final Shape shape = new Shape(numberOfHashFunctions, numberOfBits);\n        // check that probability is within range\n        checkCalculatedProbability(shape.getProbability(numberOfItems));\n        return shape;\n    }\n\n    /**\n     * Constructs a filter configuration with the specified number of items, bits\n     * and hash functions.\n     *\n     * <p>The false-positive probability is computed using the number of items, bits and hash\n     * functions. An exception is raised if this is greater than or equal to 1 (i.e. the\n     * shape is invalid for use as a Bloom filter).\n     *\n     * @param numberOfItems Number of items to be placed in the filter\n     * @param numberOfBits The number of bits in the filter.\n     * @param numberOfHashFunctions The number of hash functions in the filter\n     * @return a valid Shape.\n     * @throws IllegalArgumentException if {@code numberOfItems < 1}, {@code numberOfBits < 1},\n     * {@code numberOfHashFunctions < 1}, or if the actual probability is {@code >= 1.0}.\n     */\n    public static Shape fromNMK(final int numberOfItems, final int numberOfBits, final int numberOfHashFunctions) {\n        checkNumberOfItems(numberOfItems);\n        checkNumberOfBits(numberOfBits);\n        checkNumberOfHashFunctions(numberOfHashFunctions);\n        // check that probability is within range\n        final Shape shape = new Shape(numberOfHashFunctions, numberOfBits);\n        // check that probability is within range\n        checkCalculatedProbability(shape.getProbability(numberOfItems));\n        return shape;\n    }\n\n    /**\n     * Constructs a filter configuration with the specified number of items ({@code n}) and\n     * desired false-positive probability ({@code p}).\n     *\n     * <p>The number of bits ({@code m}) for the filter is computed.\n     * <pre>m = ceil(n * ln(p) / ln(1 / 2^ln(2)))</pre>\n     *\n     * <p>The optimal number of hash functions ({@code k}) is computed.\n     * <pre>k = round((m / n) * ln(2))</pre>\n     *\n     * <p>The actual probability will be approximately equal to the\n     * desired probability but will be dependent upon the calculated number of bits and hash\n     * functions. An exception is raised if this is greater than or equal to 1 (i.e. the\n     * shape is invalid for use as a Bloom filter).\n     *\n     * @param numberOfItems Number of items to be placed in the filter\n     * @param probability The desired false-positive probability in the range {@code (0, 1)}\n     * @return a valid Shape\n     * @throws IllegalArgumentException if {@code numberOfItems < 1}, if the desired probability\n     * is not in the range {@code (0, 1)} or if the actual probability is {@code >= 1.0}.\n     */\n    public static Shape fromNP(final int numberOfItems, final double probability) {\n        checkNumberOfItems(numberOfItems);\n        checkProbability(probability);\n\n        // Number of bits (m)\n        final double m = Math.ceil(numberOfItems * Math.log(probability) / DENOMINATOR);\n        if (m > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\"Resulting filter has more than \" + Integer.MAX_VALUE + \" bits: \" + m);\n        }\n        final int numberOfBits = (int) m;\n\n        final int numberOfHashFunctions = calculateNumberOfHashFunctions(numberOfItems, numberOfBits);\n        final Shape shape = new Shape(numberOfHashFunctions, numberOfBits);\n        // check that probability is within range\n        checkCalculatedProbability(shape.getProbability(numberOfItems));\n        return shape;\n    }\n\n    /**\n     * Constructs a filter configuration with a desired false-positive probability ({@code p}) and the\n     * specified number of bits ({@code m}) and hash functions ({@code k}).\n     *\n     * <p>The number of items ({@code n}) to be stored in the filter is computed.\n     * <pre>n = ceil(m / (-k / ln(1 - exp(ln(p) / k))))</pre>\n     *\n     * <p>The actual probability will be approximately equal to the\n     * desired probability but will be dependent upon the calculated Bloom filter capacity\n     * (number of items). An exception is raised if this is greater than or equal to 1 (i.e. the\n     * shape is invalid for use as a Bloom filter).\n     *\n     * @param probability The desired false-positive probability in the range {@code (0, 1)}\n     * @param numberOfBits The number of bits in the filter\n     * @param numberOfHashFunctions The number of hash functions in the filter\n     * @return a valid Shape.\n     * @throws IllegalArgumentException if the desired probability is not in the range {@code (0, 1)},\n     * {@code numberOfBits < 1}, {@code numberOfHashFunctions < 1}, or the actual\n     * probability is {@code >= 1.0}\n     */\n    public static Shape fromPMK(final double probability, final int numberOfBits, final int numberOfHashFunctions) {\n        checkProbability(probability);\n        checkNumberOfBits(numberOfBits);\n        checkNumberOfHashFunctions(numberOfHashFunctions);\n\n        // Number of items (n):\n        // n = ceil(m / (-k / ln(1 - exp(ln(p) / k))))\n        final double n = Math.ceil(numberOfBits / (-numberOfHashFunctions / Math.log(-Math.expm1(Math.log(probability) / numberOfHashFunctions))));\n\n        // log of probability is always < 0\n        // number of hash functions is >= 1\n        // e^x where x < 0 = [0,1)\n        // log 1-e^x = [log1, log0) = <0 with an effective lower limit of -53\n        // numberOfBits/ (-numberOfHashFunctions / [-53,0) ) >0\n        // ceil( >0 ) >= 1\n        // so we can not produce a negative value thus we don't check for it.\n        //\n        // similarly we can not produce a number greater than numberOfBits so we\n        // do not have to check for Integer.MAX_VALUE either.\n\n        final Shape shape = new Shape(numberOfHashFunctions, numberOfBits);\n        // check that probability is within range\n        checkCalculatedProbability(shape.getProbability((int) n));\n        return shape;\n    }\n\n    /**\n     * Number of hash functions to create a filter ({@code k}).\n     */\n    private final int numberOfHashFunctions;\n\n    /**\n     * Number of bits in the filter ({@code m}).\n     */\n    private final int numberOfBits;\n\n    /**\n     * Constructs a filter configuration with the specified number of hashFunctions ({@code k}) and\n     * bits ({@code m}).\n     *\n     * @param numberOfHashFunctions Number of hash functions to use for each item placed in the filter.\n     * @param numberOfBits The number of bits in the filter\n     * @throws IllegalArgumentException if {@code numberOfHashFunctions < 1} or {@code numberOfBits < 1}\n     */\n    private Shape(final int numberOfHashFunctions, final int numberOfBits) {\n        this.numberOfHashFunctions = checkNumberOfHashFunctions(numberOfHashFunctions);\n        this.numberOfBits = checkNumberOfBits(numberOfBits);\n    }\n\n    @Override\n    public boolean equals(final Object obj) {\n        // Shape is final so no check for the same class as inheritance is not possible\n        if (obj instanceof Shape) {\n            final Shape other = (Shape) obj;\n            return numberOfBits == other.numberOfBits && numberOfHashFunctions == other.numberOfHashFunctions;\n        }\n        return false;\n    }\n\n    /**\n     * Estimates the maximum number of elements that can be merged into a filter of\n     * this shape before the false positive rate exceeds the desired rate. <p> The\n     * formula for deriving {@code k} when {@code m} and {@code n} are known is:\n     *\n     * <p>{@code k = ln2 * m / n}</p>\n     *\n     * <p>Solving for {@code n} yields:</p>\n     *\n     * <p>{@code n = ln2 * m / k}</p>\n     *\n     * @return An estimate of max N.\n     */\n    public double estimateMaxN() {\n        return numberOfBits * LN_2 / numberOfHashFunctions;\n    }\n\n    /**\n     * Estimate the number of items in a Bloom filter with this shape and the specified number of bits enabled.\n     *\n     * <p><em>Note:</em></p>\n     * <ul>\n     * <li> if cardinality == numberOfBits, then result is infinity.</li>\n     * <li> if cardinality &gt; numberOfBits, then result is NaN.</li>\n     * </ul>\n     *\n     * @param cardinality the number of enabled  bits also known as the hamming value.\n     * @return An estimate of the number of items in the Bloom filter.\n     */\n    public double estimateN(final int cardinality) {\n        final double c = cardinality;\n        final double m = numberOfBits;\n        final double k = numberOfHashFunctions;\n        return -(m / k) * Math.log1p(-c / m);\n    }\n\n    /**\n     * Gets the number of bits in the Bloom filter.\n     * This is also known as {@code m}.\n     *\n     * @return the number of bits in the Bloom filter ({@code m}).\n     */\n    public int getNumberOfBits() {\n        return numberOfBits;\n    }\n\n    /**\n     * Gets the number of hash functions used to construct the filter.\n     * This is also known as {@code k}.\n     *\n     * @return the number of hash functions used to construct the filter ({@code k}).\n     */\n    public int getNumberOfHashFunctions() {\n        return numberOfHashFunctions;\n    }\n\n    /**\n     * Calculates the probability of false positives ({@code p}) given\n     * numberOfItems ({@code n}), numberOfBits ({@code m}) and numberOfHashFunctions ({@code k}).\n     * <pre>p = pow(1 - exp(-k / (m / n)), k)</pre>\n     *\n     * <p>This is the probability that a Bloom filter will return true for the presence of an item\n     * when it does not contain the item.</p>\n     *\n     * <p>The probability assumes that the Bloom filter is filled with the expected number of\n     * items. If the filter contains fewer items then the actual probability will be lower.\n     * Thus, this returns the worst-case false positive probability for a filter that has not\n     * exceeded its expected number of items.</p>\n     *\n     * @param numberOfItems the number of items hashed into the Bloom filter.\n     * @return the probability of false positives.\n     */\n    public double getProbability(final int numberOfItems) {\n        if (numberOfItems < 0) {\n            throw new IllegalArgumentException(\"Number of items must be greater than or equal to 0: \" + numberOfItems);\n        }\n        if (numberOfItems == 0) {\n            return 0;\n        }\n        return Math.pow(-Math.expm1(-1.0 * numberOfHashFunctions * numberOfItems / numberOfBits), numberOfHashFunctions);\n    }\n\n    @Override\n    public int hashCode() {\n        // Match Arrays.hashCode(new int[] {numberOfBits, numberOfHashFunctions})\n        return (31 + numberOfBits) * 31 + numberOfHashFunctions;\n    }\n\n    /**\n     * Determines if a cardinality is sparse based on the shape.\n     * <p>This method assumes that bit maps are 64bits and indexes are 32bits. If the memory\n     * necessary to store the cardinality as indexes is less than the estimated memory for bit maps,\n     * the cardinality is determined to be {@code sparse}.</p>\n     * @param cardinality the cardinality to check.\n     * @return true if the cardinality is sparse within the shape.\n     */\n    public boolean isSparse(final int cardinality) {\n        /*\n         * Since the size of a bit map is a long and the size of an index is an int,\n         * there can be 2 indexes for each bit map. In Bloom filters indexes are evenly\n         * distributed across the range of possible values, Thus if the cardinality\n         * (number of indexes) is less than or equal to 2*number of bit maps the\n         * cardinality is sparse within the shape.\n         */\n        return cardinality <= BitMaps.numberOfBitMaps(getNumberOfBits()) * 2;\n    }\n\n    @Override\n    public String toString() {\n        return String.format(\"Shape[k=%s m=%s]\", numberOfHashFunctions, numberOfBits);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final double LN_2 = Math.log(2.0);", "docstring": "\nThe natural logarithm of 2. Used in several calculations. Approximately 0.693147180559945.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "double", "name": "LN_2 = Math.log(2.0)", "syntax_pass": true}, {"attribute_expression": "private static final double DENOMINATOR = -LN_2 * LN_2;", "docstring": "\nln(1 / 2^ln(2)). Used in calculating the number of bits. Approximately -0.480453013918201.\n\n<p>ln(1 / 2^ln(2)) = ln(1) - ln(2^ln(2)) = -ln(2) * ln(2)\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "double", "name": "DENOMINATOR = -LN_2 * LN_2", "syntax_pass": true}, {"attribute_expression": "private final int numberOfHashFunctions;", "docstring": "\nNumber of hash functions to create a filter ({@code k}).\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "numberOfHashFunctions", "syntax_pass": true}, {"attribute_expression": "private final int numberOfBits;", "docstring": "\nNumber of bits in the filter ({@code m}).\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "numberOfBits", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/bloomfilter/SetOperations.java.SetOperations", "name": "SetOperations", "file_path": "src/main/java/org/apache/commons/collections4/bloomfilter/SetOperations.java", "superclasses": "", "methods": ["[int]andCardinality(BitMapExtractor,BitMapExtractor)", "[int]cardinality(BitMapExtractor)", "[int]cardinality(BitMapExtractor,BitMapExtractor,LongBinaryOperator)", "[double]cosineDistance(BitMapExtractor,BitMapExtractor)", "[double]cosineSimilarity(BitMapExtractor,BitMapExtractor)", "[double]cosineSimilarity(BloomFilter,BloomFilter)", "[int]hammingDistance(BitMapExtractor,BitMapExtractor)", "[double]jaccardDistance(BitMapExtractor,BitMapExtractor)", "[double]jaccardSimilarity(BitMapExtractor,BitMapExtractor)", "[int]orCardinality(BitMapExtractor,BitMapExtractor)", "[int]xorCardinality(BitMapExtractor,BitMapExtractor)", "[]SetOperations()"], "method_uris": ["src/main/java/org/apache/commons/collections4/bloomfilter/SetOperations.java.SetOperations.[int]andCardinality(BitMapExtractor,BitMapExtractor)", "src/main/java/org/apache/commons/collections4/bloomfilter/SetOperations.java.SetOperations.[int]cardinality(BitMapExtractor)", "src/main/java/org/apache/commons/collections4/bloomfilter/SetOperations.java.SetOperations.[int]cardinality(BitMapExtractor,BitMapExtractor,LongBinaryOperator)", "src/main/java/org/apache/commons/collections4/bloomfilter/SetOperations.java.SetOperations.[double]cosineDistance(BitMapExtractor,BitMapExtractor)", "src/main/java/org/apache/commons/collections4/bloomfilter/SetOperations.java.SetOperations.[double]cosineSimilarity(BitMapExtractor,BitMapExtractor)", "src/main/java/org/apache/commons/collections4/bloomfilter/SetOperations.java.SetOperations.[double]cosineSimilarity(BloomFilter,BloomFilter)", "src/main/java/org/apache/commons/collections4/bloomfilter/SetOperations.java.SetOperations.[int]hammingDistance(BitMapExtractor,BitMapExtractor)", "src/main/java/org/apache/commons/collections4/bloomfilter/SetOperations.java.SetOperations.[double]jaccardDistance(BitMapExtractor,BitMapExtractor)", "src/main/java/org/apache/commons/collections4/bloomfilter/SetOperations.java.SetOperations.[double]jaccardSimilarity(BitMapExtractor,BitMapExtractor)", "src/main/java/org/apache/commons/collections4/bloomfilter/SetOperations.java.SetOperations.[int]orCardinality(BitMapExtractor,BitMapExtractor)", "src/main/java/org/apache/commons/collections4/bloomfilter/SetOperations.java.SetOperations.[int]xorCardinality(BitMapExtractor,BitMapExtractor)", "src/main/java/org/apache/commons/collections4/bloomfilter/SetOperations.java.SetOperations.[]SetOperations()"], "overrides": null, "attributes": [], "class_docstring": "\nImplementations of set operations on BitMapExtractors.\n\n@since 4.5.0\n", "original_string": "public final class SetOperations {\n\n    /**\n     * Calculates the cardinality of the logical {@code AND} of the bit maps for the two filters.\n     * @param first the first BitMapExtractor.\n     * @param second the second BitMapExtractor\n     * @return the cardinality of the {@code AND} of the filters.\n     */\n    public static int andCardinality(final BitMapExtractor first, final BitMapExtractor second) {\n        return cardinality(first, second, (x, y) -> x & y);\n    }\n\n    /**\n     * Calculates the cardinality of a BitMapExtractor. By necessity this method will visit each bit map\n     * created by the bitMapExtractor.\n     * @param bitMapExtractor the extractor to calculate the cardinality for.\n     * @return the cardinality of the bit maps produced by the bitMapExtractor.\n     */\n    public static int cardinality(final BitMapExtractor bitMapExtractor) {\n        final int[] cardinality = new int[1];\n        bitMapExtractor.processBitMaps(l -> {\n            cardinality[0] += Long.bitCount(l);\n            return true;\n        });\n        return cardinality[0];\n    }\n\n    /**\n     * Calculates the cardinality of the result of a LongBinaryOperator using the\n     * {@code BitMapExtractor.makePredicate} method.\n     * @param first the first BitMapExtractor\n     * @param second the second BitMapExtractor\n     * @param op a long binary operation on where x = {@code first} and y = {@code second} bitmap extractors.\n     * @return the calculated cardinality.\n     */\n    private static int cardinality(final BitMapExtractor first, final BitMapExtractor second, final LongBinaryOperator op) {\n        final int[] cardinality = new int[1];\n\n        first.processBitMapPairs(second, (x, y) -> {\n            cardinality[0] += Long.bitCount(op.applyAsLong(x, y));\n            return true;\n        });\n        return cardinality[0];\n    }\n\n    /**\n     * Calculates the Cosine distance between two BitMapExtractor.\n     *\n     * <p>Cosine distance is defined as {@code 1 - Cosine similarity}</p>\n     *\n     * @param first the first BitMapExtractor.\n     * @param second the second BitMapExtractor.\n     * @return the jaccard distance.\n     */\n    public static double cosineDistance(final BitMapExtractor first, final BitMapExtractor second) {\n        return 1.0 - cosineSimilarity(first, second);\n    }\n\n    /**\n     * Calculates the Cosine similarity between two BitMapExtractors.\n     * <p> Also known as Orchini similarity and the Tucker coefficient of congruence or\n     * Ochiai similarity.</p>\n     *\n     * <p>If either extractor is empty the result is 0 (zero)</p>\n     *\n     * @param first the first BitMapExtractor.\n     * @param second the second BitMapExtractor.\n     * @return the Cosine similarity.\n     */\n    public static double cosineSimilarity(final BitMapExtractor first, final BitMapExtractor second) {\n        final int numerator = andCardinality(first, second);\n        // Given that the cardinality is an int then the product as a double will not\n        // overflow, we can use one sqrt:\n        return numerator == 0 ? 0 : numerator / Math.sqrt(cardinality(first) * cardinality(second));\n    }\n\n    /**\n     * Calculates the Cosine similarity between two Bloom filters.\n     * <p> Also known as Orchini similarity and the Tucker coefficient of congruence or\n     * Ochiai similarity.</p>\n     *\n     * <p>If either filter is empty (no enabled bits) the result is 0 (zero)</p>\n     *\n     * <p>This is a version of cosineSimilarity optimized for Bloom filters.</p>\n     *\n     * @param first the first Bloom filter.\n     * @param second the second Bloom filter.\n     * @return the Cosine similarity.\n     */\n    public static double cosineSimilarity(final BloomFilter first, final BloomFilter second) {\n        final int numerator = andCardinality(first, second);\n        // Given that the cardinality is an int then the product as a double will not\n        // overflow, we can use one sqrt:\n        return numerator == 0 ? 0 : numerator / Math.sqrt(first.cardinality() * second.cardinality());\n    }\n\n    /**\n     * Calculates the Hamming distance between two BitMapExtractors.\n     *\n     * @param first the first BitMapExtractor.\n     * @param second the second BitMapExtractor.\n     * @return the Hamming distance.\n     */\n    public static int hammingDistance(final BitMapExtractor first, final BitMapExtractor second) {\n        return xorCardinality(first, second);\n    }\n\n    /**\n     * Calculates the Jaccard distance between two BitMapExtractor.\n     *\n     * <p>Jaccard distance is defined as {@code 1 - Jaccard similarity}</p>\n     *\n     * @param first the first BitMapExtractor.\n     * @param second the second BitMapExtractor.\n     * @return the Jaccard distance.\n     */\n    public static double jaccardDistance(final BitMapExtractor first, final BitMapExtractor second) {\n        return 1.0 - jaccardSimilarity(first, second);\n    }\n\n    /**\n     * Calculates the Jaccard similarity between two BitMapExtractor.\n     *\n     * <p>Also known as Jaccard index, Intersection over Union, and Jaccard similarity coefficient</p>\n     *\n     * @param first the first BitMapExtractor.\n     * @param second the second BitMapExtractor.\n     * @return the Jaccard similarity.\n     */\n    public static double jaccardSimilarity(final BitMapExtractor first, final BitMapExtractor second) {\n        final int[] cardinality = new int[2];\n        first.processBitMapPairs(second, (x, y) -> {\n            cardinality[0] += Long.bitCount(x & y);\n            cardinality[1] += Long.bitCount(x | y);\n            return true;\n        });\n        final int intersection = cardinality[0];\n        return intersection == 0 ? 0 : intersection / (double) cardinality[1];\n    }\n\n    /**\n     * Calculates the cardinality of the logical {@code OR} of the bit maps for the two filters.\n     * @param first the first BitMapExtractor.\n     * @param second the second BitMapExtractor\n     * @return the cardinality of the {@code OR} of the filters.\n     */\n    public static int orCardinality(final BitMapExtractor first, final BitMapExtractor second) {\n        return cardinality(first, second, (x, y) -> x | y);\n    }\n\n    /**\n     * Calculates the cardinality of the logical {@code XOR} of the bit maps for the two filters.\n     * @param first the first BitMapExtractor.\n     * @param second the second BitMapExtractor\n     * @return the cardinality of the {@code XOR} of the filters.\n     */\n    public static int xorCardinality(final BitMapExtractor first, final BitMapExtractor second) {\n        return cardinality(first, second, (x, y) -> x ^ y);\n    }\n\n    /**\n     * Do not instantiate.\n     */\n    private SetOperations() {\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/org/apache/commons/collections4/bloomfilter/SimpleBloomFilter.java.SimpleBloomFilter", "name": "SimpleBloomFilter", "file_path": "src/main/java/org/apache/commons/collections4/bloomfilter/SimpleBloomFilter.java", "superclasses": "", "methods": ["[]SimpleBloomFilter(Shape)", "[]SimpleBloomFilter(SimpleBloomFilter)", "[long[]]asBitMapArray()", "[int]cardinality()", "[int]characteristics()", "[void]clear()", "[boolean]contains(IndexExtractor)", "[SimpleBloomFilter]copy()", "[Shape]getShape()", "[boolean]isEmpty()", "[boolean]merge(BitMapExtractor)", "[boolean]merge(BloomFilter)", "[boolean]merge(Hasher)", "[boolean]merge(IndexExtractor)", "[boolean]processBitMapPairs(BitMapExtractor,LongBiPredicate)", "[boolean]processBitMaps(LongPredicate)", "[boolean]processIndices(IntPredicate)"], "method_uris": ["src/main/java/org/apache/commons/collections4/bloomfilter/SimpleBloomFilter.java.SimpleBloomFilter.[]SimpleBloomFilter(Shape)", "src/main/java/org/apache/commons/collections4/bloomfilter/SimpleBloomFilter.java.SimpleBloomFilter.[]SimpleBloomFilter(SimpleBloomFilter)", "src/main/java/org/apache/commons/collections4/bloomfilter/SimpleBloomFilter.java.SimpleBloomFilter.[long[]]asBitMapArray()", "src/main/java/org/apache/commons/collections4/bloomfilter/SimpleBloomFilter.java.SimpleBloomFilter.[int]cardinality()", "src/main/java/org/apache/commons/collections4/bloomfilter/SimpleBloomFilter.java.SimpleBloomFilter.[int]characteristics()", "src/main/java/org/apache/commons/collections4/bloomfilter/SimpleBloomFilter.java.SimpleBloomFilter.[void]clear()", "src/main/java/org/apache/commons/collections4/bloomfilter/SimpleBloomFilter.java.SimpleBloomFilter.[boolean]contains(IndexExtractor)", "src/main/java/org/apache/commons/collections4/bloomfilter/SimpleBloomFilter.java.SimpleBloomFilter.[SimpleBloomFilter]copy()", "src/main/java/org/apache/commons/collections4/bloomfilter/SimpleBloomFilter.java.SimpleBloomFilter.[Shape]getShape()", "src/main/java/org/apache/commons/collections4/bloomfilter/SimpleBloomFilter.java.SimpleBloomFilter.[boolean]isEmpty()", "src/main/java/org/apache/commons/collections4/bloomfilter/SimpleBloomFilter.java.SimpleBloomFilter.[boolean]merge(BitMapExtractor)", "src/main/java/org/apache/commons/collections4/bloomfilter/SimpleBloomFilter.java.SimpleBloomFilter.[boolean]merge(BloomFilter)", "src/main/java/org/apache/commons/collections4/bloomfilter/SimpleBloomFilter.java.SimpleBloomFilter.[boolean]merge(Hasher)", "src/main/java/org/apache/commons/collections4/bloomfilter/SimpleBloomFilter.java.SimpleBloomFilter.[boolean]merge(IndexExtractor)", "src/main/java/org/apache/commons/collections4/bloomfilter/SimpleBloomFilter.java.SimpleBloomFilter.[boolean]processBitMapPairs(BitMapExtractor,LongBiPredicate)", "src/main/java/org/apache/commons/collections4/bloomfilter/SimpleBloomFilter.java.SimpleBloomFilter.[boolean]processBitMaps(LongPredicate)", "src/main/java/org/apache/commons/collections4/bloomfilter/SimpleBloomFilter.java.SimpleBloomFilter.[boolean]processIndices(IntPredicate)"], "overrides": null, "attributes": [], "class_docstring": "\nA bloom filter using an array of bit maps to track enabled bits. This is a standard\nimplementation and should work well for most Bloom filters.\n@since 4.5.0\n", "original_string": "public final class SimpleBloomFilter implements BloomFilter {\n\n    /**\n     * The array of bit map longs that defines this Bloom filter. Will be null if the filter is empty.\n     */\n    private final long[] bitMap;\n\n    /**\n     * The Shape of this Bloom filter.\n     */\n    private final Shape shape;\n\n    /**\n     * The cardinality of this Bloom filter.\n     */\n    private int cardinality;\n\n    /**\n     * Creates an empty instance.\n     *\n     * @param shape The shape for the filter.\n     */\n    public SimpleBloomFilter(final Shape shape) {\n        Objects.requireNonNull(shape, \"shape\");\n        this.shape = shape;\n        this.bitMap = new long[BitMaps.numberOfBitMaps(shape.getNumberOfBits())];\n        this.cardinality = 0;\n    }\n\n    /**\n     * Copy constructor for {@code copy()} use.\n     * @param source\n     */\n    private SimpleBloomFilter(final SimpleBloomFilter source) {\n        this.shape = source.shape;\n        this.bitMap = source.bitMap.clone();\n        this.cardinality = source.cardinality;\n    }\n\n    @Override\n    public long[] asBitMapArray() {\n        return Arrays.copyOf(bitMap, bitMap.length);\n    }\n\n    @Override\n    public int cardinality() {\n        // Lazy evaluation with caching\n        int c = cardinality;\n        if (c < 0) {\n            cardinality = c = SetOperations.cardinality(this);\n        }\n        return c;\n    }\n\n    @Override\n    public int characteristics() {\n        return 0;\n    }\n\n    @Override\n    public void clear() {\n        Arrays.fill(bitMap, 0L);\n        cardinality = 0;\n    }\n\n    @Override\n    public boolean contains(final IndexExtractor indexExtractor) {\n        return indexExtractor.processIndices(idx -> BitMaps.contains(bitMap, idx));\n    }\n\n    @Override\n    public SimpleBloomFilter copy() {\n        return new SimpleBloomFilter(this);\n    }\n\n    @Override\n    public Shape getShape() {\n        return shape;\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return cardinality == 0 || processBitMaps(y -> y == 0);\n    }\n\n    @Override\n    public boolean merge(final BitMapExtractor bitMapExtractor) {\n        Objects.requireNonNull(bitMapExtractor, \"bitMapExtractor\");\n        try {\n            final int[] idx = new int[1];\n            bitMapExtractor.processBitMaps(value -> {\n                bitMap[idx[0]++] |= value;\n                return true;\n            });\n            // idx[0] will be limit+1 so decrement it\n            idx[0]--;\n            final int idxLimit = BitMaps.getLongIndex(shape.getNumberOfBits());\n            if (idxLimit == idx[0]) {\n                final long excess = bitMap[idxLimit] >> shape.getNumberOfBits();\n                if (excess != 0) {\n                    throw new IllegalArgumentException(\n                            String.format(\"BitMapExtractor set a bit higher than the limit for the shape: %s\",\n                                    shape.getNumberOfBits()));\n                }\n            }\n            cardinality = -1;\n        } catch (final IndexOutOfBoundsException e) {\n            throw new IllegalArgumentException(\n                    String.format(\"BitMapExtractor should send at most %s maps\", bitMap.length), e);\n        }\n        return true;\n    }\n\n    @Override\n    public boolean merge(final BloomFilter other) {\n        Objects.requireNonNull(other, \"other\");\n        if ((other.characteristics() & SPARSE) != 0) {\n            merge((IndexExtractor) other);\n        } else {\n            merge((BitMapExtractor) other);\n        }\n        return true;\n    }\n\n    @Override\n    public boolean merge(final Hasher hasher) {\n        Objects.requireNonNull(hasher, \"hasher\");\n        return merge(hasher.indices(shape));\n    }\n\n    @Override\n    public boolean merge(final IndexExtractor indexExtractor) {\n        Objects.requireNonNull(indexExtractor, \"indexExtractor\");\n        indexExtractor.processIndices(idx -> {\n            if (idx < 0 || idx >= shape.getNumberOfBits()) {\n                throw new IllegalArgumentException(String.format(\n                        \"IndexExtractor should only send values in the range[0,%s)\", shape.getNumberOfBits()));\n            }\n            BitMaps.set(bitMap, idx);\n            return true;\n        });\n        cardinality = -1;\n        return true;\n    }\n\n    @Override\n    public boolean processBitMapPairs(final BitMapExtractor other, final LongBiPredicate func) {\n        final CountingLongPredicate p = new CountingLongPredicate(bitMap, func);\n        return other.processBitMaps(p) && p.processRemaining();\n    }\n\n    @Override\n    public boolean processBitMaps(final LongPredicate consumer) {\n        Objects.requireNonNull(consumer, \"consumer\");\n        for (final long l : bitMap) {\n            if (!consumer.test(l)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    @Override\n    public boolean processIndices(final IntPredicate consumer) {\n        Objects.requireNonNull(consumer, \"consumer\");\n        return IndexExtractor.fromBitMapExtractor(this).processIndices(consumer);\n    }\n}", "super_interfaces": ["BloomFilter"], "fields": [{"attribute_expression": "private final long[] bitMap;", "docstring": "\nThe array of bit map longs that defines this Bloom filter. Will be null if the filter is empty.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "long[]", "name": "bitMap", "syntax_pass": true}, {"attribute_expression": "private final Shape shape;", "docstring": "\nThe Shape of this Bloom filter.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Shape", "name": "shape", "syntax_pass": true}, {"attribute_expression": "private int cardinality;", "docstring": "\nThe cardinality of this Bloom filter.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "cardinality", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/bloomfilter/IndexFilter.java.IndexFilter", "name": "IndexFilter", "file_path": "src/main/java/org/apache/commons/collections4/bloomfilter/IndexFilter.java", "superclasses": "", "methods": ["[IntPredicate]create(Shape,IntPredicate)", "[]IndexFilter(Shape,IntPredicate)", "[boolean]test(int)"], "method_uris": ["src/main/java/org/apache/commons/collections4/bloomfilter/IndexFilter.java.IndexFilter.[IntPredicate]create(Shape,IntPredicate)", "src/main/java/org/apache/commons/collections4/bloomfilter/IndexFilter.java.IndexFilter.[]IndexFilter(Shape,IntPredicate)", "src/main/java/org/apache/commons/collections4/bloomfilter/IndexFilter.java.IndexFilter.[boolean]test(int)"], "overrides": null, "attributes": [{"original_string": "    static class ArrayTracker implements IntPredicate {\n        private final int[] seen;\n        private int populated;\n\n        /**\n         * Constructs the tracker based on the shape.\n         * @param shape the shape to build the tracker for.\n         */\n        ArrayTracker(final Shape shape) {\n            seen = new int[shape.getNumberOfHashFunctions()];\n        }\n\n        @Override\n        public boolean test(final int number) {\n            if (number < 0) {\n                throw new IndexOutOfBoundsException(\"number may not be less than zero. \" + number);\n            }\n            for (int i = 0; i < populated; i++) {\n                if (seen[i] == number) {\n                    return false;\n                }\n            }\n            seen[populated++] = number;\n            return true;\n        }\n    }", "definition": "    static class ArrayTracker implements IntPredicate", "class_docstring": "\nAn IndexTracker implementation that uses an array of integers to track whether or not a\nnumber has been seen. Suitable for Shapes that have few hash functions.\n@since 4.5.0\n", "name": "ArrayTracker", "super_interfaces": ["IntPredicate"], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "private final int[] seen;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int[]", "name": "seen", "syntax_pass": true}, {"attribute_expression": "private int populated;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "populated", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        ArrayTracker(final Shape shape) {\n            seen = new int[shape.getNumberOfHashFunctions()];\n        }", "docstring": "\nConstructs the tracker based on the shape.\n@param shape the shape to build the tracker for.\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "ArrayTracker", "params": [{"name": "shape", "type": "Shape"}], "body": "                                        {\n            seen = new int[shape.getNumberOfHashFunctions()];\n        }", "signature": "ArrayTracker(final Shape shape)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean test(final int number) {\n            if (number < 0) {\n                throw new IndexOutOfBoundsException(\"number may not be less than zero. \" + number);\n            }\n            for (int i = 0; i < populated; i++) {\n                if (seen[i] == number) {\n                    return false;\n                }\n            }\n            seen[populated++] = number;\n            return true;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "test", "params": [{"name": "number", "type": "int"}], "body": "                                              {\n            if (number < 0) {\n                throw new IndexOutOfBoundsException(\"number may not be less than zero. \" + number);\n            }\n            for (int i = 0; i < populated; i++) {\n                if (seen[i] == number) {\n                    return false;\n                }\n            }\n            seen[populated++] = number;\n            return true;\n        }", "signature": "@Override\n        public boolean test(final int number)"}]}, {"original_string": "    static class BitMapTracker implements IntPredicate {\n        private final long[] bits;\n\n        /**\n         * Constructs a bit map based tracker for the specified shape.\n         * @param shape The shape that is being generated.\n         */\n        BitMapTracker(final Shape shape) {\n            bits = new long[BitMaps.numberOfBitMaps(shape.getNumberOfBits())];\n        }\n\n        @Override\n        public boolean test(final int number) {\n            final boolean retval = !BitMaps.contains(bits, number);\n            BitMaps.set(bits, number);\n            return retval;\n        }\n    }", "definition": "    static class BitMapTracker implements IntPredicate", "class_docstring": "\nAn IndexTracker implementation that uses an array of bit maps to track whether or not a\nnumber has been seen.\n@since 4.5.0\n", "name": "BitMapTracker", "super_interfaces": ["IntPredicate"], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "private final long[] bits;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "long[]", "name": "bits", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        BitMapTracker(final Shape shape) {\n            bits = new long[BitMaps.numberOfBitMaps(shape.getNumberOfBits())];\n        }", "docstring": "\nConstructs a bit map based tracker for the specified shape.\n@param shape The shape that is being generated.\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "BitMapTracker", "params": [{"name": "shape", "type": "Shape"}], "body": "                                         {\n            bits = new long[BitMaps.numberOfBitMaps(shape.getNumberOfBits())];\n        }", "signature": "BitMapTracker(final Shape shape)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean test(final int number) {\n            final boolean retval = !BitMaps.contains(bits, number);\n            BitMaps.set(bits, number);\n            return retval;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "test", "params": [{"name": "number", "type": "int"}], "body": "                                              {\n            final boolean retval = !BitMaps.contains(bits, number);\n            BitMaps.set(bits, number);\n            return retval;\n        }", "signature": "@Override\n        public boolean test(final int number)"}]}], "class_docstring": "\nA convenience class for Hasher implementations to filter out duplicate indices.\n\n<p><em>If the index is negative the behavior is not defined.</em></p>\n\n<p>This is conceptually a unique filter implemented as an {@link IntPredicate}.</p>\n\n@since 4.5.0\n", "original_string": "public final class IndexFilter {\n    /**\n     * An IndexTracker implementation that uses an array of integers to track whether or not a\n     * number has been seen. Suitable for Shapes that have few hash functions.\n     * @since 4.5.0\n     */\n    static class ArrayTracker implements IntPredicate {\n        private final int[] seen;\n        private int populated;\n\n        /**\n         * Constructs the tracker based on the shape.\n         * @param shape the shape to build the tracker for.\n         */\n        ArrayTracker(final Shape shape) {\n            seen = new int[shape.getNumberOfHashFunctions()];\n        }\n\n        @Override\n        public boolean test(final int number) {\n            if (number < 0) {\n                throw new IndexOutOfBoundsException(\"number may not be less than zero. \" + number);\n            }\n            for (int i = 0; i < populated; i++) {\n                if (seen[i] == number) {\n                    return false;\n                }\n            }\n            seen[populated++] = number;\n            return true;\n        }\n    }\n    /**\n     * An IndexTracker implementation that uses an array of bit maps to track whether or not a\n     * number has been seen.\n     * @since 4.5.0\n     */\n    static class BitMapTracker implements IntPredicate {\n        private final long[] bits;\n\n        /**\n         * Constructs a bit map based tracker for the specified shape.\n         * @param shape The shape that is being generated.\n         */\n        BitMapTracker(final Shape shape) {\n            bits = new long[BitMaps.numberOfBitMaps(shape.getNumberOfBits())];\n        }\n\n        @Override\n        public boolean test(final int number) {\n            final boolean retval = !BitMaps.contains(bits, number);\n            BitMaps.set(bits, number);\n            return retval;\n        }\n    }\n    /**\n     * Creates an instance optimized for the specified shape.\n     * @param shape The shape that is being generated.\n     * @param consumer The consumer to accept the values.\n     * @return an IndexFilter optimized for the specified shape.\n     */\n    public static IntPredicate create(final Shape shape, final IntPredicate consumer) {\n        return new IndexFilter(shape, consumer)::test;\n    }\n\n    private final IntPredicate tracker;\n\n    private final int size;\n\n    private final IntPredicate consumer;\n\n    /**\n     * Creates an instance optimized for the specified shape.\n     * @param shape The shape that is being generated.\n     * @param consumer The consumer to accept the values.\n     */\n    private IndexFilter(final Shape shape, final IntPredicate consumer) {\n        this.size = shape.getNumberOfBits();\n        this.consumer = consumer;\n        if (BitMaps.numberOfBitMaps(shape.getNumberOfBits()) * Long.BYTES < (long) shape.getNumberOfHashFunctions()\n                * Integer.BYTES) {\n            this.tracker = new BitMapTracker(shape);\n        } else {\n            this.tracker = new ArrayTracker(shape);\n        }\n    }\n\n    /**\n     * Test if the number should be processed by the {@code consumer}.\n     *\n     * <p>If the number has <em>not</em> been seen before it is passed to the {@code consumer} and the result returned.\n     * If the number has been seen before the {@code consumer} is not called and {@code true} returned.</p>\n     *\n     * <p><em>If the input is not in the range [0,size) an IndexOutOfBoundsException exception is thrown.</em></p>\n     *\n     * @param number the number to check.\n     * @return {@code true} if processing should continue, {@code false} otherwise.\n     */\n    public boolean test(final int number) {\n        if (number >= size) {\n            throw new IndexOutOfBoundsException(String.format(\"number too large %d >= %d\", number, size));\n        }\n        if (tracker.test(number)) {\n            return  consumer.test(number);\n        }\n        return true;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final IntPredicate tracker;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "IntPredicate", "name": "tracker", "syntax_pass": true}, {"attribute_expression": "private final int size;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "size", "syntax_pass": true}, {"attribute_expression": "private final IntPredicate consumer;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "IntPredicate", "name": "consumer", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/multimap/HashSetValuedHashMap.java.HashSetValuedHashMap", "name": "HashSetValuedHashMap", "file_path": "src/main/java/org/apache/commons/collections4/multimap/HashSetValuedHashMap.java", "superclasses": "", "methods": ["[]HashSetValuedHashMap()", "[]HashSetValuedHashMap(int)", "[]HashSetValuedHashMap(int,int)", "[]HashSetValuedHashMap(Map<? extends K, ? extends V>)", "[]HashSetValuedHashMap(MultiValuedMap<? extends K, ? extends V>)", "[HashSet<V>]createCollection()", "[void]readObject(ObjectInputStream)", "[void]writeObject(ObjectOutputStream)"], "method_uris": ["src/main/java/org/apache/commons/collections4/multimap/HashSetValuedHashMap.java.HashSetValuedHashMap.[]HashSetValuedHashMap()", "src/main/java/org/apache/commons/collections4/multimap/HashSetValuedHashMap.java.HashSetValuedHashMap.[]HashSetValuedHashMap(int)", "src/main/java/org/apache/commons/collections4/multimap/HashSetValuedHashMap.java.HashSetValuedHashMap.[]HashSetValuedHashMap(int,int)", "src/main/java/org/apache/commons/collections4/multimap/HashSetValuedHashMap.java.HashSetValuedHashMap.[]HashSetValuedHashMap(Map<? extends K, ? extends V>)", "src/main/java/org/apache/commons/collections4/multimap/HashSetValuedHashMap.java.HashSetValuedHashMap.[]HashSetValuedHashMap(MultiValuedMap<? extends K, ? extends V>)", "src/main/java/org/apache/commons/collections4/multimap/HashSetValuedHashMap.java.HashSetValuedHashMap.[HashSet<V>]createCollection()", "src/main/java/org/apache/commons/collections4/multimap/HashSetValuedHashMap.java.HashSetValuedHashMap.[void]readObject(ObjectInputStream)", "src/main/java/org/apache/commons/collections4/multimap/HashSetValuedHashMap.java.HashSetValuedHashMap.[void]writeObject(ObjectOutputStream)"], "overrides": null, "attributes": [], "class_docstring": "\nImplements a {@code SetValuedMap}, using a {@link HashMap} to provide data\nstorage and {@link HashSet}s as value collections. This is the standard\nimplementation of a SetValuedMap.\n<p>\n<strong>Note that HashSetValuedHashMap is not synchronized and is not\nthread-safe.</strong> If you wish to use this map from multiple threads\nconcurrently, you must use appropriate synchronization. This class may throw\nexceptions when accessed by concurrent threads without synchronization.\n</p>\n\n@param <K> the type of the keys in this map\n@param <V> the type of the values in this map\n@since 4.1\n", "original_string": "public class HashSetValuedHashMap<K, V> extends AbstractSetValuedMap<K, V>\n    implements Serializable {\n\n    /** Serialization Version */\n    private static final long serialVersionUID = 20151118L;\n\n    /**\n     * The initial map capacity used when none specified in constructor.\n     */\n    private static final int DEFAULT_INITIAL_MAP_CAPACITY = 16;\n\n    /**\n     * The initial set capacity when using none specified in constructor.\n     */\n    private static final int DEFAULT_INITIAL_SET_CAPACITY = 3;\n\n    /**\n     * The initial list capacity when creating a new value collection.\n     */\n    private final int initialSetCapacity;\n\n    /**\n     * Creates an empty HashSetValuedHashMap with the default initial\n     * map capacity (16) and the default initial set capacity (3).\n     */\n    public HashSetValuedHashMap() {\n        this(DEFAULT_INITIAL_MAP_CAPACITY, DEFAULT_INITIAL_SET_CAPACITY);\n    }\n\n    /**\n     * Creates an empty HashSetValuedHashMap with the default initial\n     * map capacity (16) and the specified initial set capacity.\n     *\n     * @param initialSetCapacity  the initial capacity used for value collections\n     */\n    public HashSetValuedHashMap(final int initialSetCapacity) {\n        this(DEFAULT_INITIAL_MAP_CAPACITY, initialSetCapacity);\n    }\n\n    /**\n     * Creates an empty HashSetValuedHashMap with the specified initial\n     * map and list capacities.\n     *\n     * @param initialMapCapacity  the initial hashmap capacity\n     * @param initialSetCapacity  the initial capacity used for value collections\n     */\n    public HashSetValuedHashMap(final int initialMapCapacity, final int initialSetCapacity) {\n        super(new HashMap<>(initialMapCapacity));\n        this.initialSetCapacity = initialSetCapacity;\n    }\n\n    /**\n     * Creates an HashSetValuedHashMap copying all the mappings of the given map.\n     *\n     * @param map a {@code Map} to copy into this map\n     */\n    public HashSetValuedHashMap(final Map<? extends K, ? extends V> map) {\n        this(map.size(), DEFAULT_INITIAL_SET_CAPACITY);\n        super.putAll(map);\n    }\n\n    /**\n     * Creates an HashSetValuedHashMap copying all the mappings of the given map.\n     *\n     * @param map a {@code MultiValuedMap} to copy into this map\n     */\n    public HashSetValuedHashMap(final MultiValuedMap<? extends K, ? extends V> map) {\n        this(map.size(), DEFAULT_INITIAL_SET_CAPACITY);\n        super.putAll(map);\n    }\n\n    @Override\n    protected HashSet<V> createCollection() {\n        return new HashSet<>(initialSetCapacity);\n    }\n\n    /**\n     * Deserializes an instance from an ObjectInputStream.\n     *\n     * @param in The source ObjectInputStream.\n     * @throws IOException            Any of the usual Input/Output related exceptions.\n     * @throws ClassNotFoundException A class of a serialized object cannot be found.\n     */\n    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        setMap(new HashMap<>());\n        doReadObject(in);\n    }\n\n    /**\n     * Serializes this object to an ObjectOutputStream.\n     *\n     * @param out the target ObjectOutputStream.\n     * @throws IOException thrown when an I/O errors occur writing to the target stream.\n     */\n    private void writeObject(final ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        doWriteObject(out);\n    }\n\n}", "super_interfaces": ["Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 20151118L;", "docstring": " Serialization Version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 20151118L", "syntax_pass": true}, {"attribute_expression": "private static final int DEFAULT_INITIAL_MAP_CAPACITY = 16;", "docstring": "\nThe initial map capacity used when none specified in constructor.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "int", "name": "DEFAULT_INITIAL_MAP_CAPACITY = 16", "syntax_pass": true}, {"attribute_expression": "private static final int DEFAULT_INITIAL_SET_CAPACITY = 3;", "docstring": "\nThe initial set capacity when using none specified in constructor.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "int", "name": "DEFAULT_INITIAL_SET_CAPACITY = 3", "syntax_pass": true}, {"attribute_expression": "private final int initialSetCapacity;", "docstring": "\nThe initial list capacity when creating a new value collection.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "initialSetCapacity", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/multimap/TransformedMultiValuedMap.java.TransformedMultiValuedMap", "name": "TransformedMultiValuedMap", "file_path": "src/main/java/org/apache/commons/collections4/multimap/TransformedMultiValuedMap.java", "superclasses": "", "methods": ["[TransformedMultiValuedMap<K, V>]transformedMap(MultiValuedMap<K, V>,Transformer<? super K, ? extends K>,Transformer<? super V, ? extends V>)", "[TransformedMultiValuedMap<K, V>]transformingMap(MultiValuedMap<K, V>,Transformer<? super K, ? extends K>,Transformer<? super V, ? extends V>)", "[]TransformedMultiValuedMap(MultiValuedMap<K, V>,Transformer<? super K, ? extends K>,Transformer<? super V, ? extends V>)", "[boolean]put(K,V)", "[boolean]putAll(K,Iterable<? extends V>)", "[boolean]putAll(Map<? extends K, ? extends V>)", "[boolean]putAll(MultiValuedMap<? extends K, ? extends V>)", "[K]transformKey(K)", "[V]transformValue(V)"], "method_uris": ["src/main/java/org/apache/commons/collections4/multimap/TransformedMultiValuedMap.java.TransformedMultiValuedMap.[TransformedMultiValuedMap<K, V>]transformedMap(MultiValuedMap<K, V>,Transformer<? super K, ? extends K>,Transformer<? super V, ? extends V>)", "src/main/java/org/apache/commons/collections4/multimap/TransformedMultiValuedMap.java.TransformedMultiValuedMap.[TransformedMultiValuedMap<K, V>]transformingMap(MultiValuedMap<K, V>,Transformer<? super K, ? extends K>,Transformer<? super V, ? extends V>)", "src/main/java/org/apache/commons/collections4/multimap/TransformedMultiValuedMap.java.TransformedMultiValuedMap.[]TransformedMultiValuedMap(MultiValuedMap<K, V>,Transformer<? super K, ? extends K>,Transformer<? super V, ? extends V>)", "src/main/java/org/apache/commons/collections4/multimap/TransformedMultiValuedMap.java.TransformedMultiValuedMap.[boolean]put(K,V)", "src/main/java/org/apache/commons/collections4/multimap/TransformedMultiValuedMap.java.TransformedMultiValuedMap.[boolean]putAll(K,Iterable<? extends V>)", "src/main/java/org/apache/commons/collections4/multimap/TransformedMultiValuedMap.java.TransformedMultiValuedMap.[boolean]putAll(Map<? extends K, ? extends V>)", "src/main/java/org/apache/commons/collections4/multimap/TransformedMultiValuedMap.java.TransformedMultiValuedMap.[boolean]putAll(MultiValuedMap<? extends K, ? extends V>)", "src/main/java/org/apache/commons/collections4/multimap/TransformedMultiValuedMap.java.TransformedMultiValuedMap.[K]transformKey(K)", "src/main/java/org/apache/commons/collections4/multimap/TransformedMultiValuedMap.java.TransformedMultiValuedMap.[V]transformValue(V)"], "overrides": null, "attributes": [], "class_docstring": "\nDecorates another {@code MultiValuedMap} to transform objects that are added.\n<p>\nThis class affects the MultiValuedMap put methods. Thus objects must be\nremoved or searched for using their transformed form. For example, if the\ntransformation converts Strings to Integers, you must use the Integer form to\nremove objects.\n</p>\n<p>\n<strong>Note that TransformedMultiValuedMap is not synchronized and is not thread-safe.</strong>\n</p>\n\n@param <K> the type of the keys in this map\n@param <V> the type of the values in this map\n@since 4.1\n", "original_string": "public class TransformedMultiValuedMap<K, V> extends AbstractMultiValuedMapDecorator<K, V> {\n\n    /** Serialization Version */\n    private static final long serialVersionUID = 20150612L;\n\n    /**\n     * Factory method to create a transforming MultiValuedMap that will\n     * transform existing contents of the specified map.\n     * <p>\n     * If there are any elements already in the map being decorated, they will\n     * be transformed by this method. Contrast this with\n     * {@link #transformingMap(MultiValuedMap, Transformer, Transformer)}.\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param map  the MultiValuedMap to decorate, may not be null\n     * @param keyTransformer  the transformer to use for key conversion, null means no conversion\n     * @param valueTransformer  the transformer to use for value conversion, null means no conversion\n     * @return a new transformed MultiValuedMap\n     * @throws NullPointerException if map is null\n     */\n    public static <K, V> TransformedMultiValuedMap<K, V> transformedMap(final MultiValuedMap<K, V> map,\n            final Transformer<? super K, ? extends K> keyTransformer,\n            final Transformer<? super V, ? extends V> valueTransformer) {\n        final TransformedMultiValuedMap<K, V> decorated =\n                new TransformedMultiValuedMap<>(map, keyTransformer, valueTransformer);\n        if (!map.isEmpty()) {\n            final MultiValuedMap<K, V> mapCopy = new ArrayListValuedHashMap<>(map);\n            decorated.clear();\n            decorated.putAll(mapCopy);\n        }\n        return decorated;\n    }\n\n    /**\n     * Factory method to create a transforming MultiValuedMap.\n     * <p>\n     * If there are any elements already in the map being decorated, they are\n     * NOT transformed. Contrast this with\n     * {@link #transformedMap(MultiValuedMap, Transformer, Transformer)}.\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param map  the MultiValuedMap to decorate, may not be null\n     * @param keyTransformer  the transformer to use for key conversion, null means no conversion\n     * @param valueTransformer  the transformer to use for value conversion, null means no conversion\n     * @return a new transformed MultiValuedMap\n     * @throws NullPointerException if map is null\n     */\n    public static <K, V> TransformedMultiValuedMap<K, V> transformingMap(final MultiValuedMap<K, V> map,\n            final Transformer<? super K, ? extends K> keyTransformer,\n            final Transformer<? super V, ? extends V> valueTransformer) {\n        return new TransformedMultiValuedMap<>(map, keyTransformer, valueTransformer);\n    }\n\n    /** The key transformer */\n    private final Transformer<? super K, ? extends K> keyTransformer;\n\n    /** The value transformer */\n    private final Transformer<? super V, ? extends V> valueTransformer;\n\n    /**\n     * Constructor that wraps (not copies).\n     * <p>\n     * If there are any elements already in the collection being decorated, they\n     * are NOT transformed.\n     *\n     * @param map  the MultiValuedMap to decorate, may not be null\n     * @param keyTransformer  the transformer to use for key conversion, null means no conversion\n     * @param valueTransformer  the transformer to use for value conversion, null means no conversion\n     * @throws NullPointerException if map is null\n     */\n    protected TransformedMultiValuedMap(final MultiValuedMap<K, V> map,\n            final Transformer<? super K, ? extends K> keyTransformer,\n            final Transformer<? super V, ? extends V> valueTransformer) {\n        super(map);\n        this.keyTransformer = keyTransformer;\n        this.valueTransformer = valueTransformer;\n    }\n\n    @Override\n    public boolean put(final K key, final V value) {\n        return decorated().put(transformKey(key), transformValue(value));\n    }\n\n    @Override\n    public boolean putAll(final K key, final Iterable<? extends V> values) {\n        Objects.requireNonNull(values, \"values\");\n\n        final Iterable<V> transformedValues = FluentIterable.of(values).transform(valueTransformer);\n        final Iterator<? extends V> it = transformedValues.iterator();\n        return it.hasNext() && CollectionUtils.addAll(decorated().get(transformKey(key)), it);\n    }\n\n    @Override\n    public boolean putAll(final Map<? extends K, ? extends V> map) {\n        Objects.requireNonNull(map, \"map\");\n        boolean changed = false;\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            changed |= put(entry.getKey(), entry.getValue());\n        }\n        return changed;\n    }\n\n    @Override\n    public boolean putAll(final MultiValuedMap<? extends K, ? extends V> map) {\n        Objects.requireNonNull(map, \"map\");\n        boolean changed = false;\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entries()) {\n            changed |= put(entry.getKey(), entry.getValue());\n        }\n        return changed;\n    }\n\n    /**\n     * Transforms a key.\n     * <p>\n     * The transformer itself may throw an exception if necessary.\n     *\n     * @param object  the object to transform\n     * @return the transformed object\n     */\n    protected K transformKey(final K object) {\n        if (keyTransformer == null) {\n            return object;\n        }\n        return keyTransformer.apply(object);\n    }\n\n    /**\n     * Transforms a value.\n     * <p>\n     * The transformer itself may throw an exception if necessary.\n     *\n     * @param object  the object to transform\n     * @return the transformed object\n     */\n    protected V transformValue(final V object) {\n        if (valueTransformer == null) {\n            return object;\n        }\n        return valueTransformer.apply(object);\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = 20150612L;", "docstring": " Serialization Version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 20150612L", "syntax_pass": true}, {"attribute_expression": "private final Transformer<? super K, ? extends K> keyTransformer;", "docstring": " The key transformer", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Transformer<? super K, ? extends K>", "name": "keyTransformer", "syntax_pass": true}, {"attribute_expression": "private final Transformer<? super V, ? extends V> valueTransformer;", "docstring": " The value transformer", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Transformer<? super V, ? extends V>", "name": "valueTransformer", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/multimap/UnmodifiableMultiValuedMap.java.UnmodifiableMultiValuedMap", "name": "UnmodifiableMultiValuedMap", "file_path": "src/main/java/org/apache/commons/collections4/multimap/UnmodifiableMultiValuedMap.java", "superclasses": "", "methods": ["[UnmodifiableMultiValuedMap<K, V>]unmodifiableMultiValuedMap(MultiValuedMap<? extends K, ? extends V>)", "[]UnmodifiableMultiValuedMap(MultiValuedMap<? extends K, ? extends V>)", "[Map<K, Collection<V>>]asMap()", "[void]clear()", "[Collection<Entry<K, V>>]entries()", "[Collection<V>]get(K)", "[MultiSet<K>]keys()", "[Set<K>]keySet()", "[MapIterator<K, V>]mapIterator()", "[boolean]put(K,V)", "[boolean]putAll(K,Iterable<? extends V>)", "[boolean]putAll(Map<? extends K, ? extends V>)", "[boolean]putAll(MultiValuedMap<? extends K, ? extends V>)", "[Collection<V>]remove(Object)", "[boolean]removeMapping(Object,Object)", "[Collection<V>]values()"], "method_uris": ["src/main/java/org/apache/commons/collections4/multimap/UnmodifiableMultiValuedMap.java.UnmodifiableMultiValuedMap.[UnmodifiableMultiValuedMap<K, V>]unmodifiableMultiValuedMap(MultiValuedMap<? extends K, ? extends V>)", "src/main/java/org/apache/commons/collections4/multimap/UnmodifiableMultiValuedMap.java.UnmodifiableMultiValuedMap.[]UnmodifiableMultiValuedMap(MultiValuedMap<? extends K, ? extends V>)", "src/main/java/org/apache/commons/collections4/multimap/UnmodifiableMultiValuedMap.java.UnmodifiableMultiValuedMap.[Map<K, Collection<V>>]asMap()", "src/main/java/org/apache/commons/collections4/multimap/UnmodifiableMultiValuedMap.java.UnmodifiableMultiValuedMap.[void]clear()", "src/main/java/org/apache/commons/collections4/multimap/UnmodifiableMultiValuedMap.java.UnmodifiableMultiValuedMap.[Collection<Entry<K, V>>]entries()", "src/main/java/org/apache/commons/collections4/multimap/UnmodifiableMultiValuedMap.java.UnmodifiableMultiValuedMap.[Collection<V>]get(K)", "src/main/java/org/apache/commons/collections4/multimap/UnmodifiableMultiValuedMap.java.UnmodifiableMultiValuedMap.[MultiSet<K>]keys()", "src/main/java/org/apache/commons/collections4/multimap/UnmodifiableMultiValuedMap.java.UnmodifiableMultiValuedMap.[Set<K>]keySet()", "src/main/java/org/apache/commons/collections4/multimap/UnmodifiableMultiValuedMap.java.UnmodifiableMultiValuedMap.[MapIterator<K, V>]mapIterator()", "src/main/java/org/apache/commons/collections4/multimap/UnmodifiableMultiValuedMap.java.UnmodifiableMultiValuedMap.[boolean]put(K,V)", "src/main/java/org/apache/commons/collections4/multimap/UnmodifiableMultiValuedMap.java.UnmodifiableMultiValuedMap.[boolean]putAll(K,Iterable<? extends V>)", "src/main/java/org/apache/commons/collections4/multimap/UnmodifiableMultiValuedMap.java.UnmodifiableMultiValuedMap.[boolean]putAll(Map<? extends K, ? extends V>)", "src/main/java/org/apache/commons/collections4/multimap/UnmodifiableMultiValuedMap.java.UnmodifiableMultiValuedMap.[boolean]putAll(MultiValuedMap<? extends K, ? extends V>)", "src/main/java/org/apache/commons/collections4/multimap/UnmodifiableMultiValuedMap.java.UnmodifiableMultiValuedMap.[Collection<V>]remove(Object)", "src/main/java/org/apache/commons/collections4/multimap/UnmodifiableMultiValuedMap.java.UnmodifiableMultiValuedMap.[boolean]removeMapping(Object,Object)", "src/main/java/org/apache/commons/collections4/multimap/UnmodifiableMultiValuedMap.java.UnmodifiableMultiValuedMap.[Collection<V>]values()"], "overrides": null, "attributes": [], "class_docstring": "\nDecorates another {@link MultiValuedMap} to ensure it can't be altered.\n<p>\nAttempts to modify it will result in an UnsupportedOperationException.\n</p>\n\n@param <K> the type of key elements\n@param <V> the type of value elements\n\n@since 4.1\n", "original_string": "public final class UnmodifiableMultiValuedMap<K, V>\n        extends AbstractMultiValuedMapDecorator<K, V> implements Unmodifiable {\n\n    /** Serialization version */\n    private static final long serialVersionUID = 20150612L;\n\n    /**\n     * Factory method to create an unmodifiable MultiValuedMap.\n     * <p>\n     * If the map passed in is already unmodifiable, it is returned.\n     *\n     * @param <K> the type of key elements\n     * @param <V> the type of value elements\n     * @param map  the map to decorate, may not be null\n     * @return an unmodifiable MultiValuedMap\n     * @throws NullPointerException if map is null\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static <K, V> UnmodifiableMultiValuedMap<K, V> unmodifiableMultiValuedMap(\n            final MultiValuedMap<? extends K, ? extends V> map) {\n        if (map instanceof Unmodifiable) {\n            return (UnmodifiableMultiValuedMap<K, V>) map;\n        }\n        return new UnmodifiableMultiValuedMap<>(map);\n    }\n\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param map  the MultiValuedMap to decorate, may not be null\n     * @throws NullPointerException if the map is null\n     */\n    @SuppressWarnings(\"unchecked\")\n    private UnmodifiableMultiValuedMap(final MultiValuedMap<? extends K, ? extends V> map) {\n        super((MultiValuedMap<K, V>) map);\n    }\n\n    @Override\n    public Map<K, Collection<V>> asMap() {\n        return UnmodifiableMap.unmodifiableMap(decorated().asMap());\n    }\n\n    @Override\n    public void clear() {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public Collection<Entry<K, V>> entries() {\n        return UnmodifiableCollection.unmodifiableCollection(decorated().entries());\n    }\n\n    @Override\n    public Collection<V> get(final K key) {\n        return UnmodifiableCollection.unmodifiableCollection(decorated().get(key));\n    }\n\n    @Override\n    public MultiSet<K> keys() {\n        return UnmodifiableMultiSet.unmodifiableMultiSet(decorated().keys());\n    }\n\n    @Override\n    public Set<K> keySet() {\n        return UnmodifiableSet.unmodifiableSet(decorated().keySet());\n    }\n\n    @Override\n    public MapIterator<K, V> mapIterator() {\n        return UnmodifiableMapIterator.unmodifiableMapIterator(decorated().mapIterator());\n    }\n\n    @Override\n    public boolean put(final K key, final V value) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public boolean putAll(final K key, final Iterable<? extends V> values) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public boolean putAll(final Map<? extends K, ? extends V> map) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public boolean putAll(final MultiValuedMap<? extends K, ? extends V> map) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public Collection<V> remove(final Object key) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public boolean removeMapping(final Object key, final Object item) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public Collection<V> values() {\n        return UnmodifiableCollection.unmodifiableCollection(decorated().values());\n    }\n\n}", "super_interfaces": ["Unmodifiable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 20150612L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 20150612L", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/multimap/ArrayListValuedHashMap.java.ArrayListValuedHashMap", "name": "ArrayListValuedHashMap", "file_path": "src/main/java/org/apache/commons/collections4/multimap/ArrayListValuedHashMap.java", "superclasses": "", "methods": ["[]ArrayListValuedHashMap()", "[]ArrayListValuedHashMap(int)", "[]ArrayListValuedHashMap(int,int)", "[]ArrayListValuedHashMap(Map<? extends K, ? extends V>)", "[]ArrayListValuedHashMap(MultiValuedMap<? extends K, ? extends V>)", "[ArrayList<V>]createCollection()", "[void]readObject(ObjectInputStream)", "[void]trimToSize()", "[void]writeObject(ObjectOutputStream)"], "method_uris": ["src/main/java/org/apache/commons/collections4/multimap/ArrayListValuedHashMap.java.ArrayListValuedHashMap.[]ArrayListValuedHashMap()", "src/main/java/org/apache/commons/collections4/multimap/ArrayListValuedHashMap.java.ArrayListValuedHashMap.[]ArrayListValuedHashMap(int)", "src/main/java/org/apache/commons/collections4/multimap/ArrayListValuedHashMap.java.ArrayListValuedHashMap.[]ArrayListValuedHashMap(int,int)", "src/main/java/org/apache/commons/collections4/multimap/ArrayListValuedHashMap.java.ArrayListValuedHashMap.[]ArrayListValuedHashMap(Map<? extends K, ? extends V>)", "src/main/java/org/apache/commons/collections4/multimap/ArrayListValuedHashMap.java.ArrayListValuedHashMap.[]ArrayListValuedHashMap(MultiValuedMap<? extends K, ? extends V>)", "src/main/java/org/apache/commons/collections4/multimap/ArrayListValuedHashMap.java.ArrayListValuedHashMap.[ArrayList<V>]createCollection()", "src/main/java/org/apache/commons/collections4/multimap/ArrayListValuedHashMap.java.ArrayListValuedHashMap.[void]readObject(ObjectInputStream)", "src/main/java/org/apache/commons/collections4/multimap/ArrayListValuedHashMap.java.ArrayListValuedHashMap.[void]trimToSize()", "src/main/java/org/apache/commons/collections4/multimap/ArrayListValuedHashMap.java.ArrayListValuedHashMap.[void]writeObject(ObjectOutputStream)"], "overrides": null, "attributes": [], "class_docstring": "\nImplements a {@code ListValuedMap}, using a {@link HashMap} to provide data\nstorage and {@link ArrayList}s as value collections. This is the standard\nimplementation of a ListValuedMap.\n<p>\n<strong>Note that ArrayListValuedHashMap is not synchronized and is not\nthread-safe.</strong> If you wish to use this map from multiple threads\nconcurrently, you must use appropriate synchronization. This class may throw\nexceptions when accessed by concurrent threads without synchronization.\n</p>\n\n@param <K> the type of the keys in this map\n@param <V> the type of the values in this map\n@since 4.1\n", "original_string": "public class ArrayListValuedHashMap<K, V> extends AbstractListValuedMap<K, V>\n    implements Serializable {\n\n    /** Serialization Version */\n    private static final long serialVersionUID = 20151118L;\n\n    /**\n     * The initial map capacity used when none specified in constructor.\n     */\n    private static final int DEFAULT_INITIAL_MAP_CAPACITY = 16;\n\n    /**\n     * The initial list capacity when using none specified in constructor.\n     */\n    private static final int DEFAULT_INITIAL_LIST_CAPACITY = 3;\n\n    /**\n     * The initial list capacity when creating a new value collection.\n     */\n    private final int initialListCapacity;\n\n    /**\n     * Creates an empty ArrayListValuedHashMap with the default initial\n     * map capacity (16) and the default initial list capacity (3).\n     */\n    public ArrayListValuedHashMap() {\n        this(DEFAULT_INITIAL_MAP_CAPACITY, DEFAULT_INITIAL_LIST_CAPACITY);\n    }\n\n    /**\n     * Creates an empty ArrayListValuedHashMap with the default initial\n     * map capacity (16) and the specified initial list capacity.\n     *\n     * @param initialListCapacity  the initial capacity used for value collections\n     */\n    public ArrayListValuedHashMap(final int initialListCapacity) {\n        this(DEFAULT_INITIAL_MAP_CAPACITY, initialListCapacity);\n    }\n\n    /**\n     * Creates an empty ArrayListValuedHashMap with the specified initial\n     * map and list capacities.\n     *\n     * @param initialMapCapacity  the initial hashmap capacity\n     * @param initialListCapacity  the initial capacity used for value collections\n     */\n    public ArrayListValuedHashMap(final int initialMapCapacity, final int initialListCapacity) {\n        super(new HashMap<>(initialMapCapacity));\n        this.initialListCapacity = initialListCapacity;\n    }\n\n    /**\n     * Creates an ArrayListValuedHashMap copying all the mappings of the given map.\n     *\n     * @param map a {@code Map} to copy into this map\n     */\n    public ArrayListValuedHashMap(final Map<? extends K, ? extends V> map) {\n        this(map.size(), DEFAULT_INITIAL_LIST_CAPACITY);\n        super.putAll(map);\n    }\n\n    /**\n     * Creates an ArrayListValuedHashMap copying all the mappings of the given map.\n     *\n     * @param map a {@code MultiValuedMap} to copy into this map\n     */\n    public ArrayListValuedHashMap(final MultiValuedMap<? extends K, ? extends V> map) {\n        this(map.size(), DEFAULT_INITIAL_LIST_CAPACITY);\n        super.putAll(map);\n    }\n\n    @Override\n    protected ArrayList<V> createCollection() {\n        return new ArrayList<>(initialListCapacity);\n    }\n\n    /**\n     * Deserializes an instance from an ObjectInputStream.\n     *\n     * @param in The source ObjectInputStream.\n     * @throws IOException            Any of the usual Input/Output related exceptions.\n     * @throws ClassNotFoundException A class of a serialized object cannot be found.\n     */\n    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        setMap(new HashMap<>());\n        doReadObject(in);\n    }\n\n    /**\n     * Trims the capacity of all value collections to their current size.\n     */\n    public void trimToSize() {\n        for (final Collection<V> coll : getMap().values()) {\n            final ArrayList<V> list = (ArrayList<V>) coll;\n            list.trimToSize();\n        }\n    }\n\n    /**\n     * Serializes this object to an ObjectOutputStream.\n     *\n     * @param out the target ObjectOutputStream.\n     * @throws IOException thrown when an I/O errors occur writing to the target stream.\n     */\n    private void writeObject(final ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        doWriteObject(out);\n    }\n\n}", "super_interfaces": ["Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 20151118L;", "docstring": " Serialization Version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 20151118L", "syntax_pass": true}, {"attribute_expression": "private static final int DEFAULT_INITIAL_MAP_CAPACITY = 16;", "docstring": "\nThe initial map capacity used when none specified in constructor.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "int", "name": "DEFAULT_INITIAL_MAP_CAPACITY = 16", "syntax_pass": true}, {"attribute_expression": "private static final int DEFAULT_INITIAL_LIST_CAPACITY = 3;", "docstring": "\nThe initial list capacity when using none specified in constructor.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "int", "name": "DEFAULT_INITIAL_LIST_CAPACITY = 3", "syntax_pass": true}, {"attribute_expression": "private final int initialListCapacity;", "docstring": "\nThe initial list capacity when creating a new value collection.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "initialListCapacity", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/multiset/PredicatedMultiSet.java.PredicatedMultiSet", "name": "PredicatedMultiSet", "file_path": "src/main/java/org/apache/commons/collections4/multiset/PredicatedMultiSet.java", "superclasses": "", "methods": ["[PredicatedMultiSet<E>]predicatedMultiSet(MultiSet<E>,Predicate<? super E>)", "[]PredicatedMultiSet(MultiSet<E>,Predicate<? super E>)", "[int]add(E,int)", "[MultiSet<E>]decorated()", "[Set<MultiSet.Entry<E>>]entrySet()", "[boolean]equals(Object)", "[int]getCount(Object)", "[int]hashCode()", "[int]remove(Object,int)", "[int]setCount(E,int)", "[Set<E>]uniqueSet()"], "method_uris": ["src/main/java/org/apache/commons/collections4/multiset/PredicatedMultiSet.java.PredicatedMultiSet.[PredicatedMultiSet<E>]predicatedMultiSet(MultiSet<E>,Predicate<? super E>)", "src/main/java/org/apache/commons/collections4/multiset/PredicatedMultiSet.java.PredicatedMultiSet.[]PredicatedMultiSet(MultiSet<E>,Predicate<? super E>)", "src/main/java/org/apache/commons/collections4/multiset/PredicatedMultiSet.java.PredicatedMultiSet.[int]add(E,int)", "src/main/java/org/apache/commons/collections4/multiset/PredicatedMultiSet.java.PredicatedMultiSet.[MultiSet<E>]decorated()", "src/main/java/org/apache/commons/collections4/multiset/PredicatedMultiSet.java.PredicatedMultiSet.[Set<MultiSet.Entry<E>>]entrySet()", "src/main/java/org/apache/commons/collections4/multiset/PredicatedMultiSet.java.PredicatedMultiSet.[boolean]equals(Object)", "src/main/java/org/apache/commons/collections4/multiset/PredicatedMultiSet.java.PredicatedMultiSet.[int]getCount(Object)", "src/main/java/org/apache/commons/collections4/multiset/PredicatedMultiSet.java.PredicatedMultiSet.[int]hashCode()", "src/main/java/org/apache/commons/collections4/multiset/PredicatedMultiSet.java.PredicatedMultiSet.[int]remove(Object,int)", "src/main/java/org/apache/commons/collections4/multiset/PredicatedMultiSet.java.PredicatedMultiSet.[int]setCount(E,int)", "src/main/java/org/apache/commons/collections4/multiset/PredicatedMultiSet.java.PredicatedMultiSet.[Set<E>]uniqueSet()"], "overrides": null, "attributes": [], "class_docstring": "\nDecorates another {@link MultiSet} to validate that additions\nmatch a specified predicate.\n<p>\nThis multiset exists to provide validation for the decorated multiset.\nIt is normally created to decorate an empty multiset.\nIf an object cannot be added to the multiset, an {@link IllegalArgumentException}\nis thrown.\n</p>\n<p>\nOne usage would be to ensure that no null entries are added to the multiset.\n</p>\n<pre>\nMultiSet&lt;E&gt; set =\n     PredicatedMultiSet.predicatedMultiSet(new HashMultiSet&lt;E&gt;(),\n                                           NotNullPredicate.notNullPredicate());\n</pre>\n\n@param <E> the type held in the multiset\n@since 4.1\n", "original_string": "public class PredicatedMultiSet<E> extends PredicatedCollection<E> implements MultiSet<E> {\n\n    /** Serialization version */\n    private static final long serialVersionUID = 20150629L;\n\n    /**\n     * Factory method to create a predicated (validating) multiset.\n     * <p>\n     * If there are any elements already in the multiset being decorated, they\n     * are validated.\n     *\n     * @param <E> the type of the elements in the multiset\n     * @param multiset  the multiset to decorate, must not be null\n     * @param predicate  the predicate to use for validation, must not be null\n     * @return a new predicated MultiSet\n     * @throws NullPointerException if multiset or predicate is null\n     * @throws IllegalArgumentException if the multiset contains invalid elements\n     */\n    public static <E> PredicatedMultiSet<E> predicatedMultiSet(final MultiSet<E> multiset,\n                                                               final Predicate<? super E> predicate) {\n        return new PredicatedMultiSet<>(multiset, predicate);\n    }\n\n    /**\n     * Constructor that wraps (not copies).\n     * <p>\n     * If there are any elements already in the multiset being decorated, they\n     * are validated.\n     *\n     * @param multiset  the multiset to decorate, must not be null\n     * @param predicate  the predicate to use for validation, must not be null\n     * @throws NullPointerException if multiset or predicate is null\n     * @throws IllegalArgumentException if the multiset contains invalid elements\n     */\n    protected PredicatedMultiSet(final MultiSet<E> multiset, final Predicate<? super E> predicate) {\n        super(multiset, predicate);\n    }\n\n    @Override\n    public int add(final E object, final int count) {\n        validate(object);\n        return decorated().add(object, count);\n    }\n\n    /**\n     * Gets the decorated multiset.\n     *\n     * @return the decorated multiset\n     */\n    @Override\n    protected MultiSet<E> decorated() {\n        return (MultiSet<E>) super.decorated();\n    }\n\n    @Override\n    public Set<MultiSet.Entry<E>> entrySet() {\n        return decorated().entrySet();\n    }\n\n    @Override\n    public boolean equals(final Object object) {\n        return object == this || decorated().equals(object);\n    }\n\n    @Override\n    public int getCount(final Object object) {\n        return decorated().getCount(object);\n    }\n\n    @Override\n    public int hashCode() {\n        return decorated().hashCode();\n    }\n\n    @Override\n    public int remove(final Object object, final int count) {\n        return decorated().remove(object, count);\n    }\n\n    @Override\n    public int setCount(final E object, final int count) {\n        validate(object);\n        return decorated().setCount(object, count);\n    }\n\n    @Override\n    public Set<E> uniqueSet() {\n        return decorated().uniqueSet();\n    }\n\n}", "super_interfaces": ["MultiSet<E>"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 20150629L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 20150629L", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/multiset/SynchronizedMultiSet.java.SynchronizedMultiSet", "name": "SynchronizedMultiSet", "file_path": "src/main/java/org/apache/commons/collections4/multiset/SynchronizedMultiSet.java", "superclasses": "", "methods": ["[SynchronizedMultiSet<E>]synchronizedMultiSet(MultiSet<E>)", "[]SynchronizedMultiSet(MultiSet<E>)", "[]SynchronizedMultiSet(MultiSet<E>,Object)", "[int]add(E,int)", "[MultiSet<E>]decorated()", "[Set<Entry<E>>]entrySet()", "[boolean]equals(Object)", "[int]getCount(Object)", "[int]hashCode()", "[int]remove(Object,int)", "[int]setCount(E,int)", "[Set<E>]uniqueSet()"], "method_uris": ["src/main/java/org/apache/commons/collections4/multiset/SynchronizedMultiSet.java.SynchronizedMultiSet.[SynchronizedMultiSet<E>]synchronizedMultiSet(MultiSet<E>)", "src/main/java/org/apache/commons/collections4/multiset/SynchronizedMultiSet.java.SynchronizedMultiSet.[]SynchronizedMultiSet(MultiSet<E>)", "src/main/java/org/apache/commons/collections4/multiset/SynchronizedMultiSet.java.SynchronizedMultiSet.[]SynchronizedMultiSet(MultiSet<E>,Object)", "src/main/java/org/apache/commons/collections4/multiset/SynchronizedMultiSet.java.SynchronizedMultiSet.[int]add(E,int)", "src/main/java/org/apache/commons/collections4/multiset/SynchronizedMultiSet.java.SynchronizedMultiSet.[MultiSet<E>]decorated()", "src/main/java/org/apache/commons/collections4/multiset/SynchronizedMultiSet.java.SynchronizedMultiSet.[Set<Entry<E>>]entrySet()", "src/main/java/org/apache/commons/collections4/multiset/SynchronizedMultiSet.java.SynchronizedMultiSet.[boolean]equals(Object)", "src/main/java/org/apache/commons/collections4/multiset/SynchronizedMultiSet.java.SynchronizedMultiSet.[int]getCount(Object)", "src/main/java/org/apache/commons/collections4/multiset/SynchronizedMultiSet.java.SynchronizedMultiSet.[int]hashCode()", "src/main/java/org/apache/commons/collections4/multiset/SynchronizedMultiSet.java.SynchronizedMultiSet.[int]remove(Object,int)", "src/main/java/org/apache/commons/collections4/multiset/SynchronizedMultiSet.java.SynchronizedMultiSet.[int]setCount(E,int)", "src/main/java/org/apache/commons/collections4/multiset/SynchronizedMultiSet.java.SynchronizedMultiSet.[Set<E>]uniqueSet()"], "overrides": null, "attributes": [{"original_string": "    static class SynchronizedSet<T> extends SynchronizedCollection<T> implements Set<T> {\n        /** Serialization version */\n        private static final long serialVersionUID = 20150629L;\n\n        /**\n         * Constructs a new instance.\n         * @param set  the set to decorate\n         * @param lock  the lock to use, shared with the multiset\n         */\n        SynchronizedSet(final Set<T> set, final Object lock) {\n            super(set, lock);\n        }\n    }", "definition": "    static class SynchronizedSet<T> extends SynchronizedCollection<T> implements Set<T>", "class_docstring": "\nSynchronized Set for the MultiSet class.\n", "name": "SynchronizedSet", "super_interfaces": ["Set<T>"], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = 20150629L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 20150629L", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        SynchronizedSet(final Set<T> set, final Object lock) {\n            super(set, lock);\n        }", "docstring": "\nConstructs a new instance.\n@param set  the set to decorate\n@param lock  the lock to use, shared with the multiset\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "SynchronizedSet", "params": [{"name": "set", "type": "Set<T>"}, {"name": "lock", "type": "Object"}], "body": "                                                             {\n            super(set, lock);\n        }", "signature": "SynchronizedSet(final Set<T> set, final Object lock)"}]}], "class_docstring": "\nDecorates another {@link MultiSet} to synchronize its behavior\nfor a multithreaded environment.\n<p>\nMethods are synchronized, then forwarded to the decorated multiset.\nIterators must be separately synchronized around the loop.\n</p>\n\n@param <E> the type held in the multiset\n@since 4.1\n", "original_string": "public class SynchronizedMultiSet<E> extends SynchronizedCollection<E> implements MultiSet<E> {\n\n    /**\n     * Synchronized Set for the MultiSet class.\n     */\n    static class SynchronizedSet<T> extends SynchronizedCollection<T> implements Set<T> {\n        /** Serialization version */\n        private static final long serialVersionUID = 20150629L;\n\n        /**\n         * Constructs a new instance.\n         * @param set  the set to decorate\n         * @param lock  the lock to use, shared with the multiset\n         */\n        SynchronizedSet(final Set<T> set, final Object lock) {\n            super(set, lock);\n        }\n    }\n\n    /** Serialization version */\n    private static final long serialVersionUID = 20150629L;\n\n    /**\n     * Factory method to create a synchronized multiset.\n     *\n     * @param <E> the type of the elements in the multiset\n     * @param multiset  the multiset to decorate, must not be null\n     * @return a new synchronized MultiSet\n     * @throws NullPointerException if multiset is null\n     */\n    public static <E> SynchronizedMultiSet<E> synchronizedMultiSet(final MultiSet<E> multiset) {\n        return new SynchronizedMultiSet<>(multiset);\n    }\n\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param multiset  the multiset to decorate, must not be null\n     * @throws NullPointerException if multiset is null\n     */\n    protected SynchronizedMultiSet(final MultiSet<E> multiset) {\n        super(multiset);\n    }\n\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param multiset  the multiset to decorate, must not be null\n     * @param lock  the lock to use, must not be null\n     * @throws NullPointerException if multiset or lock is null\n     */\n    protected SynchronizedMultiSet(final MultiSet<E> multiset, final Object lock) {\n        super(multiset, lock);\n    }\n\n    @Override\n    public int add(final E object, final int count) {\n        synchronized (lock) {\n            return decorated().add(object, count);\n        }\n    }\n\n    /**\n     * Gets the multiset being decorated.\n     *\n     * @return the decorated multiset\n     */\n    @Override\n    protected MultiSet<E> decorated() {\n        return (MultiSet<E>) super.decorated();\n    }\n\n    @Override\n    public Set<Entry<E>> entrySet() {\n        synchronized (lock) {\n            final Set<MultiSet.Entry<E>> set = decorated().entrySet();\n            return new SynchronizedSet<>(set, lock);\n        }\n    }\n\n    @Override\n    public boolean equals(final Object object) {\n        if (object == this) {\n            return true;\n        }\n        synchronized (lock) {\n            return decorated().equals(object);\n        }\n    }\n\n    @Override\n    public int getCount(final Object object) {\n        synchronized (lock) {\n            return decorated().getCount(object);\n        }\n    }\n\n    @Override\n    public int hashCode() {\n        synchronized (lock) {\n            return decorated().hashCode();\n        }\n    }\n\n    @Override\n    public int remove(final Object object, final int count) {\n        synchronized (lock) {\n            return decorated().remove(object, count);\n        }\n    }\n\n    @Override\n    public int setCount(final E object, final int count) {\n        synchronized (lock) {\n            return decorated().setCount(object, count);\n        }\n    }\n\n    @Override\n    public Set<E> uniqueSet() {\n        synchronized (lock) {\n            final Set<E> set = decorated().uniqueSet();\n            return new SynchronizedSet<>(set, lock);\n        }\n    }\n\n}", "super_interfaces": ["MultiSet<E>"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 20150629L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 20150629L", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/multiset/HashMultiSet.java.HashMultiSet", "name": "HashMultiSet", "file_path": "src/main/java/org/apache/commons/collections4/multiset/HashMultiSet.java", "superclasses": "", "methods": ["[]HashMultiSet()", "[]HashMultiSet(Collection<? extends E>)", "[void]readObject(ObjectInputStream)", "[void]writeObject(ObjectOutputStream)"], "method_uris": ["src/main/java/org/apache/commons/collections4/multiset/HashMultiSet.java.HashMultiSet.[]HashMultiSet()", "src/main/java/org/apache/commons/collections4/multiset/HashMultiSet.java.HashMultiSet.[]HashMultiSet(Collection<? extends E>)", "src/main/java/org/apache/commons/collections4/multiset/HashMultiSet.java.HashMultiSet.[void]readObject(ObjectInputStream)", "src/main/java/org/apache/commons/collections4/multiset/HashMultiSet.java.HashMultiSet.[void]writeObject(ObjectOutputStream)"], "overrides": null, "attributes": [], "class_docstring": "\nImplements {@code MultiSet}, using a {@link HashMap} to provide the\ndata storage. This is the standard implementation of a multiset.\n<p>\nA {@code MultiSet} stores each object in the collection together with a\ncount of occurrences. Extra methods on the interface allow multiple copies\nof an object to be added or removed at once.\n</p>\n\n@param <E> the type held in the multiset\n@since 4.1\n", "original_string": "public class HashMultiSet<E> extends AbstractMapMultiSet<E> implements Serializable {\n\n    /** Serial version lock */\n    private static final long serialVersionUID = 20150610L;\n\n    /**\n     * Constructs an empty {@link HashMultiSet}.\n     */\n    public HashMultiSet() {\n        super(new HashMap<>());\n    }\n\n    /**\n     * Constructs a multiset containing all the members of the given collection.\n     *\n     * @param coll  a collection to copy into this multiset\n     */\n    public HashMultiSet(final Collection<? extends E> coll) {\n        this();\n        addAll(coll);\n    }\n\n    /**\n     * Deserializes the multiset in using a custom routine.\n     *\n     * @param in the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded\n     */\n    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        setMap(new HashMap<>());\n        super.doReadObject(in);\n    }\n\n    /**\n     * Serializes this object to an ObjectOutputStream.\n     *\n     * @param out the target ObjectOutputStream.\n     * @throws IOException thrown when an I/O errors occur writing to the target stream.\n     */\n    private void writeObject(final ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        super.doWriteObject(out);\n    }\n\n}", "super_interfaces": ["Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 20150610L;", "docstring": " Serial version lock", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 20150610L", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/multiset/UnmodifiableMultiSet.java.UnmodifiableMultiSet", "name": "UnmodifiableMultiSet", "file_path": "src/main/java/org/apache/commons/collections4/multiset/UnmodifiableMultiSet.java", "superclasses": "", "methods": ["[MultiSet<E>]unmodifiableMultiSet(MultiSet<? extends E>)", "[]UnmodifiableMultiSet(MultiSet<? extends E>)", "[boolean]add(E)", "[int]add(E,int)", "[boolean]addAll(Collection<? extends E>)", "[void]clear()", "[Set<MultiSet.Entry<E>>]entrySet()", "[Iterator<E>]iterator()", "[void]readObject(ObjectInputStream)", "[boolean]remove(Object)", "[int]remove(Object,int)", "[boolean]removeAll(Collection<?>)", "[boolean]removeIf(Predicate<? super E>)", "[boolean]retainAll(Collection<?>)", "[int]setCount(E,int)", "[Set<E>]uniqueSet()", "[void]writeObject(ObjectOutputStream)"], "method_uris": ["src/main/java/org/apache/commons/collections4/multiset/UnmodifiableMultiSet.java.UnmodifiableMultiSet.[MultiSet<E>]unmodifiableMultiSet(MultiSet<? extends E>)", "src/main/java/org/apache/commons/collections4/multiset/UnmodifiableMultiSet.java.UnmodifiableMultiSet.[]UnmodifiableMultiSet(MultiSet<? extends E>)", "src/main/java/org/apache/commons/collections4/multiset/UnmodifiableMultiSet.java.UnmodifiableMultiSet.[boolean]add(E)", "src/main/java/org/apache/commons/collections4/multiset/UnmodifiableMultiSet.java.UnmodifiableMultiSet.[int]add(E,int)", "src/main/java/org/apache/commons/collections4/multiset/UnmodifiableMultiSet.java.UnmodifiableMultiSet.[boolean]addAll(Collection<? extends E>)", "src/main/java/org/apache/commons/collections4/multiset/UnmodifiableMultiSet.java.UnmodifiableMultiSet.[void]clear()", "src/main/java/org/apache/commons/collections4/multiset/UnmodifiableMultiSet.java.UnmodifiableMultiSet.[Set<MultiSet.Entry<E>>]entrySet()", "src/main/java/org/apache/commons/collections4/multiset/UnmodifiableMultiSet.java.UnmodifiableMultiSet.[Iterator<E>]iterator()", "src/main/java/org/apache/commons/collections4/multiset/UnmodifiableMultiSet.java.UnmodifiableMultiSet.[void]readObject(ObjectInputStream)", "src/main/java/org/apache/commons/collections4/multiset/UnmodifiableMultiSet.java.UnmodifiableMultiSet.[boolean]remove(Object)", "src/main/java/org/apache/commons/collections4/multiset/UnmodifiableMultiSet.java.UnmodifiableMultiSet.[int]remove(Object,int)", "src/main/java/org/apache/commons/collections4/multiset/UnmodifiableMultiSet.java.UnmodifiableMultiSet.[boolean]removeAll(Collection<?>)", "src/main/java/org/apache/commons/collections4/multiset/UnmodifiableMultiSet.java.UnmodifiableMultiSet.[boolean]removeIf(Predicate<? super E>)", "src/main/java/org/apache/commons/collections4/multiset/UnmodifiableMultiSet.java.UnmodifiableMultiSet.[boolean]retainAll(Collection<?>)", "src/main/java/org/apache/commons/collections4/multiset/UnmodifiableMultiSet.java.UnmodifiableMultiSet.[int]setCount(E,int)", "src/main/java/org/apache/commons/collections4/multiset/UnmodifiableMultiSet.java.UnmodifiableMultiSet.[Set<E>]uniqueSet()", "src/main/java/org/apache/commons/collections4/multiset/UnmodifiableMultiSet.java.UnmodifiableMultiSet.[void]writeObject(ObjectOutputStream)"], "overrides": null, "attributes": [], "class_docstring": "\nDecorates another {@link MultiSet} to ensure it can't be altered.\n<p>\nAttempts to modify it will result in an UnsupportedOperationException.\n</p>\n\n@param <E> the type held in the multiset\n@since 4.1\n", "original_string": "public final class UnmodifiableMultiSet<E>\n        extends AbstractMultiSetDecorator<E> implements Unmodifiable {\n\n    /** Serialization version */\n    private static final long serialVersionUID = 20150611L;\n\n    /**\n     * Factory method to create an unmodifiable multiset.\n     * <p>\n     * If the multiset passed in is already unmodifiable, it is returned.\n     *\n     * @param <E>  the type of the elements in the multiset\n     * @param multiset  the multiset to decorate, may not be null\n     * @return an unmodifiable MultiSet\n     * @throws NullPointerException if multiset is null\n     */\n    public static <E> MultiSet<E> unmodifiableMultiSet(final MultiSet<? extends E> multiset) {\n        if (multiset instanceof Unmodifiable) {\n            @SuppressWarnings(\"unchecked\") // safe to upcast\n            final MultiSet<E> tmpMultiSet = (MultiSet<E>) multiset;\n            return tmpMultiSet;\n        }\n        return new UnmodifiableMultiSet<>(multiset);\n    }\n\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param multiset  the multiset to decorate, may not be null\n     * @throws NullPointerException if multiset is null\n     */\n    @SuppressWarnings(\"unchecked\") // safe to upcast\n    private UnmodifiableMultiSet(final MultiSet<? extends E> multiset) {\n        super((MultiSet<E>) multiset);\n    }\n\n    @Override\n    public boolean add(final E object) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public int add(final E object, final int count) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public boolean addAll(final Collection<? extends E> coll) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public void clear() {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public Set<MultiSet.Entry<E>> entrySet() {\n        final Set<MultiSet.Entry<E>> set = decorated().entrySet();\n        return UnmodifiableSet.unmodifiableSet(set);\n    }\n\n    @Override\n    public Iterator<E> iterator() {\n        return UnmodifiableIterator.<E>unmodifiableIterator(decorated().iterator());\n    }\n\n    /**\n     * Deserializes the collection in using a custom routine.\n     *\n     * @param in  the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded\n     * @throws ClassCastException if deserialized object has wrong type\n     */\n    @SuppressWarnings(\"unchecked\") // will throw CCE, see Javadoc\n    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        setCollection((Collection<E>) in.readObject());\n    }\n\n    @Override\n    public boolean remove(final Object object) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public int remove(final Object object, final int count) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public boolean removeAll(final Collection<?> coll) {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * @since 4.4\n     */\n    @Override\n    public boolean removeIf(final Predicate<? super E> filter) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public boolean retainAll(final Collection<?> coll) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public int setCount(final E object, final int count) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public Set<E> uniqueSet() {\n        final Set<E> set = decorated().uniqueSet();\n        return UnmodifiableSet.unmodifiableSet(set);\n    }\n\n    /**\n     * Serializes this object to an ObjectOutputStream.\n     *\n     * @param out the target ObjectOutputStream.\n     * @throws IOException thrown when an I/O errors occur writing to the target stream.\n     */\n    private void writeObject(final ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        out.writeObject(decorated());\n    }\n\n}", "super_interfaces": ["Unmodifiable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 20150611L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 20150611L", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java.MultiKey", "name": "MultiKey", "file_path": "src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java", "superclasses": "", "methods": ["[Class<? extends T>]getClass(T)", "[Class<? extends T>]getComponentType()", "[T[]]newArray(T,T)", "[T[]]newArray(T,T,T)", "[T[]]newArray(T,T,T,T)", "[T[]]newArray(T,T,T,T,T)", "[]MultiKey(K,K)", "[]MultiKey(K,K,K)", "[]MultiKey(K,K,K,K)", "[]MultiKey(K,K,K,K,K)", "[]MultiKey(K[])", "[]MultiKey(K[],boolean)", "[void]calculateHashCode(Object[])", "[boolean]equals(Object)", "[K]getKey(int)", "[K[]]getKeys()", "[int]hashCode()", "[Object]readResolve()", "[int]size()", "[String]toString()"], "method_uris": ["src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java.MultiKey.[Class<? extends T>]getClass(T)", "src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java.MultiKey.[Class<? extends T>]getComponentType()", "src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java.MultiKey.[T[]]newArray(T,T)", "src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java.MultiKey.[T[]]newArray(T,T,T)", "src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java.MultiKey.[T[]]newArray(T,T,T,T)", "src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java.MultiKey.[T[]]newArray(T,T,T,T,T)", "src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java.MultiKey.[]MultiKey(K,K)", "src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java.MultiKey.[]MultiKey(K,K,K)", "src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java.MultiKey.[]MultiKey(K,K,K,K)", "src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java.MultiKey.[]MultiKey(K,K,K,K,K)", "src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java.MultiKey.[]MultiKey(K[])", "src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java.MultiKey.[]MultiKey(K[],boolean)", "src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java.MultiKey.[void]calculateHashCode(Object[])", "src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java.MultiKey.[boolean]equals(Object)", "src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java.MultiKey.[K]getKey(int)", "src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java.MultiKey.[K[]]getKeys()", "src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java.MultiKey.[int]hashCode()", "src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java.MultiKey.[Object]readResolve()", "src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java.MultiKey.[int]size()", "src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java.MultiKey.[String]toString()"], "overrides": null, "attributes": [], "class_docstring": "\nA {@code MultiKey} allows multiple map keys to be merged together.\n<p>\nThe purpose of this class is to avoid the need to write code to handle\nmaps of maps. An example might be the need to look up a file name by\nkey and locale. The typical solution might be nested maps. This class\ncan be used instead by creating an instance passing in the key and locale.\n</p>\n<p>\nExample usage:\n</p>\n<pre>\n// populate map with data mapping key+locale to localizedText\nMap map = new HashMap();\nMultiKey multiKey = new MultiKey(key, locale);\nmap.put(multiKey, localizedText);\n\n// later retrieve the localized text\nMultiKey multiKey = new MultiKey(key, locale);\nString localizedText = (String) map.get(multiKey);\n</pre>\n\n@param <K> the type of keys\n@since 3.0\n", "original_string": "public class MultiKey<K> implements Serializable {\n    // This class could implement List, but that would confuse its purpose\n\n    /** Serialisation version */\n    private static final long serialVersionUID = 4465448607415788805L;\n\n    @SuppressWarnings(\"unchecked\")\n    private static <T> Class<? extends T> getClass(final T value) {\n        return (Class<? extends T>) (value == null ? Object.class : value.getClass());\n    }\n\n    private static <T> Class<? extends T> getComponentType(final T... values) {\n        @SuppressWarnings(\"unchecked\")\n        final Class<? extends T> rootClass = (Class<? extends T>) Object.class;\n        if (values == null) {\n            return rootClass;\n        }\n        Class<? extends T> prevClass = values.length > 0 ? getClass(values[0]) : rootClass;\n        for (int i = 1; i < values.length; i++) {\n            final Class<? extends T> classI = getClass(values[i]);\n            if (prevClass != classI) {\n                return rootClass;\n            }\n            prevClass = classI;\n        }\n        return prevClass;\n    }\n\n    private static <T> T[] newArray(final T key1, final T key2) {\n        @SuppressWarnings(\"unchecked\")\n        final T[] array = (T[]) Array.newInstance(getComponentType(key1, key2), 2);\n        array[0] = key1;\n        array[1] = key2;\n        return array;\n    }\n\n    private static <T> T[] newArray(final T key1, final T key2, final T key3) {\n        @SuppressWarnings(\"unchecked\")\n        final T[] array = (T[]) Array.newInstance(getComponentType(key1, key2, key3), 3);\n        array[0] = key1;\n        array[1] = key2;\n        array[2] = key3;\n        return array;\n    }\n\n    private static <T> T[] newArray(final T key1, final T key2, final T key3, final T key4) {\n        @SuppressWarnings(\"unchecked\")\n        final T[] array = (T[]) Array.newInstance(getComponentType(key1, key2, key3, key4), 4);\n        array[0] = key1;\n        array[1] = key2;\n        array[2] = key3;\n        array[3] = key4;\n        return array;\n    }\n\n    private static <T> T[] newArray(final T key1, final T key2, final T key3, final T key4, final T key5) {\n        @SuppressWarnings(\"unchecked\")\n        final T[] array = (T[]) Array.newInstance(getComponentType(key1, key2, key3, key4, key5), 5);\n        array[0] = key1;\n        array[1] = key2;\n        array[2] = key3;\n        array[3] = key4;\n        array[4] = key5;\n        return array;\n    }\n\n    /** The individual keys */\n    private final K[] keys;\n\n    /** The cached hashCode */\n    private transient int hashCode;\n\n    /**\n     * Constructor taking two keys.\n     * <p>\n     * The keys should be immutable\n     * If they are not then they must not be changed after adding to the MultiKey.\n     *\n     * @param key1  the first key\n     * @param key2  the second key\n     */\n    public MultiKey(final K key1, final K key2) {\n        this(newArray(key1, key2), false);\n    }\n\n    /**\n     * Constructor taking three keys.\n     * <p>\n     * The keys should be immutable\n     * If they are not then they must not be changed after adding to the MultiKey.\n     *\n     * @param key1  the first key\n     * @param key2  the second key\n     * @param key3  the third key\n     */\n    public MultiKey(final K key1, final K key2, final K key3) {\n        this(newArray(key1, key2, key3), false);\n    }\n\n    /**\n     * Constructor taking four keys.\n     * <p>\n     * The keys should be immutable\n     * If they are not then they must not be changed after adding to the MultiKey.\n     *\n     * @param key1  the first key\n     * @param key2  the second key\n     * @param key3  the third key\n     * @param key4  the fourth key\n     */\n    public MultiKey(final K key1, final K key2, final K key3, final K key4) {\n        this(newArray(key1, key2, key3, key4), false);\n    }\n\n    /**\n     * Constructor taking five keys.\n     * <p>\n     * The keys should be immutable\n     * If they are not then they must not be changed after adding to the MultiKey.\n     *\n     * @param key1  the first key\n     * @param key2  the second key\n     * @param key3  the third key\n     * @param key4  the fourth key\n     * @param key5  the fifth key\n     */\n    public MultiKey(final K key1, final K key2, final K key3, final K key4, final K key5) {\n        this(newArray(key1, key2, key3, key4, key5), false);\n    }\n\n    /**\n     * Constructor taking an array of keys which is cloned.\n     * <p>\n     * The keys should be immutable\n     * If they are not then they must not be changed after adding to the MultiKey.\n     * <p>\n     * This is equivalent to {@code new MultiKey(keys, true)}.\n     *\n     * @param keys  the array of keys, not null\n     * @throws NullPointerException if the key array is null\n     */\n    public MultiKey(final K[] keys) {\n        this(keys, true);\n    }\n\n    /**\n     * Constructor taking an array of keys, optionally choosing whether to clone.\n     * <p>\n     * <b>If the array is not cloned, then it must not be modified.</b>\n     * <p>\n     * This method is public for performance reasons only, to avoid a clone.\n     * The hash code is calculated once here in this method.\n     * Therefore, changing the array passed in would not change the hash code but\n     * would change the equals method, which is a bug.\n     * <p>\n     * This is the only fully safe usage of this constructor, as the object array\n     * is never made available in a variable:\n     * <pre>\n     * new MultiKey(new Object[] {...}, false);\n     * </pre>\n     * <p>\n     * The keys should be immutable\n     * If they are not then they must not be changed after adding to the MultiKey.\n     *\n     * @param keys  the array of keys, not null\n     * @param makeClone  true to clone the array, false to assign it\n     * @throws NullPointerException if the key array is null\n     * @since 3.1\n     */\n    public MultiKey(final K[] keys, final boolean makeClone) {\n        Objects.requireNonNull(keys, \"keys\");\n        this.keys = makeClone ? keys.clone() : keys;\n        calculateHashCode(keys);\n    }\n\n    /**\n     * Calculate the hash code of the instance using the provided keys.\n     * @param keys the keys to calculate the hash code for\n     */\n    private void calculateHashCode(final Object[] keys) {\n        int total = 0;\n        for (final Object key : keys) {\n            if (key != null) {\n                total ^= key.hashCode();\n            }\n        }\n        hashCode = total;\n    }\n\n    /**\n     * Compares this object to another.\n     * <p>\n     * To be equal, the other object must be a {@code MultiKey} with the\n     * same number of keys which are also equal.\n     *\n     * @param other  the other object to compare to\n     * @return true if equal\n     */\n    @Override\n    public boolean equals(final Object other) {\n        if (other == this) {\n            return true;\n        }\n        if (other instanceof MultiKey) {\n            final MultiKey<?> otherMulti = (MultiKey<?>) other;\n            return Arrays.equals(keys, otherMulti.keys);\n        }\n        return false;\n    }\n\n    /**\n     * Gets the key at the specified index.\n     * <p>\n     * The key should be immutable.\n     * If it is not then it must not be changed.\n     *\n     * @param index  the index to retrieve\n     * @return the key at the index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     * @since 3.1\n     */\n    public K getKey(final int index) {\n        return keys[index];\n    }\n\n    /**\n     * Gets a clone of the array of keys.\n     * <p>\n     * The keys should be immutable\n     * If they are not then they must not be changed.\n     *\n     * @return the individual keys\n     */\n    public K[] getKeys() {\n        return keys.clone();\n    }\n\n    /**\n     * Gets the combined hash code that is computed from all the keys.\n     * <p>\n     * This value is computed once and then cached, so elements should not\n     * change their hash codes once created (note that this is the same\n     * constraint that would be used if the individual keys elements were\n     * themselves {@link java.util.Map Map} keys).\n     *\n     * @return the hash code\n     */\n    @Override\n    public int hashCode() {\n        return hashCode;\n    }\n\n    /**\n     * Recalculate the hash code after deserialization. The hash code of some\n     * keys might have change (hash codes based on the system hash code are\n     * only stable for the same process).\n     * @return the instance with recalculated hash code\n     */\n    protected Object readResolve() {\n        calculateHashCode(keys);\n        return this;\n    }\n\n    /**\n     * Gets the size of the list of keys.\n     *\n     * @return the size of the list of keys\n     * @since 3.1\n     */\n    public int size() {\n        return keys.length;\n    }\n\n    /**\n     * Gets a debugging string version of the key.\n     *\n     * @return a debugging string\n     */\n    @Override\n    public String toString() {\n        return \"MultiKey\" + Arrays.toString(keys);\n    }\n}", "super_interfaces": ["Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 4465448607415788805L;", "docstring": " Serialisation version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 4465448607415788805L", "syntax_pass": true}, {"attribute_expression": "private final K[] keys;", "docstring": " The individual keys", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "K[]", "name": "keys", "syntax_pass": true}, {"attribute_expression": "private transient int hashCode;", "docstring": " The cached hashCode", "modifiers": "private transient", "marker_annotations": [], "non_marker_annotations": ["private", "transient"], "comments": [], "type": "int", "name": "hashCode", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/keyvalue/TiedMapEntry.java.TiedMapEntry", "name": "TiedMapEntry", "file_path": "src/main/java/org/apache/commons/collections4/keyvalue/TiedMapEntry.java", "superclasses": "", "methods": ["[]TiedMapEntry(Map<K, V>,K)", "[boolean]equals(Object)", "[K]getKey()", "[V]getValue()", "[int]hashCode()", "[V]setValue(V)", "[String]toString()"], "method_uris": ["src/main/java/org/apache/commons/collections4/keyvalue/TiedMapEntry.java.TiedMapEntry.[]TiedMapEntry(Map<K, V>,K)", "src/main/java/org/apache/commons/collections4/keyvalue/TiedMapEntry.java.TiedMapEntry.[boolean]equals(Object)", "src/main/java/org/apache/commons/collections4/keyvalue/TiedMapEntry.java.TiedMapEntry.[K]getKey()", "src/main/java/org/apache/commons/collections4/keyvalue/TiedMapEntry.java.TiedMapEntry.[V]getValue()", "src/main/java/org/apache/commons/collections4/keyvalue/TiedMapEntry.java.TiedMapEntry.[int]hashCode()", "src/main/java/org/apache/commons/collections4/keyvalue/TiedMapEntry.java.TiedMapEntry.[V]setValue(V)", "src/main/java/org/apache/commons/collections4/keyvalue/TiedMapEntry.java.TiedMapEntry.[String]toString()"], "overrides": null, "attributes": [], "class_docstring": "\nA {@link java.util.Map.Entry Map.Entry} tied to a map underneath.\n<p>\nThis can be used to enable a map entry to make changes on the underlying\nmap, however this will probably mess up any iterators.\n</p>\n\n@param <K> the type of keys\n@param <V> the type of mapped values\n@since 3.0\n", "original_string": "public class TiedMapEntry<K, V> implements Map.Entry<K, V>, KeyValue<K, V>, Serializable {\n\n    /** Serialization version */\n    private static final long serialVersionUID = -8453869361373831205L;\n\n    /** The map underlying the entry/iterator */\n    private final Map<K, V> map;\n\n    /** The key */\n    private final K key;\n\n    /**\n     * Constructs a new entry with the given Map and key.\n     *\n     * @param map  the map\n     * @param key  the key\n     */\n    public TiedMapEntry(final Map<K, V> map, final K key) {\n        this.map = map;\n        this.key = key;\n    }\n\n    /**\n     * Compares this {@code Map.Entry} with another {@code Map.Entry}.\n     * <p>\n     * Implemented per API documentation of {@link java.util.Map.Entry#equals(Object)}\n     *\n     * @param obj  the object to compare to\n     * @return true if equal key and value\n     */\n    @Override\n    public boolean equals(final Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof Map.Entry)) {\n            return false;\n        }\n        final Map.Entry<?, ?> other = (Map.Entry<?, ?>) obj;\n        final Object value = getValue();\n        return\n            (key == null ? other.getKey() == null : key.equals(other.getKey())) &&\n            (value == null ? other.getValue() == null : value.equals(other.getValue()));\n    }\n\n    /**\n     * Gets the key of this entry\n     *\n     * @return the key\n     */\n    @Override\n    public K getKey() {\n        return key;\n    }\n\n    /**\n     * Gets the value of this entry direct from the map.\n     *\n     * @return the value\n     */\n    @Override\n    public V getValue() {\n        return map.get(key);\n    }\n\n    /**\n     * Gets a hashCode compatible with the equals method.\n     * <p>\n     * Implemented per API documentation of {@link java.util.Map.Entry#hashCode()}\n     *\n     * @return a suitable hash code\n     */\n    @Override\n    public int hashCode() {\n        final Object value = getValue();\n        return (getKey() == null ? 0 : getKey().hashCode()) ^\n               (value == null ? 0 : value.hashCode());\n    }\n\n    /**\n     * Sets the value associated with the key direct onto the map.\n     *\n     * @param value  the new value\n     * @return the old value\n     * @throws IllegalArgumentException if the value is set to this map entry\n     */\n    @Override\n    public V setValue(final V value) {\n        if (value == this) {\n            throw new IllegalArgumentException(\"Cannot set value to this map entry\");\n        }\n        return map.put(key, value);\n    }\n\n    /**\n     * Gets a string version of the entry.\n     *\n     * @return entry as a string\n     */\n    @Override\n    public String toString() {\n        return getKey() + \"=\" + getValue();\n    }\n\n}", "super_interfaces": ["Map.Entry<K, V>", "KeyValue<K, V>", "Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = -8453869361373831205L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -8453869361373831205L", "syntax_pass": true}, {"attribute_expression": "private final Map<K, V> map;", "docstring": " The map underlying the entry/iterator", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Map<K, V>", "name": "map", "syntax_pass": true}, {"attribute_expression": "private final K key;", "docstring": " The key", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "K", "name": "key", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/keyvalue/DefaultKeyValue.java.DefaultKeyValue", "name": "DefaultKeyValue", "file_path": "src/main/java/org/apache/commons/collections4/keyvalue/DefaultKeyValue.java", "superclasses": "", "methods": ["[]DefaultKeyValue()", "[]DefaultKeyValue(K,V)", "[]DefaultKeyValue(KeyValue<? extends K, ? extends V>)", "[]DefaultKeyValue(Map.Entry<? extends K, ? extends V>)", "[boolean]equals(Object)", "[int]hashCode()", "[K]setKey(K)", "[V]setValue(V)", "[Map.Entry<K, V>]toMapEntry()"], "method_uris": ["src/main/java/org/apache/commons/collections4/keyvalue/DefaultKeyValue.java.DefaultKeyValue.[]DefaultKeyValue()", "src/main/java/org/apache/commons/collections4/keyvalue/DefaultKeyValue.java.DefaultKeyValue.[]DefaultKeyValue(K,V)", "src/main/java/org/apache/commons/collections4/keyvalue/DefaultKeyValue.java.DefaultKeyValue.[]DefaultKeyValue(KeyValue<? extends K, ? extends V>)", "src/main/java/org/apache/commons/collections4/keyvalue/DefaultKeyValue.java.DefaultKeyValue.[]DefaultKeyValue(Map.Entry<? extends K, ? extends V>)", "src/main/java/org/apache/commons/collections4/keyvalue/DefaultKeyValue.java.DefaultKeyValue.[boolean]equals(Object)", "src/main/java/org/apache/commons/collections4/keyvalue/DefaultKeyValue.java.DefaultKeyValue.[int]hashCode()", "src/main/java/org/apache/commons/collections4/keyvalue/DefaultKeyValue.java.DefaultKeyValue.[K]setKey(K)", "src/main/java/org/apache/commons/collections4/keyvalue/DefaultKeyValue.java.DefaultKeyValue.[V]setValue(V)", "src/main/java/org/apache/commons/collections4/keyvalue/DefaultKeyValue.java.DefaultKeyValue.[Map.Entry<K, V>]toMapEntry()"], "overrides": null, "attributes": [], "class_docstring": "\nA mutable {@code KeyValue} pair that does not implement\n{@link java.util.Map.Entry Map.Entry}.\n<p>\nNote that a {@code DefaultKeyValue} instance may not contain\nitself as a key or value.\n</p>\n\n@param <K> the type of keys\n@param <V> the type of values\n@since 3.0\n", "original_string": "public class DefaultKeyValue<K, V> extends AbstractKeyValue<K, V> {\n\n    /**\n     * Constructs a new pair with a null key and null value.\n     */\n    public DefaultKeyValue() {\n        super(null, null);\n    }\n\n    /**\n     * Constructs a new pair with the specified key and given value.\n     *\n     * @param key  the key for the entry, may be null\n     * @param value  the value for the entry, may be null\n     */\n    public DefaultKeyValue(final K key, final V value) {\n        super(key, value);\n    }\n\n    /**\n     * Constructs a new pair from the specified {@code KeyValue}.\n     *\n     * @param pair  the pair to copy, must not be null\n     * @throws NullPointerException if the entry is null\n     */\n    public DefaultKeyValue(final KeyValue<? extends K, ? extends V> pair) {\n        super(pair.getKey(), pair.getValue());\n    }\n\n    /**\n     * Constructs a new pair from the specified {@code Map.Entry}.\n     *\n     * @param entry  the entry to copy, must not be null\n     * @throws NullPointerException if the entry is null\n     */\n    public DefaultKeyValue(final Map.Entry<? extends K, ? extends V> entry) {\n        super(entry.getKey(), entry.getValue());\n    }\n\n    /**\n     * Compares this {@code Map.Entry} with another {@code Map.Entry}.\n     * <p>\n     * Returns true if the compared object is also a {@code DefaultKeyValue},\n     * and its key and value are equal to this object's key and value.\n     *\n     * @param obj  the object to compare to\n     * @return true if equal key and value\n     */\n    @Override\n    public boolean equals(final Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof DefaultKeyValue)) {\n            return false;\n        }\n\n        final DefaultKeyValue<?, ?> other = (DefaultKeyValue<?, ?>) obj;\n        return\n            (getKey() == null ? other.getKey() == null : getKey().equals(other.getKey())) &&\n            (getValue() == null ? other.getValue() == null : getValue().equals(other.getValue()));\n    }\n\n    /**\n     * Gets a hashCode compatible with the equals method.\n     * <p>\n     * Implemented per API documentation of {@link java.util.Map.Entry#hashCode()},\n     * however subclasses may override this.\n     *\n     * @return a suitable hash code\n     */\n    @Override\n    public int hashCode() {\n        return (getKey() == null ? 0 : getKey().hashCode()) ^\n               (getValue() == null ? 0 : getValue().hashCode());\n    }\n\n    /**\n     * Sets the key.\n     *\n     * @param key  the new key\n     * @return the old key\n     * @throws IllegalArgumentException if key is this object\n     */\n    @Override\n    public K setKey(final K key) {\n        if (key == this) {\n            throw new IllegalArgumentException(\"DefaultKeyValue may not contain itself as a key.\");\n        }\n\n        return super.setKey(key);\n    }\n\n    /**\n     * Sets the value.\n     *\n     * @return the old value of the value\n     * @param value the new value\n     * @throws IllegalArgumentException if value is this object\n     */\n    @Override\n    public V setValue(final V value) {\n        if (value == this) {\n            throw new IllegalArgumentException(\"DefaultKeyValue may not contain itself as a value.\");\n        }\n\n        return super.setValue(value);\n    }\n\n    /**\n     * Returns a new {@code Map.Entry} object with key and value from this pair.\n     *\n     * @return a MapEntry instance\n     */\n    public Map.Entry<K, V> toMapEntry() {\n        return new DefaultMapEntry<>(this);\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/org/apache/commons/collections4/keyvalue/DefaultMapEntry.java.DefaultMapEntry", "name": "DefaultMapEntry", "file_path": "src/main/java/org/apache/commons/collections4/keyvalue/DefaultMapEntry.java", "superclasses": "", "methods": ["[]DefaultMapEntry(K,V)", "[]DefaultMapEntry(KeyValue<? extends K, ? extends V>)", "[]DefaultMapEntry(Map.Entry<? extends K, ? extends V>)"], "method_uris": ["src/main/java/org/apache/commons/collections4/keyvalue/DefaultMapEntry.java.DefaultMapEntry.[]DefaultMapEntry(K,V)", "src/main/java/org/apache/commons/collections4/keyvalue/DefaultMapEntry.java.DefaultMapEntry.[]DefaultMapEntry(KeyValue<? extends K, ? extends V>)", "src/main/java/org/apache/commons/collections4/keyvalue/DefaultMapEntry.java.DefaultMapEntry.[]DefaultMapEntry(Map.Entry<? extends K, ? extends V>)"], "overrides": null, "attributes": [], "class_docstring": "\nA restricted implementation of {@link java.util.Map.Entry Map.Entry} that prevents\nthe {@link java.util.Map.Entry Map.Entry} contract from being broken.\n\n@param <K> the type of keys\n@param <V> the type of mapped values\n@since 3.0\n", "original_string": "public final class DefaultMapEntry<K, V> extends AbstractMapEntry<K, V> {\n\n    /**\n     * Constructs a new entry with the specified key and given value.\n     *\n     * @param key  the key for the entry, may be null\n     * @param value  the value for the entry, may be null\n     */\n    public DefaultMapEntry(final K key, final V value) {\n        super(key, value);\n    }\n\n    /**\n     * Constructs a new entry from the specified {@code KeyValue}.\n     *\n     * @param pair  the pair to copy, must not be null\n     * @throws NullPointerException if the entry is null\n     */\n    public DefaultMapEntry(final KeyValue<? extends K, ? extends V> pair) {\n        super(pair.getKey(), pair.getValue());\n    }\n\n    /**\n     * Constructs a new entry from the specified {@code Map.Entry}.\n     *\n     * @param entry  the entry to copy, must not be null\n     * @throws NullPointerException if the entry is null\n     */\n    public DefaultMapEntry(final Map.Entry<? extends K, ? extends V> entry) {\n        super(entry.getKey(), entry.getValue());\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/org/apache/commons/collections4/keyvalue/UnmodifiableMapEntry.java.UnmodifiableMapEntry", "name": "UnmodifiableMapEntry", "file_path": "src/main/java/org/apache/commons/collections4/keyvalue/UnmodifiableMapEntry.java", "superclasses": "", "methods": ["[]UnmodifiableMapEntry(K,V)", "[]UnmodifiableMapEntry(KeyValue<? extends K, ? extends V>)", "[]UnmodifiableMapEntry(Map.Entry<? extends K, ? extends V>)", "[V]setValue(V)"], "method_uris": ["src/main/java/org/apache/commons/collections4/keyvalue/UnmodifiableMapEntry.java.UnmodifiableMapEntry.[]UnmodifiableMapEntry(K,V)", "src/main/java/org/apache/commons/collections4/keyvalue/UnmodifiableMapEntry.java.UnmodifiableMapEntry.[]UnmodifiableMapEntry(KeyValue<? extends K, ? extends V>)", "src/main/java/org/apache/commons/collections4/keyvalue/UnmodifiableMapEntry.java.UnmodifiableMapEntry.[]UnmodifiableMapEntry(Map.Entry<? extends K, ? extends V>)", "src/main/java/org/apache/commons/collections4/keyvalue/UnmodifiableMapEntry.java.UnmodifiableMapEntry.[V]setValue(V)"], "overrides": null, "attributes": [], "class_docstring": "\nA {@link java.util.Map.Entry Map.Entry} that throws\nUnsupportedOperationException when {@code setValue} is called.\n\n@param <K> the type of keys\n@param <V> the type of mapped values\n@since 3.0\n", "original_string": "public final class UnmodifiableMapEntry<K, V> extends AbstractMapEntry<K, V> implements Unmodifiable {\n\n    /**\n     * Constructs a new entry with the specified key and given value.\n     *\n     * @param key  the key for the entry, may be null\n     * @param value  the value for the entry, may be null\n     */\n    public UnmodifiableMapEntry(final K key, final V value) {\n        super(key, value);\n    }\n\n    /**\n     * Constructs a new entry from the specified {@code KeyValue}.\n     *\n     * @param pair  the pair to copy, must not be null\n     * @throws NullPointerException if the entry is null\n     */\n    public UnmodifiableMapEntry(final KeyValue<? extends K, ? extends V> pair) {\n        super(pair.getKey(), pair.getValue());\n    }\n\n    /**\n     * Constructs a new entry from the specified {@code Map.Entry}.\n     *\n     * @param entry  the entry to copy, must not be null\n     * @throws NullPointerException if the entry is null\n     */\n    public UnmodifiableMapEntry(final Map.Entry<? extends K, ? extends V> entry) {\n        super(entry.getKey(), entry.getValue());\n    }\n\n    /**\n     * Throws UnsupportedOperationException.\n     *\n     * @param value  the new value\n     * @return the previous value\n     * @throws UnsupportedOperationException always\n     */\n    @Override\n    public V setValue(final V value) {\n        throw new UnsupportedOperationException(\"setValue() is not supported\");\n    }\n\n}", "super_interfaces": ["Unmodifiable"], "fields": []}]