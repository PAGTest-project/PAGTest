[{"uris": "src/test/java/org/ice4j/TransactionSupportTests.java.TransactionSupportTests.[void]setUp()", "name": "setUp", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@BeforeEach\n    public void setUp()", "original_string": "    @BeforeEach\n    public void setUp()\n        throws Exception\n    {\n        clientSock = new IceUdpSocketWrapper(\n            new SafeCloseDatagramSocket(new InetSocketAddress(\"127.0.0.1\", 0)));\n        serverSock = new IceUdpSocketWrapper(\n            new SafeCloseDatagramSocket(new InetSocketAddress(\"127.0.0.1\", 0)));\n\n        clientAddress\n            = new TransportAddress(\"127.0.0.1\", clientSock.getLocalPort(), Transport.UDP);\n        serverAddress\n            = new TransportAddress(\"127.0.0.1\", serverSock.getLocalPort(), Transport.UDP);\n\n        stunStack = new StunStack();\n        stunStack.addSocket(clientSock);\n        stunStack.addSocket(serverSock);\n\n        bindingRequest = MessageFactory.createBindingRequest();\n        bindingResponse = MessageFactory.create3489BindingResponse(\n            clientAddress, clientAddress, serverAddress);\n\n        requestCollector = new PlainRequestCollector();\n        responseCollector = new PlainResponseCollector();\n\n        System.setProperty(\n                StackProperties.PROPAGATE_RECEIVED_RETRANSMISSIONS,\n                \"false\");\n        System.setProperty(\n                StackProperties.KEEP_CRANS_AFTER_A_RESPONSE,\n                \"false\");\n        System.setProperty(\n                StackProperties.MAX_CTRAN_RETRANSMISSIONS,\n                \"\");\n        System.setProperty(\n                StackProperties.MAX_CTRAN_RETRANS_TIMER,\n                \"\");\n        System.setProperty(\n                StackProperties.FIRST_CTRAN_RETRANS_AFTER,\n                \"\");\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/TransactionSupportTests.java", "class_name": "TransactionSupportTests", "class_uri": "src/test/java/org/ice4j/TransactionSupportTests.java.TransactionSupportTests", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nInits sockets.\n\n@throws Exception if something goes bad.\n"}, {"uris": "src/test/java/org/ice4j/TransactionSupportTests.java.TransactionSupportTests.[void]tearDown()", "name": "tearDown", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@AfterEach\n    public void tearDown()", "original_string": "    @AfterEach\n    public void tearDown()\n        throws Exception\n    {\n        stunStack.removeSocket(clientAddress);\n        stunStack.removeSocket(serverAddress);\n\n        clientSock.close();\n        serverSock.close();\n\n        requestCollector = null;\n        responseCollector = null;\n\n        System.setProperty(\n                StackProperties.PROPAGATE_RECEIVED_RETRANSMISSIONS,\n                \"false\");\n        System.setProperty(\n                StackProperties.KEEP_CRANS_AFTER_A_RESPONSE,\n                \"false\");\n        System.setProperty(\n                StackProperties.MAX_CTRAN_RETRANSMISSIONS,\n                \"\");\n        System.setProperty(\n                StackProperties.MAX_CTRAN_RETRANS_TIMER,\n                \"\");\n        System.setProperty(\n                StackProperties.FIRST_CTRAN_RETRANS_AFTER,\n                \"\");\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/TransactionSupportTests.java", "class_name": "TransactionSupportTests", "class_uri": "src/test/java/org/ice4j/TransactionSupportTests.java.TransactionSupportTests", "attributes": {"modifiers": "@AfterEach\n    public", "marker_annotations": ["@AfterEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nFrees all sockets that we are currently using.\n\n@throws Exception if something does not go as planned.\n"}, {"uris": "src/test/java/org/ice4j/TestExecutionListener.java.TestExecutionListener.[void]beforeAll()", "name": "beforeAll", "arg_nums": 0, "params": [], "return_type": "void", "signature": "private static void beforeAll()", "original_string": "    private static void beforeAll()\n    {\n        // Disable config caching.\n        MetaconfigSettings.Companion.setCacheEnabled(false);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/TestExecutionListener.java", "class_name": "TestExecutionListener", "class_uri": "src/test/java/org/ice4j/TestExecutionListener.java.TestExecutionListener", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/TestExecutionListener.java.TestExecutionListener.[]TestExecutionListener()", "name": "TestExecutionListener", "arg_nums": 0, "params": [], "return_type": "", "signature": "public TestExecutionListener()", "original_string": "    public TestExecutionListener()\n    {}", "default_arguments": null, "file": "src/test/java/org/ice4j/TestExecutionListener.java", "class_name": "TestExecutionListener", "class_uri": "src/test/java/org/ice4j/TestExecutionListener.java.TestExecutionListener", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/TestExecutionListener.java.TestExecutionListener.[void]executionStarted(TestIdentifier)", "name": "executionStarted", "arg_nums": 1, "params": [{"name": "testIdentifier", "type": "TestIdentifier"}], "return_type": "void", "signature": "@Override\n    public void executionStarted(TestIdentifier testIdentifier)", "original_string": "    @Override\n    public void executionStarted(TestIdentifier testIdentifier)\n    {\n        synchronized (TestExecutionListener.class)\n        {\n            if (!initialized)\n            {\n                beforeAll();\n                initialized = true;\n            }\n        }\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/TestExecutionListener.java", "class_name": "TestExecutionListener", "class_uri": "src/test/java/org/ice4j/TestExecutionListener.java.TestExecutionListener", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/MessageEventDispatchingTest.java.MessageEventDispatchingTest.[void]setUp()", "name": "setUp", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@BeforeEach\n    public void setUp()", "original_string": "    @BeforeEach\n    public void setUp() throws Exception\n    {\n        stunStack = new StunStack();\n\n        clientSock = new IceUdpSocketWrapper(\n            new SafeCloseDatagramSocket(clientAddress));\n        serverSock = new IceUdpSocketWrapper(\n            new SafeCloseDatagramSocket(serverAddress));\n        serverSock2 = new IceUdpSocketWrapper(\n            new SafeCloseDatagramSocket(serverAddress2));\n\n        stunStack.addSocket(clientSock);\n        stunStack.addSocket(serverSock);\n        stunStack.addSocket(serverSock2);\n\n        bindingRequest = MessageFactory.createBindingRequest();\n        bindingResponse = MessageFactory.create3489BindingResponse(\n            clientAddress, clientAddress, serverAddress);\n\n        requestCollector = new PlainRequestCollector();\n        responseCollector = new PlainResponseCollector();\n\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/MessageEventDispatchingTest.java", "class_name": "MessageEventDispatchingTest", "class_uri": "src/test/java/org/ice4j/MessageEventDispatchingTest.java.MessageEventDispatchingTest", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\njunit setup method.\n\n@throws Exception if anything goes wrong.\n"}, {"uris": "src/test/java/org/ice4j/MessageEventDispatchingTest.java.MessageEventDispatchingTest.[void]tearDown()", "name": "tearDown", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@AfterEach\n    public void tearDown()", "original_string": "    @AfterEach\n    public void tearDown() throws Exception\n    {\n        stunStack.removeSocket(clientAddress);\n        stunStack.removeSocket(serverAddress);\n        stunStack.removeSocket(serverAddress2);\n\n        clientSock.close();\n        serverSock.close();\n        serverSock2.close();\n\n        requestCollector = null;\n        responseCollector = null;\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/MessageEventDispatchingTest.java", "class_name": "MessageEventDispatchingTest", "class_uri": "src/test/java/org/ice4j/MessageEventDispatchingTest.java.MessageEventDispatchingTest", "attributes": {"modifiers": "@AfterEach\n    public", "marker_annotations": ["@AfterEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\njunit tear down method.\n\n@throws Exception if anything goes wrong.\n"}, {"uris": "src/test/java/org/ice4j/message/MessageTest.java.MessageTest.[void]setupConfig()", "name": "setupConfig", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@BeforeAll\n    public static void setupConfig()", "original_string": "    @BeforeAll\n    public static void setupConfig()\n    {\n        System.clearProperty(StackProperties.ALWAYS_SIGN);\n        System.setProperty(\"ice4j.software\", \"\");\n        JitsiConfig.Companion.reloadNewConfig();\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/message/MessageTest.java", "class_name": "MessageTest", "class_uri": "src/test/java/org/ice4j/message/MessageTest.java.MessageTest", "attributes": {"modifiers": "@BeforeAll\n    public static", "marker_annotations": ["@BeforeAll"], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/message/MessageTest.java.MessageTest.[void]resetConfig()", "name": "resetConfig", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@AfterAll\n    public static void resetConfig()", "original_string": "    @AfterAll\n    public static void resetConfig()\n    {\n        System.clearProperty(\"ice4j.software\");\n        JitsiConfig.Companion.reloadNewConfig();\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/message/MessageTest.java", "class_name": "MessageTest", "class_uri": "src/test/java/org/ice4j/message/MessageTest.java.MessageTest", "attributes": {"modifiers": "@AfterAll\n    public static", "marker_annotations": ["@AfterAll"], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/message/MessageTest.java.MessageTest.[void]setUp()", "name": "setUp", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@BeforeEach\n    public void setUp()", "original_string": "    @BeforeEach\n    public void setUp() throws Exception\n    {\n        msgFixture = new MsgFixture();\n\n        stunStack = new StunStack();\n\n        //binding request\n        bindingRequest = new Request();\n        bindingRequest.setMessageType(Message.BINDING_REQUEST);\n\n        changeRequest = AttributeFactory.createChangeRequestAttribute(\n                   MsgFixture.CHANGE_IP_FLAG_1, MsgFixture.CHANGE_PORT_FLAG_1);\n        bindingRequest.putAttribute(changeRequest);\n        bindingRequest.setTransactionID(MsgFixture.TRANSACTION_ID);\n\n        //binding response\n        bindingResponse = new Response();\n        bindingResponse.setMessageType(Message.BINDING_SUCCESS_RESPONSE);\n\n        mappedAddress = AttributeFactory.createMappedAddressAttribute(\n            new TransportAddress(\n                            MsgFixture.ADDRESS_ATTRIBUTE_ADDRESS,\n                            MsgFixture.ADDRESS_ATTRIBUTE_PORT,\n                            Transport.UDP));\n\n        bindingResponse.putAttribute(mappedAddress);\n\n        sourceAddress = AttributeFactory.createSourceAddressAttribute(\n            new TransportAddress(\n                            MsgFixture.ADDRESS_ATTRIBUTE_ADDRESS_2,\n                            MsgFixture.ADDRESS_ATTRIBUTE_PORT_2,\n                            Transport.UDP));\n\n        bindingResponse.putAttribute(sourceAddress);\n\n        changedAddress = AttributeFactory.createChangedAddressAttribute(\n            new TransportAddress( MsgFixture.ADDRESS_ATTRIBUTE_ADDRESS_3,\n                        MsgFixture.ADDRESS_ATTRIBUTE_PORT_3, Transport.UDP));\n\n        bindingResponse.putAttribute(changedAddress);\n        bindingResponse.setTransactionID(MsgFixture.TRANSACTION_ID);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/message/MessageTest.java", "class_name": "MessageTest", "class_uri": "src/test/java/org/ice4j/message/MessageTest.java.MessageTest", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/message/MessageTest.java.MessageTest.[void]tearDown()", "name": "tearDown", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@AfterEach\n    public void tearDown()", "original_string": "    @AfterEach\n    public void tearDown() throws Exception\n    {\n        bindingRequest = null;\n        bindingResponse = null;\n        mappedAddress = null;\n        sourceAddress = null;\n        changedAddress = null;\n        changeRequest = null;\n\n        stunStack = null;\n\n        msgFixture = null;\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/message/MessageTest.java", "class_name": "MessageTest", "class_uri": "src/test/java/org/ice4j/message/MessageTest.java.MessageTest", "attributes": {"modifiers": "@AfterEach\n    public", "marker_annotations": ["@AfterEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest_v6.java.StunAddressDiscovererTest_v6.[void]setUp()", "name": "setUp", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@BeforeEach\n    public void setUp()", "original_string": "    @BeforeEach\n    public void setUp() throws Exception\n    {\n        StunStack stunStack = new StunStack();\n\n        responseServer\n            = new ResponseSequenceServer(stunStack, responseServerAddress);\n        stunAddressDiscoverer\n            = new NetworkConfigurationDiscoveryProcess(\n                    stunStack,\n                    discovererAddress, responseServerAddress);\n\n        stunAddressDiscoverer.start();\n        responseServer.start();\n\n        System.setProperty(StackProperties.MAX_CTRAN_RETRANS_TIMER, \"100\");\n        System.setProperty(StackProperties.MAX_CTRAN_RETRANSMISSIONS, \"2\");\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest_v6.java", "class_name": "StunAddressDiscovererTest_v6", "class_uri": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest_v6.java.StunAddressDiscovererTest_v6", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest_v6.java.StunAddressDiscovererTest_v6.[void]tearDown()", "name": "tearDown", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@AfterEach\n    public void tearDown()", "original_string": "    @AfterEach\n    public void tearDown() throws Exception\n    {\n        System.clearProperty(StackProperties.MAX_CTRAN_RETRANS_TIMER);\n        System.clearProperty(StackProperties.MAX_CTRAN_RETRANSMISSIONS);\n        responseServer.shutDown();\n        stunAddressDiscoverer.shutDown();\n        stunAddressDiscoverer = null;\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest_v6.java", "class_name": "StunAddressDiscovererTest_v6", "class_uri": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest_v6.java.StunAddressDiscovererTest_v6", "attributes": {"modifiers": "@AfterEach\n    public", "marker_annotations": ["@AfterEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/stunclient/ResponseSequenceServer.java.ResponseSequenceServer.[]ResponseSequenceServer(StunStack,TransportAddress)", "name": "ResponseSequenceServer", "arg_nums": 2, "params": [{"name": "stunStack", "type": "StunStack"}, {"name": "bindAddress", "type": "TransportAddress"}], "return_type": "", "signature": "public ResponseSequenceServer(\n            StunStack stunStack,\n            TransportAddress bindAddress)", "original_string": "    public ResponseSequenceServer(\n            StunStack stunStack,\n            TransportAddress bindAddress)\n    {\n        this.stunStack = stunStack;\n        this.serverAddress = bindAddress;\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/stunclient/ResponseSequenceServer.java", "class_name": "ResponseSequenceServer", "class_uri": "src/test/java/org/ice4j/stunclient/ResponseSequenceServer.java.ResponseSequenceServer", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>ResponseSequenceServer</tt> instance with a\nspecific <tt>StunStack</tt> to be used for the purposes of STUN\ncommunication.\n\n@param stunStack the <tt>StunStack</tt> to be used by the new instance\nfor the purposes of STUN communication\n@param bindAddress\n"}, {"uris": "src/test/java/org/ice4j/stunclient/ResponseSequenceServer.java.ResponseSequenceServer.[void]start()", "name": "start", "arg_nums": 0, "params": [], "return_type": "void", "signature": "public void start()", "original_string": "    public void start()\n        throws IOException, StunException\n    {\n        localSocket = new IceUdpSocketWrapper(\n            new SafeCloseDatagramSocket(serverAddress));\n\n        stunStack.addSocket(localSocket);\n        stunStack.addRequestListener(serverAddress, this);\n\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/stunclient/ResponseSequenceServer.java", "class_name": "ResponseSequenceServer", "class_uri": "src/test/java/org/ice4j/stunclient/ResponseSequenceServer.java.ResponseSequenceServer", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nInitializes the underlying stack\n@throws StunException if something else fails\n@throws IOException if we fail to bind a local socket.\n"}, {"uris": "src/test/java/org/ice4j/stunclient/ResponseSequenceServer.java.ResponseSequenceServer.[void]shutDown()", "name": "shutDown", "arg_nums": 0, "params": [], "return_type": "void", "signature": "public void shutDown()", "original_string": "    public void shutDown()\n    {\n        stunStack.removeSocket(serverAddress);\n        messageSequence.removeAllElements();\n        localSocket.close();\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/stunclient/ResponseSequenceServer.java", "class_name": "ResponseSequenceServer", "class_uri": "src/test/java/org/ice4j/stunclient/ResponseSequenceServer.java.ResponseSequenceServer", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nResets the server (deletes the sequence and stops the stack)\n"}, {"uris": "src/test/java/org/ice4j/stunclient/ResponseSequenceServer.java.ResponseSequenceServer.[void]addMessage(Response)", "name": "addMessage", "arg_nums": 1, "params": [{"name": "response", "type": "Response"}], "return_type": "void", "signature": "public void addMessage(Response response)", "original_string": "    public void addMessage(Response response)\n    {\n        if (response == null)\n        {\n            //leave a mark to skip a message\n            messageSequence.add(false);\n        }\n        else\n            messageSequence.add(response);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/stunclient/ResponseSequenceServer.java", "class_name": "ResponseSequenceServer", "class_uri": "src/test/java/org/ice4j/stunclient/ResponseSequenceServer.java.ResponseSequenceServer", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nAdds the specified response to this sequence or marks a pause (i.e. do\nnot respond) if response is null.\n@param response the response to add or null to mark a pause\n"}, {"uris": "src/test/java/org/ice4j/stunclient/ResponseSequenceServer.java.ResponseSequenceServer.[void]processRequest(StunMessageEvent)", "name": "processRequest", "arg_nums": 1, "params": [{"name": "evt", "type": "StunMessageEvent"}], "return_type": "void", "signature": "public void processRequest(StunMessageEvent evt)", "original_string": "    public void processRequest(StunMessageEvent evt)\n    {\n        if(messageSequence.isEmpty())\n            return;\n        Object obj = messageSequence.remove(0);\n\n        if( !(obj instanceof Response) )\n            return;\n\n        Response res = (Response)obj;\n\n        try\n        {\n            stunStack.sendResponse(evt.getMessage().getTransactionID(),\n                res, serverAddress, evt.getRemoteAddress());\n        }\n        catch (Exception ex)\n        {\n            logger.log(Level.WARNING, \"failed to send a response\", ex);\n        }\n\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/stunclient/ResponseSequenceServer.java", "class_name": "ResponseSequenceServer", "class_uri": "src/test/java/org/ice4j/stunclient/ResponseSequenceServer.java.ResponseSequenceServer", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCompletely ignores the event that is passed and just sends the next\nmessage from the sequence - or does nothing if there's something\ndifferent from a Response on the current position.\n@param evt the event being dispatched\n"}, {"uris": "src/test/java/org/ice4j/stunclient/ResponseSequenceServer.java.ResponseSequenceServer.[String]toString()", "name": "toString", "arg_nums": 0, "params": [], "return_type": "String", "signature": "public String toString()", "original_string": "    public String toString()\n    {\n        return serverAddress == null?\"null\":serverAddress.toString();\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/stunclient/ResponseSequenceServer.java", "class_name": "ResponseSequenceServer", "class_uri": "src/test/java/org/ice4j/stunclient/ResponseSequenceServer.java.ResponseSequenceServer", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns a string representation of this Server.\n@return the ip address and port where this server is bound\n"}, {"uris": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest_v4v6.java.StunAddressDiscovererTest_v4v6.[void]setUp()", "name": "setUp", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@BeforeEach\n    public void setUp()", "original_string": "    @BeforeEach\n    public void setUp()\n        throws Exception\n    {\n        StunStack stunStack = new StunStack();\n\n        responseServer_v6\n            = new ResponseSequenceServer(stunStack, responseServerAddress_v6);\n        responseServer_v4\n            = new ResponseSequenceServer(stunStack, responseServerAddress_v4);\n\n        stunAddressDiscoverer_v6\n            = new NetworkConfigurationDiscoveryProcess(\n                    stunStack,\n                    discovererAddress_v6, responseServerAddress_v6);\n        stunAddressDiscoverer_v4\n            = new NetworkConfigurationDiscoveryProcess(\n                    stunStack,\n                    discovererAddress_v4, responseServerAddress_v4);\n\n        stunAddressDiscoverer_v6.start();\n        stunAddressDiscoverer_v4.start();\n        responseServer_v6.start();\n        responseServer_v4.start();\n\n        System.setProperty(StackProperties.MAX_CTRAN_RETRANS_TIMER , \"100\");\n        System.setProperty(StackProperties.MAX_CTRAN_RETRANSMISSIONS, \"2\");\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest_v4v6.java", "class_name": "StunAddressDiscovererTest_v4v6", "class_uri": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest_v4v6.java.StunAddressDiscovererTest_v4v6", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest_v4v6.java.StunAddressDiscovererTest_v4v6.[void]tearDown()", "name": "tearDown", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@AfterEach\n    public void tearDown()", "original_string": "    @AfterEach\n    public void tearDown()\n        throws Exception\n    {\n        System.clearProperty(StackProperties.MAX_CTRAN_RETRANS_TIMER);\n        System.clearProperty(StackProperties.MAX_CTRAN_RETRANSMISSIONS);\n\n        responseServer_v6.shutDown();\n        responseServer_v4.shutDown();\n        stunAddressDiscoverer_v6.shutDown();\n        stunAddressDiscoverer_v6 = null;\n        stunAddressDiscoverer_v4.shutDown();\n        stunAddressDiscoverer_v4 = null;\n\n        //give the sockets the time to clear out\n        Thread.sleep(1000);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest_v4v6.java", "class_name": "StunAddressDiscovererTest_v4v6", "class_uri": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest_v4v6.java.StunAddressDiscovererTest_v4v6", "attributes": {"modifiers": "@AfterEach\n    public", "marker_annotations": ["@AfterEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest.java.StunAddressDiscovererTest.[void]setUp()", "name": "setUp", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@BeforeEach\n    public void setUp()", "original_string": "    @BeforeEach\n    public void setUp() throws Exception\n    {\n        System.setProperty(StackProperties.MAX_CTRAN_RETRANS_TIMER, \"100\");\n        System.setProperty(StackProperties.MAX_CTRAN_RETRANSMISSIONS, \"2\");\n\n        StunStack stunStack = new StunStack();\n\n        responseServer\n            = new ResponseSequenceServer(stunStack, responseServerAddress);\n        stunAddressDiscoverer\n            = new NetworkConfigurationDiscoveryProcess(\n                    stunStack,\n                    discovererAddress, responseServerAddress);\n\n        stunAddressDiscoverer.start();\n        responseServer.start();\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest.java", "class_name": "StunAddressDiscovererTest", "class_uri": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest.java.StunAddressDiscovererTest", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest.java.StunAddressDiscovererTest.[void]tearDown()", "name": "tearDown", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@AfterEach\n    public void tearDown()", "original_string": "    @AfterEach\n    public void tearDown() throws Exception\n    {\n        System.clearProperty(StackProperties.MAX_CTRAN_RETRANS_TIMER);\n        System.clearProperty(StackProperties.MAX_CTRAN_RETRANSMISSIONS);\n        responseServer.shutDown();\n        stunAddressDiscoverer.shutDown();\n        stunAddressDiscoverer = null;\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest.java", "class_name": "StunAddressDiscovererTest", "class_uri": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest.java.StunAddressDiscovererTest", "attributes": {"modifiers": "@AfterEach\n    public", "marker_annotations": ["@AfterEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/stack/ShallowStackTest.java.ShallowStackTest.[void]setupConfig()", "name": "setupConfig", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@BeforeAll\n    public static void setupConfig()", "original_string": "    @BeforeAll\n    public static void setupConfig()\n    {\n        System.clearProperty(StackProperties.ALWAYS_SIGN);\n        System.setProperty(\"ice4j.software\", \"\");\n        JitsiConfig.Companion.reloadNewConfig();\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/stack/ShallowStackTest.java", "class_name": "ShallowStackTest", "class_uri": "src/test/java/org/ice4j/stack/ShallowStackTest.java.ShallowStackTest", "attributes": {"modifiers": "@BeforeAll\n    public static", "marker_annotations": ["@BeforeAll"], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/stack/ShallowStackTest.java.ShallowStackTest.[void]resetConfig()", "name": "resetConfig", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@AfterAll\n    public static void resetConfig()", "original_string": "    @AfterAll\n    public static void resetConfig()\n    {\n        System.clearProperty(\"ice4j.software\");\n        JitsiConfig.Companion.reloadNewConfig();\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/stack/ShallowStackTest.java", "class_name": "ShallowStackTest", "class_uri": "src/test/java/org/ice4j/stack/ShallowStackTest.java.ShallowStackTest", "attributes": {"modifiers": "@AfterAll\n    public static", "marker_annotations": ["@AfterAll"], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/stack/ShallowStackTest.java.ShallowStackTest.[void]setUp()", "name": "setUp", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@BeforeEach\n    public void setUp()", "original_string": "    @BeforeEach\n    public void setUp()\n        throws Exception\n    {\n        msgFixture = new MsgFixture();\n\n        //init the stack\n        stunStack = new StunStack();\n\n        //access point\n        localSock = new IceUdpSocketWrapper(\n            new SafeCloseDatagramSocket(new InetSocketAddress(\"127.0.0.1\", 0)));\n        localAddress = new TransportAddress(\n            \"127.0.0.1\", localSock.getLocalPort(), Transport.UDP);\n        stunStack.addSocket(localSock);\n\n        //init the dummy server\n        dummyServerSocket = new DatagramSocket(new InetSocketAddress(\"127.0.0.1\", 0));\n        dummyServerAddress = new TransportAddress(\n            \"127.0.0.1\", dummyServerSocket.getLocalPort(), Transport.UDP);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/stack/ShallowStackTest.java", "class_name": "ShallowStackTest", "class_uri": "src/test/java/org/ice4j/stack/ShallowStackTest.java.ShallowStackTest", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nInitializes whatever sockets we'll be using in our tests.\n\n@throws Exception if something goes wrong with socket initialization.\n"}, {"uris": "src/test/java/org/ice4j/stack/ShallowStackTest.java.ShallowStackTest.[void]tearDown()", "name": "tearDown", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@AfterEach\n    public void tearDown()", "original_string": "    @AfterEach\n    public void tearDown()\n        throws Exception\n    {\n        stunStack.removeSocket(localAddress);\n        stunStack.shutDown();\n\n        localSock.close();\n\n        dummyServerSocket.close();\n\n        msgFixture = null;\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/stack/ShallowStackTest.java", "class_name": "ShallowStackTest", "class_uri": "src/test/java/org/ice4j/stack/ShallowStackTest.java.ShallowStackTest", "attributes": {"modifiers": "@AfterEach\n    public", "marker_annotations": ["@AfterEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nReleases the sockets we use here.\n\n@throws Exception if closing the sockets fails.\n"}, {"uris": "src/test/java/org/ice4j/stack/DatagramCollector.java.DatagramCollector.[]DatagramCollector()", "name": "DatagramCollector", "arg_nums": 0, "params": [], "return_type": "", "signature": "public DatagramCollector()", "original_string": "    public DatagramCollector()\n    {\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/stack/DatagramCollector.java", "class_name": "DatagramCollector", "class_uri": "src/test/java/org/ice4j/stack/DatagramCollector.java.DatagramCollector", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/stack/DatagramCollector.java.DatagramCollector.[void]run()", "name": "run", "arg_nums": 0, "params": [], "return_type": "void", "signature": "public void run()", "original_string": "    public void run()\n    {\n        try\n        {\n            // The 'receive' method synchronized the packet, hence the 'getData()' (also synchronized) will block\n            // on this anyway even after 'waitForPacket' and 'collectPacket' calls.\n            sock.receive(receivedPacket);\n\n            synchronized (this)\n            {\n                packetReceived = true;\n                notifyAll();\n            }\n\n        }\n        catch (IOException ex)\n        {\n            receivedPacket = null;\n        }\n\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/stack/DatagramCollector.java", "class_name": "DatagramCollector", "class_uri": "src/test/java/org/ice4j/stack/DatagramCollector.java.DatagramCollector", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/stack/DatagramCollector.java.DatagramCollector.[void]startListening(DatagramSocket)", "name": "startListening", "arg_nums": 1, "params": [{"name": "sock", "type": "DatagramSocket"}], "return_type": "void", "signature": "public void startListening(DatagramSocket sock)", "original_string": "    public void startListening(DatagramSocket sock)\n    {\n        this.sock = sock;\n        receivedPacket = new DatagramPacket(new byte[4096], 4096);\n\n        new Thread(this).start();\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/stack/DatagramCollector.java", "class_name": "DatagramCollector", "class_uri": "src/test/java/org/ice4j/stack/DatagramCollector.java.DatagramCollector", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/stack/DatagramCollector.java.DatagramCollector.[void]waitForPacket()", "name": "waitForPacket", "arg_nums": 0, "params": [], "return_type": "void", "signature": "public void waitForPacket()", "original_string": "    public void waitForPacket()\n    {\n        waitForPacket(50);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/stack/DatagramCollector.java", "class_name": "DatagramCollector", "class_uri": "src/test/java/org/ice4j/stack/DatagramCollector.java.DatagramCollector", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/stack/DatagramCollector.java.DatagramCollector.[void]waitForPacket(long)", "name": "waitForPacket", "arg_nums": 1, "params": [{"name": "timeoutMillis", "type": "long"}], "return_type": "void", "signature": "public void waitForPacket(long timeoutMillis)", "original_string": "    public void waitForPacket(long timeoutMillis)\n    {\n        synchronized(this)\n        {\n            if(packetReceived)\n                return;\n\n            try\n            {\n                wait(timeoutMillis);\n            }\n            catch (InterruptedException e)\n            {\n                e.printStackTrace();\n                Thread.currentThread().interrupt();\n            }\n        }\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/stack/DatagramCollector.java", "class_name": "DatagramCollector", "class_uri": "src/test/java/org/ice4j/stack/DatagramCollector.java.DatagramCollector", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/stack/DatagramCollector.java.DatagramCollector.[DatagramPacket]collectPacket()", "name": "collectPacket", "arg_nums": 0, "params": [], "return_type": "DatagramPacket", "signature": "public DatagramPacket collectPacket()", "original_string": "    public DatagramPacket collectPacket()\n    {\n        //recycle\n        DatagramPacket returnValue = receivedPacket;\n        receivedPacket = null;\n        sock           = null;\n        packetReceived = false;\n\n        //return\n        return returnValue;\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/stack/DatagramCollector.java", "class_name": "DatagramCollector", "class_uri": "src/test/java/org/ice4j/stack/DatagramCollector.java.DatagramCollector", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "DatagramPacket", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/attribute/ErrorCodeAttribute_getNameTest.java.ErrorCodeAttribute_getNameTest.[void]setUp()", "name": "setUp", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@BeforeEach\n    public void setUp()", "original_string": "    @BeforeEach\n    public void setUp() {\n        errorCodeAttribute = new ErrorCodeAttribute();\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/ErrorCodeAttribute_getNameTest.java", "class_name": "ErrorCodeAttribute_getNameTest", "class_uri": "src/test/java/org/ice4j/attribute/ErrorCodeAttribute_getNameTest.java.ErrorCodeAttribute_getNameTest", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/attribute/RequestedAddressFamilyAttribute_getNameTest.java.RequestedAddressFamilyAttribute_getNameTest.[void]setUp()", "name": "setUp", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@BeforeEach\n    public void setUp()", "original_string": "    @BeforeEach\n    public void setUp() throws Exception {\n        this.requestedAddressFamilyAttribute = new RequestedAddressFamilyAttribute();\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/RequestedAddressFamilyAttribute_getNameTest.java", "class_name": "RequestedAddressFamilyAttribute_getNameTest", "class_uri": "src/test/java/org/ice4j/attribute/RequestedAddressFamilyAttribute_getNameTest.java.RequestedAddressFamilyAttribute_getNameTest", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/attribute/SoftwareAttributeTest.java.SoftwareAttributeTest.[void]setUp()", "name": "setUp", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@BeforeEach\n    public void setUp()", "original_string": "    @BeforeEach\n    public void setUp() throws Exception\n    {\n        msgFixture = new MsgFixture();\n\n        softwareAttribute = new SoftwareAttribute();\n        softwareAttribute.setSoftware(softwareValue.getBytes());\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/SoftwareAttributeTest.java", "class_name": "SoftwareAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/SoftwareAttributeTest.java.SoftwareAttributeTest", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/attribute/SoftwareAttributeTest.java.SoftwareAttributeTest.[void]tearDown()", "name": "tearDown", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@AfterEach\n    public void tearDown()", "original_string": "    @AfterEach\n    public void tearDown() throws Exception\n    {\n        softwareAttribute = null;\n        msgFixture = null;\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/SoftwareAttributeTest.java", "class_name": "SoftwareAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/SoftwareAttributeTest.java.SoftwareAttributeTest", "attributes": {"modifiers": "@AfterEach\n    public", "marker_annotations": ["@AfterEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/attribute/RealmAttributeTest.java.RealmAttributeTest.[void]setUp()", "name": "setUp", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@BeforeEach\n    public void setUp()", "original_string": "    @BeforeEach\n    public void setUp() throws Exception\n    {\n        msgFixture = new MsgFixture();\n\n        realmAttribute = new RealmAttribute();\n        realmAttribute.setRealm(realmValue.getBytes());\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/RealmAttributeTest.java", "class_name": "RealmAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/RealmAttributeTest.java.RealmAttributeTest", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/attribute/RealmAttributeTest.java.RealmAttributeTest.[void]tearDown()", "name": "tearDown", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@AfterEach\n    public void tearDown()", "original_string": "    @AfterEach\n    public void tearDown() throws Exception\n    {\n        realmAttribute = null;\n        msgFixture = null;\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/RealmAttributeTest.java", "class_name": "RealmAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/RealmAttributeTest.java.RealmAttributeTest", "attributes": {"modifiers": "@AfterEach\n    public", "marker_annotations": ["@AfterEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/attribute/ConnectionIdAttribute_getNameTest.java.ConnectionIdAttribute_getNameTest.[void]setUp()", "name": "setUp", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@BeforeEach\n    public void setUp()", "original_string": "    @BeforeEach\n    public void setUp() {\n        connectionIdAttribute = new ConnectionIdAttribute();\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/ConnectionIdAttribute_getNameTest.java", "class_name": "ConnectionIdAttribute_getNameTest", "class_uri": "src/test/java/org/ice4j/attribute/ConnectionIdAttribute_getNameTest.java.ConnectionIdAttribute_getNameTest", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/attribute/UnknownAttributesAttribute_addAttributeIDTest.java.UnknownAttributesAttribute_addAttributeIDTest.[void]setUp()", "name": "setUp", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@BeforeEach\n    public void setUp()", "original_string": "    @BeforeEach\n    public void setUp() {\n        unknownAttributesAttribute = new UnknownAttributesAttribute();\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/UnknownAttributesAttribute_addAttributeIDTest.java", "class_name": "UnknownAttributesAttribute_addAttributeIDTest", "class_uri": "src/test/java/org/ice4j/attribute/UnknownAttributesAttribute_addAttributeIDTest.java.UnknownAttributesAttribute_addAttributeIDTest", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/attribute/RequestedAddressFamilyAttribute_getDataLengthTest.java.RequestedAddressFamilyAttribute_getDataLengthTest.[void]setUp()", "name": "setUp", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@BeforeEach\n    public void setUp()", "original_string": "    @BeforeEach\n    public void setUp() throws Exception {\n        this.requestedAddressFamilyAttribute = new RequestedAddressFamilyAttribute();\n        this.msgFixture = new MsgFixture();\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/RequestedAddressFamilyAttribute_getDataLengthTest.java", "class_name": "RequestedAddressFamilyAttribute_getDataLengthTest", "class_uri": "src/test/java/org/ice4j/attribute/RequestedAddressFamilyAttribute_getDataLengthTest.java.RequestedAddressFamilyAttribute_getDataLengthTest", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/attribute/UnknownAttributesAttributeTest.java.UnknownAttributesAttributeTest.[void]setUp()", "name": "setUp", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@BeforeEach\n    public void setUp()", "original_string": "    @BeforeEach\n    public void setUp() throws Exception\n    {\n        unknownAttributesAttribute = new UnknownAttributesAttribute();\n        binMessagesFixture = new MsgFixture();\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/UnknownAttributesAttributeTest.java", "class_name": "UnknownAttributesAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/UnknownAttributesAttributeTest.java.UnknownAttributesAttributeTest", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/attribute/UnknownAttributesAttributeTest.java.UnknownAttributesAttributeTest.[void]tearDown()", "name": "tearDown", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@AfterEach\n    public void tearDown()", "original_string": "    @AfterEach\n    public void tearDown() throws Exception\n    {\n        unknownAttributesAttribute = null;\n        binMessagesFixture = null;\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/UnknownAttributesAttributeTest.java", "class_name": "UnknownAttributesAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/UnknownAttributesAttributeTest.java.UnknownAttributesAttributeTest", "attributes": {"modifiers": "@AfterEach\n    public", "marker_annotations": ["@AfterEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/attribute/RequestedAddressFamilyAttributeTest.java.RequestedAddressFamilyAttributeTest.[void]setUp()", "name": "setUp", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@BeforeEach\n    public void setUp()", "original_string": "    @BeforeEach\n    public void setUp() throws Exception\n    {\n        this.requestedAddressFamilyAttribute =\n            new RequestedAddressFamilyAttribute();\n        this.msgFixture = new MsgFixture();\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/RequestedAddressFamilyAttributeTest.java", "class_name": "RequestedAddressFamilyAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/RequestedAddressFamilyAttributeTest.java.RequestedAddressFamilyAttributeTest", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/attribute/RequestedAddressFamilyAttributeTest.java.RequestedAddressFamilyAttributeTest.[void]tearDown()", "name": "tearDown", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@AfterEach\n    public void tearDown()", "original_string": "    @AfterEach\n    public void tearDown() throws Exception\n    {\n        this.requestedAddressFamilyAttribute = null;\n        this.msgFixture = null;\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/RequestedAddressFamilyAttributeTest.java", "class_name": "RequestedAddressFamilyAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/RequestedAddressFamilyAttributeTest.java.RequestedAddressFamilyAttributeTest", "attributes": {"modifiers": "@AfterEach\n    public", "marker_annotations": ["@AfterEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/attribute/RequestedAddressFamilyAttribute_setFamilyTest.java.RequestedAddressFamilyAttribute_setFamilyTest.[void]setUp()", "name": "setUp", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@BeforeEach\n    public void setUp()", "original_string": "    @BeforeEach\n    public void setUp() throws Exception {\n        this.requestedAddressFamilyAttribute = new RequestedAddressFamilyAttribute();\n        this.msgFixture = new MsgFixture();\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/RequestedAddressFamilyAttribute_setFamilyTest.java", "class_name": "RequestedAddressFamilyAttribute_setFamilyTest", "class_uri": "src/test/java/org/ice4j/attribute/RequestedAddressFamilyAttribute_setFamilyTest.java.RequestedAddressFamilyAttribute_setFamilyTest", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/attribute/AddressAttributeTest.java.AddressAttributeTest.[void]setUp()", "name": "setUp", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@BeforeEach\n    public void setUp()", "original_string": "    @BeforeEach\n    public void setUp() throws Exception\n    {\n        addressAttribute = new MappedAddressAttribute();\n        msgFixture = new MsgFixture();\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/AddressAttributeTest.java", "class_name": "AddressAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/AddressAttributeTest.java.AddressAttributeTest", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/attribute/AddressAttributeTest.java.AddressAttributeTest.[void]tearDown()", "name": "tearDown", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@AfterEach\n    public void tearDown()", "original_string": "    @AfterEach\n    public void tearDown() throws Exception\n    {\n        addressAttribute = null;\n        msgFixture = null;\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/AddressAttributeTest.java", "class_name": "AddressAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/AddressAttributeTest.java.AddressAttributeTest", "attributes": {"modifiers": "@AfterEach\n    public", "marker_annotations": ["@AfterEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/attribute/OptionalAttributeAttributeTest.java.OptionalAttributeAttributeTest.[void]setUp()", "name": "setUp", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@BeforeEach\n    public void setUp()", "original_string": "    @BeforeEach\n    public void setUp() throws Exception\n    {\n        msgFixture = new MsgFixture();\n        int offset = Attribute.HEADER_LENGTH;\n\n        //init a sample body\n        expectedAttributeValue =\n            new byte[msgFixture.unknownOptionalAttribute.length - offset];\n\n        System.arraycopy(msgFixture.unknownOptionalAttribute, offset,\n                         expectedAttributeValue, 0,\n                         expectedAttributeValue.length);\n\n        optionalAttribute = new OptionalAttribute(\n                                        msgFixture.optionalAttributeType);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/OptionalAttributeAttributeTest.java", "class_name": "OptionalAttributeAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/OptionalAttributeAttributeTest.java.OptionalAttributeAttributeTest", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/attribute/OptionalAttributeAttributeTest.java.OptionalAttributeAttributeTest.[void]tearDown()", "name": "tearDown", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@AfterEach\n    public void tearDown()", "original_string": "    @AfterEach\n    public void tearDown() throws Exception\n    {\n        optionalAttribute = null;\n        expectedAttributeValue = null;\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/OptionalAttributeAttributeTest.java", "class_name": "OptionalAttributeAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/OptionalAttributeAttributeTest.java.OptionalAttributeAttributeTest", "attributes": {"modifiers": "@AfterEach\n    public", "marker_annotations": ["@AfterEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/attribute/ErrorCodeAttributeTest.java.ErrorCodeAttributeTest.[void]setUp()", "name": "setUp", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@BeforeEach\n    public void setUp()", "original_string": "    @BeforeEach\n    public void setUp() throws Exception\n    {\n        errorCodeAttribute = new ErrorCodeAttribute();\n        msgFixture = new MsgFixture();\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/ErrorCodeAttributeTest.java", "class_name": "ErrorCodeAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/ErrorCodeAttributeTest.java.ErrorCodeAttributeTest", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/attribute/ErrorCodeAttributeTest.java.ErrorCodeAttributeTest.[void]tearDown()", "name": "tearDown", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@AfterEach\n    public void tearDown()", "original_string": "    @AfterEach\n    public void tearDown() throws Exception {\n        errorCodeAttribute = null;\n        msgFixture = null;\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/ErrorCodeAttributeTest.java", "class_name": "ErrorCodeAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/ErrorCodeAttributeTest.java.ErrorCodeAttributeTest", "attributes": {"modifiers": "@AfterEach\n    public", "marker_annotations": ["@AfterEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/attribute/AttributeDecoderTest.java.AttributeDecoderTest.[void]setUp()", "name": "setUp", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@BeforeEach\n    public void setUp()", "original_string": "    @BeforeEach\n    public void setUp() throws Exception\n    {\n        msgFixture = new MsgFixture();\n\n        //init a sample body\n        int offset = Attribute.HEADER_LENGTH;\n        expectedAttributeValue =\n            new byte[msgFixture.unknownOptionalAttribute.length - offset];\n        System.arraycopy(msgFixture.unknownOptionalAttribute, offset,\n                         expectedAttributeValue, 0,\n                         expectedAttributeValue.length);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/AttributeDecoderTest.java", "class_name": "AttributeDecoderTest", "class_uri": "src/test/java/org/ice4j/attribute/AttributeDecoderTest.java.AttributeDecoderTest", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/attribute/AttributeDecoderTest.java.AttributeDecoderTest.[void]tearDown()", "name": "tearDown", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@AfterEach\n    public void tearDown()", "original_string": "    @AfterEach\n    public void tearDown() throws Exception\n    {\n        msgFixture = null;\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/AttributeDecoderTest.java", "class_name": "AttributeDecoderTest", "class_uri": "src/test/java/org/ice4j/attribute/AttributeDecoderTest.java.AttributeDecoderTest", "attributes": {"modifiers": "@AfterEach\n    public", "marker_annotations": ["@AfterEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/attribute/ErrorCodeAttribute_getReasonPhraseTest.java.ErrorCodeAttribute_getReasonPhraseTest.[void]setUp()", "name": "setUp", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@BeforeEach\n    public void setUp()", "original_string": "    @BeforeEach\n    public void setUp() {\n        errorCodeAttribute = new ErrorCodeAttribute();\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/ErrorCodeAttribute_getReasonPhraseTest.java", "class_name": "ErrorCodeAttribute_getReasonPhraseTest", "class_uri": "src/test/java/org/ice4j/attribute/ErrorCodeAttribute_getReasonPhraseTest.java.ErrorCodeAttribute_getReasonPhraseTest", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/attribute/RequestedAddressFamilyAttribute_equalsTest.java.RequestedAddressFamilyAttribute_equalsTest.[void]setUp()", "name": "setUp", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@BeforeEach\n    public void setUp()", "original_string": "    @BeforeEach\n    public void setUp() throws Exception {\n        this.requestedAddressFamilyAttribute = new RequestedAddressFamilyAttribute();\n        this.msgFixture = new MsgFixture();\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/RequestedAddressFamilyAttribute_equalsTest.java", "class_name": "RequestedAddressFamilyAttribute_equalsTest", "class_uri": "src/test/java/org/ice4j/attribute/RequestedAddressFamilyAttribute_equalsTest.java.RequestedAddressFamilyAttribute_equalsTest", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/attribute/ErrorCodeAttribute_setErrorClassTest.java.ErrorCodeAttribute_setErrorClassTest.[void]setUp()", "name": "setUp", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@BeforeEach\n    public void setUp()", "original_string": "    @BeforeEach\n    public void setUp() {\n        errorCodeAttribute = new ErrorCodeAttribute();\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/ErrorCodeAttribute_setErrorClassTest.java", "class_name": "ErrorCodeAttribute_setErrorClassTest", "class_uri": "src/test/java/org/ice4j/attribute/ErrorCodeAttribute_setErrorClassTest.java.ErrorCodeAttribute_setErrorClassTest", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/attribute/ConnectionIdAttribute_equalsTest.java.ConnectionIdAttribute_equalsTest.[void]setUp()", "name": "setUp", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@BeforeEach\n    public void setUp()", "original_string": "    @BeforeEach\n    public void setUp() throws Exception {\n        this.connectionIdAttribute = new ConnectionIdAttribute();\n        this.msgFixture = new MsgFixture();\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/ConnectionIdAttribute_equalsTest.java", "class_name": "ConnectionIdAttribute_equalsTest", "class_uri": "src/test/java/org/ice4j/attribute/ConnectionIdAttribute_equalsTest.java.ConnectionIdAttribute_equalsTest", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/attribute/ConnectionIdAttributeTest.java.ConnectionIdAttributeTest.[void]setUp()", "name": "setUp", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@BeforeEach\n    public void setUp()", "original_string": "    @BeforeEach\n    public void setUp() throws Exception\n    {\n        this.connectionIdAttribute = new ConnectionIdAttribute();\n        this.msgFixture = new MsgFixture();\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/ConnectionIdAttributeTest.java", "class_name": "ConnectionIdAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/ConnectionIdAttributeTest.java.ConnectionIdAttributeTest", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/attribute/ConnectionIdAttributeTest.java.ConnectionIdAttributeTest.[void]tearDown()", "name": "tearDown", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@AfterEach\n    public void tearDown()", "original_string": "    @AfterEach\n    public void tearDown() throws Exception\n    {\n        this.connectionIdAttribute = null;\n        this.msgFixture = null;\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/ConnectionIdAttributeTest.java", "class_name": "ConnectionIdAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/ConnectionIdAttributeTest.java.ConnectionIdAttributeTest", "attributes": {"modifiers": "@AfterEach\n    public", "marker_annotations": ["@AfterEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/attribute/UnknownAttributesAttribute_equalsTest.java.UnknownAttributesAttribute_equalsTest.[void]setUp()", "name": "setUp", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@BeforeEach\n    public void setUp()", "original_string": "    @BeforeEach\n    public void setUp() throws Exception {\n        unknownAttributesAttribute = new UnknownAttributesAttribute();\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/UnknownAttributesAttribute_equalsTest.java", "class_name": "UnknownAttributesAttribute_equalsTest", "class_uri": "src/test/java/org/ice4j/attribute/UnknownAttributesAttribute_equalsTest.java.UnknownAttributesAttribute_equalsTest", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/attribute/OptionalAttribute_equalsTest.java.OptionalAttribute_equalsTest.[void]setUp()", "name": "setUp", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@BeforeEach\n    public void setUp()", "original_string": "    @BeforeEach\n    public void setUp() throws Exception {\n        msgFixture = new MsgFixture();\n        int offset = Attribute.HEADER_LENGTH;\n\n        // Init a sample body\n        expectedAttributeValue =\n            new byte[msgFixture.unknownOptionalAttribute.length - offset];\n\n        System.arraycopy(msgFixture.unknownOptionalAttribute, offset,\n                         expectedAttributeValue, 0,\n                         expectedAttributeValue.length);\n\n        optionalAttribute = new OptionalAttribute(\n                                        msgFixture.optionalAttributeType);\n        optionalAttribute.decodeAttributeBody(msgFixture.unknownOptionalAttribute,\n                                              (char)Attribute.HEADER_LENGTH,\n                                              (char)expectedAttributeValue.length);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/OptionalAttribute_equalsTest.java", "class_name": "OptionalAttribute_equalsTest", "class_uri": "src/test/java/org/ice4j/attribute/OptionalAttribute_equalsTest.java.OptionalAttribute_equalsTest", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/attribute/ChangeRequestAttribute_equalsTest.java.ChangeRequestAttribute_equalsTest.[void]setUp()", "name": "setUp", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@BeforeEach\n    public void setUp()", "original_string": "    @BeforeEach\n    public void setUp() throws Exception {\n        changeRequestAttribute = new ChangeRequestAttribute();\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/ChangeRequestAttribute_equalsTest.java", "class_name": "ChangeRequestAttribute_equalsTest", "class_uri": "src/test/java/org/ice4j/attribute/ChangeRequestAttribute_equalsTest.java.ChangeRequestAttribute_equalsTest", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/attribute/ErrorCodeAttribute_getDataLengthTest.java.ErrorCodeAttribute_getDataLengthTest.[void]setUp()", "name": "setUp", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@BeforeEach\n    public void setUp()", "original_string": "    @BeforeEach\n    public void setUp() {\n        errorCodeAttribute = new ErrorCodeAttribute();\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/ErrorCodeAttribute_getDataLengthTest.java", "class_name": "ErrorCodeAttribute_getDataLengthTest", "class_uri": "src/test/java/org/ice4j/attribute/ErrorCodeAttribute_getDataLengthTest.java.ErrorCodeAttribute_getDataLengthTest", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/attribute/ErrorCodeAttribute_getDefaultReasonPhraseTest.java.ErrorCodeAttribute_getDefaultReasonPhraseTest.[void]setUp()", "name": "setUp", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@BeforeEach\n    public void setUp()", "original_string": "    @BeforeEach\n    public void setUp() {\n        errorCodeAttribute = new ErrorCodeAttribute();\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/ErrorCodeAttribute_getDefaultReasonPhraseTest.java", "class_name": "ErrorCodeAttribute_getDefaultReasonPhraseTest", "class_uri": "src/test/java/org/ice4j/attribute/ErrorCodeAttribute_getDefaultReasonPhraseTest.java.ErrorCodeAttribute_getDefaultReasonPhraseTest", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/attribute/ChangeRequestAttributeTest.java.ChangeRequestAttributeTest.[void]setUp()", "name": "setUp", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@BeforeEach\n    public void setUp()", "original_string": "    @BeforeEach\n    public void setUp() throws Exception\n    {\n        changeRequestAttribute = new ChangeRequestAttribute();\n        binMessagesFixture = new MsgFixture();\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/ChangeRequestAttributeTest.java", "class_name": "ChangeRequestAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/ChangeRequestAttributeTest.java.ChangeRequestAttributeTest", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/attribute/ChangeRequestAttributeTest.java.ChangeRequestAttributeTest.[void]tearDown()", "name": "tearDown", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@AfterEach\n    public void tearDown()", "original_string": "    @AfterEach\n    public void tearDown() throws Exception\n    {\n        changeRequestAttribute = null;\n        binMessagesFixture = null;\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/ChangeRequestAttributeTest.java", "class_name": "ChangeRequestAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/ChangeRequestAttributeTest.java.ChangeRequestAttributeTest", "attributes": {"modifiers": "@AfterEach\n    public", "marker_annotations": ["@AfterEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/attribute/UsernameAttribute_equalsTest.java.UsernameAttribute_equalsTest.[void]setUp()", "name": "setUp", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@BeforeEach\n    public void setUp()", "original_string": "    @BeforeEach\n    public void setUp() throws Exception {\n        usernameValue = \"testUsername\";\n        usernameAttribute = new UsernameAttribute();\n        usernameAttribute.setUsername(usernameValue.getBytes());\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/UsernameAttribute_equalsTest.java", "class_name": "UsernameAttribute_equalsTest", "class_uri": "src/test/java/org/ice4j/attribute/UsernameAttribute_equalsTest.java.UsernameAttribute_equalsTest", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/attribute/ConnectionIdAttribute_getDataLengthTest.java.ConnectionIdAttribute_getDataLengthTest.[void]setUp()", "name": "setUp", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@BeforeEach\n    public void setUp()", "original_string": "    @BeforeEach\n    public void setUp() throws Exception {\n        this.connectionIdAttribute = new ConnectionIdAttribute();\n        this.msgFixture = new MsgFixture();\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/ConnectionIdAttribute_getDataLengthTest.java", "class_name": "ConnectionIdAttribute_getDataLengthTest", "class_uri": "src/test/java/org/ice4j/attribute/ConnectionIdAttribute_getDataLengthTest.java.ConnectionIdAttribute_getDataLengthTest", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/attribute/XorOnlyAttribute_equalsTest.java.XorOnlyAttribute_equalsTest.[void]setUp()", "name": "setUp", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@BeforeEach\n    public void setUp()", "original_string": "    @BeforeEach\n    public void setUp() {\n        xorOnly = new XorOnlyAttribute();\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/XorOnlyAttribute_equalsTest.java", "class_name": "XorOnlyAttribute_equalsTest", "class_uri": "src/test/java/org/ice4j/attribute/XorOnlyAttribute_equalsTest.java.XorOnlyAttribute_equalsTest", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/attribute/SoftwareAttribute_equalsTest.java.SoftwareAttribute_equalsTest.[void]setUp()", "name": "setUp", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@BeforeEach\n    public void setUp()", "original_string": "    @BeforeEach\n    public void setUp() {\n        softwareValue = \"TestSoftware\";\n        softwareAttribute1 = new SoftwareAttribute();\n        softwareAttribute1.setSoftware(softwareValue.getBytes());\n        softwareAttribute2 = new SoftwareAttribute();\n        softwareAttribute2.setSoftware(softwareValue.getBytes());\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/SoftwareAttribute_equalsTest.java", "class_name": "SoftwareAttribute_equalsTest", "class_uri": "src/test/java/org/ice4j/attribute/SoftwareAttribute_equalsTest.java.SoftwareAttribute_equalsTest", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/attribute/NonceAttributeTest.java.NonceAttributeTest.[void]setUp()", "name": "setUp", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@BeforeEach\n    public void setUp()", "original_string": "    @BeforeEach\n    public void setUp() throws Exception\n    {\n        msgFixture = new MsgFixture();\n        nonceAttribute = new NonceAttribute();\n        nonceAttribute.setNonce(nonceValue.getBytes());\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/NonceAttributeTest.java", "class_name": "NonceAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/NonceAttributeTest.java.NonceAttributeTest", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/attribute/NonceAttributeTest.java.NonceAttributeTest.[void]tearDown()", "name": "tearDown", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@AfterEach\n    public void tearDown()", "original_string": "    @AfterEach\n    public void tearDown() throws Exception\n    {\n        nonceAttribute = null;\n        msgFixture = null;\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/NonceAttributeTest.java", "class_name": "NonceAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/NonceAttributeTest.java.NonceAttributeTest", "attributes": {"modifiers": "@AfterEach\n    public", "marker_annotations": ["@AfterEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/attribute/NonceAttribute_equalsTest.java.NonceAttribute_equalsTest.[void]setUp()", "name": "setUp", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@BeforeEach\n    public void setUp()", "original_string": "    @BeforeEach\n    public void setUp() {\n        nonceAttribute = new NonceAttribute();\n        nonceValue = \"testNonce\".getBytes();\n        nonceAttribute.setNonce(nonceValue);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/NonceAttribute_equalsTest.java", "class_name": "NonceAttribute_equalsTest", "class_uri": "src/test/java/org/ice4j/attribute/NonceAttribute_equalsTest.java.NonceAttribute_equalsTest", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/attribute/UsernameAttributeTest.java.UsernameAttributeTest.[void]setUp()", "name": "setUp", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@BeforeEach\n    public void setUp()", "original_string": "    @BeforeEach\n    public void setUp() throws Exception\n    {\n        msgFixture = new MsgFixture();\n\n        usernameAttribute = new UsernameAttribute();\n        usernameAttribute.setUsername(usernameValue.getBytes());\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/UsernameAttributeTest.java", "class_name": "UsernameAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/UsernameAttributeTest.java.UsernameAttributeTest", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/attribute/UsernameAttributeTest.java.UsernameAttributeTest.[void]tearDown()", "name": "tearDown", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@AfterEach\n    public void tearDown()", "original_string": "    @AfterEach\n    public void tearDown() throws Exception\n    {\n        usernameAttribute = null;\n        msgFixture = null;\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/UsernameAttributeTest.java", "class_name": "UsernameAttributeTest", "class_uri": "src/test/java/org/ice4j/attribute/UsernameAttributeTest.java.UsernameAttributeTest", "attributes": {"modifiers": "@AfterEach\n    public", "marker_annotations": ["@AfterEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/attribute/XorOnlyTest.java.XorOnlyTest.[void]setUp()", "name": "setUp", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@BeforeEach\n    public void setUp()", "original_string": "    @BeforeEach\n    public void setUp() throws Exception\n    {\n        xorOnly = new XorOnlyAttribute();\n        msgFixture = new MsgFixture();\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/XorOnlyTest.java", "class_name": "XorOnlyTest", "class_uri": "src/test/java/org/ice4j/attribute/XorOnlyTest.java.XorOnlyTest", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/attribute/XorOnlyTest.java.XorOnlyTest.[void]tearDown()", "name": "tearDown", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@AfterEach\n    public void tearDown()", "original_string": "    @AfterEach\n    public void tearDown() throws Exception\n    {\n        xorOnly = null;\n        msgFixture = null;\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/XorOnlyTest.java", "class_name": "XorOnlyTest", "class_uri": "src/test/java/org/ice4j/attribute/XorOnlyTest.java.XorOnlyTest", "attributes": {"modifiers": "@AfterEach\n    public", "marker_annotations": ["@AfterEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/attribute/UnknownAttributesAttribute_getDataLengthTest.java.UnknownAttributesAttribute_getDataLengthTest.[void]setUp()", "name": "setUp", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@BeforeEach\n    public void setUp()", "original_string": "    @BeforeEach\n    public void setUp() {\n        unknownAttributesAttribute = new UnknownAttributesAttribute();\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/attribute/UnknownAttributesAttribute_getDataLengthTest.java", "class_name": "UnknownAttributesAttribute_getDataLengthTest", "class_uri": "src/test/java/org/ice4j/attribute/UnknownAttributesAttribute_getDataLengthTest.java.UnknownAttributesAttribute_getDataLengthTest", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/util/PeriodicRunnableTests.java.PeriodicRunnableTests.[void]beforeEach()", "name": "beforeEach", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@BeforeEach\n    void beforeEach()", "original_string": "    @BeforeEach\n    void beforeEach()\n    {\n        timer = new FakeScheduledExecutorService();\n        executor = mock(ExecutorService.class);\n        when(executor.submit(any(Runnable.class))).thenAnswer(a ->\n        {\n            ((Runnable)a.getArgument(0)).run();\n            return CompletableFuture.completedFuture(null);\n        });\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/util/PeriodicRunnableTests.java", "class_name": "PeriodicRunnableTests", "class_uri": "src/test/java/org/ice4j/util/PeriodicRunnableTests.java.PeriodicRunnableTests", "attributes": {"modifiers": "@BeforeEach", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/pseudotcp/MultiThreadSupportTest.java.MultiThreadSupportTest.[void]uncaughtException(Thread,Throwable)", "name": "uncaughtException", "arg_nums": 2, "params": [{"name": "t", "type": "Thread"}, {"name": "e", "type": "Throwable"}], "return_type": "void", "signature": "@Override\n    public void uncaughtException(Thread t, Throwable e)", "original_string": "    @Override\n    public void uncaughtException(Thread t, Throwable e)\n    {\n        synchronized (testLock)\n        {\n            testError = e;\n            errorThread = t;\n            testLock.notifyAll();\n        }\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/MultiThreadSupportTest.java", "class_name": "MultiThreadSupportTest", "class_uri": "src/test/java/org/ice4j/pseudotcp/MultiThreadSupportTest.java.MultiThreadSupportTest", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/pseudotcp/MultiThreadSupportTest.java.MultiThreadSupportTest.[boolean]assert_wait_until(BooleanSupplier,long)", "name": "assert_wait_until", "arg_nums": 2, "params": [{"name": "wait", "type": "BooleanSupplier"}, {"name": "timeoutMs", "type": "long"}], "return_type": "boolean", "signature": "protected boolean assert_wait_until(BooleanSupplier wait, long timeoutMs)", "original_string": "    protected boolean assert_wait_until(BooleanSupplier wait, long timeoutMs)\n    {\n        long timeoutNanos = TimeUnit.MILLISECONDS.toNanos(timeoutMs);\n        try\n        {\n            long start = System.nanoTime();\n            while (!wait.getAsBoolean() && (System.nanoTime() - start) < timeoutNanos)\n            {\n                synchronized (testLock)\n                {\n                    testLock.wait(ASSERT_WAIT_INTERVAL);\n                    if (testError != null)\n                    {\n                        testError.printStackTrace();\n                        fail(\"Error in thread: \" + errorThread.getName() + \" : \"\n                            + testError.getMessage());\n                    }\n                }\n            }\n            return wait.getAsBoolean();\n        }\n        catch (InterruptedException ex)\n        {\n            ex.printStackTrace();\n            fail(\"assert_wait - interrupted\");\n            //return is unreachable\n            return false;\n        }\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/MultiThreadSupportTest.java", "class_name": "MultiThreadSupportTest", "class_uri": "src/test/java/org/ice4j/pseudotcp/MultiThreadSupportTest.java.MultiThreadSupportTest", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase.[]PseudoTcpTestBase()", "name": "PseudoTcpTestBase", "arg_nums": 0, "params": [], "return_type": "", "signature": "public PseudoTcpTestBase()", "original_string": "    public PseudoTcpTestBase()\n    {\n        this.remoteTcp = new PseudoTCPBase(this, 1);\n        //Debug names are usefull to identify peers in log messages\n        remoteTcp.debugName = \"REM\";\n        this.localTcp = new PseudoTCPBase(this, 1);\n        localTcp.debugName = \"LOC\";\n        setLocalMtu(65535);\n        setRemoteMtu(65535);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java", "class_name": "PseudoTcpTestBase", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase.[byte[]]createDummyData(int)", "name": "createDummyData", "arg_nums": 1, "params": [{"name": "size", "type": "int"}], "return_type": "byte[]", "signature": "static public byte[] createDummyData(int size)", "original_string": "    static public byte[] createDummyData(int size)\n    {\n        byte[] dummy = new byte[size];\n        Random r = new Random();\n        r.nextBytes(dummy);\n        return dummy;\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java", "class_name": "PseudoTcpTestBase", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase", "attributes": {"modifiers": "static public", "marker_annotations": [], "non_marker_annotations": ["static", "public"], "comments": [], "return_type": "byte[]", "classes": []}, "docstring": "\nCreates some random data array\n\n@param size\n@return\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase.[void]setLocalMtu(int)", "name": "setLocalMtu", "arg_nums": 1, "params": [{"name": "mtu", "type": "int"}], "return_type": "void", "signature": "void setLocalMtu(int mtu)", "original_string": "    void setLocalMtu(int mtu)\n    {\n        localTcp.notifyMTU(mtu);\n        local_mtu_ = mtu;\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java", "class_name": "PseudoTcpTestBase", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets the <tt>mtu</tt> for local peer\n\n@param mtu\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase.[void]setRemoteMtu(int)", "name": "setRemoteMtu", "arg_nums": 1, "params": [{"name": "mtu", "type": "int"}], "return_type": "void", "signature": "void setRemoteMtu(int mtu)", "original_string": "    void setRemoteMtu(int mtu)\n    {\n        remoteTcp.notifyMTU(mtu);\n        remote_mtu_ = mtu;\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java", "class_name": "PseudoTcpTestBase", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets the <tt>mtu</tt> for remote peer\n\n@param mtu\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase.[void]setDelay(int)", "name": "setDelay", "arg_nums": 1, "params": [{"name": "delay", "type": "int"}], "return_type": "void", "signature": "void setDelay(int delay)", "original_string": "    void setDelay(int delay)\n    {\n        delay_ = delay;\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java", "class_name": "PseudoTcpTestBase", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets the delay introduced to packets delivery between peers\n\n@param delay\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase.[void]setLoss(int)", "name": "setLoss", "arg_nums": 1, "params": [{"name": "percent", "type": "int"}], "return_type": "void", "signature": "void setLoss(int percent)", "original_string": "    void setLoss(int percent)\n    {\n        loss_ = percent;\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java", "class_name": "PseudoTcpTestBase", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets loss % of packets transferred between local and remote peers\n\n@param percent\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase.[void]setOptNagling(boolean)", "name": "setOptNagling", "arg_nums": 1, "params": [{"name": "enable_nagles", "type": "boolean"}], "return_type": "void", "signature": "void setOptNagling(boolean enable_nagles)", "original_string": "    void setOptNagling(boolean enable_nagles)\n    {\n        localTcp.setOption(Option.OPT_NODELAY, enable_nagles ? 0 : 1);\n        remoteTcp.setOption(Option.OPT_NODELAY, enable_nagles ? 0 : 1);\n\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java", "class_name": "PseudoTcpTestBase", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets OptNagling for both local and remote peers\n\n@param enable_nagles\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase.[void]setOptAckDelay(int)", "name": "setOptAckDelay", "arg_nums": 1, "params": [{"name": "ack_delay", "type": "int"}], "return_type": "void", "signature": "void setOptAckDelay(int ack_delay)", "original_string": "    void setOptAckDelay(int ack_delay)\n    {\n        localTcp.setOption(Option.OPT_ACKDELAY, ack_delay);\n        remoteTcp.setOption(Option.OPT_ACKDELAY, ack_delay);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java", "class_name": "PseudoTcpTestBase", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets ack delay option for local and remote peers\n\n@param ack_delay\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase.[void]setOptSndBuf(int)", "name": "setOptSndBuf", "arg_nums": 1, "params": [{"name": "size", "type": "int"}], "return_type": "void", "signature": "void setOptSndBuf(int size)", "original_string": "    void setOptSndBuf(int size)\n    {\n        localTcp.setOption(Option.OPT_SNDBUF, size);\n        remoteTcp.setOption(Option.OPT_SNDBUF, size);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java", "class_name": "PseudoTcpTestBase", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets send buffer option for local and remote peers\n\n@param size\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase.[void]setRemoteOptRcvBuf(int)", "name": "setRemoteOptRcvBuf", "arg_nums": 1, "params": [{"name": "size", "type": "int"}], "return_type": "void", "signature": "void setRemoteOptRcvBuf(int size)", "original_string": "    void setRemoteOptRcvBuf(int size)\n    {\n        remoteTcp.setOption(Option.OPT_RCVBUF, size);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java", "class_name": "PseudoTcpTestBase", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets receive buffer size option for remote peer\n\n@param size\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase.[void]setLocalOptRcvBuf(int)", "name": "setLocalOptRcvBuf", "arg_nums": 1, "params": [{"name": "size", "type": "int"}], "return_type": "void", "signature": "void setLocalOptRcvBuf(int size)", "original_string": "    void setLocalOptRcvBuf(int size)\n    {\n        localTcp.setOption(Option.OPT_RCVBUF, size);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java", "class_name": "PseudoTcpTestBase", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets receive buffer size option for local peer\n\n@param size\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase.[void]disableRemoteWindowScale()", "name": "disableRemoteWindowScale", "arg_nums": 0, "params": [], "return_type": "void", "signature": "void disableRemoteWindowScale()", "original_string": "    void disableRemoteWindowScale()\n    {\n        remoteTcp.disableWindowScale();\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java", "class_name": "PseudoTcpTestBase", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nDisable window scaling for remote peer\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase.[void]disableLocalWindowScale()", "name": "disableLocalWindowScale", "arg_nums": 0, "params": [], "return_type": "void", "signature": "void disableLocalWindowScale()", "original_string": "    void disableLocalWindowScale()\n    {\n        localTcp.disableWindowScale();\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java", "class_name": "PseudoTcpTestBase", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nDisable window scaling for local peer\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase.[void]connect()", "name": "connect", "arg_nums": 0, "params": [], "return_type": "void", "signature": "void connect()", "original_string": "    void connect() throws IOException\n    {\n        localTcp.connect();\n        updateLocalClock();\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java", "class_name": "PseudoTcpTestBase", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nStarts the connection from local to remote peer\n\n@throws IOException\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase.[void]close()", "name": "close", "arg_nums": 0, "params": [], "return_type": "void", "signature": "void close()", "original_string": "    void close()\n    {\n        localTcp.close(false);\n        updateLocalClock();\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java", "class_name": "PseudoTcpTestBase", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCloses the connection\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase.[void]onTcpOpen(PseudoTCPBase)", "name": "onTcpOpen", "arg_nums": 1, "params": [{"name": "tcp", "type": "PseudoTCPBase"}], "return_type": "void", "signature": "@Override\n    public void onTcpOpen(PseudoTCPBase tcp)", "original_string": "    @Override\n    public void onTcpOpen(PseudoTCPBase tcp)\n    {\n        if (tcp == localTcp)\n        {\n            have_connected_ = true;\n            onTcpWriteable(tcp);\n        }\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java", "class_name": "PseudoTcpTestBase", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCatches the event OnTcpOpen on the local peer and marks have_connected\nflag\n\n@param tcp\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase.[void]onTcpClosed(PseudoTCPBase,IOException)", "name": "onTcpClosed", "arg_nums": 2, "params": [{"name": "tcp", "type": "PseudoTCPBase"}, {"name": "exc", "type": "IOException"}], "return_type": "void", "signature": "@Override\n    public void onTcpClosed(PseudoTCPBase tcp, IOException exc)", "original_string": "    @Override\n    public void onTcpClosed(PseudoTCPBase tcp, IOException exc)\n    {\n        assert exc == null;\n        if (tcp == remoteTcp)\n        {\n            have_disconnected_ = true;\n        }\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java", "class_name": "PseudoTcpTestBase", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCatches OnTcpClosed event on remote peer and marks have_disconnected flag\n\n@param tcp\n@param exc\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase.[int]randomInt()", "name": "randomInt", "arg_nums": 0, "params": [], "return_type": "int", "signature": "int randomInt()", "original_string": "    int randomInt()\n    {\n        return random.nextInt(100);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java", "class_name": "PseudoTcpTestBase", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "int", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase.[int]localSend(byte[],int)", "name": "localSend", "arg_nums": 2, "params": [{"name": "data", "type": "byte[]"}, {"name": "len", "type": "int"}], "return_type": "int", "signature": "int localSend(byte[] data, int len)", "original_string": "    int localSend(byte[] data, int len) throws IOException\n    {\n        return localTcp.send(data, len);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java", "class_name": "PseudoTcpTestBase", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "int", "classes": []}, "docstring": "\nSend the <tt>data</tt> from local to remote peer\n\n@param data\n@param len\n@return\n@throws IOException\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase.[int]localRecv(byte[],int)", "name": "localRecv", "arg_nums": 2, "params": [{"name": "buffer", "type": "byte[]"}, {"name": "len", "type": "int"}], "return_type": "int", "signature": "int localRecv(byte[] buffer, int len)", "original_string": "    int localRecv(byte[] buffer, int len) throws IOException\n    {\n        return localTcp.recv(buffer, len);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java", "class_name": "PseudoTcpTestBase", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "int", "classes": []}, "docstring": "\nReceive data as local peer\n\n@param buffer\n@param len\n@return\n@throws IOException\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase.[int]remoteRecv(byte[],int)", "name": "remoteRecv", "arg_nums": 2, "params": [{"name": "buffer", "type": "byte[]"}, {"name": "len", "type": "int"}], "return_type": "int", "signature": "int remoteRecv(byte[] buffer, int len)", "original_string": "    int remoteRecv(byte[] buffer, int len) throws IOException\n    {\n\n        return remoteTcp.recv(buffer, len);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java", "class_name": "PseudoTcpTestBase", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "int", "classes": []}, "docstring": "\nReceive data as remote peer\n\n@param buffer\n@param len\n@return\n@throws IOException\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase.[int]remoteSend(byte[],int)", "name": "remoteSend", "arg_nums": 2, "params": [{"name": "data", "type": "byte[]"}, {"name": "len", "type": "int"}], "return_type": "int", "signature": "int remoteSend(byte[] data, int len)", "original_string": "    int remoteSend(byte[] data, int len)\n        throws IOException\n    {\n        return remoteTcp.send(data, len);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java", "class_name": "PseudoTcpTestBase", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "int", "classes": []}, "docstring": "\nSends the <tt>data</tt> from remote to local peer\n\n@param data\n@param len\n@return\n@throws IOException\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase.[void]localPacket(byte[],int)", "name": "localPacket", "arg_nums": 2, "params": [{"name": "data", "type": "byte[]"}, {"name": "len", "type": "int"}], "return_type": "void", "signature": "private void localPacket(byte[] data, int len)", "original_string": "    private void localPacket(byte[] data, int len)\n        throws IOException\n    {\n        localTcp.notifyPacket(data, len);\n        updateLocalClock();\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java", "class_name": "PseudoTcpTestBase", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSimulates packet received by local peer\n\n@param data\n@param len\n@throws IOException\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase.[void]remotePacket(byte[],int)", "name": "remotePacket", "arg_nums": 2, "params": [{"name": "data", "type": "byte[]"}, {"name": "len", "type": "int"}], "return_type": "void", "signature": "private void remotePacket(byte[] data, int len)", "original_string": "    private void remotePacket(byte[] data, int len)\n        throws IOException\n    {\n        remoteTcp.notifyPacket(data, len);\n        updateRemoteClock();\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java", "class_name": "PseudoTcpTestBase", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSimulates packet received by remote peer\n\n@param data\n@param len\n@throws IOException\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase.[TimerTask]getWriteRemotePacketTask(byte[],int)", "name": "getWriteRemotePacketTask", "arg_nums": 2, "params": [{"name": "data", "type": "byte[]"}, {"name": "len", "type": "int"}], "return_type": "TimerTask", "signature": "private TimerTask getWriteRemotePacketTask(final byte[] data, final int len)", "original_string": "    private TimerTask getWriteRemotePacketTask(final byte[] data, final int len)\n    {\n        return new TimerTask()\n        {\n            @Override\n            public void run()\n            {\n                try\n                {\n                    remotePacket(data, len);\n                }\n                catch (IOException ex)\n                {\n                    throw new RuntimeException(ex);\n                }\n            }\n        };\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java", "class_name": "PseudoTcpTestBase", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "TimerTask", "classes": []}, "docstring": "\nCreates <tt>TimerTask</tt> with @link(RemotePacket) action\n\n@param data\n@param len\n@return\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase.[TimerTask]getWriteLocalPacketTask(byte[],int)", "name": "getWriteLocalPacketTask", "arg_nums": 2, "params": [{"name": "data", "type": "byte[]"}, {"name": "len", "type": "int"}], "return_type": "TimerTask", "signature": "private TimerTask getWriteLocalPacketTask(final byte[] data, final int len)", "original_string": "    private TimerTask getWriteLocalPacketTask(final byte[] data, final int len)\n    {\n        return new TimerTask()\n        {\n            @Override\n            public void run()\n            {\n                try\n                {\n                    localPacket(data, len);\n                }\n                catch (IOException ex)\n                {\n                    throw new RuntimeException(ex);\n                }\n            }\n        };\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java", "class_name": "PseudoTcpTestBase", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "TimerTask", "classes": []}, "docstring": "\nCreates <tt>TimerTask</tt> with @link(LocalPacket) action\n\n@param data\n@param len\n@return\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase.[WriteResult]tcpWritePacket(PseudoTCPBase,byte[],int)", "name": "tcpWritePacket", "arg_nums": 3, "params": [{"name": "tcp", "type": "PseudoTCPBase"}, {"name": "buffer", "type": "byte[]"}, {"name": "len", "type": "int"}], "return_type": "WriteResult", "signature": "@Override\n    public WriteResult tcpWritePacket(PseudoTCPBase tcp, byte[] buffer, int len)", "original_string": "    @Override\n    public WriteResult tcpWritePacket(PseudoTCPBase tcp, byte[] buffer, int len)\n    {\n        // Randomly drop the desired percentage of packets.\n        // Also drop packets that are larger than the configured MTU.\n        if (randomInt() < loss_)\n        {\n            if (logger.isLoggable(Level.FINE))\n            {\n                logger.log(Level.FINE, \"Randomly dropping packet, size=\" + len);\n            }\n        }\n        else\n        {\n            if (len > Math.min(local_mtu_, remote_mtu_))\n            {\n                if (logger.isLoggable(Level.FINE))\n                {\n                    logger.log(Level.FINE,\n                               \"Dropping packet that exceeds path MTU, size=\"\n                        + len);\n                }\n            }\n            else\n            {\n                if (tcp == localTcp)\n                {\n                    timer.schedule(getWriteRemotePacketTask(buffer, len), delay_);\n                }\n                else\n                {\n                    timer.schedule(getWriteLocalPacketTask(buffer, len), delay_);\n                }\n            }\n        }\n        return WriteResult.WR_SUCCESS;\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java", "class_name": "PseudoTcpTestBase", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "WriteResult", "classes": []}, "docstring": "\nHandles passing packets between local and remote peers. Here are taken\ndecisions about packets loss and delay.\n\n@param tcp\n@param buffer\n@param len\n@return\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase.[void]updateLocalClock()", "name": "updateLocalClock", "arg_nums": 0, "params": [], "return_type": "void", "signature": "protected void updateLocalClock()", "original_string": "    protected void updateLocalClock()\n    {\n        if (localClockThread != null)\n        {\n            synchronized (localClockLock)\n            {\n                localClockLock.notifyAll();\n            }\n        }\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java", "class_name": "PseudoTcpTestBase", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nWakes up local clock thread from wait method causing forced time update\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase.[void]updateRemoteClock()", "name": "updateRemoteClock", "arg_nums": 0, "params": [], "return_type": "void", "signature": "protected void updateRemoteClock()", "original_string": "    protected void updateRemoteClock()\n    {\n        if (remoteClockThread != null)\n        {\n            synchronized (remoteClockLock)\n            {\n                remoteClockLock.notifyAll();\n            }\n        }\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java", "class_name": "PseudoTcpTestBase", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nWakes up remote clock thread from wait method causing forced time update\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase.[void]updateNextClock(PseudoTCPBase,Object)", "name": "updateNextClock", "arg_nums": 2, "params": [{"name": "tcp", "type": "PseudoTCPBase"}, {"name": "lock", "type": "Object"}], "return_type": "void", "signature": "private void updateNextClock(final PseudoTCPBase tcp, final Object lock)", "original_string": "    private void updateNextClock(final PseudoTCPBase tcp, final Object lock)\n    {\n        try\n        {\n\n            long now = PseudoTCPBase.now();\n            //System.out.println(tcp.debugName + \" NOTIFY CLOCK: \" + now);\n            synchronized (tcp)\n            {\n                tcp.notifyClock(now);\n            }\n            //UpdateClock(tcp);\n            long interval;  // NOLINT\n            synchronized (tcp)\n            {\n                interval = tcp.getNextClock(PseudoTCPBase.now());\n            }\n            //interval = Math.max(interval, 0L);  // sometimes interval is < 0 \n            if (logger.isLoggable(Level.FINEST))\n            {\n                logger.log(Level.FINEST,\n                           tcp.debugName + \" CLOCK sleep for \" + interval);\n            }\n            if (interval < 0)\n            {\n                if (interval == -1)\n                {\n                    interval = 1000;\n                }\n                else\n                {\n                    return;\n                }\n            }\n            synchronized (lock)\n            {\n                lock.wait(interval);\n            }\n        }\n        catch (InterruptedException ex)\n        {\n            //Logger.getLogger(PseudoTcpTestBase.class.getName()).log(Level.SEVERE, null, ex);\n        }\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java", "class_name": "PseudoTcpTestBase", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nMethod handles time update for pseudoTCP logic class\n\n@param tcp\n@param lock\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase.[void]startClocks()", "name": "startClocks", "arg_nums": 0, "params": [], "return_type": "void", "signature": "protected void startClocks()", "original_string": "    protected void startClocks()\n    {\n        if (localClockThread == null && remoteClockThread == null)\n        {\n            runClocks = true;\n            localClockThread = new Thread(new Runnable()\n            {\n                @Override\n                public void run()\n                {\n                    while (runClocks)\n                    {\n                        //localTcp.NotifyClock(PseudoTCPBase.Now());\n                        updateNextClock(localTcp, localClockLock);\n\n                    }\n\n                }\n            }, \"LocalClockThread\");\n            remoteClockThread = new Thread(new Runnable()\n            {\n                @Override\n                public void run()\n                {\n                    while (runClocks)\n                    {\n                        //remoteTcp.NotifyClock(PseudoTCPBase.Now());\n                        updateNextClock(remoteTcp, remoteClockLock);\n                    }\n\n                }\n            }, \"RemoteClockThread\");\n            localClockThread.start();\n            remoteClockThread.start();\n        }\n        else\n        {\n            throw new IllegalStateException();\n        }\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java", "class_name": "PseudoTcpTestBase", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nStart clock threads\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase.[void]stopClocks()", "name": "stopClocks", "arg_nums": 0, "params": [], "return_type": "void", "signature": "protected void stopClocks()", "original_string": "    protected void stopClocks()\n    {\n        if (localClockThread != null && remoteClockThread != null)\n        {\n            try\n            {\n                runClocks = false;\n                localClockThread.interrupt();\n                remoteClockThread.interrupt();\n                localClockThread.join(5000);\n                localClockThread = null;\n                remoteClockThread.join(5000);\n                remoteClockThread = null;\n            }\n            catch (InterruptedException ex)\n            {\n                ex.printStackTrace();\n            }\n        }\n        else\n        {\n            throw new IllegalStateException();\n        }\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java", "class_name": "PseudoTcpTestBase", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nStops clock threads\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase.[boolean]assert_Connected_wait(int)", "name": "assert_Connected_wait", "arg_nums": 1, "params": [{"name": "kConnectTimeoutMs", "type": "int"}], "return_type": "boolean", "signature": "protected boolean assert_Connected_wait(int kConnectTimeoutMs)", "original_string": "    protected boolean assert_Connected_wait(int kConnectTimeoutMs)\n    {\n        return assert_wait_until(\n            () -> PseudoTcpTestBase.this.have_connected_,\n            kConnectTimeoutMs);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java", "class_name": "PseudoTcpTestBase", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nThis method waits <tt>kConnectTimeoutMs</tt> miliseconds or until the\nconnection has been established between local and remote peers\n\n@param kConnectTimeoutMs\n@return <tt>isDone</tt> result\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase.[boolean]assert_Disconnected_wait(long)", "name": "assert_Disconnected_wait", "arg_nums": 1, "params": [{"name": "kTransferTimeoutMs", "type": "long"}], "return_type": "boolean", "signature": "protected boolean assert_Disconnected_wait(long kTransferTimeoutMs)", "original_string": "    protected boolean assert_Disconnected_wait(long kTransferTimeoutMs)\n    {\n        return assert_wait_until(\n            () -> PseudoTcpTestBase.this.have_disconnected_,\n            kTransferTimeoutMs);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java", "class_name": "PseudoTcpTestBase", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nThis method waits <tt>kTransferTimeoutMs</tt> miliseconds or until the\nconnection has been closed, which means that the data was transferred\n\n@param kTransferTimeoutMs\n@return <tt>isDone</tt> result\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase.[PseudoTCPBase]getRemoteTcp()", "name": "getRemoteTcp", "arg_nums": 0, "params": [], "return_type": "PseudoTCPBase", "signature": "PseudoTCPBase getRemoteTcp()", "original_string": "    PseudoTCPBase getRemoteTcp()\n    {\n        return remoteTcp;\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java", "class_name": "PseudoTcpTestBase", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "PseudoTCPBase", "classes": []}, "docstring": "\n@return the remoteTcp\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase.[PseudoTCPBase]getLocalTcp()", "name": "getLocalTcp", "arg_nums": 0, "params": [], "return_type": "PseudoTCPBase", "signature": "PseudoTCPBase getLocalTcp()", "original_string": "    PseudoTCPBase getLocalTcp()\n    {\n        return localTcp;\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java", "class_name": "PseudoTcpTestBase", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "PseudoTCPBase", "classes": []}, "docstring": "\n@return the localTcp\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase.[long]maxTransferTime(long,long)", "name": "maxTransferTime", "arg_nums": 2, "params": [{"name": "size", "type": "long"}, {"name": "kBps", "type": "long"}], "return_type": "long", "signature": "public long maxTransferTime(long size, long kBps)", "original_string": "    public long maxTransferTime(long size, long kBps)\n    {\n        long transferTout = ((size) / kBps) * 8 * 1000;\n        return transferTout > 3000 ? transferTout : 3000;\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java", "class_name": "PseudoTcpTestBase", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "long", "classes": []}, "docstring": "\nCalculates maximum transfer time of <tt>size</tt> bytes for specified\ntransfer rate\n\n@param size\n@param kBps\n@return timeout for transfer in ms(minimum 3000 ms)\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpStreamTest.java.PseudoTcpStreamTest.[byte[]]receiveBuffer(InputStream,int)", "name": "receiveBuffer", "arg_nums": 2, "params": [{"name": "input", "type": "InputStream"}, {"name": "size", "type": "int"}], "return_type": "byte[]", "signature": "private static byte[] receiveBuffer(InputStream input, int size)", "original_string": "    private static byte[] receiveBuffer(InputStream input, int size)\n        throws IOException\n    {\n        int rcvd = 0;\n        byte[] buffer = new byte[size];\n        rcvd += input.read(buffer);\n        while (rcvd != size)\n        {\n            rcvd += input.read(buffer, rcvd, size - rcvd);\n            if (logger.isLoggable(Level.FINER))\n            {\n                logger.log(Level.FINER, \"Received: \" + rcvd);\n            }\n        }\n        \n        return buffer;\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpStreamTest.java", "class_name": "PseudoTcpStreamTest", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpStreamTest.java.PseudoTcpStreamTest", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "byte[]", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpStreamTest.java.PseudoTcpStreamTest.[void]doTestTimeout(TimeoutOperationTest)", "name": "doTestTimeout", "arg_nums": 1, "params": [{"name": "testOperation", "type": "TimeoutOperationTest"}], "return_type": "void", "signature": "private void doTestTimeout(final TimeoutOperationTest testOperation)", "original_string": "    private void doTestTimeout(final TimeoutOperationTest testOperation)\n        throws Exception\n    {\n        Thread.setDefaultUncaughtExceptionHandler(this);\n        final PseudoTcpSocketImpl server;\n        final PseudoTcpSocketImpl client;\n        DatagramSocket serverSocket = new DatagramSocket(0, InetAddress.getLoopbackAddress());\n        server = new PseudoTcpSocketImpl(0, serverSocket);\n        client = new PseudoTcpSocketImpl(0);\n        //Servers thread waiting for connection\n        new Thread(() ->\n        {\n            try\n            {\n                server.accept(2000);\n            }\n            catch (IOException e)\n            {\n                throw new RuntimeException(e);\n            }\n            try\n            {\n                testOperation.testTimeout(server);\n                fail(\"No expected timeout occurred on operation\");\n            }\n            catch (IOException e)\n            {\n                //success\n                try\n                {\n                    server.close();\n                }\n                catch (IOException exc)\n                {\n                    throw new RuntimeException(exc);\n                }\n            }\n        }).start();\n        //Clients thread connects and closes socket\n        new Thread(() ->\n        {\n            try\n            {\n                client.connect(new InetSocketAddress(\n                    InetAddress.getLoopbackAddress(),\n                        serverSocket.getLocalPort()),\n                    2000);\n                Thread.sleep(500);\n                client.close();\n            }\n            catch (Exception e)\n            {\n                throw new RuntimeException(e);\n            }\n        }).start();\n        //Waits for server to close socket\n        boolean done = assert_wait_until(()\n            -> server.getState() == PseudoTcpState.TCP_CLOSED, 3000);\n        if(!done)\n        {\n            fail(\"Test timed out\");\n        }\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpStreamTest.java", "class_name": "PseudoTcpStreamTest", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpStreamTest.java.PseudoTcpStreamTest", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestRecvWindow.java.PseudoTcpTestRecvWindow.[void]doTestTransfer(int)", "name": "doTestTransfer", "arg_nums": 1, "params": [{"name": "size", "type": "int"}], "return_type": "void", "signature": "private void doTestTransfer(int size)", "original_string": "    private void doTestTransfer(int size)\n    {\n        Thread.setDefaultUncaughtExceptionHandler(this);\n        testDataSize = size;\n        long start, elapsed;\n        send_position = new ArrayList<>();\n        recv_position = new ArrayList<>();\n        // Create some dummy data\n        byte[] dummy = createDummyData(size);\n        send_stream = new ByteFifoBuffer(size);\n        send_stream.write(dummy, size);\n        //Prepare the receive stream\n        recv_stream = new ByteFifoBuffer(size);\n        //Connect and wait until connected\n        start = PseudoTCPBase.now();\n        startClocks();\n        try\n        {\n            connect();\n        }\n        catch (IOException ex)\n        {\n            fail(ex.getMessage());\n        }\n        //assert Connect() == 0;\n        //TODO: check assert result and fail\n        // Connect and wait until connected.\n        assert_Connected_wait(kConnectTimeoutMs);\n\n        scheduleWriteAction(0);\n\n        long transferTout = maxTransferTime(dummy.length, kMinTransferRate);\n        boolean transferInTime = assert_Disconnected_wait(transferTout);\n        elapsed = PseudoTCPBase.now() - start;\n        stopClocks();\n        int received = recv_stream.getBuffered();\n        assertTrue(transferInTime, \"Transfer timeout, transferred: \" + received\n            + \" required: \" + dummy.length\n            + \" elapsed: \"\n            + elapsed + \" limit: \" + transferTout);\n\n        assert 2 == send_position.size();\n        assert 2 == recv_position.size();\n\n        int estimated_recv_window = estimateReceiveWindowSize();\n\n        // The difference in consecutive send positions should equal the\n        // receive window size or match very closely. This verifies that receive\n        // window is open after receiver drained all the data.\n        int send_position_diff = send_position.get(1) - send_position.get(0);\n        assertTrue(estimated_recv_window - send_position_diff <= 1024);\n\n        // Receiver drained the receive window twice.(+-2 because of window scaling)        \n        assert ((recv_position.get(1) - 2 * estimated_recv_window)\n            <= getShadowedBytes(getRemoteScaleFactor()));\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestRecvWindow.java", "class_name": "PseudoTcpTestRecvWindow", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestRecvWindow.java.PseudoTcpTestRecvWindow", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestRecvWindow.java.PseudoTcpTestRecvWindow.[int]getShadowedBytes(int)", "name": "getShadowedBytes", "arg_nums": 1, "params": [{"name": "scaleFactor", "type": "int"}], "return_type": "int", "signature": "static int getShadowedBytes(int scaleFactor)", "original_string": "    static int getShadowedBytes(int scaleFactor)\n    {\n        return (int) (Math.pow(2, scaleFactor) - 1);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestRecvWindow.java", "class_name": "PseudoTcpTestRecvWindow", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestRecvWindow.java.PseudoTcpTestRecvWindow", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\nThis function calculates amount of bytes witch may introduce error to\nestimation of receive window size caused by scale factor. This is because\ndata is being sent until all sent data is available in remote side's\nbuffer. But because of scale factor window size 0 is reached earlier than\nexpected and some data may still wait for window to open in the send\nqueue.\n\nFor example: m_rcv_scale == 1 and m_rcv_wnd < 2 then rcv_wnd == 0 (1 byte\nmay block) m_rcv_scale == 2 and m_rcv_wnd < 4 then rcv_wnd == 0 (3 bytes\nmay block) m_rcv_scale == 3 and m_rcv_wnd < 8 then rcv_wnd == 0 (7 bytes\nmay block) and so on...\n\nIn normal operation something would read data on remote side causing\nwindow to expand.\n\n\n\n\n\n\n@return count bytes shadowed by scale actor\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestRecvWindow.java.PseudoTcpTestRecvWindow.[void]readUntilIOPending()", "name": "readUntilIOPending", "arg_nums": 0, "params": [], "return_type": "void", "signature": "void readUntilIOPending()", "original_string": "    void readUntilIOPending() throws IOException\n    {\n        byte[] block = new byte[getRemoteTcp().getRecvBufferSize() * 2];\n        int position = recv_stream.getBuffered();\n        int rcvd, total = 0;\n        do\n        {\n            rcvd = remoteRecv(block, block.length);\n            if (rcvd > 0)\n            {\n                recv_stream.write(block, rcvd);\n                total += rcvd;\n                position += rcvd;\n            }\n        }\n        while (rcvd > 0 && total != 0);\n        recv_position.add(position);\n\n        // Disconnect if we have done two transfers.\n        if (recv_position.size() == 2)\n        {\n            close();\n            onTcpClosed(getRemoteTcp(), null);\n        }\n        else\n        {\n            writeData();\n        }\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestRecvWindow.java", "class_name": "PseudoTcpTestRecvWindow", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestRecvWindow.java.PseudoTcpTestRecvWindow", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nReads all data available at the buffer\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestRecvWindow.java.PseudoTcpTestRecvWindow.[void]scheduleWriteAction(long)", "name": "scheduleWriteAction", "arg_nums": 1, "params": [{"name": "delay", "type": "long"}], "return_type": "void", "signature": "void scheduleWriteAction(long delay)", "original_string": "    void scheduleWriteAction(long delay)\n    {\n        writeTimer.schedule(new TimerTask()\n        {\n            @Override\n            public void run()\n            {\n                try\n                {\n                    writeData();\n                }\n                catch (IOException ex)\n                {\n                    //it will get cought by \n                    //deafult exception handler in PseudoTcpTestBase\n                    throw new RuntimeException(ex);\n                }\n            }\n        }, delay);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestRecvWindow.java", "class_name": "PseudoTcpTestRecvWindow", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestRecvWindow.java.PseudoTcpTestRecvWindow", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSchedules write operation with <tt>delay</tt> given in ms\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestRecvWindow.java.PseudoTcpTestRecvWindow.[void]writeData()", "name": "writeData", "arg_nums": 0, "params": [], "return_type": "void", "signature": "void writeData()", "original_string": "    void writeData() throws IOException\n    {\n        //writeOpCount++;\n        int tosend;\n        int sent;\n        int totalSent = 0;\n        byte[] block = new byte[getRemoteTcp().getRecvBufferSize() * 2];\n        int position = testDataSize - send_stream.getBuffered();\n        synchronized (getLocalTcp())\n        {\n            do\n            {\n                tosend = send_stream.readOffset(block, 0, block.length, 0);\n                if (tosend > 0)\n                {\n                    sent = localSend(block, tosend);\n                    updateLocalClock();\n                    if (sent > 0)\n                    {\n                        totalSent += sent;\n                        send_stream.consumeReadData(sent);\n                        position += sent;\n                    }\n                    else\n                    {\n                        logger.log(Level.FINE, \"Flow Controlled\");\n                    }\n                }\n                else\n                {\n                    sent = tosend = 0;\n                }\n            }\n            while (sent > 0);\n            //position = send_stream.GetBuffered();\n\n        }\n        // Measured with precision according to window scale option used\n        if (totalSent - getRemoteTcp().getAvailable()\n            > getShadowedBytes(getRemoteScaleFactor()))\n        {\n            //send buffer was fully filled\n            //waits until it will be received by remote peer\n            while (totalSent - getRemoteTcp().getAvailable()\n                > getShadowedBytes(getRemoteScaleFactor())\n                && !getRemoteTcp().isReceiveBufferFull())\n            {\n                try\n                {\n                    Thread.sleep(50);\n                    if (logger.isLoggable(Level.FINER))\n                    {\n                        logger.log(Level.FINER,\n                                   \"Waiting... sent: \" + totalSent + \" avail: \"\n                            + getRemoteTcp().getAvailable() + \" buffered not sent: \"\n                            + getLocalTcp().getBytesBufferedNotSent()\n                            + \" isFull? \" + getRemoteTcp().isReceiveBufferFull());\n                    }\n                }\n                catch (InterruptedException ex)\n                {\n                    throw new RuntimeException(ex);\n                }\n            }\n        }\n        send_position.add(position);\n        writeTimer.schedule(new TimerTask()\n        {\n            @Override\n            public void run()\n            {\n                try\n                {\n                    readUntilIOPending();\n                }\n                catch (IOException ex)\n                {\n                    throw new RuntimeException(ex);\n                }\n            }\n        }, 10);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestRecvWindow.java", "class_name": "PseudoTcpTestRecvWindow", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestRecvWindow.java.PseudoTcpTestRecvWindow", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nWrites the data\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestRecvWindow.java.PseudoTcpTestRecvWindow.[int]estimateReceiveWindowSize()", "name": "estimateReceiveWindowSize", "arg_nums": 0, "params": [], "return_type": "int", "signature": "int estimateReceiveWindowSize()", "original_string": "    int estimateReceiveWindowSize()\n    {\n        return recv_position.get(0);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestRecvWindow.java", "class_name": "PseudoTcpTestRecvWindow", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestRecvWindow.java.PseudoTcpTestRecvWindow", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "int", "classes": []}, "docstring": "\n\n@return estimated receive window size\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestRecvWindow.java.PseudoTcpTestRecvWindow.[int]estimateSendWindowSize()", "name": "estimateSendWindowSize", "arg_nums": 0, "params": [], "return_type": "int", "signature": "int estimateSendWindowSize()", "original_string": "    int estimateSendWindowSize()\n    {\n        return send_position.get(0);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestRecvWindow.java", "class_name": "PseudoTcpTestRecvWindow", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestRecvWindow.java.PseudoTcpTestRecvWindow", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "int", "classes": []}, "docstring": "\n\n@return estimated send window size\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestRecvWindow.java.PseudoTcpTestRecvWindow.[void]onTcpReadable(PseudoTCPBase)", "name": "onTcpReadable", "arg_nums": 1, "params": [{"name": "tcp", "type": "PseudoTCPBase"}], "return_type": "void", "signature": "@Override\n    public void onTcpReadable(PseudoTCPBase tcp)", "original_string": "    @Override\n    public void onTcpReadable(PseudoTCPBase tcp)\n    {\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestRecvWindow.java", "class_name": "PseudoTcpTestRecvWindow", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestRecvWindow.java.PseudoTcpTestRecvWindow", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestRecvWindow.java.PseudoTcpTestRecvWindow.[void]onTcpWriteable(PseudoTCPBase)", "name": "onTcpWriteable", "arg_nums": 1, "params": [{"name": "tcp", "type": "PseudoTCPBase"}], "return_type": "void", "signature": "@Override\n    public void onTcpWriteable(PseudoTCPBase tcp)", "original_string": "    @Override\n    public void onTcpWriteable(PseudoTCPBase tcp)\n    {\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestRecvWindow.java", "class_name": "PseudoTcpTestRecvWindow", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestRecvWindow.java.PseudoTcpTestRecvWindow", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestRecvWindow.java.PseudoTcpTestRecvWindow.[void]setLocalOptSndBuf(int)", "name": "setLocalOptSndBuf", "arg_nums": 1, "params": [{"name": "len", "type": "int"}], "return_type": "void", "signature": "void setLocalOptSndBuf(int len)", "original_string": "    void setLocalOptSndBuf(int len)\n    {\n        getLocalTcp().setOption(Option.OPT_SNDBUF, len);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestRecvWindow.java", "class_name": "PseudoTcpTestRecvWindow", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestRecvWindow.java.PseudoTcpTestRecvWindow", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestRecvWindow.java.PseudoTcpTestRecvWindow.[int]getRemoteScaleFactor()", "name": "getRemoteScaleFactor", "arg_nums": 0, "params": [], "return_type": "int", "signature": "int getRemoteScaleFactor()", "original_string": "    int getRemoteScaleFactor()\n    {\n        return getRemoteTcp().getM_rwnd_scale();\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestRecvWindow.java", "class_name": "PseudoTcpTestRecvWindow", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestRecvWindow.java.PseudoTcpTestRecvWindow", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "int", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestTransfer.java.PseudoTcpTestTransfer.[void]doTestTransfer(int)", "name": "doTestTransfer", "arg_nums": 1, "params": [{"name": "size", "type": "int"}], "return_type": "void", "signature": "private void doTestTransfer(int size)", "original_string": "    private void doTestTransfer(int size)\n    {\n        Thread.setDefaultUncaughtExceptionHandler(this);\n        long start, elapsed;\n        int received;\n        // Create some dummy data to send\n        sendData = createDummyData(size);\n        sendStreamSize = size;\n\n        // Prepare the receive stream.\n        recvStream = new ByteArrayOutputStream(size);\n        // Connect and wait until connected.\n        start = PseudoTCPBase.now();\n        startClocks();\n        try\n        {\n            connect();\n        }\n        catch (IOException ex)\n        {\n            fail(ex.getMessage());\n        }\n\n        assert_Connected_wait(kConnectTimeoutMs);\n        // Sending will start from OnTcpWriteable and complete when all data has\n        // been received.\n        long transferTout = maxTransferTime(sendData.length, kMinTransferRate);\n        boolean transferInTime = assert_Disconnected_wait(transferTout);\n        elapsed = PseudoTCPBase.now() - start;\n        stopClocks();\n        received = recvStream.size();\n        assertTrue(transferInTime,\"Transfer timeout, transferred: \" + received\n            + \" required: \" + sendData.length\n            + \" elapsed: \"\n            + elapsed + \" limit: \" + transferTout);\n\n        // Ensure we closed down OK and we got the right data.\n        assertEquals(size, received);\n        byte[] recvdArray = recvStream.toByteArray();\n        assertArrayEquals(sendData, recvdArray);\n\n        logger.log(Level.INFO,\n                   \"Transferred \" + received + \" bytes in \" + elapsed\n            + \" ms (\" + (size * 8 / elapsed) + \" Kbps\");\n\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestTransfer.java", "class_name": "PseudoTcpTestTransfer", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestTransfer.java.PseudoTcpTestTransfer", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTransfers the data of <tt>size</tt> bytes\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestTransfer.java.PseudoTcpTestTransfer.[void]readData()", "name": "readData", "arg_nums": 0, "params": [], "return_type": "void", "signature": "void readData()", "original_string": "    void readData() throws IOException\n    {\n        byte[] block = new byte[kBlockSize];\n        int rcvd;\n        do\n        {\n            rcvd = remoteRecv(block, block.length);\n            updateRemoteClock();\n            if (rcvd != -1)\n            {\n                recvStream.write(block, 0, rcvd);\n            }\n        }\n        while (rcvd > 0);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestTransfer.java", "class_name": "PseudoTcpTestTransfer", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestTransfer.java.PseudoTcpTestTransfer", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nReads all data available at remote peer's buffer\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestTransfer.java.PseudoTcpTestTransfer.[boolean]writeData()", "name": "writeData", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "boolean writeData()", "original_string": "    boolean writeData() throws IOException\n    {\n        int tosend;\n        int sent;\n        byte[] block = new byte[kBlockSize];\n        do\n        {\n            tosend = Math.min(sendStreamSize - totalSent, block.length);\n            System.arraycopy(sendData, totalSent, block, 0, tosend);\n            if (tosend > 0)\n            {\n                sent = localSend(block, tosend);\n                updateLocalClock();\n                if (sent != -1)\n                {\n                    totalSent += sent;\n                }\n                else\n                {\n                    logger.log(Level.FINE, \"Flow Controlled\");\n                }\n            }\n            else\n            {\n                sent = tosend = 0;\n            }\n        }\n        while (sent > 0);\n\n        if (logger.isLoggable(Level.FINER))\n        {\n            logger.log(Level.FINER, \"Sent: \" + totalSent\n                + \" remaining: \" + (sendStreamSize - totalSent));\n        }\n\n        return tosend == 0;\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestTransfer.java", "class_name": "PseudoTcpTestTransfer", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestTransfer.java.PseudoTcpTestTransfer", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nWrites the data until there's space available\n\n@return true if there's no more data left to write\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestTransfer.java.PseudoTcpTestTransfer.[void]onTcpReadable(PseudoTCPBase)", "name": "onTcpReadable", "arg_nums": 1, "params": [{"name": "tcp", "type": "PseudoTCPBase"}], "return_type": "void", "signature": "@Override\n    public void onTcpReadable(PseudoTCPBase tcp)", "original_string": "    @Override\n    public void onTcpReadable(PseudoTCPBase tcp)\n    {\n        if (tcp == getRemoteTcp())\n        {\n            try\n            {\n                readData();\n                // TODO: OnTcpClosed() is currently only notified on error -\n                // there is no on-the-wire equivalent of TCP FIN.\n                // So we fake the notification when all the data has been read.\n                int received, required;\n                received = recvStream.size();\n                required = sendStreamSize;\n                if (logger.isLoggable(Level.FINER))\n                {\n                    logger.log(Level.FINER, \"Receivied: \" + received\n                        + \" required: \" + required);\n                }\n                if (received == required)\n                {\n                    onTcpClosed(getRemoteTcp(), null);\n                }\n            }\n            catch (IOException ex)\n            {\n                throw new RuntimeException(ex);\n            }\n        }\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestTransfer.java", "class_name": "PseudoTcpTestTransfer", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestTransfer.java.PseudoTcpTestTransfer", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCatches TCP readable event for remote peer and reads the data. When total\nread count equals send data size the test is finished.\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestTransfer.java.PseudoTcpTestTransfer.[void]onTcpWriteable(PseudoTCPBase)", "name": "onTcpWriteable", "arg_nums": 1, "params": [{"name": "tcp", "type": "PseudoTCPBase"}], "return_type": "void", "signature": "@Override\n    public void onTcpWriteable(PseudoTCPBase tcp)", "original_string": "    @Override\n    public void onTcpWriteable(PseudoTCPBase tcp)\n    {\n        if (tcp == getLocalTcp())\n        {\n            // Write bytes from the send stream when we can.\n            // Shut down when we've sent everything.\n            logger.log(Level.FINER, \"Flow Control Lifted\");\n            try\n            {\n                if (writeData())\n                {\n                    close();\n                }\n            }\n            catch (IOException ex)\n            {\n                ex.printStackTrace();\n                fail(ex.getMessage());\n            }\n        }\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestTransfer.java", "class_name": "PseudoTcpTestTransfer", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestTransfer.java.PseudoTcpTestTransfer", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCatches on TCP writeable event for local peer. Writes all data and closes\nthe stream\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestPingPong.java.PseudoTcpTestPingPong.[void]setBytesPerSend(int)", "name": "setBytesPerSend", "arg_nums": 1, "params": [{"name": "bytes_per_send", "type": "int"}], "return_type": "void", "signature": "public void setBytesPerSend(int bytes_per_send)", "original_string": "    public void setBytesPerSend(int bytes_per_send)\n    {\n        this.bytesPerSend = bytes_per_send;\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestPingPong.java", "class_name": "PseudoTcpTestPingPong", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestPingPong.java.PseudoTcpTestPingPong", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestPingPong.java.PseudoTcpTestPingPong.[void]doTestPingPong(int,int)", "name": "doTestPingPong", "arg_nums": 2, "params": [{"name": "size", "type": "int"}, {"name": "iterations", "type": "int"}], "return_type": "void", "signature": "private void doTestPingPong(int size, int iterations)", "original_string": "    private void doTestPingPong(int size, int iterations)\n    {\n        Thread.setDefaultUncaughtExceptionHandler(this);\n        long start;\n        iterationsRemaining = iterations;\n        receiver = getRemoteTcp();\n        sender = getLocalTcp();\n        // Create some dummy data\n        byte[] dummy = createDummyData(size);\n        send_stream = new ByteFifoBuffer(size);\n        send_stream.write(dummy, size);\n        //Prepare the receive stream\n        recv_stream = new ByteFifoBuffer(size);\n        //Connect and wait until connected\n        start = PseudoTCPBase.now();\n        startClocks();\n        try\n        {\n            connect();\n        }\n        catch (IOException ex)\n        {\n            ex.printStackTrace();\n            fail(ex.getMessage());\n        }\n        //assert Connect() == 0;\n        assert_Connected_wait(kConnectTimeoutMs);\n        // Sending will start from OnTcpWriteable and stop when the required\n        // number of iterations have completed.\n        assert_Disconnected_wait(kMinTransferRate);\n        long elapsed = PseudoTCPBase.now() - start;\n        stopClocks();\n        logger.log(Level.INFO,\n                   \"Performed \" + iterations + \" pings in \" + elapsed + \" ms\");\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestPingPong.java", "class_name": "PseudoTcpTestPingPong", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestPingPong.java.PseudoTcpTestPingPong", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nPerforms ping-pong test for <tt>iterations</tt> with packets of\n<tt>size</tt> bytes\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestPingPong.java.PseudoTcpTestPingPong.[void]onTcpReadable(PseudoTCPBase)", "name": "onTcpReadable", "arg_nums": 1, "params": [{"name": "tcp", "type": "PseudoTCPBase"}], "return_type": "void", "signature": "@Override\n    public void onTcpReadable(PseudoTCPBase tcp)", "original_string": "    @Override\n    public void onTcpReadable(PseudoTCPBase tcp)\n    {\n        assertEquals(receiver, tcp, \"Unexpected onTcpReadable\");\n        try\n        {\n            // Stream bytes to the recv stream as they arrive.\n            readData();\n        }\n        catch (IOException ex)\n        {\n            //will be caught by default handler and test will fail\n            throw new RuntimeException(ex);\n        }\n        // If we've received the desired amount of data, rewind things\n        // and send it back the other way!\n        int recvd = recv_stream.getBuffered();\n        int required = send_stream.length();\n        if (logger.isLoggable(Level.FINER))\n        {\n            logger.log(Level.FINER,\n                       \"test - receivied: \" + recvd + \" required: \" + required);\n        }\n\n        if (recvd == required)\n        {\n            if (receiver == getLocalTcp() && --iterationsRemaining == 0)\n            {\n                close();\n                // TODO: Fake OnTcpClosed() on the receiver for now.\n                onTcpClosed(getRemoteTcp(), null);\n                return;\n            }\n            //switches receivier with sender and performs test the other way\n            PseudoTCPBase tmp = receiver;\n            receiver = sender;\n            sender = tmp;\n            send_stream.resetReadPosition();\n            send_stream.consumeWriteBuffer(send_stream.getWriteRemaining());\n            recv_stream.resetWritePosition();\n            onTcpWriteable(sender);\n        }\n\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestPingPong.java", "class_name": "PseudoTcpTestPingPong", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestPingPong.java.PseudoTcpTestPingPong", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCatches onTcpReadable event for receiver\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestPingPong.java.PseudoTcpTestPingPong.[void]onTcpWriteable(PseudoTCPBase)", "name": "onTcpWriteable", "arg_nums": 1, "params": [{"name": "tcp", "type": "PseudoTCPBase"}], "return_type": "void", "signature": "@Override\n    public void onTcpWriteable(PseudoTCPBase tcp)", "original_string": "    @Override\n    public void onTcpWriteable(PseudoTCPBase tcp)\n    {\n        if (tcp != sender)\n        {\n            return;\n        }\n        // Write bytes from the send stream when we can.\n        // Shut down when we've sent everything.\n        logger.log(Level.FINER, \"Flow Control Lifted\");\n        try\n        {\n            writeData();\n        }\n        catch (IOException ex)\n        {\n            throw new RuntimeException(ex);\n        }\n\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestPingPong.java", "class_name": "PseudoTcpTestPingPong", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestPingPong.java.PseudoTcpTestPingPong", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCatches the ontcpWriteable event for sender\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestPingPong.java.PseudoTcpTestPingPong.[void]readData()", "name": "readData", "arg_nums": 0, "params": [], "return_type": "void", "signature": "private void readData()", "original_string": "    private void readData() throws IOException\n    {\n        byte[] block = new byte[kBlockSize];\n        int rcvd;\n        do\n        {\n            rcvd = receiver.recv(block, block.length);\n            if (rcvd > 0)\n            {\n                recv_stream.write(block, rcvd);\n                if (logger.isLoggable(Level.FINE))\n                {\n                    logger.log(Level.FINE,\n                               \"Receivied: \" + recv_stream.getBuffered());\n                }\n            }\n        }\n        while (rcvd > 0);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestPingPong.java", "class_name": "PseudoTcpTestPingPong", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestPingPong.java.PseudoTcpTestPingPong", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nReads the data in loop until is something available\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestPingPong.java.PseudoTcpTestPingPong.[void]writeData()", "name": "writeData", "arg_nums": 0, "params": [], "return_type": "void", "signature": "private void writeData()", "original_string": "    private void writeData() throws IOException\n    {\n        int tosend;\n        int sent;\n        byte[] block = new byte[kBlockSize];\n        do\n        {\n            tosend = bytesPerSend != 0 ? bytesPerSend : block.length;\n            tosend = send_stream.read(block, tosend);\n            if (tosend > 0)\n            {\n                sent = sender.send(block, tosend);\n                updateLocalClock();\n                if (sent != -1)\n                {\n                    if(logger.isLoggable(Level.FINE))\n                    {\n                        logger.log(Level.FINE, \"Sent: \" + sent);\n                    }\n                }\n                else\n                {\n                    logger.log(Level.FINE, \"Flow controlled\");\n                }\n            }\n            else\n            {\n                sent = tosend = 0;\n            }\n        }\n        while (sent > 0);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestPingPong.java", "class_name": "PseudoTcpTestPingPong", "class_uri": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestPingPong.java.PseudoTcpTestPingPong", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nWrites all data to the receiver\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/util/ByteFifoBufferTest.java.ByteFifoBufferTest.[]ByteFifoBufferTest()", "name": "ByteFifoBufferTest", "arg_nums": 0, "params": [], "return_type": "", "signature": "public ByteFifoBufferTest()", "original_string": "    public ByteFifoBufferTest()\n    {\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/util/ByteFifoBufferTest.java", "class_name": "ByteFifoBufferTest", "class_uri": "src/test/java/org/ice4j/pseudotcp/util/ByteFifoBufferTest.java.ByteFifoBufferTest", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/pseudotcp/util/ByteFifoBufferTest.java.ByteFifoBufferTest.[byte[]]getWData(int)", "name": "getWData", "arg_nums": 1, "params": [{"name": "count", "type": "int"}], "return_type": "byte[]", "signature": "private byte[] getWData(int count)", "original_string": "    private byte[] getWData(int count)\n    {\n        Random r = new Random();\n        byte[] res = new byte[count];\n        r.nextBytes(res);\n        return res;\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/util/ByteFifoBufferTest.java", "class_name": "ByteFifoBufferTest", "class_uri": "src/test/java/org/ice4j/pseudotcp/util/ByteFifoBufferTest.java.ByteFifoBufferTest", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "byte[]", "classes": []}, "docstring": "\nreturn some random array\n\n@param count array size\n"}, {"uris": "src/test/java/org/ice4j/pseudotcp/util/ByteFifoBuffer_consumeWriteBufferTest.java.ByteFifoBuffer_consumeWriteBufferTest.[void]setUp()", "name": "setUp", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@BeforeEach\n    public void setUp()", "original_string": "    @BeforeEach\n    public void setUp() {\n        buffer = new ByteFifoBuffer(1024);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/util/ByteFifoBuffer_consumeWriteBufferTest.java", "class_name": "ByteFifoBuffer_consumeWriteBufferTest", "class_uri": "src/test/java/org/ice4j/pseudotcp/util/ByteFifoBuffer_consumeWriteBufferTest.java.ByteFifoBuffer_consumeWriteBufferTest", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/pseudotcp/util/ByteFifoBuffer_resetWritePositionTest.java.ByteFifoBuffer_resetWritePositionTest.[void]setUp()", "name": "setUp", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@BeforeEach\n    public void setUp()", "original_string": "    @BeforeEach\n    public void setUp() {\n        byteFifoBuffer = new ByteFifoBuffer(1000);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/util/ByteFifoBuffer_resetWritePositionTest.java", "class_name": "ByteFifoBuffer_resetWritePositionTest", "class_uri": "src/test/java/org/ice4j/pseudotcp/util/ByteFifoBuffer_resetWritePositionTest.java.ByteFifoBuffer_resetWritePositionTest", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/pseudotcp/util/ByteFifoBuffer_resetWritePositionTest.java.ByteFifoBuffer_resetWritePositionTest.[byte[]]getWData(int)", "name": "getWData", "arg_nums": 1, "params": [{"name": "length", "type": "int"}], "return_type": "byte[]", "signature": "private byte[] getWData(int length)", "original_string": "    private byte[] getWData(int length) {\n        byte[] data = new byte[length];\n        for (int i = 0; i < length; i++) {\n            data[i] = (byte) (i % 256);\n        }\n        return data;\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/util/ByteFifoBuffer_resetWritePositionTest.java", "class_name": "ByteFifoBuffer_resetWritePositionTest", "class_uri": "src/test/java/org/ice4j/pseudotcp/util/ByteFifoBuffer_resetWritePositionTest.java.ByteFifoBuffer_resetWritePositionTest", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "byte[]", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/pseudotcp/util/ByteFifoBuffer_setCapacityTest.java.ByteFifoBuffer_setCapacityTest.[void]setUp()", "name": "setUp", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@BeforeEach\n    public void setUp()", "original_string": "    @BeforeEach\n    public void setUp() {\n        byteFifoBuffer = new ByteFifoBuffer(1000);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/util/ByteFifoBuffer_setCapacityTest.java", "class_name": "ByteFifoBuffer_setCapacityTest", "class_uri": "src/test/java/org/ice4j/pseudotcp/util/ByteFifoBuffer_setCapacityTest.java.ByteFifoBuffer_setCapacityTest", "attributes": {"modifiers": "@BeforeEach\n    public", "marker_annotations": ["@BeforeEach"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/pseudotcp/util/ByteFifoBuffer_setCapacityTest.java.ByteFifoBuffer_setCapacityTest.[byte[]]getWData(int)", "name": "getWData", "arg_nums": 1, "params": [{"name": "length", "type": "int"}], "return_type": "byte[]", "signature": "private byte[] getWData(int length)", "original_string": "    private byte[] getWData(int length) {\n        byte[] data = new byte[length];\n        for (int i = 0; i < length; i++) {\n            data[i] = (byte) (i % 256);\n        }\n        return data;\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/pseudotcp/util/ByteFifoBuffer_setCapacityTest.java", "class_name": "ByteFifoBuffer_setCapacityTest", "class_uri": "src/test/java/org/ice4j/pseudotcp/util/ByteFifoBuffer_setCapacityTest.java.ByteFifoBuffer_setCapacityTest", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "byte[]", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/ice/RoleConflictResolutionTest.java.RoleConflictResolutionTest.[void]testRecoveryFromRoleConflict(boolean)", "name": "testRecoveryFromRoleConflict", "arg_nums": 1, "params": [{"name": "bothControlling", "type": "boolean"}], "return_type": "void", "signature": "private static void testRecoveryFromRoleConflict(boolean bothControlling)", "original_string": "    private static void testRecoveryFromRoleConflict(boolean bothControlling)\n        throws Throwable\n    {\n        final Agent peer1 = createPeer(\"[peer-1]\", bothControlling);\n        // Set explicit tie-breakers to avoid automatic conflict resolution\n        peer1.setTieBreaker(1);\n\n        final Agent peer2 = createPeer(\"[peer-2]\", bothControlling);\n        peer1.setTieBreaker(2);\n\n        final CountDownLatch countDownLatch = new CountDownLatch(2);\n\n        for (Agent peer : Arrays.asList(peer1, peer2))\n        {\n            peer.addStateChangeListener(evt ->\n            {\n                logger.info(peer.toString() + \": state changed to \"\n                    + evt.toString());\n                if (peer.getState().isEstablished())\n                {\n                    countDownLatch.countDown();\n                }\n            });\n        }\n\n        exchangeCredentials(peer1, peer2);\n        exchangeCandidates(peer1, peer2);\n\n        peer1.startConnectivityEstablishment();\n        peer2.startConnectivityEstablishment();\n\n        boolean isConnected = countDownLatch.await(20, TimeUnit.SECONDS);\n\n        logSelectedPairs(peer1);\n        logSelectedPairs(peer2);\n\n        assertTrue(isConnected,\n            \"Expected connection established within time out\");\n        assertTrue(peer1.getState().isEstablished(),\n            \"peer 1 connectivity\");\n        assertTrue(peer2.getState().isEstablished(),\n            \"peer 2 connectivity\");\n\n        disposePeer(peer1);\n        disposePeer(peer2);\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/ice/RoleConflictResolutionTest.java", "class_name": "RoleConflictResolutionTest", "class_uri": "src/test/java/org/ice4j/ice/RoleConflictResolutionTest.java.RoleConflictResolutionTest", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/ice/RoleConflictResolutionTest.java.RoleConflictResolutionTest.[Agent]createPeer(String,boolean)", "name": "createPeer", "arg_nums": 2, "params": [{"name": "label", "type": "String"}, {"name": "iceControlling", "type": "boolean"}], "return_type": "Agent", "signature": "private static Agent createPeer(String label, boolean iceControlling)", "original_string": "    private static Agent createPeer(String label, boolean iceControlling)\n        throws IOException\n    {\n        final Agent agent = new Agent(label, null);\n        agent.setControlling(iceControlling);\n        IceMediaStream iceStream = agent.createMediaStream(\"media-stream\");\n\n        agent.createComponent(\n            iceStream,\n            0x400, 0x400, 0xFFFF,\n            KeepAliveStrategy.ALL_SUCCEEDED,\n            true);\n\n        return agent;\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/ice/RoleConflictResolutionTest.java", "class_name": "RoleConflictResolutionTest", "class_uri": "src/test/java/org/ice4j/ice/RoleConflictResolutionTest.java.RoleConflictResolutionTest", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "Agent", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/ice/RoleConflictResolutionTest.java.RoleConflictResolutionTest.[void]disposePeer(Agent)", "name": "disposePeer", "arg_nums": 1, "params": [{"name": "peer", "type": "Agent"}], "return_type": "void", "signature": "private static void disposePeer(Agent peer)", "original_string": "    private static void disposePeer(Agent peer)\n    {\n        peer.free();\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/ice/RoleConflictResolutionTest.java", "class_name": "RoleConflictResolutionTest", "class_uri": "src/test/java/org/ice4j/ice/RoleConflictResolutionTest.java.RoleConflictResolutionTest", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/ice/RoleConflictResolutionTest.java.RoleConflictResolutionTest.[void]logSelectedPairs(Agent)", "name": "logSelectedPairs", "arg_nums": 1, "params": [{"name": "peer", "type": "Agent"}], "return_type": "void", "signature": "private static void logSelectedPairs(Agent peer)", "original_string": "    private static void logSelectedPairs(Agent peer)\n    {\n        for (IceMediaStream stream : peer.getStreams())\n        {\n            for (Component component : stream.getComponents())\n            {\n                CandidatePair selectedPair = component.getSelectedPair();\n                if (selectedPair != null)\n                {\n                    logger.info(\n                            peer + \": selected pair for \" + \"component \" + component.getName() + \" :\" + selectedPair);\n                }\n            }\n        }\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/ice/RoleConflictResolutionTest.java", "class_name": "RoleConflictResolutionTest", "class_uri": "src/test/java/org/ice4j/ice/RoleConflictResolutionTest.java.RoleConflictResolutionTest", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/ice/RoleConflictResolutionTest.java.RoleConflictResolutionTest.[void]exchangeCredentials(Agent,Agent)", "name": "exchangeCredentials", "arg_nums": 2, "params": [{"name": "peer1", "type": "Agent"}, {"name": "peer2", "type": "Agent"}], "return_type": "void", "signature": "private static void exchangeCredentials(Agent peer1, Agent peer2)", "original_string": "    private static void exchangeCredentials(Agent peer1, Agent peer2)\n    {\n        for(IceMediaStream stream : peer2.getStreams())\n        {\n            stream.setRemoteUfrag(peer1.getLocalUfrag());\n            stream.setRemotePassword(peer1.getLocalPassword());\n        }\n\n        for(IceMediaStream stream : peer1.getStreams())\n        {\n            stream.setRemoteUfrag(peer2.getLocalUfrag());\n            stream.setRemotePassword(peer2.getLocalPassword());\n        }\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/ice/RoleConflictResolutionTest.java", "class_name": "RoleConflictResolutionTest", "class_uri": "src/test/java/org/ice4j/ice/RoleConflictResolutionTest.java.RoleConflictResolutionTest", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/ice/RoleConflictResolutionTest.java.RoleConflictResolutionTest.[void]exchangeCandidates(Agent,Agent)", "name": "exchangeCandidates", "arg_nums": 2, "params": [{"name": "peer1", "type": "Agent"}, {"name": "peer2", "type": "Agent"}], "return_type": "void", "signature": "private static void exchangeCandidates(Agent peer1, Agent peer2)", "original_string": "    private static void exchangeCandidates(Agent peer1, Agent peer2)\n    {\n        for (String streamName : peer1.getStreamNames())\n        {\n            IceMediaStream peer1Stream = peer1.getStream(streamName);\n            IceMediaStream peer2Stream = peer2.getStream(streamName);\n            if (peer1Stream == null || peer2Stream == null)\n            {\n                continue;\n            }\n\n            for (Integer id : peer1Stream.getComponentIDs())\n            {\n                Component peer1Component = peer1Stream.getComponent(id);\n                Component peer2Component = peer2Stream.getComponent(id);\n                if (peer1Component == null || peer2Component == null)\n                {\n                    continue;\n                }\n\n                copyRemoteCandidates(peer1Component, peer2Component);\n                copyRemoteCandidates(peer2Component, peer1Component);\n            }\n        }\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/ice/RoleConflictResolutionTest.java", "class_name": "RoleConflictResolutionTest", "class_uri": "src/test/java/org/ice4j/ice/RoleConflictResolutionTest.java.RoleConflictResolutionTest", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/org/ice4j/ice/RoleConflictResolutionTest.java.RoleConflictResolutionTest.[void]copyRemoteCandidates(Component,Component)", "name": "copyRemoteCandidates", "arg_nums": 2, "params": [{"name": "localComponent", "type": "Component"}, {"name": "remoteComponent", "type": "Component"}], "return_type": "void", "signature": "private static void copyRemoteCandidates(Component localComponent,\n                                             Component remoteComponent)", "original_string": "    private static void copyRemoteCandidates(Component localComponent,\n                                             Component remoteComponent)\n    {\n        for(LocalCandidate candidate : remoteComponent.getLocalCandidates())\n        {\n            localComponent.addRemoteCandidate(\n                new RemoteCandidate(\n                    candidate.getTransportAddress(),\n                    localComponent,\n                    candidate.getType(),\n                    candidate.getFoundation(),\n                    candidate.getPriority(),\n                    null));\n        }\n    }", "default_arguments": null, "file": "src/test/java/org/ice4j/ice/RoleConflictResolutionTest.java", "class_name": "RoleConflictResolutionTest", "class_uri": "src/test/java/org/ice4j/ice/RoleConflictResolutionTest.java.RoleConflictResolutionTest", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/test/MappingTest.java.MappingTest.[void]main(String[])", "name": "main", "arg_nums": 1, "params": [{"name": "args", "type": "String[]"}], "return_type": "void", "signature": "public static void main(String[] args)", "original_string": "    public static void main(String[] args) throws Throwable\n    {\n        //if configured, append a mapping harvester.\n        String localAddressStr = \"<your local IP here, e.g. 192.168.0.1>\";\n        String publicAddressStr = \"<your public IP here, e.g. 203.0.113.5>\";\n\n        TransportAddress localAddress;\n        TransportAddress publicAddress;\n\n        try\n        {\n            localAddress = new TransportAddress(localAddressStr, 9, Transport.UDP);\n            publicAddress = new TransportAddress(publicAddressStr, 9, Transport.UDP);\n\n            logger.info(\"Will append a NAT harvester for \" + localAddress + \"=>\" + publicAddress);\n\n        }\n        catch(Exception exc)\n        {\n            logger.info(\"Failed to create a NAT harvester for\"\n                        + \" local address=\" + localAddressStr\n                        + \" and public address=\" + publicAddressStr);\n            return;\n        }\n\n        MappingCandidateHarvester natHarvester = new StaticMappingCandidateHarvester(publicAddress, localAddress);\n\n        List<CandidateHarvester> harvesters = new ArrayList<>();\n        harvesters.add(natHarvester);\n\n        Agent localAgent = createAgent(2020, false, harvesters);\n        localAgent.setNominationStrategy(NominationStrategy.NOMINATE_HIGHEST_PRIO);\n\n        String localSDP = SdpUtils.createSDPDescription(localAgent);\n\n        //wait a bit so that the logger can stop dumping stuff:\n        Thread.sleep(500);\n\n        logger.info(\"=================== feed the following to the remote agent ===================\");\n        logger.info(\"\\n\" + localSDP);\n        logger.info(\"==============================================================================\\n\");\n    }", "default_arguments": null, "file": "src/test/java/test/MappingTest.java", "class_name": "MappingTest", "class_uri": "src/test/java/test/MappingTest.java.MappingTest", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nRuns a test application that creates an agent, attaches an AWS harvester\nas well as a few allocates streams, generates an SDP and dumps\nit on stdout\n\n@param args none currently handled\n@throws Throwable every now and then.\n"}, {"uris": "src/test/java/test/SdpUtils.java.SdpUtils.[String]createSDPDescription(Agent)", "name": "createSDPDescription", "arg_nums": 1, "params": [{"name": "agent", "type": "Agent"}], "return_type": "String", "signature": "public static String createSDPDescription(Agent agent)", "original_string": "    public static String createSDPDescription(Agent agent) throws Throwable\n    {\n        SdpFactory factory = new NistSdpFactory();\n        SessionDescription sdess = factory.createSessionDescription();\n\n        IceSdpUtils.initSessionDescription(sdess, agent);\n\n        return sdess.toString();\n    }", "default_arguments": null, "file": "src/test/java/test/SdpUtils.java", "class_name": "SdpUtils", "class_uri": "src/test/java/test/SdpUtils.java.SdpUtils", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nCreates a session description containing the streams from the specified\n<tt>agent</tt> using dummy codecs. This method is unlikely to be of use\nto integrating applications as they would likely just want to feed a\n{@link MediaDescription} and have it populated with all the necessary\nattributes.\n\n@param agent the {@link Agent} we'd like to generate.\n\n@return a {@link SessionDescription} representing <tt>agent</tt>'s\nstreams.\n\n@throws Throwable on rainy days\n"}, {"uris": "src/test/java/test/SdpUtils.java.SdpUtils.[void]parseSDP(Agent,String)", "name": "parseSDP", "arg_nums": 2, "params": [{"name": "localAgent", "type": "Agent"}, {"name": "sdp", "type": "String"}], "return_type": "void", "signature": "@SuppressWarnings(\"unchecked\") // jain-sdp legacy code.\n    public static void parseSDP(Agent localAgent, String sdp)", "original_string": "    @SuppressWarnings(\"unchecked\") // jain-sdp legacy code.\n    public static void parseSDP(Agent localAgent, String sdp)\n        throws Exception\n    {\n        SdpFactory factory = new NistSdpFactory();\n        SessionDescription sdess = factory.createSessionDescription(sdp);\n\n        for(IceMediaStream stream : localAgent.getStreams())\n        {\n            stream.setRemotePassword(sdess.getAttribute(\"ice-pwd\"));\n            stream.setRemoteUfrag(sdess.getAttribute(\"ice-ufrag\"));\n        }\n\n        Connection globalConn = sdess.getConnection();\n        String globalConnAddr = null;\n        if(globalConn != null)\n            globalConnAddr = globalConn.getAddress();\n\n        Vector<MediaDescription> mdescs = sdess.getMediaDescriptions(true);\n\n        for (MediaDescription desc : mdescs)\n        {\n            String streamName = desc.getMedia().getMediaType();\n\n            IceMediaStream stream = localAgent.getStream(streamName);\n\n            if(stream == null)\n                continue;\n\n            Vector<Attribute> attributes = desc.getAttributes(true);\n            for (Attribute attribute : attributes)\n            {\n                if (attribute.getName().equals(CandidateAttribute.NAME))\n                    parseCandidate(attribute, stream);\n            }\n\n            //set default candidates\n            Connection streamConn = desc.getConnection();\n            String streamConnAddr = null;\n            if(streamConn != null)\n                streamConnAddr = streamConn.getAddress();\n            else\n                streamConnAddr = globalConnAddr;\n\n            int port = desc.getMedia().getMediaPort();\n\n            TransportAddress defaultRtpAddress =\n                new TransportAddress(streamConnAddr, port, Transport.UDP);\n\n            int rtcpPort = port + 1;\n            String rtcpAttributeValue = desc.getAttribute(\"rtcp\");\n\n            if (rtcpAttributeValue != null)\n                rtcpPort = Integer.parseInt(rtcpAttributeValue);\n\n            TransportAddress defaultRtcpAddress =\n                new TransportAddress(streamConnAddr, rtcpPort, Transport.UDP);\n\n            Component rtpComponent = stream.getComponent(Component.RTP);\n            Component rtcpComponent = stream.getComponent(Component.RTCP);\n\n            Candidate<?> defaultRtpCandidate\n                = rtpComponent.findRemoteCandidate(defaultRtpAddress);\n            rtpComponent.setDefaultRemoteCandidate(defaultRtpCandidate);\n\n            if(rtcpComponent != null)\n            {\n                Candidate<?> defaultRtcpCandidate\n                    = rtcpComponent.findRemoteCandidate(defaultRtcpAddress);\n                rtcpComponent.setDefaultRemoteCandidate(defaultRtcpCandidate);\n            }\n        }\n    }", "default_arguments": null, "file": "src/test/java/test/SdpUtils.java", "class_name": "SdpUtils", "class_uri": "src/test/java/test/SdpUtils.java.SdpUtils", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\") // jain-sdp legacy code.\n    public static", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public", "static"], "comments": ["// jain-sdp legacy code."], "return_type": "void", "classes": []}, "docstring": "\nConfigures <tt>localAgent</tt> the the remote peer streams, components,\nand candidates specified in <tt>sdp</tt>\n\n@param localAgent the {@link Agent} that we'd like to configure.\n\n@param sdp the SDP string that the remote peer sent.\n\n@throws Exception for all sorts of reasons.\n"}, {"uris": "src/test/java/test/SdpUtils.java.SdpUtils.[RemoteCandidate]parseCandidate(Attribute,IceMediaStream)", "name": "parseCandidate", "arg_nums": 2, "params": [{"name": "attribute", "type": "Attribute"}, {"name": "stream", "type": "IceMediaStream"}], "return_type": "RemoteCandidate", "signature": "private static RemoteCandidate parseCandidate(Attribute      attribute,\n                                                  IceMediaStream stream)", "original_string": "    private static RemoteCandidate parseCandidate(Attribute      attribute,\n                                                  IceMediaStream stream)\n    {\n        String value = null;\n\n        try{\n            value = attribute.getValue();\n        }catch (Throwable t){}//can't happen\n\n        StringTokenizer tokenizer = new StringTokenizer(value);\n\n        //XXX add exception handling.\n        String foundation = tokenizer.nextToken();\n        int componentID = Integer.parseInt( tokenizer.nextToken() );\n        Transport transport = Transport.parse(tokenizer.nextToken());\n        long priority = Long.parseLong(tokenizer.nextToken());\n        String address = tokenizer.nextToken();\n        int port = Integer.parseInt(tokenizer.nextToken());\n\n        TransportAddress transAddr\n            = new TransportAddress(address, port, transport);\n\n        tokenizer.nextToken(); //skip the \"typ\" String\n        CandidateType type = CandidateType.parse(tokenizer.nextToken());\n\n        Component component = stream.getComponent(componentID);\n\n        if(component == null)\n            return null;\n\n        // check if there's a related address property\n\n        RemoteCandidate relatedCandidate = null;\n        if (tokenizer.countTokens() >= 4)\n        {\n            tokenizer.nextToken(); // skip the raddr element\n            String relatedAddr = tokenizer.nextToken();\n            tokenizer.nextToken(); // skip the rport element\n            int relatedPort = Integer.parseInt(tokenizer.nextToken());\n\n            TransportAddress raddr = new TransportAddress(\n                            relatedAddr, relatedPort, Transport.UDP);\n\n            relatedCandidate = component.findRemoteCandidate(raddr);\n        }\n\n        RemoteCandidate cand = new RemoteCandidate(transAddr, component, type,\n                        foundation, priority, relatedCandidate);\n\n        component.addRemoteCandidate(cand);\n\n        return cand;\n    }", "default_arguments": null, "file": "src/test/java/test/SdpUtils.java", "class_name": "SdpUtils", "class_uri": "src/test/java/test/SdpUtils.java.SdpUtils", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "RemoteCandidate", "classes": []}, "docstring": "\nParses the <tt>attribute</tt>.\n\n@param attribute the attribute that we need to parse.\n@param stream the {@link IceMediaStream} that the candidate is supposed\nto belong to.\n\n@return a newly created {@link RemoteCandidate} matching the\ncontent of the specified <tt>attribute</tt> or <tt>null</tt> if the\ncandidate belonged to a component we don't have.\n"}, {"uris": "src/test/java/test/Ice.java.Ice.[void]main(String[])", "name": "main", "arg_nums": 1, "params": [{"name": "args", "type": "String[]"}], "return_type": "void", "signature": "public static void main(String[] args)", "original_string": "    public static void main(String[] args) throws Throwable\n    {\n        startTime = System.currentTimeMillis();\n\n        Agent localAgent = createAgent(9090, false);\n        localAgent.setNominationStrategy(\n                        NominationStrategy.NOMINATE_HIGHEST_PRIO);\n        Agent remotePeer = createAgent(6060, false);\n\n        localAgent.addStateChangeListener(new IceProcessingListener());\n\n        //let them fight ... fights forge character.\n        localAgent.setControlling(true);\n        remotePeer.setControlling(false);\n\n        long endTime = System.currentTimeMillis();\n\n        transferRemoteCandidates(localAgent, remotePeer);\n        for(IceMediaStream stream : localAgent.getStreams())\n        {\n            stream.setRemoteUfrag(remotePeer.getLocalUfrag());\n            stream.setRemotePassword(remotePeer.getLocalPassword());\n        }\n\n        if (START_CONNECTIVITY_ESTABLISHMENT_OF_REMOTE_PEER)\n            transferRemoteCandidates(remotePeer, localAgent);\n\n        for(IceMediaStream stream : remotePeer.getStreams())\n        {\n            stream.setRemoteUfrag(localAgent.getLocalUfrag());\n            stream.setRemotePassword(localAgent.getLocalPassword());\n        }\n\n        logger.info(\"Total candidate gathering time: \"\n                        + (endTime - startTime) + \"ms\");\n        logger.info(\"LocalAgent:\\n\" + localAgent);\n\n        localAgent.startConnectivityEstablishment();\n\n        if (START_CONNECTIVITY_ESTABLISHMENT_OF_REMOTE_PEER)\n            remotePeer.startConnectivityEstablishment();\n\n        logger.info(\"Local audio clist:\\n\"\n                        + localAgent.getStream(\"audio\").getCheckList());\n\n        IceMediaStream videoStream = localAgent.getStream(\"video\");\n\n        if(videoStream != null)\n            logger.info(\"Local video clist:\\n\"\n                            + videoStream.getCheckList());\n\n        //Give processing enough time to finish. We'll System.exit() anyway\n        //as soon as localAgent enters a final state.\n        Thread.sleep(60000);\n    }", "default_arguments": null, "file": "src/test/java/test/Ice.java", "class_name": "Ice", "class_uri": "src/test/java/test/Ice.java.Ice", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nRuns the test\n@param args command line arguments\n\n@throws Throwable if bad stuff happens.\n"}, {"uris": "src/test/java/test/Ice.java.Ice.[void]transferRemoteCandidates(Agent,Agent)", "name": "transferRemoteCandidates", "arg_nums": 2, "params": [{"name": "localAgent", "type": "Agent"}, {"name": "remotePeer", "type": "Agent"}], "return_type": "void", "signature": "static void transferRemoteCandidates(Agent localAgent,\n                                                 Agent remotePeer)", "original_string": "    static void transferRemoteCandidates(Agent localAgent,\n                                                 Agent remotePeer)\n    {\n        List<IceMediaStream> streams = localAgent.getStreams();\n\n        for(IceMediaStream localStream : streams)\n        {\n            String streamName = localStream.getName();\n\n            //get a reference to the local stream\n            IceMediaStream remoteStream = remotePeer.getStream(streamName);\n\n            if(remoteStream != null)\n                transferRemoteCandidates(localStream, remoteStream);\n            else\n                localAgent.removeStream(localStream);\n        }\n    }", "default_arguments": null, "file": "src/test/java/test/Ice.java", "class_name": "Ice", "class_uri": "src/test/java/test/Ice.java.Ice", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nInstalls remote candidates in <tt>localAgent</tt>..\n\n@param localAgent a reference to the agent that we will pretend to be the\nlocal\n@param remotePeer a reference to what we'll pretend to be a remote agent.\n"}, {"uris": "src/test/java/test/Ice.java.Ice.[void]transferRemoteCandidates(IceMediaStream,IceMediaStream)", "name": "transferRemoteCandidates", "arg_nums": 2, "params": [{"name": "localStream", "type": "IceMediaStream"}, {"name": "remoteStream", "type": "IceMediaStream"}], "return_type": "void", "signature": "private static void transferRemoteCandidates(IceMediaStream localStream,\n                                                 IceMediaStream remoteStream)", "original_string": "    private static void transferRemoteCandidates(IceMediaStream localStream,\n                                                 IceMediaStream remoteStream)\n    {\n        List<Component> localComponents = localStream.getComponents();\n\n        for(Component localComponent : localComponents)\n        {\n            int id = localComponent.getComponentID();\n\n            Component remoteComponent = remoteStream.getComponent(id);\n\n            if(remoteComponent != null)\n                transferRemoteCandidates(localComponent, remoteComponent);\n            else\n                localStream.removeComponent(localComponent);\n        }\n    }", "default_arguments": null, "file": "src/test/java/test/Ice.java", "class_name": "Ice", "class_uri": "src/test/java/test/Ice.java.Ice", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nInstalls remote candidates in <tt>localStream</tt>..\n\n@param localStream the stream where we will be adding remote candidates\nto.\n@param remoteStream the stream that we should extract remote candidates\nfrom.\n"}, {"uris": "src/test/java/test/Ice.java.Ice.[void]transferRemoteCandidates(Component,Component)", "name": "transferRemoteCandidates", "arg_nums": 2, "params": [{"name": "localComponent", "type": "Component"}, {"name": "remoteComponent", "type": "Component"}], "return_type": "void", "signature": "private static void transferRemoteCandidates(Component localComponent,\n                                                 Component remoteComponent)", "original_string": "    private static void transferRemoteCandidates(Component localComponent,\n                                                 Component remoteComponent)\n    {\n        List<LocalCandidate> remoteCandidates\n            = remoteComponent.getLocalCandidates();\n\n        localComponent.setDefaultRemoteCandidate(\n                remoteComponent.getDefaultCandidate());\n\n        for(Candidate<?> rCand : remoteCandidates)\n        {\n            localComponent.addRemoteCandidate(\n                    new RemoteCandidate(\n                            rCand.getTransportAddress(),\n                            localComponent,\n                            rCand.getType(),\n                            rCand.getFoundation(),\n                            rCand.getPriority(),\n                            null));\n        }\n    }", "default_arguments": null, "file": "src/test/java/test/Ice.java", "class_name": "Ice", "class_uri": "src/test/java/test/Ice.java.Ice", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nAdds to <tt>localComponent</tt> a list of remote candidates that are\nactually the local candidates from <tt>remoteComponent</tt>.\n\n@param localComponent the <tt>Component</tt> where that we should be\nadding <tt>remoteCandidate</tt>s to.\n@param remoteComponent the source of remote candidates.\n"}, {"uris": "src/test/java/test/Ice.java.Ice.[Agent]createAgent(int)", "name": "createAgent", "arg_nums": 1, "params": [{"name": "rtpPort", "type": "int"}], "return_type": "Agent", "signature": "protected static Agent createAgent(int rtpPort)", "original_string": "    protected static Agent createAgent(int rtpPort)\n        throws Throwable\n    {\n        return createAgent(rtpPort, false);\n    }", "default_arguments": null, "file": "src/test/java/test/Ice.java", "class_name": "Ice", "class_uri": "src/test/java/test/Ice.java.Ice", "attributes": {"modifiers": "protected static", "marker_annotations": [], "non_marker_annotations": ["protected", "static"], "comments": [], "return_type": "Agent", "classes": []}, "docstring": "\nCreates a vanilla ICE <tt>Agent</tt> and adds to it an audio and a video\nstream with RTP and RTCP components.\n\n@param rtpPort the port that we should try to bind the RTP component on\n(the RTCP one would automatically go to rtpPort + 1)\n@return an ICE <tt>Agent</tt> with an audio stream with RTP and RTCP\ncomponents.\n\n@throws Throwable if anything goes wrong.\n"}, {"uris": "src/test/java/test/Ice.java.Ice.[Agent]createAgent(int,boolean)", "name": "createAgent", "arg_nums": 2, "params": [{"name": "rtpPort", "type": "int"}, {"name": "isTrickling", "type": "boolean"}], "return_type": "Agent", "signature": "protected static Agent createAgent(int rtpPort, boolean isTrickling)", "original_string": "    protected static Agent createAgent(int rtpPort, boolean isTrickling)\n        throws Throwable\n    {\n        return createAgent(rtpPort, isTrickling, null);\n    }", "default_arguments": null, "file": "src/test/java/test/Ice.java", "class_name": "Ice", "class_uri": "src/test/java/test/Ice.java.Ice", "attributes": {"modifiers": "protected static", "marker_annotations": [], "non_marker_annotations": ["protected", "static"], "comments": [], "return_type": "Agent", "classes": []}, "docstring": "\nCreates an ICE <tt>Agent</tt> (vanilla or trickle, depending on the\nvalue of <tt>isTrickling</tt>) and adds to it an audio and a video stream\nwith RTP and RTCP components.\n\n@param rtpPort the port that we should try to bind the RTP component on\n(the RTCP one would automatically go to rtpPort + 1)\n@return an ICE <tt>Agent</tt> with an audio stream with RTP and RTCP\ncomponents.\n@param isTrickling indicates whether the newly created agent should be\nperforming trickle ICE.\n\n@throws Throwable if anything goes wrong.\n"}, {"uris": "src/test/java/test/Ice.java.Ice.[Agent]createAgent(int,boolean,List<CandidateHarvester>)", "name": "createAgent", "arg_nums": 3, "params": [{"name": "rtpPort", "type": "int"}, {"name": "isTrickling", "type": "boolean"}, {"name": "harvesters", "type": "List<CandidateHarvester>"}], "return_type": "Agent", "signature": "protected static Agent createAgent(int      rtpPort,\n                                       boolean  isTrickling,\n                                       List<CandidateHarvester>  harvesters)", "original_string": "    protected static Agent createAgent(int      rtpPort,\n                                       boolean  isTrickling,\n                                       List<CandidateHarvester>  harvesters)\n        throws Throwable\n    {\n        long startTime = System.currentTimeMillis();\n        Agent agent = new Agent();\n        agent.setTrickling(isTrickling);\n\n        if(harvesters == null)\n        {\n            // STUN\n            StunCandidateHarvester stunHarv = new StunCandidateHarvester(\n                new TransportAddress(\"meet-jit-si-turnrelay.jitsi.net\", 3478, Transport.UDP));\n\n            agent.addCandidateHarvester(stunHarv);\n\n            //UPnP: adding an UPnP harvester because they are generally slow\n            //which makes it more convenient to test things like trickle.\n            agent.addCandidateHarvester( new UPNPHarvester() );\n        }\n        else\n        {\n            for(CandidateHarvester harvester: harvesters)\n            {\n                agent.addCandidateHarvester(harvester);\n            }\n        }\n\n        //STREAMS\n        createStream(rtpPort, \"audio\", agent);\n        createStream(rtpPort + 2, \"video\", agent);\n\n\n        long endTime = System.currentTimeMillis();\n        long total = endTime - startTime;\n\n        logger.info(\"Total harvesting time: \" + total + \"ms.\");\n\n        return agent;\n    }", "default_arguments": null, "file": "src/test/java/test/Ice.java", "class_name": "Ice", "class_uri": "src/test/java/test/Ice.java.Ice", "attributes": {"modifiers": "protected static", "marker_annotations": [], "non_marker_annotations": ["protected", "static"], "comments": [], "return_type": "Agent", "classes": []}, "docstring": "\nCreates an ICE <tt>Agent</tt> (vanilla or trickle, depending on the\nvalue of <tt>isTrickling</tt>) and adds to it an audio and a video stream\nwith RTP and RTCP components.\n\n@param rtpPort the port that we should try to bind the RTP component on\n(the RTCP one would automatically go to rtpPort + 1)\n@return an ICE <tt>Agent</tt> with an audio stream with RTP and RTCP\ncomponents.\n@param isTrickling indicates whether the newly created agent should be\nperforming trickle ICE.\n@param harvesters the list of {@link CandidateHarvester}s that the new\nagent should use or <tt>null</tt> if it should include the default ones.\n\n@throws Throwable if anything goes wrong.\n"}, {"uris": "src/test/java/test/Ice.java.Ice.[IceMediaStream]createStream(int,String,Agent)", "name": "createStream", "arg_nums": 3, "params": [{"name": "rtpPort", "type": "int"}, {"name": "streamName", "type": "String"}, {"name": "agent", "type": "Agent"}], "return_type": "IceMediaStream", "signature": "private static IceMediaStream createStream(int    rtpPort,\n                                               String streamName,\n                                               Agent  agent)", "original_string": "    private static IceMediaStream createStream(int    rtpPort,\n                                               String streamName,\n                                               Agent  agent)\n        throws Throwable\n    {\n        IceMediaStream stream = agent.createMediaStream(streamName);\n\n        long startTime = System.currentTimeMillis();\n\n        //TODO: component creation should probably be part of the library. it\n        //should also be started after we've defined all components to be\n        //created so that we could run the harvesting for everyone of them\n        //simultaneously with the others.\n\n        //rtp\n        agent.createComponent(stream, rtpPort, rtpPort, rtpPort + 100);\n\n        long endTime = System.currentTimeMillis();\n        logger.info(\"RTP Component created in \" + (endTime - startTime) + \" ms\");\n        startTime = endTime;\n        //rtcpComp\n        agent.createComponent(stream, rtpPort + 1, rtpPort + 1, rtpPort + 101);\n\n        endTime = System.currentTimeMillis();\n        logger.info(\"RTCP Component created in \"\n            + (endTime - startTime) + \" ms\");\n\n        return stream;\n    }", "default_arguments": null, "file": "src/test/java/test/Ice.java", "class_name": "Ice", "class_uri": "src/test/java/test/Ice.java.Ice", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "IceMediaStream", "classes": []}, "docstring": "\nCreates an <tt>IceMediaStream</tt> and adds to it an RTP and and RTCP\ncomponent.\n\n@param rtpPort the port that we should try to bind the RTP component on\n(the RTCP one would automatically go to rtpPort + 1)\n@param streamName the name of the stream to create\n@param agent the <tt>Agent</tt> that should create the stream.\n\n@return the newly created <tt>IceMediaStream</tt>.\n@throws Throwable if anything goes wrong.\n"}, {"uris": "src/test/java/test/AwsTest.java.AwsTest.[void]main(String[])", "name": "main", "arg_nums": 1, "params": [{"name": "args", "type": "String[]"}], "return_type": "void", "signature": "public static void main(String[] args)", "original_string": "    public static void main(String[] args) throws Throwable\n    {\n        if(!AwsCandidateHarvester.smellsLikeAnEC2())\n        {\n            logger.info(\"This does not appear to be an EC2 machine\");\n            return;\n        }\n        else\n        {\n            logger.info(\"Oh nice! Looks like we are on an EC2 machine\");\n\n        }\n        AwsCandidateHarvester mch = new AwsCandidateHarvester();\n\n        List<CandidateHarvester> harvesters = new ArrayList<>();\n        harvesters.add(mch);\n\n        Agent localAgent = createAgent(2020, false, harvesters);\n        localAgent.setNominationStrategy(\n                        NominationStrategy.NOMINATE_HIGHEST_PRIO);\n\n        String localSDP = SdpUtils.createSDPDescription(localAgent);\n\n        //wait a bit so that the logger can stop dumping stuff:\n        Thread.sleep(500);\n\n        logger.info(\"=================== feed the following\"\n                    +\" to the remote agent ===================\");\n\n\n        logger.info(\"\\n\" + localSDP);\n\n        logger.info(\"======================================\"\n            + \"========================================\\n\");\n    }", "default_arguments": null, "file": "src/test/java/test/AwsTest.java", "class_name": "AwsTest", "class_uri": "src/test/java/test/AwsTest.java.AwsTest", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nRuns a test application that creates an agent, attaches an AWS harvester\nas well as a few allocates streams, generates an SDP and dumps\nit on stdout\n\n@param args none currently handled\n@throws Throwable every now and then.\n"}, {"uris": "src/test/java/test/IceLite.java.IceLite.[void]main(String[])", "name": "main", "arg_nums": 1, "params": [{"name": "args", "type": "String[]"}], "return_type": "void", "signature": "public static void main(String[] args)", "original_string": "    public static void main(String[] args) throws Throwable\n    {\n        logger.severe(\"Start\");\n        startTime = System.currentTimeMillis();\n\n        Agent localAgent = createAgent(3030);\n        localAgent.setControlling(false);\n        localAgent.setNominationStrategy(\n                        NominationStrategy.NOMINATE_HIGHEST_PRIO);\n\n        localAgent.addStateChangeListener(new IceProcessingListener());\n\n        String localSDP = SdpUtils.createSDPDescription(localAgent);\n\n        System.out.println(\"=================== feed the following\"\n                        +\" to the remote agent ===================\");\n\n        System.out.println(localSDP);\n\n        System.out.println(\"======================================\"\n                        +\"========================================\\n\");\n\n        //Give processing enough time to finish. We'll System.exit() anyway\n        //as soon as localAgent enters a final state.\n        Thread.sleep(60000);\n    }", "default_arguments": null, "file": "src/test/java/test/IceLite.java", "class_name": "IceLite", "class_uri": "src/test/java/test/IceLite.java.IceLite", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nRuns a test application that allocates streams, generates an SDP, dumps\nit on stdout, waits for a remote peer SDP on stdin, then feeds that\nto our local agent and starts ICE processing.\n\n@param args none currently handled\n@throws Throwable every now and then.\n"}, {"uris": "src/test/java/test/TrickleIce.java.TrickleIce.[void]main(String[])", "name": "main", "arg_nums": 1, "params": [{"name": "args", "type": "String[]"}], "return_type": "void", "signature": "public static void main(String[] args)", "original_string": "    public static void main(String[] args) throws Throwable\n    {\n        Agent localAgent = createAgent(2020, true);\n        localAgent.setNominationStrategy(\n                        NominationStrategy.NOMINATE_HIGHEST_PRIO);\n\n        localAgent.addStateChangeListener(new IceProcessingListener());\n\n        //let them fight ... fights forge character.\n        localAgent.setControlling(false);\n        String localSDP = SdpUtils.createSDPDescription(localAgent);\n\n        //wait a bit so that the logger can stop dumping stuff:\n        Thread.sleep(500);\n\n        logger.info(\"=================== feed the following\"\n                    +\" to the remote agent ===================\");\n\n\n        logger.info(\"\\n\" + localSDP);\n\n        logger.info(\"======================================\"\n            + \"========================================\\n\");\n\n        CandidatePrinter printer = new CandidatePrinter();\n        printer.agent = localAgent;\n\n\n        localAgent.startCandidateTrickle(printer);\n\n\n        List<Component> allComponents = new LinkedList<>();\n        int allCandidates = 0;\n        for (IceMediaStream stream : localAgent.getStreams())\n        {\n            for(Component component : stream.getComponents())\n            {\n                allComponents.add(component);\n                allCandidates += component.getLocalCandidateCount();\n            }\n        }\n        logger.info(\"all candidates = \" + allCandidates);\n\n        /*String sdp = IceDistributed.readSDP();\n\n        startTime = System.currentTimeMillis();\n        SdpUtils.parseSDP(localAgent, sdp);\n\n        localAgent.startConnectivityEstablishment();\n        */\n\n        //Give processing enough time to finish. We'll System.exit() anyway\n        //as soon as localAgent enters a final state.\n        Thread.sleep(60000);\n    }", "default_arguments": null, "file": "src/test/java/test/TrickleIce.java", "class_name": "TrickleIce", "class_uri": "src/test/java/test/TrickleIce.java.TrickleIce", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nRuns a test application that allocates streams, generates an SDP, dumps\nit on stdout, waits for a remote peer SDP on stdin, then feeds that\nto our local agent and starts ICE processing.\n\n@param args none currently handled\n@throws Throwable every now and then.\n"}, {"uris": "src/test/java/test/IcePseudoTcp.java.IcePseudoTcp.[Agent]createAgent(int)", "name": "createAgent", "arg_nums": 1, "params": [{"name": "pTcpPort", "type": "int"}], "return_type": "Agent", "signature": "protected static Agent createAgent(int pTcpPort)", "original_string": "    protected static Agent createAgent(int pTcpPort)\n        throws Throwable\n    {\n        Agent agent = new Agent();\n        // STUN\n        if (USE_STUN)\n        {\n            StunCandidateHarvester stunHarv = new StunCandidateHarvester(\n                new TransportAddress(\"sip-communicator.net\",\n                                     3478, Transport.UDP));\n            StunCandidateHarvester stun6Harv = new StunCandidateHarvester(\n                new TransportAddress(\"ipv6.sip-communicator.net\",\n                                     3478, Transport.UDP));\n\n            agent.addCandidateHarvester(stunHarv);\n            agent.addCandidateHarvester(stun6Harv);\n        }\n        // TURN \n        if (USE_TURN)\n        {\n            String[] hostnames = new String[]\n            {\n                \"130.79.90.150\",\n                \"2001:660:4701:1001:230:5ff:fe1a:805f\"\n            };\n            int port = 3478;\n            LongTermCredential longTermCredential = new LongTermCredential(\n                \"guest\", \"anonymouspower!!\");\n\n            for (String hostname : hostnames)\n            {\n                agent.addCandidateHarvester(new TurnCandidateHarvester(\n                    new TransportAddress(hostname, port, Transport.UDP), longTermCredential));\n            }\n        }\n        //STREAM\n        createStream(pTcpPort, \"data\", agent);\n\n        return agent;\n    }", "default_arguments": null, "file": "src/test/java/test/IcePseudoTcp.java", "class_name": "IcePseudoTcp", "class_uri": "src/test/java/test/IcePseudoTcp.java.IcePseudoTcp", "attributes": {"modifiers": "protected static", "marker_annotations": [], "non_marker_annotations": ["protected", "static"], "comments": [], "return_type": "Agent", "classes": []}, "docstring": ""}, {"uris": "src/test/java/test/IcePseudoTcp.java.IcePseudoTcp.[IceMediaStream]createStream(int,String,Agent)", "name": "createStream", "arg_nums": 3, "params": [{"name": "pTcpPort", "type": "int"}, {"name": "streamName", "type": "String"}, {"name": "agent", "type": "Agent"}], "return_type": "IceMediaStream", "signature": "private static IceMediaStream createStream(int pTcpPort,\n                                               String streamName,\n                                               Agent agent)", "original_string": "    private static IceMediaStream createStream(int pTcpPort,\n                                               String streamName,\n                                               Agent agent)\n        throws Throwable\n    {\n        IceMediaStream stream = agent.createMediaStream(streamName);\n\n        long startTime = System.currentTimeMillis();\n\n        //udp component\n        agent.createComponent(stream, pTcpPort, pTcpPort, pTcpPort + 100);\n\n        long endTime = System.currentTimeMillis();\n        logger.info(\"UDP Component created in \" + (endTime - startTime) + \" ms\");\n\n        return stream;\n    }", "default_arguments": null, "file": "src/test/java/test/IcePseudoTcp.java", "class_name": "IcePseudoTcp", "class_uri": "src/test/java/test/IcePseudoTcp.java.IcePseudoTcp", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "IceMediaStream", "classes": []}, "docstring": ""}, {"uris": "src/test/java/test/IcePseudoTcp.java.IcePseudoTcp.[void]main(String[])", "name": "main", "arg_nums": 1, "params": [{"name": "args", "type": "String[]"}], "return_type": "void", "signature": "public static void main(String[] args)", "original_string": "    public static void main(String[] args) throws Throwable\n    {\n        startTime = System.currentTimeMillis();\n        \n        int localPort = 7999;\n        int remotePort = 6000;\n\n        Agent localAgent = createAgent(localPort);\n        localAgent.setNominationStrategy(NominationStrategy.NOMINATE_HIGHEST_PRIO);\n        Agent remotePeer = createAgent(remotePort);\n\n        localAgent.addStateChangeListener(new IcePseudoTcp.LocalIceProcessingListener());\n        remotePeer.addStateChangeListener(new IcePseudoTcp.RemoteIceProcessingListener());\n\n        //let them fight ... fights forge character.\n        localAgent.setControlling(true);\n        remotePeer.setControlling(false);\n\n        long endTime = System.currentTimeMillis();\n\n        Ice.transferRemoteCandidates(localAgent, remotePeer);\n        for (IceMediaStream stream : localAgent.getStreams())\n        {\n            stream.setRemoteUfrag(remotePeer.getLocalUfrag());\n            stream.setRemotePassword(remotePeer.getLocalPassword());\n        }\n\n        Ice.transferRemoteCandidates(remotePeer, localAgent);\n\n        for (IceMediaStream stream : remotePeer.getStreams())\n        {\n            stream.setRemoteUfrag(localAgent.getLocalUfrag());\n            stream.setRemotePassword(localAgent.getLocalPassword());\n        }\n\n        logger.log(Level.INFO, \"Total candidate gathering time: {0} ms\", (endTime - startTime));\n        logger.log(Level.INFO, \"LocalAgent: {0}\", localAgent);\n\n        localAgent.startConnectivityEstablishment();\n\n        //if (START_CONNECTIVITY_ESTABLISHMENT_OF_REMOTE_PEER)\n        remotePeer.startConnectivityEstablishment();\n\n\n        IceMediaStream dataStream = localAgent.getStream(\"data\");\n\n        if (dataStream != null)\n        {\n            logger.info(\"Local data clist:\" + dataStream.getCheckList());\n        }\n        //wait for one of the agents to complete it's job \n        synchronized (remoteAgentMonitor)\n        {\n            remoteAgentMonitor.wait(agentJobTimeout);\n        }\n        if (remoteJob != null)\n        {\n            logger.finest(\"Remote thread join started\");\n            remoteJob.join();\n            logger.finest(\"Remote thread joined\");\n        }\n        remotePeer.free();\n        if (localJob != null)\n        {\n            logger.finest(\"Local thread join started\");\n            localJob.join();\n            logger.finest(\"Local thread joined\");\n        }\n        localAgent.free();\n        System.exit(0);\n    }", "default_arguments": null, "file": "src/test/java/test/IcePseudoTcp.java", "class_name": "IcePseudoTcp", "class_uri": "src/test/java/test/IcePseudoTcp.java.IcePseudoTcp", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/test/java/test/IceDistributed.java.IceDistributed.[void]main(String[])", "name": "main", "arg_nums": 1, "params": [{"name": "args", "type": "String[]"}], "return_type": "void", "signature": "public static void main(String[] args)", "original_string": "    public static void main(String[] args) throws Throwable\n    {\n        Agent localAgent = createAgent(2020);\n        localAgent.setNominationStrategy(\n                        NominationStrategy.NOMINATE_HIGHEST_PRIO);\n\n        localAgent.addStateChangeListener(new IceProcessingListener());\n\n        //let them fight ... fights forge character.\n        localAgent.setControlling(false);\n        String localSDP = SdpUtils.createSDPDescription(localAgent);\n\n        //wait a bit so that the logger can stop dumping stuff:\n        Thread.sleep(500);\n\n        System.out.println(\"=================== feed the following\"\n                        +\" to the remote agent ===================\");\n\n\n        System.out.println(localSDP);\n\n        System.out.println(\"======================================\"\n                        +\"========================================\\n\");\n\n        String sdp = readSDP();\n\n        startTime = System.currentTimeMillis();\n        SdpUtils.parseSDP(localAgent, sdp);\n\n        localAgent.startConnectivityEstablishment();\n\n        //Give processing enough time to finish. We'll System.exit() anyway\n        //as soon as localAgent enters a final state.\n        Thread.sleep(60000);\n    }", "default_arguments": null, "file": "src/test/java/test/IceDistributed.java", "class_name": "IceDistributed", "class_uri": "src/test/java/test/IceDistributed.java.IceDistributed", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nRuns a test application that allocates streams, generates an SDP, dumps\nit on stdout, waits for a remote peer SDP on stdin, then feeds that\nto our local agent and starts ICE processing.\n\n@param args none currently handled\n@throws Throwable every now and then.\n"}, {"uris": "src/test/java/test/IceDistributed.java.IceDistributed.[String]readSDP()", "name": "readSDP", "arg_nums": 0, "params": [], "return_type": "String", "signature": "static String readSDP()", "original_string": "    static String readSDP() throws Throwable\n    {\n        System.out.println(\"Paste remote SDP here. Enter an empty \"\n                        +\"line to proceed:\");\n        System.out.println(\"(we don't mind the [java] prefix in SDP intput)\");\n        BufferedReader reader\n            = new BufferedReader(new InputStreamReader(System.in));\n\n        StringBuffer buff = new StringBuffer();\n        String line;\n\n        while ( (line = reader.readLine()) != null)\n        {\n            line = line.replace(\"[java]\", \"\");\n            line = line.trim();\n            if(line.length() == 0)\n                break;\n\n            buff.append(line);\n            buff.append(\"\\r\\n\");\n        }\n\n        return buff.toString();\n    }", "default_arguments": null, "file": "src/test/java/test/IceDistributed.java", "class_name": "IceDistributed", "class_uri": "src/test/java/test/IceDistributed.java.IceDistributed", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReads an SDP description from the standard input. We expect descriptions\nprovided to this method to be originating from instances of this\napplication running on remote computers.\n\n@return whatever we got on stdin (hopefully an SDP description.\n\n@throws Throwable if something goes wrong with console reading.\n"}, {"uris": "src/test/java/test/signalling/SignallingCallback.java.SignallingCallback.[void]onSignalling(String)", "name": "onSignalling", "arg_nums": 1, "params": [{"name": "signalling", "type": "String"}], "return_type": "void", "signature": "public void onSignalling(String signalling)", "original_string": "    public void onSignalling(String signalling);", "default_arguments": null, "file": "src/test/java/test/signalling/SignallingCallback.java", "class_name": "SignallingCallback", "class_uri": "src/test/java/test/signalling/SignallingCallback.java.SignallingCallback", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nProcesses the specified signalling string\n\n@param signalling the signalling string to process\n"}, {"uris": "src/test/java/test/signalling/Signalling.java.Signalling.[]Signalling(Socket,SignallingCallback)", "name": "Signalling", "arg_nums": 2, "params": [{"name": "socket", "type": "Socket"}, {"name": "signallingCallback", "type": "SignallingCallback"}], "return_type": "", "signature": "public Signalling(Socket socket, SignallingCallback signallingCallback)", "original_string": "    public Signalling(Socket socket, SignallingCallback signallingCallback)\n    {\n//        this.signallingSocket = socket;\n//        this.signallingCallback = signallingCallback;\n    }", "default_arguments": null, "file": "src/test/java/test/signalling/Signalling.java", "class_name": "Signalling", "class_uri": "src/test/java/test/signalling/Signalling.java.Signalling", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nCreates a signalling instance over the specified socket.\n\n@param socket the socket that this instance should use for signalling\n"}, {"uris": "src/test/java/test/signalling/Signalling.java.Signalling.[Signalling]createServerSignalling(InetSocketAddress,SignallingCallback)", "name": "createServerSignalling", "arg_nums": 2, "params": [{"name": "socketAddress", "type": "InetSocketAddress"}, {"name": "signallingCallback", "type": "SignallingCallback"}], "return_type": "Signalling", "signature": "public static Signalling createServerSignalling(\n            InetSocketAddress socketAddress,\n            SignallingCallback signallingCallback)", "original_string": "    public static Signalling createServerSignalling(\n            InetSocketAddress socketAddress,\n            SignallingCallback signallingCallback)\n        throws Throwable\n    {\n//        ServerSocket serverSocket = new ServerSocket(socketAddress);\n//        Signalling signalling = new Signalling(socketAddress, signallingCallback);\n        return null;\n    }", "default_arguments": null, "file": "src/test/java/test/signalling/Signalling.java", "class_name": "Signalling", "class_uri": "src/test/java/test/signalling/Signalling.java.Signalling", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Signalling", "classes": []}, "docstring": "\nCreates a server signalling object. The method will block until a\nconnection is actually received on\n\n@param socketAddress our bind address\n@param signallingCallback the callback that we will deliver signalling\nto.\n\n@return the newly created Signalling object\n\n@throws Throwable if anything goes wrong (which could happen with the\nsocket stuff).\n"}, {"uris": "src/main/java/org/ice4j/StunException.java.StunException.[]StunException()", "name": "StunException", "arg_nums": 0, "params": [], "return_type": "", "signature": "public StunException()", "original_string": "    public StunException()\n    {\n\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/StunException.java", "class_name": "StunException", "class_uri": "src/main/java/org/ice4j/StunException.java.StunException", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nCreates a StunException.\n"}, {"uris": "src/main/java/org/ice4j/StunException.java.StunException.[]StunException(int)", "name": "StunException", "arg_nums": 1, "params": [{"name": "id", "type": "int"}], "return_type": "", "signature": "public StunException(int id)", "original_string": "    public StunException(int id)\n    {\n        setID(id);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/StunException.java", "class_name": "StunException", "class_uri": "src/main/java/org/ice4j/StunException.java.StunException", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nCreates a StunException setting id as its identifier.\n@param id an error ID\n"}, {"uris": "src/main/java/org/ice4j/StunException.java.StunException.[]StunException(String)", "name": "StunException", "arg_nums": 1, "params": [{"name": "message", "type": "String"}], "return_type": "", "signature": "public StunException(String message)", "original_string": "    public StunException(String message)\n    {\n        super(message);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/StunException.java", "class_name": "StunException", "class_uri": "src/main/java/org/ice4j/StunException.java.StunException", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nCreates a StunException, setting an error message.\n@param message an error message.\n"}, {"uris": "src/main/java/org/ice4j/StunException.java.StunException.[]StunException(int,String)", "name": "StunException", "arg_nums": 2, "params": [{"name": "id", "type": "int"}, {"name": "message", "type": "String"}], "return_type": "", "signature": "public StunException(int id, String message)", "original_string": "    public StunException(int id, String message)\n    {\n        super(message);\n        setID(id);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/StunException.java", "class_name": "StunException", "class_uri": "src/main/java/org/ice4j/StunException.java.StunException", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nCreates a StunException, setting an error message and an error id.\n@param message an error message.\n@param id an error id.\n"}, {"uris": "src/main/java/org/ice4j/StunException.java.StunException.[]StunException(int,String,Throwable)", "name": "StunException", "arg_nums": 3, "params": [{"name": "id", "type": "int"}, {"name": "message", "type": "String"}, {"name": "cause", "type": "Throwable"}], "return_type": "", "signature": "public StunException(int id, String message, Throwable cause)", "original_string": "    public StunException(int id, String message, Throwable cause)\n    {\n        super(message, cause);\n        setID(id);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/StunException.java", "class_name": "StunException", "class_uri": "src/main/java/org/ice4j/StunException.java.StunException", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nCreates a StunException, setting an error message an error id and a\ncause.\n\n@param id an error id.\n@param message an error message.\n@param cause the error that caused this exception.\n"}, {"uris": "src/main/java/org/ice4j/StunException.java.StunException.[]StunException(String,Throwable)", "name": "StunException", "arg_nums": 2, "params": [{"name": "message", "type": "String"}, {"name": "cause", "type": "Throwable"}], "return_type": "", "signature": "public StunException(String message, Throwable cause)", "original_string": "    public StunException(String message, Throwable cause)\n    {\n        super(message, cause);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/StunException.java", "class_name": "StunException", "class_uri": "src/main/java/org/ice4j/StunException.java.StunException", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nCreates a StunException, setting an error message and a cause object.\n@param message an error message.\n@param cause the error object that caused this exception.\n"}, {"uris": "src/main/java/org/ice4j/StunException.java.StunException.[]StunException(Throwable)", "name": "StunException", "arg_nums": 1, "params": [{"name": "cause", "type": "Throwable"}], "return_type": "", "signature": "public StunException(Throwable cause)", "original_string": "    public StunException(Throwable cause)\n    {\n        super(cause);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/StunException.java", "class_name": "StunException", "class_uri": "src/main/java/org/ice4j/StunException.java.StunException", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nCreates an exception, setting the Throwable object, that caused it.\n@param cause the error that caused this exception.\n"}, {"uris": "src/main/java/org/ice4j/StunException.java.StunException.[void]setID(int)", "name": "setID", "arg_nums": 1, "params": [{"name": "id", "type": "int"}], "return_type": "void", "signature": "public void setID(int id)", "original_string": "    public void setID(int id)\n    {\n        this.id = id;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/StunException.java", "class_name": "StunException", "class_uri": "src/main/java/org/ice4j/StunException.java.StunException", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets the identifier of the error that caused the exception.\n@param id the identifier of the error that caused the exception.\n"}, {"uris": "src/main/java/org/ice4j/StunException.java.StunException.[int]getID()", "name": "getID", "arg_nums": 0, "params": [], "return_type": "int", "signature": "public int getID()", "original_string": "    public int getID()\n    {\n        return id;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/StunException.java", "class_name": "StunException", "class_uri": "src/main/java/org/ice4j/StunException.java.StunException", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\nReturns this exception's identifier.\n@return this exception's identifier;\n"}, {"uris": "src/main/java/org/ice4j/StunMessageEvent.java.StunMessageEvent.[]StunMessageEvent(StunStack,RawMessage,Message)", "name": "StunMessageEvent", "arg_nums": 3, "params": [{"name": "stunStack", "type": "StunStack"}, {"name": "rawMessage", "type": "RawMessage"}, {"name": "parsedMessage", "type": "Message"}], "return_type": "", "signature": "public StunMessageEvent(\n            StunStack stunStack,\n            RawMessage rawMessage,\n            Message parsedMessage)", "original_string": "    public StunMessageEvent(\n            StunStack stunStack,\n            RawMessage rawMessage,\n            Message parsedMessage)\n    {\n        super(stunStack, rawMessage.getLocalAddress(), parsedMessage);\n\n        this.rawMessage = rawMessage;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/StunMessageEvent.java", "class_name": "StunMessageEvent", "class_uri": "src/main/java/org/ice4j/StunMessageEvent.java.StunMessageEvent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nConstructs a StunMessageEvent according to the specified message.\n\n@param stunStack the <tt>StunStack</tt> to be associated with the new\ninstance\n@param rawMessage the crude message we got off the wire.\n@param parsedMessage the message itself\n"}, {"uris": "src/main/java/org/ice4j/StunMessageEvent.java.StunMessageEvent.[TransportAddress]getLocalAddress()", "name": "getLocalAddress", "arg_nums": 0, "params": [], "return_type": "TransportAddress", "signature": "public TransportAddress getLocalAddress()", "original_string": "    public TransportAddress getLocalAddress()\n    {\n        return getSourceAddress();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/StunMessageEvent.java", "class_name": "StunMessageEvent", "class_uri": "src/main/java/org/ice4j/StunMessageEvent.java.StunMessageEvent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "TransportAddress", "classes": []}, "docstring": "\nReturns a <tt>TransportAddress</tt> referencing the access point where\nthe message was received.\n\n@return a descriptor of the access point where the message arrived.\n"}, {"uris": "src/main/java/org/ice4j/StunMessageEvent.java.StunMessageEvent.[TransportAddress]getRemoteAddress()", "name": "getRemoteAddress", "arg_nums": 0, "params": [], "return_type": "TransportAddress", "signature": "public TransportAddress getRemoteAddress()", "original_string": "    public TransportAddress getRemoteAddress()\n    {\n        return rawMessage.getRemoteAddress();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/StunMessageEvent.java", "class_name": "StunMessageEvent", "class_uri": "src/main/java/org/ice4j/StunMessageEvent.java.StunMessageEvent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "TransportAddress", "classes": []}, "docstring": "\nReturns the address that sent the message.\n\n@return the address that sent the message.\n"}, {"uris": "src/main/java/org/ice4j/StunMessageEvent.java.StunMessageEvent.[String]toString()", "name": "toString", "arg_nums": 0, "params": [], "return_type": "String", "signature": "@Override\n    public String toString()", "original_string": "    @Override\n    public String toString()\n    {\n        StringBuffer buff = new StringBuffer(\"StunMessageEvent:\\n\\tMessage=\");\n\n        buff.append(getMessage());\n        buff.append(\" remoteAddr=\").append(getRemoteAddress());\n        buff.append(\" localAddr=\").append(getLocalAddress());\n\n        return buff.toString();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/StunMessageEvent.java", "class_name": "StunMessageEvent", "class_uri": "src/main/java/org/ice4j/StunMessageEvent.java.StunMessageEvent", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns a <tt>String</tt> representation of this event, containing the\ncorresponding message, remote and local addresses.\n\n@return a <tt>String</tt> representation of this event, containing the\ncorresponding message, remote and local addresses.\n"}, {"uris": "src/main/java/org/ice4j/StunMessageEvent.java.StunMessageEvent.[RawMessage]getRawMessage()", "name": "getRawMessage", "arg_nums": 0, "params": [], "return_type": "RawMessage", "signature": "public RawMessage getRawMessage()", "original_string": "    public RawMessage getRawMessage()\n    {\n        return rawMessage;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/StunMessageEvent.java", "class_name": "StunMessageEvent", "class_uri": "src/main/java/org/ice4j/StunMessageEvent.java.StunMessageEvent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "RawMessage", "classes": []}, "docstring": "\nReturns the raw message that caused this event.\n\n@return the {@link RawMessage} that caused this event.\n"}, {"uris": "src/main/java/org/ice4j/StunTimeoutEvent.java.StunTimeoutEvent.[]StunTimeoutEvent(StunStack,Message,TransportAddress,TransactionID)", "name": "StunTimeoutEvent", "arg_nums": 4, "params": [{"name": "stunStack", "type": "StunStack"}, {"name": "message", "type": "Message"}, {"name": "localAddress", "type": "TransportAddress"}, {"name": "transactionID", "type": "TransactionID"}], "return_type": "", "signature": "public StunTimeoutEvent(\n            StunStack stunStack,\n            Message message,\n            TransportAddress localAddress,\n            TransactionID transactionID)", "original_string": "    public StunTimeoutEvent(\n            StunStack stunStack,\n            Message message,\n            TransportAddress localAddress,\n            TransactionID transactionID)\n    {\n        super(stunStack, localAddress, message);\n\n        setTransactionID(transactionID);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/StunTimeoutEvent.java", "class_name": "StunTimeoutEvent", "class_uri": "src/main/java/org/ice4j/StunTimeoutEvent.java.StunTimeoutEvent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nConstructs a <tt>StunTimeoutEvent</tt> according to the specified\nmessage.\n\n@param stunStack the <tt>StunStack</tt> to be associated with the new\ninstance\n@param message the message itself\n@param localAddress the local address that the message was sent from.\n@param transactionID the ID of the  associated with this event.\n"}, {"uris": "src/main/java/org/ice4j/StunTimeoutEvent.java.StunTimeoutEvent.[TransportAddress]getLocalAddress()", "name": "getLocalAddress", "arg_nums": 0, "params": [], "return_type": "TransportAddress", "signature": "public TransportAddress getLocalAddress()", "original_string": "    public TransportAddress getLocalAddress()\n    {\n        return getSourceAddress();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/StunTimeoutEvent.java", "class_name": "StunTimeoutEvent", "class_uri": "src/main/java/org/ice4j/StunTimeoutEvent.java.StunTimeoutEvent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "TransportAddress", "classes": []}, "docstring": "\nReturns the <tt>TransportAddress</tt> that the message was supposed to\nleave from.\n\n@return the <tt>TransportAddress</tt> that the message was supposed to\nleave from.\n"}, {"uris": "src/main/java/org/ice4j/StunTimeoutEvent.java.StunTimeoutEvent.[String]toString()", "name": "toString", "arg_nums": 0, "params": [], "return_type": "String", "signature": "@Override\n    public String toString()", "original_string": "    @Override\n    public String toString()\n    {\n        StringBuffer buff = new StringBuffer(\"StunTimeoutEvent:\\n\\tMessage=\");\n\n        buff.append(getMessage());\n        buff.append(\" localAddr=\").append(getLocalAddress());\n\n        return buff.toString();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/StunTimeoutEvent.java", "class_name": "StunTimeoutEvent", "class_uri": "src/main/java/org/ice4j/StunTimeoutEvent.java.StunTimeoutEvent", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns a <tt>String</tt> representation of this event, containing the\ncorresponding message, and local address.\n\n@return a <tt>String</tt> representation of this event, containing the\ncorresponding message, and local address.\n"}, {"uris": "src/main/java/org/ice4j/AbstractResponseCollector.java.AbstractResponseCollector.[void]processFailure(BaseStunMessageEvent)", "name": "processFailure", "arg_nums": 1, "params": [{"name": "event", "type": "BaseStunMessageEvent"}], "return_type": "void", "signature": "protected abstract void processFailure(BaseStunMessageEvent event)", "original_string": "    protected abstract void processFailure(BaseStunMessageEvent event);", "default_arguments": null, "file": "src/main/java/org/ice4j/AbstractResponseCollector.java", "class_name": "AbstractResponseCollector", "class_uri": "src/main/java/org/ice4j/AbstractResponseCollector.java.AbstractResponseCollector", "attributes": {"modifiers": "protected abstract", "marker_annotations": [], "non_marker_annotations": ["protected", "abstract"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nNotifies this <tt>ResponseCollector</tt> that a transaction described by\nthe specified <tt>BaseStunMessageEvent</tt> has failed. The possible\nreasons for the failure include timeouts, unreachable destination, etc.\n\n@param event the <tt>BaseStunMessageEvent</tt> which describes the failed\ntransaction and the runtime type of which specifies the failure reason\n"}, {"uris": "src/main/java/org/ice4j/AbstractResponseCollector.java.AbstractResponseCollector.[void]processTimeout(StunTimeoutEvent)", "name": "processTimeout", "arg_nums": 1, "params": [{"name": "event", "type": "StunTimeoutEvent"}], "return_type": "void", "signature": "public void processTimeout(StunTimeoutEvent event)", "original_string": "    public void processTimeout(StunTimeoutEvent event)\n    {\n        processFailure(event);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/AbstractResponseCollector.java", "class_name": "AbstractResponseCollector", "class_uri": "src/main/java/org/ice4j/AbstractResponseCollector.java.AbstractResponseCollector", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nNotifies this collector that no response had been received after repeated\nretransmissions of the original request (as described by rfc3489) and\nthat the request should be considered unanswered.\n\n@param event the <tt>StunTimeoutEvent</tt> containing a reference to the\ntransaction that has just failed.\n"}, {"uris": "src/main/java/org/ice4j/AbstractResponseCollector.java.AbstractResponseCollector.[void]processUnreachable(StunFailureEvent)", "name": "processUnreachable", "arg_nums": 1, "params": [{"name": "event", "type": "StunFailureEvent"}], "return_type": "void", "signature": "public void processUnreachable(StunFailureEvent event)", "original_string": "    public void processUnreachable(StunFailureEvent event)\n    {\n        processFailure(event);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/AbstractResponseCollector.java", "class_name": "AbstractResponseCollector", "class_uri": "src/main/java/org/ice4j/AbstractResponseCollector.java.AbstractResponseCollector", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nNotifies this collector that the destination of the request has been\ndetermined to be unreachable and that the request should be considered\nunanswered.\n\n@param event the <tt>StunFailureEvent</tt> containing the\n<tt>PortUnreachableException</tt> that has just occurred.\n"}, {"uris": "src/main/java/org/ice4j/StackProperties.java.StackProperties.[String]getString(String)", "name": "getString", "arg_nums": 1, "params": [{"name": "propertyName", "type": "String"}], "return_type": "String", "signature": "public static String getString(String propertyName)", "original_string": "    public static String getString(String propertyName)\n    {\n        Object obj = System.getProperty(propertyName);\n        String str;\n\n        if (obj == null)\n        {\n            str = null;\n        }\n        else\n        {\n            str = obj.toString().trim();\n            if (str.length() == 0)\n                str = null;\n        }\n        return str;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/StackProperties.java", "class_name": "StackProperties", "class_uri": "src/main/java/org/ice4j/StackProperties.java.StackProperties", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns the String value of the specified property (minus all\nencompassing whitespaces)and null in case no property value was mapped\nagainst the specified propertyName, or in case the returned property\nstring had zero length or contained whitespaces only.\n\n@param propertyName the name of the property that is being queried.\n\n@return the result of calling the property's toString method and null in\ncase there was no value mapped against the specified\n<tt>propertyName</tt>, or the returned string had zero length or\ncontained whitespaces only.\n"}, {"uris": "src/main/java/org/ice4j/StackProperties.java.StackProperties.[String[]]getStringArray(String,String)", "name": "getStringArray", "arg_nums": 2, "params": [{"name": "propertyName", "type": "String"}, {"name": "regex", "type": "String"}], "return_type": "String[]", "signature": "public static String[] getStringArray(String propertyName, String regex)", "original_string": "    public static String[] getStringArray(String propertyName, String regex)\n    {\n        String str = getString(propertyName);\n        if (str == null)\n            return null;\n\n        String[] parts = str.split(regex);\n\n        // Remove mal-formatted entries.\n        List<String> res = new ArrayList<>();\n        for (String s : parts)\n            if (s != null && s.trim().length() != 0)\n                res.add(s);\n\n        if (res.size() == 0)\n            return null;\n\n        return res.toArray(new String[res.size()]);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/StackProperties.java", "class_name": "StackProperties", "class_uri": "src/main/java/org/ice4j/StackProperties.java.StackProperties", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "String[]", "classes": []}, "docstring": "\nReturns the String array of the specified property, or null in case\nthe returned property string array had zero length.\n\n@param propertyName the name of the property that is being queried.\n@param  regex the delimiting regular expression\n\n@return  the array of strings computed by splitting the specified\nproperty value around matches of the given regular expression\n"}, {"uris": "src/main/java/org/ice4j/StackProperties.java.StackProperties.[int]getInt(String,int)", "name": "getInt", "arg_nums": 2, "params": [{"name": "propertyName", "type": "String"}, {"name": "defaultValue", "type": "int"}], "return_type": "int", "signature": "public static int getInt(String propertyName, int defaultValue)", "original_string": "    public static int getInt(String propertyName, int defaultValue)\n    {\n        String stringValue = getString(propertyName);\n        int intValue = defaultValue;\n\n        if ((stringValue != null) && (stringValue.length() > 0))\n        {\n            try\n            {\n                intValue = Integer.parseInt(stringValue);\n            }\n            catch (NumberFormatException ex)\n            {\n                logger.log(\n                        Level.FINE,\n                        propertyName + \" does not appear to be an integer. \"\n                            + \"Defaulting to \" + defaultValue + \".\",\n                        ex);\n            }\n        }\n        return intValue;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/StackProperties.java", "class_name": "StackProperties", "class_uri": "src/main/java/org/ice4j/StackProperties.java.StackProperties", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\nReturns the value of a specific property as a signed decimal integer. If\na property with the specified property name exists, its string\nrepresentation is parsed into a signed decimal integer according to the\nrules of {@link Integer#parseInt(String)}. If parsing the value as a\nsigned decimal integer fails or there is no value associated with the\nspecified property name, <tt>defaultValue</tt> is returned.\n\n@param propertyName the name of the property to get the value of as a\nsigned decimal integer\n@param defaultValue the value to be returned if parsing the value of the\nspecified property name as a signed decimal integer fails or there is no\nvalue associated with the specified property name in the System\nproperties.\n@return the value of the property with the specified name in the System\nproperties as a signed decimal integer;\n<tt>defaultValue</tt> if parsing the value of the specified property name\nfails or no value is associated among the System properties.\n"}, {"uris": "src/main/java/org/ice4j/StackProperties.java.StackProperties.[boolean]getBoolean(String,boolean)", "name": "getBoolean", "arg_nums": 2, "params": [{"name": "propertyName", "type": "String"}, {"name": "defaultValue", "type": "boolean"}], "return_type": "boolean", "signature": "public static boolean getBoolean(String propertyName, boolean defaultValue)", "original_string": "    public static boolean getBoolean(String propertyName, boolean defaultValue)\n    {\n        String str = getString(propertyName);\n\n        return (str == null) ? defaultValue : Boolean.parseBoolean(str);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/StackProperties.java", "class_name": "StackProperties", "class_uri": "src/main/java/org/ice4j/StackProperties.java.StackProperties", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nGets the value of a specific property as a <tt>boolean</tt>. If the\nspecified property name is associated with a value, the string\nrepresentation of the value is parsed into a <tt>boolean</tt> according\nto the rules of {@link Boolean#parseBoolean(String)} . Otherwise,\n<tt>defaultValue</tt> is returned.\n\n@param propertyName the name of the property to get the value of as a\n<tt>boolean</tt>\n@param defaultValue the value to be returned if the specified property\nname is not associated with a value\n@return the value of the property with the specified name as a\n<tt>boolean</tt>; <tt>defaultValue</tt> if the property with the\nspecified name is not associated with a value\n"}, {"uris": "src/main/java/org/ice4j/ResponseCollector.java.ResponseCollector.[void]processResponse(StunResponseEvent)", "name": "processResponse", "arg_nums": 1, "params": [{"name": "event", "type": "StunResponseEvent"}], "return_type": "void", "signature": "public void processResponse(StunResponseEvent event)", "original_string": "    public void processResponse(StunResponseEvent event);", "default_arguments": null, "file": "src/main/java/org/ice4j/ResponseCollector.java", "class_name": "ResponseCollector", "class_uri": "src/main/java/org/ice4j/ResponseCollector.java.ResponseCollector", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nDispatch the specified response.\n\n@param event the response to dispatch.\n"}, {"uris": "src/main/java/org/ice4j/ResponseCollector.java.ResponseCollector.[void]processTimeout(StunTimeoutEvent)", "name": "processTimeout", "arg_nums": 1, "params": [{"name": "event", "type": "StunTimeoutEvent"}], "return_type": "void", "signature": "public void processTimeout(StunTimeoutEvent event)", "original_string": "    public void processTimeout(StunTimeoutEvent event);", "default_arguments": null, "file": "src/main/java/org/ice4j/ResponseCollector.java", "class_name": "ResponseCollector", "class_uri": "src/main/java/org/ice4j/ResponseCollector.java.ResponseCollector", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nNotifies this collector that no response had been received after repeated\nretransmissions of the original request (as described by rfc3489) and\nthat the request should be considered unanswered.\n\n@param event the <tt>StunTimeoutEvent</tt> containing a reference to the\ntransaction that has just failed.\n"}, {"uris": "src/main/java/org/ice4j/StunFailureEvent.java.StunFailureEvent.[]StunFailureEvent(StunStack,Message,TransportAddress,Throwable)", "name": "StunFailureEvent", "arg_nums": 4, "params": [{"name": "stunStack", "type": "StunStack"}, {"name": "message", "type": "Message"}, {"name": "localAddress", "type": "TransportAddress"}, {"name": "cause", "type": "Throwable"}], "return_type": "", "signature": "public StunFailureEvent(\n            StunStack stunStack,\n            Message message,\n            TransportAddress localAddress,\n            Throwable cause)", "original_string": "    public StunFailureEvent(\n            StunStack stunStack,\n            Message message,\n            TransportAddress localAddress,\n            Throwable cause)\n    {\n        super(stunStack, localAddress, message);\n\n        this.cause = cause;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/StunFailureEvent.java", "class_name": "StunFailureEvent", "class_uri": "src/main/java/org/ice4j/StunFailureEvent.java.StunFailureEvent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nConstructs a <tt>StunFailureEvent</tt> according to the specified\nmessage.\n\n@param stunStack the <tt>StunStack</tt> to be associated with the new\ninstance\n@param message the message itself\n@param localAddress the local address that the message was sent from.\n@param cause the <tt>Exception</tt> that caused this failure or\n<tt>null</tt> if there's no <tt>Exception</tt> associated with this\nfailure\n"}, {"uris": "src/main/java/org/ice4j/StunFailureEvent.java.StunFailureEvent.[TransportAddress]getLocalAddress()", "name": "getLocalAddress", "arg_nums": 0, "params": [], "return_type": "TransportAddress", "signature": "public TransportAddress getLocalAddress()", "original_string": "    public TransportAddress getLocalAddress()\n    {\n        return getSourceAddress();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/StunFailureEvent.java", "class_name": "StunFailureEvent", "class_uri": "src/main/java/org/ice4j/StunFailureEvent.java.StunFailureEvent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "TransportAddress", "classes": []}, "docstring": "\nReturns the <tt>TransportAddress</tt> that the message was supposed to\nleave from.\n\n@return the <tt>TransportAddress</tt> that the message was supposed to\nleave from.\n"}, {"uris": "src/main/java/org/ice4j/StunFailureEvent.java.StunFailureEvent.[Throwable]getCause()", "name": "getCause", "arg_nums": 0, "params": [], "return_type": "Throwable", "signature": "public Throwable getCause()", "original_string": "    public Throwable getCause()\n    {\n        return cause;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/StunFailureEvent.java", "class_name": "StunFailureEvent", "class_uri": "src/main/java/org/ice4j/StunFailureEvent.java.StunFailureEvent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Throwable", "classes": []}, "docstring": "\nReturns the <tt>Exception</tt> that cause this failure or <tt>null</tt>\nif the failure is not related to an <tt>Exception</tt>.\n\n@return the <tt>Exception</tt> that cause this failure or <tt>null</tt>\nif the failure is not related to an <tt>Exception</tt>.\n"}, {"uris": "src/main/java/org/ice4j/StunFailureEvent.java.StunFailureEvent.[String]toString()", "name": "toString", "arg_nums": 0, "params": [], "return_type": "String", "signature": "@Override\n    public String toString()", "original_string": "    @Override\n    public String toString()\n    {\n        StringBuffer buff = new StringBuffer(\"StunFailureEvent:\\n\\tMessage=\");\n\n        buff.append(getMessage());\n        buff.append(\" localAddr=\").append(getLocalAddress());\n\n        return buff.toString();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/StunFailureEvent.java", "class_name": "StunFailureEvent", "class_uri": "src/main/java/org/ice4j/StunFailureEvent.java.StunFailureEvent", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns a <tt>String</tt> representation of this event, containing the\ncorresponding message, and local address.\n\n@return a <tt>String</tt> representation of this event, containing the\ncorresponding message, and local address.\n"}, {"uris": "src/main/java/org/ice4j/StunResponseEvent.java.StunResponseEvent.[]StunResponseEvent(StunStack,RawMessage,Response,Request,TransactionID)", "name": "StunResponseEvent", "arg_nums": 5, "params": [{"name": "stunStack", "type": "StunStack"}, {"name": "rawMessage", "type": "RawMessage"}, {"name": "response", "type": "Response"}, {"name": "request", "type": "Request"}, {"name": "transactionID", "type": "TransactionID"}], "return_type": "", "signature": "public StunResponseEvent(\n            StunStack stunStack,\n            RawMessage rawMessage,\n            Response response,\n            Request request,\n            TransactionID transactionID)", "original_string": "    public StunResponseEvent(\n            StunStack stunStack,\n            RawMessage rawMessage,\n            Response response,\n            Request request,\n            TransactionID transactionID)\n    {\n        super(stunStack, rawMessage, response);\n        this.request = request;\n        super.setTransactionID(transactionID);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/StunResponseEvent.java", "class_name": "StunResponseEvent", "class_uri": "src/main/java/org/ice4j/StunResponseEvent.java.StunResponseEvent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nCreates a new instance of this event.\n\n@param stunStack the <tt>StunStack</tt> to be associated with the new\ninstance\n@param rawMessage the crude message we got off the wire.\n@param response the STUN {@link Response} that we've just received.\n@param request  the message itself\n@param transactionID a reference to the exact {@link TransactionID}\ninstance that represents the corresponding client transaction.\n"}, {"uris": "src/main/java/org/ice4j/StunResponseEvent.java.StunResponseEvent.[Request]getRequest()", "name": "getRequest", "arg_nums": 0, "params": [], "return_type": "Request", "signature": "public Request getRequest()", "original_string": "    public Request getRequest()\n    {\n        return request;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/StunResponseEvent.java", "class_name": "StunResponseEvent", "class_uri": "src/main/java/org/ice4j/StunResponseEvent.java.StunResponseEvent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Request", "classes": []}, "docstring": "\nReturns the {@link Request} that started the transaction that this\n{@link Response} has just arrived in.\n\n@return the {@link Request} that started the transaction that this\n{@link Response} has just arrived in.\n"}, {"uris": "src/main/java/org/ice4j/StunResponseEvent.java.StunResponseEvent.[Response]getResponse()", "name": "getResponse", "arg_nums": 0, "params": [], "return_type": "Response", "signature": "public Response getResponse()", "original_string": "    public Response getResponse()\n    {\n        return (Response)getMessage();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/StunResponseEvent.java", "class_name": "StunResponseEvent", "class_uri": "src/main/java/org/ice4j/StunResponseEvent.java.StunResponseEvent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Response", "classes": []}, "docstring": "\nReturns the {@link Response} that has just arrived and that caused this\nevent.\n\n@return  the {@link Response} that has just arrived and that caused this\nevent.\n"}, {"uris": "src/main/java/org/ice4j/ChannelDataMessageEvent.java.ChannelDataMessageEvent.[]ChannelDataMessageEvent(StunStack,TransportAddress,TransportAddress,ChannelData)", "name": "ChannelDataMessageEvent", "arg_nums": 4, "params": [{"name": "stunStack", "type": "StunStack"}, {"name": "remoteAddress", "type": "TransportAddress"}, {"name": "localAddress", "type": "TransportAddress"}, {"name": "channelDataMessage", "type": "ChannelData"}], "return_type": "", "signature": "public ChannelDataMessageEvent(StunStack stunStack,\n        TransportAddress remoteAddress,\n        TransportAddress localAddress,\n        ChannelData channelDataMessage)", "original_string": "    public ChannelDataMessageEvent(StunStack stunStack,\n        TransportAddress remoteAddress,\n        TransportAddress localAddress,\n        ChannelData channelDataMessage)\n    {\n        super(remoteAddress);\n        \n        this.remoteAddress = remoteAddress;\n        this.localAddress = localAddress;\n        this.stunStack = stunStack;\n        this.channelDataMessage = channelDataMessage;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ChannelDataMessageEvent.java", "class_name": "ChannelDataMessageEvent", "class_uri": "src/main/java/org/ice4j/ChannelDataMessageEvent.java.ChannelDataMessageEvent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>ChannelDataMessageEvent</tt> associated with a\nspecific ChannelData <tt>Message</tt>.\n\n@param stunStack the <tt>StunStack</tt> to be associated with the new\n           instance.\n@param remoteAddress the <tt>TransportAddress</tt> which is to be\n           reported as the source of the new event.\n@param localAddress the <tt>TransportAddress</tt> which is to be reported\n           as the receiving location of the new event.\n@param channelDataMessage the ChannelData <tt>Message</tt> associated\n           with the new event.\n"}, {"uris": "src/main/java/org/ice4j/ChannelDataMessageEvent.java.ChannelDataMessageEvent.[ChannelData]getChannelDataMessage()", "name": "getChannelDataMessage", "arg_nums": 0, "params": [], "return_type": "ChannelData", "signature": "public ChannelData getChannelDataMessage()", "original_string": "    public ChannelData getChannelDataMessage()\n    {\n        return channelDataMessage;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ChannelDataMessageEvent.java", "class_name": "ChannelDataMessageEvent", "class_uri": "src/main/java/org/ice4j/ChannelDataMessageEvent.java.ChannelDataMessageEvent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChannelData", "classes": []}, "docstring": "\nGets the ChannelData <tt>Message</tt> associated with this event.\n\n@return the ChannelData <tt>Message</tt> associated with this event\n"}, {"uris": "src/main/java/org/ice4j/ChannelDataMessageEvent.java.ChannelDataMessageEvent.[TransportAddress]getRemoteAddress()", "name": "getRemoteAddress", "arg_nums": 0, "params": [], "return_type": "TransportAddress", "signature": "public TransportAddress getRemoteAddress()", "original_string": "    public TransportAddress getRemoteAddress()\n    {\n        return this.remoteAddress;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ChannelDataMessageEvent.java", "class_name": "ChannelDataMessageEvent", "class_uri": "src/main/java/org/ice4j/ChannelDataMessageEvent.java.ChannelDataMessageEvent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "TransportAddress", "classes": []}, "docstring": "\nGets the <tt>TransportAddress</tt> which is the remote address of this\nevent.\n\n@return the <tt>TransportAddress</tt> which is the address who caused\n        this event\n"}, {"uris": "src/main/java/org/ice4j/ChannelDataMessageEvent.java.ChannelDataMessageEvent.[TransportAddress]getLocalAddress()", "name": "getLocalAddress", "arg_nums": 0, "params": [], "return_type": "TransportAddress", "signature": "public TransportAddress getLocalAddress()", "original_string": "    public TransportAddress getLocalAddress()\n    {\n        return this.localAddress;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ChannelDataMessageEvent.java", "class_name": "ChannelDataMessageEvent", "class_uri": "src/main/java/org/ice4j/ChannelDataMessageEvent.java.ChannelDataMessageEvent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "TransportAddress", "classes": []}, "docstring": "\nGets the <tt>TransportAddress</tt> which is local address on which this\nevent was received.\n\n@return the <tt>TransportAddress</tt> which is local address on which\n        this event was received.\n"}, {"uris": "src/main/java/org/ice4j/ChannelDataMessageEvent.java.ChannelDataMessageEvent.[StunStack]getStunStack()", "name": "getStunStack", "arg_nums": 0, "params": [], "return_type": "StunStack", "signature": "public StunStack getStunStack()", "original_string": "    public StunStack getStunStack()\n    {\n        return stunStack;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ChannelDataMessageEvent.java", "class_name": "ChannelDataMessageEvent", "class_uri": "src/main/java/org/ice4j/ChannelDataMessageEvent.java.ChannelDataMessageEvent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "StunStack", "classes": []}, "docstring": "\nGets the <tt>StunStack</tt> associated with this instance.\n\n@return the <tt>StunStack</tt> associated with this instance\n"}, {"uris": "src/main/java/org/ice4j/PeerUdpMessageEvent.java.PeerUdpMessageEvent.[]PeerUdpMessageEvent(StunStack,RawMessage)", "name": "PeerUdpMessageEvent", "arg_nums": 2, "params": [{"name": "stunStack", "type": "StunStack"}, {"name": "udpMessage", "type": "RawMessage"}], "return_type": "", "signature": "public PeerUdpMessageEvent(StunStack stunStack, RawMessage udpMessage)", "original_string": "    public PeerUdpMessageEvent(StunStack stunStack, RawMessage udpMessage)\n    {\n        super(udpMessage.getRemoteAddress());\n        \n        this.stunStack = stunStack;\n        this.udpMessage = udpMessage;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/PeerUdpMessageEvent.java", "class_name": "PeerUdpMessageEvent", "class_uri": "src/main/java/org/ice4j/PeerUdpMessageEvent.java.PeerUdpMessageEvent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>PeerUdpMessageEvent</tt> associated with a\nspecific PeerUdp <tt>Message</tt>.\n\n@param stunStack the <tt>StunStack</tt> to be associated with the new\n           instance.\n@param udpMessage the Peer UDP <tt>Message</tt> associated\n           with the new event.\n"}, {"uris": "src/main/java/org/ice4j/PeerUdpMessageEvent.java.PeerUdpMessageEvent.[byte[]]getBytes()", "name": "getBytes", "arg_nums": 0, "params": [], "return_type": "byte[]", "signature": "public byte[] getBytes()", "original_string": "    public byte[] getBytes()\n    {\n        return this.udpMessage.getBytes();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/PeerUdpMessageEvent.java", "class_name": "PeerUdpMessageEvent", "class_uri": "src/main/java/org/ice4j/PeerUdpMessageEvent.java.PeerUdpMessageEvent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "byte[]", "classes": []}, "docstring": "\nReturns the message itself.\n\n@return a binary array containing the message data.\n"}, {"uris": "src/main/java/org/ice4j/PeerUdpMessageEvent.java.PeerUdpMessageEvent.[int]getMessageLength()", "name": "getMessageLength", "arg_nums": 0, "params": [], "return_type": "int", "signature": "public int getMessageLength()", "original_string": "    public int getMessageLength()\n    {\n        return this.udpMessage.getMessageLength();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/PeerUdpMessageEvent.java", "class_name": "PeerUdpMessageEvent", "class_uri": "src/main/java/org/ice4j/PeerUdpMessageEvent.java.PeerUdpMessageEvent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\nReturns the message length.\n\n@return a the length of the message.\n"}, {"uris": "src/main/java/org/ice4j/PeerUdpMessageEvent.java.PeerUdpMessageEvent.[TransportAddress]getRemoteAddress()", "name": "getRemoteAddress", "arg_nums": 0, "params": [], "return_type": "TransportAddress", "signature": "public TransportAddress getRemoteAddress()", "original_string": "    public TransportAddress getRemoteAddress()\n    {\n        return this.udpMessage.getRemoteAddress();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/PeerUdpMessageEvent.java", "class_name": "PeerUdpMessageEvent", "class_uri": "src/main/java/org/ice4j/PeerUdpMessageEvent.java.PeerUdpMessageEvent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "TransportAddress", "classes": []}, "docstring": "\nReturns the address and port of the host that sent the message\n\n@return the [address]:[port] pair that sent the message.\n"}, {"uris": "src/main/java/org/ice4j/PeerUdpMessageEvent.java.PeerUdpMessageEvent.[TransportAddress]getLocalAddress()", "name": "getLocalAddress", "arg_nums": 0, "params": [], "return_type": "TransportAddress", "signature": "public TransportAddress getLocalAddress()", "original_string": "    public TransportAddress getLocalAddress()\n    {\n        return this.udpMessage.getLocalAddress();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/PeerUdpMessageEvent.java", "class_name": "PeerUdpMessageEvent", "class_uri": "src/main/java/org/ice4j/PeerUdpMessageEvent.java.PeerUdpMessageEvent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "TransportAddress", "classes": []}, "docstring": "\nReturns the address that this message was received on.\n\n@return the address that this message was received on.\n"}, {"uris": "src/main/java/org/ice4j/PeerUdpMessageEvent.java.PeerUdpMessageEvent.[StunStack]getStunStack()", "name": "getStunStack", "arg_nums": 0, "params": [], "return_type": "StunStack", "signature": "public StunStack getStunStack()", "original_string": "    public StunStack getStunStack()\n    {\n        return stunStack;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/PeerUdpMessageEvent.java", "class_name": "PeerUdpMessageEvent", "class_uri": "src/main/java/org/ice4j/PeerUdpMessageEvent.java.PeerUdpMessageEvent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "StunStack", "classes": []}, "docstring": "\nGets the <tt>StunStack</tt> associated with this instance.\n\n@return the <tt>StunStack</tt> associated with this instance\n"}, {"uris": "src/main/java/org/ice4j/BaseStunMessageEvent.java.BaseStunMessageEvent.[]BaseStunMessageEvent(StunStack,TransportAddress,Message)", "name": "BaseStunMessageEvent", "arg_nums": 3, "params": [{"name": "stunStack", "type": "StunStack"}, {"name": "sourceAddress", "type": "TransportAddress"}, {"name": "message", "type": "Message"}], "return_type": "", "signature": "public BaseStunMessageEvent(\n            StunStack stunStack,\n            TransportAddress sourceAddress,\n            Message message)", "original_string": "    public BaseStunMessageEvent(\n            StunStack stunStack,\n            TransportAddress sourceAddress,\n            Message message)\n    {\n        super(sourceAddress);\n\n        this.stunStack = stunStack;\n        this.message = message;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/BaseStunMessageEvent.java", "class_name": "BaseStunMessageEvent", "class_uri": "src/main/java/org/ice4j/BaseStunMessageEvent.java.BaseStunMessageEvent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>BaseStunMessageEvent</tt> associated with a\nspecific STUN <tt>Message</tt>.\n\n@param stunStack the <tt>StunStack</tt> to be associated with the new\ninstance\n@param sourceAddress the <tt>TransportAddress</tt> which is to be\nreported as the source of the new event\n@param message the STUN <tt>Message</tt> associated with the new event\n"}, {"uris": "src/main/java/org/ice4j/BaseStunMessageEvent.java.BaseStunMessageEvent.[Message]getMessage()", "name": "getMessage", "arg_nums": 0, "params": [], "return_type": "Message", "signature": "public Message getMessage()", "original_string": "    public Message getMessage()\n    {\n        return message;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/BaseStunMessageEvent.java", "class_name": "BaseStunMessageEvent", "class_uri": "src/main/java/org/ice4j/BaseStunMessageEvent.java.BaseStunMessageEvent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Message", "classes": []}, "docstring": "\nGets the STUN <tt>Message</tt> associated with this event.\n\n@return the STUN <tt>Message</tt> associated with this event\n"}, {"uris": "src/main/java/org/ice4j/BaseStunMessageEvent.java.BaseStunMessageEvent.[TransportAddress]getSourceAddress()", "name": "getSourceAddress", "arg_nums": 0, "params": [], "return_type": "TransportAddress", "signature": "protected TransportAddress getSourceAddress()", "original_string": "    protected TransportAddress getSourceAddress()\n    {\n        return (TransportAddress) getSource();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/BaseStunMessageEvent.java", "class_name": "BaseStunMessageEvent", "class_uri": "src/main/java/org/ice4j/BaseStunMessageEvent.java.BaseStunMessageEvent", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "TransportAddress", "classes": []}, "docstring": "\nGets the <tt>TransportAddress</tt> which is the source of this event.\n\n@return the <tt>TransportAddress</tt> which is the source of this event\n"}, {"uris": "src/main/java/org/ice4j/BaseStunMessageEvent.java.BaseStunMessageEvent.[StunStack]getStunStack()", "name": "getStunStack", "arg_nums": 0, "params": [], "return_type": "StunStack", "signature": "public StunStack getStunStack()", "original_string": "    public StunStack getStunStack()\n    {\n        return stunStack;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/BaseStunMessageEvent.java", "class_name": "BaseStunMessageEvent", "class_uri": "src/main/java/org/ice4j/BaseStunMessageEvent.java.BaseStunMessageEvent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "StunStack", "classes": []}, "docstring": "\nGets the <tt>StunStack</tt> associated with this instance.\n\n@return the <tt>StunStack</tt> associated with this instance\n"}, {"uris": "src/main/java/org/ice4j/BaseStunMessageEvent.java.BaseStunMessageEvent.[TransactionID]getTransactionID()", "name": "getTransactionID", "arg_nums": 0, "params": [], "return_type": "TransactionID", "signature": "public TransactionID getTransactionID()", "original_string": "    public TransactionID getTransactionID()\n    {\n        if (transactionID == null)\n        {\n            transactionID\n                = TransactionID.createTransactionID(\n                        getStunStack(),\n                        getMessage().getTransactionID());\n        }\n        return transactionID;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/BaseStunMessageEvent.java", "class_name": "BaseStunMessageEvent", "class_uri": "src/main/java/org/ice4j/BaseStunMessageEvent.java.BaseStunMessageEvent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "TransactionID", "classes": []}, "docstring": "\nGets the ID of the transaction related to the STUN <tt>Message</tt>\nassociated with this event.\n\n@return the ID of the transaction related to the STUN <tt>Message</tt>\nassociated with this event\n"}, {"uris": "src/main/java/org/ice4j/BaseStunMessageEvent.java.BaseStunMessageEvent.[void]setTransactionID(TransactionID)", "name": "setTransactionID", "arg_nums": 1, "params": [{"name": "tranID", "type": "TransactionID"}], "return_type": "void", "signature": "protected void setTransactionID(TransactionID tranID)", "original_string": "    protected void setTransactionID(TransactionID tranID)\n    {\n        this.transactionID = tranID;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/BaseStunMessageEvent.java", "class_name": "BaseStunMessageEvent", "class_uri": "src/main/java/org/ice4j/BaseStunMessageEvent.java.BaseStunMessageEvent", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nAllows descendants of this class to set the transaction ID so that we\ndon't need to look it up later. This is not mandatory.\n\n@param tranID the ID of the transaction associated with this event.\n"}, {"uris": "src/main/java/org/ice4j/TransportAddress.java.TransportAddress.[]TransportAddress(String,int,Transport)", "name": "TransportAddress", "arg_nums": 3, "params": [{"name": "hostname", "type": "String"}, {"name": "port", "type": "int"}, {"name": "transport", "type": "Transport"}], "return_type": "", "signature": "public TransportAddress(String hostname, int port, Transport transport)", "original_string": "    public TransportAddress(String hostname, int port, Transport transport)\n    {\n        super(hostname, port);\n\n        this.transport = transport;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/TransportAddress.java", "class_name": "TransportAddress", "class_uri": "src/main/java/org/ice4j/TransportAddress.java.TransportAddress", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nCreates an address instance address from an IP address and a port number.\n<p>\nA valid port value is between 0 and 65535.\nA port number of <tt>zero</tt> will let the system pick up an\nephemeral port in a <tt>bind</tt> operation.\n<P>\nA <tt>null</tt> address will assign the <i>wildcard</i> address.\n<p>\n@param   hostname    The IP address\n@param   port        The port number\n@param   transport   The transport that this address would be bound to.\n@throws IllegalArgumentException if the port parameter is outside the\nspecified range of valid port values.\n"}, {"uris": "src/main/java/org/ice4j/TransportAddress.java.TransportAddress.[]TransportAddress(byte[],int,Transport)", "name": "TransportAddress", "arg_nums": 3, "params": [{"name": "ipAddress", "type": "byte[]"}, {"name": "port", "type": "int"}, {"name": "transport", "type": "Transport"}], "return_type": "", "signature": "public TransportAddress(byte[] ipAddress, int port, Transport transport)", "original_string": "    public TransportAddress(byte[] ipAddress, int port, Transport transport)\n        throws UnknownHostException\n    {\n        this(InetAddress.getByAddress(ipAddress), port, transport);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/TransportAddress.java", "class_name": "TransportAddress", "class_uri": "src/main/java/org/ice4j/TransportAddress.java.TransportAddress", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nCreates an address instance address from a byte array containing an IP\naddress and a port number.\n<p>\nA valid port value is between 0 and 65535.\nA port number of <tt>zero</tt> will let the system pick up an\nephemeral port in a <tt>bind</tt> operation.\n<P>\nA <tt>null</tt> address will assign the <i>wildcard</i> address.\n<p>\n@param    ipAddress The IP address\n@param    port      The port number\n@param    transport The <tt>Transport</tt> to use with this address.\n\n@throws UnknownHostException UnknownHostException  if IP address is of\nillegal length\n"}, {"uris": "src/main/java/org/ice4j/TransportAddress.java.TransportAddress.[]TransportAddress(InetSocketAddress,Transport)", "name": "TransportAddress", "arg_nums": 2, "params": [{"name": "address", "type": "InetSocketAddress"}, {"name": "transport", "type": "Transport"}], "return_type": "", "signature": "public TransportAddress(InetSocketAddress address, Transport transport)", "original_string": "    public TransportAddress(InetSocketAddress address, Transport transport)\n    {\n        this(address.getAddress(), address.getPort(), transport);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/TransportAddress.java", "class_name": "TransportAddress", "class_uri": "src/main/java/org/ice4j/TransportAddress.java.TransportAddress", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nCreates an address instance from an <tt>InetSocketAddress</tt>.\n\n@param    address   the address and port.\n@param    transport the transport to use with this address.\n\n@throws IllegalArgumentException if the port parameter is outside the\nrange of valid port values, or if the host name parameter is\n<tt>null</tt>.\n"}, {"uris": "src/main/java/org/ice4j/TransportAddress.java.TransportAddress.[]TransportAddress(InetAddress,int,Transport)", "name": "TransportAddress", "arg_nums": 3, "params": [{"name": "address", "type": "InetAddress"}, {"name": "port", "type": "int"}, {"name": "transport", "type": "Transport"}], "return_type": "", "signature": "public TransportAddress(InetAddress address, int port, Transport transport)", "original_string": "    public TransportAddress(InetAddress address, int port, Transport transport)\n    {\n        super(address, port);\n\n        this.transport = transport;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/TransportAddress.java", "class_name": "TransportAddress", "class_uri": "src/main/java/org/ice4j/TransportAddress.java.TransportAddress", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nCreates an address instance from a host name and a port number.\n<p>\nAn attempt will be made to resolve the host name into an InetAddress.\nIf that attempt fails, the address will be flagged as <I>unresolved</I>.\n<p>\nA valid port value is between 0 and 65535. A port number of zero will\nlet the system pick up an ephemeral port in a <tt>bind</tt> operation.\n<p>\n@param    address   the address itself\n@param    port      the port number\n@param    transport the transport to use with this address.\n\n@throws IllegalArgumentException if the port parameter is outside the\nrange of valid port values, or if the host name parameter is\n<tt>null</tt>.\n"}, {"uris": "src/main/java/org/ice4j/TransportAddress.java.TransportAddress.[byte[]]getAddressBytes()", "name": "getAddressBytes", "arg_nums": 0, "params": [], "return_type": "byte[]", "signature": "public byte[] getAddressBytes()", "original_string": "    public byte[] getAddressBytes()\n    {\n        return getAddress().getAddress();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/TransportAddress.java", "class_name": "TransportAddress", "class_uri": "src/main/java/org/ice4j/TransportAddress.java.TransportAddress", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "byte[]", "classes": []}, "docstring": "\nReturns the raw IP address of this Address object. The result is in\nnetwork byte order: the highest order byte of the address is in\ngetAddress()[0].\n\n@return the raw IP address of this object.\n"}, {"uris": "src/main/java/org/ice4j/TransportAddress.java.TransportAddress.[String]toString()", "name": "toString", "arg_nums": 0, "params": [], "return_type": "String", "signature": "public String toString()", "original_string": "    public String toString()\n    {\n        return toString(false);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/TransportAddress.java", "class_name": "TransportAddress", "class_uri": "src/main/java/org/ice4j/TransportAddress.java.TransportAddress", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nConstructs a string representation of this InetSocketAddress. This String\nis constructed by calling toString() on the InetAddress and concatenating\nthe port number (with a colon). If the address is unresolved then the\npart before the colon will only contain the host name.\n\n@return a string representation of this object.\n"}, {"uris": "src/main/java/org/ice4j/TransportAddress.java.TransportAddress.[String]toRedactedString()", "name": "toRedactedString", "arg_nums": 0, "params": [], "return_type": "String", "signature": "public String toRedactedString()", "original_string": "    public String toRedactedString()\n    {\n        return toString(true);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/TransportAddress.java", "class_name": "TransportAddress", "class_uri": "src/main/java/org/ice4j/TransportAddress.java.TransportAddress", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": ""}, {"uris": "src/main/java/org/ice4j/TransportAddress.java.TransportAddress.[String]toString(boolean)", "name": "toString", "arg_nums": 1, "params": [{"name": "redact", "type": "boolean"}], "return_type": "String", "signature": "private String toString(boolean redact)", "original_string": "    private String toString(boolean redact)\n    {\n        String hostAddress;\n        if (redact)\n        {\n            hostAddress = getRedactedAddress();\n            if (hostAddress == null)\n            {\n                String hostName = getHostName();\n                if (hostName != null)\n                {\n                    /* The transport address is an unresolved hostname.  Redact the hostname. */\n                    hostAddress = \"xxxx.xxx\";\n                }\n            }\n        }\n        else\n        {\n            hostAddress = getHostAddress();\n            if (hostAddress == null)\n            {\n                hostAddress = getHostName();\n            }\n        }\n        if (hostAddress == null)\n        {\n            // The address has neither a hostName nor a hostAddress.  Shouldn't happen, but don't NPE if it does. */\n            hostAddress = \"null\";\n        }\n\n        StringBuilder bldr = new StringBuilder(hostAddress);\n\n        if (isIPv6())\n           bldr.insert(0, \"[\").append(\"]\");\n\n        bldr.append(\":\").append(getPort());\n        bldr.append(\"/\").append(getTransport());\n\n        return bldr.toString();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/TransportAddress.java", "class_name": "TransportAddress", "class_uri": "src/main/java/org/ice4j/TransportAddress.java.TransportAddress", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "String", "classes": []}, "docstring": ""}, {"uris": "src/main/java/org/ice4j/TransportAddress.java.TransportAddress.[String]getHostAddress()", "name": "getHostAddress", "arg_nums": 0, "params": [], "return_type": "String", "signature": "public String getHostAddress()", "original_string": "    public String getHostAddress()\n    {\n        InetAddress addr = getAddress();\n        String addressStr\n            = addr != null ? addr.getHostAddress() : null;\n\n        if (addr instanceof Inet6Address)\n            addressStr = NetworkUtils.stripScopeID(addressStr);\n\n        return addressStr;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/TransportAddress.java", "class_name": "TransportAddress", "class_uri": "src/main/java/org/ice4j/TransportAddress.java.TransportAddress", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns the host address.\n\n@return a String part of the address\n"}, {"uris": "src/main/java/org/ice4j/TransportAddress.java.TransportAddress.[String]getRedactedAddress()", "name": "getRedactedAddress", "arg_nums": 0, "params": [], "return_type": "String", "signature": "public String getRedactedAddress()", "original_string": "    public String getRedactedAddress()\n    {\n        if (AgentConfig.config.getRedactRemoteAddresses())\n        {\n            InetAddress addr = getAddress();\n            if (addr != null)\n            {\n                return toRedactedString(addr);\n            }\n            else\n            {\n                return null;\n            }\n        }\n        else\n        {\n            return getHostAddress();\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/TransportAddress.java", "class_name": "TransportAddress", "class_uri": "src/main/java/org/ice4j/TransportAddress.java.TransportAddress", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": " Return the host address, redacted if address redaction is enabled."}, {"uris": "src/main/java/org/ice4j/TransportAddress.java.TransportAddress.[Transport]getTransport()", "name": "getTransport", "arg_nums": 0, "params": [], "return_type": "Transport", "signature": "public Transport getTransport()", "original_string": "    public Transport getTransport()\n    {\n        return transport;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/TransportAddress.java", "class_name": "TransportAddress", "class_uri": "src/main/java/org/ice4j/TransportAddress.java.TransportAddress", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Transport", "classes": []}, "docstring": "\nThe transport that this transport address is suggesting.\n\n@return one of the transport strings (UDP/TCP/...) defined as contants\nin this class.\n"}, {"uris": "src/main/java/org/ice4j/TransportAddress.java.TransportAddress.[boolean]equals(TransportAddress)", "name": "equals", "arg_nums": 1, "params": [{"name": "transportAddress", "type": "TransportAddress"}], "return_type": "boolean", "signature": "public boolean equals(TransportAddress transportAddress)", "original_string": "    public boolean equals(TransportAddress transportAddress)\n    {\n        return equalsTransportAddress(transportAddress);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/TransportAddress.java", "class_name": "TransportAddress", "class_uri": "src/main/java/org/ice4j/TransportAddress.java.TransportAddress", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nDetermines whether this <tt>TransportAddress</tt> is value equal to a\nspecific <tt>TransportAddress</tt>.\n\n@param transportAddress the <tt>TransportAddress</tt> to test for value\nequality with this <tt>TransportAddress</tt>\n@return <tt>true</tt> if this <tt>TransportAddress</tt> is value equal to\nthe specified <tt>transportAddress</tt>; otherwise, <tt>false</tt>\n@see #equalsTransportAddress(Object)\n"}, {"uris": "src/main/java/org/ice4j/TransportAddress.java.TransportAddress.[boolean]equalsTransportAddress(Object)", "name": "equalsTransportAddress", "arg_nums": 1, "params": [{"name": "obj", "type": "Object"}], "return_type": "boolean", "signature": "public boolean equalsTransportAddress(Object obj)", "original_string": "    public boolean equalsTransportAddress(Object obj)\n    {\n        return super.equals(obj)\n            &&(  ((TransportAddress)obj).getTransport() == getTransport() );\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/TransportAddress.java", "class_name": "TransportAddress", "class_uri": "src/main/java/org/ice4j/TransportAddress.java.TransportAddress", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nCompares this object against the specified object. The result is\n<tt>true</tt> if and only if the argument is not <tt>null</tt> and it\nrepresents the same address.\n<p>\nTwo instances of <tt>TransportAddress</tt> represent the same\naddress if both the InetAddresses (or hostnames if it is unresolved),\nport numbers, and <tt>Transport</tt>s are equal.\n\nIf both addresses are unresolved, then the hostname, the port and\nthe <tt>Transport</tt> are compared.\n\n@param   obj   the object to compare against.\n@return  <tt>true</tt> if the objects are the same and\n<tt>false</tt> otherwise.\n@see java.net.InetAddress#equals(java.lang.Object)\n"}, {"uris": "src/main/java/org/ice4j/TransportAddress.java.TransportAddress.[boolean]isIPv6()", "name": "isIPv6", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "public boolean isIPv6()", "original_string": "    public boolean isIPv6()\n    {\n        return getAddress() instanceof Inet6Address;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/TransportAddress.java", "class_name": "TransportAddress", "class_uri": "src/main/java/org/ice4j/TransportAddress.java.TransportAddress", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nReturns <tt>true</tt> if this is an IPv6 address and <tt>false</tt>\notherwise.\n\n@return <tt>true</tt> if this is an IPv6 address and <tt>false</tt>\notherwise.\n"}, {"uris": "src/main/java/org/ice4j/TransportAddress.java.TransportAddress.[boolean]canReach(TransportAddress)", "name": "canReach", "arg_nums": 1, "params": [{"name": "dst", "type": "TransportAddress"}], "return_type": "boolean", "signature": "public boolean canReach(TransportAddress dst)", "original_string": "    public boolean canReach(TransportAddress dst)\n    {\n        if ( getTransport() != dst.getTransport() )\n            return false;\n\n        if (isIPv6() != dst.isIPv6())\n            return false;\n\n        if (isIPv6())\n        {\n            Inet6Address srcAddr = (Inet6Address)getAddress();\n            Inet6Address dstAddr = (Inet6Address)dst.getAddress();\n\n            if (srcAddr.isLinkLocalAddress() != dstAddr.isLinkLocalAddress())\n            {\n                //this one may actually work if for example we are contacting\n                //the public address of someone in our local network. however\n                //in most cases we would also be able to reach the same address\n                //via a global address of our own and the probability of the\n                //opposite is considerably lower than the probability of us\n                //trying to reach a distant global address through one of our\n                //own. Therefore we would return false here by default.\n                return\n                    Boolean.getBoolean(\n                            StackProperties.ALLOW_LINK_TO_GLOBAL_REACHABILITY);\n            }\n        }\n\n        //may add more unreachability conditions here in the future;\n\n        return true;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/TransportAddress.java", "class_name": "TransportAddress", "class_uri": "src/main/java/org/ice4j/TransportAddress.java.TransportAddress", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nDetermines whether this <tt>TransportAddress</tt> is theoretically\ncapable of communicating with <tt>dst</tt>. An address is certain not\nto be able to communicate with another if they do not have the same\n<tt>Transport</tt> or family.\n\n@param dst the <tt>TransportAddress</tt> that we'd like to check for\nreachability from this one.\n\n@return <tt>true</tt> if this {@link TransportAddress} shares the same\n<tt>Transport</tt> and family as <tt>dst</tt> or <tt>false</tt>\notherwise.\n\n"}, {"uris": "src/main/java/org/ice4j/TransportAddress.java.TransportAddress.[String]redact(InetAddress)", "name": "redact", "arg_nums": 1, "params": [{"name": "addr", "type": "InetAddress"}], "return_type": "String", "signature": "public static String redact(InetAddress addr)", "original_string": "    public static String redact(InetAddress addr)\n    {\n        if (AgentConfig.config.getRedactRemoteAddresses())\n        {\n            return toRedactedString(addr);\n        }\n        else\n        {\n            return addr.getHostAddress();\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/TransportAddress.java", "class_name": "TransportAddress", "class_uri": "src/main/java/org/ice4j/TransportAddress.java.TransportAddress", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "String", "classes": []}, "docstring": ""}, {"uris": "src/main/java/org/ice4j/TransportAddress.java.TransportAddress.[String]redact(SocketAddress)", "name": "redact", "arg_nums": 1, "params": [{"name": "addr", "type": "SocketAddress"}], "return_type": "String", "signature": "public static String redact(SocketAddress addr)", "original_string": "    public static String redact(SocketAddress addr)\n    {\n        if (addr instanceof InetSocketAddress && AgentConfig.config.getRedactRemoteAddresses())\n        {\n            InetSocketAddress iaddr = (InetSocketAddress)addr;\n            return toRedactedString(iaddr.getAddress()) + \":\" + iaddr.getPort();\n        }\n        else if (addr == null)\n        {\n            return null;\n        }\n        else\n        {\n            return addr.toString();\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/TransportAddress.java", "class_name": "TransportAddress", "class_uri": "src/main/java/org/ice4j/TransportAddress.java.TransportAddress", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "String", "classes": []}, "docstring": ""}, {"uris": "src/main/java/org/ice4j/TransportAddress.java.TransportAddress.[String]toRedactedString(InetAddress)", "name": "toRedactedString", "arg_nums": 1, "params": [{"name": "addr", "type": "InetAddress"}], "return_type": "String", "signature": "public static String toRedactedString(InetAddress addr)", "original_string": "    public static String toRedactedString(InetAddress addr)\n    {\n        if (addr == null)\n        {\n            return null;\n        }\n        if (addr.isAnyLocalAddress() || addr.isLoopbackAddress())\n        {\n            return addr.getHostAddress();\n        }\n        if (addr instanceof Inet6Address)\n        {\n            StringBuilder sb = new StringBuilder();\n            byte[] addrBytes = addr.getAddress();\n            if ((addrBytes[0] & 0xe0) == 0x20)\n            {\n                /* Globally-routable IPv6 address; the second nybble can indicate the\n                 * RIR that allocated the address, so don't print it.\n                 */\n                sb.append(\"2xxx\");\n            }\n            else if (addrBytes[0] != 0 || addrBytes[1] != 0)\n            {\n                /* Other IPv6 address; most common will be fc00:: unique-local and fe80:: link-local address where the\n                 * first 16 bits don't leak anything but the type; all others indicate something unexpected.\n                 */\n                sb.append(Integer.toHexString(((addrBytes[0]<<8) & 0xff00)\n                        | (addrBytes[1] & 0xff)));\n            }\n            sb.append(\"::xxx\");\n            return sb.toString();\n        }\n        else if (addr instanceof Inet4Address)\n        {\n            return \"xx.xx.xx.xx\";\n        }\n        else\n        {\n            return addr.getHostAddress();\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/TransportAddress.java", "class_name": "TransportAddress", "class_uri": "src/main/java/org/ice4j/TransportAddress.java.TransportAddress", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturn a redacted form of an InetAddress, in a form preserving its IP address family\nand (for IPv6) its highest-level bytes.\n"}, {"uris": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Request]createBindingRequest()", "name": "createBindingRequest", "arg_nums": 0, "params": [], "return_type": "Request", "signature": "public static Request createBindingRequest()", "original_string": "    public static Request createBindingRequest()\n    {\n        Request bindingRequest = new Request();\n        try\n        {\n            bindingRequest.setMessageType(Message.BINDING_REQUEST);\n        }\n        catch (IllegalArgumentException ex)\n        {\n            // there should be no exc here since we're the creators.\n            logger.log(Level.FINE, \"Failed to set message type.\", ex);\n        }\n\n        /* do not add this by default */\n        /*\n         * //add a change request attribute ChangeRequestAttribute attribute =\n         * AttributeFactory.createChangeRequestAttribute();\n         *\n         * try { bindingRequest.putAttribute(attribute); } catch (StunException\n         * ex) { //shouldn't happen throw new\n         * RuntimeException(\"Failed to add a change request \"\n         * +\"attribute to a binding request!\"); }\n         */\n        return bindingRequest;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/MessageFactory.java", "class_name": "MessageFactory", "class_uri": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Request", "classes": []}, "docstring": "\nCreates a default binding request. The request DOES NOT contains a\nChangeRequest attribute with zero change ip and change port flags.\n\n@return a default binding request.\n"}, {"uris": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Request]createBindingRequest(long)", "name": "createBindingRequest", "arg_nums": 1, "params": [{"name": "priority", "type": "long"}], "return_type": "Request", "signature": "public static Request createBindingRequest(long priority)", "original_string": "    public static Request createBindingRequest(long priority)\n                    throws StunException\n    {\n        Request bindingRequest = createBindingRequest();\n\n        PriorityAttribute attribute = AttributeFactory\n                        .createPriorityAttribute(priority);\n        bindingRequest.putAttribute(attribute);\n\n        return bindingRequest;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/MessageFactory.java", "class_name": "MessageFactory", "class_uri": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Request", "classes": []}, "docstring": "\nCreates a default binding request. The request contains a ChangeReqeust\nattribute with zero change ip and change port flags. It also contains the\nPRIORITY attribute used for ICE processing\n\n@param priority the value for the priority attribute\n@return a BindingRequest header with ICE PRIORITY attribute\n@throws StunException if we have a problem creating the request\n"}, {"uris": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Request]createBindingRequest(long,boolean,long)", "name": "createBindingRequest", "arg_nums": 3, "params": [{"name": "priority", "type": "long"}, {"name": "controlling", "type": "boolean"}, {"name": "tieBreaker", "type": "long"}], "return_type": "Request", "signature": "public static Request createBindingRequest(long priority,\n                    boolean controlling, long tieBreaker)", "original_string": "    public static Request createBindingRequest(long priority,\n                    boolean controlling, long tieBreaker)\n                    throws StunException\n    {\n        Request bindingRequest = createBindingRequest();\n\n        PriorityAttribute attribute = AttributeFactory\n                        .createPriorityAttribute(priority);\n        bindingRequest.putAttribute(attribute);\n\n        if (controlling)\n        {\n            IceControllingAttribute iceControllingAttribute = AttributeFactory\n                            .createIceControllingAttribute(tieBreaker);\n            bindingRequest.putAttribute(iceControllingAttribute);\n        }\n        else\n        {\n            IceControlledAttribute iceControlledAttribute = AttributeFactory\n                            .createIceControlledAttribute(tieBreaker);\n            bindingRequest.putAttribute(iceControlledAttribute);\n        }\n\n        return bindingRequest;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/MessageFactory.java", "class_name": "MessageFactory", "class_uri": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Request", "classes": []}, "docstring": "\nCreates a default binding request. The request contains a ChangeReqeust\nattribute with zero change ip and change port flags. It contains the\nPRIORITY, ICE-CONTROLLED or ICE-CONTROLLING attributes used for ICE\nprocessing\n\n@param priority the value of the ICE priority attributes\n@param controlling the value of the controlling attribute\n@param tieBreaker the value of the ICE tie breaker attribute\n@return a BindingRequest header with some ICE attributes (PRIORITY,\nICE-CONTROLLING / ICE-CONTROLLED)\n@throws StunException if we have a problem creating the request\n"}, {"uris": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Response]create3489BindingResponse(TransportAddress,TransportAddress,TransportAddress)", "name": "create3489BindingResponse", "arg_nums": 3, "params": [{"name": "mappedAddress", "type": "TransportAddress"}, {"name": "sourceAddress", "type": "TransportAddress"}, {"name": "changedAddress", "type": "TransportAddress"}], "return_type": "Response", "signature": "public static Response create3489BindingResponse(\n                    TransportAddress mappedAddress,\n                    TransportAddress sourceAddress,\n                    TransportAddress changedAddress)", "original_string": "    public static Response create3489BindingResponse(\n                    TransportAddress mappedAddress,\n                    TransportAddress sourceAddress,\n                    TransportAddress changedAddress)\n                    throws IllegalArgumentException\n    {\n        Response bindingResponse = new Response();\n        bindingResponse.setMessageType(Message.BINDING_SUCCESS_RESPONSE);\n\n        // mapped address\n        MappedAddressAttribute mappedAddressAttribute = AttributeFactory\n                        .createMappedAddressAttribute(mappedAddress);\n\n        // the changed address and source address attribute were removed in\n        // RFC 5389 so we should be prepared to go without them.\n\n        // source address\n        SourceAddressAttribute sourceAddressAttribute = null;\n\n        if (sourceAddress != null)\n            sourceAddressAttribute = AttributeFactory\n                            .createSourceAddressAttribute(sourceAddress);\n\n        // changed address\n        ChangedAddressAttribute changedAddressAttribute = null;\n\n        if (changedAddress != null)\n            changedAddressAttribute = AttributeFactory\n                            .createChangedAddressAttribute(changedAddress);\n\n        bindingResponse.putAttribute(mappedAddressAttribute);\n\n        // the changed address and source address attribute were removed in\n        // RFC 5389 so we should be prepared to go without them.\n\n        if (sourceAddressAttribute != null)\n            bindingResponse.putAttribute(sourceAddressAttribute);\n\n        if (changedAddressAttribute != null)\n            bindingResponse.putAttribute(changedAddressAttribute);\n\n        return bindingResponse;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/MessageFactory.java", "class_name": "MessageFactory", "class_uri": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Response", "classes": []}, "docstring": "\nCreates a BindingResponse in a 3489 compliant manner, assigning the\nspecified values to mandatory headers.\n\n@param mappedAddress the address to assign the mappedAddressAttribute\n@param sourceAddress the address to assign the sourceAddressAttribute\n@param changedAddress the address to assign the changedAddressAttribute\n@return a BindingResponse assigning the specified values to mandatory\nheaders.\n@throws IllegalArgumentException if there was something wrong with the\nway we are trying to create the response.\n"}, {"uris": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Response]createBindingResponse(Request,TransportAddress)", "name": "createBindingResponse", "arg_nums": 2, "params": [{"name": "request", "type": "Request"}, {"name": "mappedAddress", "type": "TransportAddress"}], "return_type": "Response", "signature": "public static Response createBindingResponse(Request request,\n                    TransportAddress mappedAddress)", "original_string": "    public static Response createBindingResponse(Request request,\n                    TransportAddress mappedAddress)\n                    throws IllegalArgumentException\n    {\n        Response bindingResponse = new Response();\n        bindingResponse.setMessageType(Message.BINDING_SUCCESS_RESPONSE);\n\n        // xor mapped address\n        XorMappedAddressAttribute xorMappedAddressAttribute = AttributeFactory\n                        .createXorMappedAddressAttribute(mappedAddress,\n                                        request.getTransactionID());\n\n        bindingResponse.putAttribute(xorMappedAddressAttribute);\n\n        return bindingResponse;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/MessageFactory.java", "class_name": "MessageFactory", "class_uri": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Response", "classes": []}, "docstring": "\nCreates a BindingResponse in a 5389 compliant manner containing a single\n<tt>XOR-MAPPED-ADDRESS</tt> attribute\n\n@param request the request that created the transaction that this\nresponse will belong to.\n@param mappedAddress the address to assign the mappedAddressAttribute\n@return a BindingResponse assigning the specified values to mandatory\nheaders.\n@throws IllegalArgumentException if there was something wrong with the\nway we are trying to create the response.\n"}, {"uris": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Response]createBindingErrorResponse(char,String,char[])", "name": "createBindingErrorResponse", "arg_nums": 3, "params": [{"name": "errorCode", "type": "char"}, {"name": "reasonPhrase", "type": "String"}, {"name": "unknownAttributes", "type": "char[]"}], "return_type": "Response", "signature": "public static Response createBindingErrorResponse(char errorCode,\n                    String reasonPhrase, char[] unknownAttributes)", "original_string": "    public static Response createBindingErrorResponse(char errorCode,\n                    String reasonPhrase, char[] unknownAttributes)\n        throws IllegalArgumentException\n    {\n        Response bindingErrorResponse = new Response();\n        bindingErrorResponse.setMessageType(Message.BINDING_ERROR_RESPONSE);\n\n        // init attributes\n        UnknownAttributesAttribute unknownAttributesAttribute = null;\n        ErrorCodeAttribute errorCodeAttribute = AttributeFactory\n                        .createErrorCodeAttribute(errorCode,\n                                        reasonPhrase);\n\n        bindingErrorResponse.putAttribute(errorCodeAttribute);\n\n        if (unknownAttributes != null)\n        {\n            unknownAttributesAttribute = AttributeFactory\n                            .createUnknownAttributesAttribute();\n            for (int i = 0; i < unknownAttributes.length; i++)\n            {\n                unknownAttributesAttribute\n                                .addAttributeID(unknownAttributes[i]);\n            }\n            bindingErrorResponse\n                            .putAttribute(unknownAttributesAttribute);\n        }\n\n        return bindingErrorResponse;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/MessageFactory.java", "class_name": "MessageFactory", "class_uri": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Response", "classes": []}, "docstring": "\nCreates a binding error response according to the specified error code\nand unknown attributes.\n\n@param errorCode the error code to encapsulate in this message\n@param reasonPhrase a human readable description of the error\n@param unknownAttributes a char[] array containing the ids of one or more\nattributes that had not been recognized.\n@throws IllegalArgumentException INVALID_ARGUMENTS if one or more of the\ngiven parameters had an invalid value.\n\n@return a binding error response message containing an error code and a\nUNKNOWN-ATTRIBUTES header\n"}, {"uris": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Response]createBindingErrorResponseUnknownAttributes(char[])", "name": "createBindingErrorResponseUnknownAttributes", "arg_nums": 1, "params": [{"name": "unknownAttributes", "type": "char[]"}], "return_type": "Response", "signature": "public static Response createBindingErrorResponseUnknownAttributes(\n                    char[] unknownAttributes)", "original_string": "    public static Response createBindingErrorResponseUnknownAttributes(\n                    char[] unknownAttributes) throws StunException\n    {\n        return createBindingErrorResponse(\n                        ErrorCodeAttribute.UNKNOWN_ATTRIBUTE, null,\n                        unknownAttributes);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/MessageFactory.java", "class_name": "MessageFactory", "class_uri": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Response", "classes": []}, "docstring": "\nCreates a binding error response with UNKNOWN_ATTRIBUTES error code and\nthe specified unknown attributes.\n\n@param unknownAttributes a char[] array containing the ids of one or more\nattributes that had not been recognized.\n@throws StunException INVALID_ARGUMENTS if one or more of the given\nparameters had an invalid value.\n@return a binding error response message containing an error code and a\nUNKNOWN-ATTRIBUTES header\n"}, {"uris": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Response]createBindingErrorResponseUnknownAttributes(String,char[])", "name": "createBindingErrorResponseUnknownAttributes", "arg_nums": 2, "params": [{"name": "reasonPhrase", "type": "String"}, {"name": "unknownAttributes", "type": "char[]"}], "return_type": "Response", "signature": "public static Response createBindingErrorResponseUnknownAttributes(\n                    String reasonPhrase, char[] unknownAttributes)", "original_string": "    public static Response createBindingErrorResponseUnknownAttributes(\n                    String reasonPhrase, char[] unknownAttributes)\n                    throws StunException\n    {\n        return createBindingErrorResponse(\n                        ErrorCodeAttribute.UNKNOWN_ATTRIBUTE,\n                        reasonPhrase, unknownAttributes);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/MessageFactory.java", "class_name": "MessageFactory", "class_uri": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Response", "classes": []}, "docstring": "\nCreates a binding error response with UNKNOWN_ATTRIBUTES error code and\nthe specified unknown attributes and reason phrase.\n\n@param reasonPhrase a short description of the error.\n@param unknownAttributes a char[] array containing the ids of one or more\nattributes that had not been recognized.\n@throws StunException INVALID_ARGUMENTS if one or more of the given\nparameters had an invalid value.\n@return a binding error response message containing an error code and a\nUNKNOWN-ATTRIBUTES header\n"}, {"uris": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Response]createBindingErrorResponse(char,String)", "name": "createBindingErrorResponse", "arg_nums": 2, "params": [{"name": "errorCode", "type": "char"}, {"name": "reasonPhrase", "type": "String"}], "return_type": "Response", "signature": "public static Response createBindingErrorResponse(char errorCode,\n                    String reasonPhrase)", "original_string": "    public static Response createBindingErrorResponse(char errorCode,\n                    String reasonPhrase)\n    {\n        return createBindingErrorResponse(errorCode, reasonPhrase, null);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/MessageFactory.java", "class_name": "MessageFactory", "class_uri": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Response", "classes": []}, "docstring": "\nCreates a binding error response with an ERROR-CODE attribute.\n\n@param errorCode the error code to encapsulate in this message\n@param reasonPhrase a human readable description of the error.\n\n@return a binding error response message containing an error code and a\nUNKNOWN-ATTRIBUTES header\n"}, {"uris": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Response]createBindingErrorResponse(char)", "name": "createBindingErrorResponse", "arg_nums": 1, "params": [{"name": "errorCode", "type": "char"}], "return_type": "Response", "signature": "public static Response createBindingErrorResponse(char errorCode)", "original_string": "    public static Response createBindingErrorResponse(char errorCode)\n    {\n        return createBindingErrorResponse(errorCode, null, null);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/MessageFactory.java", "class_name": "MessageFactory", "class_uri": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Response", "classes": []}, "docstring": "\nCreates a binding error response according to the specified error code.\n\n@param errorCode the error code to encapsulate in this message attributes\nthat had not been recognized.\n\n@return a binding error response message containing an error code and a\nUNKNOWN-ATTRIBUTES header\n"}, {"uris": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Indication]createBindingIndication()", "name": "createBindingIndication", "arg_nums": 0, "params": [], "return_type": "Indication", "signature": "public static Indication createBindingIndication()", "original_string": "    public static Indication createBindingIndication()\n    {\n        Indication bindingIndication = new Indication();\n\n        bindingIndication.setMessageType(Message.BINDING_INDICATION);\n        return bindingIndication;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/MessageFactory.java", "class_name": "MessageFactory", "class_uri": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Indication", "classes": []}, "docstring": "\nCreates a default binding indication.\n\n@return a default binding indication.\n"}, {"uris": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Request]createAllocateRequest()", "name": "createAllocateRequest", "arg_nums": 0, "params": [], "return_type": "Request", "signature": "public static Request createAllocateRequest()", "original_string": "    public static Request createAllocateRequest()\n    {\n        Request allocateRequest = new Request();\n\n        try\n        {\n            allocateRequest.setMessageType(Message.ALLOCATE_REQUEST);\n        }\n        catch (IllegalArgumentException ex)\n        {\n            // there should be no exc here since we're the creators.\n            logger.log(Level.FINE, \"Failed to set message type.\", ex);\n        }\n        return allocateRequest;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/MessageFactory.java", "class_name": "MessageFactory", "class_uri": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Request", "classes": []}, "docstring": "\nCreate an allocate request without attribute.\n\n@return an allocate request\n"}, {"uris": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Request]createAllocateRequest(byte,boolean)", "name": "createAllocateRequest", "arg_nums": 2, "params": [{"name": "protocol", "type": "byte"}, {"name": "rFlag", "type": "boolean"}], "return_type": "Request", "signature": "public static Request createAllocateRequest(byte protocol,\n                    boolean rFlag)", "original_string": "    public static Request createAllocateRequest(byte protocol,\n                    boolean rFlag)\n    {\n        Request allocateRequest = new Request();\n\n        try\n        {\n            allocateRequest.setMessageType(Message.ALLOCATE_REQUEST);\n\n            /* XXX add enum somewhere for transport number */\n            if (protocol != 6 && protocol != 17)\n                throw new StunException(\"Protocol not valid!\");\n\n            // REQUESTED-TRANSPORT\n            allocateRequest.putAttribute(\n                    AttributeFactory.createRequestedTransportAttribute(\n                            protocol));\n\n            // EVEN-PORT\n            if (rFlag)\n            {\n                allocateRequest.putAttribute(\n                        AttributeFactory.createEvenPortAttribute(rFlag));\n            }\n        }\n        catch (StunException ex)\n        {\n            logger.log(Level.FINE, \"Failed to set message type.\", ex);\n        }\n        return allocateRequest;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/MessageFactory.java", "class_name": "MessageFactory", "class_uri": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Request", "classes": []}, "docstring": "\nCreate an allocate request to allocate an even port. Attention this does\nnot have attributes for long-term authentication.\n\n@param protocol requested protocol number\n@param rFlag R flag for the EVEN-PORT\n@return an allocation request\n"}, {"uris": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Response]createAllocationResponse(Request,TransportAddress,TransportAddress,int)", "name": "createAllocationResponse", "arg_nums": 4, "params": [{"name": "request", "type": "Request"}, {"name": "mappedAddress", "type": "TransportAddress"}, {"name": "relayedAddress", "type": "TransportAddress"}, {"name": "lifetime", "type": "int"}], "return_type": "Response", "signature": "public static Response createAllocationResponse(\n            Request request,\n            TransportAddress mappedAddress,\n            TransportAddress relayedAddress,\n            int lifetime )", "original_string": "    public static Response createAllocationResponse(\n            Request request,\n            TransportAddress mappedAddress,\n            TransportAddress relayedAddress,\n            int lifetime )\n        throws IllegalArgumentException\n    {\n        return createAllocationResponse(\n            request, mappedAddress, relayedAddress, null , lifetime);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/MessageFactory.java", "class_name": "MessageFactory", "class_uri": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Response", "classes": []}, "docstring": "\nCreates a AllocationResponse in a 5389 compliant manner containing at\nmost 4 attributes\n<br><tt>XOR-RELAYED-ADDRESS</tt> attribute\n<br><tt>LIFETIME</tt> attribute\n<br><tt>XOR-MAPPED-ADDRESS</tt> attribute\n\n@param request the request that created the transaction that this\nresponse will belong to.\n@param mappedAddress the address to assign the mappedAddressAttribute\n@param relayedAddress the address to assign the relayedAddressAttribute\n@param lifetime the address to assign the lifetimeAttribute\n@return a AllocationResponse assigning the specified values to mandatory\nheaders.\n@throws IllegalArgumentException if there was something wrong with the\nway we are trying to create the response.\n"}, {"uris": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Response]createAllocationResponse(Request,TransportAddress,TransportAddress,byte[],int)", "name": "createAllocationResponse", "arg_nums": 5, "params": [{"name": "request", "type": "Request"}, {"name": "mappedAddress", "type": "TransportAddress"}, {"name": "relayedAddress", "type": "TransportAddress"}, {"name": "token", "type": "byte[]"}, {"name": "lifetime", "type": "int"}], "return_type": "Response", "signature": "public static Response createAllocationResponse(\n            Request request,\n            TransportAddress mappedAddress,\n            TransportAddress relayedAddress,\n            byte[] token,\n            int lifetime)", "original_string": "    public static Response createAllocationResponse(\n            Request request,\n            TransportAddress mappedAddress,\n            TransportAddress relayedAddress,\n            byte[] token,\n            int lifetime)\n        throws IllegalArgumentException\n    {\n        Response allocationSuccessResponse = new Response();\n\n        allocationSuccessResponse.setMessageType(Message.ALLOCATE_RESPONSE);\n\n        // xor mapped address\n        XorMappedAddressAttribute xorMappedAddressAttribute\n            = AttributeFactory\n                .createXorMappedAddressAttribute(\n                        mappedAddress, request.getTransactionID());\n\n        allocationSuccessResponse.putAttribute(xorMappedAddressAttribute);\n\n        //xor relayed address\n        XorRelayedAddressAttribute xorRelayedAddressAttribute\n            = AttributeFactory\n                .createXorRelayedAddressAttribute(relayedAddress,\n                        request.getTransactionID());\n\n        allocationSuccessResponse.putAttribute(xorRelayedAddressAttribute);\n\n        //lifetime\n        LifetimeAttribute lifetimeAttribute\n            = AttributeFactory.createLifetimeAttribute(lifetime);\n\n        allocationSuccessResponse.putAttribute(lifetimeAttribute);\n        \n        if (token != null)\n        {\n            //reservation token\n            ReservationTokenAttribute reservationTokenAttribute\n                = AttributeFactory\n                    .createReservationTokenAttribute(token);\n\n            allocationSuccessResponse.putAttribute(reservationTokenAttribute);\n        }\n        \n        return allocationSuccessResponse;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/MessageFactory.java", "class_name": "MessageFactory", "class_uri": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Response", "classes": []}, "docstring": "\nCreates a AllocationResponse in a 5389 compliant manner containing at most 4 attributes\n<br><tt>XOR-RELAYED-ADDRESS</tt> attribute\n<br><tt>LIFETIME</tt> attribute\n<br><tt>RESERVATION-TOKEN</tt> attribute\n<br><tt>XOR-MAPPED-ADDRESS</tt> attribute\n\n@param request the request that created the transaction that this\nresponse will belong to.\n@param mappedAddress the address to assign the mappedAddressAttribute\n@param relayedAddress the address to assign the relayedAddressAttribute\n@param token the address to assign the reservationTokenAttribute\n@param lifetime the address to assign the lifetimeAttribute\n@return a AllocationResponse assigning the specified values to mandatory\nheaders.\n@throws IllegalArgumentException if there was something wrong with the\nway we are trying to create the response.\n"}, {"uris": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Response]createAllocationErrorResponse(char)", "name": "createAllocationErrorResponse", "arg_nums": 1, "params": [{"name": "errorCode", "type": "char"}], "return_type": "Response", "signature": "public static Response createAllocationErrorResponse(char errorCode)", "original_string": "    public static Response createAllocationErrorResponse(char errorCode)\n    {\n        return createAllocationErrorResponse(errorCode, null);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/MessageFactory.java", "class_name": "MessageFactory", "class_uri": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Response", "classes": []}, "docstring": "\nCreates a allocation error response according to the specified error\ncode.\n\n@param errorCode the error code to encapsulate in this message attributes\nthat had not been recognised.\n\n@return a allocation error response message containing an error code.\n"}, {"uris": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Response]createAllocationErrorResponse(char,String)", "name": "createAllocationErrorResponse", "arg_nums": 2, "params": [{"name": "errorCode", "type": "char"}, {"name": "reasonPhrase", "type": "String"}], "return_type": "Response", "signature": "public static Response createAllocationErrorResponse(char errorCode,\n                        String reasonPhrase)", "original_string": "    public static Response createAllocationErrorResponse(char errorCode,\n                        String reasonPhrase)\n    {\n        Response allocationErrorResponse = new Response();\n\n        allocationErrorResponse.setMessageType(Message.ALLOCATE_ERROR_RESPONSE);\n\n        //error code attribute\n        ErrorCodeAttribute errorCodeAttribute\n            = AttributeFactory\n                .createErrorCodeAttribute(errorCode,\n                                          reasonPhrase);\n\n        allocationErrorResponse.putAttribute(errorCodeAttribute);\n\n        return allocationErrorResponse;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/MessageFactory.java", "class_name": "MessageFactory", "class_uri": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Response", "classes": []}, "docstring": "\nCreates a allocation error response according to the specified error\ncode.\n\n@param errorCode the error code to encapsulate in this message\n@param reasonPhrase a human readable description of the error\nattributes that had not been recognised.\n@throws IllegalArgumentException INVALID_ARGUMENTS if one or more of the\ngiven parameters had an invalid value.\n\n@return a allocation error response message containing an error code.\n"}, {"uris": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Request]createGoogleAllocateRequest(String)", "name": "createGoogleAllocateRequest", "arg_nums": 1, "params": [{"name": "username", "type": "String"}], "return_type": "Request", "signature": "public static Request createGoogleAllocateRequest(String username)", "original_string": "    public static Request createGoogleAllocateRequest(String username)\n    {\n        Request allocateRequest = new Request();\n        Attribute usernameAttr = AttributeFactory.createUsernameAttribute(\n                username);\n        Attribute magicCookieAttr =\n            AttributeFactory.createMagicCookieAttribute();\n\n        allocateRequest.setMessageType(Message.ALLOCATE_REQUEST);\n        // first attribute is MAGIC-COOKIE\n        allocateRequest.putAttribute(magicCookieAttr);\n        allocateRequest.putAttribute(usernameAttr);\n\n        return allocateRequest;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/MessageFactory.java", "class_name": "MessageFactory", "class_uri": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Request", "classes": []}, "docstring": "\nCreate an allocate request for a Google TURN relay (old TURN protocol\nmodified).\n\n@param username short-term username\n@return an allocation request\n"}, {"uris": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[void]addLongTermCredentialAttributes(Request,byte,byte,byte)", "name": "addLongTermCredentialAttributes", "arg_nums": 4, "params": [{"name": "request", "type": "Request"}, {"name": "username", "type": "byte"}, {"name": "realm", "type": "byte"}, {"name": "nonce", "type": "byte"}], "return_type": "void", "signature": "public static void addLongTermCredentialAttributes(\n            Request request,\n            byte username[], byte realm[], byte nonce[])", "original_string": "    public static void addLongTermCredentialAttributes(\n            Request request,\n            byte username[], byte realm[], byte nonce[])\n        throws StunException\n    {\n        UsernameAttribute usernameAttribute\n            = AttributeFactory.createUsernameAttribute(username);\n        RealmAttribute realmAttribute\n            = AttributeFactory.createRealmAttribute(realm);\n        NonceAttribute nonceAttribute\n            = AttributeFactory.createNonceAttribute(nonce);\n\n        request.putAttribute(usernameAttribute);\n        request.putAttribute(realmAttribute);\n        request.putAttribute(nonceAttribute);\n\n        // MESSAGE-INTEGRITY\n        MessageIntegrityAttribute messageIntegrityAttribute;\n\n        try\n        {\n            /*\n             * The value of USERNAME is a variable-length value. It MUST contain\n             * a UTF-8 [RFC3629] encoded sequence of less than 513 bytes, and\n             * MUST have been processed using SASLprep [RFC4013].\n             */\n            messageIntegrityAttribute\n                = AttributeFactory.createMessageIntegrityAttribute(\n                        new String(username, \"UTF-8\"));\n        }\n        catch (UnsupportedEncodingException ueex)\n        {\n            throw new StunException(\"username\", ueex);\n        }\n        request.putAttribute(messageIntegrityAttribute);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/MessageFactory.java", "class_name": "MessageFactory", "class_uri": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nAdds the <tt>Attribute</tt>s to a specific <tt>Request</tt> which support\nthe STUN long-term credential mechanism.\n<p>\n<b>Warning</b>: The MESSAGE-INTEGRITY <tt>Attribute</tt> will also be\nadded so <tt>Attribute</tt>s added afterwards will not be taken into\naccount for the calculation of the MESSAGE-INTEGRITY value. For example,\nthe FINGERPRINT <tt>Attribute</tt> may still safely be added afterwards,\nbecause it is known to appear after the MESSAGE-INTEGRITY.\n</p>\n\n@param request the <tt>Request</tt> in which the <tt>Attribute</tt>s of\nthe STUN long-term credential mechanism are to be added\n@param username the value for the USERNAME <tt>Attribute</tt> to be added\nto <tt>request</tt>\n@param realm the value for the REALM <tt>Attribute</tt> to be added to\n<tt>request</tt>\n@param nonce the value for the NONCE <tt>Attribute</tt> to be added to\n<tt>request</tt>\n\n@throws StunException if anything goes wrong while adding the\n<tt>Attribute</tt>s to <tt>request</tt> which support the STUN long-term\ncredential mechanism\n"}, {"uris": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Request]createRefreshRequest()", "name": "createRefreshRequest", "arg_nums": 0, "params": [], "return_type": "Request", "signature": "public static Request createRefreshRequest()", "original_string": "    public static Request createRefreshRequest()\n    {\n        Request refreshRequest = new Request();\n\n        try\n        {\n            refreshRequest.setMessageType(Message.REFRESH_REQUEST);\n        }\n        catch (IllegalArgumentException iaex)\n        {\n            /*\n             * We don't actually expect the exception to happen so we're\n             * ignoring it.\n             */\n            logger.log(Level.FINE, \"Failed to set message type.\", iaex);\n        }\n        return refreshRequest;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/MessageFactory.java", "class_name": "MessageFactory", "class_uri": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Request", "classes": []}, "docstring": "\nCreates a new TURN Refresh <tt>Request</tt> without any optional\nattributes such as LIFETIME.\n\n@return a new TURN Refresh <tt>Request</tt> without any optional\nattributes such as LIFETIME\n"}, {"uris": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Request]createRefreshRequest(int)", "name": "createRefreshRequest", "arg_nums": 1, "params": [{"name": "lifetime", "type": "int"}], "return_type": "Request", "signature": "public static Request createRefreshRequest(int lifetime)", "original_string": "    public static Request createRefreshRequest(int lifetime)\n    {\n        Request refreshRequest = new Request();\n\n        try\n        {\n            refreshRequest.setMessageType(Message.REFRESH_REQUEST);\n\n            /* add a LIFETIME attribute */\n            LifetimeAttribute lifetimeReq = AttributeFactory\n                            .createLifetimeAttribute(lifetime);\n            refreshRequest.putAttribute(lifetimeReq);\n        }\n        catch (IllegalArgumentException ex)\n        {\n            logger.log(Level.FINE, \"Failed to set message type.\", ex);\n        }\n\n        return refreshRequest;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/MessageFactory.java", "class_name": "MessageFactory", "class_uri": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Request", "classes": []}, "docstring": "\nCreate a refresh request.\n\n@param lifetime lifetime value\n@return refresh request\n"}, {"uris": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Response]createRefreshResponse(int)", "name": "createRefreshResponse", "arg_nums": 1, "params": [{"name": "lifetime", "type": "int"}], "return_type": "Response", "signature": "public static Response createRefreshResponse(int lifetime)", "original_string": "    public static Response createRefreshResponse(int lifetime)\n    {\n        Response refreshSuccessResponse = new Response();\n\n        try\n        {\n            refreshSuccessResponse.setMessageType(Message.REFRESH_RESPONSE);\n\n            //lifetime attribute\n            LifetimeAttribute lifetimeAttribute\n                = AttributeFactory\n                        .createLifetimeAttribute(lifetime);\n\n            refreshSuccessResponse.putAttribute(lifetimeAttribute);\n        }\n        catch(IllegalArgumentException ex)\n        {\n            logger.log(Level.FINE, \"Failed to set message type.\", ex);\n        }\n        return refreshSuccessResponse;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/MessageFactory.java", "class_name": "MessageFactory", "class_uri": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Response", "classes": []}, "docstring": "\nCreates a refresh success response with given lifetime.\n\n@param lifetime the lifetime value to be used.\n@return refresh error response including the error code attribute.\n"}, {"uris": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Response]createRefreshErrorResponse(char)", "name": "createRefreshErrorResponse", "arg_nums": 1, "params": [{"name": "errorCode", "type": "char"}], "return_type": "Response", "signature": "public static Response createRefreshErrorResponse(char errorCode)", "original_string": "    public static Response createRefreshErrorResponse(char errorCode)\n    {\n        return createRefreshErrorResponse(errorCode, null);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/MessageFactory.java", "class_name": "MessageFactory", "class_uri": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Response", "classes": []}, "docstring": "\nCreates a refresh error response\n\n@param errorCode the error code to encapsulate in this message.\n@return refresh error response including the error code attribute.\n"}, {"uris": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Response]createRefreshErrorResponse(char,String)", "name": "createRefreshErrorResponse", "arg_nums": 2, "params": [{"name": "errorCode", "type": "char"}, {"name": "reasonPhrase", "type": "String"}], "return_type": "Response", "signature": "public static Response createRefreshErrorResponse(\n            char errorCode, String reasonPhrase)", "original_string": "    public static Response createRefreshErrorResponse(\n            char errorCode, String reasonPhrase)\n    {\n        Response refreshErrorResponse = new Response();\n\n        try\n        {\n            refreshErrorResponse.setMessageType(\n                Message.REFRESH_ERROR_RESPONSE);\n\n            ErrorCodeAttribute errorCodeAttribute\n                = AttributeFactory\n                        .createErrorCodeAttribute(\n                            errorCode, reasonPhrase);\n\n            refreshErrorResponse.putAttribute(errorCodeAttribute);\n        }\n        catch(IllegalArgumentException ex)\n        {\n             logger.log(Level.FINE, \"Failed to set message type.\", ex);\n        }\n        return refreshErrorResponse;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/MessageFactory.java", "class_name": "MessageFactory", "class_uri": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Response", "classes": []}, "docstring": "\nCreates a refresh error response.\n@param errorCode the error code to encapsulate in this message.\n@param reasonPhrase a human readable description of the error.\n@return refresh error response including the error code attribute.\n"}, {"uris": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Request]createChannelBindRequest(char,TransportAddress,byte[])", "name": "createChannelBindRequest", "arg_nums": 3, "params": [{"name": "channelNumber", "type": "char"}, {"name": "peerAddress", "type": "TransportAddress"}, {"name": "tranID", "type": "byte[]"}], "return_type": "Request", "signature": "public static Request createChannelBindRequest(char channelNumber,\n                    TransportAddress peerAddress, byte[] tranID)", "original_string": "    public static Request createChannelBindRequest(char channelNumber,\n                    TransportAddress peerAddress, byte[] tranID)\n    {\n        Request channelBindRequest = new Request();\n\n        try\n        {\n            channelBindRequest\n                            .setMessageType(Message.CHANNELBIND_REQUEST);\n\n            // add a CHANNEL-NUMBER attribute\n            ChannelNumberAttribute channelNumberAttribute = AttributeFactory\n                            .createChannelNumberAttribute(channelNumber);\n            channelBindRequest.putAttribute(channelNumberAttribute);\n\n            // add a XOR-PEER-ADDRESS\n            XorPeerAddressAttribute peerAddressAttribute\n                = AttributeFactory\n                        .createXorPeerAddressAttribute(peerAddress, tranID);\n            channelBindRequest.putAttribute(peerAddressAttribute);\n        }\n        catch (IllegalArgumentException ex)\n        {\n            logger.log(Level.FINE, \"Failed to set message type.\", ex);\n        }\n\n        return channelBindRequest;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/MessageFactory.java", "class_name": "MessageFactory", "class_uri": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Request", "classes": []}, "docstring": "\nCreate a ChannelBind request.\n\n@param channelNumber the channel number\n@param peerAddress the peer address\n@param tranID the ID of the transaction that we should be using\n\n@return channel bind request\n"}, {"uris": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Response]createChannelBindResponse()", "name": "createChannelBindResponse", "arg_nums": 0, "params": [], "return_type": "Response", "signature": "public static Response createChannelBindResponse()", "original_string": "    public static Response createChannelBindResponse()\n    {\n        Response channelBindSuccessResponse = new Response();\n\n        channelBindSuccessResponse.setMessageType(\n            Message.CHANNELBIND_RESPONSE);\n\n        return channelBindSuccessResponse;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/MessageFactory.java", "class_name": "MessageFactory", "class_uri": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Response", "classes": []}, "docstring": "\nCreates a Channel Bind Success Response.\n@return Channel Bind Success Response.\n"}, {"uris": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Response]createChannelBindErrorResponse(char)", "name": "createChannelBindErrorResponse", "arg_nums": 1, "params": [{"name": "errorCode", "type": "char"}], "return_type": "Response", "signature": "public static Response createChannelBindErrorResponse(char errorCode)", "original_string": "    public static Response createChannelBindErrorResponse(char errorCode)\n    {\n        return createChannelBindErrorResponse(errorCode, null);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/MessageFactory.java", "class_name": "MessageFactory", "class_uri": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Response", "classes": []}, "docstring": "\nCreates a Channel Bind Error Response with given error code.\n\n@param errorCode the error code to encapsulate in this message.\n@return Channel Bind Error Response including the error code attribute.\n"}, {"uris": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Response]createChannelBindErrorResponse(char,String)", "name": "createChannelBindErrorResponse", "arg_nums": 2, "params": [{"name": "errorCode", "type": "char"}, {"name": "reasonPhrase", "type": "String"}], "return_type": "Response", "signature": "public static Response createChannelBindErrorResponse(\n            char errorCode, String reasonPhrase)", "original_string": "    public static Response createChannelBindErrorResponse(\n            char errorCode, String reasonPhrase)\n    {\n        Response channelBindErrorResponse = new Response();\n\n        channelBindErrorResponse\n            .setMessageType(Message.CHANNELBIND_ERROR_RESPONSE);\n\n        ErrorCodeAttribute errorCodeAttribute\n            = AttributeFactory\n                .createErrorCodeAttribute(errorCode, reasonPhrase);\n\n        channelBindErrorResponse.putAttribute(errorCodeAttribute);\n\n        return channelBindErrorResponse;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/MessageFactory.java", "class_name": "MessageFactory", "class_uri": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Response", "classes": []}, "docstring": "\nCreates a Channel Bind Error Response with given error code\nand reasonPhrase.\n@param errorCode the error code to encapsulate in this message.\n@param reasonPhrase a human readable description of the error.\n@return Channel Bind Error Response including the error code attribute.\n"}, {"uris": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Request]createCreatePermissionRequest(TransportAddress,byte[])", "name": "createCreatePermissionRequest", "arg_nums": 2, "params": [{"name": "peerAddress", "type": "TransportAddress"}, {"name": "transactionID", "type": "byte[]"}], "return_type": "Request", "signature": "public static Request createCreatePermissionRequest(\n            TransportAddress peerAddress,\n            byte[] transactionID)", "original_string": "    public static Request createCreatePermissionRequest(\n            TransportAddress peerAddress,\n            byte[] transactionID)\n    {\n        Request createPermissionRequest = new Request();\n\n        try\n        {\n            createPermissionRequest.setMessageType(\n                    Message.CREATEPERMISSION_REQUEST);\n        }\n        catch (IllegalArgumentException iaex)\n        {\n            // Expected to not happen because we are the creators.\n            logger.log(Level.FINE, \"Failed to set message type.\", iaex);\n        }\n        createPermissionRequest.putAttribute(\n                AttributeFactory.createXorPeerAddressAttribute(\n                        peerAddress,\n                        transactionID));\n        return createPermissionRequest;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/MessageFactory.java", "class_name": "MessageFactory", "class_uri": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Request", "classes": []}, "docstring": "\nCreates a new TURN CreatePermission <tt>Request</tt> with a specific\nvalue for its XOR-PEER-ADDRESS attribute.\n\n@param peerAddress the value to assigned to the XOR-PEER-ADDRESS\nattribute\n@param transactionID the ID of the transaction which is to be used for\nthe assignment of <tt>peerAddress</tt> to the XOR-PEER-ADDRESS attribute\n@return a new TURN CreatePermission <tt>Request</tt> with the specified\nvalue for its XOR-PEER-ADDRESS attribute\n"}, {"uris": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Response]createCreatePermissionResponse()", "name": "createCreatePermissionResponse", "arg_nums": 0, "params": [], "return_type": "Response", "signature": "public static Response createCreatePermissionResponse()", "original_string": "    public static Response createCreatePermissionResponse()\n    {\n        Response permissionSuccessResponse = new Response();\n\n        permissionSuccessResponse.setMessageType(\n            Message.CREATEPERMISSION_RESPONSE);\n\n        return permissionSuccessResponse;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/MessageFactory.java", "class_name": "MessageFactory", "class_uri": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Response", "classes": []}, "docstring": "\nCreates a create permission success response.\n\n@return CreatePermission Response \n"}, {"uris": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Response]createCreatePermissionErrorResponse(char)", "name": "createCreatePermissionErrorResponse", "arg_nums": 1, "params": [{"name": "errorCode", "type": "char"}], "return_type": "Response", "signature": "public static Response createCreatePermissionErrorResponse(char errorCode)", "original_string": "    public static Response createCreatePermissionErrorResponse(char errorCode)\n    {\n        return createPermissionErrorResponse(\n            errorCode, null);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/MessageFactory.java", "class_name": "MessageFactory", "class_uri": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Response", "classes": []}, "docstring": "\nCreates a create permission error response.\n\n@param errorCode the error code to encapsulate in this message.\n@return CreatePermission Error Response with error code attribute.\n"}, {"uris": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Response]createPermissionErrorResponse(char,String)", "name": "createPermissionErrorResponse", "arg_nums": 2, "params": [{"name": "errorCode", "type": "char"}, {"name": "reasonPhrase", "type": "String"}], "return_type": "Response", "signature": "public static Response createPermissionErrorResponse(\n            char errorCode, String reasonPhrase)", "original_string": "    public static Response createPermissionErrorResponse(\n            char errorCode, String reasonPhrase)\n    {\n        Response createPermissionErrorResponse = new Response();\n\n        createPermissionErrorResponse.setMessageType(\n            Message.CREATEPERMISSION_ERROR_RESPONSE);\n\n        ErrorCodeAttribute errorCodeAttribute\n            = AttributeFactory\n                .createErrorCodeAttribute(\n                        errorCode, reasonPhrase);\n\n        createPermissionErrorResponse.putAttribute(errorCodeAttribute);\n\n        return createPermissionErrorResponse;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/MessageFactory.java", "class_name": "MessageFactory", "class_uri": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Response", "classes": []}, "docstring": "\nCreates a create permission error response.\n\n@param errorCode the error code to encapsulate in this message.\n@param reasonPhrase a human readable description of the error.\n@return CreatePermission Error Response with error code attribute.\n"}, {"uris": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Indication]createSendIndication(TransportAddress,byte[],byte[])", "name": "createSendIndication", "arg_nums": 3, "params": [{"name": "peerAddress", "type": "TransportAddress"}, {"name": "data", "type": "byte[]"}, {"name": "tranID", "type": "byte[]"}], "return_type": "Indication", "signature": "public static Indication createSendIndication(\n                    TransportAddress peerAddress, byte[] data, byte[] tranID)", "original_string": "    public static Indication createSendIndication(\n                    TransportAddress peerAddress, byte[] data, byte[] tranID)\n    {\n        Indication sendIndication = new Indication();\n\n        try\n        {\n            sendIndication.setMessageType(Message.SEND_INDICATION);\n\n            /* add XOR-PEER-ADDRESS attribute */\n            XorPeerAddressAttribute peerAddressAttribute = AttributeFactory\n                            .createXorPeerAddressAttribute(peerAddress, tranID);\n            sendIndication.putAttribute(peerAddressAttribute);\n\n            /* add DATA if data */\n            if (data != null && data.length > 0)\n            {\n                DataAttribute dataAttribute = AttributeFactory\n                                .createDataAttribute(data);\n                sendIndication.putAttribute(dataAttribute);\n            }\n        }\n        catch (IllegalArgumentException ex)\n        {\n            logger.log(Level.FINE, \"Failed to set message type.\", ex);\n        }\n\n        return sendIndication;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/MessageFactory.java", "class_name": "MessageFactory", "class_uri": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Indication", "classes": []}, "docstring": "\nCreate a Send Indication.\n\n@param peerAddress peer address\n@param data data (could be 0 byte)\n@param tranID the ID of the transaction that we should be using\n\n@return send indication message\n"}, {"uris": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Indication]createDataIndication(TransportAddress,byte[],byte[])", "name": "createDataIndication", "arg_nums": 3, "params": [{"name": "peerAddress", "type": "TransportAddress"}, {"name": "data", "type": "byte[]"}, {"name": "tranID", "type": "byte[]"}], "return_type": "Indication", "signature": "public static Indication createDataIndication(\n            TransportAddress peerAddress, byte[] data, byte[] tranID)", "original_string": "    public static Indication createDataIndication(\n            TransportAddress peerAddress, byte[] data, byte[] tranID)\n    {\n        Indication dataIndication = new Indication();\n\n        try\n        {\n            dataIndication.setMessageType(Message.DATA_INDICATION);\n\n            /* add XOR-PEER-ADDRESS attribute */\n            XorPeerAddressAttribute peerAddressAttribute\n                = AttributeFactory\n                        .createXorPeerAddressAttribute(peerAddress, tranID);\n            dataIndication.putAttribute(peerAddressAttribute);\n\n            /* add DATA if data */\n            if (data != null && data.length > 0)\n            {\n                DataAttribute dataAttribute\n                    = AttributeFactory\n                            .createDataAttribute(data);\n                dataIndication.putAttribute(dataAttribute);\n            }\n        }\n        catch (IllegalArgumentException ex)\n        {\n            logger.log(Level.FINE, \"Failed to set message type.\", ex);\n        }\n\n        return dataIndication;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/MessageFactory.java", "class_name": "MessageFactory", "class_uri": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Indication", "classes": []}, "docstring": "\nCreate a Data Indication.\n\n@param peerAddress peer address\n@param data data (could be 0 byte)\n@param tranID the ID of the transaction that we should be using\n\n@return data indication message\n"}, {"uris": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Request]createSendRequest(String,TransportAddress,byte[])", "name": "createSendRequest", "arg_nums": 3, "params": [{"name": "username", "type": "String"}, {"name": "peerAddress", "type": "TransportAddress"}, {"name": "data", "type": "byte[]"}], "return_type": "Request", "signature": "public static Request createSendRequest(\n                    String username, TransportAddress peerAddress, byte[] data)", "original_string": "    public static Request createSendRequest(\n                    String username, TransportAddress peerAddress, byte[] data)\n    {\n        Request sendRequest = new Request();\n\n        try\n        {\n            sendRequest.setMessageType(Message.SEND_REQUEST);\n\n            /* add MAGIC-COOKIE attribute */\n            sendRequest.putAttribute(\n                    AttributeFactory.createMagicCookieAttribute());\n\n            /* add USERNAME attribute */\n            sendRequest.putAttribute(\n                    AttributeFactory.createUsernameAttribute(username));\n\n            /* add DESTINATION-ADDRESS attribute */\n            DestinationAddressAttribute peerAddressAttribute = AttributeFactory\n                            .createDestinationAddressAttribute(peerAddress);\n            sendRequest.putAttribute(peerAddressAttribute);\n\n            /* add DATA if data */\n            if (data != null && data.length > 0)\n            {\n                DataAttribute dataAttribute = AttributeFactory\n                                .createDataAttributeWithoutPadding(data);\n                sendRequest.putAttribute(dataAttribute);\n            }\n        }\n        catch (IllegalArgumentException ex)\n        {\n            logger.log(Level.FINE, \"Failed to set message type.\", ex);\n        }\n\n        return sendRequest;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/MessageFactory.java", "class_name": "MessageFactory", "class_uri": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Request", "classes": []}, "docstring": "\nCreate a old Send Request.\n@param username the username\n@param peerAddress peer address\n@param data data (could be 0 byte)\n@return send indication message\n"}, {"uris": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Request]createSharedSecretRequest()", "name": "createSharedSecretRequest", "arg_nums": 0, "params": [], "return_type": "Request", "signature": "public static Request createSharedSecretRequest()", "original_string": "    public static Request createSharedSecretRequest()\n    {\n        throw new UnsupportedOperationException(\n                        \"Shared Secret Support is not currently implemented\");\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/MessageFactory.java", "class_name": "MessageFactory", "class_uri": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Request", "classes": []}, "docstring": "\nCreate a shared secret request.\nWARNING: This is not currently supported.\n\n@return request\n"}, {"uris": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Response]createSharedSecretResponse()", "name": "createSharedSecretResponse", "arg_nums": 0, "params": [], "return_type": "Response", "signature": "public static Response createSharedSecretResponse()", "original_string": "    public static Response createSharedSecretResponse()\n    {\n        throw new UnsupportedOperationException(\n                        \"Shared Secret Support is not currently implemented\");\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/MessageFactory.java", "class_name": "MessageFactory", "class_uri": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Response", "classes": []}, "docstring": "\nCreate a shared secret response.\nWARNING: This is not currently supported.\n\n@return response\n"}, {"uris": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Response]createSharedSecretErrorResponse()", "name": "createSharedSecretErrorResponse", "arg_nums": 0, "params": [], "return_type": "Response", "signature": "public static Response createSharedSecretErrorResponse()", "original_string": "    public static Response createSharedSecretErrorResponse()\n    {\n        throw new UnsupportedOperationException(\n                        \"Shared Secret Support is not currently implemented\");\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/MessageFactory.java", "class_name": "MessageFactory", "class_uri": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Response", "classes": []}, "docstring": "\nCreate a shared secret error response.\nWARNING: This is not currently supported.\n\n@return error response\n"}, {"uris": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Request]createConnectRequest(TransportAddress,Request)", "name": "createConnectRequest", "arg_nums": 2, "params": [{"name": "peerAddress", "type": "TransportAddress"}, {"name": "request", "type": "Request"}], "return_type": "Request", "signature": "public static Request createConnectRequest(\n            TransportAddress peerAddress, Request request)", "original_string": "    public static Request createConnectRequest(\n            TransportAddress peerAddress, Request request)\n        throws IllegalArgumentException\n    {\n        Request connectRequest = new Request();\n\n        connectRequest.setMessageType(Message.CONNECT_REQUEST);\n\n        //xor peer address\n        XorPeerAddressAttribute xorPeerAddressAttribute\n            = AttributeFactory\n                .createXorPeerAddressAttribute(\n                    peerAddress, request.getTransactionID());\n\n        connectRequest.putAttribute(xorPeerAddressAttribute);\n\n        return connectRequest;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/MessageFactory.java", "class_name": "MessageFactory", "class_uri": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Request", "classes": []}, "docstring": "\nCreates a ConnectRequest in a 6062 compliant manner containing only\n<br><tt>XOR-PEER-ADDRESS</tt> attribute\n\n@param request the request that created the transaction that this\nresponse will belong to.\n@param peerAddress the address to assign the xorPeerAddressAttribute\n@return a ConnectRequest assigning the specified values to mandatory\nheaders.\n@throws IllegalArgumentException if there was something wrong with the\nway we are trying to create the response.\n"}, {"uris": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Request]createConnectRequest(TransportAddress,byte[])", "name": "createConnectRequest", "arg_nums": 2, "params": [{"name": "peerAddress", "type": "TransportAddress"}, {"name": "transactionId", "type": "byte[]"}], "return_type": "Request", "signature": "public static Request createConnectRequest(TransportAddress peerAddress,\n        byte[] transactionId)", "original_string": "    public static Request createConnectRequest(TransportAddress peerAddress,\n        byte[] transactionId)\n        throws IllegalArgumentException\n    {\n        Request connectRequest = new Request();\n\n        connectRequest.setMessageType(Message.CONNECT_REQUEST);\n\n        // xor peer address\n        XorPeerAddressAttribute xorPeerAddressAttribute = AttributeFactory\n            .createXorPeerAddressAttribute(peerAddress, transactionId);\n\n        connectRequest.putAttribute(xorPeerAddressAttribute);\n\n        return connectRequest;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/MessageFactory.java", "class_name": "MessageFactory", "class_uri": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Request", "classes": []}, "docstring": "\nCreates a ConnectRequest in a 6062 compliant manner containing only\n<tt>XOR-PEER-ADDRESS</tt> attribute. This method is used by turnserver.\n\n@param peerAddress the address to assign the xorPeerAddressAttribute\n@param transactionId the transaction id that this response will belong\nto.\n@return a ConnectRequest assigning the specified values to mandatory\nheaders.\n@throws IllegalArgumentException if there was something wrong with the\nway we are trying to create the response.\n"}, {"uris": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Response]createConnectResponse(int)", "name": "createConnectResponse", "arg_nums": 1, "params": [{"name": "connectionIdValue", "type": "int"}], "return_type": "Response", "signature": "public static Response createConnectResponse(\n            int connectionIdValue)", "original_string": "    public static Response createConnectResponse(\n            int connectionIdValue)\n        throws IllegalArgumentException\n    {\n        Response connectSuccessResponse = new Response();\n\n        connectSuccessResponse.setMessageType(Message.CONNECT_RESPONSE);\n\n        //connection id\n        ConnectionIdAttribute connectionIdAttribute\n            = AttributeFactory\n                .createConnectionIdAttribute(connectionIdValue);\n\n        connectSuccessResponse.putAttribute(connectionIdAttribute);\n\n        return connectSuccessResponse;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/MessageFactory.java", "class_name": "MessageFactory", "class_uri": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Response", "classes": []}, "docstring": "\nCreates a Connect Response in a 6062 compliant manner containing a single\n<tt>CONNECTION-ID-ATTRIBUTE</tt> attribute\n@param connectionIdValue the address to assign the connectionIdAttribute\n@return a ConnectResponse assigning the specified values to mandatory\nheaders.\n@throws IllegalArgumentException if there was something wrong with the\nway we are trying to create the response.\n"}, {"uris": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Response]createConnectErrorResponse(char)", "name": "createConnectErrorResponse", "arg_nums": 1, "params": [{"name": "errorCode", "type": "char"}], "return_type": "Response", "signature": "public static Response createConnectErrorResponse(char errorCode)", "original_string": "    public static Response createConnectErrorResponse(char errorCode)\n        throws IllegalArgumentException\n    {\n        return createConnectErrorResponse(errorCode, null);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/MessageFactory.java", "class_name": "MessageFactory", "class_uri": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Response", "classes": []}, "docstring": "\nCreates a Connect error response according to the specified error code.\n\n@param errorCode the error code to encapsulate in this message\n@throws IllegalArgumentException INVALID_ARGUMENTS if one or more of the\ngiven parameters had an invalid value.\n@return a Connect error response message containing an error code.\n"}, {"uris": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Response]createConnectErrorResponse(char,String)", "name": "createConnectErrorResponse", "arg_nums": 2, "params": [{"name": "errorCode", "type": "char"}, {"name": "reasonPhrase", "type": "String"}], "return_type": "Response", "signature": "public static Response createConnectErrorResponse(\n            char  errorCode, String reasonPhrase )", "original_string": "    public static Response createConnectErrorResponse(\n            char  errorCode, String reasonPhrase )\n        throws IllegalArgumentException\n    {\n        Response connectionErrorResponse = new Response();\n\n        connectionErrorResponse.setMessageType(Message.CONNECT_ERROR_RESPONSE);\n\n        //error code attribute\n        ErrorCodeAttribute errorCodeAttribute\n            = AttributeFactory\n                .createErrorCodeAttribute(errorCode, reasonPhrase);\n\n        connectionErrorResponse.putAttribute(errorCodeAttribute);\n\n        return connectionErrorResponse;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/MessageFactory.java", "class_name": "MessageFactory", "class_uri": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Response", "classes": []}, "docstring": "\nCreates a Connect error response according to the specified error code.\n\n@param errorCode the error code to encapsulate in this message\n@param reasonPhrase a human readable description of the error\n@throws IllegalArgumentException INVALID_ARGUMENTS if one or more of the\ngiven parameters had an invalid value.\n@return a Connect error response message containing an error code.\n"}, {"uris": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Request]createConnectionBindRequest(int)", "name": "createConnectionBindRequest", "arg_nums": 1, "params": [{"name": "connectionIdValue", "type": "int"}], "return_type": "Request", "signature": "public static Request createConnectionBindRequest(int connectionIdValue)", "original_string": "    public static Request createConnectionBindRequest(int connectionIdValue)\n        throws IllegalArgumentException\n    {\n        Request connectionBindRequest = new Request();\n\n        connectionBindRequest.setMessageType(Message.CONNECTION_BIND_REQUEST);\n\n        //connection id\n        ConnectionIdAttribute connectionIdAttribute\n            = AttributeFactory\n                .createConnectionIdAttribute(connectionIdValue);\n\n        connectionBindRequest.putAttribute(connectionIdAttribute);\n\n        return connectionBindRequest;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/MessageFactory.java", "class_name": "MessageFactory", "class_uri": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Request", "classes": []}, "docstring": "\nCreates a ConnectionBindRequest in a 6062 compliant manner containing\nonly <tt>CONECTION-ID-ATTRIBUTE</tt> attribute.\n\n@param connectionIdValue the value to assign the connectionIdAtribute\n@return a ConnectionBind Request assigning the specified values\n        to mandatory headers.\n@throws IllegalArgumentException if there was something wrong with the\n        way we are trying to create the Request.\n"}, {"uris": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Response]createConnectionBindResponse()", "name": "createConnectionBindResponse", "arg_nums": 0, "params": [], "return_type": "Response", "signature": "public static Response createConnectionBindResponse()", "original_string": "    public static Response createConnectionBindResponse()\n        throws IllegalArgumentException\n    {\n        Response connectSuccessResponse = new Response();\n\n        connectSuccessResponse.setMessageType(\n            Message.CONNECTION_BIND_SUCCESS_RESPONSE);\n\n        return connectSuccessResponse;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/MessageFactory.java", "class_name": "MessageFactory", "class_uri": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Response", "classes": []}, "docstring": "\nCreates a ConnectionBind Response in a 6062 compliant manner.\n\n@return a ConnectionBind Response assigning the specified values to\n        mandatory headers.\n@throws IllegalArgumentException if there was something wrong with the\nway we are trying to create the response.\n"}, {"uris": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Response]createConnectionBindErrorResponse(char)", "name": "createConnectionBindErrorResponse", "arg_nums": 1, "params": [{"name": "errorCode", "type": "char"}], "return_type": "Response", "signature": "public static Response createConnectionBindErrorResponse(char errorCode)", "original_string": "    public static Response createConnectionBindErrorResponse(char errorCode)\n        throws IllegalArgumentException\n    {\n        return createConnectionBindErrorResponse(errorCode, null);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/MessageFactory.java", "class_name": "MessageFactory", "class_uri": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Response", "classes": []}, "docstring": "\nCreates a ConnectionBind error response according to the specified error\ncode.\n\n@param errorCode the error code to encapsulate in this message\n@throws IllegalArgumentException INVALID_ARGUMENTS if one or more of the\ngiven parameters had an invalid value.\n@return a ConnectionBind error response message containing an error code.\n"}, {"uris": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Response]createConnectionBindErrorResponse(char,String)", "name": "createConnectionBindErrorResponse", "arg_nums": 2, "params": [{"name": "errorCode", "type": "char"}, {"name": "reasonPhrase", "type": "String"}], "return_type": "Response", "signature": "public static Response createConnectionBindErrorResponse(\n            char  errorCode, String reasonPhrase)", "original_string": "    public static Response createConnectionBindErrorResponse(\n            char  errorCode, String reasonPhrase)\n        throws IllegalArgumentException\n    {\n        Response connectionBindErrorResponse = new Response();\n\n        connectionBindErrorResponse.setMessageType(\n            Message.CONNECTION_BIND_ERROR_RESPONSE);\n\n        //error code attribute\n        ErrorCodeAttribute errorCodeAttribute\n            = AttributeFactory\n                .createErrorCodeAttribute(errorCode, reasonPhrase);\n\n        connectionBindErrorResponse.putAttribute(errorCodeAttribute);\n\n        return connectionBindErrorResponse;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/MessageFactory.java", "class_name": "MessageFactory", "class_uri": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Response", "classes": []}, "docstring": "\nCreates a ConnectionBind error response according to the specified error\ncode.\n\n@param errorCode the error code to encapsulate in this message\n@param reasonPhrase a human readable description of the error\n@throws IllegalArgumentException INVALID_ARGUMENTS if one or more of the\ngiven parameters had an invalid value.\n@return a ConnectionBind error response message containing an error code.\n"}, {"uris": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Indication]createConnectionAttemptIndication(int,TransportAddress)", "name": "createConnectionAttemptIndication", "arg_nums": 2, "params": [{"name": "connectionIdValue", "type": "int"}, {"name": "peerAddress", "type": "TransportAddress"}], "return_type": "Indication", "signature": "public static Indication createConnectionAttemptIndication(\n            int connectionIdValue, TransportAddress peerAddress)", "original_string": "    public static Indication createConnectionAttemptIndication(\n            int connectionIdValue, TransportAddress peerAddress)\n        throws IllegalArgumentException\n    {\n        Indication connectionAttemptIndication = new Indication();\n\n        connectionAttemptIndication.setMessageType(\n            Message.CONNECTION_ATTEMPT_INDICATION);\n\n        //connection id attribute\n        ConnectionIdAttribute connectionIdAttribute\n            = AttributeFactory\n                .createConnectionIdAttribute(connectionIdValue);\n\n        connectionAttemptIndication.putAttribute(connectionIdAttribute);\n\n        //xor peer address attribute\n        XorPeerAddressAttribute xorPeerAddressAttribute\n            = AttributeFactory\n                .createXorPeerAddressAttribute(peerAddress,\n                    connectionAttemptIndication.getTransactionID());\n\n        connectionAttemptIndication.putAttribute(xorPeerAddressAttribute);\n\n        return connectionAttemptIndication;\n   }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/MessageFactory.java", "class_name": "MessageFactory", "class_uri": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Indication", "classes": []}, "docstring": "\nCreates a ConnectionAttempt Indication in a 6062 compliant manner\ncontaining only <tt>CONECTION-ID-ATTRIBUTE</tt> attribute and\n<tt>XOR-PPER-ADDRESS</tt> attribute.\n\n@param connectionIdValue the value to assign the connectionidAtribute\n@param peerAddress the value to assign the xorPeerAddress\n@return a ConnectionAttempt Indication assigning the specified values to\n        mandatory headers.\n@throws IllegalArgumentException if there was something wrong with the\nway we are trying to create the Request.\n"}, {"uris": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Indication]createConnectionAttemptIndication(int,TransportAddress,byte[])", "name": "createConnectionAttemptIndication", "arg_nums": 3, "params": [{"name": "connectionIdValue", "type": "int"}, {"name": "peerAddress", "type": "TransportAddress"}, {"name": "transactionId", "type": "byte[]"}], "return_type": "Indication", "signature": "public static Indication createConnectionAttemptIndication(\n        int connectionIdValue, TransportAddress peerAddress,\n        byte[] transactionId)", "original_string": "    public static Indication createConnectionAttemptIndication(\n        int connectionIdValue, TransportAddress peerAddress,\n        byte[] transactionId)\n        throws IllegalArgumentException, StunException\n    {\n        Indication connectionAttemptIndication = new Indication();\n\n        // set the attempt transaction id\n        connectionAttemptIndication.setTransactionID(transactionId);\n\n        connectionAttemptIndication.setMessageType(\n            Message.CONNECTION_ATTEMPT_INDICATION);\n\n        // connection id attribute\n        ConnectionIdAttribute connectionIdAttribute = AttributeFactory\n            .createConnectionIdAttribute(connectionIdValue);\n\n        connectionAttemptIndication.putAttribute(connectionIdAttribute);\n\n        // xor peer address attribute\n        XorPeerAddressAttribute xorPeerAddressAttribute = AttributeFactory\n            .createXorPeerAddressAttribute(peerAddress,\n            connectionAttemptIndication.getTransactionID());\n\n        connectionAttemptIndication.putAttribute(xorPeerAddressAttribute);\n\n        return connectionAttemptIndication;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/MessageFactory.java", "class_name": "MessageFactory", "class_uri": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Indication", "classes": []}, "docstring": "\nCreates a ConnectionAttempt Indication in a 6062 compliant manner\ncontaining only <tt>CONECTION-ID-ATTRIBUTE</tt> attribute and\n<tt>XOR-PPER-ADDRESS</tt> attribute.\n\n@param connectionIdValue the value to assign the connectionidAtribute\n@param peerAddress the value to assign the xorPeerAddress\n@param transactionId the transaction id that the response belongs to.\n@return a ConnectionAttempt Indication assigning the specified values to\nmandatory headers.\n@throws IllegalArgumentException if there was something wrong with the\nway we are trying to create the Request.\n@throws StunException when the transaction id is not valid.\n"}, {"uris": "src/main/java/org/ice4j/message/Indication.java.Indication.[]Indication()", "name": "Indication", "arg_nums": 0, "params": [], "return_type": "", "signature": "Indication()", "original_string": "    Indication()\n    {\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/Indication.java", "class_name": "Indication", "class_uri": "src/main/java/org/ice4j/message/Indication.java.Indication", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "docstring": "\nConstructor.\n"}, {"uris": "src/main/java/org/ice4j/message/Indication.java.Indication.[void]setMessageType(char)", "name": "setMessageType", "arg_nums": 1, "params": [{"name": "indicationType", "type": "char"}], "return_type": "void", "signature": "@Override\n    public void setMessageType(char indicationType)", "original_string": "    @Override\n    public void setMessageType(char indicationType)\n        throws IllegalArgumentException\n    {\n        /* old TURN DATA indication type is an indication despite\n         * 0x0115 & 0x0110 indicates STUN error response type\n         */\n        if (!isIndicationType(indicationType) &&\n                indicationType != OLD_DATA_INDICATION)\n            throw new IllegalArgumentException(\n                    (int)(indicationType)\n                    + \" - is not a valid indication type.\");\n\n        super.setMessageType(indicationType);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/Indication.java", "class_name": "Indication", "class_uri": "src/main/java/org/ice4j/message/Indication.java.Indication", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nChecks whether indicationType is a valid indication type and if yes sets\nit as the type of this instance.\n\n@param indicationType the type to set\n@throws IllegalArgumentException if indicationType is not a valid\nindication type\n"}, {"uris": "src/main/java/org/ice4j/message/ChannelData.java.ChannelData.[]ChannelData()", "name": "ChannelData", "arg_nums": 0, "params": [], "return_type": "", "signature": "public ChannelData()", "original_string": "    public ChannelData()\n    {\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/ChannelData.java", "class_name": "ChannelData", "class_uri": "src/main/java/org/ice4j/message/ChannelData.java.ChannelData", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nConstructor.\n"}, {"uris": "src/main/java/org/ice4j/message/ChannelData.java.ChannelData.[void]setChannelNumber(char)", "name": "setChannelNumber", "arg_nums": 1, "params": [{"name": "channelNumber", "type": "char"}], "return_type": "void", "signature": "public void setChannelNumber(char channelNumber)", "original_string": "    public void setChannelNumber(char channelNumber)\n    {\n        this.channelNumber = channelNumber;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/ChannelData.java", "class_name": "ChannelData", "class_uri": "src/main/java/org/ice4j/message/ChannelData.java.ChannelData", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSet the channel number\n@param channelNumber the channel number\n"}, {"uris": "src/main/java/org/ice4j/message/ChannelData.java.ChannelData.[char]getChannelNumber()", "name": "getChannelNumber", "arg_nums": 0, "params": [], "return_type": "char", "signature": "public char getChannelNumber()", "original_string": "    public char getChannelNumber()\n    {\n        return this.channelNumber;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/ChannelData.java", "class_name": "ChannelData", "class_uri": "src/main/java/org/ice4j/message/ChannelData.java.ChannelData", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "char", "classes": []}, "docstring": "\nGet the channel number.\n@return channel number\n"}, {"uris": "src/main/java/org/ice4j/message/ChannelData.java.ChannelData.[void]setData(byte)", "name": "setData", "arg_nums": 1, "params": [{"name": "data", "type": "byte"}], "return_type": "void", "signature": "public void setData(byte data[])", "original_string": "    public void setData(byte data[])\n    {\n        this.data = data;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/ChannelData.java", "class_name": "ChannelData", "class_uri": "src/main/java/org/ice4j/message/ChannelData.java.ChannelData", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSet the data.\n@param data the data\n"}, {"uris": "src/main/java/org/ice4j/message/ChannelData.java.ChannelData.[byte[]]getData()", "name": "getData", "arg_nums": 0, "params": [], "return_type": "byte[]", "signature": "public byte[] getData()", "original_string": "    public byte[] getData()\n    {\n        return this.data;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/ChannelData.java", "class_name": "ChannelData", "class_uri": "src/main/java/org/ice4j/message/ChannelData.java.ChannelData", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "byte[]", "classes": []}, "docstring": "\nGet the data.\n@return data\n"}, {"uris": "src/main/java/org/ice4j/message/ChannelData.java.ChannelData.[char]getDataLength()", "name": "getDataLength", "arg_nums": 0, "params": [], "return_type": "char", "signature": "public char getDataLength()", "original_string": "    public char getDataLength()\n    {\n        if (data == null)\n            return 0;\n\n        return (char)data.length;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/ChannelData.java", "class_name": "ChannelData", "class_uri": "src/main/java/org/ice4j/message/ChannelData.java.ChannelData", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "char", "classes": []}, "docstring": "\nGet the data length (without padding).\n\n@return data length\n"}, {"uris": "src/main/java/org/ice4j/message/ChannelData.java.ChannelData.[int]padTo4(int)", "name": "padTo4", "arg_nums": 1, "params": [{"name": "num", "type": "int"}], "return_type": "int", "signature": "private static int padTo4(int num)", "original_string": "    private static int padTo4(int num)\n    {\n        return (num + 3) & ~3;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/ChannelData.java", "class_name": "ChannelData", "class_uri": "src/main/java/org/ice4j/message/ChannelData.java.ChannelData", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\n@return num padded to 4\n"}, {"uris": "src/main/java/org/ice4j/message/ChannelData.java.ChannelData.[boolean]validateChannelNumber(char)", "name": "validateChannelNumber", "arg_nums": 1, "params": [{"name": "channelNumber", "type": "char"}], "return_type": "boolean", "signature": "private static boolean validateChannelNumber(char channelNumber)", "original_string": "    private static boolean validateChannelNumber(char channelNumber)\n    {\n        return (channelNumber > 0x3FFF);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/ChannelData.java", "class_name": "ChannelData", "class_uri": "src/main/java/org/ice4j/message/ChannelData.java.ChannelData", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nDetermines whether a specific channel number is in the valid channel\nnumber range defined by the TURN RFC.\n\n@param channelNumber the channel number to be checked for being in the\nvalid channel number range defined by the TURN RFC\n@return <tt>true</tt> if the specified <tt>channelNumber</tt> is in the\nvalid channel number range defined by the TURN RFC\n"}, {"uris": "src/main/java/org/ice4j/message/ChannelData.java.ChannelData.[byte[]]encode()", "name": "encode", "arg_nums": 0, "params": [], "return_type": "byte[]", "signature": "public byte[] encode()", "original_string": "    public byte[] encode() throws StunException\n    {\n        return encode(false);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/ChannelData.java", "class_name": "ChannelData", "class_uri": "src/main/java/org/ice4j/message/ChannelData.java.ChannelData", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "byte[]", "classes": []}, "docstring": "\nReturns a non padded binary representation of this message.\n@return a non padded binary representation of this message.\n@throws StunException if the channel number is invalid\n@deprecated\n"}, {"uris": "src/main/java/org/ice4j/message/ChannelData.java.ChannelData.[byte[]]encode(boolean)", "name": "encode", "arg_nums": 1, "params": [{"name": "pad", "type": "boolean"}], "return_type": "byte[]", "signature": "public byte[] encode(boolean pad)", "original_string": "    public byte[] encode(boolean pad) throws StunException\n    {\n        int dataLength = getDataLength();\n        if (pad)\n            dataLength = padTo4(dataLength);\n        byte binMsg[] = new byte[HEADER_LENGTH + dataLength];\n        int offset = 0;\n\n        if (!validateChannelNumber(channelNumber))\n        {\n            throw new StunException(StunException.ILLEGAL_ARGUMENT, \"Channel number invalid\");\n        }\n\n        /* channel number */\n        binMsg[offset++] = (byte)(channelNumber >> 8);\n        binMsg[offset++] = (byte)(channelNumber & 0xff);\n\n        /* length */\n        binMsg[offset++] = (byte)((data != null) ? data.length >> 8 : 0);\n        binMsg[offset++] = (byte)((data != null) ? data.length & 0xff : 0);\n\n        if (data != null)\n        {\n            System.arraycopy(data, 0, binMsg, offset, data.length);\n        }\n\n        return binMsg;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/ChannelData.java", "class_name": "ChannelData", "class_uri": "src/main/java/org/ice4j/message/ChannelData.java.ChannelData", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "byte[]", "classes": []}, "docstring": "\nReturns a binary representation of this message.\n@param pad determine if we pad this message\n@return a binary representation of this message.\n@throws StunException if the channel number is invalid\n"}, {"uris": "src/main/java/org/ice4j/message/ChannelData.java.ChannelData.[ChannelData]decode(byte,char,char)", "name": "decode", "arg_nums": 3, "params": [{"name": "binMessage", "type": "byte"}, {"name": "offset", "type": "char"}, {"name": "arrayLen", "type": "char"}], "return_type": "ChannelData", "signature": "public static ChannelData decode(byte binMessage[], char offset, char arrayLen)", "original_string": "    public static ChannelData decode(byte binMessage[], char offset, char arrayLen) throws StunException\n    {\n        return decode(binMessage, offset);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/ChannelData.java", "class_name": "ChannelData", "class_uri": "src/main/java/org/ice4j/message/ChannelData.java.ChannelData", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "ChannelData", "classes": []}, "docstring": "\nConstructs a message from its binary representation.\n@param binMessage the binary array that contains the encoded message\n@param offset the index where the message starts.\n@param arrayLen the length of the message\n@return a Message object constructed from the binMessage array\n@throws StunException ILLEGAL_ARGUMENT if one or more of the arguments\nhave invalid values.\n@deprecated\n"}, {"uris": "src/main/java/org/ice4j/message/ChannelData.java.ChannelData.[ChannelData]decode(byte,char)", "name": "decode", "arg_nums": 2, "params": [{"name": "binMessage", "type": "byte"}, {"name": "offset", "type": "char"}], "return_type": "ChannelData", "signature": "public static ChannelData decode(byte binMessage[], char offset)", "original_string": "    public static ChannelData decode(byte binMessage[], char offset) throws StunException\n    {\n        char msgLen = 0;\n        char channelNumber = 0;\n        ChannelData channelData = null;\n        byte data[] = null;\n\n        if ((binMessage.length - offset) < HEADER_LENGTH)\n        {\n            throw new StunException(StunException.ILLEGAL_ARGUMENT, \"Size too short\");\n        }\n\n        channelNumber = (char)((binMessage[offset++]<<8) | (binMessage[offset++]&0xFF));\n\n        if (!validateChannelNumber(channelNumber))\n        {\n            throw new StunException(StunException.ILLEGAL_ARGUMENT, \"Channel number invalid\");\n        }\n\n        msgLen = (char)((binMessage[offset++]<<8) | (binMessage[offset++]&0xFF));\n        if (msgLen > (binMessage.length - offset))\n        {\n            throw new StunException(StunException.ILLEGAL_ARGUMENT, \"Size mismatch\");\n        }\n\n        data = new byte[msgLen];\n        System.arraycopy(binMessage, offset, data, 0, msgLen);\n\n        channelData = new ChannelData();\n        channelData.setData(data);\n        channelData.setChannelNumber(channelNumber);\n\n        return channelData;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/ChannelData.java", "class_name": "ChannelData", "class_uri": "src/main/java/org/ice4j/message/ChannelData.java.ChannelData", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "ChannelData", "classes": []}, "docstring": "\nConstructs a message from its binary representation.\n@param binMessage the binary array that contains the encoded message\n@param offset the index where the message starts.\n@return a Message object constructed from the binMessage array\n@throws StunException ILLEGAL_ARGUMENT if one or more of the arguments\nhave invalid values.\n"}, {"uris": "src/main/java/org/ice4j/message/ChannelData.java.ChannelData.[boolean]isChannelDataMessage(byte[])", "name": "isChannelDataMessage", "arg_nums": 1, "params": [{"name": "binMessage", "type": "byte[]"}], "return_type": "boolean", "signature": "public static boolean isChannelDataMessage(byte[] binMessage)", "original_string": "    public static boolean isChannelDataMessage(byte[] binMessage)\n    {\n        return (binMessage[0] >> 6 == 0x1);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/ChannelData.java", "class_name": "ChannelData", "class_uri": "src/main/java/org/ice4j/message/ChannelData.java.ChannelData", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nChecks if the given binary message is a ChannelData Message. Every\nChannelData message has first two bits as 01.\n\n@param binMessage binary message to check.\n@return true is given binary message is a ChannelData Message.\n"}, {"uris": "src/main/java/org/ice4j/message/Response.java.Response.[]Response()", "name": "Response", "arg_nums": 0, "params": [], "return_type": "", "signature": "Response()", "original_string": "    Response()\n    {\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/Response.java", "class_name": "Response", "class_uri": "src/main/java/org/ice4j/message/Response.java.Response", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "docstring": "\nConstructor.\n"}, {"uris": "src/main/java/org/ice4j/message/Response.java.Response.[boolean]isErrorResponse()", "name": "isErrorResponse", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "public boolean isErrorResponse()", "original_string": "    public boolean isErrorResponse()\n    {\n        return isErrorResponseType(getMessageType());\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/Response.java", "class_name": "Response", "class_uri": "src/main/java/org/ice4j/message/Response.java.Response", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nDetermines whether this instance represents a STUN error response.\n\n@return <tt>true</tt> if this instance represents a STUN error response;\notherwise, <tt>false</tt>\n"}, {"uris": "src/main/java/org/ice4j/message/Response.java.Response.[boolean]isSuccessResponse()", "name": "isSuccessResponse", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "public boolean isSuccessResponse()", "original_string": "    public boolean isSuccessResponse()\n    {\n        return isSuccessResponseType(getMessageType());\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/Response.java", "class_name": "Response", "class_uri": "src/main/java/org/ice4j/message/Response.java.Response", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nDetermines whether this instance represents a STUN success response.\n\n@return <tt>true</tt> if this instance represents a STUN success\nresponse; otherwise, <tt>false</tt>\n"}, {"uris": "src/main/java/org/ice4j/message/Response.java.Response.[void]setMessageType(char)", "name": "setMessageType", "arg_nums": 1, "params": [{"name": "responseType", "type": "char"}], "return_type": "void", "signature": "public void setMessageType(char responseType)", "original_string": "    public void setMessageType(char responseType)\n        throws IllegalArgumentException\n    {\n        if (!isResponseType(responseType))\n            throw new IllegalArgumentException(\n                                    Integer.toString(responseType)\n                                        + \" is not a valid response type.\");\n\n\n        super.setMessageType(responseType);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/Response.java", "class_name": "Response", "class_uri": "src/main/java/org/ice4j/message/Response.java.Response", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nChecks whether responseType is a valid response type and if yes sets it\nas the type of the current instance.\n@param responseType the type to set\n@throws IllegalArgumentException if responseType is not a valid\nresponse type\n"}, {"uris": "src/main/java/org/ice4j/message/Request.java.Request.[]Request()", "name": "Request", "arg_nums": 0, "params": [], "return_type": "", "signature": "Request()", "original_string": "    Request()\n    {\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/Request.java", "class_name": "Request", "class_uri": "src/main/java/org/ice4j/message/Request.java.Request", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "docstring": "\nConstructor.\n"}, {"uris": "src/main/java/org/ice4j/message/Request.java.Request.[void]setMessageType(char)", "name": "setMessageType", "arg_nums": 1, "params": [{"name": "requestType", "type": "char"}], "return_type": "void", "signature": "public void setMessageType(char requestType)", "original_string": "    public void setMessageType(char requestType)\n        throws IllegalArgumentException\n    {\n        if (!isRequestType(requestType))\n            throw new IllegalArgumentException(\n                                    (int)(requestType)\n                                    + \" - is not a valid request type.\");\n\n\n        super.setMessageType(requestType);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/Request.java", "class_name": "Request", "class_uri": "src/main/java/org/ice4j/message/Request.java.Request", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nChecks whether requestType is a valid request type and if yes sets it\nas the type of the current instance.\n@param requestType the type to set\n@throws IllegalArgumentException if requestType is not a valid\nrequest type\n"}, {"uris": "src/main/java/org/ice4j/message/Message.java.Message.[]Message()", "name": "Message", "arg_nums": 0, "params": [], "return_type": "", "signature": "protected Message()", "original_string": "    protected Message()\n    {\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/Message.java", "class_name": "Message", "class_uri": "src/main/java/org/ice4j/message/Message.java.Message", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nCreates an empty STUN Message.\n"}, {"uris": "src/main/java/org/ice4j/message/Message.java.Message.[char]getDataLength()", "name": "getDataLength", "arg_nums": 0, "params": [], "return_type": "char", "signature": "public char getDataLength()", "original_string": "    public char getDataLength()\n    {\n        char length = 0;\n\n        List<Attribute> attrs = getAttributes();\n        for (Attribute att : attrs)\n        {\n            int attLen = att.getDataLength() + Attribute.HEADER_LENGTH;\n\n            //take attribute padding into account:\n            attLen += (4 - (attLen % 4)) % 4;\n\n            length += attLen;\n        }\n        return length;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/Message.java", "class_name": "Message", "class_uri": "src/main/java/org/ice4j/message/Message.java.Message", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "char", "classes": []}, "docstring": "\nReturns the length of this message's body.\n@return the length of the data in this message.\n"}, {"uris": "src/main/java/org/ice4j/message/Message.java.Message.[char]getDataLengthWithoutPadding()", "name": "getDataLengthWithoutPadding", "arg_nums": 0, "params": [], "return_type": "char", "signature": "public char getDataLengthWithoutPadding()", "original_string": "    public char getDataLengthWithoutPadding()\n    {\n        char length = 0;\n\n        List<Attribute> attrs = getAttributes();\n\n        for (Attribute att : attrs)\n        {\n            int attLen = att.getDataLength() + Attribute.HEADER_LENGTH;\n            length += attLen;\n        }\n        return length;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/Message.java", "class_name": "Message", "class_uri": "src/main/java/org/ice4j/message/Message.java.Message", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "char", "classes": []}, "docstring": "\nReturns the length of this message's body without padding.\nSome STUN/ICE dialect does not take into account padding (GTalk).\n\n@return the length of the data in this message.\n"}, {"uris": "src/main/java/org/ice4j/message/Message.java.Message.[void]putAttribute(Attribute)", "name": "putAttribute", "arg_nums": 1, "params": [{"name": "attribute", "type": "Attribute"}], "return_type": "void", "signature": "public void putAttribute(Attribute attribute)", "original_string": "    public void putAttribute(Attribute attribute)\n        throws IllegalArgumentException\n    {\n        if (getAttributePresentity(attribute.getAttributeType()) == N_A)\n        {\n            throw new IllegalArgumentException(\n                                    \"The attribute \"\n                                    + attribute.getName()\n                                    + \" is not allowed in a \"\n                                    + getName());\n        }\n\n        synchronized(attributes)\n        {\n            attributes.put(attribute.getAttributeType(), attribute);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/Message.java", "class_name": "Message", "class_uri": "src/main/java/org/ice4j/message/Message.java.Message", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nPuts the specified attribute into this message. If an attribute with that\nname was already added, it would be replaced.\n\n@param attribute the attribute to put into this message.\n\n@throws IllegalArgumentException if the message cannot contain\nsuch an attribute.\n"}, {"uris": "src/main/java/org/ice4j/message/Message.java.Message.[boolean]containsAttribute(char)", "name": "containsAttribute", "arg_nums": 1, "params": [{"name": "attributeType", "type": "char"}], "return_type": "boolean", "signature": "public boolean containsAttribute(char attributeType)", "original_string": "    public boolean containsAttribute(char attributeType)\n    {\n        return attributes.containsKey(attributeType);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/Message.java", "class_name": "Message", "class_uri": "src/main/java/org/ice4j/message/Message.java.Message", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nReturns <tt>true</tt> if the this <tt>Message</tt> contains an attribute\nwith the specified type or <tt>false</tt> otherwise.\n\n@param attributeType the type whose presence we need to determine.\n\n@return <tt>true</tt> if the this <tt>Message</tt> contains an attribute\nwith the specified type or <tt>false</tt> otherwise.\n"}, {"uris": "src/main/java/org/ice4j/message/Message.java.Message.[Attribute]getAttribute(char)", "name": "getAttribute", "arg_nums": 1, "params": [{"name": "attributeType", "type": "char"}], "return_type": "Attribute", "signature": "public Attribute getAttribute(char attributeType)", "original_string": "    public Attribute getAttribute(char attributeType)\n    {\n        synchronized(attributes)\n        {\n            return attributes.get(attributeType);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/Message.java", "class_name": "Message", "class_uri": "src/main/java/org/ice4j/message/Message.java.Message", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Attribute", "classes": []}, "docstring": "\nReturns the attribute with the specified type or null if no such\nattribute exists.\n\n@param attributeType the type of the attribute\n@return the attribute with the specified type or null if no such\nattribute exists\n"}, {"uris": "src/main/java/org/ice4j/message/Message.java.Message.[List<Attribute>]getAttributes()", "name": "getAttributes", "arg_nums": 0, "params": [], "return_type": "List<Attribute>", "signature": "public List<Attribute> getAttributes()", "original_string": "    public List<Attribute> getAttributes()\n    {\n        synchronized(attributes)\n        {\n            return new LinkedList<>(attributes.values());\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/Message.java", "class_name": "Message", "class_uri": "src/main/java/org/ice4j/message/Message.java.Message", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<Attribute>", "classes": []}, "docstring": "\nReturns a copy of all {@link Attribute}s in this {@link Message}.\n\n@return a copy of all {@link Attribute}s in this {@link Message}.\n"}, {"uris": "src/main/java/org/ice4j/message/Message.java.Message.[Attribute]removeAttribute(char)", "name": "removeAttribute", "arg_nums": 1, "params": [{"name": "attributeType", "type": "char"}], "return_type": "Attribute", "signature": "public Attribute removeAttribute(char attributeType)", "original_string": "    public Attribute removeAttribute(char attributeType)\n    {\n        synchronized(attributes)\n        {\n            return attributes.remove(attributeType);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/Message.java", "class_name": "Message", "class_uri": "src/main/java/org/ice4j/message/Message.java.Message", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Attribute", "classes": []}, "docstring": "\nRemoves the specified attribute.\n\n@param attributeType the attribute to remove.\n\n@return the <tt>Attribute</tt> we've just removed.\n"}, {"uris": "src/main/java/org/ice4j/message/Message.java.Message.[int]getAttributeCount()", "name": "getAttributeCount", "arg_nums": 0, "params": [], "return_type": "int", "signature": "public int getAttributeCount()", "original_string": "    public int getAttributeCount()\n    {\n        return  attributes.size();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/Message.java", "class_name": "Message", "class_uri": "src/main/java/org/ice4j/message/Message.java.Message", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\nReturns the number of attributes, currently contained by the message.\n\n@return the number of attributes, currently contained by the message.\n"}, {"uris": "src/main/java/org/ice4j/message/Message.java.Message.[void]setMessageType(char)", "name": "setMessageType", "arg_nums": 1, "params": [{"name": "messageType", "type": "char"}], "return_type": "void", "signature": "protected void setMessageType(char messageType)", "original_string": "    protected void setMessageType(char messageType)\n    {\n        this.messageType = messageType;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/Message.java", "class_name": "Message", "class_uri": "src/main/java/org/ice4j/message/Message.java.Message", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets this message's type to be messageType. Method is package access\nas it should not permit changing the type of message once it has been\ninitialized (could provoke attribute discrepancies). Called by\nmessageFactory.\n\n@param messageType the message type.\n"}, {"uris": "src/main/java/org/ice4j/message/Message.java.Message.[char]getMessageType()", "name": "getMessageType", "arg_nums": 0, "params": [], "return_type": "char", "signature": "public char getMessageType()", "original_string": "    public char getMessageType()\n    {\n        return messageType;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/Message.java", "class_name": "Message", "class_uri": "src/main/java/org/ice4j/message/Message.java.Message", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "char", "classes": []}, "docstring": "\nThe message type of this message.\n\n@return the message type of the message.\n"}, {"uris": "src/main/java/org/ice4j/message/Message.java.Message.[void]setTransactionID(byte[])", "name": "setTransactionID", "arg_nums": 1, "params": [{"name": "tranID", "type": "byte[]"}], "return_type": "void", "signature": "public void setTransactionID(byte[] tranID)", "original_string": "    public void setTransactionID(byte[] tranID)\n        throws StunException\n    {\n        if (tranID == null\n           || (tranID.length != TRANSACTION_ID_LENGTH &&\n                   tranID.length != RFC3489_TRANSACTION_ID_LENGTH))\n            throw new StunException(StunException.ILLEGAL_ARGUMENT,\n                                    \"Invalid transaction id length\");\n\n        int tranIDLength = tranID.length;\n\n        this.transactionID = new byte[tranIDLength];\n        System.arraycopy(tranID, 0,\n                         this.transactionID, 0, tranIDLength);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/Message.java", "class_name": "Message", "class_uri": "src/main/java/org/ice4j/message/Message.java.Message", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCopies the specified tranID and sets it as this message's transactionID.\n\n@param tranID the transaction id to set in this message.\n\n@throws StunException ILLEGAL_ARGUMENT if the transaction id is not\nvalid.\n"}, {"uris": "src/main/java/org/ice4j/message/Message.java.Message.[byte[]]getTransactionID()", "name": "getTransactionID", "arg_nums": 0, "params": [], "return_type": "byte[]", "signature": "public byte[] getTransactionID()", "original_string": "    public byte[] getTransactionID()\n    {\n        return this.transactionID;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/Message.java", "class_name": "Message", "class_uri": "src/main/java/org/ice4j/message/Message.java.Message", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "byte[]", "classes": []}, "docstring": "\nReturns a reference to this message's transaction id.\n\n@return a reference to this message's transaction id.\n"}, {"uris": "src/main/java/org/ice4j/message/Message.java.Message.[byte]getAttributePresentity(char)", "name": "getAttributePresentity", "arg_nums": 1, "params": [{"name": "attributeType", "type": "char"}], "return_type": "byte", "signature": "protected byte getAttributePresentity(char attributeType)", "original_string": "    protected byte getAttributePresentity(char attributeType)\n    {\n        if (!rfc3489CompatibilityMode)\n            return O;\n\n        byte msgIndex = -1;\n        byte attributeIndex = -1;\n\n        switch (messageType)\n        {\n            case BINDING_REQUEST:\n                msgIndex = BINDING_REQUEST_PRESENTITY_INDEX; break;\n            case BINDING_SUCCESS_RESPONSE:\n                msgIndex = BINDING_RESPONSE_PRESENTITY_INDEX; break;\n            case BINDING_ERROR_RESPONSE:\n                msgIndex = BINDING_ERROR_RESPONSE_PRESENTITY_INDEX; break;\n            case SHARED_SECRET_REQUEST:\n                msgIndex = SHARED_SECRET_REQUEST_PRESENTITY_INDEX; break;\n            case SHARED_SECRET_RESPONSE:\n                msgIndex = SHARED_SECRET_RESPONSE_PRESENTITY_INDEX; break;\n            case SHARED_SECRET_ERROR_RESPONSE:\n                msgIndex = SHARED_SECRET_ERROR_RESPONSE_PRESENTITY_INDEX; break;\n            case ALLOCATE_REQUEST:\n                msgIndex = ALLOCATE_REQUEST_PRESENTITY_INDEX; break;\n            case REFRESH_REQUEST:\n                msgIndex = REFRESH_REQUEST_PRESENTITY_INDEX; break;\n            case CHANNELBIND_REQUEST:\n                msgIndex = CHANNELBIND_REQUEST_PRESENTITY_INDEX; break;\n            case SEND_INDICATION:\n                msgIndex = SEND_INDICATION_PRESENTITY_INDEX; break;\n            case DATA_INDICATION:\n                msgIndex = DATA_INDICATION_PRESENTITY_INDEX; break;\n            default:\n                if (logger.isLoggable(Level.FINE))\n                {\n                    logger.log(\n                            Level.FINE,\n                            \"Attribute presentity not defined for STUN \" +\n                            \"message type: \" + ((int) messageType)\n                                + \". Will assume optional.\");\n                }\n                return O;\n        }\n\n        switch (attributeType)\n        {\n            case Attribute.MAPPED_ADDRESS:\n                attributeIndex = MAPPED_ADDRESS_PRESENTITY_INDEX; break;\n            case Attribute.RESPONSE_ADDRESS:\n                attributeIndex = RESPONSE_ADDRESS_PRESENTITY_INDEX; break;\n            case Attribute.CHANGE_REQUEST:\n                attributeIndex = CHANGE_REQUEST_PRESENTITY_INDEX; break;\n            case Attribute.SOURCE_ADDRESS:\n                attributeIndex = SOURCE_ADDRESS_PRESENTITY_INDEX; break;\n            case Attribute.CHANGED_ADDRESS:\n                attributeIndex = CHANGED_ADDRESS_PRESENTITY_INDEX; break;\n            case Attribute.USERNAME:\n                attributeIndex = USERNAME_PRESENTITY_INDEX; break;\n            case Attribute.PASSWORD:\n                attributeIndex = PASSWORD_PRESENTITY_INDEX; break;\n            case Attribute.MESSAGE_INTEGRITY:\n                attributeIndex = MESSAGE_INTEGRITY_PRESENTITY_INDEX; break;\n            case Attribute.ERROR_CODE:\n                attributeIndex = ERROR_CODE_PRESENTITY_INDEX; break;\n            case Attribute.UNKNOWN_ATTRIBUTES:\n                attributeIndex = UNKNOWN_ATTRIBUTES_PRESENTITY_INDEX; break;\n            case Attribute.REFLECTED_FROM:\n                attributeIndex = REFLECTED_FROM_PRESENTITY_INDEX; break;\n            case Attribute.XOR_MAPPED_ADDRESS:\n                attributeIndex = XOR_MAPPED_ADDRESS_PRESENTITY_INDEX; break;\n            case Attribute.XOR_ONLY:\n                attributeIndex = XOR_ONLY_PRESENTITY_INDEX; break;\n            case Attribute.SOFTWARE:\n                attributeIndex = SOFTWARE_PRESENTITY_INDEX; break;\n            case Attribute.ALTERNATE_SERVER:\n                attributeIndex = ALTERNATE_SERVER_PRESENTITY_INDEX; break;\n            case Attribute.REALM:\n                attributeIndex = REALM_PRESENTITY_INDEX; break;\n            case Attribute.NONCE:\n                attributeIndex = NONCE_PRESENTITY_INDEX; break;\n            case Attribute.FINGERPRINT:\n                attributeIndex = FINGERPRINT_PRESENTITY_INDEX; break;\n            case Attribute.CHANNEL_NUMBER:\n                attributeIndex = CHANNEL_NUMBER_PRESENTITY_INDEX; break;\n            case Attribute.LIFETIME:\n                attributeIndex = LIFETIME_PRESENTITY_INDEX; break;\n            case Attribute.XOR_PEER_ADDRESS:\n                attributeIndex = XOR_PEER_ADDRESS_PRESENTITY_INDEX; break;\n            case Attribute.DATA:\n                attributeIndex = DATA_PRESENTITY_INDEX; break;\n            case Attribute.XOR_RELAYED_ADDRESS:\n                attributeIndex = XOR_RELAYED_ADDRESS_PRESENTITY_INDEX; break;\n            case Attribute.EVEN_PORT:\n                attributeIndex = EVEN_PORT_PRESENTITY_INDEX; break;\n            case Attribute.REQUESTED_TRANSPORT:\n                attributeIndex = REQUESTED_TRANSPORT_PRESENTITY_INDEX; break;\n            case Attribute.DONT_FRAGMENT:\n                attributeIndex = DONT_FRAGMENT_PRESENTITY_INDEX; break;\n            case Attribute.RESERVATION_TOKEN:\n                attributeIndex = RESERVATION_TOKEN_PRESENTITY_INDEX; break;\n            default:\n                attributeIndex = UNKNOWN_OPTIONAL_ATTRIBUTES_PRESENTITY_INDEX;\n                break;\n        }\n\n        return attributePresentities[ attributeIndex ][ msgIndex ];\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/Message.java", "class_name": "Message", "class_uri": "src/main/java/org/ice4j/message/Message.java.Message", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "byte", "classes": []}, "docstring": "\nReturns whether an attribute could be present in this message.\n\n@param attributeType the id of the attribute to check .\n\n@return Message.N_A - for not applicable <br>\n        Message.C   - for case depending <br>\n        Message.N_A - for not applicable <br>\n"}, {"uris": "src/main/java/org/ice4j/message/Message.java.Message.[String]getName()", "name": "getName", "arg_nums": 0, "params": [], "return_type": "String", "signature": "public String getName()", "original_string": "    public String getName()\n    {\n        switch (messageType)\n        {\n        case ALLOCATE_REQUEST:             return \"ALLOCATE-REQUEST\";\n        case ALLOCATE_RESPONSE:            return \"ALLOCATE-RESPONSE\";\n        case ALLOCATE_ERROR_RESPONSE:      return \"ALLOCATE-ERROR-RESPONSE\";\n        case BINDING_REQUEST:              return \"BINDING-REQUEST\";\n        case BINDING_SUCCESS_RESPONSE:     return \"BINDING-RESPONSE\";\n        case BINDING_ERROR_RESPONSE:       return \"BINDING-ERROR-RESPONSE\";\n        case CREATEPERMISSION_REQUEST:     return \"CREATE-PERMISSION-REQUEST\";\n        case CREATEPERMISSION_RESPONSE:    return \"CREATE-PERMISSION-RESPONSE\";\n        case CREATEPERMISSION_ERROR_RESPONSE:\n            return \"CREATE-PERMISSION-ERROR-RESPONSE\";\n        case DATA_INDICATION:              return \"DATA-INDICATION\";\n        case REFRESH_REQUEST:              return \"REFRESH-REQUEST\";\n        case REFRESH_RESPONSE:             return \"REFRESH-RESPONSE\";\n        case REFRESH_ERROR_RESPONSE:       return \"REFRESH-ERROR-RESPONSE\";\n        case SEND_INDICATION:              return \"SEND-INDICATION\";\n        case SHARED_SECRET_REQUEST:        return \"SHARED-SECRET-REQUEST\";\n        case SHARED_SECRET_RESPONSE:       return \"SHARED-SECRET-RESPONSE\";\n        case SHARED_SECRET_ERROR_RESPONSE:\n            return \"SHARED-SECRET-ERROR-RESPONSE\";\n        default:                           return \"UNKNOWN-MESSAGE\";\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/Message.java", "class_name": "Message", "class_uri": "src/main/java/org/ice4j/message/Message.java.Message", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns the human readable name of this message. Message names do\nnot really matter from the protocol point of view. They are only used\nfor debugging and readability.\n\n@return this message's name.\n"}, {"uris": "src/main/java/org/ice4j/message/Message.java.Message.[boolean]equals(Object)", "name": "equals", "arg_nums": 1, "params": [{"name": "obj", "type": "Object"}], "return_type": "boolean", "signature": "@Override\n    public boolean equals(Object obj)", "original_string": "    @Override\n    public boolean equals(Object obj)\n    {\n        if (!(obj instanceof Message))\n            return false;\n\n        if (obj == this)\n            return true;\n\n        Message msg = (Message) obj;\n        if ( msg.getMessageType()   != getMessageType())\n            return false;\n        if (msg.getDataLength() != getDataLength())\n            return false;\n\n        //compare attributes\n        for (Attribute localAtt : attributes.values())\n        {\n            if (!localAtt.equals(msg.getAttribute(localAtt.getAttributeType())))\n                return false;\n        }\n\n        return true;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/Message.java", "class_name": "Message", "class_uri": "src/main/java/org/ice4j/message/Message.java.Message", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nCompares two STUN Messages. Messages are considered equal when their\ntype, length, and all their attributes are equal.\n\n@param obj the object to compare this message with.\n\n@return true if the messages are equal and false otherwise.\n"}, {"uris": "src/main/java/org/ice4j/message/Message.java.Message.[byte[]]encode(StunStack)", "name": "encode", "arg_nums": 1, "params": [{"name": "stunStack", "type": "StunStack"}], "return_type": "byte[]", "signature": "public byte[] encode(StunStack stunStack)", "original_string": "    public byte[] encode(StunStack stunStack)\n        throws IllegalStateException\n    {\n        prepareForEncoding();\n\n        //make sure we have everything necessary to encode a proper message\n        validateAttributePresentity();\n\n        final char dataLength;\n\n        dataLength = getDataLength();\n\n        byte binMsg[] = new byte[HEADER_LENGTH + dataLength];\n        int offset    = 0;\n\n        // STUN Message Type\n        binMsg[offset++] = (byte)(getMessageType() >> 8);\n        binMsg[offset++] = (byte)(getMessageType() & 0xFF);\n\n        // Message Length\n        final int messageLengthOffset = offset;\n\n        offset += 2;\n\n        byte tranID[] = getTransactionID();\n\n        if (tranID.length == 12)\n        {\n            System.arraycopy(MAGIC_COOKIE, 0, binMsg, offset, 4);\n            offset += 4;\n            System.arraycopy(tranID, 0, binMsg, offset, TRANSACTION_ID_LENGTH);\n            offset += TRANSACTION_ID_LENGTH;\n        }\n        else\n        {\n            /* RFC3489 behavior */\n            System.arraycopy(tranID, 0, binMsg, offset,\n                RFC3489_TRANSACTION_ID_LENGTH);\n            offset += RFC3489_TRANSACTION_ID_LENGTH;\n        }\n\n        Vector<Map.Entry<Character, Attribute>> v = new Vector<>();\n        Iterator<Map.Entry<Character, Attribute>> iter = null;\n        char dataLengthForContentDependentAttribute = 0;\n\n        synchronized (attributes)\n        {\n            v.addAll(attributes.entrySet());\n        }\n\n        iter = v.iterator();\n\n        while (iter.hasNext())\n        {\n            Attribute attribute = iter.next().getValue();\n            int attributeLength\n                = attribute.getDataLength() + Attribute.HEADER_LENGTH;\n\n            //take attribute padding into account:\n            attributeLength += (4 - attributeLength % 4) % 4;\n            dataLengthForContentDependentAttribute += attributeLength;\n\n            //special handling for message integrity and fingerprint values\n            byte[] binAtt;\n\n            if (attribute instanceof ContentDependentAttribute)\n            {\n                /*\n                 * The \"Message Length\" seen by a ContentDependentAttribute is\n                 * up to and including the very Attribute but without any other\n                 * Attribute instances after it.\n                 */\n                binMsg[messageLengthOffset]\n                    = (byte)(dataLengthForContentDependentAttribute >> 8);\n                binMsg[messageLengthOffset + 1]\n                    = (byte)(dataLengthForContentDependentAttribute & 0xFF);\n                binAtt\n                    = ((ContentDependentAttribute)attribute)\n                            .encode(stunStack, binMsg, 0, offset);\n            }\n            else\n            {\n                binAtt = attribute.encode();\n            }\n\n            System.arraycopy(binAtt, 0, binMsg, offset, binAtt.length);\n            /*\n             * Offset by attributeLength and not by binAtt.length because\n             * attributeLength takes the attribute padding into account and\n             * binAtt.length does not.\n             */\n            offset += attributeLength;\n        }\n\n        // Message Length\n        binMsg[messageLengthOffset]     = (byte)(dataLength >> 8);\n        binMsg[messageLengthOffset + 1] = (byte)(dataLength & 0xFF);\n\n        return binMsg;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/Message.java", "class_name": "Message", "class_uri": "src/main/java/org/ice4j/message/Message.java.Message", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "byte[]", "classes": []}, "docstring": "\nReturns a binary representation of this message.\n\n@param stunStack the <tt>StunStack</tt> in the context of which the\nrequest to encode this <tt>Message</tt> is being made\n@return a binary representation of this message.\n\n@throws IllegalStateException if the message does not have all\nrequired attributes.\n"}, {"uris": "src/main/java/org/ice4j/message/Message.java.Message.[void]prepareForEncoding()", "name": "prepareForEncoding", "arg_nums": 0, "params": [], "return_type": "void", "signature": "private void prepareForEncoding()", "original_string": "    private void prepareForEncoding()\n    {\n        //remove MESSAGE-INTEGRITY and FINGERPRINT attributes so that we can\n        //make sure they are added at the end.\n        Attribute msgIntAttr = removeAttribute(Attribute.MESSAGE_INTEGRITY);\n        Attribute fingerprint = removeAttribute(Attribute.FINGERPRINT);\n\n        //add a SOFTWARE attribute if the user said so, and unless they did it\n        //themselves.\n        String software = AgentConfig.config.getSoftware();\n\n        if (getAttribute(Attribute.SOFTWARE) == null\n            && software != null && software.length() > 0)\n        {\n            putAttribute(AttributeFactory\n                            .createSoftwareAttribute(software.getBytes()));\n        }\n\n        //re-add MESSAGE-INTEGRITY if there was one.\n        if (msgIntAttr != null)\n        {\n            putAttribute(msgIntAttr);\n        }\n\n        //add FINGERPRINT if there was one or if user told us to add it\n        //everywhere.\n        if (fingerprint == null\n            && Boolean.getBoolean(StackProperties.ALWAYS_SIGN))\n        {\n            fingerprint = AttributeFactory.createFingerprintAttribute();\n        }\n\n        if (fingerprint != null)\n        {\n            putAttribute(fingerprint);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/Message.java", "class_name": "Message", "class_uri": "src/main/java/org/ice4j/message/Message.java.Message", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nAdds attributes that have been requested vis configuration properties.\nAsserts attribute order where necessary.\n"}, {"uris": "src/main/java/org/ice4j/message/Message.java.Message.[Message]decode(byte[],int,int)", "name": "decode", "arg_nums": 3, "params": [{"name": "binMessage", "type": "byte[]"}, {"name": "offset", "type": "int"}, {"name": "arrayLen", "type": "int"}], "return_type": "Message", "signature": "public static Message decode(byte[] binMessage, int offset, int arrayLen)", "original_string": "    public static Message decode(byte[] binMessage, int offset, int arrayLen)\n        throws StunException\n    {\n        int originalOffset = offset;\n        arrayLen = Math.min(binMessage.length, arrayLen);\n\n        if (arrayLen - offset < Message.HEADER_LENGTH)\n        {\n            throw new StunException( StunException.ILLEGAL_ARGUMENT,\n                         \"The given binary array is not a valid StunMessage\");\n        }\n\n        char messageType = (char)((binMessage[offset++] << 8)\n                               | (binMessage[offset++] & 0xFF));\n\n        Message message;\n        /* 0x0115 is a old TURN DATA indication message type */\n        if (Message.isResponseType(messageType) &&\n                messageType != OLD_DATA_INDICATION)\n            message = new Response();\n        else if (Message.isRequestType(messageType))\n            message = new Request();\n        else /* indication */\n            message = new Indication();\n\n        message.setMessageType(messageType);\n\n        int length = (char)((binMessage[offset++] << 8)\n                          | (binMessage[offset++]  & 0xFF));\n\n        /* copy the cookie */\n        byte[] cookie = new byte[4];\n        System.arraycopy(binMessage, offset, cookie, 0, 4);\n        offset += 4;\n\n        boolean rfc3489Compat = false;\n\n        if (!Arrays.equals(MAGIC_COOKIE, cookie))\n        {\n            rfc3489Compat = true;\n        }\n\n        if (arrayLen - offset - TRANSACTION_ID_LENGTH < length)\n        {\n            throw\n                new StunException(\n                        StunException.ILLEGAL_ARGUMENT,\n                        \"The given binary array does not seem to contain\"\n                            + \" a whole StunMessage: given \"\n                            + arrayLen\n                            + \" bytes of \"\n                            + message.getName()\n                            + \" but expecting \"\n                            + (offset + TRANSACTION_ID_LENGTH + length));\n        }\n\n        byte[] tranID = new byte[TRANSACTION_ID_LENGTH];\n        System.arraycopy(binMessage, offset, tranID, 0, TRANSACTION_ID_LENGTH);\n        try\n        {\n            if (rfc3489Compat)\n            {\n                byte[] rfc3489TranID = new byte[TRANSACTION_ID_LENGTH + 4];\n                System.arraycopy(cookie, 0, rfc3489TranID, 0, 4);\n                System.arraycopy(tranID, 0, rfc3489TranID, 4,\n                        TRANSACTION_ID_LENGTH);\n                message.setTransactionID(rfc3489TranID);\n            }\n            else\n            {\n                message.setTransactionID(tranID);\n            }\n        }\n        catch (StunException exc)\n        {\n            throw new StunException( StunException.ILLEGAL_ARGUMENT,\n                            \"The given binary array does not seem to \"\n                            + \"contain a whole StunMessage\", exc);\n        }\n\n        offset += TRANSACTION_ID_LENGTH;\n\n        while (offset - Message.HEADER_LENGTH < length)\n        {\n            Attribute att = AttributeDecoder.decode(\n                binMessage, offset, (char)(length - offset));\n\n            performAttributeSpecificActions(att, binMessage,\n                originalOffset, offset);\n\n            message.putAttribute(att);\n            offset += att.getDataLength() + Attribute.HEADER_LENGTH;\n\n            //now also skip any potential padding that might have come with\n            //this attribute.\n            if ((att.getDataLength() % 4) > 0)\n            {\n                offset += (4 - (att.getDataLength() % 4));\n            }\n        }\n\n        return message;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/Message.java", "class_name": "Message", "class_uri": "src/main/java/org/ice4j/message/Message.java.Message", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Message", "classes": []}, "docstring": "\nConstructs a message from its binary representation.\n@param binMessage the binary array that contains the encoded message\n@param offset the index where the message starts.\n@param arrayLen the length of the message\n@return a Message object constructed from the binMessage array\n\n@throws StunException <tt>ILLEGAL_ARGUMENT</tt> if one or more of the\narguments have invalid values.\n"}, {"uris": "src/main/java/org/ice4j/message/Message.java.Message.[void]performAttributeSpecificActions(Attribute,byte[],int,int)", "name": "performAttributeSpecificActions", "arg_nums": 4, "params": [{"name": "attribute", "type": "Attribute"}, {"name": "binMessage", "type": "byte[]"}, {"name": "offset", "type": "int"}, {"name": "msgLen", "type": "int"}], "return_type": "void", "signature": "private static void performAttributeSpecificActions(Attribute attribute,\n                                                        byte[]    binMessage,\n                                                        int       offset,\n                                                        int       msgLen)", "original_string": "    private static void performAttributeSpecificActions(Attribute attribute,\n                                                        byte[]    binMessage,\n                                                        int       offset,\n                                                        int       msgLen)\n        throws StunException\n    {\n        //check finger print CRC\n        if (attribute instanceof FingerprintAttribute)\n        {\n            if (!validateFingerprint((FingerprintAttribute)attribute,\n                            binMessage, offset, msgLen))\n            {\n                //RFC 5389 says that we should ignore bad CRCs rather than\n                //reply with an error response.\n                throw new StunException(\"Wrong value in FINGERPRINT\");\n            }\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/Message.java", "class_name": "Message", "class_uri": "src/main/java/org/ice4j/message/Message.java.Message", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nExecutes actions related specific attributes like asserting proper\nfingerprint checksum.\n\n@param attribute the <tt>Attribute</tt> we'd like to process.\n@param binMessage the byte array that the message arrived with.\n@param offset the index where data starts in <tt>binMessage</tt>.\n@param msgLen the number of message bytes in <tt>binMessage</tt>.\n\n@throws StunException if there's something in the <tt>attribute</tt> that\ncaused us to discard the whole message (e.g. an invalid checksum or\nusername)\n"}, {"uris": "src/main/java/org/ice4j/message/Message.java.Message.[boolean]validateFingerprint(FingerprintAttribute,byte[],int,int)", "name": "validateFingerprint", "arg_nums": 4, "params": [{"name": "fingerprint", "type": "FingerprintAttribute"}, {"name": "message", "type": "byte[]"}, {"name": "offset", "type": "int"}, {"name": "length", "type": "int"}], "return_type": "boolean", "signature": "private static boolean validateFingerprint(FingerprintAttribute fingerprint,\n                                               byte[]               message,\n                                               int                  offset,\n                                               int                  length)", "original_string": "    private static boolean validateFingerprint(FingerprintAttribute fingerprint,\n                                               byte[]               message,\n                                               int                  offset,\n                                               int                  length)\n    {\n\n        byte[] incomingCrcBytes = fingerprint.getChecksum();\n\n        //now check whether the CRC really is what it's supposed to be.\n        //re calculate the check sum\n        byte[] realCrcBytes = FingerprintAttribute.calculateXorCRC32(\n                        message, offset, length);\n\n        //CRC validation.\n        if ( ! Arrays.equals(incomingCrcBytes, realCrcBytes))\n        {\n            if (logger.isLoggable(Level.FINE))\n            {\n                logger.fine(\n                        \"An incoming message arrived with a wrong FINGERPRINT \"\n                        +\"attribute value. \"\n                        +\"CRC Was:\"  + Arrays.toString(incomingCrcBytes)\n                        + \". Should have been:\" + Arrays.toString(realCrcBytes)\n                        +\". Will ignore.\");\n            }\n\n            return false;\n        }\n\n        return true;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/Message.java", "class_name": "Message", "class_uri": "src/main/java/org/ice4j/message/Message.java.Message", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nRecalculates the FINGERPRINT CRC32 checksum of the <tt>message</tt>\narray so that we could compare it with the value brought by the\n{@link FingerprintAttribute}.\n\n@param fingerprint the attribute that we need to validate.\n@param message the message whose CRC32 checksum we'd need to recalculate.\n@param offset the index in <tt>message</tt> where data starts.\n@param length the number of bytes in <tt>message</tt> that the CRC32\nwould need to be calculated over.\n\n@return <tt>true</tt> if <tt>FINGERPRINT</tt> contains a valid CRC32\nvalue and <tt>false</tt> otherwise.\n"}, {"uris": "src/main/java/org/ice4j/message/Message.java.Message.[void]validateAttributePresentity()", "name": "validateAttributePresentity", "arg_nums": 0, "params": [], "return_type": "void", "signature": "protected void validateAttributePresentity()", "original_string": "    protected void validateAttributePresentity()\n        throws IllegalStateException\n    {\n        if (! rfc3489CompatibilityMode )\n            return;\n\n        for (char i = Attribute.MAPPED_ADDRESS; i < Attribute.REFLECTED_FROM; i++)\n            if (getAttributePresentity(i) == M && getAttribute(i) == null)\n                throw new IllegalStateException(\n                    \"A mandatory attribute (type=\" + (int)i + \") is missing!\");\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/Message.java", "class_name": "Message", "class_uri": "src/main/java/org/ice4j/message/Message.java.Message", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nVerify that the message has all obligatory attributes and throw an\nexception if this is not the case.\n\n@throws IllegalStateException if the message does not have all\nrequired attributes.\n"}, {"uris": "src/main/java/org/ice4j/message/Message.java.Message.[boolean]isErrorResponseType(char)", "name": "isErrorResponseType", "arg_nums": 1, "params": [{"name": "type", "type": "char"}], "return_type": "boolean", "signature": "public static boolean isErrorResponseType(char type)", "original_string": "    public static boolean isErrorResponseType(char type)\n    {\n      return ((type & MESSAGE_CLASS_MASK) == STUN_ERROR_RESP);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/Message.java", "class_name": "Message", "class_uri": "src/main/java/org/ice4j/message/Message.java.Message", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nDetermines if the message type is a Error Response.\n@param type type to test\n@return true if the type is Error Response, false otherwise\n"}, {"uris": "src/main/java/org/ice4j/message/Message.java.Message.[boolean]isSuccessResponseType(char)", "name": "isSuccessResponseType", "arg_nums": 1, "params": [{"name": "type", "type": "char"}], "return_type": "boolean", "signature": "public static boolean isSuccessResponseType(char type)", "original_string": "    public static boolean isSuccessResponseType(char type)\n    {\n        return ((type & MESSAGE_CLASS_MASK) == STUN_SUCCESS_RESP);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/Message.java", "class_name": "Message", "class_uri": "src/main/java/org/ice4j/message/Message.java.Message", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nDetermines if the message type is a Success Response.\n@param type type to test\n@return true if the type is Success Response, false otherwise\n"}, {"uris": "src/main/java/org/ice4j/message/Message.java.Message.[boolean]isResponseType(char)", "name": "isResponseType", "arg_nums": 1, "params": [{"name": "type", "type": "char"}], "return_type": "boolean", "signature": "public static boolean isResponseType(char type)", "original_string": "    public static boolean isResponseType(char type)\n    {\n        /* return (((type >> 8) & 1) != 0); */\n        return (isSuccessResponseType(type) || isErrorResponseType(type));\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/Message.java", "class_name": "Message", "class_uri": "src/main/java/org/ice4j/message/Message.java.Message", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nDetermines whether type could be the type of a STUN Response (as opposed\nto STUN Request).\n@param type the type to test.\n@return true if type is a valid response type.\n"}, {"uris": "src/main/java/org/ice4j/message/Message.java.Message.[boolean]isIndicationType(char)", "name": "isIndicationType", "arg_nums": 1, "params": [{"name": "type", "type": "char"}], "return_type": "boolean", "signature": "public static boolean isIndicationType(char type)", "original_string": "    public static boolean isIndicationType(char type)\n    {\n      return ((type & MESSAGE_CLASS_MASK) == STUN_INDICATION);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/Message.java", "class_name": "Message", "class_uri": "src/main/java/org/ice4j/message/Message.java.Message", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nDetermines if the message type is Indication.\n@param type type to test\n@return true if the type is Indication, false otherwise\n"}, {"uris": "src/main/java/org/ice4j/message/Message.java.Message.[boolean]isRequestType(char)", "name": "isRequestType", "arg_nums": 1, "params": [{"name": "type", "type": "char"}], "return_type": "boolean", "signature": "public static boolean isRequestType(char type)", "original_string": "    public static boolean isRequestType(char type)\n    {\n        /* return !isResponseType(type); */\n        return ((type & MESSAGE_CLASS_MASK) == STUN_REQUEST);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/Message.java", "class_name": "Message", "class_uri": "src/main/java/org/ice4j/message/Message.java.Message", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nDetermines whether type could be the type of a STUN Request (as opposed\nto STUN Response).\n@param type the type to test.\n@return true if type is a valid request type.\n"}, {"uris": "src/main/java/org/ice4j/message/Message.java.Message.[String]toString()", "name": "toString", "arg_nums": 0, "params": [], "return_type": "String", "signature": "@Override\n    public String toString()", "original_string": "    @Override\n    public String toString()\n    {\n        StringBuilder stringBuilder = new StringBuilder();\n\n        stringBuilder.append(getName());\n        stringBuilder.append(\"(0x\");\n        stringBuilder.append(Integer.toHexString(getMessageType()));\n        stringBuilder.append(\")[attrib.count=\");\n        stringBuilder.append(getAttributeCount());\n        stringBuilder.append(\" len=\");\n        stringBuilder.append((int) this.getDataLength());\n\n        byte[] transactionID = getTransactionID();\n\n        if (transactionID != null)\n        {\n            stringBuilder.append(\" tranID=\");\n            stringBuilder.append(TransactionID.toString(transactionID));\n        }\n        stringBuilder.append(\"]\");\n        return stringBuilder.toString();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/message/Message.java", "class_name": "Message", "class_uri": "src/main/java/org/ice4j/message/Message.java.Message", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns a <tt>String</tt> representation of this message.\n\n@return  a <tt>String</tt> representation of this message.\n"}, {"uris": "src/main/java/org/ice4j/stunclient/BlockingRequestSender.java.BlockingRequestSender.[]BlockingRequestSender(StunStack,TransportAddress)", "name": "BlockingRequestSender", "arg_nums": 2, "params": [{"name": "stunStack", "type": "StunStack"}, {"name": "localAddress", "type": "TransportAddress"}], "return_type": "", "signature": "public BlockingRequestSender(StunStack stunStack,\n                          TransportAddress localAddress)", "original_string": "    public BlockingRequestSender(StunStack stunStack,\n                          TransportAddress localAddress)\n    {\n        this.stunStack = stunStack;\n        this.localAddress = localAddress;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stunclient/BlockingRequestSender.java", "class_name": "BlockingRequestSender", "class_uri": "src/main/java/org/ice4j/stunclient/BlockingRequestSender.java.BlockingRequestSender", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nCreates a new request sender.\n@param stunStack the stack that the sender should send requests\nthrough.\n@param localAddress the <tt>TransportAddress</tt> that requests should be\nleaving from.\n"}, {"uris": "src/main/java/org/ice4j/stunclient/BlockingRequestSender.java.BlockingRequestSender.[TransportAddress]getLocalAddress()", "name": "getLocalAddress", "arg_nums": 0, "params": [], "return_type": "TransportAddress", "signature": "public TransportAddress getLocalAddress()", "original_string": "    public TransportAddress getLocalAddress()\n    {\n        return localAddress;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stunclient/BlockingRequestSender.java", "class_name": "BlockingRequestSender", "class_uri": "src/main/java/org/ice4j/stunclient/BlockingRequestSender.java.BlockingRequestSender", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "TransportAddress", "classes": []}, "docstring": "\nReturns the local Address on which this Blocking Request Sender is bound\nto.\n\n@return the localAddress of this RequestSender.\n"}, {"uris": "src/main/java/org/ice4j/stunclient/BlockingRequestSender.java.BlockingRequestSender.[void]processFailure(BaseStunMessageEvent)", "name": "processFailure", "arg_nums": 1, "params": [{"name": "event", "type": "BaseStunMessageEvent"}], "return_type": "void", "signature": "@Override\n    protected synchronized void processFailure(BaseStunMessageEvent event)", "original_string": "    @Override\n    protected synchronized void processFailure(BaseStunMessageEvent event)\n    {\n        synchronized(sendLock)\n        {\n            ended = true;\n            notifyAll();\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stunclient/BlockingRequestSender.java", "class_name": "BlockingRequestSender", "class_uri": "src/main/java/org/ice4j/stunclient/BlockingRequestSender.java.BlockingRequestSender", "attributes": {"modifiers": "@Override\n    protected synchronized", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected", "synchronized"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nNotifies this <tt>ResponseCollector</tt> that a transaction described by\nthe specified <tt>BaseStunMessageEvent</tt> has failed. The possible\nreasons for the failure include timeouts, unreachable destination, etc.\nNotifies the discoverer so that it may resume.\n\n@param event the <tt>BaseStunMessageEvent</tt> which describes the failed\ntransaction and the runtime type of which specifies the failure reason\n@see AbstractResponseCollector#processFailure(BaseStunMessageEvent)\n"}, {"uris": "src/main/java/org/ice4j/stunclient/BlockingRequestSender.java.BlockingRequestSender.[void]processResponse(StunResponseEvent)", "name": "processResponse", "arg_nums": 1, "params": [{"name": "evt", "type": "StunResponseEvent"}], "return_type": "void", "signature": "@Override\n    public synchronized void processResponse(StunResponseEvent evt)", "original_string": "    @Override\n    public synchronized void processResponse(StunResponseEvent evt)\n    {\n        synchronized(sendLock)\n        {\n            this.responseEvent = evt;\n            ended = true;\n            notifyAll();\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stunclient/BlockingRequestSender.java", "class_name": "BlockingRequestSender", "class_uri": "src/main/java/org/ice4j/stunclient/BlockingRequestSender.java.BlockingRequestSender", "attributes": {"modifiers": "@Override\n    public synchronized", "marker_annotations": ["@Override"], "non_marker_annotations": ["public", "synchronized"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSaves the message event and notifies the discoverer thread so that\nit may resume.\n@param evt the newly arrived message event.\n"}, {"uris": "src/main/java/org/ice4j/stunclient/BlockingRequestSender.java.BlockingRequestSender.[StunMessageEvent]sendRequestAndWaitForResponse(Request,TransportAddress)", "name": "sendRequestAndWaitForResponse", "arg_nums": 2, "params": [{"name": "request", "type": "Request"}, {"name": "serverAddress", "type": "TransportAddress"}], "return_type": "StunMessageEvent", "signature": "public synchronized StunMessageEvent sendRequestAndWaitForResponse(\n                                                Request request,\n                                                TransportAddress serverAddress)", "original_string": "    public synchronized StunMessageEvent sendRequestAndWaitForResponse(\n                                                Request request,\n                                                TransportAddress serverAddress)\n            throws StunException,\n                   IOException\n    {\n        synchronized(sendLock)\n        {\n            stunStack.sendRequest(request, serverAddress, localAddress,\n                                     BlockingRequestSender.this);\n        }\n\n        ended = false;\n        while (!ended)\n        {\n            try\n            {\n                wait();\n            }\n            catch (InterruptedException ex)\n            {\n                logger.log(Level.WARNING, \"Interrupted\", ex);\n            }\n        }\n        StunMessageEvent res = responseEvent;\n        responseEvent = null; //prepare for next message\n\n        return res;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stunclient/BlockingRequestSender.java", "class_name": "BlockingRequestSender", "class_uri": "src/main/java/org/ice4j/stunclient/BlockingRequestSender.java.BlockingRequestSender", "attributes": {"modifiers": "public synchronized", "marker_annotations": [], "non_marker_annotations": ["public", "synchronized"], "comments": [], "return_type": "StunMessageEvent", "classes": []}, "docstring": "\nSends the specified request and blocks until a response has been\nreceived or the request transaction has timed out.\n@param request the request to send\n@param serverAddress the request destination address\n@return the event encapsulating the response or null if no response\nhas been received.\n\n@throws IOException  if an error occurs while sending message bytes\nthrough the network socket.\n@throws IllegalArgumentException if the apDescriptor references an\naccess point that had not been installed,\n@throws StunException if message encoding fails,\n"}, {"uris": "src/main/java/org/ice4j/stunclient/BlockingRequestSender.java.BlockingRequestSender.[StunMessageEvent]sendRequestAndWaitForResponse(Request,TransportAddress,TransactionID)", "name": "sendRequestAndWaitForResponse", "arg_nums": 3, "params": [{"name": "request", "type": "Request"}, {"name": "serverAddress", "type": "TransportAddress"}, {"name": "tranID", "type": "TransactionID"}], "return_type": "StunMessageEvent", "signature": "public synchronized StunMessageEvent sendRequestAndWaitForResponse(\n                                                Request request,\n                                                TransportAddress serverAddress,\n                                                TransactionID tranID)", "original_string": "    public synchronized StunMessageEvent sendRequestAndWaitForResponse(\n                                                Request request,\n                                                TransportAddress serverAddress,\n                                                TransactionID tranID)\n            throws StunException,\n                   IOException\n    {\n        synchronized(sendLock)\n        {\n            stunStack.sendRequest(request, serverAddress, localAddress,\n                                     BlockingRequestSender.this, tranID);\n        }\n\n        ended = false;\n        while (!ended)\n        {\n            try\n            {\n                wait();\n            }\n            catch (InterruptedException ex)\n            {\n                logger.log(Level.WARNING, \"Interrupted\", ex);\n            }\n        }\n        StunMessageEvent res = responseEvent;\n        responseEvent = null; //prepare for next message\n\n        return res;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stunclient/BlockingRequestSender.java", "class_name": "BlockingRequestSender", "class_uri": "src/main/java/org/ice4j/stunclient/BlockingRequestSender.java.BlockingRequestSender", "attributes": {"modifiers": "public synchronized", "marker_annotations": [], "non_marker_annotations": ["public", "synchronized"], "comments": [], "return_type": "StunMessageEvent", "classes": []}, "docstring": "\nSends the specified request and blocks until a response has been\nreceived or the request transaction has timed out with given \ntransactionID.\n@param request the request to send\n@param serverAddress the request destination address\n@param tranID the TransactionID to set for this reuest.\n@return the event encapsulating the response or null if no response\nhas been received.\n\n@throws IOException  if an error occurs while sending message bytes\nthrough the network socket.\n@throws IllegalArgumentException if the apDescriptor references an\naccess point that had not been installed,\n@throws StunException if message encoding fails,\n"}, {"uris": "src/main/java/org/ice4j/stunclient/NetworkConfigurationDiscoveryProcess.java.NetworkConfigurationDiscoveryProcess.[]NetworkConfigurationDiscoveryProcess(StunStack,TransportAddress,TransportAddress)", "name": "NetworkConfigurationDiscoveryProcess", "arg_nums": 3, "params": [{"name": "stunStack", "type": "StunStack"}, {"name": "localAddress", "type": "TransportAddress"}, {"name": "serverAddress", "type": "TransportAddress"}], "return_type": "", "signature": "public NetworkConfigurationDiscoveryProcess(\n            StunStack stunStack,\n            TransportAddress localAddress, TransportAddress serverAddress)", "original_string": "    public NetworkConfigurationDiscoveryProcess(\n            StunStack stunStack,\n            TransportAddress localAddress, TransportAddress serverAddress)\n    {\n        if (stunStack == null)\n            throw new NullPointerException(\"stunStack\");\n\n        this.stunStack = stunStack;\n        this.localAddress  = localAddress;\n        this.serverAddress = serverAddress;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stunclient/NetworkConfigurationDiscoveryProcess.java", "class_name": "NetworkConfigurationDiscoveryProcess", "class_uri": "src/main/java/org/ice4j/stunclient/NetworkConfigurationDiscoveryProcess.java.NetworkConfigurationDiscoveryProcess", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a <tt>StunAddressDiscoverer</tt> with a specific\n<tt>StunStack</tt>. In order to use it one must first start it.\n\n@param stunStack the <tt>StunStack</tt> to be used by the new instance\n@param localAddress  the address where the stack should bind.\n@param serverAddress the address of the server to interrogate.\n"}, {"uris": "src/main/java/org/ice4j/stunclient/NetworkConfigurationDiscoveryProcess.java.NetworkConfigurationDiscoveryProcess.[void]shutDown()", "name": "shutDown", "arg_nums": 0, "params": [], "return_type": "void", "signature": "public void shutDown()", "original_string": "    public void shutDown()\n    {\n        stunStack.removeSocket(localAddress);\n        sock.close();\n        sock = null;\n\n        localAddress  = null;\n        requestSender = null;\n\n        this.started = false;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stunclient/NetworkConfigurationDiscoveryProcess.java", "class_name": "NetworkConfigurationDiscoveryProcess", "class_uri": "src/main/java/org/ice4j/stunclient/NetworkConfigurationDiscoveryProcess.java.NetworkConfigurationDiscoveryProcess", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nShuts down the underlying stack and prepares the object for garbage\ncollection.\n"}, {"uris": "src/main/java/org/ice4j/stunclient/NetworkConfigurationDiscoveryProcess.java.NetworkConfigurationDiscoveryProcess.[void]start()", "name": "start", "arg_nums": 0, "params": [], "return_type": "void", "signature": "public void start()", "original_string": "    public void start()\n        throws IOException, StunException\n    {\n        sock = new IceUdpSocketWrapper(\n            new SafeCloseDatagramSocket(localAddress));\n\n        stunStack.addSocket(sock);\n\n        requestSender = new BlockingRequestSender(stunStack, localAddress);\n\n        started = true;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stunclient/NetworkConfigurationDiscoveryProcess.java", "class_name": "NetworkConfigurationDiscoveryProcess", "class_uri": "src/main/java/org/ice4j/stunclient/NetworkConfigurationDiscoveryProcess.java.NetworkConfigurationDiscoveryProcess", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nPuts the discoverer into an operational state.\n@throws IOException if we fail to bind.\n@throws StunException if the stun4j stack fails start for some reason.\n"}, {"uris": "src/main/java/org/ice4j/stunclient/NetworkConfigurationDiscoveryProcess.java.NetworkConfigurationDiscoveryProcess.[StunDiscoveryReport]determineAddress()", "name": "determineAddress", "arg_nums": 0, "params": [], "return_type": "StunDiscoveryReport", "signature": "public StunDiscoveryReport determineAddress()", "original_string": "    public StunDiscoveryReport determineAddress()\n        throws StunException, IOException\n    {\n        checkStarted();\n        StunDiscoveryReport report = new StunDiscoveryReport();\n        StunMessageEvent evt = doTestI(serverAddress);\n\n        if (evt == null)\n        {\n            //UDP Blocked\n            report.setNatType(StunDiscoveryReport.UDP_BLOCKING_FIREWALL);\n            return report;\n        }\n        else\n        {\n            TransportAddress mappedAddress\n                =((MappedAddressAttribute)evt.getMessage()\n                  .getAttribute(Attribute.MAPPED_ADDRESS)).getAddress();\n\n            if (mappedAddress == null)\n            {\n              /* maybe we contact a STUNbis server and which do not\n               * understand our request.\n               */\n              logger.info(\"Failed to do the network discovery\");\n              return null;\n            }\n\n            logger.fine(\"mapped address is=\"+mappedAddress\n                        +\", name=\" + mappedAddress.getHostAddress());\n\n            TransportAddress backupServerAddress\n                =((ChangedAddressAttribute) evt.getMessage()\n                  .getAttribute(Attribute.CHANGED_ADDRESS)).getAddress();\n\n            logger.fine(\"backup server address is=\"+backupServerAddress\n                        + \", name=\" + backupServerAddress.getHostAddress());\n\n            report.setPublicAddress(mappedAddress);\n            if (mappedAddress.equals(localAddress))\n            {\n                evt = doTestII(serverAddress);\n                if (evt == null)\n                {\n                    //Sym UDP Firewall\n                    report.setNatType(StunDiscoveryReport\n                                        .SYMMETRIC_UDP_FIREWALL);\n                    return report;\n                }\n                else\n                {\n                    //open internet\n                    report.setNatType(StunDiscoveryReport.OPEN_INTERNET);\n                    return report;\n\n                }\n            }\n            else\n            {\n                evt = doTestII(serverAddress);\n                if (evt == null)\n                {\n                    evt = doTestI(backupServerAddress);\n                    if (evt == null)\n                    {\n                        logger.info(\"Failed to receive a response from \"\n                                    +\"backup stun server!\");\n                        return report;\n                    }\n                    TransportAddress mappedAddress2 =\n                        ((MappedAddressAttribute)evt.getMessage().\n                            getAttribute(Attribute.MAPPED_ADDRESS))\n                                .getAddress();\n                    if (mappedAddress.equals(mappedAddress2))\n                    {\n                        evt = doTestIII(serverAddress);\n                        if (evt == null)\n                        {\n                            //port restricted cone\n                            report.setNatType(StunDiscoveryReport\n                                              .PORT_RESTRICTED_CONE_NAT);\n                            return report;\n                        }\n                        else\n                        {\n                            //restricted cone\n                            report.setNatType(StunDiscoveryReport\n                                              .RESTRICTED_CONE_NAT);\n                            return report;\n\n                        }\n                    }\n                    else\n                    {\n                        //Symmetric NAT\n                        report.setNatType(StunDiscoveryReport.SYMMETRIC_NAT);\n                        return report;\n                    }\n                }\n                else\n                {\n                    //full cone\n                    report.setNatType(StunDiscoveryReport.FULL_CONE_NAT);\n                    return report;\n                }\n            }\n        }\n\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stunclient/NetworkConfigurationDiscoveryProcess.java", "class_name": "NetworkConfigurationDiscoveryProcess", "class_uri": "src/main/java/org/ice4j/stunclient/NetworkConfigurationDiscoveryProcess.java.NetworkConfigurationDiscoveryProcess", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "StunDiscoveryReport", "classes": []}, "docstring": "\nImplements the discovery process itself (see class description).\n@return a StunDiscoveryReport containing details about the network\nconfiguration of the host where the class is executed.\n\n@throws StunException ILLEGAL_STATE if the discoverer has not been started\n@throws IOException if a failure occurs while executing the discovery\nalgorithm.\n"}, {"uris": "src/main/java/org/ice4j/stunclient/NetworkConfigurationDiscoveryProcess.java.NetworkConfigurationDiscoveryProcess.[StunMessageEvent]doTestI(TransportAddress)", "name": "doTestI", "arg_nums": 1, "params": [{"name": "serverAddress", "type": "TransportAddress"}], "return_type": "StunMessageEvent", "signature": "private StunMessageEvent doTestI(TransportAddress serverAddress)", "original_string": "    private StunMessageEvent doTestI(TransportAddress serverAddress)\n        throws IOException, StunException\n    {\n        Request request = MessageFactory.createBindingRequest();\n\n/*\n        ChangeRequestAttribute changeRequest\n            = (ChangeRequestAttribute)request\n                .getAttribute(Attribute.CHANGE_REQUEST);\n        changeRequest.setChangeIpFlag(false);\n        changeRequest.setChangePortFlag(false);\n*/\n        /* add a change request attribute */\n        ChangeRequestAttribute changeRequest\n            = AttributeFactory.createChangeRequestAttribute();\n        changeRequest.setChangeIpFlag(false);\n        changeRequest.setChangePortFlag(false);\n        request.putAttribute(changeRequest);\n\n        StunMessageEvent evt = null;\n        try\n        {\n            evt = requestSender.sendRequestAndWaitForResponse(\n                    request, serverAddress);\n        }\n        catch (StunException ex)\n        {\n            //this shouldn't happen since we are the ones that created the\n            //request\n            logger.log(Level.SEVERE,\n                       \"Internal Error. Failed to encode a message\",\n                       ex);\n            return null;\n        }\n\n        if (evt != null)\n            logger.fine(\"TEST I res=\"+evt.getRemoteAddress().toString()\n                               +\" - \"+ evt.getRemoteAddress().getHostAddress());\n        else\n            logger.fine(\"NO RESPONSE received to TEST I.\");\n        return evt;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stunclient/NetworkConfigurationDiscoveryProcess.java", "class_name": "NetworkConfigurationDiscoveryProcess", "class_uri": "src/main/java/org/ice4j/stunclient/NetworkConfigurationDiscoveryProcess.java.NetworkConfigurationDiscoveryProcess", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "StunMessageEvent", "classes": []}, "docstring": "\nSends a binding request to the specified server address. Both change IP\nand change port flags are set to false.\n@param serverAddress the address where to send the bindingRequest.\n@return The returned message encapsulating event or null if no message\nwas received.\n\n@throws StunException if an exception occurs while sending the messge\n@throws IOException if an error occurs while sending bytes through\nthe socket.\n"}, {"uris": "src/main/java/org/ice4j/stunclient/NetworkConfigurationDiscoveryProcess.java.NetworkConfigurationDiscoveryProcess.[StunMessageEvent]doTestII(TransportAddress)", "name": "doTestII", "arg_nums": 1, "params": [{"name": "serverAddress", "type": "TransportAddress"}], "return_type": "StunMessageEvent", "signature": "private StunMessageEvent doTestII(TransportAddress serverAddress)", "original_string": "    private StunMessageEvent doTestII(TransportAddress serverAddress)\n        throws StunException, IOException\n    {\n        Request request = MessageFactory.createBindingRequest();\n\n        /* ChangeRequestAttribute changeRequest\n         *  = (ChangeRequestAttribute)request\n         *   .getAttribute(Attribute.CHANGE_REQUEST); */\n        /* add a change request attribute */\n        ChangeRequestAttribute changeRequest = AttributeFactory.createChangeRequestAttribute();\n        changeRequest.setChangeIpFlag(true);\n        changeRequest.setChangePortFlag(true);\n        request.putAttribute(changeRequest);\n\n        StunMessageEvent evt\n            = requestSender.sendRequestAndWaitForResponse(request,\n                                                          serverAddress);\n        if (evt != null)\n            logger.fine(\"Test II res=\"+evt.getRemoteAddress().toString()\n                            +\" - \"+ evt.getRemoteAddress().getHostAddress());\n        else\n            logger.fine(\"NO RESPONSE received to Test II.\");\n\n        return evt;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stunclient/NetworkConfigurationDiscoveryProcess.java", "class_name": "NetworkConfigurationDiscoveryProcess", "class_uri": "src/main/java/org/ice4j/stunclient/NetworkConfigurationDiscoveryProcess.java.NetworkConfigurationDiscoveryProcess", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "StunMessageEvent", "classes": []}, "docstring": "\nSends a binding request to the specified server address with both change\nIP and change port flags are set to true.\n@param serverAddress the address where to send the bindingRequest.\n@return The returned message encapsulating event or null if no message\nwas received.\n\n@throws StunException if an exception occurs while sending the messge\n@throws IOException if an exception occurs while executing the algorithm.\n"}, {"uris": "src/main/java/org/ice4j/stunclient/NetworkConfigurationDiscoveryProcess.java.NetworkConfigurationDiscoveryProcess.[StunMessageEvent]doTestIII(TransportAddress)", "name": "doTestIII", "arg_nums": 1, "params": [{"name": "serverAddress", "type": "TransportAddress"}], "return_type": "StunMessageEvent", "signature": "private StunMessageEvent doTestIII(TransportAddress serverAddress)", "original_string": "    private StunMessageEvent doTestIII(TransportAddress serverAddress)\n        throws StunException, IOException\n    {\n        Request request = MessageFactory.createBindingRequest();\n\n        /* ChangeRequestAttribute changeRequest\n                = (ChangeRequestAttribute)request.getAttribute(Attribute.CHANGE_REQUEST); */\n        /* add a change request attribute */\n        ChangeRequestAttribute changeRequest = AttributeFactory.createChangeRequestAttribute();\n        changeRequest.setChangeIpFlag(false);\n        changeRequest.setChangePortFlag(true);\n        request.putAttribute(changeRequest);\n\n        StunMessageEvent evt = requestSender.sendRequestAndWaitForResponse(\n            request, serverAddress);\n        if (evt != null)\n            logger.fine(\"Test III res=\"+evt.getRemoteAddress().toString()\n                            +\" - \"+ evt.getRemoteAddress().getHostAddress());\n        else\n            logger.fine(\"NO RESPONSE received to Test III.\");\n\n        return evt;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stunclient/NetworkConfigurationDiscoveryProcess.java", "class_name": "NetworkConfigurationDiscoveryProcess", "class_uri": "src/main/java/org/ice4j/stunclient/NetworkConfigurationDiscoveryProcess.java.NetworkConfigurationDiscoveryProcess", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "StunMessageEvent", "classes": []}, "docstring": "\nSends a binding request to the specified server address with only change\nport flag set to true and change IP flag - to false.\n@param serverAddress the address where to send the bindingRequest.\n@return The returned message encapsulating event or null if no message\nwas received.\n@throws StunException if an exception occurs while sending the messge\n@throws IOException if an exception occurs while sending bytes through\nthe socket.\n"}, {"uris": "src/main/java/org/ice4j/stunclient/NetworkConfigurationDiscoveryProcess.java.NetworkConfigurationDiscoveryProcess.[void]checkStarted()", "name": "checkStarted", "arg_nums": 0, "params": [], "return_type": "void", "signature": "private void checkStarted()", "original_string": "    private void checkStarted()\n        throws StunException\n    {\n        if (!started)\n            throw new StunException(StunException.ILLEGAL_STATE,\n                                    \"The Discoverer must be started before \"\n                                    +\"launching the discovery process!\");\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stunclient/NetworkConfigurationDiscoveryProcess.java", "class_name": "NetworkConfigurationDiscoveryProcess", "class_uri": "src/main/java/org/ice4j/stunclient/NetworkConfigurationDiscoveryProcess.java.NetworkConfigurationDiscoveryProcess", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nMakes shure the discoverer is operational and throws an\nStunException.ILLEGAL_STATE if that is not the case.\n@throws StunException ILLEGAL_STATE if the discoverer is not operational.\n"}, {"uris": "src/main/java/org/ice4j/stunclient/StunDiscoveryReport.java.StunDiscoveryReport.[]StunDiscoveryReport()", "name": "StunDiscoveryReport", "arg_nums": 0, "params": [], "return_type": "", "signature": "StunDiscoveryReport()", "original_string": "    StunDiscoveryReport()\n    {\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stunclient/StunDiscoveryReport.java", "class_name": "StunDiscoveryReport", "class_uri": "src/main/java/org/ice4j/stunclient/StunDiscoveryReport.java.StunDiscoveryReport", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "docstring": "\nCreates a discovery report with natType = UNKNOWN and a null public\naddress.\n"}, {"uris": "src/main/java/org/ice4j/stunclient/StunDiscoveryReport.java.StunDiscoveryReport.[String]getNatType()", "name": "getNatType", "arg_nums": 0, "params": [], "return_type": "String", "signature": "public String getNatType()", "original_string": "    public String getNatType()\n    {\n        return natType;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stunclient/StunDiscoveryReport.java", "class_name": "StunDiscoveryReport", "class_uri": "src/main/java/org/ice4j/stunclient/StunDiscoveryReport.java.StunDiscoveryReport", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns the type of the NAT described in the report.\n@return the type of the NAT that this report is about.\n"}, {"uris": "src/main/java/org/ice4j/stunclient/StunDiscoveryReport.java.StunDiscoveryReport.[void]setNatType(String)", "name": "setNatType", "arg_nums": 1, "params": [{"name": "natType", "type": "String"}], "return_type": "void", "signature": "void setNatType(String natType)", "original_string": "    void setNatType(String natType)\n    {\n        this.natType = natType;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stunclient/StunDiscoveryReport.java", "class_name": "StunDiscoveryReport", "class_uri": "src/main/java/org/ice4j/stunclient/StunDiscoveryReport.java.StunDiscoveryReport", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets the type of the NAT indicated by the report.\n@param natType the type of the NAT.\n"}, {"uris": "src/main/java/org/ice4j/stunclient/StunDiscoveryReport.java.StunDiscoveryReport.[TransportAddress]getPublicAddress()", "name": "getPublicAddress", "arg_nums": 0, "params": [], "return_type": "TransportAddress", "signature": "public TransportAddress getPublicAddress()", "original_string": "    public TransportAddress getPublicAddress()\n    {\n        return publicAddress;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stunclient/StunDiscoveryReport.java", "class_name": "StunDiscoveryReport", "class_uri": "src/main/java/org/ice4j/stunclient/StunDiscoveryReport.java.StunDiscoveryReport", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "TransportAddress", "classes": []}, "docstring": "\nReturns the public addressed discovered by a discovery process.\n@return an Inetner address for public use.\n"}, {"uris": "src/main/java/org/ice4j/stunclient/StunDiscoveryReport.java.StunDiscoveryReport.[void]setPublicAddress(TransportAddress)", "name": "setPublicAddress", "arg_nums": 1, "params": [{"name": "stunAddress", "type": "TransportAddress"}], "return_type": "void", "signature": "void setPublicAddress(TransportAddress stunAddress)", "original_string": "    void setPublicAddress(TransportAddress stunAddress)\n    {\n        this.publicAddress = stunAddress;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stunclient/StunDiscoveryReport.java", "class_name": "StunDiscoveryReport", "class_uri": "src/main/java/org/ice4j/stunclient/StunDiscoveryReport.java.StunDiscoveryReport", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets a public address.\n@param stunAddress An address that's accesible from everywhere.\n"}, {"uris": "src/main/java/org/ice4j/stunclient/StunDiscoveryReport.java.StunDiscoveryReport.[boolean]equals(Object)", "name": "equals", "arg_nums": 1, "params": [{"name": "obj", "type": "Object"}], "return_type": "boolean", "signature": "public boolean equals(Object obj)", "original_string": "    public boolean equals(Object obj)\n    {\n        if (! (obj instanceof StunDiscoveryReport))\n           return false;\n\n        if (obj == this)\n            return true;\n\n        StunDiscoveryReport target = (StunDiscoveryReport)obj;\n\n        return (   target.getNatType() == getNatType()\n                && ( getPublicAddress() == null && target.getPublicAddress() == null\n                    || target.getPublicAddress().equals(getPublicAddress())));\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stunclient/StunDiscoveryReport.java", "class_name": "StunDiscoveryReport", "class_uri": "src/main/java/org/ice4j/stunclient/StunDiscoveryReport.java.StunDiscoveryReport", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nCompares this object with obj. Two reports are considered equal if and\nonly if both have the same nat type and their public addresses are\nequal or are both null.\n@param obj the object to compare against.\n@return true if the two objects are equal and false otherwise.\n"}, {"uris": "src/main/java/org/ice4j/stunclient/StunDiscoveryReport.java.StunDiscoveryReport.[String]toString()", "name": "toString", "arg_nums": 0, "params": [], "return_type": "String", "signature": "public String toString()", "original_string": "    public String toString()\n    {\n        return   \"The detected network configuration is: \" + getNatType() + \"\\n\"\n               + \"Your mapped public address is: \" + getPublicAddress();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stunclient/StunDiscoveryReport.java", "class_name": "StunDiscoveryReport", "class_uri": "src/main/java/org/ice4j/stunclient/StunDiscoveryReport.java.StunDiscoveryReport", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns a readable representation of the report.\n@return a readable representation of the report.\n"}, {"uris": "src/main/java/org/ice4j/stunclient/SimpleAddressDetector.java.SimpleAddressDetector.[]SimpleAddressDetector(TransportAddress)", "name": "SimpleAddressDetector", "arg_nums": 1, "params": [{"name": "serverAddress", "type": "TransportAddress"}], "return_type": "", "signature": "public SimpleAddressDetector(TransportAddress serverAddress)", "original_string": "    public SimpleAddressDetector(TransportAddress serverAddress)\n    {\n        this.serverAddress = serverAddress;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stunclient/SimpleAddressDetector.java", "class_name": "SimpleAddressDetector", "class_uri": "src/main/java/org/ice4j/stunclient/SimpleAddressDetector.java.SimpleAddressDetector", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nCreates a StunAddressDiscoverer. In order to use it one must start the\ndiscoverer.\n@param serverAddress the address of the server to interrogate.\n"}, {"uris": "src/main/java/org/ice4j/stunclient/SimpleAddressDetector.java.SimpleAddressDetector.[TransportAddress]getServerAddress()", "name": "getServerAddress", "arg_nums": 0, "params": [], "return_type": "TransportAddress", "signature": "public TransportAddress getServerAddress()", "original_string": "    public TransportAddress getServerAddress()\n    {\n        return serverAddress;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stunclient/SimpleAddressDetector.java", "class_name": "SimpleAddressDetector", "class_uri": "src/main/java/org/ice4j/stunclient/SimpleAddressDetector.java.SimpleAddressDetector", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "TransportAddress", "classes": []}, "docstring": "\nReturns the server address that this detector is using to run stun\nqueries.\n\n@return StunAddress the address of the stun server that we are running\nstun queries against.\n"}, {"uris": "src/main/java/org/ice4j/stunclient/SimpleAddressDetector.java.SimpleAddressDetector.[void]shutDown()", "name": "shutDown", "arg_nums": 0, "params": [], "return_type": "void", "signature": "public void shutDown()", "original_string": "    public void shutDown()\n    {\n        stunStack = null;\n        requestSender = null;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stunclient/SimpleAddressDetector.java", "class_name": "SimpleAddressDetector", "class_uri": "src/main/java/org/ice4j/stunclient/SimpleAddressDetector.java.SimpleAddressDetector", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nShuts down the underlying stack and prepares the object for garbage\ncollection.\n"}, {"uris": "src/main/java/org/ice4j/stunclient/SimpleAddressDetector.java.SimpleAddressDetector.[void]start()", "name": "start", "arg_nums": 0, "params": [], "return_type": "void", "signature": "public void start()", "original_string": "    public void start()\n    {\n        stunStack = new StunStack();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stunclient/SimpleAddressDetector.java", "class_name": "SimpleAddressDetector", "class_uri": "src/main/java/org/ice4j/stunclient/SimpleAddressDetector.java.SimpleAddressDetector", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nPuts the discoverer into an operational state.\n"}, {"uris": "src/main/java/org/ice4j/stunclient/SimpleAddressDetector.java.SimpleAddressDetector.[TransportAddress]getMappingFor(IceSocketWrapper)", "name": "getMappingFor", "arg_nums": 1, "params": [{"name": "socket", "type": "IceSocketWrapper"}], "return_type": "TransportAddress", "signature": "public TransportAddress getMappingFor(IceSocketWrapper socket)", "original_string": "    public TransportAddress getMappingFor(IceSocketWrapper socket)\n       throws IOException, BindException\n    {\n         TransportAddress localAddress = new TransportAddress(\n              (InetSocketAddress)socket.getLocalSocketAddress(), Transport.UDP);\n\n         stunStack.addSocket(socket);\n\n         requestSender = new BlockingRequestSender(stunStack, localAddress);\n         StunMessageEvent evt = null;\n         try\n         {\n             evt = requestSender.sendRequestAndWaitForResponse(\n                 MessageFactory.createBindingRequest(), serverAddress);\n         }\n         catch(StunException exc)\n         {\n             //this shouldn't be happening since we are the one that constructed\n             //the request, so let's catch it here and not oblige users to\n             //handle exception they are not responsible for.\n             logger.log(Level.SEVERE, \"Internal Error. We apparently \"\n                        +\"constructed a faulty request.\", exc);\n             return null;\n         }\n         finally\n         {\n             stunStack.removeSocket(localAddress);\n         }\n\n        if (evt != null)\n        {\n            Response res = (Response)evt.getMessage();\n\n             /* in classic STUN, the response contains a MAPPED-ADDRESS */\n             MappedAddressAttribute maAtt = (MappedAddressAttribute)\n                                 res.getAttribute(Attribute.MAPPED_ADDRESS);\n             if (maAtt != null)\n             {\n                  return maAtt.getAddress();\n             }\n\n             /* in STUN bis, the response contains a XOR-MAPPED-ADDRESS */\n             XorMappedAddressAttribute xorAtt = (XorMappedAddressAttribute)res\n                 .getAttribute(Attribute.XOR_MAPPED_ADDRESS);\n             if (xorAtt != null)\n             {\n               byte xoring[] = new byte[16];\n\n               System.arraycopy(Message.MAGIC_COOKIE, 0, xoring, 0, 4);\n               System.arraycopy(res.getTransactionID(), 0, xoring, 4, 12);\n\n              return xorAtt.applyXor(xoring);\n            }\n       }\n\n       return null;\n   }", "default_arguments": null, "file": "src/main/java/org/ice4j/stunclient/SimpleAddressDetector.java", "class_name": "SimpleAddressDetector", "class_uri": "src/main/java/org/ice4j/stunclient/SimpleAddressDetector.java.SimpleAddressDetector", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "TransportAddress", "classes": []}, "docstring": "\nCreates a listening point for the specified socket and attempts to\ndiscover how its local address is NAT mapped.\n@param socket the socket whose address needs to be resolved.\n@return a StunAddress object containing the mapped address or null if\ndiscovery failed.\n\n@throws IOException if something fails along the way.\n@throws BindException if we cannot bind the socket.\n"}, {"uris": "src/main/java/org/ice4j/stack/EventDispatcher.java.EventDispatcher.[]EventDispatcher()", "name": "EventDispatcher", "arg_nums": 0, "params": [], "return_type": "", "signature": "public EventDispatcher()", "original_string": "    public EventDispatcher()\n    {\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/EventDispatcher.java", "class_name": "EventDispatcher", "class_uri": "src/main/java/org/ice4j/stack/EventDispatcher.java.EventDispatcher", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>EventDispatcher</tt> instance.\n"}, {"uris": "src/main/java/org/ice4j/stack/EventDispatcher.java.EventDispatcher.[void]addIndicationListener(TransportAddress,MessageEventHandler)", "name": "addIndicationListener", "arg_nums": 2, "params": [{"name": "localAddr", "type": "TransportAddress"}, {"name": "indicationListener", "type": "MessageEventHandler"}], "return_type": "void", "signature": "public void addIndicationListener(\n            TransportAddress localAddr,\n            MessageEventHandler indicationListener)", "original_string": "    public void addIndicationListener(\n            TransportAddress localAddr,\n            MessageEventHandler indicationListener)\n    {\n        addMessageListener(\n                localAddr,\n                new IndicationEventHandler(indicationListener));\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/EventDispatcher.java", "class_name": "EventDispatcher", "class_uri": "src/main/java/org/ice4j/stack/EventDispatcher.java.EventDispatcher", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nRegisters a specific <tt>MessageEventHandler</tt> for notifications about\nSTUN indications received at a specific local <tt>TransportAddress</tt>.\n\n@param localAddr the local <tt>TransportAddress</tt> STUN indications\nreceived at which are to be reported to the specified\n<tt>indicationListener</tt>\n@param indicationListener the <tt>MessageEventHandler</tt> which is to be\nregistered for notifications about STUN indications received at the\nspecified local <tt>TransportAddress</tt>\n"}, {"uris": "src/main/java/org/ice4j/stack/EventDispatcher.java.EventDispatcher.[void]addOldIndicationListener(TransportAddress,MessageEventHandler)", "name": "addOldIndicationListener", "arg_nums": 2, "params": [{"name": "localAddr", "type": "TransportAddress"}, {"name": "indicationListener", "type": "MessageEventHandler"}], "return_type": "void", "signature": "public void addOldIndicationListener(\n            TransportAddress localAddr,\n            MessageEventHandler indicationListener)", "original_string": "    public void addOldIndicationListener(\n            TransportAddress localAddr,\n            MessageEventHandler indicationListener)\n    {\n        addMessageListener(\n                localAddr,\n                new OldIndicationEventHandler(indicationListener));\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/EventDispatcher.java", "class_name": "EventDispatcher", "class_uri": "src/main/java/org/ice4j/stack/EventDispatcher.java.EventDispatcher", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nRegisters a specific <tt>MessageEventHandler</tt> for notifications about\nold indications received at a specific local <tt>TransportAddress</tt>.\n\n@param localAddr the local <tt>TransportAddress</tt> STUN indications\nreceived at which are to be reported to the specified\n<tt>indicationListener</tt>\n@param indicationListener the <tt>MessageEventHandler</tt> which is to be\nregistered for notifications about old indications received at the\nspecified local <tt>TransportAddress</tt>\n"}, {"uris": "src/main/java/org/ice4j/stack/EventDispatcher.java.EventDispatcher.[void]addMessageListener(MessageTypeEventHandler<?>)", "name": "addMessageListener", "arg_nums": 1, "params": [{"name": "messageListener", "type": "MessageTypeEventHandler<?>"}], "return_type": "void", "signature": "private synchronized void addMessageListener(\n            MessageTypeEventHandler<?> messageListener)", "original_string": "    private synchronized void addMessageListener(\n            MessageTypeEventHandler<?> messageListener)\n    {\n        synchronized(messageListeners)\n        {\n            if (!messageListeners.contains(messageListener))\n                messageListeners.add(messageListener);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/EventDispatcher.java", "class_name": "EventDispatcher", "class_uri": "src/main/java/org/ice4j/stack/EventDispatcher.java.EventDispatcher", "attributes": {"modifiers": "private synchronized", "marker_annotations": [], "non_marker_annotations": ["private", "synchronized"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nRegisters a specific <tt>MessageTypeEventHandler</tt> for notifications\nabout received STUN messages.\n\n@param messageListener the <tt>MessageTypeEventHandler</tt> which is to\nbe registered for notifications about received STUN messages\n"}, {"uris": "src/main/java/org/ice4j/stack/EventDispatcher.java.EventDispatcher.[void]addMessageListener(TransportAddress,MessageTypeEventHandler<?>)", "name": "addMessageListener", "arg_nums": 2, "params": [{"name": "localAddr", "type": "TransportAddress"}, {"name": "messageListener", "type": "MessageTypeEventHandler<?>"}], "return_type": "void", "signature": "private synchronized void addMessageListener(\n            TransportAddress localAddr,\n            MessageTypeEventHandler<?> messageListener)", "original_string": "    private synchronized void addMessageListener(\n            TransportAddress localAddr,\n            MessageTypeEventHandler<?> messageListener)\n    {\n        synchronized(children)\n        {\n            EventDispatcher child = children.get(localAddr);\n\n            if (child == null)\n            {\n                child = new EventDispatcher();\n                children.put(localAddr, child);\n            }\n            child.addMessageListener(messageListener);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/EventDispatcher.java", "class_name": "EventDispatcher", "class_uri": "src/main/java/org/ice4j/stack/EventDispatcher.java.EventDispatcher", "attributes": {"modifiers": "private synchronized", "marker_annotations": [], "non_marker_annotations": ["private", "synchronized"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nRegisters a specific <tt>MessageTypeEventHandler</tt> for notifications\nabout STUN messages received at a specific local\n<tt>TransportAddress</tt>.\n\n@param localAddr the local <tt>TransportAddress</tt> STUN messages\nreceived at which are to be reported to the specified\n<tt>messageListener</tt>\n@param messageListener the <tt>MessageTypeEventHandler</tt> which is to\nbe registered for notifications about STUN messages received at the\nspecified local <tt>TransportAddress</tt>\n"}, {"uris": "src/main/java/org/ice4j/stack/EventDispatcher.java.EventDispatcher.[void]addRequestListener(RequestListener)", "name": "addRequestListener", "arg_nums": 1, "params": [{"name": "listener", "type": "RequestListener"}], "return_type": "void", "signature": "public void addRequestListener(RequestListener listener)", "original_string": "    public void addRequestListener(RequestListener listener)\n    {\n        addMessageListener(new RequestListenerMessageEventHandler(listener));\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/EventDispatcher.java", "class_name": "EventDispatcher", "class_uri": "src/main/java/org/ice4j/stack/EventDispatcher.java.EventDispatcher", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nAdd a RequestListener to the listener list. The listener is registered\nfor requests coming from no matter which NetAccessPoint.\n\n@param listener  The RequestListener to be added\n"}, {"uris": "src/main/java/org/ice4j/stack/EventDispatcher.java.EventDispatcher.[void]addRequestListener(TransportAddress,RequestListener)", "name": "addRequestListener", "arg_nums": 2, "params": [{"name": "localAddr", "type": "TransportAddress"}, {"name": "listener", "type": "RequestListener"}], "return_type": "void", "signature": "public void addRequestListener( TransportAddress localAddr,\n                                    RequestListener  listener)", "original_string": "    public void addRequestListener( TransportAddress localAddr,\n                                    RequestListener  listener)\n    {\n        addMessageListener(\n                localAddr,\n                new RequestListenerMessageEventHandler(listener));\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/EventDispatcher.java", "class_name": "EventDispatcher", "class_uri": "src/main/java/org/ice4j/stack/EventDispatcher.java.EventDispatcher", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nAdd a RequestListener for a specific NetAccessPoint. The listener\nwill be invoked only when a call on fireRequestReceived is issued for\nthat specific NetAccessPoint.\n\n@param localAddr  The NETAP descriptor that we're interested in.\n@param listener  The ConfigurationChangeListener to be added\n"}, {"uris": "src/main/java/org/ice4j/stack/EventDispatcher.java.EventDispatcher.[void]removeMessageListener(MessageTypeEventHandler<?>)", "name": "removeMessageListener", "arg_nums": 1, "params": [{"name": "messageListener", "type": "MessageTypeEventHandler<?>"}], "return_type": "void", "signature": "private synchronized void removeMessageListener(\n            MessageTypeEventHandler<?> messageListener)", "original_string": "    private synchronized void removeMessageListener(\n            MessageTypeEventHandler<?> messageListener)\n    {\n        synchronized(messageListeners)\n        {\n            messageListeners.remove(messageListener);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/EventDispatcher.java", "class_name": "EventDispatcher", "class_uri": "src/main/java/org/ice4j/stack/EventDispatcher.java.EventDispatcher", "attributes": {"modifiers": "private synchronized", "marker_annotations": [], "non_marker_annotations": ["private", "synchronized"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nUnregisters a specific <tt>MessageTypeEventHandler</tt> from\nnotifications about received STUN messages.\n\n@param messageListener the <tt>MessageTypeEventHandler</tt> to be\nunregistered for notifications about received STUN messages\n"}, {"uris": "src/main/java/org/ice4j/stack/EventDispatcher.java.EventDispatcher.[void]removeMessageListener(TransportAddress,MessageTypeEventHandler<?>)", "name": "removeMessageListener", "arg_nums": 2, "params": [{"name": "localAddr", "type": "TransportAddress"}, {"name": "messageListener", "type": "MessageTypeEventHandler<?>"}], "return_type": "void", "signature": "private synchronized void removeMessageListener(\n            TransportAddress localAddr,\n            MessageTypeEventHandler<?> messageListener)", "original_string": "    private synchronized void removeMessageListener(\n            TransportAddress localAddr,\n            MessageTypeEventHandler<?> messageListener)\n    {\n        synchronized(children)\n        {\n            EventDispatcher child = children.get( localAddr );\n\n            if (child == null)\n                return;\n            child.removeMessageListener(messageListener);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/EventDispatcher.java", "class_name": "EventDispatcher", "class_uri": "src/main/java/org/ice4j/stack/EventDispatcher.java.EventDispatcher", "attributes": {"modifiers": "private synchronized", "marker_annotations": [], "non_marker_annotations": ["private", "synchronized"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nUnregisters a specific <tt>MessageTypeEventHandler</tt> from\nnotifications about STUN messages received at a specific local\n<tt>TransportAddress</tt>.\n\n@param localAddr the local <tt>TransportAddress</tt> STUN messages\nreceived at which to no longer be reported to the specified\n<tt>messageListener</tt>\n@param messageListener the <tt>MessageTypeEventHandler</tt> to be\nunregistered for notifications about STUN messages received at the\nspecified local <tt>TransportAddress</tt>\n"}, {"uris": "src/main/java/org/ice4j/stack/EventDispatcher.java.EventDispatcher.[void]removeRequestListener(RequestListener)", "name": "removeRequestListener", "arg_nums": 1, "params": [{"name": "listener", "type": "RequestListener"}], "return_type": "void", "signature": "public void removeRequestListener(RequestListener listener)", "original_string": "    public void removeRequestListener(RequestListener listener)\n    {\n        removeMessageListener(new RequestListenerMessageEventHandler(listener));\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/EventDispatcher.java", "class_name": "EventDispatcher", "class_uri": "src/main/java/org/ice4j/stack/EventDispatcher.java.EventDispatcher", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nRemove a RquestListener from the listener list.\nThis removes a RequestListener that was registered\nfor all NetAccessPoints and would not remove listeners registered for\nspecific NetAccessPointDescriptors.\n\n@param listener The RequestListener to be removed\n"}, {"uris": "src/main/java/org/ice4j/stack/EventDispatcher.java.EventDispatcher.[void]removeRequestListener(TransportAddress,RequestListener)", "name": "removeRequestListener", "arg_nums": 2, "params": [{"name": "localAddr", "type": "TransportAddress"}, {"name": "listener", "type": "RequestListener"}], "return_type": "void", "signature": "public void removeRequestListener(TransportAddress localAddr,\n                                      RequestListener  listener)", "original_string": "    public void removeRequestListener(TransportAddress localAddr,\n                                      RequestListener  listener)\n    {\n        removeMessageListener(\n                localAddr,\n                new RequestListenerMessageEventHandler(listener));\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/EventDispatcher.java", "class_name": "EventDispatcher", "class_uri": "src/main/java/org/ice4j/stack/EventDispatcher.java.EventDispatcher", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nRemove a RequestListener for a specific NetAccessPointDescriptor. This\nwould only remove the listener for the specified NetAccessPointDescriptor\nand would not remove it if it was also registered as a wildcard listener.\n\n@param localAddr  The NetAPDescriptor that was listened on.\n@param listener  The RequestListener to be removed\n"}, {"uris": "src/main/java/org/ice4j/stack/EventDispatcher.java.EventDispatcher.[void]fireMessageEvent(StunMessageEvent)", "name": "fireMessageEvent", "arg_nums": 1, "params": [{"name": "evt", "type": "StunMessageEvent"}], "return_type": "void", "signature": "public void fireMessageEvent(StunMessageEvent evt)", "original_string": "    public void fireMessageEvent(StunMessageEvent evt)\n    {\n        TransportAddress localAddr = evt.getLocalAddress();\n        MessageTypeEventHandler<?>[] messageListenersCopy;\n\n        synchronized(messageListeners)\n        {\n            messageListenersCopy\n                = messageListeners.toArray(\n                        new MessageTypeEventHandler<?>[\n                                messageListeners.size()]);\n        }\n\n        char messageType = (char) (evt.getMessage().getMessageType() & 0x0110);\n\n        for (MessageTypeEventHandler<?> messageListener : messageListenersCopy)\n        {\n            if (messageType == messageListener.messageType)\n                messageListener.handleMessageEvent(evt);\n        }\n\n        synchronized(children)\n        {\n            EventDispatcher child = children.get(localAddr);\n\n            if (child != null)\n                child.fireMessageEvent(evt);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/EventDispatcher.java", "class_name": "EventDispatcher", "class_uri": "src/main/java/org/ice4j/stack/EventDispatcher.java.EventDispatcher", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nDispatch a StunMessageEvent to any registered listeners.\n\n@param evt  The request event to be delivered.\n"}, {"uris": "src/main/java/org/ice4j/stack/EventDispatcher.java.EventDispatcher.[boolean]hasRequestListeners(TransportAddress)", "name": "hasRequestListeners", "arg_nums": 1, "params": [{"name": "localAddr", "type": "TransportAddress"}], "return_type": "boolean", "signature": "public boolean hasRequestListeners(TransportAddress localAddr)", "original_string": "    public boolean hasRequestListeners(TransportAddress localAddr)\n    {\n        synchronized(messageListeners)\n        {\n            if (!messageListeners.isEmpty())\n            {\n                // there is a generic listener\n                return true;\n            }\n        }\n\n        synchronized(children)\n        {\n            if (!children.isEmpty())\n            {\n                EventDispatcher child = children.get(localAddr);\n\n                if (child != null)\n                    return !child.messageListeners.isEmpty();\n            }\n        }\n\n        return false;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/EventDispatcher.java", "class_name": "EventDispatcher", "class_uri": "src/main/java/org/ice4j/stack/EventDispatcher.java.EventDispatcher", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nCheck if there are any listeners for a specific address.\n(Generic listeners count as well)\n\n@param localAddr the NetAccessPointDescriptor.\n@return true if there are one or more listeners for the specified\nNetAccessPointDescriptor\n"}, {"uris": "src/main/java/org/ice4j/stack/EventDispatcher.java.EventDispatcher.[void]removeAllListeners()", "name": "removeAllListeners", "arg_nums": 0, "params": [], "return_type": "void", "signature": "public void removeAllListeners()", "original_string": "    public void removeAllListeners()\n    {\n        messageListeners.clear();\n        children.clear();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/EventDispatcher.java", "class_name": "EventDispatcher", "class_uri": "src/main/java/org/ice4j/stack/EventDispatcher.java.EventDispatcher", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nRemoves (absolutely all listeners for this event dispatcher).\n"}, {"uris": "src/main/java/org/ice4j/stack/NetAccessManager.java.NetAccessManager.[]NetAccessManager(StunStack)", "name": "NetAccessManager", "arg_nums": 1, "params": [{"name": "stunStack", "type": "StunStack"}], "return_type": "", "signature": "NetAccessManager(StunStack stunStack)", "original_string": "    NetAccessManager(StunStack stunStack)\n    {\n        this(stunStack, null, null);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/NetAccessManager.java", "class_name": "NetAccessManager", "class_uri": "src/main/java/org/ice4j/stack/NetAccessManager.java.NetAccessManager", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "docstring": "\nConstructs a NetAccessManager.\n\n@param stunStack the <tt>StunStack</tt> which is creating the new\ninstance, is going to be its owner and is the handler that incoming\nmessage requests should be passed to\n"}, {"uris": "src/main/java/org/ice4j/stack/NetAccessManager.java.NetAccessManager.[]NetAccessManager(StunStack,PeerUdpMessageEventHandler,ChannelDataEventHandler)", "name": "NetAccessManager", "arg_nums": 3, "params": [{"name": "stunStack", "type": "StunStack"}, {"name": "peerUdpMessageEventHandler", "type": "PeerUdpMessageEventHandler"}, {"name": "channelDataEventHandler", "type": "ChannelDataEventHandler"}], "return_type": "", "signature": "NetAccessManager(StunStack stunStack,\n        PeerUdpMessageEventHandler peerUdpMessageEventHandler,\n        ChannelDataEventHandler channelDataEventHandler)", "original_string": "    NetAccessManager(StunStack stunStack,\n        PeerUdpMessageEventHandler peerUdpMessageEventHandler,\n        ChannelDataEventHandler channelDataEventHandler)\n    {\n        this.stunStack = stunStack;\n        this.messageEventHandler = stunStack;\n        this.peerUdpMessageEventHandler = peerUdpMessageEventHandler;\n        this.channelDataEventHandler = channelDataEventHandler;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/NetAccessManager.java", "class_name": "NetAccessManager", "class_uri": "src/main/java/org/ice4j/stack/NetAccessManager.java.NetAccessManager", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "docstring": "\nConstructs a NetAccessManager with given peerUdpMessageEventHandler and\nchannelDataEventHandler.\n\n@param stunStack the <tt>StunStack</tt> which is creating the new\n           instance, is going to be its owner and is the handler that\n           incoming message requests should be passed to\n@param peerUdpMessageEventHandler the <tt>PeerUdpMessageEventHandler</tt>\n           that will handle incoming UDP messages which are not STUN\n           messages and ChannelData messages.\n@param channelDataEventHandler the <tt>ChannelDataEventHandler</tt> that\n           will handle incoming UDP messages which are ChannelData\n           messages.\n"}, {"uris": "src/main/java/org/ice4j/stack/NetAccessManager.java.NetAccessManager.[MessageEventHandler]getMessageEventHandler()", "name": "getMessageEventHandler", "arg_nums": 0, "params": [], "return_type": "MessageEventHandler", "signature": "MessageEventHandler getMessageEventHandler()", "original_string": "    MessageEventHandler getMessageEventHandler()\n    {\n        return messageEventHandler;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/NetAccessManager.java", "class_name": "NetAccessManager", "class_uri": "src/main/java/org/ice4j/stack/NetAccessManager.java.NetAccessManager", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "MessageEventHandler", "classes": []}, "docstring": "\nGets the <tt>MessageEventHandler</tt> of this <tt>NetAccessManager</tt>\nwhich is to be notified when incoming messages have been processed and\nare ready for delivery.\n\n@return the <tt>MessageEventHandler</tt> of this\n<tt>NetAccessManager</tt> which is to be notified when incoming messages\nhave been processed and are ready for delivery\n"}, {"uris": "src/main/java/org/ice4j/stack/NetAccessManager.java.NetAccessManager.[PeerUdpMessageEventHandler]getUdpMessageEventHandler()", "name": "getUdpMessageEventHandler", "arg_nums": 0, "params": [], "return_type": "PeerUdpMessageEventHandler", "signature": "public PeerUdpMessageEventHandler getUdpMessageEventHandler()", "original_string": "    public PeerUdpMessageEventHandler getUdpMessageEventHandler()\n    {\n        return peerUdpMessageEventHandler;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/NetAccessManager.java", "class_name": "NetAccessManager", "class_uri": "src/main/java/org/ice4j/stack/NetAccessManager.java.NetAccessManager", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "PeerUdpMessageEventHandler", "classes": []}, "docstring": "\nGets the <tt>PeerUdpMessageEventHandler</tt> of this\n<tt>NetAccessManager</tt> which is to be notified when incoming UDP\nmessages have been processed and are ready for delivery.\n\n@return the <tt>PeerUdpMessageEventHandler</tt> of this\n        <tt>NetAccessManager</tt> which is to be notified when incoming\n        UDP messages have been processed and are ready for delivery\n"}, {"uris": "src/main/java/org/ice4j/stack/NetAccessManager.java.NetAccessManager.[ChannelDataEventHandler]getChannelDataMessageEventHandler()", "name": "getChannelDataMessageEventHandler", "arg_nums": 0, "params": [], "return_type": "ChannelDataEventHandler", "signature": "public ChannelDataEventHandler getChannelDataMessageEventHandler()", "original_string": "    public ChannelDataEventHandler getChannelDataMessageEventHandler()\n    {\n        return channelDataEventHandler;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/NetAccessManager.java", "class_name": "NetAccessManager", "class_uri": "src/main/java/org/ice4j/stack/NetAccessManager.java.NetAccessManager", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ChannelDataEventHandler", "classes": []}, "docstring": "\nGets the <tt>ChannelDataEventHandler</tt> of this\n<tt>NetAccessManager</tt> which is to be notified when incoming\nChannelData messages have been processed and are ready for delivery.\n\n@return the <tt>ChannelDataEventHandler</tt> of this\n        <tt>NetAccessManager</tt> which is to be notified when incoming\n        ChannelData messages have been processed and are ready for\n        delivery\n"}, {"uris": "src/main/java/org/ice4j/stack/NetAccessManager.java.NetAccessManager.[StunStack]getStunStack()", "name": "getStunStack", "arg_nums": 0, "params": [], "return_type": "StunStack", "signature": "StunStack getStunStack()", "original_string": "    StunStack getStunStack()\n    {\n        return stunStack;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/NetAccessManager.java", "class_name": "NetAccessManager", "class_uri": "src/main/java/org/ice4j/stack/NetAccessManager.java.NetAccessManager", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "StunStack", "classes": []}, "docstring": "\nGets the <tt>StunStack</tt> which has created this instance and is its\nowner.\n\n@return the <tt>StunStack</tt> which has created this instance and is its\nowner\n"}, {"uris": "src/main/java/org/ice4j/stack/NetAccessManager.java.NetAccessManager.[void]handleError(String,Throwable)", "name": "handleError", "arg_nums": 2, "params": [{"name": "message", "type": "String"}, {"name": "error", "type": "Throwable"}], "return_type": "void", "signature": "@Override\n    public void handleError(String message, Throwable error)", "original_string": "    @Override\n    public void handleError(String message, Throwable error)\n    {\n        if (isStopped.get())\n        {\n            logger.log(Level.WARNING,\n                \"Got error when stopped, ignoring: \" + message, error);\n            return;\n        }\n        /**\n         * apart from logging, i am not sure what else we could do here.\n         */\n        logger.log( Level.FINE,\n                        \"The following error occurred with \"\n                        +\"an incoming message:\",\n                        error);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/NetAccessManager.java", "class_name": "NetAccessManager", "class_uri": "src/main/java/org/ice4j/stack/NetAccessManager.java.NetAccessManager", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nA civilized way of not caring!\n@param message a description of the error\n@param error   the error that has occurred\n"}, {"uris": "src/main/java/org/ice4j/stack/NetAccessManager.java.NetAccessManager.[void]handleFatalError(Runnable,String,Throwable)", "name": "handleFatalError", "arg_nums": 3, "params": [{"name": "callingThread", "type": "Runnable"}, {"name": "message", "type": "String"}, {"name": "error", "type": "Throwable"}], "return_type": "void", "signature": "@Override\n    public void handleFatalError(Runnable callingThread,\n                                 String message,\n                                 Throwable error)", "original_string": "    @Override\n    public void handleFatalError(Runnable callingThread,\n                                 String message,\n                                 Throwable error)\n    {\n        if (isStopped.get())\n        {\n            logger.log(Level.WARNING,\n                \"Got fatal error when stopped, ignoring: \" + message, error);\n            return;\n        }\n\n        if (callingThread instanceof Connector)\n        {\n            Connector connector = (Connector)callingThread;\n\n            //make sure nothing's left and notify user\n            removeSocket(connector.getListenAddress(),\n                         connector.getRemoteAddress());\n            if (error != null)\n            {\n                logger.log(Level.WARNING, \"Removing connector:\" + connector,\n                           error);\n            }\n            else if (logger.isLoggable(Level.FINE))\n            {\n                logger.fine(\"Removing connector \" + connector);\n            }\n        }\n        else\n        {\n            logger.log(Level.SEVERE, message, error);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/NetAccessManager.java", "class_name": "NetAccessManager", "class_uri": "src/main/java/org/ice4j/stack/NetAccessManager.java.NetAccessManager", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nClears the faulty thread and reports the problem.\n\n@param callingThread the thread where the error occurred.\n@param message       A description of the error\n@param error         The error itself\n"}, {"uris": "src/main/java/org/ice4j/stack/NetAccessManager.java.NetAccessManager.[void]addSocket(IceSocketWrapper)", "name": "addSocket", "arg_nums": 1, "params": [{"name": "socket", "type": "IceSocketWrapper"}], "return_type": "void", "signature": "protected void addSocket(IceSocketWrapper socket)", "original_string": "    protected void addSocket(IceSocketWrapper socket)\n    {\n        //no null check - let it through as a NullPointerException\n        Socket tcpSocket  = socket.getTCPSocket();\n\n        TransportAddress remoteAddress = null;\n        if (tcpSocket != null)\n        {\n            // In case of TCP we can extract the remote address from the actual\n            // Socket.\n            remoteAddress\n                = new TransportAddress(tcpSocket.getInetAddress(),\n                                       tcpSocket.getPort(),\n                                       Transport.TCP);\n        }\n\n        addSocket(socket, remoteAddress);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/NetAccessManager.java", "class_name": "NetAccessManager", "class_uri": "src/main/java/org/ice4j/stack/NetAccessManager.java.NetAccessManager", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCreates and starts a new access point based on the specified socket.\nIf the specified access point has already been installed the method\nhas no effect.\n\n@param  socket   the socket that the access point should use.\n"}, {"uris": "src/main/java/org/ice4j/stack/NetAccessManager.java.NetAccessManager.[void]addSocket(IceSocketWrapper,TransportAddress)", "name": "addSocket", "arg_nums": 2, "params": [{"name": "socket", "type": "IceSocketWrapper"}, {"name": "remoteAddress", "type": "TransportAddress"}], "return_type": "void", "signature": "protected void addSocket(IceSocketWrapper socket,\n                             TransportAddress remoteAddress)", "original_string": "    protected void addSocket(IceSocketWrapper socket,\n                             TransportAddress remoteAddress)\n    {\n        Transport transport\n            = socket.getUDPSocket() != null ? Transport.UDP : Transport.TCP;\n        TransportAddress localAddress\n            = new TransportAddress(\n                    socket.getLocalAddress(),\n                    socket.getLocalPort(),\n                    transport);\n\n        final Map<TransportAddress, Map<TransportAddress, Connector>>\n            connectorsMap\n                = (transport == Transport.UDP)\n                ? udpConnectors\n                : tcpConnectors;\n\n        synchronized (connectorsMap)\n        {\n            Map<TransportAddress, Connector> connectorsForLocalAddress\n                = connectorsMap.get(localAddress);\n\n            if (connectorsForLocalAddress == null)\n            {\n                connectorsForLocalAddress = new HashMap<>();\n                connectorsMap.put(localAddress, connectorsForLocalAddress);\n            }\n\n            if (!connectorsForLocalAddress.containsKey(remoteAddress))\n            {\n                Connector connector\n                    = new Connector(\n                        socket,\n                        remoteAddress,\n                        this::onIncomingRawMessage,\n                        this);\n\n                connectorsForLocalAddress.put(remoteAddress, connector);\n                connector.start();\n            }\n            else\n            {\n                logger.info(\"Not creating a new Connector, because we already \"\n                            + \"have one for the given address pair: \"\n                            + localAddress + \" -> \" + remoteAddress);\n            }\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/NetAccessManager.java", "class_name": "NetAccessManager", "class_uri": "src/main/java/org/ice4j/stack/NetAccessManager.java.NetAccessManager", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCreates and starts a new access point based on the specified socket.\nIf the specified access point has already been installed the method\nhas no effect.\n\n@param  socket   the socket that the access point should use.\n@param remoteAddress the remote address of the socket of the\n{@link Connector} to be created if it is a TCP socket, or null if it\nis UDP.\n"}, {"uris": "src/main/java/org/ice4j/stack/NetAccessManager.java.NetAccessManager.[void]removeSocket(TransportAddress,TransportAddress)", "name": "removeSocket", "arg_nums": 2, "params": [{"name": "localAddress", "type": "TransportAddress"}, {"name": "remoteAddress", "type": "TransportAddress"}], "return_type": "void", "signature": "protected void removeSocket(TransportAddress localAddress,\n                                TransportAddress remoteAddress)", "original_string": "    protected void removeSocket(TransportAddress localAddress,\n                                TransportAddress remoteAddress)\n    {\n        Connector connector = null;\n\n        final Map<TransportAddress, Map<TransportAddress, Connector>>\n                connectorsMap\n                = (localAddress.getTransport() == Transport.UDP)\n                ? udpConnectors\n                : tcpConnectors;\n\n        synchronized (connectorsMap)\n        {\n            Map<TransportAddress, Connector> connectorsForLocalAddress\n                    = connectorsMap.get(localAddress);\n\n            if (connectorsForLocalAddress != null)\n            {\n                connector = connectorsForLocalAddress.get(remoteAddress);\n\n                if (connector != null)\n                {\n                    connectorsForLocalAddress.remove(remoteAddress);\n                    if (connectorsForLocalAddress.isEmpty())\n                        connectorsMap.remove(localAddress);\n                }\n            }\n        }\n\n        if (connector != null)\n            connector.stop();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/NetAccessManager.java", "class_name": "NetAccessManager", "class_uri": "src/main/java/org/ice4j/stack/NetAccessManager.java.NetAccessManager", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nStops and deletes the specified access point.\n\n@param localAddress the local address of the connector to remove.\n@param remoteAddress the remote address of the connector to remote. Use\n<tt>null</tt> to match the <tt>Connector</tt> with no specified remote\naddress.\n"}, {"uris": "src/main/java/org/ice4j/stack/NetAccessManager.java.NetAccessManager.[void]stop()", "name": "stop", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@SuppressWarnings(\"unchecked\")\n    public void stop()", "original_string": "    @SuppressWarnings(\"unchecked\")\n    public void stop()\n    {\n        // Mark NetAccessManager as stopped, it will immediately result in\n        // ignoring of all concurrent requests to handle messages\n        isStopped.set(true);\n\n        // no item can be added to {@link #activeTasks} when\n        // NetAccessManager is stopped, so it is safe to iterate without\n        // removing item in-place.\n        for (MessageProcessingTask messageProcessingTask : activeTasks)\n        {\n            messageProcessingTask.cancel();\n        }\n        activeTasks.clear();\n\n        for (Object o : new Object[]{udpConnectors, tcpConnectors})\n        {\n            Map<TransportAddress, Map<TransportAddress, Connector>>\n                connectorsMap\n                    = (Map<TransportAddress, Map<TransportAddress, Connector>>)o;\n\n            synchronized (connectorsMap)\n            {\n                for (Map<TransportAddress, Connector> connectorsForLocalAddress\n                        : connectorsMap.values())\n                {\n                    for (Connector connector : connectorsForLocalAddress.values())\n                    {\n                        connector.stop();\n                    }\n                }\n            }\n\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/NetAccessManager.java", "class_name": "NetAccessManager", "class_uri": "src/main/java/org/ice4j/stack/NetAccessManager.java.NetAccessManager", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n    public", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nStops <tt>NetAccessManager</tt> and all of its active\n<tt>MessageProcessingTask</tt>.\n"}, {"uris": "src/main/java/org/ice4j/stack/NetAccessManager.java.NetAccessManager.[Connector]getConnector(TransportAddress,TransportAddress)", "name": "getConnector", "arg_nums": 2, "params": [{"name": "localAddress", "type": "TransportAddress"}, {"name": "remoteAddress", "type": "TransportAddress"}], "return_type": "Connector", "signature": "private Connector getConnector(TransportAddress localAddress,\n                                   TransportAddress remoteAddress)", "original_string": "    private Connector getConnector(TransportAddress localAddress,\n                                   TransportAddress remoteAddress)\n    {\n        boolean udp = localAddress.getTransport() == Transport.UDP;\n        final Map<TransportAddress, Map<TransportAddress, Connector>>\n                connectorsMap\n                = udp\n                ? udpConnectors\n                : tcpConnectors;\n        Connector connector = null;\n\n        synchronized (connectorsMap)\n        {\n            Map<TransportAddress, Connector> connectorsForLocalAddress\n                    = connectorsMap.get(localAddress);\n\n            if (connectorsForLocalAddress != null)\n            {\n                connector = connectorsForLocalAddress.get(remoteAddress);\n\n                // Fallback to the socket with no specific remote address\n                if (udp && connector == null)\n                    connector = connectorsForLocalAddress.get(null);\n            }\n        }\n\n        return connector;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/NetAccessManager.java", "class_name": "NetAccessManager", "class_uri": "src/main/java/org/ice4j/stack/NetAccessManager.java.NetAccessManager", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Connector", "classes": []}, "docstring": "\nReturns the <tt>Connector</tt> responsible for a particular source\naddress and a particular destination address.\n\n@param localAddress the source address.\n@param remoteAddress the destination address.\nReturns the <tt>Connector</tt> responsible for a particular source\naddress and a particular destination address, or <tt>null</tt> if there's\nnone.\n"}, {"uris": "src/main/java/org/ice4j/stack/NetAccessManager.java.NetAccessManager.[void]onIncomingRawMessage(RawMessage)", "name": "onIncomingRawMessage", "arg_nums": 1, "params": [{"name": "message", "type": "RawMessage"}], "return_type": "void", "signature": "private void onIncomingRawMessage(final RawMessage message)", "original_string": "    private void onIncomingRawMessage(final RawMessage message)\n    {\n        if (isStopped.get())\n        {\n            logger.fine(\"Got RawMessage when stopped, ignore it.\");\n            return;\n        }\n\n        MessageProcessingTask messageProcessingTask\n            = taskPool.poll();\n        if (messageProcessingTask == null)\n        {\n            messageProcessingTask\n                = new MessageProcessingTask(this);\n            if (logger.isLoggable(Level.FINEST))\n            {\n                logger.finest(\"Allocated new MessageProcessingTask for \"\n                    + this + \" due to absence of available pooled instances\");\n            }\n        }\n        else\n        {\n            messageProcessingTask.resetState();\n        }\n\n        messageProcessingTask.setMessage(message, onRawMessageProcessed);\n\n        activeTasks.add(messageProcessingTask);\n\n        // Use overload which does not return Future object to avoid\n        // unnecessary allocation\n        messageProcessingExecutor.execute(messageProcessingTask);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/NetAccessManager.java", "class_name": "NetAccessManager", "class_uri": "src/main/java/org/ice4j/stack/NetAccessManager.java.NetAccessManager", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nEnqueues incoming {@link RawMessage} for asynchronous\nprocessing by {@link #messageProcessingExecutor}\n@param message <tt>RawMessage</tt> to process\n"}, {"uris": "src/main/java/org/ice4j/stack/NetAccessManager.java.NetAccessManager.[void]sendMessage(Message,TransportAddress,TransportAddress)", "name": "sendMessage", "arg_nums": 3, "params": [{"name": "stunMessage", "type": "Message"}, {"name": "srcAddr", "type": "TransportAddress"}, {"name": "remoteAddr", "type": "TransportAddress"}], "return_type": "void", "signature": "void sendMessage(\n            Message stunMessage,\n            TransportAddress srcAddr,\n            TransportAddress remoteAddr)", "original_string": "    void sendMessage(\n            Message stunMessage,\n            TransportAddress srcAddr,\n            TransportAddress remoteAddr)\n        throws IllegalArgumentException,\n               IOException\n    {\n        sendMessage(stunMessage.encode(stunStack), srcAddr, remoteAddr);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/NetAccessManager.java", "class_name": "NetAccessManager", "class_uri": "src/main/java/org/ice4j/stack/NetAccessManager.java.NetAccessManager", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSends the specified stun message through the specified access point.\n\n@param stunMessage the message to send\n@param srcAddr the access point to use to send the message\n@param remoteAddr the destination of the message.\n\n@throws IllegalArgumentException if the apDescriptor references an\naccess point that had not been installed,\n@throws IOException  if an error occurs while sending message bytes\nthrough the network socket.\n"}, {"uris": "src/main/java/org/ice4j/stack/NetAccessManager.java.NetAccessManager.[void]sendMessage(ChannelData,TransportAddress,TransportAddress)", "name": "sendMessage", "arg_nums": 3, "params": [{"name": "channelData", "type": "ChannelData"}, {"name": "srcAddr", "type": "TransportAddress"}, {"name": "remoteAddr", "type": "TransportAddress"}], "return_type": "void", "signature": "void sendMessage(\n            ChannelData channelData,\n            TransportAddress srcAddr,\n            TransportAddress remoteAddr)", "original_string": "    void sendMessage(\n            ChannelData channelData,\n            TransportAddress srcAddr,\n            TransportAddress remoteAddr)\n        throws IllegalArgumentException,\n               IOException, StunException\n    {\n        boolean pad = srcAddr.getTransport() == Transport.TCP\n            || srcAddr.getTransport() == Transport.TLS;\n        sendMessage(channelData.encode(pad), srcAddr, remoteAddr);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/NetAccessManager.java", "class_name": "NetAccessManager", "class_uri": "src/main/java/org/ice4j/stack/NetAccessManager.java.NetAccessManager", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSends the specified stun message through the specified access point.\n\n@param channelData the message to send\n@param srcAddr the access point to use to send the message\n@param remoteAddr the destination of the message.\n\n@throws IllegalArgumentException if the apDescriptor references an\naccess point that had not been installed,\n@throws IOException  if an error occurs while sending message bytes\nthrough the network socket.\n@throws StunException \n"}, {"uris": "src/main/java/org/ice4j/stack/NetAccessManager.java.NetAccessManager.[void]sendMessage(byte[],TransportAddress,TransportAddress)", "name": "sendMessage", "arg_nums": 3, "params": [{"name": "bytes", "type": "byte[]"}, {"name": "srcAddr", "type": "TransportAddress"}, {"name": "remoteAddr", "type": "TransportAddress"}], "return_type": "void", "signature": "void sendMessage(\n            byte[] bytes,\n            TransportAddress srcAddr,\n            TransportAddress remoteAddr)", "original_string": "    void sendMessage(\n            byte[] bytes,\n            TransportAddress srcAddr,\n            TransportAddress remoteAddr)\n        throws IllegalArgumentException,\n               IOException\n    {\n        Connector ap = getConnector(srcAddr, remoteAddr);\n        if (ap == null)\n        {\n            throw new SocketNotFoundException(\"No socket found for \" + srcAddr + \"->\" + remoteAddr);\n        }\n\n        ap.sendMessage(bytes, remoteAddr);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/NetAccessManager.java", "class_name": "NetAccessManager", "class_uri": "src/main/java/org/ice4j/stack/NetAccessManager.java.NetAccessManager", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSends the specified bytes through the specified access point.\n\n@param bytes the bytes to send.\n@param srcAddr the access point to use to send the bytes.\n@param remoteAddr the destination of the message.\n\n@throws IllegalArgumentException if the apDescriptor references an\naccess point that had not been installed,\n@throws IOException  if an error occurs while sending message bytes\nthrough the network socket.\n"}, {"uris": "src/main/java/org/ice4j/stack/StunClientTransaction.java.StunClientTransaction.[]StunClientTransaction(StunStack,Request,TransportAddress,TransportAddress,ResponseCollector)", "name": "StunClientTransaction", "arg_nums": 5, "params": [{"name": "stackCallback", "type": "StunStack"}, {"name": "request", "type": "Request"}, {"name": "requestDestination", "type": "TransportAddress"}, {"name": "localAddress", "type": "TransportAddress"}, {"name": "responseCollector", "type": "ResponseCollector"}], "return_type": "", "signature": "public StunClientTransaction(StunStack         stackCallback,\n                                 Request           request,\n                                 TransportAddress  requestDestination,\n                                 TransportAddress  localAddress,\n                                 ResponseCollector responseCollector)", "original_string": "    public StunClientTransaction(StunStack         stackCallback,\n                                 Request           request,\n                                 TransportAddress  requestDestination,\n                                 TransportAddress  localAddress,\n                                 ResponseCollector responseCollector)\n    {\n        this(stackCallback,\n             request,\n             requestDestination,\n             localAddress,\n             responseCollector,\n             TransactionID.createNewTransactionID());\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/StunClientTransaction.java", "class_name": "StunClientTransaction", "class_uri": "src/main/java/org/ice4j/stack/StunClientTransaction.java.StunClientTransaction", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nCreates a client transaction.\n\n@param stackCallback the stack that created us.\n@param request the request that we are living for.\n@param requestDestination the destination of the request.\n@param localAddress the local <tt>TransportAddress</tt> this transaction\nwill be communication through.\n@param responseCollector the instance that should receive this request's\nresponse retransmit.\n"}, {"uris": "src/main/java/org/ice4j/stack/StunClientTransaction.java.StunClientTransaction.[]StunClientTransaction(StunStack,Request,TransportAddress,TransportAddress,ResponseCollector,TransactionID)", "name": "StunClientTransaction", "arg_nums": 6, "params": [{"name": "stackCallback", "type": "StunStack"}, {"name": "request", "type": "Request"}, {"name": "requestDestination", "type": "TransportAddress"}, {"name": "localAddress", "type": "TransportAddress"}, {"name": "responseCollector", "type": "ResponseCollector"}, {"name": "transactionID", "type": "TransactionID"}], "return_type": "", "signature": "public StunClientTransaction(StunStack         stackCallback,\n                                 Request           request,\n                                 TransportAddress  requestDestination,\n                                 TransportAddress  localAddress,\n                                 ResponseCollector responseCollector,\n                                 TransactionID     transactionID)", "original_string": "    public StunClientTransaction(StunStack         stackCallback,\n                                 Request           request,\n                                 TransportAddress  requestDestination,\n                                 TransportAddress  localAddress,\n                                 ResponseCollector responseCollector,\n                                 TransactionID     transactionID)\n    {\n        this.stackCallback      = stackCallback;\n        this.request            = request;\n        this.localAddress       = localAddress;\n        this.responseCollector  = responseCollector;\n        this.requestDestination = requestDestination;\n\n        initTransactionConfiguration();\n\n        retransmitter = new Retransmitter(); // create it here to support 'originalWaitInterval' configuration\n\n        this.transactionID = transactionID;\n\n        try\n        {\n            request.setTransactionID(transactionID.getBytes());\n        }\n        catch (StunException ex)\n        {\n            // Shouldn't happen so lets just throw a RuntimeException in case\n            // something is really messed up.\n            throw new IllegalArgumentException(\n                    \"The TransactionID class generated an invalid transaction\"\n                        + \" ID\");\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/StunClientTransaction.java", "class_name": "StunClientTransaction", "class_uri": "src/main/java/org/ice4j/stack/StunClientTransaction.java.StunClientTransaction", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nCreates a client transaction.\n\n@param stackCallback the stack that created us.\n@param request the request that we are living for.\n@param requestDestination the destination of the request.\n@param localAddress the local <tt>TransportAddress</tt> this transaction\nwill be communication through.\n@param responseCollector the instance that should receive this request's\nresponse retransmit.\n@param transactionID the ID that we'd like the new transaction to have\nin case the application created it in order to use it for application\ndata correlation.\n"}, {"uris": "src/main/java/org/ice4j/stack/StunClientTransaction.java.StunClientTransaction.[void]sendRequest()", "name": "sendRequest", "arg_nums": 0, "params": [], "return_type": "void", "signature": "void sendRequest()", "original_string": "    void sendRequest()\n        throws IllegalArgumentException, IOException\n    {\n        logger.fine(\n                \"sending STUN \" + \" tid \" + transactionID + \" from \"\n                    + localAddress + \" to \" + requestDestination);\n        sendRequest0();\n\n        this.retransmitter.schedule();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/StunClientTransaction.java", "class_name": "StunClientTransaction", "class_uri": "src/main/java/org/ice4j/stack/StunClientTransaction.java.StunClientTransaction", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSends the request and schedules the first retransmission for after\n{@link #originalWaitInterval} and thus starts the retransmission\nalgorithm.\n\n@throws IOException  if an error occurs while sending message bytes\nthrough the network socket.\n@throws IllegalArgumentException if the apDescriptor references an\naccess point that had not been installed\n\n"}, {"uris": "src/main/java/org/ice4j/stack/StunClientTransaction.java.StunClientTransaction.[void]sendRequest0()", "name": "sendRequest0", "arg_nums": 0, "params": [], "return_type": "void", "signature": "private void sendRequest0()", "original_string": "    private void sendRequest0()\n        throws IllegalArgumentException, IOException\n    {\n        if (cancelled.get())\n        {\n            logger.finer(\"Trying to resend a cancelled transaction.\");\n        }\n        else\n        {\n            stackCallback.getNetAccessManager().sendMessage(\n                    this.request,\n                    localAddress,\n                    requestDestination);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/StunClientTransaction.java", "class_name": "StunClientTransaction", "class_uri": "src/main/java/org/ice4j/stack/StunClientTransaction.java.StunClientTransaction", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSimply calls the sendMessage method of the accessmanager.\n\n@throws IOException  if an error occurs while sending message bytes\nthrough the network socket.\n@throws IllegalArgumentException if the apDescriptor references an\naccess point that had not been installed,\n"}, {"uris": "src/main/java/org/ice4j/stack/StunClientTransaction.java.StunClientTransaction.[Request]getRequest()", "name": "getRequest", "arg_nums": 0, "params": [], "return_type": "Request", "signature": "Request getRequest()", "original_string": "    Request getRequest()\n    {\n        return this.request;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/StunClientTransaction.java", "class_name": "StunClientTransaction", "class_uri": "src/main/java/org/ice4j/stack/StunClientTransaction.java.StunClientTransaction", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Request", "classes": []}, "docstring": "\nReturns the request that was the reason for creating this transaction.\n\n@return the request that was the reason for creating this transaction.\n"}, {"uris": "src/main/java/org/ice4j/stack/StunClientTransaction.java.StunClientTransaction.[void]cancel()", "name": "cancel", "arg_nums": 0, "params": [], "return_type": "void", "signature": "void cancel()", "original_string": "    void cancel()\n    {\n        // The cancelled field is initialized to false and then the one and\n        // only write access to it is here to set it to true. The rest of the\n        // code just checks whether it has become true.\n        cancelled.set(true);\n\n        this.retransmitter.cancel();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/StunClientTransaction.java", "class_name": "StunClientTransaction", "class_uri": "src/main/java/org/ice4j/stack/StunClientTransaction.java.StunClientTransaction", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCancels the transaction. Once this method is called the transaction is\nconsidered terminated and will stop retransmissions.\n"}, {"uris": "src/main/java/org/ice4j/stack/StunClientTransaction.java.StunClientTransaction.[void]handleResponse(StunMessageEvent)", "name": "handleResponse", "arg_nums": 1, "params": [{"name": "evt", "type": "StunMessageEvent"}], "return_type": "void", "signature": "public void handleResponse(StunMessageEvent evt)", "original_string": "    public void handleResponse(StunMessageEvent evt)\n    {\n        TransactionID transactionID = getTransactionID();\n\n        logger.fine(\"handleResponse tid \" + transactionID);\n        if (!Boolean.getBoolean(StackProperties.KEEP_CRANS_AFTER_A_RESPONSE))\n        {\n            cancel();\n        }\n\n        responseCollector.processResponse(\n            new StunResponseEvent(\n                stackCallback,\n                evt.getRawMessage(),\n                (Response) evt.getMessage(),\n                request,\n                transactionID));\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/StunClientTransaction.java", "class_name": "StunClientTransaction", "class_uri": "src/main/java/org/ice4j/stack/StunClientTransaction.java.StunClientTransaction", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nDispatches the response then cancels itself and notifies the StunStack\nfor its termination.\n\n@param evt the event that contains the newly received message\n"}, {"uris": "src/main/java/org/ice4j/stack/StunClientTransaction.java.StunClientTransaction.[TransactionID]getTransactionID()", "name": "getTransactionID", "arg_nums": 0, "params": [], "return_type": "TransactionID", "signature": "TransactionID getTransactionID()", "original_string": "    TransactionID getTransactionID()\n    {\n        return this.transactionID;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/StunClientTransaction.java", "class_name": "StunClientTransaction", "class_uri": "src/main/java/org/ice4j/stack/StunClientTransaction.java.StunClientTransaction", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "TransactionID", "classes": []}, "docstring": "\nReturns the ID of the current transaction.\n\n@return the ID of the transaction.\n"}, {"uris": "src/main/java/org/ice4j/stack/StunClientTransaction.java.StunClientTransaction.[void]initTransactionConfiguration()", "name": "initTransactionConfiguration", "arg_nums": 0, "params": [], "return_type": "void", "signature": "private void initTransactionConfiguration()", "original_string": "    private void initTransactionConfiguration()\n    {\n        //Max Retransmissions\n        String maxRetransmissionsStr\n            = System.getProperty(StackProperties.MAX_CTRAN_RETRANSMISSIONS);\n\n        if (maxRetransmissionsStr != null\n                && maxRetransmissionsStr.trim().length() > 0)\n        {\n            try\n            {\n                maxRetransmissions = Integer.parseInt(maxRetransmissionsStr);\n            }\n            catch (NumberFormatException e)\n            {\n                logger.log(Level.FINE,\n                           \"Failed to parse MAX_RETRANSMISSIONS\",\n                           e);\n                maxRetransmissions = DEFAULT_MAX_RETRANSMISSIONS;\n            }\n        }\n\n        //Original Wait Interval\n        String originalWaitIntervalStr\n            = System.getProperty(StackProperties.FIRST_CTRAN_RETRANS_AFTER);\n\n        if (originalWaitIntervalStr != null\n                && originalWaitIntervalStr.trim().length() > 0)\n        {\n            try\n            {\n                originalWaitInterval\n                    = Integer.parseInt(originalWaitIntervalStr);\n            }\n            catch (NumberFormatException e)\n            {\n                logger.log(Level.FINE,\n                           \"Failed to parse ORIGINAL_WAIT_INTERVAL\",\n                           e);\n                originalWaitInterval = DEFAULT_ORIGINAL_WAIT_INTERVAL;\n            }\n        }\n\n        //Max Wait Interval\n        String maxWaitIntervalStr\n                = System.getProperty(StackProperties.MAX_CTRAN_RETRANS_TIMER);\n\n        if (maxWaitIntervalStr != null\n                && maxWaitIntervalStr.trim().length() > 0)\n        {\n            try\n            {\n                maxWaitInterval = Integer.parseInt(maxWaitIntervalStr);\n            }\n            catch (NumberFormatException e)\n            {\n                logger.log(Level.FINE, \"Failed to parse MAX_WAIT_INTERVAL\", e);\n                maxWaitInterval = DEFAULT_MAX_WAIT_INTERVAL;\n            }\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/StunClientTransaction.java", "class_name": "StunClientTransaction", "class_uri": "src/main/java/org/ice4j/stack/StunClientTransaction.java.StunClientTransaction", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nInit transaction duration/retransmission parameters. (Mostly contributed\nby Pascal Maugeri.)\n"}, {"uris": "src/main/java/org/ice4j/stack/StunClientTransaction.java.StunClientTransaction.[TransportAddress]getLocalAddress()", "name": "getLocalAddress", "arg_nums": 0, "params": [], "return_type": "TransportAddress", "signature": "public TransportAddress getLocalAddress()", "original_string": "    public TransportAddress getLocalAddress()\n    {\n        return localAddress;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/StunClientTransaction.java", "class_name": "StunClientTransaction", "class_uri": "src/main/java/org/ice4j/stack/StunClientTransaction.java.StunClientTransaction", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "TransportAddress", "classes": []}, "docstring": "\nReturns the local <tt>TransportAddress</tt> that this transaction is\nsending requests from.\n\n@return  the local <tt>TransportAddress</tt> that this transaction is\nsending requests from.\n"}, {"uris": "src/main/java/org/ice4j/stack/StunClientTransaction.java.StunClientTransaction.[TransportAddress]getRemoteAddress()", "name": "getRemoteAddress", "arg_nums": 0, "params": [], "return_type": "TransportAddress", "signature": "public TransportAddress getRemoteAddress()", "original_string": "    public TransportAddress getRemoteAddress()\n    {\n        return requestDestination;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/StunClientTransaction.java", "class_name": "StunClientTransaction", "class_uri": "src/main/java/org/ice4j/stack/StunClientTransaction.java.StunClientTransaction", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "TransportAddress", "classes": []}, "docstring": "\nReturns the remote <tt>TransportAddress</tt> that this transaction is\nsending requests to.\n\n@return the remote <tt>TransportAddress</tt> that this transaction is\nsending requests to.\n"}, {"uris": "src/main/java/org/ice4j/stack/MessageEventHandler.java.MessageEventHandler.[void]handleMessageEvent(StunMessageEvent)", "name": "handleMessageEvent", "arg_nums": 1, "params": [{"name": "evt", "type": "StunMessageEvent"}], "return_type": "void", "signature": "public void handleMessageEvent(StunMessageEvent evt)", "original_string": "    public void handleMessageEvent(StunMessageEvent evt);", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/MessageEventHandler.java", "class_name": "MessageEventHandler", "class_uri": "src/main/java/org/ice4j/stack/MessageEventHandler.java.MessageEventHandler", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCalled when an incoming message has been received, parsed and is ready\nfor delivery.\n@param evt the Event object that encapsulates the newly received message.\n"}, {"uris": "src/main/java/org/ice4j/stack/RawMessage.java.RawMessage.[]RawMessage(byte[],int,TransportAddress,TransportAddress)", "name": "RawMessage", "arg_nums": 4, "params": [{"name": "messageBytes", "type": "byte[]"}, {"name": "messageLength", "type": "int"}, {"name": "remoteAddress", "type": "TransportAddress"}, {"name": "localAddress", "type": "TransportAddress"}], "return_type": "", "signature": "RawMessage(byte[]           messageBytes,\n               int              messageLength,\n               TransportAddress remoteAddress,\n               TransportAddress localAddress)", "original_string": "    RawMessage(byte[]           messageBytes,\n               int              messageLength,\n               TransportAddress remoteAddress,\n               TransportAddress localAddress)\n    {\n        /*\n         * Let NullPointerException go out.\n         * \n         * The length of the array messgeBytes may be enormous while\n         * messageLength may be tiny so it does not make sense to clone\n         * messageBytes.\n         */\n        this.messageBytes  = new byte[messageLength];\n        System.arraycopy(messageBytes, 0, this.messageBytes, 0, messageLength);\n        this.messageLength = messageLength;\n        this.localAddress  = localAddress;\n        this.remoteAddress = remoteAddress;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/RawMessage.java", "class_name": "RawMessage", "class_uri": "src/main/java/org/ice4j/stack/RawMessage.java.RawMessage", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "docstring": "\nConstructs a raw message with the specified field values. All parameters\nare cloned before being assigned to class members.\n\n@param messageBytes the message itself.\n@param messageLength the number of bytes currently stored in the\n<tt>messageBytes</tt> array.\n@param remoteAddress the address where the message came from.\n@param localAddress the <tt>TransportAddress</tt> that the message was\nreceived on.\n\n@throws NullPointerException if one or more of the parameters were null.\n"}, {"uris": "src/main/java/org/ice4j/stack/RawMessage.java.RawMessage.[byte[]]getBytes()", "name": "getBytes", "arg_nums": 0, "params": [], "return_type": "byte[]", "signature": "public byte[] getBytes()", "original_string": "    public byte[] getBytes()\n    {\n        return messageBytes;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/RawMessage.java", "class_name": "RawMessage", "class_uri": "src/main/java/org/ice4j/stack/RawMessage.java.RawMessage", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "byte[]", "classes": []}, "docstring": "\nReturns the message itself.\n\n@return a binary array containing the message data.\n"}, {"uris": "src/main/java/org/ice4j/stack/RawMessage.java.RawMessage.[int]getMessageLength()", "name": "getMessageLength", "arg_nums": 0, "params": [], "return_type": "int", "signature": "public int getMessageLength()", "original_string": "    public int getMessageLength()\n    {\n        return messageLength;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/RawMessage.java", "class_name": "RawMessage", "class_uri": "src/main/java/org/ice4j/stack/RawMessage.java.RawMessage", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\nReturns the message length.\n\n@return a the length of the message.\n"}, {"uris": "src/main/java/org/ice4j/stack/RawMessage.java.RawMessage.[TransportAddress]getRemoteAddress()", "name": "getRemoteAddress", "arg_nums": 0, "params": [], "return_type": "TransportAddress", "signature": "public TransportAddress getRemoteAddress()", "original_string": "    public TransportAddress getRemoteAddress()\n    {\n        return this.remoteAddress;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/RawMessage.java", "class_name": "RawMessage", "class_uri": "src/main/java/org/ice4j/stack/RawMessage.java.RawMessage", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "TransportAddress", "classes": []}, "docstring": "\nReturns the address and port of the host that sent the message\n\n@return the [address]:[port] pair that sent the message.\n"}, {"uris": "src/main/java/org/ice4j/stack/RawMessage.java.RawMessage.[TransportAddress]getLocalAddress()", "name": "getLocalAddress", "arg_nums": 0, "params": [], "return_type": "TransportAddress", "signature": "public TransportAddress getLocalAddress()", "original_string": "    public TransportAddress getLocalAddress()\n    {\n        return localAddress;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/RawMessage.java", "class_name": "RawMessage", "class_uri": "src/main/java/org/ice4j/stack/RawMessage.java.RawMessage", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "TransportAddress", "classes": []}, "docstring": "\nReturns the address that this message was received on.\n\n@return the address that this message was received on.\n"}, {"uris": "src/main/java/org/ice4j/stack/RawMessage.java.RawMessage.[RawMessage]build(byte[],int,TransportAddress,TransportAddress)", "name": "build", "arg_nums": 4, "params": [{"name": "messageBytes", "type": "byte[]"}, {"name": "messageLength", "type": "int"}, {"name": "remoteAddress", "type": "TransportAddress"}, {"name": "localAddress", "type": "TransportAddress"}], "return_type": "RawMessage", "signature": "public static RawMessage build(byte[] messageBytes, int messageLength,\n        TransportAddress remoteAddress, TransportAddress localAddress)", "original_string": "    public static RawMessage build(byte[] messageBytes, int messageLength,\n        TransportAddress remoteAddress, TransportAddress localAddress)\n    {\n        return new RawMessage(messageBytes, messageLength, remoteAddress,\n            localAddress);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/RawMessage.java", "class_name": "RawMessage", "class_uri": "src/main/java/org/ice4j/stack/RawMessage.java.RawMessage", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "RawMessage", "classes": []}, "docstring": "\nUse builder pattern to allow creation of immutable RawMessage instances,\nfrom outside the current package.\n\n@param messageBytes the message itself.\n@param messageLength the number of bytes currently stored in the\n<tt>messageBytes</tt> array.\n@param remoteAddress the address where the message came from.\n@param localAddress the <tt>TransportAddress</tt> that the message was\nreceived on.\n@return RawMessage instance\n"}, {"uris": "src/main/java/org/ice4j/stack/MessageProcessingTask.java.MessageProcessingTask.[]MessageProcessingTask(NetAccessManager)", "name": "MessageProcessingTask", "arg_nums": 1, "params": [{"name": "netAccessManager", "type": "NetAccessManager"}], "return_type": "", "signature": "MessageProcessingTask(NetAccessManager netAccessManager)", "original_string": "    MessageProcessingTask(NetAccessManager netAccessManager)\n        throws IllegalArgumentException\n    {\n        if (netAccessManager == null)\n        {\n            throw new NullPointerException(\"netAccessManager\");\n        }\n\n        MessageEventHandler messageEventHandler\n            = netAccessManager.getMessageEventHandler();\n\n        if (messageEventHandler == null)\n        {\n            throw new IllegalArgumentException(\n                \"The message event handler may not be null\");\n        }\n\n        this.netAccessManager = netAccessManager;\n        this.messageEventHandler = messageEventHandler;\n        this.errorHandler = netAccessManager;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/MessageProcessingTask.java", "class_name": "MessageProcessingTask", "class_uri": "src/main/java/org/ice4j/stack/MessageProcessingTask.java.MessageProcessingTask", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "docstring": "\nCreates a Message processor.\n\n@param netAccessManager the <tt>NetAccessManager</tt> which is creating\nthe new instance, is going to be its owner, specifies the\n<tt>MessageEventHandler</tt> and represents the <tt>ErrorHandler</tt> to\nhandle exceptions in the new instance\n@throws IllegalArgumentException if any of the mentioned properties of\n<tt>netAccessManager</tt> are <tt>null</tt>\n"}, {"uris": "src/main/java/org/ice4j/stack/MessageProcessingTask.java.MessageProcessingTask.[void]setMessage(RawMessage,Consumer<MessageProcessingTask>)", "name": "setMessage", "arg_nums": 2, "params": [{"name": "message", "type": "RawMessage"}, {"name": "onProcessed", "type": "Consumer<MessageProcessingTask>"}], "return_type": "void", "signature": "void setMessage(\n        RawMessage message,\n        Consumer<MessageProcessingTask> onProcessed)", "original_string": "    void setMessage(\n        RawMessage message,\n        Consumer<MessageProcessingTask> onProcessed)\n    {\n        if (message == null)\n        {\n            throw new IllegalArgumentException(\"The message may not be null\");\n        }\n        rawMessage = message;\n        rawMessageProcessedHandler = onProcessed;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/MessageProcessingTask.java", "class_name": "MessageProcessingTask", "class_uri": "src/main/java/org/ice4j/stack/MessageProcessingTask.java.MessageProcessingTask", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nAssigns the <tt>RawMessage</tt> that will be processed\nby this <tt>MessageProcessingTask</tt> on executor's thread.\n@param message RawMessage to be processed\n@param onProcessed callback which will be invoked when processing\nof {@link #rawMessage} is completed\n"}, {"uris": "src/main/java/org/ice4j/stack/MessageProcessingTask.java.MessageProcessingTask.[void]resetState()", "name": "resetState", "arg_nums": 0, "params": [], "return_type": "void", "signature": "void resetState()", "original_string": "    void resetState()\n    {\n        cancelled.set(false);\n        rawMessage = null;\n        rawMessageProcessedHandler = null;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/MessageProcessingTask.java", "class_name": "MessageProcessingTask", "class_uri": "src/main/java/org/ice4j/stack/MessageProcessingTask.java.MessageProcessingTask", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nPerforms proper reset of internal state of pooled instance.\n"}, {"uris": "src/main/java/org/ice4j/stack/MessageProcessingTask.java.MessageProcessingTask.[void]cancel()", "name": "cancel", "arg_nums": 0, "params": [], "return_type": "void", "signature": "public void cancel()", "original_string": "    public void cancel()\n    {\n        cancelled.set(true);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/MessageProcessingTask.java", "class_name": "MessageProcessingTask", "class_uri": "src/main/java/org/ice4j/stack/MessageProcessingTask.java.MessageProcessingTask", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nAttempts to cancel processing of {@link #rawMessage}\n"}, {"uris": "src/main/java/org/ice4j/stack/MessageProcessingTask.java.MessageProcessingTask.[void]run()", "name": "run", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Override\n    public void run()", "original_string": "    @Override\n    public void run()\n    {\n        final Consumer<MessageProcessingTask> onProcessed\n            = rawMessageProcessedHandler;\n        final RawMessage message = rawMessage;\n        //add an extra try/catch block that handles uncatched errors\n        try\n        {\n            if (message == null)\n            {\n                return;\n            }\n            rawMessage = null;\n            rawMessageProcessedHandler = null;\n\n            if (cancelled.get())\n            {\n                return;\n            }\n\n            StunStack stunStack = netAccessManager.getStunStack();\n\n            Message stunMessage;\n            try\n            {\n                stunMessage\n                    = Message.decode(message.getBytes(),\n                                     0,\n                                     message.getMessageLength());\n            }\n            catch (StunException ex)\n            {\n                errorHandler.handleError(\n                    \"Failed to decode a stun message!\",\n                    ex);\n                    return;\n            }\n\n            logger.finest(\"Dispatching a StunMessageEvent.\");\n\n            StunMessageEvent stunMessageEvent\n                = new StunMessageEvent(stunStack, message, stunMessage);\n\n            messageEventHandler.handleMessageEvent(stunMessageEvent);\n        }\n        catch (Throwable err)\n        {\n            errorHandler.handleFatalError(\n                Thread.currentThread(),\n                \"Unexpected Error!\", err);\n        }\n        finally\n        {\n            // On processed callback must be invoked in all cases, even when\n            // cancellation or early exist happen, otherwise\n            // NetAccessManager internal tracking of pooled and active\n            // message processors will misbehave.\n            if (onProcessed != null)\n            {\n                onProcessed.accept(this);\n            }\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/MessageProcessingTask.java", "class_name": "MessageProcessingTask", "class_uri": "src/main/java/org/ice4j/stack/MessageProcessingTask.java.MessageProcessingTask", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nDoes the message parsing.\n"}, {"uris": "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[void]addSocket(IceSocketWrapper)", "name": "addSocket", "arg_nums": 1, "params": [{"name": "sock", "type": "IceSocketWrapper"}], "return_type": "void", "signature": "public void addSocket(IceSocketWrapper sock)", "original_string": "    public void addSocket(IceSocketWrapper sock)\n    {\n        netAccessManager.addSocket(sock);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/StunStack.java", "class_name": "StunStack", "class_uri": "src/main/java/org/ice4j/stack/StunStack.java.StunStack", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCreates and starts a Network Access Point (Connector) based on the\nspecified socket.\n\n@param sock The socket that the new access point should represent.\n"}, {"uris": "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[void]addSocket(IceSocketWrapper,TransportAddress)", "name": "addSocket", "arg_nums": 2, "params": [{"name": "sock", "type": "IceSocketWrapper"}, {"name": "remoteAddress", "type": "TransportAddress"}], "return_type": "void", "signature": "public void addSocket(IceSocketWrapper sock, TransportAddress remoteAddress)", "original_string": "    public void addSocket(IceSocketWrapper sock, TransportAddress remoteAddress)\n    {\n        netAccessManager.addSocket(sock, remoteAddress);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/StunStack.java", "class_name": "StunStack", "class_uri": "src/main/java/org/ice4j/stack/StunStack.java.StunStack", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCreates and starts a Network Access Point (Connector) based on the\nspecified socket and the specified remote address.\n\n@param sock The socket that the new access point should represent.\n@param remoteAddress the remote address of the socket of the\n{@link Connector} to be created if it is a TCP socket, or null if it\nis UDP.\n"}, {"uris": "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[void]removeSocket(TransportAddress)", "name": "removeSocket", "arg_nums": 1, "params": [{"name": "localAddr", "type": "TransportAddress"}], "return_type": "void", "signature": "public void removeSocket(TransportAddress localAddr)", "original_string": "    public void removeSocket(TransportAddress localAddr)\n    {\n        removeSocket(localAddr, null);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/StunStack.java", "class_name": "StunStack", "class_uri": "src/main/java/org/ice4j/stack/StunStack.java.StunStack", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nStops and deletes the connector listening on the specified local address.\nNote this removes connectors with UDP sockets only, use\n{@link #removeSocket(org.ice4j.TransportAddress, org.ice4j.TransportAddress)}\nwith the appropriate remote address for TCP.\n\n@param localAddr the local address of the socket to remove.\n"}, {"uris": "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[void]removeSocket(TransportAddress,TransportAddress)", "name": "removeSocket", "arg_nums": 2, "params": [{"name": "localAddr", "type": "TransportAddress"}, {"name": "remoteAddr", "type": "TransportAddress"}], "return_type": "void", "signature": "public void removeSocket(TransportAddress localAddr,\n                             TransportAddress remoteAddr)", "original_string": "    public void removeSocket(TransportAddress localAddr,\n                             TransportAddress remoteAddr)\n    {\n        //first cancel all transactions using this address.\n        cancelTransactionsForAddress(localAddr, remoteAddr);\n\n        netAccessManager.removeSocket(localAddr, remoteAddr);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/StunStack.java", "class_name": "StunStack", "class_uri": "src/main/java/org/ice4j/stack/StunStack.java.StunStack", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nStops and deletes the connector listening on the specified local address\nand remote address.\n\n@param localAddr the local address of the socket to remove.\n@param remoteAddr the remote address of the socket to remove. Use\n<tt>null</tt> for UDP.\n"}, {"uris": "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[StunClientTransaction]getClientTransaction(byte[])", "name": "getClientTransaction", "arg_nums": 1, "params": [{"name": "transactionID", "type": "byte[]"}], "return_type": "StunClientTransaction", "signature": "protected StunClientTransaction getClientTransaction(byte[] transactionID)", "original_string": "    protected StunClientTransaction getClientTransaction(byte[] transactionID)\n    {\n        synchronized (clientTransactions)\n        {\n            Collection<StunClientTransaction> cTrans\n                = clientTransactions.values();\n\n            for (StunClientTransaction tran : cTrans)\n            {\n                if (tran.getTransactionID().equals(transactionID))\n                    return tran;\n            }\n        }\n        return null;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/StunStack.java", "class_name": "StunStack", "class_uri": "src/main/java/org/ice4j/stack/StunStack.java.StunStack", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "StunClientTransaction", "classes": []}, "docstring": "\nReturns the transaction with the specified <tt>transactionID</tt> or\n<tt>null</tt> if no such transaction exists.\n\n@param transactionID the ID of the transaction we are looking for.\n\n@return the {@link StunClientTransaction} we are looking for.\n"}, {"uris": "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[StunServerTransaction]getServerTransaction(byte[])", "name": "getServerTransaction", "arg_nums": 1, "params": [{"name": "transactionID", "type": "byte[]"}], "return_type": "StunServerTransaction", "signature": "protected StunServerTransaction getServerTransaction(byte[] transactionID)", "original_string": "    protected StunServerTransaction getServerTransaction(byte[] transactionID)\n    {\n        synchronized (serverTransactions)\n        {\n            long now = System.currentTimeMillis();\n\n            for (Iterator<StunServerTransaction> i\n                        = serverTransactions.values().iterator();\n                    i.hasNext();)\n            {\n                StunServerTransaction serverTransaction = i.next();\n\n                if (serverTransaction.isExpired(now))\n                    i.remove();\n                else if (serverTransaction.getTransactionID().equals(\n                        transactionID))\n                    return serverTransaction;\n            }\n        }\n        return null;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/StunStack.java", "class_name": "StunStack", "class_uri": "src/main/java/org/ice4j/stack/StunStack.java.StunStack", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "StunServerTransaction", "classes": []}, "docstring": "\nReturns the transaction with the specified <tt>transactionID</tt> or\n<tt>null</tt> if no such transaction exists.\n\n@param transactionID the ID of the transaction we are looking for.\n\n@return the {@link StunClientTransaction} we are looking for.\n"}, {"uris": "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[StunServerTransaction]getServerTransaction(TransactionID)", "name": "getServerTransaction", "arg_nums": 1, "params": [{"name": "transactionID", "type": "TransactionID"}], "return_type": "StunServerTransaction", "signature": "protected StunServerTransaction getServerTransaction(\n            TransactionID transactionID)", "original_string": "    protected StunServerTransaction getServerTransaction(\n            TransactionID transactionID)\n    {\n        StunServerTransaction serverTransaction;\n\n        synchronized (serverTransactions)\n        {\n            serverTransaction = serverTransactions.get(transactionID);\n        }\n        /*\n         * If a StunServerTransaction is expired, do not return it. It will be\n         * removed from serverTransactions soon.\n         */\n        if ((serverTransaction != null) && serverTransaction.isExpired())\n            serverTransaction = null;\n        return serverTransaction;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/StunStack.java", "class_name": "StunStack", "class_uri": "src/main/java/org/ice4j/stack/StunStack.java.StunStack", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "StunServerTransaction", "classes": []}, "docstring": "\nReturns the transaction with the specified <tt>transactionID</tt> or\n<tt>null</tt> if no such transaction exists.\n\n@param transactionID the ID of the transaction we are looking for.\n\n@return the {@link StunClientTransaction} we are looking for.\n"}, {"uris": "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[void]cancelTransaction(TransactionID)", "name": "cancelTransaction", "arg_nums": 1, "params": [{"name": "transactionID", "type": "TransactionID"}], "return_type": "void", "signature": "public void cancelTransaction(TransactionID transactionID)", "original_string": "    public void cancelTransaction(TransactionID transactionID)\n    {\n        StunClientTransaction clientTransaction\n            = clientTransactions.get(transactionID);\n\n        if (clientTransaction != null)\n            clientTransaction.cancel();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/StunStack.java", "class_name": "StunStack", "class_uri": "src/main/java/org/ice4j/stack/StunStack.java.StunStack", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCancels the {@link StunClientTransaction} with the specified\n<tt>transactionID</tt>. Cancellation means that the stack will not\nretransmit the request, will not treat the lack of response to be a\nfailure, but will wait the duration of the transaction timeout for a\nresponse.\n\n@param transactionID the {@link TransactionID} of the\n{@link StunClientTransaction} to cancel\n"}, {"uris": "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[void]cancelTransactionsForAddress(TransportAddress,TransportAddress)", "name": "cancelTransactionsForAddress", "arg_nums": 2, "params": [{"name": "localAddr", "type": "TransportAddress"}, {"name": "remoteAddr", "type": "TransportAddress"}], "return_type": "void", "signature": "private void cancelTransactionsForAddress(TransportAddress localAddr,\n                                              TransportAddress remoteAddr)", "original_string": "    private void cancelTransactionsForAddress(TransportAddress localAddr,\n                                              TransportAddress remoteAddr)\n    {\n        List<StunClientTransaction> clientTransactionsToCancel = null;\n\n        synchronized (clientTransactions)\n        {\n            Iterator<StunClientTransaction> clientTransactionsIter\n                = clientTransactions.values().iterator();\n\n            while (clientTransactionsIter.hasNext())\n            {\n                StunClientTransaction tran = clientTransactionsIter.next();\n\n                if (tran.getLocalAddress().equals(localAddr)\n                        && (remoteAddr == null\n                                || remoteAddr.equals(tran.getRemoteAddress())))\n                {\n                    clientTransactionsIter.remove();\n\n                    /*\n                     * Invoke StunClientTransaction.cancel() outside the\n                     * clientTransactions-synchronized block in order to avoid a\n                     * deadlock. Reported by Carl Hasselskog.\n                     */\n                    if (clientTransactionsToCancel == null)\n                    {\n                        clientTransactionsToCancel = new LinkedList<>();\n                    }\n                    clientTransactionsToCancel.add(tran);\n                }\n            }\n        }\n        /*\n         * Invoke StunClientTransaction.cancel() outside the\n         * clientTransactions-synchronized block in order to avoid a deadlock.\n         * Reported by Carl Hasselskog.\n         */\n        if (clientTransactionsToCancel != null)\n        {\n            for (StunClientTransaction tran : clientTransactionsToCancel)\n                tran.cancel();\n        }\n\n        List<StunServerTransaction> serverTransactionsToExpire = null;\n\n        synchronized (serverTransactions)\n        {\n            Iterator<StunServerTransaction> serverTransactionsIter\n                = serverTransactions.values().iterator();\n\n            while (serverTransactionsIter.hasNext())\n            {\n                StunServerTransaction tran = serverTransactionsIter.next();\n                TransportAddress listenAddr = tran.getLocalListeningAddress();\n                TransportAddress sendingAddr = tran.getSendingAddress();\n\n                if (listenAddr.equals(localAddr)\n                        || (sendingAddr != null\n                                && sendingAddr.equals(localAddr)))\n                {\n                    if (remoteAddr == null\n                          || remoteAddr.equals(tran.getRequestSourceAddress()))\n                    {\n                        serverTransactionsIter.remove();\n\n                        if (serverTransactionsToExpire == null)\n                        {\n                            serverTransactionsToExpire = new LinkedList<>();\n                        }\n                        serverTransactionsToExpire.add(tran);\n                    }\n                }\n            }\n        }\n        if (serverTransactionsToExpire != null)\n        {\n            for (StunServerTransaction tran : serverTransactionsToExpire)\n                tran.expire();\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/StunStack.java", "class_name": "StunStack", "class_uri": "src/main/java/org/ice4j/stack/StunStack.java.StunStack", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nStops all transactions for the specified <tt>localAddr</tt> so that they\nwon't send messages through any longer and so that we could remove the\nassociated socket.\n\n@param localAddr the <tt>TransportAddress</tt> that we'd like to remove\ntransactions for.\n@param remoteAddr the remote <tt>TransportAddress</tt> that we'd like to\nremove transactions for. If <tt>null</tt>, then it will not be taken\ninto account (that is, all transactions with for <tt>localAddr</tt> will\nbe cancelled).\n"}, {"uris": "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[]StunStack(PeerUdpMessageEventHandler,ChannelDataEventHandler)", "name": "StunStack", "arg_nums": 2, "params": [{"name": "peerUdpMessageEventHandler", "type": "PeerUdpMessageEventHandler"}, {"name": "channelDataEventHandler", "type": "ChannelDataEventHandler"}], "return_type": "", "signature": "public StunStack(PeerUdpMessageEventHandler peerUdpMessageEventHandler,\n            ChannelDataEventHandler channelDataEventHandler)", "original_string": "    public StunStack(PeerUdpMessageEventHandler peerUdpMessageEventHandler,\n            ChannelDataEventHandler channelDataEventHandler)\n    {\n        /*\n         * The Mac instantiation used in MessageIntegrityAttribute could take\n         * several hundred milliseconds so we don't want it instantiated only\n         * after we get a response because the delay may cause the transaction\n         * to fail.\n         */\n        synchronized (StunStack.class)\n        {\n            if (mac == null)\n            {\n                try\n                {\n                    mac\n                        = Mac.getInstance(\n                                MessageIntegrityAttribute.HMAC_SHA1_ALGORITHM);\n                }\n                catch (NoSuchAlgorithmException nsaex)\n                {\n                    nsaex.printStackTrace();\n                }\n            }\n        }\n        netAccessManager =\n            new NetAccessManager(this, peerUdpMessageEventHandler,\n                channelDataEventHandler);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/StunStack.java", "class_name": "StunStack", "class_uri": "src/main/java/org/ice4j/stack/StunStack.java.StunStack", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>StunStack</tt> instance with given\npeerUdpMessageEventHandler and channelDataEventHandler.\n\n@param peerUdpMessageEventHandler the <tt>PeerUdpMessageEventHandler</tt>\n           that will handle incoming UDP messages which are not STUN\n           messages and ChannelData messages.\n@param channelDataEventHandler the <tt>ChannelDataEventHandler</tt> that\n           will handle incoming UDP messages which are ChannelData\n           messages.\n"}, {"uris": "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[]StunStack()", "name": "StunStack", "arg_nums": 0, "params": [], "return_type": "", "signature": "public StunStack()", "original_string": "    public StunStack()\n    {\n        this(null, null);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/StunStack.java", "class_name": "StunStack", "class_uri": "src/main/java/org/ice4j/stack/StunStack.java.StunStack", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>StunStack</tt> instance.\n"}, {"uris": "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[NetAccessManager]getNetAccessManager()", "name": "getNetAccessManager", "arg_nums": 0, "params": [], "return_type": "NetAccessManager", "signature": "NetAccessManager getNetAccessManager()", "original_string": "    NetAccessManager getNetAccessManager()\n    {\n        return netAccessManager;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/StunStack.java", "class_name": "StunStack", "class_uri": "src/main/java/org/ice4j/stack/StunStack.java.StunStack", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "NetAccessManager", "classes": []}, "docstring": "\nReturns the currently active instance of NetAccessManager.\n@return the currently active instance of NetAccessManager.\n"}, {"uris": "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[void]sendChannelData(ChannelData,TransportAddress,TransportAddress)", "name": "sendChannelData", "arg_nums": 3, "params": [{"name": "channelData", "type": "ChannelData"}, {"name": "sendTo", "type": "TransportAddress"}, {"name": "sendThrough", "type": "TransportAddress"}], "return_type": "void", "signature": "public void sendChannelData(\n            ChannelData channelData,\n            TransportAddress sendTo,\n            TransportAddress sendThrough)", "original_string": "    public void sendChannelData(\n            ChannelData channelData,\n            TransportAddress sendTo,\n            TransportAddress sendThrough)\n        throws StunException\n    {\n        try\n        {\n            getNetAccessManager().sendMessage(channelData, sendThrough, sendTo);\n        }\n        catch (StunException stex)\n        {\n            throw stex;\n        }\n        catch (IllegalArgumentException iaex)\n        {\n            throw new StunException(\n                    StunException.ILLEGAL_ARGUMENT,\n                    \"Failed to send STUN indication: \" + channelData,\n                    iaex);\n        }\n        catch (IOException ioex)\n        {\n            throw new StunException(\n                    StunException.NETWORK_ERROR,\n                    \"Failed to send STUN indication: \" + channelData,\n                    ioex);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/StunStack.java", "class_name": "StunStack", "class_uri": "src/main/java/org/ice4j/stack/StunStack.java.StunStack", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSends a specific STUN <tt>Indication</tt> to a specific destination\n<tt>TransportAddress</tt> through a socket registered with this\n<tt>StunStack</tt> using a specific <tt>TransportAddress</tt>.\n\n@param channelData the STUN <tt>Indication</tt> to be sent to the\nspecified destination <tt>TransportAddress</tt> through the socket with\nthe specified <tt>TransportAddress</tt>\n@param sendTo the <tt>TransportAddress</tt> of the destination to which\nthe specified <tt>indication</tt> is to be sent\n@param sendThrough the <tt>TransportAddress</tt> of the socket registered\nwith this <tt>StunStack</tt> through which the specified\n<tt>indication</tt> is to be sent\n@throws StunException if anything goes wrong while sending the specified\n<tt>indication</tt> to the destination <tt>sendTo</tt> through the socket\nidentified by <tt>sendThrough</tt>\n"}, {"uris": "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[void]sendUdpMessage(RawMessage,TransportAddress,TransportAddress)", "name": "sendUdpMessage", "arg_nums": 3, "params": [{"name": "udpMessage", "type": "RawMessage"}, {"name": "sendTo", "type": "TransportAddress"}, {"name": "sendThrough", "type": "TransportAddress"}], "return_type": "void", "signature": "public void sendUdpMessage(\n            RawMessage udpMessage,\n            TransportAddress sendTo,\n            TransportAddress sendThrough)", "original_string": "    public void sendUdpMessage(\n            RawMessage udpMessage,\n            TransportAddress sendTo,\n            TransportAddress sendThrough)\n        throws StunException\n    {\n        \n        try\n        {\n            getNetAccessManager().sendMessage(\n                udpMessage.getBytes(), sendThrough, sendTo);\n        }\n        catch (IllegalArgumentException iaex)\n        {\n            throw new StunException(\n                    StunException.ILLEGAL_ARGUMENT,\n                    \"Failed to send STUN indication: \" + udpMessage,\n                    iaex);\n        }\n        catch (IOException ioex)\n        {\n            throw new StunException(\n                    StunException.NETWORK_ERROR,\n                    \"Failed to send STUN indication: \" + udpMessage,\n                    ioex);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/StunStack.java", "class_name": "StunStack", "class_uri": "src/main/java/org/ice4j/stack/StunStack.java.StunStack", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSends a specific STUN <tt>Indication</tt> to a specific destination\n<tt>TransportAddress</tt> through a socket registered with this\n<tt>StunStack</tt> using a specific <tt>TransportAddress</tt>.\n\n@param udpMessage the <tt>RawMessage</tt> to be sent to the\nspecified destination <tt>TransportAddress</tt> through the socket with\nthe specified <tt>TransportAddress</tt>\n@param sendTo the <tt>TransportAddress</tt> of the destination to which\nthe specified <tt>indication</tt> is to be sent\n@param sendThrough the <tt>TransportAddress</tt> of the socket registered\nwith this <tt>StunStack</tt> through which the specified\n<tt>indication</tt> is to be sent\n@throws StunException if anything goes wrong while sending the specified\n<tt>indication</tt> to the destination <tt>sendTo</tt> through the socket\nidentified by <tt>sendThrough</tt>\n"}, {"uris": "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[void]sendIndication(Indication,TransportAddress,TransportAddress)", "name": "sendIndication", "arg_nums": 3, "params": [{"name": "indication", "type": "Indication"}, {"name": "sendTo", "type": "TransportAddress"}, {"name": "sendThrough", "type": "TransportAddress"}], "return_type": "void", "signature": "public void sendIndication(\n            Indication indication,\n            TransportAddress sendTo,\n            TransportAddress sendThrough)", "original_string": "    public void sendIndication(\n            Indication indication,\n            TransportAddress sendTo,\n            TransportAddress sendThrough)\n        throws StunException\n    {\n        if (indication.getTransactionID() == null)\n        {\n            indication.setTransactionID(\n                    TransactionID.createNewTransactionID().getBytes());\n        }\n\n        try\n        {\n            getNetAccessManager().sendMessage(indication, sendThrough, sendTo);\n        }\n        catch (IllegalArgumentException iaex)\n        {\n            throw new StunException(\n                    StunException.ILLEGAL_ARGUMENT,\n                    \"Failed to send STUN indication: \" + indication,\n                    iaex);\n        }\n        catch (IOException ioex)\n        {\n            throw new StunException(\n                    StunException.NETWORK_ERROR,\n                    \"Failed to send STUN indication: \" + indication,\n                    ioex);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/StunStack.java", "class_name": "StunStack", "class_uri": "src/main/java/org/ice4j/stack/StunStack.java.StunStack", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSends a specific STUN <tt>Indication</tt> to a specific destination\n<tt>TransportAddress</tt> through a socket registered with this\n<tt>StunStack</tt> using a specific <tt>TransportAddress</tt>.\n\n@param indication the STUN <tt>Indication</tt> to be sent to the\nspecified destination <tt>TransportAddress</tt> through the socket with\nthe specified <tt>TransportAddress</tt>\n@param sendTo the <tt>TransportAddress</tt> of the destination to which\nthe specified <tt>indication</tt> is to be sent\n@param sendThrough the <tt>TransportAddress</tt> of the socket registered\nwith this <tt>StunStack</tt> through which the specified\n<tt>indication</tt> is to be sent\n@throws StunException if anything goes wrong while sending the specified\n<tt>indication</tt> to the destination <tt>sendTo</tt> through the socket\nidentified by <tt>sendThrough</tt>\n"}, {"uris": "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[TransactionID]sendRequest(Request,TransportAddress,TransportAddress,ResponseCollector)", "name": "sendRequest", "arg_nums": 4, "params": [{"name": "request", "type": "Request"}, {"name": "sendTo", "type": "TransportAddress"}, {"name": "sendThrough", "type": "TransportAddress"}, {"name": "collector", "type": "ResponseCollector"}], "return_type": "TransactionID", "signature": "public TransactionID sendRequest(  Request           request,\n                                       TransportAddress  sendTo,\n                                       TransportAddress  sendThrough,\n                                       ResponseCollector collector)", "original_string": "    public TransactionID sendRequest(  Request           request,\n                                       TransportAddress  sendTo,\n                                       TransportAddress  sendThrough,\n                                       ResponseCollector collector)\n        throws IOException, IllegalArgumentException\n    {\n        return sendRequest(request, sendTo, sendThrough, collector,\n                        TransactionID.createNewTransactionID());\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/StunStack.java", "class_name": "StunStack", "class_uri": "src/main/java/org/ice4j/stack/StunStack.java.StunStack", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "TransactionID", "classes": []}, "docstring": "\nSends the specified request through the specified access point, and\nregisters the specified ResponseCollector for later notification.\n@param  request     the request to send\n@param  sendTo      the destination address of the request.\n@param  sendThrough the local address to use when sending the request\n@param  collector   the instance to notify when a response arrives or the\n                    the transaction timeouts\n\n@return the <tt>TransactionID</tt> of the <tt>StunClientTransaction</tt>\nthat we used in order to send the request.\n\n@throws IOException  if an error occurs while sending message bytes\nthrough the network socket.\n@throws IllegalArgumentException if the apDescriptor references an\naccess point that had not been installed,\n"}, {"uris": "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[TransactionID]sendRequest(Request,TransportAddress,TransportAddress,ResponseCollector,TransactionID)", "name": "sendRequest", "arg_nums": 5, "params": [{"name": "request", "type": "Request"}, {"name": "sendTo", "type": "TransportAddress"}, {"name": "sendThrough", "type": "TransportAddress"}, {"name": "collector", "type": "ResponseCollector"}, {"name": "transactionID", "type": "TransactionID"}], "return_type": "TransactionID", "signature": "public TransactionID sendRequest(Request           request,\n                                     TransportAddress  sendTo,\n                                     TransportAddress  sendThrough,\n                                     ResponseCollector collector,\n                                     TransactionID     transactionID)", "original_string": "    public TransactionID sendRequest(Request           request,\n                                     TransportAddress  sendTo,\n                                     TransportAddress  sendThrough,\n                                     ResponseCollector collector,\n                                     TransactionID     transactionID)\n        throws IllegalArgumentException,\n               IOException\n    {\n        return\n            sendRequest(\n                    request, sendTo, sendThrough, collector, transactionID,\n                    -1, -1, -1);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/StunStack.java", "class_name": "StunStack", "class_uri": "src/main/java/org/ice4j/stack/StunStack.java.StunStack", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "TransactionID", "classes": []}, "docstring": "\nSends the specified request through the specified access point, and\nregisters the specified ResponseCollector for later notification.\n@param  request     the request to send\n@param  sendTo      the destination address of the request.\n@param  sendThrough the local address to use when sending the request\n@param  collector   the instance to notify when a response arrives or the\nthe transaction timeouts\n@param transactionID the ID that we'd like the new transaction to use\nin case the application created it in order to use it for application\ndata correlation.\n\n@return the <tt>TransactionID</tt> of the <tt>StunClientTransaction</tt>\nthat we used in order to send the request.\n\n@throws IllegalArgumentException if the apDescriptor references an\naccess point that had not been installed,\n@throws IOException  if an error occurs while sending message bytes\nthrough the network socket.\n"}, {"uris": "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[TransactionID]sendRequest(Request,TransportAddress,TransportAddress,ResponseCollector,TransactionID,int,int,int)", "name": "sendRequest", "arg_nums": 8, "params": [{"name": "request", "type": "Request"}, {"name": "sendTo", "type": "TransportAddress"}, {"name": "sendThrough", "type": "TransportAddress"}, {"name": "collector", "type": "ResponseCollector"}, {"name": "transactionID", "type": "TransactionID"}, {"name": "originalWaitInterval", "type": "int"}, {"name": "maxWaitInterval", "type": "int"}, {"name": "maxRetransmissions", "type": "int"}], "return_type": "TransactionID", "signature": "public TransactionID sendRequest(Request           request,\n                                     TransportAddress  sendTo,\n                                     TransportAddress  sendThrough,\n                                     ResponseCollector collector,\n                                     TransactionID     transactionID,\n                                     int               originalWaitInterval,\n                                     int               maxWaitInterval,\n                                     int               maxRetransmissions)", "original_string": "    public TransactionID sendRequest(Request           request,\n                                     TransportAddress  sendTo,\n                                     TransportAddress  sendThrough,\n                                     ResponseCollector collector,\n                                     TransactionID     transactionID,\n                                     int               originalWaitInterval,\n                                     int               maxWaitInterval,\n                                     int               maxRetransmissions)\n        throws IllegalArgumentException,\n               IOException\n    {\n        StunClientTransaction clientTransaction\n            = new StunClientTransaction(\n                    this,\n                    request,\n                    sendTo,\n                    sendThrough,\n                    collector,\n                    transactionID);\n\n        if (originalWaitInterval > 0)\n            clientTransaction.originalWaitInterval = originalWaitInterval;\n        if (maxWaitInterval > 0)\n            clientTransaction.maxWaitInterval = maxWaitInterval;\n        if (maxRetransmissions >= 0)\n            clientTransaction.maxRetransmissions = maxRetransmissions;\n\n        clientTransactions.put(\n                clientTransaction.getTransactionID(),\n                clientTransaction);\n\n        clientTransaction.sendRequest();\n\n        return clientTransaction.getTransactionID();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/StunStack.java", "class_name": "StunStack", "class_uri": "src/main/java/org/ice4j/stack/StunStack.java.StunStack", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "TransactionID", "classes": []}, "docstring": "\nSends the specified request through the specified access point, and\nregisters the specified ResponseCollector for later notification.\n@param  request     the request to send\n@param  sendTo      the destination address of the request.\n@param  sendThrough the local address to use when sending the request\n@param  collector   the instance to notify when a response arrives or the\nthe transaction timeouts\n@param transactionID the ID that we'd like the new transaction to use\nin case the application created it in order to use it for application\ndata correlation.\n@param originalWaitInterval The number of milliseconds to wait before\nthe first retransmission of the request.\n@param maxWaitInterval The maximum wait interval. Once this interval is\nreached we should stop doubling its value.\n@param maxRetransmissions Maximum number of retransmissions. Once this\nnumber is reached and if no response is received after maxWaitInterval\nmilliseconds the request is considered unanswered.\n@return the <tt>TransactionID</tt> of the <tt>StunClientTransaction</tt>\nthat we used in order to send the request.\n\n@throws IllegalArgumentException if the apDescriptor references an\naccess point that had not been installed,\n@throws IOException  if an error occurs while sending message bytes\nthrough the network socket.\n"}, {"uris": "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[TransactionID]sendRequest(Request,TransportAddress,DatagramSocket,ResponseCollector)", "name": "sendRequest", "arg_nums": 4, "params": [{"name": "request", "type": "Request"}, {"name": "sendTo", "type": "TransportAddress"}, {"name": "sendThrough", "type": "DatagramSocket"}, {"name": "collector", "type": "ResponseCollector"}], "return_type": "TransactionID", "signature": "public TransactionID sendRequest( Request           request,\n                                      TransportAddress  sendTo,\n                                      DatagramSocket    sendThrough,\n                                      ResponseCollector collector )", "original_string": "    public TransactionID sendRequest( Request           request,\n                                      TransportAddress  sendTo,\n                                      DatagramSocket    sendThrough,\n                                      ResponseCollector collector )\n        throws IOException, IllegalArgumentException\n    {\n        TransportAddress sendThroughAddr = new TransportAddress(\n            sendThrough.getLocalAddress(), sendThrough.getLocalPort(),\n                Transport.UDP);\n\n        return sendRequest(request, sendTo, sendThroughAddr, collector);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/StunStack.java", "class_name": "StunStack", "class_uri": "src/main/java/org/ice4j/stack/StunStack.java.StunStack", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "TransactionID", "classes": []}, "docstring": "\nSends the specified request through the specified access point, and\nregisters the specified ResponseCollector for later notification.\n@param  request     the request to send\n@param  sendTo      the destination address of the request.\n@param  sendThrough the socket that we should send the request through.\n@param  collector   the instance to notify when a response arrives or the\n                    the transaction timeouts\n\n@return the <tt>TransactionID</tt> of the <tt>StunClientTransaction</tt>\nthat we used in order to send the request.\n\n@throws IOException  if an error occurs while sending message bytes\nthrough the network socket.\n@throws IllegalArgumentException if the apDescriptor references an\naccess point that had not been installed,\n"}, {"uris": "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[void]sendResponse(byte[],Response,TransportAddress,TransportAddress)", "name": "sendResponse", "arg_nums": 4, "params": [{"name": "transactionID", "type": "byte[]"}, {"name": "response", "type": "Response"}, {"name": "sendThrough", "type": "TransportAddress"}, {"name": "sendTo", "type": "TransportAddress"}], "return_type": "void", "signature": "public void sendResponse(byte[]           transactionID,\n                             Response         response,\n                             TransportAddress sendThrough,\n                             TransportAddress sendTo)", "original_string": "    public void sendResponse(byte[]           transactionID,\n                             Response         response,\n                             TransportAddress sendThrough,\n                             TransportAddress sendTo)\n        throws StunException,\n               IOException,\n               IllegalArgumentException\n    {\n        TransactionID tid\n            = TransactionID.createTransactionID(this, transactionID);\n        StunServerTransaction sTran = getServerTransaction(tid);\n\n        if (sTran == null)\n        {\n            throw new StunException(StunException.TRANSACTION_DOES_NOT_EXIST,\n                                \"The transaction specified in the response \"\n                                + \"(tid=\"+ tid.toString() +\") \"\n                                + \"object does not exist.\");\n        }\n        else if ( sTran.isRetransmitting())\n        {\n            throw new StunException(StunException.TRANSACTION_ALREADY_ANSWERED,\n                                    \"The transaction specified in the response \"\n                                    + \"(tid=\"+ tid.toString() +\") \"\n                                    + \"has already seen a previous response. \"\n                                    + \"Response was:\\n\"\n                                    + sTran.getResponse());\n        }\n        else\n        {\n            sTran.sendResponse(response, sendThrough, sendTo);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/StunStack.java", "class_name": "StunStack", "class_uri": "src/main/java/org/ice4j/stack/StunStack.java.StunStack", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSends the specified response message through the specified access point.\n\n@param transactionID the id of the transaction to use when sending the\nresponse. Actually we are getting kind of redundant here as we already\nhave the id in the response object, but I am bringing out as an extra\nparameter as the user might otherwise forget to explicitly set it.\n@param response      the message to send.\n@param sendThrough   the local address to use when sending the message.\n@param sendTo        the destination of the message.\n\n@throws IOException  if an error occurs while sending message bytes\nthrough the network socket.\n@throws IllegalArgumentException if the apDescriptor references an\naccess point that had not been installed,\n@throws StunException if message encoding fails\n"}, {"uris": "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[void]addIndicationListener(TransportAddress,MessageEventHandler)", "name": "addIndicationListener", "arg_nums": 2, "params": [{"name": "localAddr", "type": "TransportAddress"}, {"name": "indicationListener", "type": "MessageEventHandler"}], "return_type": "void", "signature": "public void addIndicationListener(\n            TransportAddress localAddr,\n            MessageEventHandler indicationListener)", "original_string": "    public void addIndicationListener(\n            TransportAddress localAddr,\n            MessageEventHandler indicationListener)\n    {\n        eventDispatcher.addIndicationListener(localAddr, indicationListener);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/StunStack.java", "class_name": "StunStack", "class_uri": "src/main/java/org/ice4j/stack/StunStack.java.StunStack", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nAdds a new <tt>MessageEventHandler</tt> which is to be notified about\nSTUN indications received at a specific local <tt>TransportAddress</tt>.\n\n@param localAddr the <tt>TransportAddress</tt> of the local socket for\nwhich received STUN indications are to be reported to the specified\n<tt>MessageEventHandler</tt>\n@param indicationListener the <tt>MessageEventHandler</tt> which is to be\nregistered for notifications about STUN indications received at the\nspecified local <tt>TransportAddress</tt>\n"}, {"uris": "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[void]addOldIndicationListener(TransportAddress,MessageEventHandler)", "name": "addOldIndicationListener", "arg_nums": 2, "params": [{"name": "localAddr", "type": "TransportAddress"}, {"name": "indicationListener", "type": "MessageEventHandler"}], "return_type": "void", "signature": "public void addOldIndicationListener(\n            TransportAddress localAddr,\n            MessageEventHandler indicationListener)", "original_string": "    public void addOldIndicationListener(\n            TransportAddress localAddr,\n            MessageEventHandler indicationListener)\n    {\n        eventDispatcher.addOldIndicationListener(localAddr, indicationListener);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/StunStack.java", "class_name": "StunStack", "class_uri": "src/main/java/org/ice4j/stack/StunStack.java.StunStack", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nAdds a new <tt>MessageEventHandler</tt> which is to be notified about\nold indications received at a specific local <tt>TransportAddress</tt>.\n\n@param localAddr the <tt>TransportAddress</tt> of the local socket for\nwhich received STUN indications are to be reported to the specified\n<tt>MessageEventHandler</tt>\n@param indicationListener the <tt>MessageEventHandler</tt> which is to be\nregistered for notifications about old indications received at the\nspecified local <tt>TransportAddress</tt>\n"}, {"uris": "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[void]addRequestListener(RequestListener)", "name": "addRequestListener", "arg_nums": 1, "params": [{"name": "requestListener", "type": "RequestListener"}], "return_type": "void", "signature": "public void addRequestListener(RequestListener requestListener)", "original_string": "    public void addRequestListener(RequestListener requestListener)\n    {\n        this.eventDispatcher.addRequestListener( requestListener );\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/StunStack.java", "class_name": "StunStack", "class_uri": "src/main/java/org/ice4j/stack/StunStack.java.StunStack", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets the listener that should be notified when a new Request is received.\n@param requestListener the listener interested in incoming requests.\n"}, {"uris": "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[void]removeIndicationListener(TransportAddress,MessageEventHandler)", "name": "removeIndicationListener", "arg_nums": 2, "params": [{"name": "localAddr", "type": "TransportAddress"}, {"name": "indicationListener", "type": "MessageEventHandler"}], "return_type": "void", "signature": "public void removeIndicationListener(\n            TransportAddress localAddr,\n            MessageEventHandler indicationListener)", "original_string": "    public void removeIndicationListener(\n            TransportAddress localAddr,\n            MessageEventHandler indicationListener)\n    {\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/StunStack.java", "class_name": "StunStack", "class_uri": "src/main/java/org/ice4j/stack/StunStack.java.StunStack", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nRemoves an existing <tt>MessageEventHandler</tt> to no longer be notified\nabout STUN indications received at a specific local\n<tt>TransportAddress</tt>.\n\n@param localAddr the <tt>TransportAddress</tt> of the local socket for\nwhich received STUN indications are to no longer be reported to the\nspecified <tt>MessageEventHandler</tt>\n@param indicationListener the <tt>MessageEventHandler</tt> which is to be\nunregistered for notifications about STUN indications received at the\nspecified local <tt>TransportAddress</tt>\n"}, {"uris": "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[void]removeRequestListener(RequestListener)", "name": "removeRequestListener", "arg_nums": 1, "params": [{"name": "listener", "type": "RequestListener"}], "return_type": "void", "signature": "public void removeRequestListener(RequestListener listener)", "original_string": "    public void removeRequestListener(RequestListener listener)\n    {\n        this.eventDispatcher.removeRequestListener(listener);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/StunStack.java", "class_name": "StunStack", "class_uri": "src/main/java/org/ice4j/stack/StunStack.java.StunStack", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nRemoves the specified listener from the local listener list. (If any\ninstances of this listener have been registered for a particular\naccess point, they will not be removed).\n@param listener the RequestListener listener to unregister\n"}, {"uris": "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[void]addRequestListener(TransportAddress,RequestListener)", "name": "addRequestListener", "arg_nums": 2, "params": [{"name": "localAddress", "type": "TransportAddress"}, {"name": "listener", "type": "RequestListener"}], "return_type": "void", "signature": "public void addRequestListener( TransportAddress localAddress,\n                                    RequestListener  listener)", "original_string": "    public void addRequestListener( TransportAddress localAddress,\n                                    RequestListener  listener)\n    {\n            eventDispatcher.addRequestListener(localAddress, listener);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/StunStack.java", "class_name": "StunStack", "class_uri": "src/main/java/org/ice4j/stack/StunStack.java.StunStack", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nAdd a RequestListener for requests coming from a specific NetAccessPoint.\nThe listener will be invoked only when a request event is received on\nthat specific property.\n\n@param localAddress The local <tt>TransportAddress</tt> that we would\nlike to listen on.\n@param listener The ConfigurationChangeListener to be added\n"}, {"uris": "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[void]removeClientTransaction(StunClientTransaction)", "name": "removeClientTransaction", "arg_nums": 1, "params": [{"name": "tran", "type": "StunClientTransaction"}], "return_type": "void", "signature": "void removeClientTransaction(StunClientTransaction tran)", "original_string": "    void removeClientTransaction(StunClientTransaction tran)\n    {\n        synchronized (clientTransactions)\n        {\n            clientTransactions.remove(tran.getTransactionID());\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/StunStack.java", "class_name": "StunStack", "class_uri": "src/main/java/org/ice4j/stack/StunStack.java.StunStack", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nRemoves a client transaction from this providers client transactions\nlist. The method is used by <tt>StunClientTransaction</tt>s themselves\nwhen a timeout occurs.\n\n@param tran the transaction to remove.\n"}, {"uris": "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[void]removeServerTransaction(StunServerTransaction)", "name": "removeServerTransaction", "arg_nums": 1, "params": [{"name": "tran", "type": "StunServerTransaction"}], "return_type": "void", "signature": "void removeServerTransaction(StunServerTransaction tran)", "original_string": "    void removeServerTransaction(StunServerTransaction tran)\n    {\n        synchronized (serverTransactions)\n        {\n            serverTransactions.remove(tran.getTransactionID());\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/StunStack.java", "class_name": "StunStack", "class_uri": "src/main/java/org/ice4j/stack/StunStack.java.StunStack", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nRemoves a server transaction from this provider's server transactions\nlist.\nMethod is used by StunServerTransaction-s themselves when they expire.\n@param tran the transaction to remove.\n"}, {"uris": "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[void]handleMessageEvent(StunMessageEvent)", "name": "handleMessageEvent", "arg_nums": 1, "params": [{"name": "ev", "type": "StunMessageEvent"}], "return_type": "void", "signature": "@Override\n    public void handleMessageEvent(StunMessageEvent ev)", "original_string": "    @Override\n    public void handleMessageEvent(StunMessageEvent ev)\n    {\n        Message msg = ev.getMessage();\n\n        if (logger.isLoggable(Level.FINEST))\n        {\n            logger.finest(\n                    \"Received a message on \" + ev.getLocalAddress()\n                        + \" of type:\" + (int) msg.getMessageType());\n        }\n\n        //request\n        if (msg instanceof Request)\n        {\n            logger.finest(\"parsing request\");\n\n            TransactionID serverTid = ev.getTransactionID();\n            StunServerTransaction sTran  = getServerTransaction(serverTid);\n\n            if ( sTran != null)\n            {\n                //requests from this transaction have already been seen\n                //retransmit the response if there was any\n                logger.finest(\"found an existing transaction\");\n\n                try\n                {\n                    sTran.retransmitResponse();\n                    logger.finest(\"Response retransmitted\");\n                }\n                catch (Exception ex)\n                {\n                    //we couldn't really do anything here .. apart from logging\n                    logger.log(Level.WARNING,\n                               \"Failed to retransmit a stun response\",\n                               ex);\n                }\n\n                if (!Boolean.getBoolean(\n                        StackProperties.PROPAGATE_RECEIVED_RETRANSMISSIONS))\n                {\n                    return;\n                }\n            }\n            else\n            {\n                logger.finest(\"existing transaction not found\");\n                sTran\n                    = new StunServerTransaction(\n                            this,\n                            serverTid,\n                            ev.getLocalAddress(),\n                            ev.getRemoteAddress());\n\n                // if there is an OOM error here, stop here right now\n                try\n                {\n                    sTran.start();\n                }\n                catch(OutOfMemoryError t)\n                {\n                    logger.info(\"STUN transaction thread start failed:\" + t);\n                    return;\n                }\n                synchronized (serverTransactions)\n                {\n                    serverTransactions.put(serverTid, sTran);\n                    expiredTransactionsCollector.schedule();\n                }\n            }\n\n            //validate attributes that need validation.\n            try\n            {\n                validateRequestAttributes(ev);\n            }\n            catch(Exception exc)\n            {\n                //validation failed. log get lost.\n                logger.log(Level.FINE, \"Failed to validate msg, removing transaction: \" + ev, exc);\n                removeServerTransaction(sTran);\n                return;\n            }\n\n            try\n            {\n                eventDispatcher.fireMessageEvent(ev);\n            }\n            catch (Throwable t)\n            {\n                Response error;\n\n                logger.log(Level.INFO, \"Received an invalid request.\", t);\n                Throwable cause = t.getCause();\n\n                if (((t instanceof StunException)\n                            && ((StunException) t).getID()\n                                    == StunException\n                                        .TRANSACTION_ALREADY_ANSWERED)\n                        || ((cause instanceof StunException)\n                                && ((StunException) cause).getID()\n                                        == StunException\n                                            .TRANSACTION_ALREADY_ANSWERED))\n                {\n                    // do not try to send an error response since we will\n                    // get another TRANSACTION_ALREADY_ANSWERED\n                    return;\n                }\n\n                if (t instanceof IllegalArgumentException)\n                {\n                    error\n                        = createCorrespondingErrorResponse(\n                                msg.getMessageType(),\n                                ErrorCodeAttribute.BAD_REQUEST,\n                                t.getMessage());\n                }\n                else\n                {\n                    error\n                        = createCorrespondingErrorResponse(\n                                msg.getMessageType(),\n                                ErrorCodeAttribute.SERVER_ERROR,\n                                \"Oops! Something went wrong on our side :(\");\n                }\n\n                try\n                {\n                    sendResponse(\n                            serverTid.getBytes(),\n                            error,\n                            ev.getLocalAddress(),\n                            ev.getRemoteAddress());\n                }\n                catch(Exception exc)\n                {\n                    logger.log(Level.FINE,\n                               \"Couldn't send a server error response\",\n                               exc);\n                }\n            }\n        }\n        //response\n        else if (msg instanceof Response)\n        {\n            TransactionID tid = ev.getTransactionID();\n            StunClientTransaction tran = clientTransactions.remove(tid);\n\n            if (tran != null)\n            {\n                tran.handleResponse(ev);\n            }\n            else\n            {\n                //do nothing - just drop the phantom response.\n                logger.fine(\n                        \"Dropped response - no matching client tran found for\"\n                            + \" tid \" + tid + \"\\n\" + \"all tids in stock were \"\n                            + clientTransactions.keySet());\n            }\n        }\n        // indication\n        else if (msg instanceof Indication)\n        {\n            eventDispatcher.fireMessageEvent(ev);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/StunStack.java", "class_name": "StunStack", "class_uri": "src/main/java/org/ice4j/stack/StunStack.java.StunStack", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCalled to notify this provider for an incoming message.\n\n@param ev the event object that contains the new message.\n"}, {"uris": "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[CredentialsManager]getCredentialsManager()", "name": "getCredentialsManager", "arg_nums": 0, "params": [], "return_type": "CredentialsManager", "signature": "public CredentialsManager getCredentialsManager()", "original_string": "    public CredentialsManager getCredentialsManager()\n    {\n        return credentialsManager;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/StunStack.java", "class_name": "StunStack", "class_uri": "src/main/java/org/ice4j/stack/StunStack.java.StunStack", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "CredentialsManager", "classes": []}, "docstring": "\nReturns the {@link CredentialsManager} that this stack is using for\nverification of {@link MessageIntegrityAttribute}s.\n\n@return the {@link CredentialsManager} that this stack is using for\nverification of {@link MessageIntegrityAttribute}s.\n"}, {"uris": "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[void]shutDown()", "name": "shutDown", "arg_nums": 0, "params": [], "return_type": "void", "signature": "public void shutDown()", "original_string": "    public void shutDown()\n    {\n        eventDispatcher.removeAllListeners();\n\n        // clientTransactions\n        Collection<StunClientTransaction> clientTransactionsToCancel;\n\n        synchronized (clientTransactions)\n        {\n            clientTransactionsToCancel\n                = new ArrayList<>(clientTransactions.values());\n            clientTransactions.clear();\n        }\n        /*\n         * Invoke StunClientTransaction.cancel() outside the\n         * clientTransactions-synchronized block in order to avoid a deadlock.\n         * Reported by Carl Hasselskog.\n         */\n        for (StunClientTransaction tran : clientTransactionsToCancel)\n            tran.cancel();\n\n        // serverTransactions\n        Collection<StunServerTransaction> serverTransactionsToExpire;\n\n        expiredTransactionsCollector.cancel();\n\n        synchronized (serverTransactions)\n        {\n            serverTransactionsToExpire\n                = new ArrayList<>(serverTransactions.values());\n            serverTransactions.clear();\n        }\n        for (StunServerTransaction tran : serverTransactionsToExpire)\n            tran.expire();\n\n        netAccessManager.stop();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/StunStack.java", "class_name": "StunStack", "class_uri": "src/main/java/org/ice4j/stack/StunStack.java.StunStack", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCancels all running transactions and prepares for garbage collection\n"}, {"uris": "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[void]validateRequestAttributes(StunMessageEvent)", "name": "validateRequestAttributes", "arg_nums": 1, "params": [{"name": "evt", "type": "StunMessageEvent"}], "return_type": "void", "signature": "private void validateRequestAttributes(StunMessageEvent evt)", "original_string": "    private void validateRequestAttributes(StunMessageEvent evt)\n        throws IllegalArgumentException, StunException, IOException\n    {\n        Message request = evt.getMessage();\n\n        //assert valid username\n        UsernameAttribute unameAttr = (UsernameAttribute)request\n            .getAttribute(Attribute.USERNAME);\n        String username = null;\n\n        if (unameAttr != null)\n        {\n            username = LongTermCredential.toString(unameAttr.getUsername());\n            if (!validateUsername(username))\n            {\n                Response error = createCorrespondingErrorResponse(\n                                request.getMessageType(),\n                                ErrorCodeAttribute.UNAUTHORIZED,\n                                \"unknown user \" + username);\n\n                sendResponse(request.getTransactionID(), error,\n                                evt.getLocalAddress(),\n                                evt.getRemoteAddress());\n\n                throw new IllegalArgumentException(\n                    \"Non-recognized username: \" + username);\n            }\n        }\n\n        //assert Message Integrity\n        MessageIntegrityAttribute msgIntAttr\n            = (MessageIntegrityAttribute)\n                request.getAttribute(Attribute.MESSAGE_INTEGRITY);\n\n        if (msgIntAttr != null)\n        {\n            //we should complain if we have msg integrity and no username.\n            if (unameAttr == null)\n            {\n                Response error = createCorrespondingErrorResponse(\n                                request.getMessageType(),\n                                ErrorCodeAttribute.BAD_REQUEST,\n                                \"missing username\");\n\n                sendResponse(request.getTransactionID(), error,\n                                evt.getLocalAddress(),\n                                evt.getRemoteAddress());\n\n                throw new IllegalArgumentException(\n                    \"Missing USERNAME in the presence of MESSAGE-INTEGRITY: \");\n            }\n\n            if (!validateMessageIntegrity(\n                    msgIntAttr,\n                    username,\n                    true,\n                    evt.getRawMessage()))\n            {\n                Response error = createCorrespondingErrorResponse(\n                                request.getMessageType(),\n                                ErrorCodeAttribute.UNAUTHORIZED,\n                                \"Wrong MESSAGE-INTEGRITY value\");\n\n                sendResponse(request.getTransactionID(), error,\n                                evt.getLocalAddress(),\n                                evt.getRemoteAddress());\n\n                throw new IllegalArgumentException(\n                    \"Wrong MESSAGE-INTEGRITY value.\");\n            }\n        }\n        else if (Boolean.getBoolean(StackProperties.REQUIRE_MESSAGE_INTEGRITY))\n        {\n            // no message integrity\n            Response error = createCorrespondingErrorResponse(\n                            request.getMessageType(),\n                            ErrorCodeAttribute.UNAUTHORIZED,\n                            \"Missing MESSAGE-INTEGRITY.\");\n\n            sendResponse(request.getTransactionID(), error,\n                            evt.getLocalAddress(),\n                            evt.getRemoteAddress());\n            throw new IllegalArgumentException(\n                \"Missing MESSAGE-INTEGRITY.\");\n        }\n\n        //look for unknown attributes.\n        List<Attribute> allAttributes = request.getAttributes();\n        StringBuffer sBuff = new StringBuffer();\n        for (Attribute attr : allAttributes)\n        {\n            if (attr instanceof OptionalAttribute\n                && attr.getAttributeType()\n                    < Attribute.UNKNOWN_OPTIONAL_ATTRIBUTE)\n                sBuff.append(attr.getAttributeType());\n        }\n\n        if (sBuff.length() > 0)\n        {\n            Response error = createCorrespondingErrorResponse(\n                    request.getMessageType(),\n                    ErrorCodeAttribute.UNKNOWN_ATTRIBUTE,\n                    \"unknown attribute \", sBuff.toString().toCharArray());\n\n            sendResponse(request.getTransactionID(), error,\n                            evt.getLocalAddress(),\n                            evt.getRemoteAddress());\n\n            throw new IllegalArgumentException(\n                \"Unknown attribute(s).\");\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/StunStack.java", "class_name": "StunStack", "class_uri": "src/main/java/org/ice4j/stack/StunStack.java.StunStack", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nExecutes actions related specific attributes like asserting proper\nchecksums or verifying the validity of user names.\n\n@param evt the {@link StunMessageEvent} that contains the {@link\nRequest} that we need to validate.\n\n@throws IllegalArgumentException if there's something in the\n<tt>attribute</tt> that caused us to discard the whole message (e.g. an\ninvalid checksum\nor username)\n@throws StunException if we fail while sending an error response.\n@throws IOException if we fail while sending an error response.\n"}, {"uris": "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[boolean]validateMessageIntegrity(MessageIntegrityAttribute,String,boolean,RawMessage)", "name": "validateMessageIntegrity", "arg_nums": 4, "params": [{"name": "msgInt", "type": "MessageIntegrityAttribute"}, {"name": "username", "type": "String"}, {"name": "shortTermCredentialMechanism", "type": "boolean"}, {"name": "message", "type": "RawMessage"}], "return_type": "boolean", "signature": "public boolean validateMessageIntegrity(\n            MessageIntegrityAttribute msgInt,\n            String                    username,\n            boolean                   shortTermCredentialMechanism,\n            RawMessage                message)", "original_string": "    public boolean validateMessageIntegrity(\n            MessageIntegrityAttribute msgInt,\n            String                    username,\n            boolean                   shortTermCredentialMechanism,\n            RawMessage                message)\n    {\n        int colon = -1;\n\n        if ((username == null)\n                || (username.length() < 1)\n                || (shortTermCredentialMechanism\n                        && ((colon = username.indexOf(\":\")) < 1)))\n        {\n            if (logger.isLoggable(Level.FINE))\n            {\n                logger.log(Level.FINE, \"Received a message with an improperly \"\n                        +\"formatted username\");\n            }\n            return false;\n        }\n\n        if (shortTermCredentialMechanism)\n            username = username.substring(0, colon); // lfrag\n\n        byte[] key = getCredentialsManager().getLocalKey(username);\n\n        if (key == null)\n            return false;\n\n        /*\n         * Now check whether the SHA1 matches. Using\n         * MessageIntegrityAttribute.calculateHmacSha1 on the bytes of the\n         * RawMessage will be incorrect if there are other Attributes after the\n         * MessageIntegrityAttribute because the value of the\n         * MessageIntegrityAttribute is calculated on a STUN \"Message Length\"\n         * upto and including the MESSAGE-INTEGRITY and excluding any Attributes\n         * after it.\n         */\n        byte[] binMsg = new byte[msgInt.getLocationInMessage()];\n\n        System.arraycopy(message.getBytes(), 0, binMsg, 0, binMsg.length);\n\n        char messageLength\n            = (char)\n                (binMsg.length\n                    + Attribute.HEADER_LENGTH\n                    + msgInt.getDataLength()\n                    - Message.HEADER_LENGTH);\n\n        binMsg[2] = (byte) (messageLength >> 8);\n        binMsg[3] = (byte) (messageLength & 0xFF);\n\n        byte[] expectedMsgIntHmacSha1Content;\n\n        try\n        {\n            expectedMsgIntHmacSha1Content\n                = MessageIntegrityAttribute.calculateHmacSha1(\n                        binMsg, 0, binMsg.length,\n                        key);\n        }\n        catch (IllegalArgumentException iaex)\n        {\n            expectedMsgIntHmacSha1Content = null;\n        }\n\n        byte[] msgIntHmacSha1Content = msgInt.getHmacSha1Content();\n\n        if (!Arrays.equals(\n                expectedMsgIntHmacSha1Content,\n                msgIntHmacSha1Content))\n        {\n            if (logger.isLoggable(Level.FINE))\n            {\n                logger.log(\n                        Level.FINE,\n                        \"Received a message with a wrong \"\n                            +\"MESSAGE-INTEGRITY HMAC-SHA1 signature: \"\n                            + \"expected: \"\n                            + toHexString(expectedMsgIntHmacSha1Content)\n                            + \", received: \"\n                            + toHexString(msgIntHmacSha1Content));\n            }\n            return false;\n        }\n\n        if (logger.isLoggable(Level.FINEST))\n            logger.finest(\"Successfully verified msg integrity\");\n        return true;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/StunStack.java", "class_name": "StunStack", "class_uri": "src/main/java/org/ice4j/stack/StunStack.java.StunStack", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nRecalculates the HMAC-SHA1 signature of the <tt>message</tt> array so\nthat we could compare it with the value brought by the\n{@link MessageIntegrityAttribute}.\n\n@param msgInt the attribute that we need to validate.\n@param username the user name that the message integrity checksum is\nsupposed to have been built for.\n@param shortTermCredentialMechanism <tt>true</tt> if <tt>msgInt</tt> is\nto be validated as part of the STUN short-term credential mechanism or\n<tt>false</tt> for the STUN long-term credential mechanism\n@param message the message whose SHA1 checksum we'd need to recalculate.\n\n@return <tt>true</tt> if <tt>msgInt</tt> contains a valid SHA1 value and\n<tt>false</tt> otherwise.\n"}, {"uris": "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[String]toHexString(byte[])", "name": "toHexString", "arg_nums": 1, "params": [{"name": "bytes", "type": "byte[]"}], "return_type": "String", "signature": "private static String toHexString(byte[] bytes)", "original_string": "    private static String toHexString(byte[] bytes)\n    {\n        if (bytes == null)\n            return null;\n        else\n        {\n            StringBuilder hexStringBuilder\n                = new StringBuilder(2 * bytes.length);\n            char[] hexes\n                = new char[]\n                            {\n                                '0', '1', '2', '3', '4', '5', '6', '7', '8',\n                                '9', 'A', 'B', 'C', 'D', 'E', 'F'\n                            };\n\n            for (int i = 0; i < bytes.length; i++)\n            {\n                byte b = bytes[i];\n\n                hexStringBuilder.append(hexes[(b & 0xF0) >> 4]);\n                hexStringBuilder.append(hexes[b & 0x0F]);\n            }\n            return hexStringBuilder.toString();\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/StunStack.java", "class_name": "StunStack", "class_uri": "src/main/java/org/ice4j/stack/StunStack.java.StunStack", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns a <tt>String</tt> representation of a specific <tt>byte</tt>\narray as an unsigned integer in base 16.\n\n@param bytes the <tt>byte</tt> to get the <tt>String</tt> representation\nof as an unsigned integer in base 16\n@return a <tt>String</tt> representation of the specified <tt>byte</tt>\narray as an unsigned integer in base 16\n"}, {"uris": "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[boolean]validateUsername(String)", "name": "validateUsername", "arg_nums": 1, "params": [{"name": "username", "type": "String"}], "return_type": "boolean", "signature": "private boolean validateUsername(String username)", "original_string": "    private boolean validateUsername(String username)\n    {\n        int colon = username.indexOf(\":\");\n\n        if ((username.length() < 1) || (colon < 1))\n        {\n            if (logger.isLoggable(Level.FINE))\n            {\n                logger.log(Level.FINE, \"Received a message with an improperly \"\n                        +\"formatted username\");\n            }\n            return false;\n        }\n\n        String lfrag = username.substring(0, colon);\n\n        return getCredentialsManager().checkLocalUserName(lfrag);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/StunStack.java", "class_name": "StunStack", "class_uri": "src/main/java/org/ice4j/stack/StunStack.java.StunStack", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nAsserts the validity of a specific username (e.g. which we've received in\na USERNAME attribute).\n\n@param username the username to be validated\n@return <tt>true</tt> if <tt>username</tt> contains a valid username;\n<tt>false</tt>, otherwise\n"}, {"uris": "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[PacketLogger]getPacketLogger()", "name": "getPacketLogger", "arg_nums": 0, "params": [], "return_type": "PacketLogger", "signature": "public static PacketLogger getPacketLogger()", "original_string": "    public static PacketLogger getPacketLogger()\n    {\n        return packetLogger;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/StunStack.java", "class_name": "StunStack", "class_uri": "src/main/java/org/ice4j/stack/StunStack.java.StunStack", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "PacketLogger", "classes": []}, "docstring": "\nReturns the currently set packet logger.\n@return the currently available packet logger.\n"}, {"uris": "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[void]setPacketLogger(PacketLogger)", "name": "setPacketLogger", "arg_nums": 1, "params": [{"name": "packetLogger", "type": "PacketLogger"}], "return_type": "void", "signature": "public static void setPacketLogger(PacketLogger packetLogger)", "original_string": "    public static void setPacketLogger(PacketLogger packetLogger)\n    {\n        StunStack.packetLogger = packetLogger;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/StunStack.java", "class_name": "StunStack", "class_uri": "src/main/java/org/ice4j/stack/StunStack.java.StunStack", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSetting a packet logger for the stack.\n@param packetLogger the packet logger to use.\n"}, {"uris": "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[boolean]isPacketLoggerEnabled()", "name": "isPacketLoggerEnabled", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "public static boolean isPacketLoggerEnabled()", "original_string": "    public static boolean isPacketLoggerEnabled()\n    {\n        return packetLogger != null && packetLogger.isEnabled();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/StunStack.java", "class_name": "StunStack", "class_uri": "src/main/java/org/ice4j/stack/StunStack.java.StunStack", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nChecks whether packet logger is set and enabled.\n@return <tt>true</tt> if we have a packet logger instance and\n it is enabled.\n"}, {"uris": "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[Response]createCorrespondingErrorResponse(char,char,String)", "name": "createCorrespondingErrorResponse", "arg_nums": 3, "params": [{"name": "requestType", "type": "char"}, {"name": "errorCode", "type": "char"}, {"name": "reasonPhrase", "type": "String"}], "return_type": "Response", "signature": "public Response createCorrespondingErrorResponse(char requestType,\n        char errorCode, String reasonPhrase, char... unknownAttributes)", "original_string": "    public Response createCorrespondingErrorResponse(char requestType,\n        char errorCode, String reasonPhrase, char... unknownAttributes)\n    {\n        if (requestType == Message.BINDING_REQUEST)\n        {\n            if (unknownAttributes != null)\n            {\n                return MessageFactory.createBindingErrorResponse(\n                    errorCode, reasonPhrase, unknownAttributes);\n            }\n            else\n            {\n                return MessageFactory.createBindingErrorResponse(\n                    errorCode, reasonPhrase);\n            }\n        }\n        else\n        {\n            return null;\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/StunStack.java", "class_name": "StunStack", "class_uri": "src/main/java/org/ice4j/stack/StunStack.java.StunStack", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Response", "classes": []}, "docstring": "\nReturns the Error Response object with specified errorCode and\nreasonPhrase corresponding to input type.\n\n@param requestType the message type of Request.\n@param errorCode the errorCode for Error Response object.\n@param reasonPhrase the reasonPhrase for the Error Response object.\n@param unknownAttributes char[] array containing the ids of one or more\n           attributes that had not been recognized.\n@return corresponding Error Response object.\n"}, {"uris": "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[void]logPacketToPcap(DatagramPacket,boolean,InetAddress,int)", "name": "logPacketToPcap", "arg_nums": 4, "params": [{"name": "p", "type": "DatagramPacket"}, {"name": "isSent", "type": "boolean"}, {"name": "interfaceAddress", "type": "InetAddress"}, {"name": "interfacePort", "type": "int"}], "return_type": "void", "signature": "public static void logPacketToPcap(\n            DatagramPacket p,\n            boolean isSent,\n            InetAddress interfaceAddress,\n            int interfacePort)", "original_string": "    public static void logPacketToPcap(\n            DatagramPacket p,\n            boolean isSent,\n            InetAddress interfaceAddress,\n            int interfacePort)\n    {\n        if (interfaceAddress != null && isPacketLoggerEnabled())\n        {\n            InetAddress[] addr = {interfaceAddress, p.getAddress()};\n            int[] port = {interfacePort, p.getPort()};\n            int fromIndex = isSent ? 0 : 1;\n            int toIndex = isSent ? 1 : 0;\n\n            getPacketLogger().logPacket(\n                    addr[fromIndex].getAddress(),\n                    port[fromIndex],\n                    addr[toIndex].getAddress(),\n                    port[toIndex],\n                    p.getData(),\n                    isSent);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/StunStack.java", "class_name": "StunStack", "class_uri": "src/main/java/org/ice4j/stack/StunStack.java.StunStack", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nLogs a specific <tt>DatagramPacket</tt> using the packet logger of the\n<tt>StunStack</tt>.\n\n@param p The <tt>DatagramPacket</tt> to log.\n@param isSent <tt>true</tt> if the packet is sent, or <tt>false</tt>\nif the packet is received.\n@param interfaceAddress The <tt>InetAddress</tt> to use as source (if\nthe packet was sent) or destination (if the packet was received).\n@param interfacePort The port to use as source (if the packet was sent)\nor destination (if the packet was received).\n"}, {"uris": "src/main/java/org/ice4j/stack/ChannelDataEventHandler.java.ChannelDataEventHandler.[void]handleMessageEvent(ChannelDataMessageEvent)", "name": "handleMessageEvent", "arg_nums": 1, "params": [{"name": "messageEvent", "type": "ChannelDataMessageEvent"}], "return_type": "void", "signature": "public void handleMessageEvent(ChannelDataMessageEvent messageEvent)", "original_string": "    public void handleMessageEvent(ChannelDataMessageEvent messageEvent);", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/ChannelDataEventHandler.java", "class_name": "ChannelDataEventHandler", "class_uri": "src/main/java/org/ice4j/stack/ChannelDataEventHandler.java.ChannelDataEventHandler", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCalled when an incoming Channel Data message has been received, parsed\nand is ready for delivery.\n\n@param messageEvent the event object that encapsulates the newly received\n                    message.\n"}, {"uris": "src/main/java/org/ice4j/stack/PacketLogger.java.PacketLogger.[void]logPacket(byte[],int,byte[],int,byte[],boolean)", "name": "logPacket", "arg_nums": 6, "params": [{"name": "sourceAddress", "type": "byte[]"}, {"name": "sourcePort", "type": "int"}, {"name": "destinationAddress", "type": "byte[]"}, {"name": "destinationPort", "type": "int"}, {"name": "packetContent", "type": "byte[]"}, {"name": "sender", "type": "boolean"}], "return_type": "void", "signature": "public void logPacket(\n            byte[] sourceAddress,\n            int sourcePort,\n            byte[] destinationAddress,\n            int destinationPort,\n            byte[] packetContent,\n            boolean sender)", "original_string": "    public void logPacket(\n            byte[] sourceAddress,\n            int sourcePort,\n            byte[] destinationAddress,\n            int destinationPort,\n            byte[] packetContent,\n            boolean sender);", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/PacketLogger.java", "class_name": "PacketLogger", "class_uri": "src/main/java/org/ice4j/stack/PacketLogger.java.PacketLogger", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nLogs a incoming or outgoing packet.\n\n@param sourceAddress the source address of the packet.\n@param sourcePort the source port.\n@param destinationAddress the destination address of the packet.\n@param destinationPort the destination port.\n@param packetContent the content of the packet.\n@param sender whether we are sending or not the packet.\n"}, {"uris": "src/main/java/org/ice4j/stack/PacketLogger.java.PacketLogger.[boolean]isEnabled()", "name": "isEnabled", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "public boolean isEnabled()", "original_string": "    public boolean isEnabled();", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/PacketLogger.java", "class_name": "PacketLogger", "class_uri": "src/main/java/org/ice4j/stack/PacketLogger.java.PacketLogger", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nChecks whether the logger is enabled. \n@return <tt>true</tt> if the logger is enabled, <tt>false</tt>\n otherwise.\n"}, {"uris": "src/main/java/org/ice4j/stack/StunServerTransaction.java.StunServerTransaction.[]StunServerTransaction(StunStack,TransactionID,TransportAddress,TransportAddress)", "name": "StunServerTransaction", "arg_nums": 4, "params": [{"name": "stackCallback", "type": "StunStack"}, {"name": "tranID", "type": "TransactionID"}, {"name": "localListeningAddress", "type": "TransportAddress"}, {"name": "requestSource", "type": "TransportAddress"}], "return_type": "", "signature": "public StunServerTransaction(StunStack        stackCallback,\n                                 TransactionID    tranID,\n                                 TransportAddress localListeningAddress,\n                                 TransportAddress requestSource)", "original_string": "    public StunServerTransaction(StunStack        stackCallback,\n                                 TransactionID    tranID,\n                                 TransportAddress localListeningAddress,\n                                 TransportAddress requestSource)\n    {\n        this.stackCallback  = stackCallback;\n        this.transactionID  = tranID;\n        this.localListeningAddress = localListeningAddress;\n        this.requestSource = requestSource;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/StunServerTransaction.java", "class_name": "StunServerTransaction", "class_uri": "src/main/java/org/ice4j/stack/StunServerTransaction.java.StunServerTransaction", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nCreates a server transaction\n@param stackCallback the stack that created us.\n@param tranID the transaction id contained by the request that was the\ncause for this transaction.\n@param localListeningAddress the <tt>TransportAddress</tt> that this\ntransaction is receiving requests on.\n@param requestSource the <tt>TransportAddress</tt> that this\ntransaction is receiving requests from.\n"}, {"uris": "src/main/java/org/ice4j/stack/StunServerTransaction.java.StunServerTransaction.[void]start()", "name": "start", "arg_nums": 0, "params": [], "return_type": "void", "signature": "public synchronized void start()", "original_string": "    public synchronized void start()\n    {\n        if (expirationTime == -1)\n        {\n            expired = false;\n            expirationTime = LIFETIME + System.currentTimeMillis();\n        }\n        else\n        {\n            throw new IllegalStateException(\n                    \"StunServerTransaction \" + getTransactionID()\n                        + \" has already been started!\");\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/StunServerTransaction.java", "class_name": "StunServerTransaction", "class_uri": "src/main/java/org/ice4j/stack/StunServerTransaction.java.StunServerTransaction", "attributes": {"modifiers": "public synchronized", "marker_annotations": [], "non_marker_annotations": ["public", "synchronized"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nStart the transaction. This launches the countdown to the moment the\ntransaction would expire.\n"}, {"uris": "src/main/java/org/ice4j/stack/StunServerTransaction.java.StunServerTransaction.[void]sendResponse(Response,TransportAddress,TransportAddress)", "name": "sendResponse", "arg_nums": 3, "params": [{"name": "response", "type": "Response"}, {"name": "sendThrough", "type": "TransportAddress"}, {"name": "sendTo", "type": "TransportAddress"}], "return_type": "void", "signature": "public void sendResponse(Response         response,\n                             TransportAddress sendThrough,\n                             TransportAddress sendTo)", "original_string": "    public void sendResponse(Response         response,\n                             TransportAddress sendThrough,\n                             TransportAddress sendTo)\n        throws StunException,\n               IOException,\n               IllegalArgumentException\n    {\n        if (!isRetransmitting)\n        {\n            this.response = response;\n            //the transaction id might already have been set, but its our job\n            //to make sure of that\n            response.setTransactionID(this.transactionID.getBytes());\n            this.localSendingAddress   = sendThrough;\n            this.responseDestination   = sendTo;\n        }\n\n        isRetransmitting = true;\n        retransmitResponse();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/StunServerTransaction.java", "class_name": "StunServerTransaction", "class_uri": "src/main/java/org/ice4j/stack/StunServerTransaction.java.StunServerTransaction", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSends the specified response through the <code>sendThrough</code>\nNetAccessPoint descriptor to the specified destination and changes\nthe transaction's state to retransmitting.\n\n@param response the response to send the transaction to.\n@param sendThrough the local address through which responses are to\nbe sent\n@param sendTo the destination for responses of this transaction.\n\n@throws IOException  if an error occurs while sending message bytes\nthrough the network socket.\n@throws IllegalArgumentException if the apDescriptor references an\naccess point that had not been installed,\n@throws StunException if message encoding fails,\n"}, {"uris": "src/main/java/org/ice4j/stack/StunServerTransaction.java.StunServerTransaction.[void]retransmitResponse()", "name": "retransmitResponse", "arg_nums": 0, "params": [], "return_type": "void", "signature": "protected void retransmitResponse()", "original_string": "    protected void retransmitResponse()\n        throws StunException,\n               IOException,\n               IllegalArgumentException\n    {\n        //don't retransmit if we are expired or if the user application\n        //hasn't yet transmitted a first response\n        if (isExpired() || !isRetransmitting)\n            return;\n\n        stackCallback.getNetAccessManager().sendMessage(\n                response,\n                localSendingAddress,\n                responseDestination);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/StunServerTransaction.java", "class_name": "StunServerTransaction", "class_uri": "src/main/java/org/ice4j/stack/StunServerTransaction.java.StunServerTransaction", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nRetransmits the response that was originally sent to the request that\ncaused this transaction.\n\n@throws IOException  if an error occurs while sending message bytes\nthrough the network socket.\n@throws IllegalArgumentException if the apDescriptor references an\naccess point that had not been installed,\n@throws StunException if message encoding fails,\n"}, {"uris": "src/main/java/org/ice4j/stack/StunServerTransaction.java.StunServerTransaction.[void]expire()", "name": "expire", "arg_nums": 0, "params": [], "return_type": "void", "signature": "public synchronized void expire()", "original_string": "    public synchronized void expire()\n    {\n        expired = true;\n        /*\n         * StunStack has a background Thread running with the purpose of\n         * removing expired StunServerTransactions.\n         */\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/StunServerTransaction.java", "class_name": "StunServerTransaction", "class_uri": "src/main/java/org/ice4j/stack/StunServerTransaction.java.StunServerTransaction", "attributes": {"modifiers": "public synchronized", "marker_annotations": [], "non_marker_annotations": ["public", "synchronized"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCancels the transaction. Once this method is called the transaction is\nconsidered terminated and will stop retransmissions.\n"}, {"uris": "src/main/java/org/ice4j/stack/StunServerTransaction.java.StunServerTransaction.[boolean]isExpired()", "name": "isExpired", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "public boolean isExpired()", "original_string": "    public boolean isExpired()\n    {\n        return isExpired(System.currentTimeMillis());\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/StunServerTransaction.java", "class_name": "StunServerTransaction", "class_uri": "src/main/java/org/ice4j/stack/StunServerTransaction.java.StunServerTransaction", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nDetermines whether this <tt>StunServerTransaction</tt> is expired now.\n\n@return <tt>true</tt> if this <tt>StunServerTransaction</tT> is expired\nnow; otherwise, <tt>false</tt>\n"}, {"uris": "src/main/java/org/ice4j/stack/StunServerTransaction.java.StunServerTransaction.[boolean]isExpired(long)", "name": "isExpired", "arg_nums": 1, "params": [{"name": "now", "type": "long"}], "return_type": "boolean", "signature": "public synchronized boolean isExpired(long now)", "original_string": "    public synchronized boolean isExpired(long now)\n    {\n        if (expirationTime == -1)\n            return false;\n        else if (expirationTime < now)\n            return true;\n        else\n            return expired;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/StunServerTransaction.java", "class_name": "StunServerTransaction", "class_uri": "src/main/java/org/ice4j/stack/StunServerTransaction.java.StunServerTransaction", "attributes": {"modifiers": "public synchronized", "marker_annotations": [], "non_marker_annotations": ["public", "synchronized"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nDetermines whether this <tt>StunServerTransaction</tt> will be expired at\na specific point in time.\n\n@param now the time in milliseconds at which the <tt>expired</tt> state\nof this <tt>StunServerTransaction</tt> is to be returned\n@return <tt>true</tt> if this <tt>StunServerTransaction</tt> will be\nexpired at the specified point in time; otherwise, <tt>false</tt>\n"}, {"uris": "src/main/java/org/ice4j/stack/StunServerTransaction.java.StunServerTransaction.[TransactionID]getTransactionID()", "name": "getTransactionID", "arg_nums": 0, "params": [], "return_type": "TransactionID", "signature": "public TransactionID getTransactionID()", "original_string": "    public TransactionID getTransactionID()\n    {\n        return transactionID;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/StunServerTransaction.java", "class_name": "StunServerTransaction", "class_uri": "src/main/java/org/ice4j/stack/StunServerTransaction.java.StunServerTransaction", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "TransactionID", "classes": []}, "docstring": "\nReturns the ID of the current transaction.\n\n@return the ID of the transaction.\n"}, {"uris": "src/main/java/org/ice4j/stack/StunServerTransaction.java.StunServerTransaction.[boolean]isRetransmitting()", "name": "isRetransmitting", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "public boolean isRetransmitting()", "original_string": "    public boolean isRetransmitting()\n    {\n        return isRetransmitting;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/StunServerTransaction.java", "class_name": "StunServerTransaction", "class_uri": "src/main/java/org/ice4j/stack/StunServerTransaction.java.StunServerTransaction", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nSpecifies whether this server transaction is in the retransmitting state.\nOr in other words - has it already sent a first response or not?\n\n@return <tt>true</tt> if this transaction is still retransmitting and\nfalse <tt>otherwise</tt>\n"}, {"uris": "src/main/java/org/ice4j/stack/StunServerTransaction.java.StunServerTransaction.[TransportAddress]getSendingAddress()", "name": "getSendingAddress", "arg_nums": 0, "params": [], "return_type": "TransportAddress", "signature": "public TransportAddress getSendingAddress()", "original_string": "    public TransportAddress getSendingAddress()\n    {\n        return localSendingAddress;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/StunServerTransaction.java", "class_name": "StunServerTransaction", "class_uri": "src/main/java/org/ice4j/stack/StunServerTransaction.java.StunServerTransaction", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "TransportAddress", "classes": []}, "docstring": "\nReturns the local <tt>TransportAddress</tt> that this transaction is\nsending responses from.\n\n@return the local <tt>TransportAddress</tt> that this transaction is\nsending responses from.\n"}, {"uris": "src/main/java/org/ice4j/stack/StunServerTransaction.java.StunServerTransaction.[TransportAddress]getResponseDestinationAddress()", "name": "getResponseDestinationAddress", "arg_nums": 0, "params": [], "return_type": "TransportAddress", "signature": "public TransportAddress getResponseDestinationAddress()", "original_string": "    public TransportAddress getResponseDestinationAddress()\n    {\n        return responseDestination;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/StunServerTransaction.java", "class_name": "StunServerTransaction", "class_uri": "src/main/java/org/ice4j/stack/StunServerTransaction.java.StunServerTransaction", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "TransportAddress", "classes": []}, "docstring": "\nReturns the remote <tt>TransportAddress</tt> that this transaction is\nreceiving requests from.\n\n@return the remote <tt>TransportAddress</tt> that this transaction is\nreceiving requests from.\n"}, {"uris": "src/main/java/org/ice4j/stack/StunServerTransaction.java.StunServerTransaction.[TransportAddress]getLocalListeningAddress()", "name": "getLocalListeningAddress", "arg_nums": 0, "params": [], "return_type": "TransportAddress", "signature": "public TransportAddress getLocalListeningAddress()", "original_string": "    public TransportAddress getLocalListeningAddress()\n    {\n        return localListeningAddress;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/StunServerTransaction.java", "class_name": "StunServerTransaction", "class_uri": "src/main/java/org/ice4j/stack/StunServerTransaction.java.StunServerTransaction", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "TransportAddress", "classes": []}, "docstring": "\nReturns the local <tt>TransportAddress</tt> that this transaction is\nreceiving requests on.\n\n@return the local <tt>TransportAddress</tt> that this transaction is\nreceiving requests on.\n"}, {"uris": "src/main/java/org/ice4j/stack/StunServerTransaction.java.StunServerTransaction.[TransportAddress]getRequestSourceAddress()", "name": "getRequestSourceAddress", "arg_nums": 0, "params": [], "return_type": "TransportAddress", "signature": "public TransportAddress getRequestSourceAddress()", "original_string": "    public TransportAddress getRequestSourceAddress()\n    {\n        return requestSource;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/StunServerTransaction.java", "class_name": "StunServerTransaction", "class_uri": "src/main/java/org/ice4j/stack/StunServerTransaction.java.StunServerTransaction", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "TransportAddress", "classes": []}, "docstring": "\nReturns the remote <tt>TransportAddress</tt> that this transaction is\nreceiving requests from.\n\n@return the remote <tt>TransportAddress</tt> that this transaction is\nreceiving requests from.\n"}, {"uris": "src/main/java/org/ice4j/stack/StunServerTransaction.java.StunServerTransaction.[Response]getResponse()", "name": "getResponse", "arg_nums": 0, "params": [], "return_type": "Response", "signature": "protected Response getResponse()", "original_string": "    protected Response getResponse()\n    {\n        return response;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/StunServerTransaction.java", "class_name": "StunServerTransaction", "class_uri": "src/main/java/org/ice4j/stack/StunServerTransaction.java.StunServerTransaction", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Response", "classes": []}, "docstring": "\nReturns the <tt>Response</tt> that the <tt>StunStack</tt> has sent\nthrough this transaction or <tt>null</tt> if no <tt>Response</tt> has\nbeen sent yet.\n\n@return the <tt>Response</tt> that the <tt>StunStack</tt> has sent\nthrough this transaction or <tt>null</tt> if no <tt>Response</tt> has\nbeen sent yet.\n"}, {"uris": "src/main/java/org/ice4j/stack/PeerUdpMessageEventHandler.java.PeerUdpMessageEventHandler.[void]handleMessageEvent(PeerUdpMessageEvent)", "name": "handleMessageEvent", "arg_nums": 1, "params": [{"name": "messageEvent", "type": "PeerUdpMessageEvent"}], "return_type": "void", "signature": "public void handleMessageEvent(PeerUdpMessageEvent messageEvent)", "original_string": "    public void handleMessageEvent(PeerUdpMessageEvent messageEvent);", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/PeerUdpMessageEventHandler.java", "class_name": "PeerUdpMessageEventHandler", "class_uri": "src/main/java/org/ice4j/stack/PeerUdpMessageEventHandler.java.PeerUdpMessageEventHandler", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCalled when an incoming Peer UDP message has been received, parsed\nand is ready for delivery.\n\n@param messageEvent the event object that encapsulates the newly received\n                    message.\n"}, {"uris": "src/main/java/org/ice4j/stack/Connector.java.Connector.[]Connector(IceSocketWrapper,TransportAddress,Consumer<RawMessage>,ErrorHandler)", "name": "Connector", "arg_nums": 4, "params": [{"name": "socket", "type": "IceSocketWrapper"}, {"name": "remoteAddress", "type": "TransportAddress"}, {"name": "messageConsumer", "type": "Consumer<RawMessage>"}, {"name": "errorHandler", "type": "ErrorHandler"}], "return_type": "", "signature": "protected Connector(IceSocketWrapper socket,\n                        TransportAddress remoteAddress,\n                        Consumer<RawMessage> messageConsumer,\n                        ErrorHandler   errorHandler)", "original_string": "    protected Connector(IceSocketWrapper socket,\n                        TransportAddress remoteAddress,\n                        Consumer<RawMessage> messageConsumer,\n                        ErrorHandler   errorHandler)\n    {\n        this.sock = socket;\n        this.messageConsumer = messageConsumer;\n        this.errorHandler = errorHandler;\n        this.remoteAddress = remoteAddress;\n\n        Transport transport\n            = socket.getUDPSocket() != null ? Transport.UDP : Transport.TCP;\n\n        listenAddress\n            = new TransportAddress(socket.getLocalAddress(),\n                                   socket.getLocalPort(),\n                                   transport);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/Connector.java", "class_name": "Connector", "class_uri": "src/main/java/org/ice4j/stack/Connector.java.Connector", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nCreates a network access point.\n@param socket the socket that this access point is supposed to use for\ncommunication.\n@param remoteAddress the remote address of the socket of this\n{@link Connector} if it is a TCP socket, or null if it is UDP.\n@param messageConsumer the incoming messages consumer\n@param errorHandler the instance to notify when errors occur.\n"}, {"uris": "src/main/java/org/ice4j/stack/Connector.java.Connector.[void]start()", "name": "start", "arg_nums": 0, "params": [], "return_type": "void", "signature": "void start()", "original_string": "    void start()\n    {\n        this.running = true;\n\n        Thread thread = new Thread(this, \"IceConnector@\" + hashCode());\n\n        thread.setDaemon(true);\n        thread.start();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/Connector.java", "class_name": "Connector", "class_uri": "src/main/java/org/ice4j/stack/Connector.java.Connector", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nStart the network listening thread.\n"}, {"uris": "src/main/java/org/ice4j/stack/Connector.java.Connector.[IceSocketWrapper]getSocket()", "name": "getSocket", "arg_nums": 0, "params": [], "return_type": "IceSocketWrapper", "signature": "protected IceSocketWrapper getSocket()", "original_string": "    protected IceSocketWrapper getSocket()\n    {\n        return sock;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/Connector.java", "class_name": "Connector", "class_uri": "src/main/java/org/ice4j/stack/Connector.java.Connector", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "IceSocketWrapper", "classes": []}, "docstring": "\nReturns the <tt>DatagramSocket</tt> that contains the port and address\nassociated with this access point.\n\n@return the <tt>DatagramSocket</tt> associated with this AP.\n"}, {"uris": "src/main/java/org/ice4j/stack/Connector.java.Connector.[void]run()", "name": "run", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Override\n    public void run()", "original_string": "    @Override\n    public void run()\n    {\n        DatagramPacket packet = null;\n\n        while (this.running)\n        {\n            try\n            {\n                IceSocketWrapper localSock;\n\n                synchronized (sockLock)\n                {\n                    if (!running)\n                        return;\n\n                    localSock = this.sock;\n                }\n\n                /*\n                 * Make sure localSock's receiveBufferSize is taken into\n                 * account including after it gets changed.\n                 */\n                int receiveBufferSize = 1500;\n                /*\n                if(localSock.getTCPSocket() != null)\n                {\n                    receiveBufferSize = localSock.getTCPSocket().\n                        getReceiveBufferSize();\n                }\n                else if(localSock.getUDPSocket() != null)\n                {\n                    receiveBufferSize = localSock.getUDPSocket().\n                        getReceiveBufferSize();\n                }\n                */\n\n                if (packet == null)\n                {\n                    packet\n                        = new DatagramPacket(\n                                new byte[receiveBufferSize],\n                                receiveBufferSize);\n                }\n                else\n                {\n                    byte[] packetData = packet.getData();\n\n                    if ((packetData == null)\n                            || (packetData.length < receiveBufferSize))\n                    {\n                        packet.setData(\n                                new byte[receiveBufferSize],\n                                0,\n                                receiveBufferSize);\n                    }\n                    else\n                    {\n                        /*\n                         * XXX Tell the packet it is large enough because the\n                         * socket will not look at the length of the data array\n                         * property and will just respect the length property.\n                         */\n                        packet.setLength(receiveBufferSize);\n                    }\n                }\n\n                localSock.receive(packet);\n\n                //get lost if we are no longer running.\n                if (!running)\n                    return;\n\n                if (logger.isLoggable(Level.FINEST))\n                {\n                    logger.finest(\"received datagram packet - addr: \"\n                            + packet.getAddress() + \" port: \" + packet.getPort());\n                }\n                if (packet.getPort() < 0)\n                {\n                    logger.warning(\"Out of range packet port, resetting to 0\");\n                    // force a minimum port of 0 to prevent out of range errors\n                    packet.setPort(0);\n                }\n\n                RawMessage rawMessage\n                    = new RawMessage(\n                            packet.getData(),\n                            packet.getLength(),\n                            new TransportAddress(\n                                    packet.getAddress(),\n                                    packet.getPort(),\n                                    listenAddress.getTransport()),\n                            listenAddress);\n\n                messageConsumer.accept(rawMessage);\n            }\n            catch (SocketException ex)\n            {\n                if (running)\n                {\n                    logger.log(\n                            Level.WARNING,\n                            \"Connector died: \" + listenAddress + \" -> \"\n                                    + remoteAddress,\n                            ex);\n\n                    stop();\n                    //Something wrong has happened\n                    errorHandler.handleFatalError(\n                            this,\n                            \"A socket exception was thrown\"\n                                + \" while trying to receive a message.\",\n                            ex);\n                }\n                else\n                {\n                    //The exception was most probably caused by calling\n                    //this.stop().\n                }\n            }\n            catch (ClosedChannelException cce)\n            {\n                // The socket was closed, possibly by the remote peer.\n                // If we were already stopped, just ignore it.\n                if (running)\n                {\n                    // We could be the first thread to realize that the socket\n                    // was closed. But that's normal operation, so don't\n                    // complain too much.\n                    stop();\n                    errorHandler.handleFatalError(\n                        this,\n                        \"The socket was closed:\",\n                        null);\n                }\n            }\n            catch (IOException ex)\n            {\n                logger.log(Level.WARNING,\n                           \"A net access point has gone useless:\", ex);\n\n                errorHandler.handleError(ex.getMessage(), ex);\n                //do not stop the thread;\n            }\n            catch (Throwable ex)\n            {\n                logger.log(Level.WARNING,\n                           \"A net access point has gone useless:\", ex);\n\n                stop();\n                errorHandler.handleFatalError(\n                        this,\n                        \"Unknown error occurred while listening for messages!\",\n                        ex);\n            }\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/Connector.java", "class_name": "Connector", "class_uri": "src/main/java/org/ice4j/stack/Connector.java.Connector", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nThe listening thread's run method.\n"}, {"uris": "src/main/java/org/ice4j/stack/Connector.java.Connector.[void]stop()", "name": "stop", "arg_nums": 0, "params": [], "return_type": "void", "signature": "protected void stop()", "original_string": "    protected void stop()\n    {\n        synchronized(sockLock)\n        {\n            this.running = false;\n            if (this.sock != null)\n            {\n                this.sock.close();\n                this.sock = null;\n            }\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/Connector.java", "class_name": "Connector", "class_uri": "src/main/java/org/ice4j/stack/Connector.java.Connector", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nMakes the access point stop listening on its socket.\n"}, {"uris": "src/main/java/org/ice4j/stack/Connector.java.Connector.[void]sendMessage(byte[],TransportAddress)", "name": "sendMessage", "arg_nums": 2, "params": [{"name": "message", "type": "byte[]"}, {"name": "address", "type": "TransportAddress"}], "return_type": "void", "signature": "void sendMessage(byte[] message, TransportAddress address)", "original_string": "    void sendMessage(byte[] message, TransportAddress address)\n        throws IOException\n    {\n        DatagramPacket datagramPacket\n            = new DatagramPacket(message, 0, message.length, address);\n\n        IceSocketWrapper sock = this.sock;\n        if (sock != null)\n        {\n            sock.send(datagramPacket);\n        }\n        else\n        {\n            logger.warning(\"Can not send message, Connector stopped.\");\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/Connector.java", "class_name": "Connector", "class_uri": "src/main/java/org/ice4j/stack/Connector.java.Connector", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSends message through this access point's socket.\n\n@param message the bytes to send.\n@param address message destination.\n\n@throws IOException if an exception occurs while sending the message.\n"}, {"uris": "src/main/java/org/ice4j/stack/Connector.java.Connector.[String]toString()", "name": "toString", "arg_nums": 0, "params": [], "return_type": "String", "signature": "@Override\n    public String toString()", "original_string": "    @Override\n    public String toString()\n    {\n        return\n            \"ice4j.Connector@\" + listenAddress\n                + \" status: \" + (running ? \"not\" : \"\") +\" running\";\n     }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/Connector.java", "class_name": "Connector", "class_uri": "src/main/java/org/ice4j/stack/Connector.java.Connector", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns a String representation of the object.\n@return a String representation of the object.\n"}, {"uris": "src/main/java/org/ice4j/stack/Connector.java.Connector.[TransportAddress]getListenAddress()", "name": "getListenAddress", "arg_nums": 0, "params": [], "return_type": "TransportAddress", "signature": "TransportAddress getListenAddress()", "original_string": "     TransportAddress getListenAddress()\n     {\n         return listenAddress;\n     }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/Connector.java", "class_name": "Connector", "class_uri": "src/main/java/org/ice4j/stack/Connector.java.Connector", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "TransportAddress", "classes": []}, "docstring": "\nReturns the <tt>TransportAddress</tt> that this access point is bound\non.\n\n@return the <tt>TransportAddress</tt> associated with this AP.\n"}, {"uris": "src/main/java/org/ice4j/stack/Connector.java.Connector.[TransportAddress]getRemoteAddress()", "name": "getRemoteAddress", "arg_nums": 0, "params": [], "return_type": "TransportAddress", "signature": "TransportAddress getRemoteAddress()", "original_string": "    TransportAddress getRemoteAddress()\n    {\n        return remoteAddress;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/Connector.java", "class_name": "Connector", "class_uri": "src/main/java/org/ice4j/stack/Connector.java.Connector", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "TransportAddress", "classes": []}, "docstring": "\nReturns the remote <tt>TransportAddress</tt> or <tt>null</tt> if none\nis specified.\n\n@return the remote <tt>TransportAddress</tt> or <tt>null</tt> if none\nis specified.\n"}, {"uris": "src/main/java/org/ice4j/stack/ErrorHandler.java.ErrorHandler.[void]handleError(String,Throwable)", "name": "handleError", "arg_nums": 2, "params": [{"name": "message", "type": "String"}, {"name": "error", "type": "Throwable"}], "return_type": "void", "signature": "public void handleError(String message, Throwable error)", "original_string": "    public void handleError(String message, Throwable error);", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/ErrorHandler.java", "class_name": "ErrorHandler", "class_uri": "src/main/java/org/ice4j/stack/ErrorHandler.java.ErrorHandler", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCalled when an error has occurred which may have caused data loss but the\ncalling thread is still running.\n\n@param message A message describing the error\n@param error   The error itself.\n"}, {"uris": "src/main/java/org/ice4j/stack/ErrorHandler.java.ErrorHandler.[void]handleFatalError(Runnable,String,Throwable)", "name": "handleFatalError", "arg_nums": 3, "params": [{"name": "callingThread", "type": "Runnable"}, {"name": "message", "type": "String"}, {"name": "error", "type": "Throwable"}], "return_type": "void", "signature": "public void handleFatalError(Runnable callingThread,\n                                 String message,\n                                 Throwable error)", "original_string": "    public void handleFatalError(Runnable callingThread,\n                                 String message,\n                                 Throwable error);", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/ErrorHandler.java", "class_name": "ErrorHandler", "class_uri": "src/main/java/org/ice4j/stack/ErrorHandler.java.ErrorHandler", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCalled when a fatal error has occurred and the calling thread will exit.\n\n@param callingThread the thread where the error has occurred\n@param message       a message describing the error.\n@param error         the error itself.\n"}, {"uris": "src/main/java/org/ice4j/stack/RequestListener.java.RequestListener.[void]processRequest(StunMessageEvent)", "name": "processRequest", "arg_nums": 1, "params": [{"name": "evt", "type": "StunMessageEvent"}], "return_type": "void", "signature": "public void processRequest(StunMessageEvent evt)", "original_string": "    public void processRequest(StunMessageEvent evt)\n        throws IllegalArgumentException;", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/RequestListener.java", "class_name": "RequestListener", "class_uri": "src/main/java/org/ice4j/stack/RequestListener.java.RequestListener", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCalled when delivering incoming STUN requests. Throwing an\n{@link IllegalArgumentException} from within this method would cause the\nstack to reply with a <tt>400 Bad Request</tt> {@link Response} using\nthe exception's message as a reason phrase for the error response. Any\nother exception would result in a <tt>500 Server Error</tt> {@link\nResponse}.\n\n@param evt the event containing the incoming STUN request.\n\n@throws IllegalArgumentException if <tt>evt</tt> contains a malformed\n{@link Request} and the stack would need to response with a\n<tt>400 Bad Request</tt> {@link Response}.\n"}, {"uris": "src/main/java/org/ice4j/stack/TransactionID.java.TransactionID.[]TransactionID()", "name": "TransactionID", "arg_nums": 0, "params": [], "return_type": "", "signature": "private TransactionID()", "original_string": "    private TransactionID()\n    {\n        this(false);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/TransactionID.java", "class_name": "TransactionID", "class_uri": "src/main/java/org/ice4j/stack/TransactionID.java.TransactionID", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nLimits access to <tt>TransactionID</tt> instantiation.\n"}, {"uris": "src/main/java/org/ice4j/stack/TransactionID.java.TransactionID.[]TransactionID(boolean)", "name": "TransactionID", "arg_nums": 1, "params": [{"name": "rfc3489Compatibility", "type": "boolean"}], "return_type": "", "signature": "private TransactionID(boolean rfc3489Compatibility)", "original_string": "    private TransactionID(boolean rfc3489Compatibility)\n    {\n        transactionID\n            = new byte[\n                    rfc3489Compatibility\n                        ? RFC3489_TRANSACTION_ID_LENGTH\n                        : RFC5389_TRANSACTION_ID_LENGTH];\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/TransactionID.java", "class_name": "TransactionID", "class_uri": "src/main/java/org/ice4j/stack/TransactionID.java.TransactionID", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nLimits access to <tt>TransactionID</tt> instantiation.\n\n@param rfc3489Compatibility true to create a RFC3489 transaction ID\n"}, {"uris": "src/main/java/org/ice4j/stack/TransactionID.java.TransactionID.[TransactionID]createNewTransactionID()", "name": "createNewTransactionID", "arg_nums": 0, "params": [], "return_type": "TransactionID", "signature": "public static TransactionID createNewTransactionID()", "original_string": "    public static TransactionID createNewTransactionID()\n    {\n        TransactionID tid = new TransactionID();\n\n        generateTransactionID(tid, 12);\n        return tid;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/TransactionID.java", "class_name": "TransactionID", "class_uri": "src/main/java/org/ice4j/stack/TransactionID.java.TransactionID", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "TransactionID", "classes": []}, "docstring": "\nCreates a transaction id object.The transaction id itself is generated\nusing the following algorithm:\n\nThe first 6 bytes of the id are given the value of\n<tt>System.currentTimeMillis()</tt>. Putting the right most bits first\nso that we get a more optimized equals() method.\n\n@return A <tt>TransactionID</tt> object with a unique transaction id.\n"}, {"uris": "src/main/java/org/ice4j/stack/TransactionID.java.TransactionID.[TransactionID]createNewRFC3489TransactionID()", "name": "createNewRFC3489TransactionID", "arg_nums": 0, "params": [], "return_type": "TransactionID", "signature": "public static TransactionID createNewRFC3489TransactionID()", "original_string": "    public static TransactionID createNewRFC3489TransactionID()\n    {\n        TransactionID tid = new TransactionID(true);\n\n        generateTransactionID(tid, 16);\n        return tid;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/TransactionID.java", "class_name": "TransactionID", "class_uri": "src/main/java/org/ice4j/stack/TransactionID.java.TransactionID", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "TransactionID", "classes": []}, "docstring": "\nCreates a RFC3489 transaction id object.The transaction id itself is\ngenerated using the following algorithm:\n\nThe first 8 bytes of the id are given the value of\n<tt>System.currentTimeMillis()</tt>. Putting the right most bits first\nso that we get a more optimized equals() method.\n\n@return A <tt>TransactionID</tt> object with a unique transaction id.\n"}, {"uris": "src/main/java/org/ice4j/stack/TransactionID.java.TransactionID.[void]generateTransactionID(TransactionID,int)", "name": "generateTransactionID", "arg_nums": 2, "params": [{"name": "tid", "type": "TransactionID"}, {"name": "nb", "type": "int"}], "return_type": "void", "signature": "private static void generateTransactionID(TransactionID tid, int nb)", "original_string": "    private static void generateTransactionID(TransactionID tid, int nb)\n    {\n        long left  = System.currentTimeMillis(); //the first nb/2 bytes of the id\n        long right = random.nextLong(); //the last nb/2 bytes of the id\n        int b = nb / 2;\n\n        for (int i = 0; i < b; i++)\n        {\n            tid.transactionID[i]   = (byte)((left  >> (i * 8)) & 0xFFL);\n            tid.transactionID[i + b] = (byte)((right >> (i * 8)) & 0xFFL);\n        }\n\n        //calculate hashcode for Hashtable storage.\n        tid.hashCode =   (tid.transactionID[3] << 24 & 0xFF000000)\n                       | (tid.transactionID[2] << 16 & 0x00FF0000)\n                       | (tid.transactionID[1] << 8  & 0x0000FF00)\n                       | (tid.transactionID[0]       & 0x000000FF);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/TransactionID.java", "class_name": "TransactionID", "class_uri": "src/main/java/org/ice4j/stack/TransactionID.java.TransactionID", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nGenerates a random transaction ID\n\n@param tid transaction ID\n@param nb number of bytes to generate\n"}, {"uris": "src/main/java/org/ice4j/stack/TransactionID.java.TransactionID.[TransactionID]createTransactionID(StunStack,byte[])", "name": "createTransactionID", "arg_nums": 2, "params": [{"name": "stunStack", "type": "StunStack"}, {"name": "transactionID", "type": "byte[]"}], "return_type": "TransactionID", "signature": "public static TransactionID createTransactionID(\n            StunStack stunStack,\n            byte[] transactionID)", "original_string": "    public static TransactionID createTransactionID(\n            StunStack stunStack,\n            byte[] transactionID)\n    {\n        //first check whether we can find a client or a server tran with the\n        //specified id.\n        StunClientTransaction cliTran\n            = stunStack.getClientTransaction(transactionID);\n\n        if (cliTran != null)\n            return cliTran.getTransactionID();\n\n        StunServerTransaction serTran\n            = stunStack.getServerTransaction(transactionID);\n\n        if (serTran != null)\n            return serTran.getTransactionID();\n\n        //seems that the caller really wants a new ID\n        TransactionID tid = null;\n        tid = new TransactionID((transactionID.length == 16));\n\n        System.arraycopy(transactionID, 0, tid.transactionID, 0,\n                tid.transactionID.length);\n\n        //calculate hashcode for Hashtable storage.\n        tid.hashCode =   (tid.transactionID[3] << 24 & 0xFF000000)\n                       | (tid.transactionID[2] << 16 & 0x00FF0000)\n                       | (tid.transactionID[1] << 8  & 0x0000FF00)\n                       | (tid.transactionID[0]       & 0x000000FF);\n\n        return tid;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/TransactionID.java", "class_name": "TransactionID", "class_uri": "src/main/java/org/ice4j/stack/TransactionID.java.TransactionID", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "TransactionID", "classes": []}, "docstring": "\nReturns a <tt>TransactionID</tt> instance for the specified id. If\n<tt>transactionID</tt> is the ID of a client or a server transaction\nalready known to the stack, then this method would return a reference\nto that transaction's instance so that we could use it to for storing\napplication data.\n\n@param stunStack the <tt>StunStack</tt> in the context of which the\nrequest to create a <tt>TransactionID</tt> is being made\n@param transactionID the value of the ID.\n\n@return a reference to the (possibly already existing)\n<tt>TransactionID</tt> corresponding to the value of\n<tt>transactionID</tt>\n"}, {"uris": "src/main/java/org/ice4j/stack/TransactionID.java.TransactionID.[byte[]]getBytes()", "name": "getBytes", "arg_nums": 0, "params": [], "return_type": "byte[]", "signature": "public byte[] getBytes()", "original_string": "    public byte[] getBytes()\n    {\n        return transactionID;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/TransactionID.java", "class_name": "TransactionID", "class_uri": "src/main/java/org/ice4j/stack/TransactionID.java.TransactionID", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "byte[]", "classes": []}, "docstring": "\nReturns the transaction id byte array (length 12 or 16 if RFC3489\ncompatible).\n\n@return the transaction ID byte array.\n"}, {"uris": "src/main/java/org/ice4j/stack/TransactionID.java.TransactionID.[boolean]isRFC3489Compatible()", "name": "isRFC3489Compatible", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "public boolean isRFC3489Compatible()", "original_string": "    public boolean isRFC3489Compatible()\n    {\n        return (transactionID.length == 16);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/TransactionID.java", "class_name": "TransactionID", "class_uri": "src/main/java/org/ice4j/stack/TransactionID.java.TransactionID", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nIf the transaction is compatible with RFC3489 (16 bytes).\n\n@return true if transaction ID is compatible with RFC3489\n"}, {"uris": "src/main/java/org/ice4j/stack/TransactionID.java.TransactionID.[boolean]equals(Object)", "name": "equals", "arg_nums": 1, "params": [{"name": "obj", "type": "Object"}], "return_type": "boolean", "signature": "public boolean equals(Object obj)", "original_string": "    public boolean equals(Object obj)\n    {\n        if (this == obj)\n            return true;\n        if (!(obj instanceof TransactionID))\n            return false;\n\n        byte targetBytes[] = ((TransactionID)obj).transactionID;\n\n        return Arrays.equals(transactionID, targetBytes);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/TransactionID.java", "class_name": "TransactionID", "class_uri": "src/main/java/org/ice4j/stack/TransactionID.java.TransactionID", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nCompares two TransactionID objects.\n@param obj the object to compare with.\n@return true if the objects are equal and false otherwise.\n"}, {"uris": "src/main/java/org/ice4j/stack/TransactionID.java.TransactionID.[boolean]equals(byte[])", "name": "equals", "arg_nums": 1, "params": [{"name": "targetID", "type": "byte[]"}], "return_type": "boolean", "signature": "public boolean equals(byte[] targetID)", "original_string": "    public boolean equals(byte[] targetID)\n    {\n        return Arrays.equals(transactionID, targetID);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/TransactionID.java", "class_name": "TransactionID", "class_uri": "src/main/java/org/ice4j/stack/TransactionID.java.TransactionID", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nCompares the specified byte array with this transaction id.\n@param targetID the id to compare with ours.\n@return true if targetID matches this transaction id.\n"}, {"uris": "src/main/java/org/ice4j/stack/TransactionID.java.TransactionID.[int]hashCode()", "name": "hashCode", "arg_nums": 0, "params": [], "return_type": "int", "signature": "public int hashCode()", "original_string": "    public int hashCode()\n    {\n        return hashCode;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/TransactionID.java", "class_name": "TransactionID", "class_uri": "src/main/java/org/ice4j/stack/TransactionID.java.TransactionID", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\nReturns the first four bytes of the transactionID to ensure proper\nretrieval from hashtables.\n@return the hashcode of this object - as advised by the Java Platform\nSpecification\n"}, {"uris": "src/main/java/org/ice4j/stack/TransactionID.java.TransactionID.[String]toString()", "name": "toString", "arg_nums": 0, "params": [], "return_type": "String", "signature": "public String toString()", "original_string": "    public String toString()\n    {\n        return TransactionID.toString(transactionID);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/TransactionID.java", "class_name": "TransactionID", "class_uri": "src/main/java/org/ice4j/stack/TransactionID.java.TransactionID", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns a string representation of the ID\n\n@return a hex string representing the id\n"}, {"uris": "src/main/java/org/ice4j/stack/TransactionID.java.TransactionID.[String]toString(byte[])", "name": "toString", "arg_nums": 1, "params": [{"name": "transactionID", "type": "byte[]"}], "return_type": "String", "signature": "public static String toString(byte[] transactionID)", "original_string": "    public static String toString(byte[] transactionID)\n    {\n        StringBuilder idStr = new StringBuilder();\n\n        idStr.append(\"0x\");\n        for (int i = 0; i < transactionID.length; i++)\n        {\n\n            if ((transactionID[i] & 0xFF) <= 15)\n                idStr.append(\"0\");\n\n            idStr.append(\n                    Integer.toHexString(transactionID[i] & 0xFF).toUpperCase());\n        }\n\n        return idStr.toString();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/TransactionID.java", "class_name": "TransactionID", "class_uri": "src/main/java/org/ice4j/stack/TransactionID.java.TransactionID", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns a string representation of the ID\n\n@param transactionID the transaction ID to convert into <tt>String</tt>.\n\n@return a hex string representing the id\n"}, {"uris": "src/main/java/org/ice4j/stack/TransactionID.java.TransactionID.[void]setApplicationData(Object)", "name": "setApplicationData", "arg_nums": 1, "params": [{"name": "applicationData", "type": "Object"}], "return_type": "void", "signature": "public void setApplicationData(Object applicationData)", "original_string": "    public void setApplicationData(Object applicationData)\n    {\n        this.applicationData = applicationData;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/TransactionID.java", "class_name": "TransactionID", "class_uri": "src/main/java/org/ice4j/stack/TransactionID.java.TransactionID", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nStores <tt>applicationData</tt> in this ID so that we can refer back to\nit if we ever need to at a later stage (e.g. when receiving a response\nto a {@link StunClientTransaction}).\n\n@param applicationData a reference to the {@link Object} that the\napplication would like to correlate to the transaction represented by\nthis ID.\n"}, {"uris": "src/main/java/org/ice4j/stack/TransactionID.java.TransactionID.[Object]getApplicationData()", "name": "getApplicationData", "arg_nums": 0, "params": [], "return_type": "Object", "signature": "public Object getApplicationData()", "original_string": "    public Object getApplicationData()\n    {\n        return applicationData;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/stack/TransactionID.java", "class_name": "TransactionID", "class_uri": "src/main/java/org/ice4j/stack/TransactionID.java.TransactionID", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object", "classes": []}, "docstring": "\nReturns whatever <tt>applicationData</tt> was previously stored in this\nID.\n\n@return a reference to the {@link Object} that the application may have\nstored in this ID's application data field.\n"}, {"uris": "src/main/java/org/ice4j/attribute/DestinationAddressAttribute.java.DestinationAddressAttribute.[]DestinationAddressAttribute()", "name": "DestinationAddressAttribute", "arg_nums": 0, "params": [], "return_type": "", "signature": "DestinationAddressAttribute()", "original_string": "    DestinationAddressAttribute()\n    {\n        super(DESTINATION_ADDRESS);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/DestinationAddressAttribute.java", "class_name": "DestinationAddressAttribute", "class_uri": "src/main/java/org/ice4j/attribute/DestinationAddressAttribute.java.DestinationAddressAttribute", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "docstring": "\nConstructor.\n"}, {"uris": "src/main/java/org/ice4j/attribute/XorRelayedAddressAttribute.java.XorRelayedAddressAttribute.[]XorRelayedAddressAttribute()", "name": "XorRelayedAddressAttribute", "arg_nums": 0, "params": [], "return_type": "", "signature": "XorRelayedAddressAttribute()", "original_string": "    XorRelayedAddressAttribute()\n    {\n        super(XOR_RELAYED_ADDRESS);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/XorRelayedAddressAttribute.java", "class_name": "XorRelayedAddressAttribute", "class_uri": "src/main/java/org/ice4j/attribute/XorRelayedAddressAttribute.java.XorRelayedAddressAttribute", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "docstring": "\nConstructor.\n"}, {"uris": "src/main/java/org/ice4j/attribute/ContentDependentAttribute.java.ContentDependentAttribute.[byte[]]encode(StunStack,byte[],int,int)", "name": "encode", "arg_nums": 4, "params": [{"name": "stunStack", "type": "StunStack"}, {"name": "content", "type": "byte[]"}, {"name": "offset", "type": "int"}, {"name": "length", "type": "int"}], "return_type": "byte[]", "signature": "public byte[] encode(\n            StunStack stunStack,\n            byte[] content, int offset, int length)", "original_string": "    public byte[] encode(\n            StunStack stunStack,\n            byte[] content, int offset, int length);", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/ContentDependentAttribute.java", "class_name": "ContentDependentAttribute", "class_uri": "src/main/java/org/ice4j/attribute/ContentDependentAttribute.java.ContentDependentAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "byte[]", "classes": []}, "docstring": "\nReturns a binary representation of this attribute.\n\n@param stunStack the <tt>StunStack</tt> in the context of which the\nrequest to encode this <tt>ContentDependentAttribute</tt> is being made\n@param content the content of the message that this attribute will be\ntransported in\n@param offset the <tt>content</tt>-related offset where the actual\ncontent starts.\n@param length the length of the content in the <tt>content</tt> array.\n\n@return a binary representation of this attribute valid for the message\nwith the specified <tt>content</tt>.\n"}, {"uris": "src/main/java/org/ice4j/attribute/MessageIntegrityAttribute.java.MessageIntegrityAttribute.[]MessageIntegrityAttribute()", "name": "MessageIntegrityAttribute", "arg_nums": 0, "params": [], "return_type": "", "signature": "protected MessageIntegrityAttribute()", "original_string": "    protected MessageIntegrityAttribute()\n    {\n        super(MESSAGE_INTEGRITY);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/MessageIntegrityAttribute.java", "class_name": "MessageIntegrityAttribute", "class_uri": "src/main/java/org/ice4j/attribute/MessageIntegrityAttribute.java.MessageIntegrityAttribute", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nCreates a <tt>MessageIntegrityAttribute</tt>.\n"}, {"uris": "src/main/java/org/ice4j/attribute/MessageIntegrityAttribute.java.MessageIntegrityAttribute.[void]setUsername(String)", "name": "setUsername", "arg_nums": 1, "params": [{"name": "username", "type": "String"}], "return_type": "void", "signature": "public void setUsername(String username)", "original_string": "    public void setUsername(String username)\n    {\n        this.username = username;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/MessageIntegrityAttribute.java", "class_name": "MessageIntegrityAttribute", "class_uri": "src/main/java/org/ice4j/attribute/MessageIntegrityAttribute.java.MessageIntegrityAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets the username that we should use to obtain an encryption\nkey (password) that the {@link #encode()} method should use when\ncreating the content of this message.\n\n@param username the username that we should use to obtain an encryption\nkey (password) that the {@link #encode()} method should use when\ncreating the content of this message.\n"}, {"uris": "src/main/java/org/ice4j/attribute/MessageIntegrityAttribute.java.MessageIntegrityAttribute.[void]setMedia(String)", "name": "setMedia", "arg_nums": 1, "params": [{"name": "media", "type": "String"}], "return_type": "void", "signature": "public void setMedia(String media)", "original_string": "    public void setMedia(String media)\n    {\n        this.media = media;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/MessageIntegrityAttribute.java", "class_name": "MessageIntegrityAttribute", "class_uri": "src/main/java/org/ice4j/attribute/MessageIntegrityAttribute.java.MessageIntegrityAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets the media name that we should use to get the corresponding remote\nkey (short-term authentication only).\n\n@param media name\n"}, {"uris": "src/main/java/org/ice4j/attribute/MessageIntegrityAttribute.java.MessageIntegrityAttribute.[byte[]]getHmacSha1Content()", "name": "getHmacSha1Content", "arg_nums": 0, "params": [], "return_type": "byte[]", "signature": "public byte[] getHmacSha1Content()", "original_string": "    public byte[] getHmacSha1Content()\n    {\n        return hmacSha1Content;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/MessageIntegrityAttribute.java", "class_name": "MessageIntegrityAttribute", "class_uri": "src/main/java/org/ice4j/attribute/MessageIntegrityAttribute.java.MessageIntegrityAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "byte[]", "classes": []}, "docstring": "\nReturns the HMAC-SHA1 value stored in this attribute.\n\n@return the HMAC-SHA1 value stored in this attribute.\n"}, {"uris": "src/main/java/org/ice4j/attribute/MessageIntegrityAttribute.java.MessageIntegrityAttribute.[byte[]]calculateHmacSha1(byte[],int,int,byte[])", "name": "calculateHmacSha1", "arg_nums": 4, "params": [{"name": "message", "type": "byte[]"}, {"name": "offset", "type": "int"}, {"name": "length", "type": "int"}, {"name": "key", "type": "byte[]"}], "return_type": "byte[]", "signature": "public static byte[] calculateHmacSha1(byte[] message,\n                                           int    offset,\n                                           int    length,\n                                           byte[] key)", "original_string": "    public static byte[] calculateHmacSha1(byte[] message,\n                                           int    offset,\n                                           int    length,\n                                           byte[] key)\n        throws IllegalArgumentException\n    {\n        byte[] hmac;\n\n        try\n        {\n            // get an HMAC-SHA1 key from the raw key bytes\n            SecretKeySpec signingKey\n                = new SecretKeySpec(key, HMAC_SHA1_ALGORITHM);\n            // get an HMAC-SHA1 Mac instance and initialize it with the key\n            Mac mac = Mac.getInstance(HMAC_SHA1_ALGORITHM);\n\n            mac.init(signingKey);\n\n            // compute the hmac on input data bytes\n            byte[] macInput = new byte[length];\n\n            //doFinal seems incapable to only work with a part of an array\n            //so we'd need to create an array that only contains what we\n            //actually need to work with.\n            System.arraycopy(message, offset, macInput, 0, length);\n            hmac = mac.doFinal(macInput);\n        }\n        catch (Exception exc)\n        {\n            throw new IllegalArgumentException(\n                        \"Could not create HMAC-SHA1 request encoding: \", exc);\n        }\n        return hmac;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/MessageIntegrityAttribute.java", "class_name": "MessageIntegrityAttribute", "class_uri": "src/main/java/org/ice4j/attribute/MessageIntegrityAttribute.java.MessageIntegrityAttribute", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "byte[]", "classes": []}, "docstring": "\nEncodes <tt>message</tt> using <tt>key</tt> and the HMAC-SHA1 algorithm\nas per RFC 2104 and returns the resulting byte array. This is a utility\nmethod that generates content for the {@link MessageIntegrityAttribute}\nregardless of the credentials being used (short or long term).\n\n@param message the STUN message that the resulting content will need to\ntravel in.\n@param offset the index where data starts in <tt>message</tt>.\n@param length the length of the data in <tt>message</tt> that the method\nshould consider.\n@param key the key that we should be using for the encoding (which\ndepends on whether we are using short or long term credentials).\n\n@return the HMAC that should be used in a\n<tt>MessageIntegrityAttribute</tt> transported by <tt>message</tt>.\n\n@throws IllegalArgumentException if the encoding fails for some reason.\n"}, {"uris": "src/main/java/org/ice4j/attribute/MessageIntegrityAttribute.java.MessageIntegrityAttribute.[void]decodeAttributeBody(byte[],char,char)", "name": "decodeAttributeBody", "arg_nums": 3, "params": [{"name": "attributeValue", "type": "byte[]"}, {"name": "offset", "type": "char"}, {"name": "length", "type": "char"}], "return_type": "void", "signature": "public void decodeAttributeBody( byte[] attributeValue,\n                                     char offset,\n                                     char length)", "original_string": "    public void decodeAttributeBody( byte[] attributeValue,\n                                     char offset,\n                                     char length)\n    {\n        hmacSha1Content = new byte[length];\n        System.arraycopy(attributeValue, offset, hmacSha1Content, 0, length);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/MessageIntegrityAttribute.java", "class_name": "MessageIntegrityAttribute", "class_uri": "src/main/java/org/ice4j/attribute/MessageIntegrityAttribute.java.MessageIntegrityAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets this attribute's fields according to the message and attributeValue\narrays.\n\n@param attributeValue a binary array containing this attribute's field\nvalues and NOT containing the attribute header.\n@param offset the position where attribute values begin (most often\noffset is equal to the index of the first byte after length)\n@param length the length of the binary array.\nthe start of this attribute.\n"}, {"uris": "src/main/java/org/ice4j/attribute/MessageIntegrityAttribute.java.MessageIntegrityAttribute.[byte[]]encode()", "name": "encode", "arg_nums": 0, "params": [], "return_type": "byte[]", "signature": "public byte[] encode()", "original_string": "    public byte[] encode()\n        throws UnsupportedOperationException\n    {\n        throw new UnsupportedOperationException(\n                        \"ContentDependentAttributes should be encoded \"\n                        + \"through the contend-dependent encode method\");\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/MessageIntegrityAttribute.java", "class_name": "MessageIntegrityAttribute", "class_uri": "src/main/java/org/ice4j/attribute/MessageIntegrityAttribute.java.MessageIntegrityAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "byte[]", "classes": []}, "docstring": "\nReturns a binary representation of this attribute.\n\n@return nothing\n@throws UnsupportedOperationException since {@link\nContentDependentAttribute}s should be encoded through the content\ndependent encode method.\n"}, {"uris": "src/main/java/org/ice4j/attribute/MessageIntegrityAttribute.java.MessageIntegrityAttribute.[byte[]]encode(StunStack,byte[],int,int)", "name": "encode", "arg_nums": 4, "params": [{"name": "stunStack", "type": "StunStack"}, {"name": "content", "type": "byte[]"}, {"name": "offset", "type": "int"}, {"name": "length", "type": "int"}], "return_type": "byte[]", "signature": "public byte[] encode(\n            StunStack stunStack,\n            byte[] content, int offset, int length)", "original_string": "    public byte[] encode(\n            StunStack stunStack,\n            byte[] content, int offset, int length)\n    {\n        char type = getAttributeType();\n        byte binValue[] = new byte[HEADER_LENGTH + getDataLength()];\n\n        //Type\n        binValue[0] = (byte)(type >> 8);\n        binValue[1] = (byte)(type & 0x00FF);\n\n        //Length\n        binValue[2] = (byte)(getDataLength() >> 8);\n        binValue[3] = (byte)(getDataLength() & 0x00FF);\n\n        byte[] key = null;\n        char msgType =\n            (char) (((content[0] & 0xFF) << 8) | (content[1] & 0xFF));\n\n        if (Message.isRequestType(msgType))\n        {\n            /* attribute part of a request, use the remote key */\n            key\n                = stunStack.getCredentialsManager()\n                    .getRemoteKey(username, media);\n        }\n        else if (Message.isResponseType(msgType))\n        {\n            /* attribute part of a response, use the local key */\n            key = stunStack.getCredentialsManager().getLocalKey(username);\n        }\n        else // msgType is Indication\n        {\n            logger.warning(\"Can not encode a message of type Indication.\");\n        }\n\n        Objects.requireNonNull(key, \"key=null; msgType=\" + String.format(\"%04X\", (int)msgType));\n        //now calculate the HMAC-SHA1\n        this.hmacSha1Content = calculateHmacSha1(content, offset, length, key);\n\n        //username\n        System.arraycopy(hmacSha1Content, 0, binValue, HEADER_LENGTH, getDataLength());\n\n        return binValue;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/MessageIntegrityAttribute.java", "class_name": "MessageIntegrityAttribute", "class_uri": "src/main/java/org/ice4j/attribute/MessageIntegrityAttribute.java.MessageIntegrityAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "byte[]", "classes": []}, "docstring": "\nReturns a binary representation of this attribute.\n\n@param stunStack the <tt>StunStack</tt> in the context of which the\nrequest to encode this <tt>ContentDependentAttribute</tt> is being made\n@param content the content of the message that this attribute will be\ntransported in\n@param offset the <tt>content</tt>-related offset where the actual\ncontent starts.\n@param length the length of the content in the <tt>content</tt> array.\n\n@return a binary representation of this attribute valid for the message\nwith the specified <tt>content</tt>.\n"}, {"uris": "src/main/java/org/ice4j/attribute/MessageIntegrityAttribute.java.MessageIntegrityAttribute.[char]getDataLength()", "name": "getDataLength", "arg_nums": 0, "params": [], "return_type": "char", "signature": "public char getDataLength()", "original_string": "    public char getDataLength()\n    {\n        return DATA_LENGTH;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/MessageIntegrityAttribute.java", "class_name": "MessageIntegrityAttribute", "class_uri": "src/main/java/org/ice4j/attribute/MessageIntegrityAttribute.java.MessageIntegrityAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "char", "classes": []}, "docstring": "\nReturns the length of this attribute's body.\n\n@return the length of this attribute's value.\n"}, {"uris": "src/main/java/org/ice4j/attribute/MessageIntegrityAttribute.java.MessageIntegrityAttribute.[String]getName()", "name": "getName", "arg_nums": 0, "params": [], "return_type": "String", "signature": "public String getName()", "original_string": "    public String getName()\n    {\n        return NAME;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/MessageIntegrityAttribute.java", "class_name": "MessageIntegrityAttribute", "class_uri": "src/main/java/org/ice4j/attribute/MessageIntegrityAttribute.java.MessageIntegrityAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns the human readable name of this attribute.\n\n@return this attribute's name.\n"}, {"uris": "src/main/java/org/ice4j/attribute/MessageIntegrityAttribute.java.MessageIntegrityAttribute.[boolean]equals(Object)", "name": "equals", "arg_nums": 1, "params": [{"name": "obj", "type": "Object"}], "return_type": "boolean", "signature": "public boolean equals(Object obj)", "original_string": "    public boolean equals(Object obj)\n    {\n        if (! (obj instanceof MessageIntegrityAttribute))\n            return false;\n\n        if (obj == this)\n            return true;\n\n        MessageIntegrityAttribute att = (MessageIntegrityAttribute) obj;\n        if (att.getAttributeType() != getAttributeType()\n                || att.getDataLength() != getDataLength()\n                || !Arrays.equals( att.hmacSha1Content, hmacSha1Content))\n            return false;\n\n        return true;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/MessageIntegrityAttribute.java", "class_name": "MessageIntegrityAttribute", "class_uri": "src/main/java/org/ice4j/attribute/MessageIntegrityAttribute.java.MessageIntegrityAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nCompares two <tt>MessageIntegrityAttribute</tt>s. Two attributes are\nconsidered equal when they have the same type length and value.\n\n@param obj the object to compare this attribute with.\n@return true if the attributes are equal and false otherwise.\n"}, {"uris": "src/main/java/org/ice4j/attribute/UnknownAttributesAttribute.java.UnknownAttributesAttribute.[]UnknownAttributesAttribute()", "name": "UnknownAttributesAttribute", "arg_nums": 0, "params": [], "return_type": "", "signature": "UnknownAttributesAttribute()", "original_string": "    UnknownAttributesAttribute()\n    {\n        super(UNKNOWN_ATTRIBUTES);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/UnknownAttributesAttribute.java", "class_name": "UnknownAttributesAttribute", "class_uri": "src/main/java/org/ice4j/attribute/UnknownAttributesAttribute.java.UnknownAttributesAttribute", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "docstring": "\nConstructor.\n"}, {"uris": "src/main/java/org/ice4j/attribute/UnknownAttributesAttribute.java.UnknownAttributesAttribute.[String]getName()", "name": "getName", "arg_nums": 0, "params": [], "return_type": "String", "signature": "public String getName()", "original_string": "    public String getName()\n    {\n        return NAME;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/UnknownAttributesAttribute.java", "class_name": "UnknownAttributesAttribute", "class_uri": "src/main/java/org/ice4j/attribute/UnknownAttributesAttribute.java.UnknownAttributesAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns the human readable name of this attribute. Attribute names do\nnot really matter from the protocol point of view. They are only used\nfor debugging and readability.\n@return this attribute's name.\n"}, {"uris": "src/main/java/org/ice4j/attribute/UnknownAttributesAttribute.java.UnknownAttributesAttribute.[char]getDataLength()", "name": "getDataLength", "arg_nums": 0, "params": [], "return_type": "char", "signature": "public char getDataLength()", "original_string": "    public char getDataLength()\n    {\n        char len = (char)unknownAttributes.size();\n\n        if ( (len % 2 ) != 0 )\n            len++;\n\n        return (char)(len * 2);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/UnknownAttributesAttribute.java", "class_name": "UnknownAttributesAttribute", "class_uri": "src/main/java/org/ice4j/attribute/UnknownAttributesAttribute.java.UnknownAttributesAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "char", "classes": []}, "docstring": "\nReturns the length (in bytes) of this attribute's body.\nIf the number of unknown attributes is an odd number, one of the\nattributes MUST be repeated in the list, so that the total length of\nthe list is a multiple of 4 bytes.\n@return the length of this attribute's value (a multiple of 4).\n"}, {"uris": "src/main/java/org/ice4j/attribute/UnknownAttributesAttribute.java.UnknownAttributesAttribute.[void]addAttributeID(char)", "name": "addAttributeID", "arg_nums": 1, "params": [{"name": "attributeID", "type": "char"}], "return_type": "void", "signature": "public void addAttributeID(char attributeID)", "original_string": "    public void addAttributeID(char attributeID)\n    {\n        //some attributes may be repeated for padding\n        //(packet length should be divisable by 4)\n        if (!contains(attributeID))\n            unknownAttributes.add(attributeID);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/UnknownAttributesAttribute.java", "class_name": "UnknownAttributesAttribute", "class_uri": "src/main/java/org/ice4j/attribute/UnknownAttributesAttribute.java.UnknownAttributesAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nAdds the specified attribute type to the list of unknown attributes.\n@param attributeID the id of an attribute to be listed as unknown in this\nattribute\n"}, {"uris": "src/main/java/org/ice4j/attribute/UnknownAttributesAttribute.java.UnknownAttributesAttribute.[boolean]contains(char)", "name": "contains", "arg_nums": 1, "params": [{"name": "attributeID", "type": "char"}], "return_type": "boolean", "signature": "public boolean contains(char attributeID)", "original_string": "    public boolean contains(char attributeID)\n    {\n        return unknownAttributes.contains(attributeID);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/UnknownAttributesAttribute.java", "class_name": "UnknownAttributesAttribute", "class_uri": "src/main/java/org/ice4j/attribute/UnknownAttributesAttribute.java.UnknownAttributesAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nVerifies whether the specified attributeID is contained by this attribute.\n@param attributeID the attribute id to look for.\n@return true if this attribute contains the specified attribute id.\n"}, {"uris": "src/main/java/org/ice4j/attribute/UnknownAttributesAttribute.java.UnknownAttributesAttribute.[Iterator<Character>]getAttributes()", "name": "getAttributes", "arg_nums": 0, "params": [], "return_type": "Iterator<Character>", "signature": "public Iterator<Character> getAttributes()", "original_string": "    public Iterator<Character> getAttributes()\n    {\n        return unknownAttributes.iterator();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/UnknownAttributesAttribute.java", "class_name": "UnknownAttributesAttribute", "class_uri": "src/main/java/org/ice4j/attribute/UnknownAttributesAttribute.java.UnknownAttributesAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Iterator<Character>", "classes": []}, "docstring": "\nReturns an iterator over the list of attribute IDs contained by this\nattribute.\n@return an iterator over the list of attribute IDs contained by this\nattribute.\n"}, {"uris": "src/main/java/org/ice4j/attribute/UnknownAttributesAttribute.java.UnknownAttributesAttribute.[int]getAttributeCount()", "name": "getAttributeCount", "arg_nums": 0, "params": [], "return_type": "int", "signature": "public int getAttributeCount()", "original_string": "    public int getAttributeCount()\n    {\n        return unknownAttributes.size();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/UnknownAttributesAttribute.java", "class_name": "UnknownAttributesAttribute", "class_uri": "src/main/java/org/ice4j/attribute/UnknownAttributesAttribute.java.UnknownAttributesAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\nReturns the number of attribute IDs contained by this class.\n@return the number of attribute IDs contained by this class.\n"}, {"uris": "src/main/java/org/ice4j/attribute/UnknownAttributesAttribute.java.UnknownAttributesAttribute.[char]getAttribute(int)", "name": "getAttribute", "arg_nums": 1, "params": [{"name": "index", "type": "int"}], "return_type": "char", "signature": "public char getAttribute(int index )", "original_string": "    public char getAttribute(int index )\n    {\n        return unknownAttributes.get(index);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/UnknownAttributesAttribute.java", "class_name": "UnknownAttributesAttribute", "class_uri": "src/main/java/org/ice4j/attribute/UnknownAttributesAttribute.java.UnknownAttributesAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "char", "classes": []}, "docstring": "\nReturns the attribute id with index i.\n@param index the index of the attribute id to return.\n@return the attribute id with index i.\n"}, {"uris": "src/main/java/org/ice4j/attribute/UnknownAttributesAttribute.java.UnknownAttributesAttribute.[byte[]]encode()", "name": "encode", "arg_nums": 0, "params": [], "return_type": "byte[]", "signature": "public byte[] encode()", "original_string": "    public byte[] encode()\n    {\n        byte binValue[] = new byte[getDataLength() + HEADER_LENGTH];\n        int  offset     = 0;\n\n        //Type\n        binValue[offset++] = (byte) (getAttributeType() >> 8);\n        binValue[offset++] = (byte) (getAttributeType() & 0x00FF);\n\n        //Length\n        binValue[offset++] = (byte) (getDataLength() >> 8);\n        binValue[offset++] = (byte) (getDataLength() & 0x00FF);\n\n\n        Iterator<Character> attributes = getAttributes();\n        while (attributes.hasNext())\n        {\n            char att = attributes.next();\n            binValue[offset++] = (byte)(att >> 8);\n            binValue[offset++] = (byte)(att & 0x00FF);\n        }\n\n       // If the number of unknown attributes is an odd number, one of the\n       // attributes MUST be repeated in the list, so that the total length of\n       // the list is a multiple of 4 bytes.\n       if (offset < binValue.length)\n       {\n           char att = getAttribute(0);\n           binValue[offset++] = (byte) (att >> 8);\n           binValue[offset++] = (byte) (att & 0x00FF);\n       }\n\n        return binValue;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/UnknownAttributesAttribute.java", "class_name": "UnknownAttributesAttribute", "class_uri": "src/main/java/org/ice4j/attribute/UnknownAttributesAttribute.java.UnknownAttributesAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "byte[]", "classes": []}, "docstring": "\nReturns a binary representation of this attribute.\n@return a binary representation of this attribute.\n"}, {"uris": "src/main/java/org/ice4j/attribute/UnknownAttributesAttribute.java.UnknownAttributesAttribute.[boolean]equals(Object)", "name": "equals", "arg_nums": 1, "params": [{"name": "obj", "type": "Object"}], "return_type": "boolean", "signature": "public boolean equals(Object obj)", "original_string": "    public boolean equals(Object obj)\n    {\n        if (! (obj instanceof UnknownAttributesAttribute))\n            return false;\n\n        if (obj == this)\n            return true;\n\n        UnknownAttributesAttribute att = (UnknownAttributesAttribute) obj;\n        if (att.getAttributeType() != getAttributeType()\n            || att.getDataLength() != getDataLength()\n            || !unknownAttributes.equals(att.unknownAttributes)\n        )\n            return false;\n\n        return true;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/UnknownAttributesAttribute.java", "class_name": "UnknownAttributesAttribute", "class_uri": "src/main/java/org/ice4j/attribute/UnknownAttributesAttribute.java.UnknownAttributesAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nCompares two STUN Attributes. Attributes are considered equal when their\ntype, length, and all data are the same.\n\n@param obj the object to compare this attribute with.\n@return true if the attributes are equal and false otherwise.\n"}, {"uris": "src/main/java/org/ice4j/attribute/UnknownAttributesAttribute.java.UnknownAttributesAttribute.[void]decodeAttributeBody(byte[],char,char)", "name": "decodeAttributeBody", "arg_nums": 3, "params": [{"name": "attributeValue", "type": "byte[]"}, {"name": "offset", "type": "char"}, {"name": "length", "type": "char"}], "return_type": "void", "signature": "void decodeAttributeBody(byte[] attributeValue, char offset, char length)", "original_string": "    void decodeAttributeBody(byte[] attributeValue, char offset, char length)\n    throws StunException\n    {\n        if ( (length % 2 ) != 0)\n            throw new StunException(\"Attribute IDs are 2 bytes long and the \"\n                                    + \"passed binary array has an odd length \" +\n                                            \"value.\");\n        char originalOffset = offset;\n        for (int i = offset; i < originalOffset + length; i += 2)\n        {\n            char attributeID = (char) (((attributeValue[offset++] & 0xFF) << 8)\n                | (attributeValue[offset++] & 0xFF));\n            addAttributeID(attributeID);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/UnknownAttributesAttribute.java", "class_name": "UnknownAttributesAttribute", "class_uri": "src/main/java/org/ice4j/attribute/UnknownAttributesAttribute.java.UnknownAttributesAttribute", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets this attribute's fields according to attributeValue array.\n\n@param attributeValue a binary array containing this attribute's field\n                      values and NOT containing the attribute header.\n@param offset the position where attribute values begin (most often\n                 offset is equal to the index of the first byte after\n                 length)\n@param length the length of the binary array.\n@throws StunException if attrubteValue contains invalid data.\n"}, {"uris": "src/main/java/org/ice4j/attribute/IceControllingAttribute.java.IceControllingAttribute.[]IceControllingAttribute()", "name": "IceControllingAttribute", "arg_nums": 0, "params": [], "return_type": "", "signature": "public IceControllingAttribute()", "original_string": "    public IceControllingAttribute()\n    {\n        super(true);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/IceControllingAttribute.java", "class_name": "IceControllingAttribute", "class_uri": "src/main/java/org/ice4j/attribute/IceControllingAttribute.java.IceControllingAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nConstructs an ICE-CONTROLLING attribute.\n"}, {"uris": "src/main/java/org/ice4j/attribute/XorMappedAddressAttribute.java.XorMappedAddressAttribute.[]XorMappedAddressAttribute()", "name": "XorMappedAddressAttribute", "arg_nums": 0, "params": [], "return_type": "", "signature": "XorMappedAddressAttribute()", "original_string": "    XorMappedAddressAttribute()\n    {\n        super(XOR_MAPPED_ADDRESS);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/XorMappedAddressAttribute.java", "class_name": "XorMappedAddressAttribute", "class_uri": "src/main/java/org/ice4j/attribute/XorMappedAddressAttribute.java.XorMappedAddressAttribute", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "docstring": "\nCreates an instance of this attribute\n"}, {"uris": "src/main/java/org/ice4j/attribute/XorMappedAddressAttribute.java.XorMappedAddressAttribute.[]XorMappedAddressAttribute(char)", "name": "XorMappedAddressAttribute", "arg_nums": 1, "params": [{"name": "type", "type": "char"}], "return_type": "", "signature": "XorMappedAddressAttribute(char type)", "original_string": "    XorMappedAddressAttribute(char type)\n    {\n      super(type);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/XorMappedAddressAttribute.java", "class_name": "XorMappedAddressAttribute", "class_uri": "src/main/java/org/ice4j/attribute/XorMappedAddressAttribute.java.XorMappedAddressAttribute", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "docstring": "\nConstructor.\n@param type other type than XOR-MAPPED-ADDRESS\n"}, {"uris": "src/main/java/org/ice4j/attribute/XorMappedAddressAttribute.java.XorMappedAddressAttribute.[TransportAddress]applyXor(TransportAddress,byte[])", "name": "applyXor", "arg_nums": 2, "params": [{"name": "address", "type": "TransportAddress"}, {"name": "transactionID", "type": "byte[]"}], "return_type": "TransportAddress", "signature": "public static TransportAddress applyXor(TransportAddress address,\n                                       byte[] transactionID)", "original_string": "    public static TransportAddress applyXor(TransportAddress address,\n                                       byte[] transactionID)\n    {\n        byte[] addressBytes = address.getAddressBytes();\n        char port = (char)address.getPort();\n\n        char portModifier = (char)( (transactionID[0] << 8 & 0x0000FF00)\n                                  | (transactionID[1] & 0x000000FF));\n\n        port ^= portModifier;\n\n        for (int i = 0; i < addressBytes.length; i++)\n            addressBytes[i] ^= transactionID[i];\n\n        TransportAddress xoredAdd;\n        try\n        {\n            xoredAdd = new TransportAddress(addressBytes, port, Transport.UDP);\n        }\n        catch (UnknownHostException e)\n        {\n            //shouldn't happen so just throw an illegal arg\n            throw new IllegalArgumentException(e);\n        }\n\n        return xoredAdd;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/XorMappedAddressAttribute.java", "class_name": "XorMappedAddressAttribute", "class_uri": "src/main/java/org/ice4j/attribute/XorMappedAddressAttribute.java.XorMappedAddressAttribute", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "TransportAddress", "classes": []}, "docstring": "\nReturns the result of applying XOR on the specified attribute's address.\nThe method may be used for both encoding and decoding XorMappedAddresses.\n\n@param address the address on which XOR should be applied\n@param transactionID the transaction id to use for the XOR\n\n@return the XOR-ed address.\n"}, {"uris": "src/main/java/org/ice4j/attribute/XorMappedAddressAttribute.java.XorMappedAddressAttribute.[TransportAddress]getAddress(byte[])", "name": "getAddress", "arg_nums": 1, "params": [{"name": "transactionID", "type": "byte[]"}], "return_type": "TransportAddress", "signature": "public TransportAddress getAddress(byte[] transactionID)", "original_string": "    public TransportAddress getAddress(byte[] transactionID)\n    {\n        byte[] xorMask = new byte[16];\n\n        System.arraycopy(Message.MAGIC_COOKIE, 0, xorMask, 0, 4);\n        System.arraycopy(transactionID, 0, xorMask, 4, 12);\n\n        return applyXor(xorMask);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/XorMappedAddressAttribute.java", "class_name": "XorMappedAddressAttribute", "class_uri": "src/main/java/org/ice4j/attribute/XorMappedAddressAttribute.java.XorMappedAddressAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "TransportAddress", "classes": []}, "docstring": "\nReturns the result of applying XOR on this attribute's address, using the\nspecified transaction ID when converting IPv6 addresses.\n\n@param transactionID the transaction ID to use in case this attribute is\nencapsulating an IPv6 address.\n\n@return the XOR-ed address.\n"}, {"uris": "src/main/java/org/ice4j/attribute/XorMappedAddressAttribute.java.XorMappedAddressAttribute.[TransportAddress]applyXor(byte[])", "name": "applyXor", "arg_nums": 1, "params": [{"name": "xorMask", "type": "byte[]"}], "return_type": "TransportAddress", "signature": "public TransportAddress applyXor(byte[] xorMask)", "original_string": "    public TransportAddress applyXor(byte[] xorMask)\n    {\n        return applyXor(getAddress(), xorMask);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/XorMappedAddressAttribute.java", "class_name": "XorMappedAddressAttribute", "class_uri": "src/main/java/org/ice4j/attribute/XorMappedAddressAttribute.java.XorMappedAddressAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "TransportAddress", "classes": []}, "docstring": "\nReturns the result of applying XOR on this attribute's address, using the\nspecified XOR mask. The method may be used for both encoding and\ndecoding <tt>XorMappedAddresses</tt>.\n\n@param xorMask the XOR mask to use when obtaining the original address.\n\n@return the XOR-ed address.\n"}, {"uris": "src/main/java/org/ice4j/attribute/XorMappedAddressAttribute.java.XorMappedAddressAttribute.[void]setAddress(TransportAddress,byte[])", "name": "setAddress", "arg_nums": 2, "params": [{"name": "address", "type": "TransportAddress"}, {"name": "transactionID", "type": "byte[]"}], "return_type": "void", "signature": "public void setAddress(TransportAddress address, byte[] transactionID)", "original_string": "    public void setAddress(TransportAddress address, byte[] transactionID)\n    {\n        byte[] xorMask = new byte[16];\n\n        System.arraycopy(Message.MAGIC_COOKIE, 0, xorMask, 0, 4);\n        System.arraycopy(transactionID, 0, xorMask, 4, 12);\n\n        TransportAddress xorAddress = applyXor(address, xorMask);\n\n        super.setAddress(xorAddress);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/XorMappedAddressAttribute.java", "class_name": "XorMappedAddressAttribute", "class_uri": "src/main/java/org/ice4j/attribute/XorMappedAddressAttribute.java.XorMappedAddressAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nApplies a XOR mask to the specified address and then sets it as the value\ntransported by this attribute.\n\n@param address the address that we should xor and then record in this\nattribute.\n@param transactionID the transaction identifier that we should use\nwhen creating the XOR mask.\n"}, {"uris": "src/main/java/org/ice4j/attribute/SoftwareAttribute.java.SoftwareAttribute.[]SoftwareAttribute()", "name": "SoftwareAttribute", "arg_nums": 0, "params": [], "return_type": "", "signature": "protected SoftwareAttribute ()", "original_string": "    protected SoftwareAttribute ()\n    {\n        super(SOFTWARE);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/SoftwareAttribute.java", "class_name": "SoftwareAttribute", "class_uri": "src/main/java/org/ice4j/attribute/SoftwareAttribute.java.SoftwareAttribute", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nCreates a new <tt>SoftwareAttribute</tt>.\n"}, {"uris": "src/main/java/org/ice4j/attribute/SoftwareAttribute.java.SoftwareAttribute.[void]decodeAttributeBody(byte[],char,char)", "name": "decodeAttributeBody", "arg_nums": 3, "params": [{"name": "attributeValue", "type": "byte[]"}, {"name": "offset", "type": "char"}, {"name": "length", "type": "char"}], "return_type": "void", "signature": "void decodeAttributeBody(byte[] attributeValue, char offset, char length)", "original_string": "    void decodeAttributeBody(byte[] attributeValue, char offset, char length)\n    {\n        software = new byte[length];\n        System.arraycopy(attributeValue, offset, software, 0, length);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/SoftwareAttribute.java", "class_name": "SoftwareAttribute", "class_uri": "src/main/java/org/ice4j/attribute/SoftwareAttribute.java.SoftwareAttribute", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCopies the value of the software attribute from the specified\nattributeValue.\n\n@param attributeValue a binary array containing this attribute's\nfield values and NOT containing the attribute header.\n@param offset the position where attribute values begin (most often\noffset is equal to the index of the first byte after length)\n@param length the length of the binary array.\n"}, {"uris": "src/main/java/org/ice4j/attribute/SoftwareAttribute.java.SoftwareAttribute.[byte[]]encode()", "name": "encode", "arg_nums": 0, "params": [], "return_type": "byte[]", "signature": "public byte[] encode()", "original_string": "    public byte[] encode()\n    {\n        char type = getAttributeType();\n        byte binValue[] = new byte[HEADER_LENGTH + getDataLength()\n                                   //add padding\n                                   + (4 - getDataLength() % 4) % 4];\n\n        //Type\n        binValue[0] = (byte)(type >> 8);\n        binValue[1] = (byte)(type & 0x00FF);\n\n        //Length\n        binValue[2] = (byte)(getDataLength() >> 8);\n        binValue[3] = (byte)(getDataLength() & 0x00FF);\n\n        //software\n        System.arraycopy(software, 0, binValue, 4, getDataLength());\n\n        return binValue;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/SoftwareAttribute.java", "class_name": "SoftwareAttribute", "class_uri": "src/main/java/org/ice4j/attribute/SoftwareAttribute.java.SoftwareAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "byte[]", "classes": []}, "docstring": "\nReturns a binary representation of this attribute.\n\n@return a binary representation of this attribute.\n"}, {"uris": "src/main/java/org/ice4j/attribute/SoftwareAttribute.java.SoftwareAttribute.[char]getDataLength()", "name": "getDataLength", "arg_nums": 0, "params": [], "return_type": "char", "signature": "public char getDataLength()", "original_string": "    public char getDataLength()\n    {\n        return (char)software.length;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/SoftwareAttribute.java", "class_name": "SoftwareAttribute", "class_uri": "src/main/java/org/ice4j/attribute/SoftwareAttribute.java.SoftwareAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "char", "classes": []}, "docstring": "\nReturns the length of this attribute's body.\n\n@return the length of this attribute's value.\n"}, {"uris": "src/main/java/org/ice4j/attribute/SoftwareAttribute.java.SoftwareAttribute.[String]getName()", "name": "getName", "arg_nums": 0, "params": [], "return_type": "String", "signature": "public String getName()", "original_string": "    public String getName()\n    {\n        return \"SOFTWARE\";\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/SoftwareAttribute.java", "class_name": "SoftwareAttribute", "class_uri": "src/main/java/org/ice4j/attribute/SoftwareAttribute.java.SoftwareAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns the human readable name of this attribute.\n\n@return this attribute's name.\n"}, {"uris": "src/main/java/org/ice4j/attribute/SoftwareAttribute.java.SoftwareAttribute.[byte[]]getSoftware()", "name": "getSoftware", "arg_nums": 0, "params": [], "return_type": "byte[]", "signature": "public byte[] getSoftware()", "original_string": "    public byte[] getSoftware()\n    {\n        if (software == null)\n            return null;\n\n        byte[] copy = new byte[software.length];\n        System.arraycopy(software, 0, copy, 0, software.length);\n        return copy;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/SoftwareAttribute.java", "class_name": "SoftwareAttribute", "class_uri": "src/main/java/org/ice4j/attribute/SoftwareAttribute.java.SoftwareAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "byte[]", "classes": []}, "docstring": "\nReturns a (cloned) byte array containing the data value of the software\nattribute.\n@return the binary array containing the software.\n"}, {"uris": "src/main/java/org/ice4j/attribute/SoftwareAttribute.java.SoftwareAttribute.[void]setSoftware(byte[])", "name": "setSoftware", "arg_nums": 1, "params": [{"name": "software", "type": "byte[]"}], "return_type": "void", "signature": "public void setSoftware(byte[] software)", "original_string": "    public void setSoftware(byte[] software)\n    {\n        if (software == null)\n        {\n            this.software = null;\n            return;\n        }\n\n        this.software = new byte[software.length];\n        System.arraycopy(software, 0, this.software, 0, software.length);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/SoftwareAttribute.java", "class_name": "SoftwareAttribute", "class_uri": "src/main/java/org/ice4j/attribute/SoftwareAttribute.java.SoftwareAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCopies the specified binary array into the the data value of the software\nattribute.\n\n@param software the binary array containing the software.\n"}, {"uris": "src/main/java/org/ice4j/attribute/SoftwareAttribute.java.SoftwareAttribute.[boolean]equals(Object)", "name": "equals", "arg_nums": 1, "params": [{"name": "obj", "type": "Object"}], "return_type": "boolean", "signature": "public boolean equals(Object obj)", "original_string": "    public boolean equals(Object obj)\n    {\n        if (! (obj instanceof SoftwareAttribute))\n            return false;\n\n        if (obj == this)\n            return true;\n\n        SoftwareAttribute att = (SoftwareAttribute) obj;\n        if (att.getAttributeType() != getAttributeType()\n                || att.getDataLength() != getDataLength()\n                || !Arrays.equals( att.software, software))\n            return false;\n\n        return true;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/SoftwareAttribute.java", "class_name": "SoftwareAttribute", "class_uri": "src/main/java/org/ice4j/attribute/SoftwareAttribute.java.SoftwareAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nCompares two STUN Attributes. Two attributes are considered equal when\nthey have the same type length and value.\n\n@param obj the object to compare this attribute with.\n@return true if the attributes are equal and false otherwise.\n"}, {"uris": "src/main/java/org/ice4j/attribute/RemoteAddressAttribute.java.RemoteAddressAttribute.[]RemoteAddressAttribute()", "name": "RemoteAddressAttribute", "arg_nums": 0, "params": [], "return_type": "", "signature": "RemoteAddressAttribute()", "original_string": "    RemoteAddressAttribute()\n    {\n        super(REMOTE_ADDRESS);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/RemoteAddressAttribute.java", "class_name": "RemoteAddressAttribute", "class_uri": "src/main/java/org/ice4j/attribute/RemoteAddressAttribute.java.RemoteAddressAttribute", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "docstring": "\nConstructor.\n"}, {"uris": "src/main/java/org/ice4j/attribute/SourceAddressAttribute.java.SourceAddressAttribute.[]SourceAddressAttribute()", "name": "SourceAddressAttribute", "arg_nums": 0, "params": [], "return_type": "", "signature": "SourceAddressAttribute()", "original_string": "    SourceAddressAttribute()\n    {\n        super(SOURCE_ADDRESS);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/SourceAddressAttribute.java", "class_name": "SourceAddressAttribute", "class_uri": "src/main/java/org/ice4j/attribute/SourceAddressAttribute.java.SourceAddressAttribute", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "docstring": "\nCreates a SOURCE-ADDRESS attribute\n"}, {"uris": "src/main/java/org/ice4j/attribute/AddressAttribute.java.AddressAttribute.[]AddressAttribute(char)", "name": "AddressAttribute", "arg_nums": 1, "params": [{"name": "attributeType", "type": "char"}], "return_type": "", "signature": "AddressAttribute(char attributeType)", "original_string": "    AddressAttribute(char attributeType)\n    {\n        super(attributeType);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/AddressAttribute.java", "class_name": "AddressAttribute", "class_uri": "src/main/java/org/ice4j/attribute/AddressAttribute.java.AddressAttribute", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "docstring": "\nConstructs an address attribute with the specified type.\n\n@param attributeType the type of the address attribute.\n"}, {"uris": "src/main/java/org/ice4j/attribute/AddressAttribute.java.AddressAttribute.[boolean]isTypeValid(char)", "name": "isTypeValid", "arg_nums": 1, "params": [{"name": "type", "type": "char"}], "return_type": "boolean", "signature": "private boolean isTypeValid(char type)", "original_string": "    private boolean isTypeValid(char type)\n    {\n        return (type == MAPPED_ADDRESS || type == RESPONSE_ADDRESS\n                || type == SOURCE_ADDRESS || type == CHANGED_ADDRESS\n                || type == REFLECTED_FROM || type == XOR_MAPPED_ADDRESS\n                || type == ALTERNATE_SERVER || type == XOR_PEER_ADDRESS\n                || type == XOR_RELAYED_ADDRESS || type == DESTINATION_ADDRESS);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/AddressAttribute.java", "class_name": "AddressAttribute", "class_uri": "src/main/java/org/ice4j/attribute/AddressAttribute.java.AddressAttribute", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nVerifies that type is a valid address attribute type.\n@param type the type to test\n@return true if the type is a valid address attribute type and false\notherwise\n"}, {"uris": "src/main/java/org/ice4j/attribute/AddressAttribute.java.AddressAttribute.[void]setAttributeType(char)", "name": "setAttributeType", "arg_nums": 1, "params": [{"name": "type", "type": "char"}], "return_type": "void", "signature": "protected void setAttributeType(char  type)", "original_string": "    protected void setAttributeType(char  type)\n    {\n        if (!isTypeValid(type))\n            throw new IllegalArgumentException(((int)type)\n                                + \"is not a valid address attribute!\");\n\n        super.setAttributeType(type);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/AddressAttribute.java", "class_name": "AddressAttribute", "class_uri": "src/main/java/org/ice4j/attribute/AddressAttribute.java.AddressAttribute", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets it as this attribute's type.\n\n@param type the new type of the attribute.\n"}, {"uris": "src/main/java/org/ice4j/attribute/AddressAttribute.java.AddressAttribute.[String]getName()", "name": "getName", "arg_nums": 0, "params": [], "return_type": "String", "signature": "public String getName()", "original_string": "    public String getName()\n    {\n        switch(getAttributeType())\n        {\n            case MAPPED_ADDRESS:     return MappedAddressAttribute.NAME;\n            case RESPONSE_ADDRESS:   return ResponseAddressAttribute.NAME;\n            case SOURCE_ADDRESS:     return SourceAddressAttribute.NAME;\n            case CHANGED_ADDRESS:    return ChangedAddressAttribute.NAME;\n            case REFLECTED_FROM:     return ReflectedFromAttribute.NAME;\n            case XOR_MAPPED_ADDRESS: return XorMappedAddressAttribute.NAME;\n            case ALTERNATE_SERVER:   return AlternateServerAttribute.NAME;\n            case XOR_PEER_ADDRESS:   return XorPeerAddressAttribute.NAME;\n            case XOR_RELAYED_ADDRESS:return XorRelayedAddressAttribute.NAME;\n        }\n\n        return \"UNKNOWN ATTRIBUTE\";\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/AddressAttribute.java", "class_name": "AddressAttribute", "class_uri": "src/main/java/org/ice4j/attribute/AddressAttribute.java.AddressAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns the human readable name of this attribute. Attribute names do\nnot really matter from the protocol point of view. They are only used\nfor debugging and readability.\n@return this attribute's name.\n"}, {"uris": "src/main/java/org/ice4j/attribute/AddressAttribute.java.AddressAttribute.[boolean]equals(Object)", "name": "equals", "arg_nums": 1, "params": [{"name": "obj", "type": "Object"}], "return_type": "boolean", "signature": "public boolean equals(Object obj)", "original_string": "    public boolean equals(Object obj)\n    {\n        if (! (obj instanceof AddressAttribute))\n            return false;\n\n        if (obj == this)\n            return true;\n\n        AddressAttribute att = (AddressAttribute) obj;\n        if (att.getAttributeType() != getAttributeType()\n            || att.getDataLength() != getDataLength()\n            //compare data\n            || att.getFamily()     != getFamily()\n            || (att.getAddress()   != null\n                && !address.equals(att.getAddress()))\n            )\n            return false;\n\n        //addresses\n        if ( att.getAddress() == null && getAddress() == null)\n            return true;\n\n        return true;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/AddressAttribute.java", "class_name": "AddressAttribute", "class_uri": "src/main/java/org/ice4j/attribute/AddressAttribute.java.AddressAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nCompares two STUN Attributes. Attributes are considered equal when their\ntype, length, and all data are the same.\n\n@param obj the object to compare this attribute with.\n@return true if the attributes are equal and false otherwise.\n"}, {"uris": "src/main/java/org/ice4j/attribute/AddressAttribute.java.AddressAttribute.[char]getDataLength()", "name": "getDataLength", "arg_nums": 0, "params": [], "return_type": "char", "signature": "public char getDataLength()", "original_string": "    public char getDataLength()\n    {\n        if (getFamily() == ADDRESS_FAMILY_IPV6)\n            return DATA_LENGTH_FOR_IPV6;\n        else\n            return DATA_LENGTH_FOR_IPV4;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/AddressAttribute.java", "class_name": "AddressAttribute", "class_uri": "src/main/java/org/ice4j/attribute/AddressAttribute.java.AddressAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "char", "classes": []}, "docstring": "\nReturns the length of this attribute's body.\n@return the length of this attribute's value (8 bytes).\n"}, {"uris": "src/main/java/org/ice4j/attribute/AddressAttribute.java.AddressAttribute.[byte[]]encode()", "name": "encode", "arg_nums": 0, "params": [], "return_type": "byte[]", "signature": "public byte[] encode()", "original_string": "    public byte[] encode()\n    {\n        char type = getAttributeType();\n        if (!isTypeValid(type))\n            throw new IllegalStateException(((int)type)\n                            + \"is not a valid address attribute!\");\n        byte binValue[] = new byte[HEADER_LENGTH + getDataLength()];\n\n        //Type\n        binValue[0] = (byte)(type >> 8);\n        binValue[1] = (byte)(type & 0x00FF);\n        //Length\n        binValue[2] = (byte)(getDataLength() >> 8);\n        binValue[3] = (byte)(getDataLength() & 0x00FF);\n        //Not used\n        binValue[4] = 0x00;\n        //Family\n        binValue[5] = getFamily();\n        //port\n        binValue[6] = (byte)(getPort() >> 8);\n        binValue[7] = (byte)(getPort() & 0x00FF);\n\n        //address\n        if (getFamily() == ADDRESS_FAMILY_IPV6)\n        {\n            System.arraycopy(getAddressBytes(), 0, binValue, 8, 16);\n        }\n        else\n        {\n            System.arraycopy(getAddressBytes(), 0, binValue, 8, 4);\n        }\n\n        return binValue;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/AddressAttribute.java", "class_name": "AddressAttribute", "class_uri": "src/main/java/org/ice4j/attribute/AddressAttribute.java.AddressAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "byte[]", "classes": []}, "docstring": "\nReturns a binary representation of this attribute.\n@return a binary representation of this attribute.\n"}, {"uris": "src/main/java/org/ice4j/attribute/AddressAttribute.java.AddressAttribute.[void]setAddress(TransportAddress)", "name": "setAddress", "arg_nums": 1, "params": [{"name": "address", "type": "TransportAddress"}], "return_type": "void", "signature": "public void setAddress(TransportAddress address)", "original_string": "    public void setAddress(TransportAddress address)\n    {\n        this.address = address;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/AddressAttribute.java", "class_name": "AddressAttribute", "class_uri": "src/main/java/org/ice4j/attribute/AddressAttribute.java.AddressAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets address to be the address transported by this attribute.\n@param address that this attribute should encapsulate.\n"}, {"uris": "src/main/java/org/ice4j/attribute/AddressAttribute.java.AddressAttribute.[TransportAddress]getAddress()", "name": "getAddress", "arg_nums": 0, "params": [], "return_type": "TransportAddress", "signature": "public TransportAddress getAddress()", "original_string": "    public TransportAddress getAddress()\n    {\n        return address;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/AddressAttribute.java", "class_name": "AddressAttribute", "class_uri": "src/main/java/org/ice4j/attribute/AddressAttribute.java.AddressAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "TransportAddress", "classes": []}, "docstring": "\nReturns the address encapsulated by this attribute.\n\n@return the address encapsulated by this attribute.\n"}, {"uris": "src/main/java/org/ice4j/attribute/AddressAttribute.java.AddressAttribute.[byte[]]getAddressBytes()", "name": "getAddressBytes", "arg_nums": 0, "params": [], "return_type": "byte[]", "signature": "public byte[] getAddressBytes()", "original_string": "    public byte[] getAddressBytes()\n    {\n        return address.getAddressBytes();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/AddressAttribute.java", "class_name": "AddressAttribute", "class_uri": "src/main/java/org/ice4j/attribute/AddressAttribute.java.AddressAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "byte[]", "classes": []}, "docstring": "\nReturns the bytes of the address.\n\n@return the <tt>byte[]</tt> array containing the address.\n"}, {"uris": "src/main/java/org/ice4j/attribute/AddressAttribute.java.AddressAttribute.[byte]getFamily()", "name": "getFamily", "arg_nums": 0, "params": [], "return_type": "byte", "signature": "public byte getFamily()", "original_string": "    public byte getFamily()\n    {\n        if ( address.getAddress() instanceof Inet6Address )\n            return ADDRESS_FAMILY_IPV6;\n        else\n            return ADDRESS_FAMILY_IPV4;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/AddressAttribute.java", "class_name": "AddressAttribute", "class_uri": "src/main/java/org/ice4j/attribute/AddressAttribute.java.AddressAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "byte", "classes": []}, "docstring": "\nReturns the family that the this.address belongs to.\n@return the family that the this.address belongs to.\n"}, {"uris": "src/main/java/org/ice4j/attribute/AddressAttribute.java.AddressAttribute.[int]getPort()", "name": "getPort", "arg_nums": 0, "params": [], "return_type": "int", "signature": "public int getPort()", "original_string": "    public int getPort()\n    {\n        return address.getPort();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/AddressAttribute.java", "class_name": "AddressAttribute", "class_uri": "src/main/java/org/ice4j/attribute/AddressAttribute.java.AddressAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\nReturns the port associated with the address contained by the attribute.\n@return the port associated with the address contained by the attribute.\n"}, {"uris": "src/main/java/org/ice4j/attribute/AddressAttribute.java.AddressAttribute.[void]decodeAttributeBody(byte[],char,char)", "name": "decodeAttributeBody", "arg_nums": 3, "params": [{"name": "attributeValue", "type": "byte[]"}, {"name": "offset", "type": "char"}, {"name": "length", "type": "char"}], "return_type": "void", "signature": "void decodeAttributeBody(byte[] attributeValue, char offset, char length)", "original_string": "    void decodeAttributeBody(byte[] attributeValue, char offset, char length)\n        throws StunException\n    {\n        //skip through padding\n        offset ++;\n\n        //get family\n        byte family = attributeValue[offset++];\n\n        //port\n        char port = ((char)((attributeValue[offset++] << 8 )\n                        | (attributeValue[offset++] & 0xFF) ));\n\n        //address\n        byte address[] = null;\n        if (family == ADDRESS_FAMILY_IPV6)\n        {\n            address = new byte[16];\n        }\n        else\n        {\n            //ipv4\n            address = new byte[4];\n        }\n\n        System.arraycopy(attributeValue, offset, address, 0, address.length);\n        try\n        {\n            setAddress(new TransportAddress(address, port, Transport.UDP));\n        }\n        catch (UnknownHostException e)\n        {\n            throw new StunException(e);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/AddressAttribute.java", "class_name": "AddressAttribute", "class_uri": "src/main/java/org/ice4j/attribute/AddressAttribute.java.AddressAttribute", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets this attribute's fields according to attributeValue array.\n\n@param attributeValue a binary array containing this attribute's field\n                      values and NOT containing the attribute header.\n@param offset the position where attribute values begin (most often\n                 offset is equal to the index of the first byte after\n                 length)\n@param length the length of the binary array.\n@throws StunException if attrubteValue contains invalid data.\n"}, {"uris": "src/main/java/org/ice4j/attribute/XorOnlyAttribute.java.XorOnlyAttribute.[]XorOnlyAttribute()", "name": "XorOnlyAttribute", "arg_nums": 0, "params": [], "return_type": "", "signature": "protected XorOnlyAttribute()", "original_string": "    protected XorOnlyAttribute()\n    {\n        super(Attribute.XOR_ONLY);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/XorOnlyAttribute.java", "class_name": "XorOnlyAttribute", "class_uri": "src/main/java/org/ice4j/attribute/XorOnlyAttribute.java.XorOnlyAttribute", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nConstructor.\n"}, {"uris": "src/main/java/org/ice4j/attribute/XorOnlyAttribute.java.XorOnlyAttribute.[void]decodeAttributeBody(byte[],char,char)", "name": "decodeAttributeBody", "arg_nums": 3, "params": [{"name": "attributeValue", "type": "byte[]"}, {"name": "offset", "type": "char"}, {"name": "length", "type": "char"}], "return_type": "void", "signature": "void decodeAttributeBody(byte[] attributeValue, char offset, char length)", "original_string": "    void decodeAttributeBody(byte[] attributeValue, char offset, char length)\n        throws StunException\n    {\n        //nothing to do cause we have 0 length\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/XorOnlyAttribute.java", "class_name": "XorOnlyAttribute", "class_uri": "src/main/java/org/ice4j/attribute/XorOnlyAttribute.java.XorOnlyAttribute", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets this attribute's fields according to attributeValue array.\n\n@param attributeValue a binary array containing this attribute's\n  field values and NOT containing the attribute header.\n@param offset the position where attribute values begin (most often\n  offset is equal to the index of the first byte after length)\n@param length the length of the binary array.\n@throws StunException if attrubteValue contains invalid data.\n"}, {"uris": "src/main/java/org/ice4j/attribute/XorOnlyAttribute.java.XorOnlyAttribute.[byte[]]encode()", "name": "encode", "arg_nums": 0, "params": [], "return_type": "byte[]", "signature": "public byte[] encode()", "original_string": "    public byte[] encode()\n    {\n        char type = getAttributeType();\n        byte binValue[] = new byte[HEADER_LENGTH + getDataLength()];\n\n        //Type\n        binValue[0] = (byte)(type >> 8);\n        binValue[1] = (byte)(type & 0x00FF);\n\n        //Length\n        binValue[2] = (byte)(getDataLength() >> 8);\n        binValue[3] = (byte)(getDataLength() & 0x00FF);\n\n        return binValue;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/XorOnlyAttribute.java", "class_name": "XorOnlyAttribute", "class_uri": "src/main/java/org/ice4j/attribute/XorOnlyAttribute.java.XorOnlyAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "byte[]", "classes": []}, "docstring": "\nReturns a binary representation of this attribute.\n\n@return a binary representation of this attribute.\n"}, {"uris": "src/main/java/org/ice4j/attribute/XorOnlyAttribute.java.XorOnlyAttribute.[char]getDataLength()", "name": "getDataLength", "arg_nums": 0, "params": [], "return_type": "char", "signature": "public char getDataLength()", "original_string": "    public char getDataLength()\n    {\n        return 0;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/XorOnlyAttribute.java", "class_name": "XorOnlyAttribute", "class_uri": "src/main/java/org/ice4j/attribute/XorOnlyAttribute.java.XorOnlyAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "char", "classes": []}, "docstring": "\nReturns the length of this attribute's body. (Which in the case of the\nXOR-ONLY attribute is 0);\n\n@return the length of this attribute's value.\n"}, {"uris": "src/main/java/org/ice4j/attribute/XorOnlyAttribute.java.XorOnlyAttribute.[String]getName()", "name": "getName", "arg_nums": 0, "params": [], "return_type": "String", "signature": "public String getName()", "original_string": "    public String getName()\n    {\n        return \"XOR-ONLY\";\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/XorOnlyAttribute.java", "class_name": "XorOnlyAttribute", "class_uri": "src/main/java/org/ice4j/attribute/XorOnlyAttribute.java.XorOnlyAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns the human readable name of this attribute.\n\n@return this attribute's name.\n"}, {"uris": "src/main/java/org/ice4j/attribute/XorOnlyAttribute.java.XorOnlyAttribute.[boolean]equals(Object)", "name": "equals", "arg_nums": 1, "params": [{"name": "obj", "type": "Object"}], "return_type": "boolean", "signature": "public boolean equals(Object obj)", "original_string": "    public boolean equals(Object obj)\n    {\n        if (! (obj instanceof XorOnlyAttribute))\n            return false;\n\n        if (obj == this)\n            return true;\n\n        XorOnlyAttribute att = (XorOnlyAttribute) obj;\n        if (att.getAttributeType() != getAttributeType()\n            || att.getDataLength() != getDataLength())\n            return false;\n\n        return true;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/XorOnlyAttribute.java", "class_name": "XorOnlyAttribute", "class_uri": "src/main/java/org/ice4j/attribute/XorOnlyAttribute.java.XorOnlyAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nCompares two STUN Attributes. Two attributes are considered equal when\nthey have the same type length and value.\n\n@param obj the object to compare this attribute with.\n@return true if the attributes are equal and false otherwise.\n"}, {"uris": "src/main/java/org/ice4j/attribute/UsernameAttribute.java.UsernameAttribute.[]UsernameAttribute()", "name": "UsernameAttribute", "arg_nums": 0, "params": [], "return_type": "", "signature": "UsernameAttribute()", "original_string": "    UsernameAttribute()\n    {\n        super(USERNAME);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/UsernameAttribute.java", "class_name": "UsernameAttribute", "class_uri": "src/main/java/org/ice4j/attribute/UsernameAttribute.java.UsernameAttribute", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "docstring": "\nConstructor.\n"}, {"uris": "src/main/java/org/ice4j/attribute/UsernameAttribute.java.UsernameAttribute.[void]decodeAttributeBody(byte[],char,char)", "name": "decodeAttributeBody", "arg_nums": 3, "params": [{"name": "attributeValue", "type": "byte[]"}, {"name": "offset", "type": "char"}, {"name": "length", "type": "char"}], "return_type": "void", "signature": "@Override\n    void decodeAttributeBody(byte[] attributeValue, char offset, char length)", "original_string": "    @Override\n    void decodeAttributeBody(byte[] attributeValue, char offset, char length)\n    {\n        username = new byte[length];\n        System.arraycopy(attributeValue, offset, username, 0, length);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/UsernameAttribute.java", "class_name": "UsernameAttribute", "class_uri": "src/main/java/org/ice4j/attribute/UsernameAttribute.java.UsernameAttribute", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCopies the value of the username attribute from the specified\nattributeValue.\n\n@param attributeValue a binary array containing this attribute's\n  field values and NOT containing the attribute header.\n@param offset the position where attribute values begin (most often\n  offset is equal to the index of the first byte after length)\n@param length the length of the binary array.\n"}, {"uris": "src/main/java/org/ice4j/attribute/UsernameAttribute.java.UsernameAttribute.[byte[]]encode()", "name": "encode", "arg_nums": 0, "params": [], "return_type": "byte[]", "signature": "public byte[] encode()", "original_string": "    public byte[] encode()\n    {\n        char type = getAttributeType();\n        byte binValue[] = new byte[HEADER_LENGTH + getDataLength()\n                                   //add padding\n                                   + (4 - getDataLength() % 4) % 4];\n\n        //Type\n        binValue[0] = (byte)(type >> 8);\n        binValue[1] = (byte)(type & 0x00FF);\n\n        //Length\n        binValue[2] = (byte)(getDataLength() >> 8);\n        binValue[3] = (byte)(getDataLength() & 0x00FF);\n\n        //username\n        System.arraycopy(username, 0, binValue, 4, getDataLength());\n\n        return binValue;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/UsernameAttribute.java", "class_name": "UsernameAttribute", "class_uri": "src/main/java/org/ice4j/attribute/UsernameAttribute.java.UsernameAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "byte[]", "classes": []}, "docstring": "\nReturns a binary representation of this attribute.\n\n@return a binary representation of this attribute.\n"}, {"uris": "src/main/java/org/ice4j/attribute/UsernameAttribute.java.UsernameAttribute.[char]getDataLength()", "name": "getDataLength", "arg_nums": 0, "params": [], "return_type": "char", "signature": "public char getDataLength()", "original_string": "    public char getDataLength()\n    {\n        return (char)username.length;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/UsernameAttribute.java", "class_name": "UsernameAttribute", "class_uri": "src/main/java/org/ice4j/attribute/UsernameAttribute.java.UsernameAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "char", "classes": []}, "docstring": "\nReturns the length of this attribute's body.\n\n@return the length of this attribute's value.\n"}, {"uris": "src/main/java/org/ice4j/attribute/UsernameAttribute.java.UsernameAttribute.[String]getName()", "name": "getName", "arg_nums": 0, "params": [], "return_type": "String", "signature": "public String getName()", "original_string": "    public String getName()\n    {\n        return NAME;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/UsernameAttribute.java", "class_name": "UsernameAttribute", "class_uri": "src/main/java/org/ice4j/attribute/UsernameAttribute.java.UsernameAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns the human readable name of this attribute.\n\n@return this attribute's name.\n"}, {"uris": "src/main/java/org/ice4j/attribute/UsernameAttribute.java.UsernameAttribute.[byte[]]getUsername()", "name": "getUsername", "arg_nums": 0, "params": [], "return_type": "byte[]", "signature": "public byte[] getUsername()", "original_string": "    public byte[] getUsername()\n    {\n        return (username == null) ? null : username.clone();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/UsernameAttribute.java", "class_name": "UsernameAttribute", "class_uri": "src/main/java/org/ice4j/attribute/UsernameAttribute.java.UsernameAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "byte[]", "classes": []}, "docstring": "\nReturns a (cloned) byte array containing the data value of the username\nattribute.\n\n@return the binary array containing the username.\n"}, {"uris": "src/main/java/org/ice4j/attribute/UsernameAttribute.java.UsernameAttribute.[void]setUsername(byte[])", "name": "setUsername", "arg_nums": 1, "params": [{"name": "username", "type": "byte[]"}], "return_type": "void", "signature": "public void setUsername(byte[] username)", "original_string": "    public void setUsername(byte[] username)\n    {\n        if (username == null)\n        {\n            this.username = null;\n            return;\n        }\n\n        this.username = new byte[username.length];\n        System.arraycopy(username, 0, this.username, 0, username.length);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/UsernameAttribute.java", "class_name": "UsernameAttribute", "class_uri": "src/main/java/org/ice4j/attribute/UsernameAttribute.java.UsernameAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCopies the specified binary array into the the data value of the username\nattribute.\n\n@param username the binary array containing the username.\n"}, {"uris": "src/main/java/org/ice4j/attribute/UsernameAttribute.java.UsernameAttribute.[boolean]equals(Object)", "name": "equals", "arg_nums": 1, "params": [{"name": "obj", "type": "Object"}], "return_type": "boolean", "signature": "public boolean equals(Object obj)", "original_string": "    public boolean equals(Object obj)\n    {\n        if (! (obj instanceof UsernameAttribute))\n            return false;\n\n        if (obj == this)\n            return true;\n\n        UsernameAttribute att = (UsernameAttribute) obj;\n        if (att.getAttributeType() != getAttributeType()\n                || att.getDataLength() != getDataLength()\n                || !Arrays.equals( att.username, username))\n            return false;\n\n        return true;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/UsernameAttribute.java", "class_name": "UsernameAttribute", "class_uri": "src/main/java/org/ice4j/attribute/UsernameAttribute.java.UsernameAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nCompares two STUN Attributes. Two attributes are considered equal when\nthey have the same type length and value.\n\n@param obj the object to compare this attribute with.\n\n@return true if the attributes are equal and false otherwise.\n"}, {"uris": "src/main/java/org/ice4j/attribute/PriorityAttribute.java.PriorityAttribute.[]PriorityAttribute()", "name": "PriorityAttribute", "arg_nums": 0, "params": [], "return_type": "", "signature": "public PriorityAttribute()", "original_string": "    public PriorityAttribute()\n    {\n        super(PRIORITY);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/PriorityAttribute.java", "class_name": "PriorityAttribute", "class_uri": "src/main/java/org/ice4j/attribute/PriorityAttribute.java.PriorityAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nCreates a priority attribute.\n"}, {"uris": "src/main/java/org/ice4j/attribute/PriorityAttribute.java.PriorityAttribute.[void]decodeAttributeBody(byte[],char,char)", "name": "decodeAttributeBody", "arg_nums": 3, "params": [{"name": "attributeValue", "type": "byte[]"}, {"name": "offset", "type": "char"}, {"name": "length", "type": "char"}], "return_type": "void", "signature": "void decodeAttributeBody(byte[] attributeValue, char offset, char length)", "original_string": "    void decodeAttributeBody(byte[] attributeValue, char offset, char length)\n            throws StunException\n    {\n\n        // array used to hold the intermediate long values reconstructed from\n        // the attributeValue array\n        long[] values = new long[4];\n\n        // Reading in the network byte order (Big-Endian)\n        values[0] = (long)((attributeValue[offset++] & 0xff) << 24);\n        values[1] = (long)((attributeValue[offset++] & 0xff) << 16);\n        values[2] = (long)((attributeValue[offset++] & 0xff) << 8);\n        values[3] = (long)(attributeValue[offset++] & 0xff);\n\n        // reconstructing the priority value\n        this.priority = values[0] | values[1] | values[2] | values[3];\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/PriorityAttribute.java", "class_name": "PriorityAttribute", "class_uri": "src/main/java/org/ice4j/attribute/PriorityAttribute.java.PriorityAttribute", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nReconstructs the priority value from the given byte array\nand stores it in the 'long' variable\n\n@param attributeValue a binary array containing this attribute's\n  field values and NOT containing the attribute header.\n@param offset the position where attribute values begin (most often\n  offset is equal to the index of the first byte after length)\n@param length the length of the binary array.\n@throws StunException if attrubteValue contains invalid data.\n"}, {"uris": "src/main/java/org/ice4j/attribute/PriorityAttribute.java.PriorityAttribute.[byte[]]encode()", "name": "encode", "arg_nums": 0, "params": [], "return_type": "byte[]", "signature": "public byte[] encode()", "original_string": "    public byte[] encode()\n    {\n        char type = getAttributeType();\n        byte[] binValue = new byte[HEADER_LENGTH + getDataLength()];\n\n        //Type\n        binValue[0] = (byte)(type >> 8);\n        binValue[1] = (byte)(type & 0x00FF);\n\n        //Length\n        binValue[2] = (byte)(getDataLength() >> 8);\n        binValue[3] = (byte)(getDataLength() & 0x00FF);\n\n        //Priority\n        binValue[4] = (byte)((priority & 0xFF000000L) >> 24);\n        binValue[5] = (byte)((priority & 0x00FF0000L) >> 16);\n        binValue[6] = (byte)((priority & 0x0000FF00L) >> 8);\n        binValue[7] = (byte)(priority & 0x000000FFL);\n\n        return binValue;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/PriorityAttribute.java", "class_name": "PriorityAttribute", "class_uri": "src/main/java/org/ice4j/attribute/PriorityAttribute.java.PriorityAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "byte[]", "classes": []}, "docstring": "\nReturns a binary representation of this attribute.\n\n@return a binary representation of this attribute.\n"}, {"uris": "src/main/java/org/ice4j/attribute/PriorityAttribute.java.PriorityAttribute.[boolean]equals(Object)", "name": "equals", "arg_nums": 1, "params": [{"name": "obj", "type": "Object"}], "return_type": "boolean", "signature": "public boolean equals(Object obj)", "original_string": "    public boolean equals(Object obj)\n    {\n        if (! (obj instanceof PriorityAttribute))\n            return false;\n\n        if (obj == this)\n            return true;\n\n        PriorityAttribute att = (PriorityAttribute) obj;\n        if (att.getAttributeType() != getAttributeType()\n            || att.getDataLength() != getDataLength()\n            || (priority != att.priority))\n            return false;\n\n        return true;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/PriorityAttribute.java", "class_name": "PriorityAttribute", "class_uri": "src/main/java/org/ice4j/attribute/PriorityAttribute.java.PriorityAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nCompares two STUN Attributes. Two attributes are considered equal when\nthey have the same type length and value.\n\n@param obj the object to compare this attribute with.\n@return true if the attributes are equal and false otherwise.\n"}, {"uris": "src/main/java/org/ice4j/attribute/PriorityAttribute.java.PriorityAttribute.[char]getDataLength()", "name": "getDataLength", "arg_nums": 0, "params": [], "return_type": "char", "signature": "public char getDataLength()", "original_string": "    public char getDataLength()\n    {\n        return DATA_LENGTH_PRIORITY;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/PriorityAttribute.java", "class_name": "PriorityAttribute", "class_uri": "src/main/java/org/ice4j/attribute/PriorityAttribute.java.PriorityAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "char", "classes": []}, "docstring": "\nReturns the length of this attribute's body.\n\n@return the length of this attribute's value.\n"}, {"uris": "src/main/java/org/ice4j/attribute/PriorityAttribute.java.PriorityAttribute.[String]getName()", "name": "getName", "arg_nums": 0, "params": [], "return_type": "String", "signature": "public String getName()", "original_string": "    public String getName()\n    {\n        return \"PRIORITY\";\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/PriorityAttribute.java", "class_name": "PriorityAttribute", "class_uri": "src/main/java/org/ice4j/attribute/PriorityAttribute.java.PriorityAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns the human readable name of this attribute.\n\n@return this attribute's name.\n"}, {"uris": "src/main/java/org/ice4j/attribute/PriorityAttribute.java.PriorityAttribute.[long]getPriority()", "name": "getPriority", "arg_nums": 0, "params": [], "return_type": "long", "signature": "public long getPriority()", "original_string": "    public long getPriority()\n    {\n        return priority;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/PriorityAttribute.java", "class_name": "PriorityAttribute", "class_uri": "src/main/java/org/ice4j/attribute/PriorityAttribute.java.PriorityAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "long", "classes": []}, "docstring": "\nReturns the priority specified in the PRIORITY Attribute\n\n@return long specifying the priority\n"}, {"uris": "src/main/java/org/ice4j/attribute/PriorityAttribute.java.PriorityAttribute.[void]setPriority(long)", "name": "setPriority", "arg_nums": 1, "params": [{"name": "priority", "type": "long"}], "return_type": "void", "signature": "public void setPriority(long priority)", "original_string": "    public void setPriority(long priority)\n        throws IllegalArgumentException\n    {\n        /* Priority must be between 1 and (2^31 - 1) */\n        if (priority <= 0 || priority > 0x7FFFFFFFL)\n        {\n            throw new IllegalArgumentException(\"Priority must be \" +\n                    \"between 0 and (2**31 - 1)\");\n        }\n        else\n            this.priority = priority;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/PriorityAttribute.java", "class_name": "PriorityAttribute", "class_uri": "src/main/java/org/ice4j/attribute/PriorityAttribute.java.PriorityAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets the priority of the PRIORITY Attribute with the specified value\n\n@param priority     the long variable specifying the priority value\n\n@throws IllegalArgumentException if indicated priority value is illegal.\n"}, {"uris": "src/main/java/org/ice4j/attribute/IceControlledAttribute.java.IceControlledAttribute.[]IceControlledAttribute()", "name": "IceControlledAttribute", "arg_nums": 0, "params": [], "return_type": "", "signature": "public IceControlledAttribute()", "original_string": "    public IceControlledAttribute()\n    {\n        super(false);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/IceControlledAttribute.java", "class_name": "IceControlledAttribute", "class_uri": "src/main/java/org/ice4j/attribute/IceControlledAttribute.java.IceControlledAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nConstructs an ICE-CONTROLLING attribute.\n"}, {"uris": "src/main/java/org/ice4j/attribute/ReflectedFromAttribute.java.ReflectedFromAttribute.[]ReflectedFromAttribute()", "name": "ReflectedFromAttribute", "arg_nums": 0, "params": [], "return_type": "", "signature": "public ReflectedFromAttribute()", "original_string": "    public ReflectedFromAttribute()\n    {\n        super(REFLECTED_FROM);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/ReflectedFromAttribute.java", "class_name": "ReflectedFromAttribute", "class_uri": "src/main/java/org/ice4j/attribute/ReflectedFromAttribute.java.ReflectedFromAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nCreates a REFLECTED-FROM attribute\n"}, {"uris": "src/main/java/org/ice4j/attribute/ErrorCodeAttribute.java.ErrorCodeAttribute.[]ErrorCodeAttribute()", "name": "ErrorCodeAttribute", "arg_nums": 0, "params": [], "return_type": "", "signature": "ErrorCodeAttribute()", "original_string": "    ErrorCodeAttribute()\n    {\n        super(ERROR_CODE);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/ErrorCodeAttribute.java", "class_name": "ErrorCodeAttribute", "class_uri": "src/main/java/org/ice4j/attribute/ErrorCodeAttribute.java.ErrorCodeAttribute", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "docstring": "\nConstructs a new ERROR-CODE attribute\n"}, {"uris": "src/main/java/org/ice4j/attribute/ErrorCodeAttribute.java.ErrorCodeAttribute.[void]setErrorCode(char)", "name": "setErrorCode", "arg_nums": 1, "params": [{"name": "errorCode", "type": "char"}], "return_type": "void", "signature": "public void setErrorCode(char errorCode)", "original_string": "    public void setErrorCode(char errorCode)\n        throws IllegalArgumentException\n    {\n        setErrorClass((byte)(errorCode / 100));\n        setErrorNumber((byte)(errorCode % 100));\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/ErrorCodeAttribute.java", "class_name": "ErrorCodeAttribute", "class_uri": "src/main/java/org/ice4j/attribute/ErrorCodeAttribute.java.ErrorCodeAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nA convenience method that sets error class and number according to the\nspecified errorCode.The class represents the hundreds digit of the error\ncode. The value MUST be between 1 and 6.  The number represents the\nresponse code modulo 100, and its value MUST be between 0 and 99.\n\n@param errorCode the errorCode that this class encapsulates.\n@throws IllegalArgumentException if errorCode is not a valid error code.\n"}, {"uris": "src/main/java/org/ice4j/attribute/ErrorCodeAttribute.java.ErrorCodeAttribute.[char]getErrorCode()", "name": "getErrorCode", "arg_nums": 0, "params": [], "return_type": "char", "signature": "public char getErrorCode()", "original_string": "    public char getErrorCode()\n    {\n        return (char)(getErrorClass() * 100 + getErrorNumber());\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/ErrorCodeAttribute.java", "class_name": "ErrorCodeAttribute", "class_uri": "src/main/java/org/ice4j/attribute/ErrorCodeAttribute.java.ErrorCodeAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "char", "classes": []}, "docstring": "\nA convenience method that constructs an error code from this Attribute's\nclass and number.\n@return the code of the error this attribute represents.\n"}, {"uris": "src/main/java/org/ice4j/attribute/ErrorCodeAttribute.java.ErrorCodeAttribute.[void]setErrorNumber(byte)", "name": "setErrorNumber", "arg_nums": 1, "params": [{"name": "errorNumber", "type": "byte"}], "return_type": "void", "signature": "public void setErrorNumber(byte errorNumber)", "original_string": "    public void setErrorNumber(byte errorNumber)\n        throws IllegalArgumentException\n    {\n        /*\n        if(errorNumber < 0 || errorNumber > 9999)\n            throw new IllegalArgumentException(\n                            errorNumber + \" is not a valid error number!\");\n         */\n        this.errorNumber = errorNumber;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/ErrorCodeAttribute.java", "class_name": "ErrorCodeAttribute", "class_uri": "src/main/java/org/ice4j/attribute/ErrorCodeAttribute.java.ErrorCodeAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets this attribute's error number.\n@param errorNumber the error number to assign this attribute.\n@throws IllegalArgumentException if errorNumber is not a valid error\nnumber.\n"}, {"uris": "src/main/java/org/ice4j/attribute/ErrorCodeAttribute.java.ErrorCodeAttribute.[byte]getErrorNumber()", "name": "getErrorNumber", "arg_nums": 0, "params": [], "return_type": "byte", "signature": "public byte getErrorNumber()", "original_string": "    public byte getErrorNumber()\n    {\n        return this.errorNumber;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/ErrorCodeAttribute.java", "class_name": "ErrorCodeAttribute", "class_uri": "src/main/java/org/ice4j/attribute/ErrorCodeAttribute.java.ErrorCodeAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "byte", "classes": []}, "docstring": "\nReturns this attribute's error number.\n@return  this attribute's error number.\n"}, {"uris": "src/main/java/org/ice4j/attribute/ErrorCodeAttribute.java.ErrorCodeAttribute.[void]setErrorClass(byte)", "name": "setErrorClass", "arg_nums": 1, "params": [{"name": "errorClass", "type": "byte"}], "return_type": "void", "signature": "public void setErrorClass(byte errorClass)", "original_string": "    public void setErrorClass(byte errorClass)\n        throws IllegalArgumentException\n    {\n        if (errorClass < 0 || errorClass > 99)\n            throw new IllegalArgumentException(\n                errorClass + \" is not a valid error number!\");\n        this.errorClass = errorClass;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/ErrorCodeAttribute.java", "class_name": "ErrorCodeAttribute", "class_uri": "src/main/java/org/ice4j/attribute/ErrorCodeAttribute.java.ErrorCodeAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets this error's error class.\n@param errorClass this error's error class.\n@throws IllegalArgumentException if errorClass is not a valid error\nclass.\n"}, {"uris": "src/main/java/org/ice4j/attribute/ErrorCodeAttribute.java.ErrorCodeAttribute.[byte]getErrorClass()", "name": "getErrorClass", "arg_nums": 0, "params": [], "return_type": "byte", "signature": "public byte getErrorClass()", "original_string": "    public byte getErrorClass()\n    {\n        return errorClass;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/ErrorCodeAttribute.java", "class_name": "ErrorCodeAttribute", "class_uri": "src/main/java/org/ice4j/attribute/ErrorCodeAttribute.java.ErrorCodeAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "byte", "classes": []}, "docstring": "\nReturns this error's error class.\n@return this error's error class.\n"}, {"uris": "src/main/java/org/ice4j/attribute/ErrorCodeAttribute.java.ErrorCodeAttribute.[String]getDefaultReasonPhrase(char)", "name": "getDefaultReasonPhrase", "arg_nums": 1, "params": [{"name": "errorCode", "type": "char"}], "return_type": "String", "signature": "public static String getDefaultReasonPhrase(char errorCode)", "original_string": "    public static String getDefaultReasonPhrase(char errorCode)\n    {\n        switch(errorCode)\n        {\n            case 300:\n                return \"(Try Alternate): The server would like the client to\"\n                    + \" use the server specified in the ALTERNATE-SERVER\"\n                    + \" attribute instead.\";\n            case 400:\n                return \"(Bad Request): The request was malformed.  The client\"\n                    + \" should not retry the request without modification from\"\n                    + \" the previous attempt.\";\n            case 401:\n                return \"(Unauthorized): The Binding Request did not contain\"\n                    + \" a MESSAGE-INTEGRITY attribute.\";\n            case 403:\n                return \"(Forbidden): The request was valid but cannot be\"\n                    + \" performed due to administrative or similar\"\n                    + \" restrictions.\";\n            case 420:\n                return \"(Unknown Attribute): The server did not understand\"\n                    + \" a mandatory attribute in the request.\";\n            case 430:\n                return \"(Stale Credentials): The Binding Request did contain\"\n                    + \" a MESSAGE-INTEGRITY attribute, but it used a shared\"\n                    + \" secret that has expired.\";\n            case 431:\n                return \"(Integrity Check Failure): The Binding Request\"\n                    + \" contained a MESSAGE-INTEGRITY attribute, but the HMAC\"\n                    + \" failed verification.\";\n            case 432:\n                return \"(Missing Username): The Binding Request contained\"\n                    + \" a MESSAGE-INTEGRITY attribute, but not a USERNAME\"\n                    + \" attribute.\";\n            case 433:\n                return \"(Use TLS): The Shared Secret request has to be sent\"\n                    + \" over TLS, but was not received over TLS.\";\n            case 437:\n                return \"(Allocation Mismatch): A request was received by the\"\n                    + \" server that requires an allocation to be in place,\"\n                    + \" but no allocation exists, or a request was received\"\n                    + \" that requires no allocation, but an allocation exists.\";\n            case 438:\n                return \"(Stale Nonce): See the procedures for the long-term\"\n                    + \" credential mechanism.\";\n            case 440:\n                return \"(Address Family not Supported):  The server does not\"\n                    + \" support the address family requested by the client.\";\n            case 441:\n                return \"(Wrong Credentials): The credentials in the\"\n                    + \" (non-Allocate) request do not match those used\"\n                    + \" to create the allocation.\";\n            case 442:\n                return \"(Unsupported Transport Protocol): The Allocate request\"\n                    + \" asked the server to use a transport protocol between\"\n                    + \" the server and the peer that the server does not\"\n                    + \" support.\";\n            case 443:\n                return \"Peer Address Family Mismatch):  A peer address was of\"\n                    + \" a different address family than that of the relayed\"\n                    + \" transport address of the allocation.\";\n            case 446:\n                return  \"Connection Already Exists\";\n            case 447:\n                return  \"Connection Timeout or Failure\";\n            case 486:\n                return \"(Allocation Quota Reached): No more allocations using\"\n                    + \" this username can be created at the present time.\";\n            case 500:\n                return  \"(Server Error): The server has suffered a temporary\"\n                    + \" error. The client should try again.\";\n            case 508:\n                return \"(Insufficient Capacity): The server is unable to carry\"\n                    + \" out the request due to some capacity limit being\"\n                    + \" reached.\";\n            case 600:\n                return \"(Global Failure:) The server is refusing to fulfill\"\n                    + \" the request. The client should not retry.\";\n            \n            default:  return \"Unknown Error\";\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/ErrorCodeAttribute.java", "class_name": "ErrorCodeAttribute", "class_uri": "src/main/java/org/ice4j/attribute/ErrorCodeAttribute.java.ErrorCodeAttribute", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns a default reason phrase corresponding to the specified error\ncode, as described by rfc 3489.\n@param errorCode the code of the error that the reason phrase must\n                 describe.\n@return a default reason phrase corresponding to the specified error\ncode, as described by rfc 3489.\n"}, {"uris": "src/main/java/org/ice4j/attribute/ErrorCodeAttribute.java.ErrorCodeAttribute.[void]setReasonPhrase(String)", "name": "setReasonPhrase", "arg_nums": 1, "params": [{"name": "reasonPhrase", "type": "String"}], "return_type": "void", "signature": "public void setReasonPhrase(String reasonPhrase)", "original_string": "    public void setReasonPhrase(String reasonPhrase)\n    {\n        this.reasonPhrase = reasonPhrase.getBytes();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/ErrorCodeAttribute.java", "class_name": "ErrorCodeAttribute", "class_uri": "src/main/java/org/ice4j/attribute/ErrorCodeAttribute.java.ErrorCodeAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSet's a reason phrase. The reason phrase is meant for user consumption,\nand can be anything appropriate for the response code.  The lengths of\nthe reason phrases MUST be a multiple of 4 (measured in bytes).\n\n@param reasonPhrase a reason phrase that describes this error.\n"}, {"uris": "src/main/java/org/ice4j/attribute/ErrorCodeAttribute.java.ErrorCodeAttribute.[String]getReasonPhrase()", "name": "getReasonPhrase", "arg_nums": 0, "params": [], "return_type": "String", "signature": "public String getReasonPhrase()", "original_string": "    public String getReasonPhrase()\n    {\n        if (reasonPhrase == null)\n            return null;\n\n        return new String(reasonPhrase);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/ErrorCodeAttribute.java", "class_name": "ErrorCodeAttribute", "class_uri": "src/main/java/org/ice4j/attribute/ErrorCodeAttribute.java.ErrorCodeAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns the reason phrase. The reason phrase is meant for user consumption,\nand can be anything appropriate for the response code.  The lengths of\nthe reason phrases MUST be a multiple of 4 (measured in bytes).\n\n@return reasonPhrase a reason phrase that describes this error.\n"}, {"uris": "src/main/java/org/ice4j/attribute/ErrorCodeAttribute.java.ErrorCodeAttribute.[String]getName()", "name": "getName", "arg_nums": 0, "params": [], "return_type": "String", "signature": "@Override\n    public String getName()", "original_string": "    @Override\n    public String getName()\n    {\n        return NAME;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/ErrorCodeAttribute.java", "class_name": "ErrorCodeAttribute", "class_uri": "src/main/java/org/ice4j/attribute/ErrorCodeAttribute.java.ErrorCodeAttribute", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns the human readable name of this attribute. Attribute names do\nnot really matter from the protocol point of view. They are only used\nfor debugging and readability.\n@return this attribute's name.\n"}, {"uris": "src/main/java/org/ice4j/attribute/ErrorCodeAttribute.java.ErrorCodeAttribute.[char]getDataLength()", "name": "getDataLength", "arg_nums": 0, "params": [], "return_type": "char", "signature": "@Override\n    public char getDataLength()", "original_string": "    @Override\n    public char getDataLength()\n    {\n        char len = (char)(4 //error code numbers\n           + (char)(reasonPhrase == null ? 0 : reasonPhrase.length));\n\n        return len;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/ErrorCodeAttribute.java", "class_name": "ErrorCodeAttribute", "class_uri": "src/main/java/org/ice4j/attribute/ErrorCodeAttribute.java.ErrorCodeAttribute", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "char", "classes": []}, "docstring": "\nReturns the length of this attribute's body.\n@return the length of this attribute's value.\n"}, {"uris": "src/main/java/org/ice4j/attribute/ErrorCodeAttribute.java.ErrorCodeAttribute.[byte[]]encode()", "name": "encode", "arg_nums": 0, "params": [], "return_type": "byte[]", "signature": "@Override\n    public byte[] encode()", "original_string": "    @Override\n    public byte[] encode()\n    {\n        byte binValue[] =  new byte[HEADER_LENGTH + getDataLength()\n                                    //add padding\n                                    + (4 - getDataLength() % 4) % 4];\n\n        //Type\n        binValue[0] = (byte) (getAttributeType() >> 8);\n        binValue[1] = (byte) (getAttributeType() & 0x00FF);\n        //Length\n        binValue[2] = (byte) (getDataLength() >> 8);\n        binValue[3] = (byte) (getDataLength() & 0x00FF);\n\n        //Not used\n        binValue[4] = 0x00;\n        binValue[5] = 0x00;\n\n        //Error code\n        binValue[6] = getErrorClass();\n        binValue[7] = getErrorNumber();\n\n        if (reasonPhrase != null)\n            System.arraycopy(reasonPhrase, 0, binValue, 8, reasonPhrase.length);\n\n        return binValue;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/ErrorCodeAttribute.java", "class_name": "ErrorCodeAttribute", "class_uri": "src/main/java/org/ice4j/attribute/ErrorCodeAttribute.java.ErrorCodeAttribute", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "byte[]", "classes": []}, "docstring": "\nReturns a binary representation of this attribute.\n@return a binary representation of this attribute.\n"}, {"uris": "src/main/java/org/ice4j/attribute/ErrorCodeAttribute.java.ErrorCodeAttribute.[boolean]equals(Object)", "name": "equals", "arg_nums": 1, "params": [{"name": "obj", "type": "Object"}], "return_type": "boolean", "signature": "@Override\n    public boolean equals(Object obj)", "original_string": "     @Override\n    public boolean equals(Object obj)\n     {\n         if (! (obj instanceof ErrorCodeAttribute))\n             return false;\n\n         if (obj == this)\n             return true;\n\n         ErrorCodeAttribute att = (ErrorCodeAttribute) obj;\n         if (att.getAttributeType() != getAttributeType()\n             || att.getDataLength() != getDataLength()\n             //compare data\n             || att.getErrorClass() != getErrorClass()\n             || att.getErrorNumber()!= getErrorNumber()\n             || ( att.getReasonPhrase() != null\n                  && !att.getReasonPhrase().equals(getReasonPhrase()))\n             )\n             return false;\n\n         return true;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/ErrorCodeAttribute.java", "class_name": "ErrorCodeAttribute", "class_uri": "src/main/java/org/ice4j/attribute/ErrorCodeAttribute.java.ErrorCodeAttribute", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nCompares two STUN Attributes. Attributes are considered equal when their\ntype, length, and all data are the same.\n\n@param obj the object to compare this attribute with.\n@return true if the attributes are equal and false otherwise.\n"}, {"uris": "src/main/java/org/ice4j/attribute/ErrorCodeAttribute.java.ErrorCodeAttribute.[void]decodeAttributeBody(byte[],char,char)", "name": "decodeAttributeBody", "arg_nums": 3, "params": [{"name": "attributeValue", "type": "byte[]"}, {"name": "offset", "type": "char"}, {"name": "length", "type": "char"}], "return_type": "void", "signature": "@Override\n    void decodeAttributeBody(byte[] attributeValue, char offset, char length)", "original_string": "    @Override\n    void decodeAttributeBody(byte[] attributeValue, char offset, char length)\n    {\n\n        offset += 2; //skip the 0s\n\n        //Error code\n        setErrorClass(attributeValue[offset++]);\n        setErrorNumber(attributeValue[offset++]);\n\n        //Reason Phrase\n        byte[] reasonBytes = new byte[length - 4];\n\n        System.arraycopy(attributeValue, offset, reasonBytes,\n                            0, reasonBytes.length);\n        setReasonPhrase(new String(reasonBytes));\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/ErrorCodeAttribute.java", "class_name": "ErrorCodeAttribute", "class_uri": "src/main/java/org/ice4j/attribute/ErrorCodeAttribute.java.ErrorCodeAttribute", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets this attribute's fields according to attributeValue array.\n\n@param attributeValue a binary array containing this attribute's field\n                      values and NOT containing the attribute header.\n@param offset the position where attribute values begin (most often\n                 offset is equal to the index of the first byte after\n                 length)\n@param length the length of the binary array.\n"}, {"uris": "src/main/java/org/ice4j/attribute/ReservationTokenAttribute.java.ReservationTokenAttribute.[]ReservationTokenAttribute()", "name": "ReservationTokenAttribute", "arg_nums": 0, "params": [], "return_type": "", "signature": "protected ReservationTokenAttribute ()", "original_string": "    protected ReservationTokenAttribute ()\n    {\n        super(RESERVATION_TOKEN);\n        this.reservationToken = new byte[8];\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/ReservationTokenAttribute.java", "class_name": "ReservationTokenAttribute", "class_uri": "src/main/java/org/ice4j/attribute/ReservationTokenAttribute.java.ReservationTokenAttribute", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nConstructor.\n"}, {"uris": "src/main/java/org/ice4j/attribute/ReservationTokenAttribute.java.ReservationTokenAttribute.[void]decodeAttributeBody(byte[],char,char)", "name": "decodeAttributeBody", "arg_nums": 3, "params": [{"name": "attributeValue", "type": "byte[]"}, {"name": "offset", "type": "char"}, {"name": "length", "type": "char"}], "return_type": "void", "signature": "@Override\n    void decodeAttributeBody(byte[] attributeValue, char offset, char length)", "original_string": "    @Override\n    void decodeAttributeBody(byte[] attributeValue, char offset, char length)\n        throws StunException\n    {\n        if (length != 8)\n        {\n          throw new StunException(\"Length mismatch!\");\n        }\n\n        reservationToken = new byte[8];\n        System.arraycopy(attributeValue, offset, reservationToken, 0, 8);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/ReservationTokenAttribute.java", "class_name": "ReservationTokenAttribute", "class_uri": "src/main/java/org/ice4j/attribute/ReservationTokenAttribute.java.ReservationTokenAttribute", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCopies the value of the reservationToken attribute from the specified\nattributeValue.\n@param attributeValue a binary array containing this attribute's\n  field values and NOT containing the attribute header.\n@param offset the position where attribute values begin (most often\n  offset is equal to the index of the first byte after length)\n@param length the length of the binary array.\n@throws StunException if attributeValue contains invalid reservationToken.\n"}, {"uris": "src/main/java/org/ice4j/attribute/ReservationTokenAttribute.java.ReservationTokenAttribute.[byte[]]encode()", "name": "encode", "arg_nums": 0, "params": [], "return_type": "byte[]", "signature": "@Override\n    public byte[] encode()", "original_string": "    @Override\n    public byte[] encode()\n    {\n        char type = getAttributeType();\n        byte binValue[] = new byte[HEADER_LENGTH + 8];\n\n        //Type\n        binValue[0] = (byte)(type >> 8);\n        binValue[1] = (byte)(type & 0x00FF);\n\n        //Length\n        binValue[2] = (byte)(8 >> 8);\n        binValue[3] = (byte)(8 & 0x00FF);\n\n        //reservationToken\n        System.arraycopy(reservationToken, 0, binValue, 4, 8);\n\n        return binValue;\n      }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/ReservationTokenAttribute.java", "class_name": "ReservationTokenAttribute", "class_uri": "src/main/java/org/ice4j/attribute/ReservationTokenAttribute.java.ReservationTokenAttribute", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "byte[]", "classes": []}, "docstring": "\nReturns a binary representation of this attribute.\n@return a binary representation of this attribute.\n"}, {"uris": "src/main/java/org/ice4j/attribute/ReservationTokenAttribute.java.ReservationTokenAttribute.[String]getName()", "name": "getName", "arg_nums": 0, "params": [], "return_type": "String", "signature": "@Override\n    public String getName()", "original_string": "    @Override\n    public String getName()\n    {\n        return NAME;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/ReservationTokenAttribute.java", "class_name": "ReservationTokenAttribute", "class_uri": "src/main/java/org/ice4j/attribute/ReservationTokenAttribute.java.ReservationTokenAttribute", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns the human readable name of this attribute.\n\n@return this attribute's name.\n"}, {"uris": "src/main/java/org/ice4j/attribute/ReservationTokenAttribute.java.ReservationTokenAttribute.[byte[]]getReservationToken()", "name": "getReservationToken", "arg_nums": 0, "params": [], "return_type": "byte[]", "signature": "public byte[] getReservationToken()", "original_string": "    public byte[] getReservationToken()\n    {\n        if (reservationToken == null)\n            return null;\n\n        byte[] copy = new byte[reservationToken.length];\n        System.arraycopy(reservationToken, 0, copy, 0, reservationToken.length);\n        return copy;\n      }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/ReservationTokenAttribute.java", "class_name": "ReservationTokenAttribute", "class_uri": "src/main/java/org/ice4j/attribute/ReservationTokenAttribute.java.ReservationTokenAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "byte[]", "classes": []}, "docstring": "\nReturns a (cloned) byte array containing the reservationToken value of\nthe reservationToken attribute.\n@return the binary array containing the reservationToken.\n"}, {"uris": "src/main/java/org/ice4j/attribute/ReservationTokenAttribute.java.ReservationTokenAttribute.[void]setReservationToken(byte[])", "name": "setReservationToken", "arg_nums": 1, "params": [{"name": "reservationToken", "type": "byte[]"}], "return_type": "void", "signature": "public void setReservationToken(byte[] reservationToken)", "original_string": "    public void setReservationToken(byte[] reservationToken)\n    {\n        if (reservationToken == null)\n        {\n            this.reservationToken = null;\n            return;\n        }\n\n        this.reservationToken = new byte[reservationToken.length];\n        System.arraycopy(reservationToken, 0, this.reservationToken, 0,\n                reservationToken.length);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/ReservationTokenAttribute.java", "class_name": "ReservationTokenAttribute", "class_uri": "src/main/java/org/ice4j/attribute/ReservationTokenAttribute.java.ReservationTokenAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCopies the specified binary array into the the reservationToken value of\nthe reservationToken attribute.\n@param reservationToken the binary array containing the reservationToken.\n"}, {"uris": "src/main/java/org/ice4j/attribute/ReservationTokenAttribute.java.ReservationTokenAttribute.[char]getDataLength()", "name": "getDataLength", "arg_nums": 0, "params": [], "return_type": "char", "signature": "@Override\n    public char getDataLength()", "original_string": "    @Override\n    public char getDataLength()\n    {\n        return (char)reservationToken.length;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/ReservationTokenAttribute.java", "class_name": "ReservationTokenAttribute", "class_uri": "src/main/java/org/ice4j/attribute/ReservationTokenAttribute.java.ReservationTokenAttribute", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "char", "classes": []}, "docstring": "\nReturns the length of this attribute's body.\n@return the length of this attribute's value.\n"}, {"uris": "src/main/java/org/ice4j/attribute/ReservationTokenAttribute.java.ReservationTokenAttribute.[ReservationTokenAttribute]createNewReservationTokenAttribute()", "name": "createNewReservationTokenAttribute", "arg_nums": 0, "params": [], "return_type": "ReservationTokenAttribute", "signature": "public static ReservationTokenAttribute createNewReservationTokenAttribute()", "original_string": "    public static ReservationTokenAttribute createNewReservationTokenAttribute()\n    {\n        ReservationTokenAttribute token = new ReservationTokenAttribute();\n\n        generateReservationTokenAttribute(token, 8);\n        return token;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/ReservationTokenAttribute.java", "class_name": "ReservationTokenAttribute", "class_uri": "src/main/java/org/ice4j/attribute/ReservationTokenAttribute.java.ReservationTokenAttribute", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "ReservationTokenAttribute", "classes": []}, "docstring": "\nCreates a Reservation Token object.The Reservation Token itself is\ngenerated using the following algorithm:\n\nThe first 6 bytes of the id are given the value of\n<tt>System.currentTimeMillis()</tt>. Putting the right most bits first so\nthat we get a more optimized equals() method.\n\n@return A <tt>Reservation Token </tt>object with a unique token value.\n"}, {"uris": "src/main/java/org/ice4j/attribute/ReservationTokenAttribute.java.ReservationTokenAttribute.[void]generateReservationTokenAttribute(ReservationTokenAttribute,int)", "name": "generateReservationTokenAttribute", "arg_nums": 2, "params": [{"name": "token", "type": "ReservationTokenAttribute"}, {"name": "nb", "type": "int"}], "return_type": "void", "signature": "private static void generateReservationTokenAttribute(\n        ReservationTokenAttribute token, int nb)", "original_string": "    private static void generateReservationTokenAttribute(\n        ReservationTokenAttribute token, int nb)\n    {\n        long left = System.currentTimeMillis(); // the first nb/2 bytes of the\n                                               // token\n        long right = random.nextLong(); // the last nb/2 bytes of the token\n        int b = nb / 2;\n\n        for (int i = 0; i < b; i++)\n        {\n            token.reservationToken[i]   = (byte)((left  >> (i * 8)) & 0xFFL);\n            token.reservationToken[i + b] = (byte)((right >> (i * 8)) & 0xFFL);\n        }\n\n        //calculate hashcode for Hashtable storage.\n        token.hashCode =   (token.reservationToken[3] << 24 & 0xFF000000)\n                       | (token.reservationToken[2] << 16 & 0x00FF0000)\n                       | (token.reservationToken[1] << 8  & 0x0000FF00)\n                       | (token.reservationToken[0]       & 0x000000FF);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/ReservationTokenAttribute.java", "class_name": "ReservationTokenAttribute", "class_uri": "src/main/java/org/ice4j/attribute/ReservationTokenAttribute.java.ReservationTokenAttribute", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nGenerates a random ReservationTokenAttribute\n\n@param token ReservationTokenAttribute\n@param nb number of bytes to generate\n"}, {"uris": "src/main/java/org/ice4j/attribute/ReservationTokenAttribute.java.ReservationTokenAttribute.[boolean]equals(Object)", "name": "equals", "arg_nums": 1, "params": [{"name": "obj", "type": "Object"}], "return_type": "boolean", "signature": "@Override\n    public boolean equals(Object obj)", "original_string": "    @Override\n    public boolean equals(Object obj)\n    {\n        if (! (obj instanceof ReservationTokenAttribute))\n            return false;\n\n        if (obj == this)\n            return true;\n\n        ReservationTokenAttribute att = (ReservationTokenAttribute) obj;\n        if (att.getAttributeType() != getAttributeType()\n            || att.getDataLength() != getDataLength()\n            || !Arrays.equals( att.reservationToken, reservationToken))\n            return false;\n\n        return true;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/ReservationTokenAttribute.java", "class_name": "ReservationTokenAttribute", "class_uri": "src/main/java/org/ice4j/attribute/ReservationTokenAttribute.java.ReservationTokenAttribute", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nCompares two STUN Attributes. Two attributes are considered equal when\nthey have the same type length and value.\n@param obj the object to compare this attribute with.\n@return true if the attributes are equal and false otherwise.\n"}, {"uris": "src/main/java/org/ice4j/attribute/ReservationTokenAttribute.java.ReservationTokenAttribute.[String]toString()", "name": "toString", "arg_nums": 0, "params": [], "return_type": "String", "signature": "@Override\n    public String toString()", "original_string": "    @Override\n    public String toString()\n    {\n        return ReservationTokenAttribute.toString(this.reservationToken);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/ReservationTokenAttribute.java", "class_name": "ReservationTokenAttribute", "class_uri": "src/main/java/org/ice4j/attribute/ReservationTokenAttribute.java.ReservationTokenAttribute", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns a string representation of the token.\n\n@return a hex string representing the token.\n"}, {"uris": "src/main/java/org/ice4j/attribute/ReservationTokenAttribute.java.ReservationTokenAttribute.[String]toString(byte[])", "name": "toString", "arg_nums": 1, "params": [{"name": "reservationToken", "type": "byte[]"}], "return_type": "String", "signature": "public static String toString(byte[] reservationToken)", "original_string": "    public static String toString(byte[] reservationToken)\n    {\n        StringBuilder idStr = new StringBuilder();\n\n        idStr.append(\"0x\");\n        for (int i = 0; i < reservationToken.length; i++)\n        {\n            if ((reservationToken[i] & 0xFF) <= 15)\n                idStr.append(\"0\");\n\n            idStr.append(Integer.toHexString(\n                reservationToken[i] & 0xFF).toUpperCase());\n        }\n        return idStr.toString();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/ReservationTokenAttribute.java", "class_name": "ReservationTokenAttribute", "class_uri": "src/main/java/org/ice4j/attribute/ReservationTokenAttribute.java.ReservationTokenAttribute", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns a string representation of the token.\n\n@param reservationToken the Reservation Token to convert into\n           <tt>String</tt>.\n\n@return a hex string representing the token.\n"}, {"uris": "src/main/java/org/ice4j/attribute/ReservationTokenAttribute.java.ReservationTokenAttribute.[int]hashCode()", "name": "hashCode", "arg_nums": 0, "params": [], "return_type": "int", "signature": "@Override\n    public int hashCode()", "original_string": "    @Override\n    public int hashCode()\n    {\n        return this.hashCode;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/ReservationTokenAttribute.java", "class_name": "ReservationTokenAttribute", "class_uri": "src/main/java/org/ice4j/attribute/ReservationTokenAttribute.java.ReservationTokenAttribute", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\nReturns the hash code of this Reservation-Token.\n"}, {"uris": "src/main/java/org/ice4j/attribute/RealmAttribute.java.RealmAttribute.[]RealmAttribute()", "name": "RealmAttribute", "arg_nums": 0, "params": [], "return_type": "", "signature": "RealmAttribute()", "original_string": "    RealmAttribute()\n    {\n        super(REALM);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/RealmAttribute.java", "class_name": "RealmAttribute", "class_uri": "src/main/java/org/ice4j/attribute/RealmAttribute.java.RealmAttribute", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "docstring": "\nConstructor.\n"}, {"uris": "src/main/java/org/ice4j/attribute/RealmAttribute.java.RealmAttribute.[void]decodeAttributeBody(byte[],char,char)", "name": "decodeAttributeBody", "arg_nums": 3, "params": [{"name": "attributeValue", "type": "byte[]"}, {"name": "offset", "type": "char"}, {"name": "length", "type": "char"}], "return_type": "void", "signature": "void decodeAttributeBody(byte[] attributeValue, char offset, char length)", "original_string": "    void decodeAttributeBody(byte[] attributeValue, char offset, char length)\n        throws StunException\n    {\n        realm = new byte[length];\n        System.arraycopy(attributeValue, offset, realm, 0, length);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/RealmAttribute.java", "class_name": "RealmAttribute", "class_uri": "src/main/java/org/ice4j/attribute/RealmAttribute.java.RealmAttribute", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCopies the value of the realm attribute from the specified\nattributeValue.\n@param attributeValue a binary array containing this attribute's\n  field values and NOT containing the attribute header.\n@param offset the position where attribute values begin (most often\n  offset is equal to the index of the first byte after length)\n@param length the length of the binary array.\n@throws StunException if attributeValue contains invalid data.\n"}, {"uris": "src/main/java/org/ice4j/attribute/RealmAttribute.java.RealmAttribute.[byte[]]encode()", "name": "encode", "arg_nums": 0, "params": [], "return_type": "byte[]", "signature": "public byte[] encode()", "original_string": "    public byte[] encode()\n    {\n        char type = getAttributeType();\n        byte binValue[] = new byte[HEADER_LENGTH + getDataLength() +\n                                   (getDataLength() % 4)];\n\n        //Type\n        binValue[0] = (byte)(type >> 8);\n        binValue[1] = (byte)(type & 0x00FF);\n\n        //Length\n        binValue[2] = (byte)(getDataLength() >> 8);\n        binValue[3] = (byte)(getDataLength() & 0x00FF);\n\n        /* realm */\n        System.arraycopy(realm, 0, binValue, 4, getDataLength());\n\n        return binValue;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/RealmAttribute.java", "class_name": "RealmAttribute", "class_uri": "src/main/java/org/ice4j/attribute/RealmAttribute.java.RealmAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "byte[]", "classes": []}, "docstring": "\nReturns a binary representation of this attribute.\n@return a binary representation of this attribute.\n"}, {"uris": "src/main/java/org/ice4j/attribute/RealmAttribute.java.RealmAttribute.[char]getDataLength()", "name": "getDataLength", "arg_nums": 0, "params": [], "return_type": "char", "signature": "public char getDataLength()", "original_string": "    public char getDataLength()\n    {\n        return (char)realm.length;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/RealmAttribute.java", "class_name": "RealmAttribute", "class_uri": "src/main/java/org/ice4j/attribute/RealmAttribute.java.RealmAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "char", "classes": []}, "docstring": "\nReturns the length of this attribute's body.\n@return the length of this attribute's value.\n"}, {"uris": "src/main/java/org/ice4j/attribute/RealmAttribute.java.RealmAttribute.[String]getName()", "name": "getName", "arg_nums": 0, "params": [], "return_type": "String", "signature": "public String getName()", "original_string": "    public String getName()\n    {\n        return NAME;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/RealmAttribute.java", "class_name": "RealmAttribute", "class_uri": "src/main/java/org/ice4j/attribute/RealmAttribute.java.RealmAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns the human readable name of this attribute.\n@return this attribute's name.\n"}, {"uris": "src/main/java/org/ice4j/attribute/RealmAttribute.java.RealmAttribute.[byte[]]getRealm()", "name": "getRealm", "arg_nums": 0, "params": [], "return_type": "byte[]", "signature": "public byte[] getRealm()", "original_string": "    public byte[] getRealm()\n    {\n        return (realm == null) ? null : realm.clone();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/RealmAttribute.java", "class_name": "RealmAttribute", "class_uri": "src/main/java/org/ice4j/attribute/RealmAttribute.java.RealmAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "byte[]", "classes": []}, "docstring": "\nReturns a (cloned) byte array containing the data value of the realm\nattribute.\n@return the binary array containing the realm.\n"}, {"uris": "src/main/java/org/ice4j/attribute/RealmAttribute.java.RealmAttribute.[void]setRealm(byte[])", "name": "setRealm", "arg_nums": 1, "params": [{"name": "realm", "type": "byte[]"}], "return_type": "void", "signature": "public void setRealm(byte[] realm)", "original_string": "    public void setRealm(byte[] realm)\n    {\n        if (realm == null)\n        {\n            this.realm = null;\n            return;\n        }\n\n        this.realm = new byte[realm.length];\n        System.arraycopy(realm, 0, this.realm, 0, realm.length);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/RealmAttribute.java", "class_name": "RealmAttribute", "class_uri": "src/main/java/org/ice4j/attribute/RealmAttribute.java.RealmAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCopies the specified binary array into the the data value of the realm\nattribute.\n@param realm the binary array containing the realm.\n"}, {"uris": "src/main/java/org/ice4j/attribute/RealmAttribute.java.RealmAttribute.[boolean]equals(Object)", "name": "equals", "arg_nums": 1, "params": [{"name": "obj", "type": "Object"}], "return_type": "boolean", "signature": "public boolean equals(Object obj)", "original_string": "    public boolean equals(Object obj)\n    {\n        if (! (obj instanceof RealmAttribute))\n            return false;\n\n        if (obj == this)\n            return true;\n\n        RealmAttribute att = (RealmAttribute) obj;\n        if (att.getAttributeType() != getAttributeType()\n                || att.getDataLength() != getDataLength()\n                || !Arrays.equals( att.realm, realm))\n            return false;\n\n        return true;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/RealmAttribute.java", "class_name": "RealmAttribute", "class_uri": "src/main/java/org/ice4j/attribute/RealmAttribute.java.RealmAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nCompares two STUN Attributes. Two attributes are considered equal when they\nhave the same type length and value.\n@param obj the object to compare this attribute with.\n@return true if the attributes are equal and false otherwise.\n"}, {"uris": "src/main/java/org/ice4j/attribute/EvenPortAttribute.java.EvenPortAttribute.[]EvenPortAttribute()", "name": "EvenPortAttribute", "arg_nums": 0, "params": [], "return_type": "", "signature": "EvenPortAttribute()", "original_string": "    EvenPortAttribute()\n    {\n        super(EVEN_PORT);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/EvenPortAttribute.java", "class_name": "EvenPortAttribute", "class_uri": "src/main/java/org/ice4j/attribute/EvenPortAttribute.java.EvenPortAttribute", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "docstring": "\nConstructor.\n"}, {"uris": "src/main/java/org/ice4j/attribute/EvenPortAttribute.java.EvenPortAttribute.[boolean]equals(Object)", "name": "equals", "arg_nums": 1, "params": [{"name": "obj", "type": "Object"}], "return_type": "boolean", "signature": "public boolean equals(Object obj)", "original_string": "    public boolean equals(Object obj)\n    {\n        if (! (obj instanceof EvenPortAttribute))\n            return false;\n\n        if (obj == this)\n            return true;\n\n        EvenPortAttribute att = (EvenPortAttribute) obj;\n        if (att.getAttributeType() != getAttributeType()\n                || att.getDataLength() != getDataLength()\n                /* compare data */\n                || att.rFlag != rFlag\n           )\n            return false;\n\n        return true;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/EvenPortAttribute.java", "class_name": "EvenPortAttribute", "class_uri": "src/main/java/org/ice4j/attribute/EvenPortAttribute.java.EvenPortAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nCompares two STUN Attributes. Attributes are considered equal when their\ntype, length, and all data are the same.\n@param obj the object to compare this attribute with.\n@return true if the attributes are equal and false otherwise.\n"}, {"uris": "src/main/java/org/ice4j/attribute/EvenPortAttribute.java.EvenPortAttribute.[String]getName()", "name": "getName", "arg_nums": 0, "params": [], "return_type": "String", "signature": "public String getName()", "original_string": "    public String getName()\n    {\n        return NAME;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/EvenPortAttribute.java", "class_name": "EvenPortAttribute", "class_uri": "src/main/java/org/ice4j/attribute/EvenPortAttribute.java.EvenPortAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns the human readable name of this attribute. Attribute names do\nnot really matter from the protocol point of view. They are only used\nfor debugging and readability.\n@return this attribute's name.\n"}, {"uris": "src/main/java/org/ice4j/attribute/EvenPortAttribute.java.EvenPortAttribute.[char]getDataLength()", "name": "getDataLength", "arg_nums": 0, "params": [], "return_type": "char", "signature": "public char getDataLength()", "original_string": "    public char getDataLength()\n    {\n        return DATA_LENGTH;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/EvenPortAttribute.java", "class_name": "EvenPortAttribute", "class_uri": "src/main/java/org/ice4j/attribute/EvenPortAttribute.java.EvenPortAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "char", "classes": []}, "docstring": "\nReturns the length of this attribute's body.\n@return the length of this attribute's value (8 bytes).\n"}, {"uris": "src/main/java/org/ice4j/attribute/EvenPortAttribute.java.EvenPortAttribute.[byte[]]encode()", "name": "encode", "arg_nums": 0, "params": [], "return_type": "byte[]", "signature": "public byte[] encode()", "original_string": "    public byte[] encode()\n    {\n        byte binValue[] = new byte[HEADER_LENGTH + DATA_LENGTH];\n\n        //Type\n        binValue[0] = (byte)(getAttributeType() >> 8);\n        binValue[1] = (byte)(getAttributeType() & 0x00FF);\n        //Length\n        binValue[2] = (byte)(getDataLength() >> 8);\n        binValue[3] = (byte)(getDataLength() & 0x00FF);\n        //Data\n        binValue[4] = (byte)(rFlag ? 1 << 8 : 0);\n\n        return binValue;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/EvenPortAttribute.java", "class_name": "EvenPortAttribute", "class_uri": "src/main/java/org/ice4j/attribute/EvenPortAttribute.java.EvenPortAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "byte[]", "classes": []}, "docstring": "\nReturns a binary representation of this attribute.\n@return a binary representation of this attribute.\n"}, {"uris": "src/main/java/org/ice4j/attribute/EvenPortAttribute.java.EvenPortAttribute.[void]decodeAttributeBody(byte[],char,char)", "name": "decodeAttributeBody", "arg_nums": 3, "params": [{"name": "attributeValue", "type": "byte[]"}, {"name": "offset", "type": "char"}, {"name": "length", "type": "char"}], "return_type": "void", "signature": "void decodeAttributeBody(byte[] attributeValue, char offset, char length)", "original_string": "    void decodeAttributeBody(byte[] attributeValue, char offset, char length)\n        throws StunException\n    {\n        if (length != 4)\n        {\n            throw new StunException(\"length invalid\");\n        }\n\n        rFlag = (attributeValue[0] & 0x80) > 0;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/EvenPortAttribute.java", "class_name": "EvenPortAttribute", "class_uri": "src/main/java/org/ice4j/attribute/EvenPortAttribute.java.EvenPortAttribute", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets this attribute's fields according to attributeValue array.\n@param attributeValue a binary array containing this attribute's field\n                      values and NOT containing the attribute header.\n@param offset the position where attribute values begin (most often\n         offset is equal to the index of the first byte after\n         length)\n@param length the length of the binary array.\n@throws StunException if attrubteValue contains invalid data.\n"}, {"uris": "src/main/java/org/ice4j/attribute/EvenPortAttribute.java.EvenPortAttribute.[void]setRFlag(boolean)", "name": "setRFlag", "arg_nums": 1, "params": [{"name": "rFlag", "type": "boolean"}], "return_type": "void", "signature": "public void setRFlag(boolean rFlag)", "original_string": "    public void setRFlag(boolean rFlag)\n    {\n        this.rFlag = rFlag;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/EvenPortAttribute.java", "class_name": "EvenPortAttribute", "class_uri": "src/main/java/org/ice4j/attribute/EvenPortAttribute.java.EvenPortAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSet the R flag.\n@param rFlag true of false\n"}, {"uris": "src/main/java/org/ice4j/attribute/EvenPortAttribute.java.EvenPortAttribute.[boolean]isRFlag()", "name": "isRFlag", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "public boolean isRFlag()", "original_string": "    public boolean isRFlag()\n    {\n        return rFlag;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/EvenPortAttribute.java", "class_name": "EvenPortAttribute", "class_uri": "src/main/java/org/ice4j/attribute/EvenPortAttribute.java.EvenPortAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nIs the R flag set\n@return true if it is, false otherwise\n"}, {"uris": "src/main/java/org/ice4j/attribute/ChangeRequestAttribute.java.ChangeRequestAttribute.[]ChangeRequestAttribute()", "name": "ChangeRequestAttribute", "arg_nums": 0, "params": [], "return_type": "", "signature": "ChangeRequestAttribute()", "original_string": "    ChangeRequestAttribute()\n    {\n        super(CHANGE_REQUEST);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/ChangeRequestAttribute.java", "class_name": "ChangeRequestAttribute", "class_uri": "src/main/java/org/ice4j/attribute/ChangeRequestAttribute.java.ChangeRequestAttribute", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "docstring": "\nCreates an empty ChangeRequestAttribute.\n"}, {"uris": "src/main/java/org/ice4j/attribute/ChangeRequestAttribute.java.ChangeRequestAttribute.[String]getName()", "name": "getName", "arg_nums": 0, "params": [], "return_type": "String", "signature": "public String getName()", "original_string": "    public String getName()\n    {\n        return NAME;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/ChangeRequestAttribute.java", "class_name": "ChangeRequestAttribute", "class_uri": "src/main/java/org/ice4j/attribute/ChangeRequestAttribute.java.ChangeRequestAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns the human readable name of this attribute. Attribute names do\nnot really matter from the protocol point of view. They are only used\nfor debugging and readability.\n@return this attribute's name.\n"}, {"uris": "src/main/java/org/ice4j/attribute/ChangeRequestAttribute.java.ChangeRequestAttribute.[boolean]equals(Object)", "name": "equals", "arg_nums": 1, "params": [{"name": "obj", "type": "Object"}], "return_type": "boolean", "signature": "public boolean equals(Object obj)", "original_string": "     public boolean equals(Object obj)\n     {\n         if (! (obj instanceof ChangeRequestAttribute))\n             return false;\n\n         if (obj == this)\n             return true;\n\n         ChangeRequestAttribute att = (ChangeRequestAttribute) obj;\n         if (att.getAttributeType()   != getAttributeType()\n             || att.getDataLength()   != getDataLength()\n             //compare data\n             || att.getChangeIpFlag() != getChangeIpFlag()\n             || att.getChangePortFlag()       != getChangePortFlag()\n             )\n             return false;\n\n         return true;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/ChangeRequestAttribute.java", "class_name": "ChangeRequestAttribute", "class_uri": "src/main/java/org/ice4j/attribute/ChangeRequestAttribute.java.ChangeRequestAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nCompares two STUN Attributes. Attributes are considered equal when their\ntype, length, and all data are the same.\n\n@param obj the object to compare this attribute with.\n@return true if the attributes are equal and false otherwise.\n"}, {"uris": "src/main/java/org/ice4j/attribute/ChangeRequestAttribute.java.ChangeRequestAttribute.[char]getDataLength()", "name": "getDataLength", "arg_nums": 0, "params": [], "return_type": "char", "signature": "public char getDataLength()", "original_string": "    public char getDataLength()\n    {\n        return DATA_LENGTH;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/ChangeRequestAttribute.java", "class_name": "ChangeRequestAttribute", "class_uri": "src/main/java/org/ice4j/attribute/ChangeRequestAttribute.java.ChangeRequestAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "char", "classes": []}, "docstring": "\nReturns the length of this attribute's body.\n@return the length of this attribute's value (8 bytes).\n"}, {"uris": "src/main/java/org/ice4j/attribute/ChangeRequestAttribute.java.ChangeRequestAttribute.[byte[]]encode()", "name": "encode", "arg_nums": 0, "params": [], "return_type": "byte[]", "signature": "public byte[] encode()", "original_string": "    public byte[] encode()\n    {\n        byte binValue[] = new byte[HEADER_LENGTH + DATA_LENGTH];\n\n        //Type\n        binValue[0] = (byte)(getAttributeType() >> 8);\n        binValue[1] = (byte)(getAttributeType() & 0x00FF);\n        //Length\n        binValue[2] = (byte)(getDataLength() >> 8);\n        binValue[3] = (byte)(getDataLength() & 0x00FF);\n        //Data\n        binValue[4] = 0x00;\n        binValue[5] = 0x00;\n        binValue[6] = 0x00;\n        binValue[7] = (byte)((getChangeIpFlag() ? 4 : 0) +\n                (getChangePortFlag() ? 2 : 0));\n\n        return binValue;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/ChangeRequestAttribute.java", "class_name": "ChangeRequestAttribute", "class_uri": "src/main/java/org/ice4j/attribute/ChangeRequestAttribute.java.ChangeRequestAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "byte[]", "classes": []}, "docstring": "\nReturns a binary representation of this attribute.\n@return a binary representation of this attribute.\n"}, {"uris": "src/main/java/org/ice4j/attribute/ChangeRequestAttribute.java.ChangeRequestAttribute.[void]setChangeIpFlag(boolean)", "name": "setChangeIpFlag", "arg_nums": 1, "params": [{"name": "changeIP", "type": "boolean"}], "return_type": "void", "signature": "public void setChangeIpFlag(boolean changeIP)", "original_string": "    public void setChangeIpFlag(boolean changeIP)\n    {\n        this.changeIpFlag = changeIP;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/ChangeRequestAttribute.java", "class_name": "ChangeRequestAttribute", "class_uri": "src/main/java/org/ice4j/attribute/ChangeRequestAttribute.java.ChangeRequestAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets the value of the changeIpFlag. The \"change IP\" flag,  if true,\nrequests the server to send the Binding Response with a different IP\naddress than the one the Binding Request was received on.\n\n@param changeIP the new value of the changeIpFlag.\n"}, {"uris": "src/main/java/org/ice4j/attribute/ChangeRequestAttribute.java.ChangeRequestAttribute.[boolean]getChangeIpFlag()", "name": "getChangeIpFlag", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "public boolean getChangeIpFlag()", "original_string": "    public boolean getChangeIpFlag()\n    {\n        return changeIpFlag;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/ChangeRequestAttribute.java", "class_name": "ChangeRequestAttribute", "class_uri": "src/main/java/org/ice4j/attribute/ChangeRequestAttribute.java.ChangeRequestAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nReturns the value of the changeIpFlag. The \"change IP\" flag,  if true,\nrequests the server to send the Binding Response with a different IP\naddress than the one the Binding Request was received on.\n\n@return the value of the changeIpFlag.\n"}, {"uris": "src/main/java/org/ice4j/attribute/ChangeRequestAttribute.java.ChangeRequestAttribute.[void]setChangePortFlag(boolean)", "name": "setChangePortFlag", "arg_nums": 1, "params": [{"name": "changePort", "type": "boolean"}], "return_type": "void", "signature": "public void setChangePortFlag(boolean changePort)", "original_string": "    public void setChangePortFlag(boolean changePort)\n    {\n        this.changePortFlag = changePort;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/ChangeRequestAttribute.java", "class_name": "ChangeRequestAttribute", "class_uri": "src/main/java/org/ice4j/attribute/ChangeRequestAttribute.java.ChangeRequestAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets the value of the changePortFlag. The \"change port\" flag.  If true,\nrequests the server to send the Binding Response with a different port\nthan the one the Binding Request was received on.\n\n@param changePort the new value of the changePort flag.\n"}, {"uris": "src/main/java/org/ice4j/attribute/ChangeRequestAttribute.java.ChangeRequestAttribute.[boolean]getChangePortFlag()", "name": "getChangePortFlag", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "public boolean getChangePortFlag()", "original_string": "    public boolean getChangePortFlag()\n    {\n        return changePortFlag;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/ChangeRequestAttribute.java", "class_name": "ChangeRequestAttribute", "class_uri": "src/main/java/org/ice4j/attribute/ChangeRequestAttribute.java.ChangeRequestAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nReturns the value of the changePortFlag. The \"change port\" flag. If true,\nrequests the server to send the Binding Response with a different port\nthan the one the Binding Request was received on.\n\n@return the value of the changePort flag.\n"}, {"uris": "src/main/java/org/ice4j/attribute/ChangeRequestAttribute.java.ChangeRequestAttribute.[void]decodeAttributeBody(byte[],char,char)", "name": "decodeAttributeBody", "arg_nums": 3, "params": [{"name": "attributeValue", "type": "byte[]"}, {"name": "offset", "type": "char"}, {"name": "length", "type": "char"}], "return_type": "void", "signature": "void decodeAttributeBody(byte[] attributeValue, char offset, char length)", "original_string": "     void decodeAttributeBody(byte[] attributeValue, char offset, char length)\n         throws StunException\n     {\n         offset += 3; // first three bytes of change req att are not used\n         setChangeIpFlag((attributeValue[offset] & 4) > 0);\n         setChangePortFlag((attributeValue[offset] & 0x2) > 0);\n     }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/ChangeRequestAttribute.java", "class_name": "ChangeRequestAttribute", "class_uri": "src/main/java/org/ice4j/attribute/ChangeRequestAttribute.java.ChangeRequestAttribute", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets this attribute's fields according to attributeValue array.\n\n@param attributeValue a binary array containing this attribute's field\n                      values and NOT containing the attribute header.\n@param offset the position where attribute values begin (most often\n                 offset is equal to the index of the first byte after\n                 length)\n@param length the length of the binary array.\n@throws StunException if attrubteValue contains invalid data.\n"}, {"uris": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[ChangeRequestAttribute]createChangeRequestAttribute()", "name": "createChangeRequestAttribute", "arg_nums": 0, "params": [], "return_type": "ChangeRequestAttribute", "signature": "public static ChangeRequestAttribute createChangeRequestAttribute()", "original_string": "    public static ChangeRequestAttribute createChangeRequestAttribute()\n    {\n        return createChangeRequestAttribute(false, false);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/AttributeFactory.java", "class_name": "AttributeFactory", "class_uri": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "ChangeRequestAttribute", "classes": []}, "docstring": "\nCreates a ChangeRequestAttribute with \"false\" values for the changeIP and\nchangePort flags.\n\n@return the newly created ChangeRequestAttribute.\n"}, {"uris": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[ChangeRequestAttribute]createChangeRequestAttribute(boolean,boolean)", "name": "createChangeRequestAttribute", "arg_nums": 2, "params": [{"name": "changeIP", "type": "boolean"}, {"name": "changePort", "type": "boolean"}], "return_type": "ChangeRequestAttribute", "signature": "public static ChangeRequestAttribute createChangeRequestAttribute(\n                    boolean changeIP, boolean changePort)", "original_string": "    public static ChangeRequestAttribute createChangeRequestAttribute(\n                    boolean changeIP, boolean changePort)\n    {\n        ChangeRequestAttribute attribute = new ChangeRequestAttribute();\n\n        attribute.setChangeIpFlag(changeIP);\n        attribute.setChangePortFlag(changePort);\n\n        return attribute;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/AttributeFactory.java", "class_name": "AttributeFactory", "class_uri": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "ChangeRequestAttribute", "classes": []}, "docstring": "\nCreates a ChangeRequestAttribute with the specified flag values.\n\n@param changeIP the value of the changeIP flag.\n@param changePort the value of the changePort flag.\n@return the newly created ChangeRequestAttribute.\n"}, {"uris": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[ChangedAddressAttribute]createChangedAddressAttribute(TransportAddress)", "name": "createChangedAddressAttribute", "arg_nums": 1, "params": [{"name": "address", "type": "TransportAddress"}], "return_type": "ChangedAddressAttribute", "signature": "public static ChangedAddressAttribute createChangedAddressAttribute(\n                    TransportAddress address)", "original_string": "    public static ChangedAddressAttribute createChangedAddressAttribute(\n                    TransportAddress address)\n    {\n        ChangedAddressAttribute attribute = new ChangedAddressAttribute();\n\n        attribute.setAddress(address);\n\n        return attribute;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/AttributeFactory.java", "class_name": "AttributeFactory", "class_uri": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "ChangedAddressAttribute", "classes": []}, "docstring": "\nCreates a changedAddressAttribute of the specified type and with the\nspecified address and port\n\n@param address the address value of the address attribute\n@return the newly created address attribute.\n"}, {"uris": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[ErrorCodeAttribute]createErrorCodeAttribute(byte,byte)", "name": "createErrorCodeAttribute", "arg_nums": 2, "params": [{"name": "errorClass", "type": "byte"}, {"name": "errorNumber", "type": "byte"}], "return_type": "ErrorCodeAttribute", "signature": "public static ErrorCodeAttribute createErrorCodeAttribute(byte errorClass,\n                    byte errorNumber)", "original_string": "    public static ErrorCodeAttribute createErrorCodeAttribute(byte errorClass,\n                    byte errorNumber)\n        throws StunException\n    {\n        return createErrorCodeAttribute(errorClass, errorNumber, null);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/AttributeFactory.java", "class_name": "AttributeFactory", "class_uri": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "ErrorCodeAttribute", "classes": []}, "docstring": "\nCreates an ErrorCodeAttribute with the specified error class and number\nand a default reason phrase.\n\n@param errorClass a valid error class.\n@param errorNumber a valid error number.\n@return the newly created attribute.\n@throws StunException if the error class or number have invalid values\naccording to rfc3489.\n"}, {"uris": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[ErrorCodeAttribute]createErrorCodeAttribute(byte,byte,String)", "name": "createErrorCodeAttribute", "arg_nums": 3, "params": [{"name": "errorClass", "type": "byte"}, {"name": "errorNumber", "type": "byte"}, {"name": "reasonPhrase", "type": "String"}], "return_type": "ErrorCodeAttribute", "signature": "public static ErrorCodeAttribute createErrorCodeAttribute(\n                                                        byte errorClass,\n                                                        byte errorNumber,\n                                                        String reasonPhrase)", "original_string": "    public static ErrorCodeAttribute createErrorCodeAttribute(\n                                                        byte errorClass,\n                                                        byte errorNumber,\n                                                        String reasonPhrase)\n        throws StunException\n    {\n        ErrorCodeAttribute attribute = new ErrorCodeAttribute();\n\n        attribute.setErrorClass(errorClass);\n        attribute.setErrorNumber(errorNumber);\n\n        attribute.setReasonPhrase(reasonPhrase == null ? ErrorCodeAttribute\n                        .getDefaultReasonPhrase(attribute.getErrorCode())\n                        : reasonPhrase);\n\n        return attribute;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/AttributeFactory.java", "class_name": "AttributeFactory", "class_uri": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "ErrorCodeAttribute", "classes": []}, "docstring": "\nCreates an ErrorCodeAttribute with the specified error class, number and\nreason phrase.\n\n@param errorClass a valid error class.\n@param errorNumber a valid error number.\n@param reasonPhrase a human readable reason phrase. A null reason phrase\nwould be replaced (if possible) by a default one as defined byte the\nrfc3489.\n@return the newly created attribute.\n@throws StunException if the error class or number have invalid values\naccording to rfc3489.\n"}, {"uris": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[ErrorCodeAttribute]createErrorCodeAttribute(char)", "name": "createErrorCodeAttribute", "arg_nums": 1, "params": [{"name": "errorCode", "type": "char"}], "return_type": "ErrorCodeAttribute", "signature": "public static ErrorCodeAttribute createErrorCodeAttribute(char errorCode)", "original_string": "    public static ErrorCodeAttribute createErrorCodeAttribute(char errorCode)\n                    throws StunException\n    {\n        return createErrorCodeAttribute(errorCode, null);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/AttributeFactory.java", "class_name": "AttributeFactory", "class_uri": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "ErrorCodeAttribute", "classes": []}, "docstring": "\nCreates an ErrorCodeAttribute with the specified error code and a default\nreason phrase.\n\n@param errorCode a valid error code.\n@return the newly created attribute.\n@throws StunException if errorCode is not a valid error code as defined\nby rfc3489\n"}, {"uris": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[ErrorCodeAttribute]createErrorCodeAttribute(char,String)", "name": "createErrorCodeAttribute", "arg_nums": 2, "params": [{"name": "errorCode", "type": "char"}, {"name": "reasonPhrase", "type": "String"}], "return_type": "ErrorCodeAttribute", "signature": "public static ErrorCodeAttribute createErrorCodeAttribute(\n                                                          char errorCode,\n                                                          String reasonPhrase)", "original_string": "    public static ErrorCodeAttribute createErrorCodeAttribute(\n                                                          char errorCode,\n                                                          String reasonPhrase)\n        throws IllegalArgumentException\n    {\n        ErrorCodeAttribute attribute = new ErrorCodeAttribute();\n\n        attribute.setErrorCode(errorCode);\n        attribute.setReasonPhrase(reasonPhrase == null ? ErrorCodeAttribute\n                        .getDefaultReasonPhrase(attribute.getErrorCode())\n                        : reasonPhrase);\n\n        return attribute;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/AttributeFactory.java", "class_name": "AttributeFactory", "class_uri": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "ErrorCodeAttribute", "classes": []}, "docstring": "\nCreates an ErrorCodeAttribute with the specified error code and reason\nphrase.\n\n@param errorCode a valid error code.\n@param reasonPhrase a human readable reason phrase. A null reason phrase\nwould be replaced (if possible) by a default one as defined byte the\nrfc3489.\n\n@return the newly created attribute.\n@throws IllegalArgumentException if errorCode is not a valid error code\nas defined by rfc3489\n"}, {"uris": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[MappedAddressAttribute]createMappedAddressAttribute(TransportAddress)", "name": "createMappedAddressAttribute", "arg_nums": 1, "params": [{"name": "address", "type": "TransportAddress"}], "return_type": "MappedAddressAttribute", "signature": "public static MappedAddressAttribute createMappedAddressAttribute(\n                    TransportAddress address)", "original_string": "    public static MappedAddressAttribute createMappedAddressAttribute(\n                    TransportAddress address)\n    {\n        MappedAddressAttribute attribute = new MappedAddressAttribute();\n\n        attribute.setAddress(address);\n\n        return attribute;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/AttributeFactory.java", "class_name": "AttributeFactory", "class_uri": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "MappedAddressAttribute", "classes": []}, "docstring": "\nCreates a MappedAddressAttribute of the specified type and with the\nspecified address and port\n\n@param address the address value of the address attribute\n@return the newly created address attribute.\n"}, {"uris": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[ReflectedFromAttribute]createReflectedFromAttribute(TransportAddress)", "name": "createReflectedFromAttribute", "arg_nums": 1, "params": [{"name": "address", "type": "TransportAddress"}], "return_type": "ReflectedFromAttribute", "signature": "public static ReflectedFromAttribute createReflectedFromAttribute(\n                    TransportAddress address)", "original_string": "    public static ReflectedFromAttribute createReflectedFromAttribute(\n                    TransportAddress address)\n    {\n        ReflectedFromAttribute attribute = new ReflectedFromAttribute();\n\n        attribute.setAddress(address);\n\n        return attribute;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/AttributeFactory.java", "class_name": "AttributeFactory", "class_uri": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "ReflectedFromAttribute", "classes": []}, "docstring": "\nCreates a ReflectedFromAddressAttribute of the specified type and with\nthe specified address and port\n\n@param address the address value of the address attribute\n@return the newly created address attribute.\n"}, {"uris": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[ResponseAddressAttribute]createResponseAddressAttribute(TransportAddress)", "name": "createResponseAddressAttribute", "arg_nums": 1, "params": [{"name": "address", "type": "TransportAddress"}], "return_type": "ResponseAddressAttribute", "signature": "public static ResponseAddressAttribute createResponseAddressAttribute(\n                    TransportAddress address)", "original_string": "    public static ResponseAddressAttribute createResponseAddressAttribute(\n                    TransportAddress address)\n    {\n        ResponseAddressAttribute attribute = new ResponseAddressAttribute();\n\n        attribute.setAddress(address);\n\n        return attribute;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/AttributeFactory.java", "class_name": "AttributeFactory", "class_uri": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "ResponseAddressAttribute", "classes": []}, "docstring": "\nCreates a ResponseFromAddressAttribute of the specified type and with the\nspecified address and port\n\n@param address the address value of the address attribute\n@return the newly created address attribute.\n"}, {"uris": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[SourceAddressAttribute]createSourceAddressAttribute(TransportAddress)", "name": "createSourceAddressAttribute", "arg_nums": 1, "params": [{"name": "address", "type": "TransportAddress"}], "return_type": "SourceAddressAttribute", "signature": "public static SourceAddressAttribute createSourceAddressAttribute(\n                    TransportAddress address)", "original_string": "    public static SourceAddressAttribute createSourceAddressAttribute(\n                    TransportAddress address)\n    {\n        SourceAddressAttribute attribute = new SourceAddressAttribute();\n\n        attribute.setAddress(address);\n\n        return attribute;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/AttributeFactory.java", "class_name": "AttributeFactory", "class_uri": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "SourceAddressAttribute", "classes": []}, "docstring": "\nCreates a SourceFromAddressAttribute of the specified type and with the\nspecified address and port\n\n@param address the address value of the address attribute\n@return the newly created address attribute.\n"}, {"uris": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[UnknownAttributesAttribute]createUnknownAttributesAttribute()", "name": "createUnknownAttributesAttribute", "arg_nums": 0, "params": [], "return_type": "UnknownAttributesAttribute", "signature": "public static UnknownAttributesAttribute createUnknownAttributesAttribute()", "original_string": "    public static UnknownAttributesAttribute createUnknownAttributesAttribute()\n    {\n        UnknownAttributesAttribute attribute = new UnknownAttributesAttribute();\n\n        return attribute;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/AttributeFactory.java", "class_name": "AttributeFactory", "class_uri": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "UnknownAttributesAttribute", "classes": []}, "docstring": "\nCreates an empty UnknownAttributesAttribute.\n\n@return the newly created UnknownAttributesAttribute\n"}, {"uris": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[XorRelayedAddressAttribute]createXorRelayedAddressAttribute(TransportAddress,byte[])", "name": "createXorRelayedAddressAttribute", "arg_nums": 2, "params": [{"name": "address", "type": "TransportAddress"}, {"name": "tranID", "type": "byte[]"}], "return_type": "XorRelayedAddressAttribute", "signature": "public static XorRelayedAddressAttribute createXorRelayedAddressAttribute(\n                    TransportAddress address, byte[] tranID)", "original_string": "    public static XorRelayedAddressAttribute createXorRelayedAddressAttribute(\n                    TransportAddress address, byte[] tranID)\n    {\n        XorRelayedAddressAttribute attribute = new XorRelayedAddressAttribute();\n\n        // TODO (Emil): shouldn't we be XORing the address before setting it?\n        attribute.setAddress(address, tranID);\n        return attribute;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/AttributeFactory.java", "class_name": "AttributeFactory", "class_uri": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "XorRelayedAddressAttribute", "classes": []}, "docstring": "\nCreates a XorRelayedAddressAttribute of the specified type and with the\nspecified address and port.\n\n@param address the address value of the address attribute\n@param tranID the ID of the transaction that we will be using for the XOR\nmask.\n\n@return the newly created address attribute.\n"}, {"uris": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[XorPeerAddressAttribute]createXorPeerAddressAttribute(TransportAddress,byte[])", "name": "createXorPeerAddressAttribute", "arg_nums": 2, "params": [{"name": "address", "type": "TransportAddress"}, {"name": "tranID", "type": "byte[]"}], "return_type": "XorPeerAddressAttribute", "signature": "public static XorPeerAddressAttribute createXorPeerAddressAttribute(\n                    TransportAddress address, byte[] tranID)", "original_string": "    public static XorPeerAddressAttribute createXorPeerAddressAttribute(\n                    TransportAddress address, byte[] tranID)\n    {\n        XorPeerAddressAttribute attribute = new XorPeerAddressAttribute();\n\n        // TODO (Emil): shouldn't we be XORing the address before setting it?\n        attribute.setAddress(address, tranID);\n        return attribute;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/AttributeFactory.java", "class_name": "AttributeFactory", "class_uri": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "XorPeerAddressAttribute", "classes": []}, "docstring": "\nCreates a XorPeerAddressAttribute of the specified type and with the\nspecified address and port\n\n@param address the address value of the address attribute\n@param tranID the ID of the transaction that we will be using for the XOR\nmask.\n@return the newly created address attribute.\n"}, {"uris": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[XorMappedAddressAttribute]createXorMappedAddressAttribute(TransportAddress,byte[])", "name": "createXorMappedAddressAttribute", "arg_nums": 2, "params": [{"name": "address", "type": "TransportAddress"}, {"name": "tranID", "type": "byte[]"}], "return_type": "XorMappedAddressAttribute", "signature": "public static XorMappedAddressAttribute createXorMappedAddressAttribute(\n                    TransportAddress address, byte[] tranID)", "original_string": "    public static XorMappedAddressAttribute createXorMappedAddressAttribute(\n                    TransportAddress address, byte[] tranID)\n    {\n        XorMappedAddressAttribute attribute = new XorMappedAddressAttribute();\n\n        attribute.setAddress(address, tranID);\n\n        return attribute;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/AttributeFactory.java", "class_name": "AttributeFactory", "class_uri": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "XorMappedAddressAttribute", "classes": []}, "docstring": "\nCreates a XorMappedAddressAttribute for the specified <tt>address</tt>.\n\n@param address the address value of the address attribute\n@param tranID the ID of the transaction that we will be using for the XOR\nmask.\n\n@return the newly created XOR address attribute.\n"}, {"uris": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[UsernameAttribute]createUsernameAttribute(byte)", "name": "createUsernameAttribute", "arg_nums": 1, "params": [{"name": "username", "type": "byte"}], "return_type": "UsernameAttribute", "signature": "public static UsernameAttribute createUsernameAttribute(byte username[])", "original_string": "    public static UsernameAttribute createUsernameAttribute(byte username[])\n    {\n        UsernameAttribute attribute = new UsernameAttribute();\n\n        attribute.setUsername(username);\n        return attribute;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/AttributeFactory.java", "class_name": "AttributeFactory", "class_uri": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "UsernameAttribute", "classes": []}, "docstring": "\nCreate a UsernameAttribute.\n\n@param username username value\n\n@return newly created UsernameAttribute\n"}, {"uris": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[UsernameAttribute]createUsernameAttribute(String)", "name": "createUsernameAttribute", "arg_nums": 1, "params": [{"name": "username", "type": "String"}], "return_type": "UsernameAttribute", "signature": "public static UsernameAttribute createUsernameAttribute(String username)", "original_string": "    public static UsernameAttribute createUsernameAttribute(String username)\n    {\n        UsernameAttribute attribute = new UsernameAttribute();\n\n        try\n        {\n            attribute.setUsername(username.getBytes(\"UTF-8\"));\n        }\n        catch (UnsupportedEncodingException ueex)\n        {\n            throw new UndeclaredThrowableException(ueex);\n        }\n        return attribute;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/AttributeFactory.java", "class_name": "AttributeFactory", "class_uri": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "UsernameAttribute", "classes": []}, "docstring": "\nCreates a new <tt>UsernameAttribute</tt> instance.\n\n@param username the String value of the username\n@return a new <tt>UsernameAttribute</tt> instance\n"}, {"uris": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[MessageIntegrityAttribute]createMessageIntegrityAttribute(String)", "name": "createMessageIntegrityAttribute", "arg_nums": 1, "params": [{"name": "username", "type": "String"}], "return_type": "MessageIntegrityAttribute", "signature": "public static MessageIntegrityAttribute createMessageIntegrityAttribute(\n                                                    String username)", "original_string": "    public static MessageIntegrityAttribute createMessageIntegrityAttribute(\n                                                    String username)\n    {\n        MessageIntegrityAttribute attribute = new MessageIntegrityAttribute();\n\n        attribute.setUsername(username);\n        return attribute;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/AttributeFactory.java", "class_name": "AttributeFactory", "class_uri": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "MessageIntegrityAttribute", "classes": []}, "docstring": "\nCreates an empty <tt>MessageIntegrityAttribute</tt>. When included in a\nmessage the stack would set the body of this attribute so that the\nthe HMAC-SHA1 (RFC 2104) would correspond to the actual message that's\ntransporting the attribute.\n\n@param username the username that we should use to obtain an encryption\nkey (password) that the {@link Attribute#encode()} method should use when\ncreating the content of this message.\n\n@return the newly created address attribute.\n"}, {"uris": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[FingerprintAttribute]createFingerprintAttribute()", "name": "createFingerprintAttribute", "arg_nums": 0, "params": [], "return_type": "FingerprintAttribute", "signature": "public static FingerprintAttribute createFingerprintAttribute()", "original_string": "    public static FingerprintAttribute createFingerprintAttribute()\n    {\n        FingerprintAttribute attribute = new FingerprintAttribute();\n\n        return attribute;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/AttributeFactory.java", "class_name": "AttributeFactory", "class_uri": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "FingerprintAttribute", "classes": []}, "docstring": "\nCreates an empty <tt>FingerprintAttribute</tt> with a 0 check sum. Once\nincluded in a message, the value of this attribute will be calculated\nby the stack just before sending it.\n\n@return the newly created <tt>FingerprintAttribute</tt>.\n"}, {"uris": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[ChannelNumberAttribute]createChannelNumberAttribute(char)", "name": "createChannelNumberAttribute", "arg_nums": 1, "params": [{"name": "channelNumber", "type": "char"}], "return_type": "ChannelNumberAttribute", "signature": "public static ChannelNumberAttribute createChannelNumberAttribute(\n                    char channelNumber)", "original_string": "    public static ChannelNumberAttribute createChannelNumberAttribute(\n                    char channelNumber)\n    {\n        ChannelNumberAttribute attribute = new ChannelNumberAttribute();\n\n        attribute.setChannelNumber(channelNumber);\n        return attribute;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/AttributeFactory.java", "class_name": "AttributeFactory", "class_uri": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "ChannelNumberAttribute", "classes": []}, "docstring": "\nCreate a ChannelNumberAttribute.\n\n@param channelNumber channel number\n@return newly created ChannelNumberAttribute\n"}, {"uris": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[RealmAttribute]createRealmAttribute(byte)", "name": "createRealmAttribute", "arg_nums": 1, "params": [{"name": "realm", "type": "byte"}], "return_type": "RealmAttribute", "signature": "public static RealmAttribute createRealmAttribute(byte realm[])", "original_string": "    public static RealmAttribute createRealmAttribute(byte realm[])\n    {\n        RealmAttribute attribute = new RealmAttribute();\n\n        attribute.setRealm(realm);\n        return attribute;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/AttributeFactory.java", "class_name": "AttributeFactory", "class_uri": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "RealmAttribute", "classes": []}, "docstring": "\nCreate a RealmAttribute.\n\n@param realm realm value\n@return newly created RealmAttribute\n"}, {"uris": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[NonceAttribute]createNonceAttribute(byte)", "name": "createNonceAttribute", "arg_nums": 1, "params": [{"name": "nonce", "type": "byte"}], "return_type": "NonceAttribute", "signature": "public static NonceAttribute createNonceAttribute(byte nonce[])", "original_string": "    public static NonceAttribute createNonceAttribute(byte nonce[])\n    {\n        NonceAttribute attribute = new NonceAttribute();\n\n        attribute.setNonce(nonce);\n        return attribute;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/AttributeFactory.java", "class_name": "AttributeFactory", "class_uri": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "NonceAttribute", "classes": []}, "docstring": "\nCreate a NonceAttribute.\n\n@param nonce nonce value\n@return newly created NonceAttribute\n"}, {"uris": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[SoftwareAttribute]createSoftwareAttribute(byte)", "name": "createSoftwareAttribute", "arg_nums": 1, "params": [{"name": "software", "type": "byte"}], "return_type": "SoftwareAttribute", "signature": "public static SoftwareAttribute createSoftwareAttribute(byte software[])", "original_string": "    public static SoftwareAttribute createSoftwareAttribute(byte software[])\n    {\n        SoftwareAttribute attribute = new SoftwareAttribute();\n\n        attribute.setSoftware(software);\n        return attribute;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/AttributeFactory.java", "class_name": "AttributeFactory", "class_uri": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "SoftwareAttribute", "classes": []}, "docstring": "\nCreate a SoftwareAttribute.\n\n@param software software value\n@return newly created SoftwareAttribute\n"}, {"uris": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[EvenPortAttribute]createEvenPortAttribute(boolean)", "name": "createEvenPortAttribute", "arg_nums": 1, "params": [{"name": "rFlag", "type": "boolean"}], "return_type": "EvenPortAttribute", "signature": "public static EvenPortAttribute createEvenPortAttribute(boolean rFlag)", "original_string": "    public static EvenPortAttribute createEvenPortAttribute(boolean rFlag)\n    {\n        EvenPortAttribute attribute = new EvenPortAttribute();\n\n        attribute.setRFlag(rFlag);\n        return attribute;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/AttributeFactory.java", "class_name": "AttributeFactory", "class_uri": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "EvenPortAttribute", "classes": []}, "docstring": "\nCreate a EventAttribute.\n\n@param rFlag R flag\n@return the newly created EventPortAttribute\n"}, {"uris": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[LifetimeAttribute]createLifetimeAttribute(int)", "name": "createLifetimeAttribute", "arg_nums": 1, "params": [{"name": "lifetime", "type": "int"}], "return_type": "LifetimeAttribute", "signature": "public static LifetimeAttribute createLifetimeAttribute(int lifetime)", "original_string": "    public static LifetimeAttribute createLifetimeAttribute(int lifetime)\n    {\n        LifetimeAttribute attribute = new LifetimeAttribute();\n\n        attribute.setLifetime(lifetime);\n        return attribute;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/AttributeFactory.java", "class_name": "AttributeFactory", "class_uri": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "LifetimeAttribute", "classes": []}, "docstring": "\nCreate a LifetimeAttribute.\n\n@param lifetime lifetime value\n@return newly created LifetimeAttribute\n"}, {"uris": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[RequestedTransportAttribute]createRequestedTransportAttribute(byte)", "name": "createRequestedTransportAttribute", "arg_nums": 1, "params": [{"name": "protocol", "type": "byte"}], "return_type": "RequestedTransportAttribute", "signature": "public static RequestedTransportAttribute createRequestedTransportAttribute(\n                    byte protocol)", "original_string": "    public static RequestedTransportAttribute createRequestedTransportAttribute(\n                    byte protocol)\n    {\n        RequestedTransportAttribute attribute =\n            new RequestedTransportAttribute();\n\n        attribute.setRequestedTransport(protocol);\n        return attribute;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/AttributeFactory.java", "class_name": "AttributeFactory", "class_uri": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "RequestedTransportAttribute", "classes": []}, "docstring": "\nCreate a RequestedTransportAttribute.\n\n@param protocol transport protocol requested\n@return newly created RequestedTransportAttribute\n"}, {"uris": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[ReservationTokenAttribute]createReservationTokenAttribute(byte)", "name": "createReservationTokenAttribute", "arg_nums": 1, "params": [{"name": "token", "type": "byte"}], "return_type": "ReservationTokenAttribute", "signature": "public static ReservationTokenAttribute createReservationTokenAttribute(\n                    byte token[])", "original_string": "    public static ReservationTokenAttribute createReservationTokenAttribute(\n                    byte token[])\n    {\n        ReservationTokenAttribute attribute = new ReservationTokenAttribute();\n\n        attribute.setReservationToken(token);\n        return attribute;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/AttributeFactory.java", "class_name": "AttributeFactory", "class_uri": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "ReservationTokenAttribute", "classes": []}, "docstring": "\nCreate a ReservationTokenAttribute.\n\n@param token the token\n@return newly created RequestedTransportAttribute\n"}, {"uris": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[DataAttribute]createDataAttribute(byte)", "name": "createDataAttribute", "arg_nums": 1, "params": [{"name": "data", "type": "byte"}], "return_type": "DataAttribute", "signature": "public static DataAttribute createDataAttribute(byte data[])", "original_string": "    public static DataAttribute createDataAttribute(byte data[])\n    {\n        DataAttribute attribute = new DataAttribute();\n\n        attribute.setData(data);\n        return attribute;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/AttributeFactory.java", "class_name": "AttributeFactory", "class_uri": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "DataAttribute", "classes": []}, "docstring": "\nCreate a DataAtttribute.\n\n@param data the data\n@return newly created DataAttribute\n"}, {"uris": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[DataAttribute]createDataAttributeWithoutPadding(byte)", "name": "createDataAttributeWithoutPadding", "arg_nums": 1, "params": [{"name": "data", "type": "byte"}], "return_type": "DataAttribute", "signature": "public static DataAttribute createDataAttributeWithoutPadding(byte data[])", "original_string": "    public static DataAttribute createDataAttributeWithoutPadding(byte data[])\n    {\n        DataAttribute attribute = new DataAttribute(false);\n\n        attribute.setData(data);\n        return attribute;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/AttributeFactory.java", "class_name": "AttributeFactory", "class_uri": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "DataAttribute", "classes": []}, "docstring": "\nCreate a DataAtttribute.\n\n@param data the data\n@return newly created DataAttribute\n"}, {"uris": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[IceControlledAttribute]createIceControlledAttribute(long)", "name": "createIceControlledAttribute", "arg_nums": 1, "params": [{"name": "tieBreaker", "type": "long"}], "return_type": "IceControlledAttribute", "signature": "public static IceControlledAttribute createIceControlledAttribute(\n                                                            long tieBreaker)", "original_string": "    public static IceControlledAttribute createIceControlledAttribute(\n                                                            long tieBreaker)\n    {\n        IceControlledAttribute attribute = new IceControlledAttribute();\n        attribute.setTieBreaker(tieBreaker);\n\n        return attribute;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/AttributeFactory.java", "class_name": "AttributeFactory", "class_uri": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "IceControlledAttribute", "classes": []}, "docstring": "\nCreates an IceControlledAttribute object with the specified tie-breaker\nvalue\n\n@param tieBreaker the tie-breaker value to be used\n@return the created IceControlledAttribute\n"}, {"uris": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[PriorityAttribute]createPriorityAttribute(long)", "name": "createPriorityAttribute", "arg_nums": 1, "params": [{"name": "priority", "type": "long"}], "return_type": "PriorityAttribute", "signature": "public static PriorityAttribute createPriorityAttribute(long priority)", "original_string": "    public static PriorityAttribute createPriorityAttribute(long priority)\n                    throws IllegalArgumentException\n    {\n        PriorityAttribute attribute = new PriorityAttribute();\n\n        attribute.setPriority(priority);\n\n        return attribute;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/AttributeFactory.java", "class_name": "AttributeFactory", "class_uri": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "PriorityAttribute", "classes": []}, "docstring": "\nCreates a Priority attribute with the specified priority value\n\n@param priority the priority value\n@return the created PriorityAttribute\n@throws IllegalArgumentException if priority &lt; 0 or priority &gt;\n            (2^31 - 1)\n"}, {"uris": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[UseCandidateAttribute]createUseCandidateAttribute()", "name": "createUseCandidateAttribute", "arg_nums": 0, "params": [], "return_type": "UseCandidateAttribute", "signature": "public static UseCandidateAttribute createUseCandidateAttribute()", "original_string": "    public static UseCandidateAttribute createUseCandidateAttribute()\n    {\n        UseCandidateAttribute attribute = new UseCandidateAttribute();\n\n        return attribute;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/AttributeFactory.java", "class_name": "AttributeFactory", "class_uri": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "UseCandidateAttribute", "classes": []}, "docstring": "\nCreates a UseCandidateAttribute\n\n@return the created UseCandidateAttribute\n"}, {"uris": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[IceControllingAttribute]createIceControllingAttribute(long)", "name": "createIceControllingAttribute", "arg_nums": 1, "params": [{"name": "tieBreaker", "type": "long"}], "return_type": "IceControllingAttribute", "signature": "public static IceControllingAttribute createIceControllingAttribute(\n                    long tieBreaker)", "original_string": "    public static IceControllingAttribute createIceControllingAttribute(\n                    long tieBreaker)\n    {\n        IceControllingAttribute attribute = new IceControllingAttribute();\n        attribute.setTieBreaker(tieBreaker);\n\n        return attribute;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/AttributeFactory.java", "class_name": "AttributeFactory", "class_uri": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "IceControllingAttribute", "classes": []}, "docstring": "\nCreates an IceControllingAttribute with the specified tie-breaker value\n\n@param tieBreaker the tie-breaker value to be used\n\n@return the created IceControllingAttribute\n"}, {"uris": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[MagicCookieAttribute]createMagicCookieAttribute()", "name": "createMagicCookieAttribute", "arg_nums": 0, "params": [], "return_type": "MagicCookieAttribute", "signature": "public static MagicCookieAttribute createMagicCookieAttribute()", "original_string": "    public static MagicCookieAttribute createMagicCookieAttribute()\n    {\n        MagicCookieAttribute attribute = new MagicCookieAttribute();\n        return attribute;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/AttributeFactory.java", "class_name": "AttributeFactory", "class_uri": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "MagicCookieAttribute", "classes": []}, "docstring": "\nCreates a MagicCookieAttribute.\n\n@return the created MagicCookieAttribute\n"}, {"uris": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[DestinationAddressAttribute]createDestinationAddressAttribute(TransportAddress)", "name": "createDestinationAddressAttribute", "arg_nums": 1, "params": [{"name": "address", "type": "TransportAddress"}], "return_type": "DestinationAddressAttribute", "signature": "public static DestinationAddressAttribute createDestinationAddressAttribute(\n                    TransportAddress address)", "original_string": "    public static DestinationAddressAttribute createDestinationAddressAttribute(\n                    TransportAddress address)\n    {\n        DestinationAddressAttribute attribute =\n            new DestinationAddressAttribute();\n\n        attribute.setAddress(address);\n\n        return attribute;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/AttributeFactory.java", "class_name": "AttributeFactory", "class_uri": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "DestinationAddressAttribute", "classes": []}, "docstring": "\nCreates a DestinationFromAddressAttribute of the specified type and with\nthe specified address and port\n\n@param address the address value of the address attribute\n@return the newly created address attribute.\n"}, {"uris": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[RequestedAddressFamilyAttribute]createRequestedAddressFamilyAttribute(char)", "name": "createRequestedAddressFamilyAttribute", "arg_nums": 1, "params": [{"name": "family", "type": "char"}], "return_type": "RequestedAddressFamilyAttribute", "signature": "public static RequestedAddressFamilyAttribute\n        createRequestedAddressFamilyAttribute(char family)", "original_string": "    public static RequestedAddressFamilyAttribute\n        createRequestedAddressFamilyAttribute(char family)\n    {\n        RequestedAddressFamilyAttribute attribute\n            = new RequestedAddressFamilyAttribute();\n\n        boolean isSet = attribute.setFamily(family);\n        if (!isSet)\n        {\n            attribute = null;\n        }\n\n        return attribute;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/AttributeFactory.java", "class_name": "AttributeFactory", "class_uri": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "RequestedAddressFamilyAttribute", "classes": []}, "docstring": "\nCreates a new RequestedAddressFamilyAttribute of the specified family\n\n@param family address family value as specified in the RFC\n@return the newly created RequestedAddressFamily attribute if family is\n        IPv4/IPv6 otherwise <tt>null</tt>.\n"}, {"uris": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[ConnectionIdAttribute]createConnectionIdAttribute(int)", "name": "createConnectionIdAttribute", "arg_nums": 1, "params": [{"name": "connectionIdValue", "type": "int"}], "return_type": "ConnectionIdAttribute", "signature": "public static ConnectionIdAttribute createConnectionIdAttribute(\n        int connectionIdValue)", "original_string": "    public static ConnectionIdAttribute createConnectionIdAttribute(\n        int connectionIdValue)\n    {\n        ConnectionIdAttribute attribute = new ConnectionIdAttribute();\n\n        attribute.setConnectionIdValue(connectionIdValue);\n\n        return attribute;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/AttributeFactory.java", "class_name": "AttributeFactory", "class_uri": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "ConnectionIdAttribute", "classes": []}, "docstring": "\nCreates a new ConnectionIdAttribute of the specified connectionIdValue\n\n@param connectionIdValue the connection ID value.\n@return the newly created ConnectionId attribute. \n"}, {"uris": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[ConnectionIdAttribute]createConnectionIdAttribute()", "name": "createConnectionIdAttribute", "arg_nums": 0, "params": [], "return_type": "ConnectionIdAttribute", "signature": "public static ConnectionIdAttribute createConnectionIdAttribute()", "original_string": "    public static ConnectionIdAttribute createConnectionIdAttribute()\n    {\n        ConnectionIdAttribute attribute = new ConnectionIdAttribute();\n        int connectionIdValue = attribute.hashCode();\n        attribute.setConnectionIdValue(connectionIdValue);\n\n        return attribute;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/AttributeFactory.java", "class_name": "AttributeFactory", "class_uri": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "ConnectionIdAttribute", "classes": []}, "docstring": "\nCreates a new ConnectionIdAttribute. The connectionId value is set as the\nhashcode value of the object.\n\n@return the newly created ConnectionId attribute.\n"}, {"uris": "src/main/java/org/ice4j/attribute/RequestedAddressFamilyAttribute.java.RequestedAddressFamilyAttribute.[]RequestedAddressFamilyAttribute()", "name": "RequestedAddressFamilyAttribute", "arg_nums": 0, "params": [], "return_type": "", "signature": "protected RequestedAddressFamilyAttribute()", "original_string": "    protected RequestedAddressFamilyAttribute() \n    {\n        super(REQUESTED_ADDRESS_FAMILY);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/RequestedAddressFamilyAttribute.java", "class_name": "RequestedAddressFamilyAttribute", "class_uri": "src/main/java/org/ice4j/attribute/RequestedAddressFamilyAttribute.java.RequestedAddressFamilyAttribute", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nConstructor.\n"}, {"uris": "src/main/java/org/ice4j/attribute/RequestedAddressFamilyAttribute.java.RequestedAddressFamilyAttribute.[char]getDataLength()", "name": "getDataLength", "arg_nums": 0, "params": [], "return_type": "char", "signature": "@Override\n    public char getDataLength()", "original_string": "    @Override\n    public char getDataLength() \n    {\n        return DATA_LENGTH;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/RequestedAddressFamilyAttribute.java", "class_name": "RequestedAddressFamilyAttribute", "class_uri": "src/main/java/org/ice4j/attribute/RequestedAddressFamilyAttribute.java.RequestedAddressFamilyAttribute", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "char", "classes": []}, "docstring": "\nReturns the length of this attribute's body.\n@return the length of this attribute's value (1 byte).\n"}, {"uris": "src/main/java/org/ice4j/attribute/RequestedAddressFamilyAttribute.java.RequestedAddressFamilyAttribute.[String]getName()", "name": "getName", "arg_nums": 0, "params": [], "return_type": "String", "signature": "@Override\n    public String getName()", "original_string": "    @Override\n    public String getName() \n    {\n        return NAME;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/RequestedAddressFamilyAttribute.java", "class_name": "RequestedAddressFamilyAttribute", "class_uri": "src/main/java/org/ice4j/attribute/RequestedAddressFamilyAttribute.java.RequestedAddressFamilyAttribute", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns the human readable name of this attribute. Attribute names do\nnot really matter from the protocol point of view. They are only used\nfor debugging and readability.\n@return this attribute's name.\n"}, {"uris": "src/main/java/org/ice4j/attribute/RequestedAddressFamilyAttribute.java.RequestedAddressFamilyAttribute.[boolean]equals(Object)", "name": "equals", "arg_nums": 1, "params": [{"name": "obj", "type": "Object"}], "return_type": "boolean", "signature": "@Override\n    public boolean equals(Object obj)", "original_string": "    @Override\n    public boolean equals(Object obj) \n    {\n        if (! (obj instanceof RequestedAddressFamilyAttribute))\n            return false;\n\n        if (obj == this)\n            return true;\n\n        RequestedAddressFamilyAttribute att\n            = (RequestedAddressFamilyAttribute) obj;\n\n        if (att.getAttributeType() != getAttributeType()\n                || att.getDataLength() != getDataLength()\n                /* compare data */\n                || att.family != family\n           )\n            return false;\n\n        return true;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/RequestedAddressFamilyAttribute.java", "class_name": "RequestedAddressFamilyAttribute", "class_uri": "src/main/java/org/ice4j/attribute/RequestedAddressFamilyAttribute.java.RequestedAddressFamilyAttribute", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nCompares two TURN Attributes. Attributes are considered equal when their\ntype, length, and all data are the same.\n@param obj the object to compare this attribute with.\n@return true if the attributes are equal and false otherwise.\n"}, {"uris": "src/main/java/org/ice4j/attribute/RequestedAddressFamilyAttribute.java.RequestedAddressFamilyAttribute.[byte[]]encode()", "name": "encode", "arg_nums": 0, "params": [], "return_type": "byte[]", "signature": "@Override\n    public byte[] encode()", "original_string": "    @Override\n    public byte[] encode() \n    {\n        byte binValue[] = new byte[HEADER_LENGTH + DATA_LENGTH];\n\n        //Type\n        binValue[0] = (byte)(getAttributeType() >> 8);\n        binValue[1] = (byte)(getAttributeType() & 0x00FF);\n        //Length\n        binValue[2] = (byte)(getDataLength() >> 8);\n        binValue[3] = (byte)(getDataLength() & 0x00FF);\n        //Data\n        binValue[4] = (byte) family;\n\n        return binValue;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/RequestedAddressFamilyAttribute.java", "class_name": "RequestedAddressFamilyAttribute", "class_uri": "src/main/java/org/ice4j/attribute/RequestedAddressFamilyAttribute.java.RequestedAddressFamilyAttribute", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "byte[]", "classes": []}, "docstring": "\nReturns a binary representation of this attribute.\n@return a binary representation of this attribute.\n"}, {"uris": "src/main/java/org/ice4j/attribute/RequestedAddressFamilyAttribute.java.RequestedAddressFamilyAttribute.[void]decodeAttributeBody(byte[],char,char)", "name": "decodeAttributeBody", "arg_nums": 3, "params": [{"name": "attributeValue", "type": "byte[]"}, {"name": "offset", "type": "char"}, {"name": "length", "type": "char"}], "return_type": "void", "signature": "@Override\n    void decodeAttributeBody(byte[] attributeValue, char offset, char length)", "original_string": "    @Override\n    void decodeAttributeBody(byte[] attributeValue, char offset, char length) \n        throws StunException\n    {\n        if (length != DATA_LENGTH)\n        {\n            throw new StunException(\"length invalid: \" + length);\n        }\n\n        family = (char)(attributeValue[offset] & 0xff);\n\n        if (family != IPv4 && family != IPv6)\n        {\n            // instead throw TurnException\n            throw new StunException(\"invalid family value: \" + family);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/RequestedAddressFamilyAttribute.java", "class_name": "RequestedAddressFamilyAttribute", "class_uri": "src/main/java/org/ice4j/attribute/RequestedAddressFamilyAttribute.java.RequestedAddressFamilyAttribute", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets this attribute's fields according to attributeValue array.\n@param attributeValue a binary array containing this attribute's field\n                      values and NOT containing the attribute header.\n@param offset the position where attribute values begin (most often\n         offset is equal to the index of the first byte after\n         length)\n@param length the length of the binary array.\n@throws StunException if attrubteValue contains invalid data.\n"}, {"uris": "src/main/java/org/ice4j/attribute/RequestedAddressFamilyAttribute.java.RequestedAddressFamilyAttribute.[char]getFamily()", "name": "getFamily", "arg_nums": 0, "params": [], "return_type": "char", "signature": "public char getFamily()", "original_string": "    public char getFamily() \n    {\n        return family;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/RequestedAddressFamilyAttribute.java", "class_name": "RequestedAddressFamilyAttribute", "class_uri": "src/main/java/org/ice4j/attribute/RequestedAddressFamilyAttribute.java.RequestedAddressFamilyAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "char", "classes": []}, "docstring": "\nGets the address family value\n@return family the address family value\n"}, {"uris": "src/main/java/org/ice4j/attribute/RequestedAddressFamilyAttribute.java.RequestedAddressFamilyAttribute.[boolean]setFamily(char)", "name": "setFamily", "arg_nums": 1, "params": [{"name": "family", "type": "char"}], "return_type": "boolean", "signature": "public boolean setFamily(char family)", "original_string": "    public boolean setFamily(char family) \n    {    \n        if (family == IPv4 || family == IPv6)\n        {\n            this.family = family;\n            return true;\n        }\n        else\n        {\n            return false;\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/RequestedAddressFamilyAttribute.java", "class_name": "RequestedAddressFamilyAttribute", "class_uri": "src/main/java/org/ice4j/attribute/RequestedAddressFamilyAttribute.java.RequestedAddressFamilyAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nSets the address family value\n@param family the address family value to set\n@return true if argument is IPv4 or IPv6 otherwise false\n"}, {"uris": "src/main/java/org/ice4j/attribute/RequestedTransportAttribute.java.RequestedTransportAttribute.[]RequestedTransportAttribute()", "name": "RequestedTransportAttribute", "arg_nums": 0, "params": [], "return_type": "", "signature": "RequestedTransportAttribute()", "original_string": "    RequestedTransportAttribute()\n    {\n        super(REQUESTED_TRANSPORT);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/RequestedTransportAttribute.java", "class_name": "RequestedTransportAttribute", "class_uri": "src/main/java/org/ice4j/attribute/RequestedTransportAttribute.java.RequestedTransportAttribute", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "docstring": "\nConstructor.\n"}, {"uris": "src/main/java/org/ice4j/attribute/RequestedTransportAttribute.java.RequestedTransportAttribute.[boolean]equals(Object)", "name": "equals", "arg_nums": 1, "params": [{"name": "obj", "type": "Object"}], "return_type": "boolean", "signature": "@Override\n    public boolean equals(Object obj)", "original_string": "    @Override\n    public boolean equals(Object obj)\n    {\n        if (! (obj instanceof RequestedTransportAttribute))\n            return false;\n\n        if (obj == this)\n            return true;\n\n        RequestedTransportAttribute att = (RequestedTransportAttribute) obj;\n        if (att.getAttributeType()   != getAttributeType()\n                || att.getDataLength()   != getDataLength()\n                /* compare data */\n                || att.transportProtocol != transportProtocol\n           )\n            return false;\n\n        return true;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/RequestedTransportAttribute.java", "class_name": "RequestedTransportAttribute", "class_uri": "src/main/java/org/ice4j/attribute/RequestedTransportAttribute.java.RequestedTransportAttribute", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nCompares two STUN Attributes. Attributes are considered equal when their\ntype, length, and all data are the same.\n@param obj the object to compare this attribute with.\n@return true if the attributes are equal and false otherwise.\n"}, {"uris": "src/main/java/org/ice4j/attribute/RequestedTransportAttribute.java.RequestedTransportAttribute.[String]getName()", "name": "getName", "arg_nums": 0, "params": [], "return_type": "String", "signature": "@Override\n    public String getName()", "original_string": "    @Override\n    public String getName()\n    {\n        return NAME;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/RequestedTransportAttribute.java", "class_name": "RequestedTransportAttribute", "class_uri": "src/main/java/org/ice4j/attribute/RequestedTransportAttribute.java.RequestedTransportAttribute", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns the human readable name of this attribute. Attribute names do\nnot really matter from the protocol point of view. They are only used\nfor debugging and readability.\n@return this attribute's name.\n"}, {"uris": "src/main/java/org/ice4j/attribute/RequestedTransportAttribute.java.RequestedTransportAttribute.[char]getDataLength()", "name": "getDataLength", "arg_nums": 0, "params": [], "return_type": "char", "signature": "@Override\n    public char getDataLength()", "original_string": "    @Override\n    public char getDataLength()\n    {\n        return DATA_LENGTH;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/RequestedTransportAttribute.java", "class_name": "RequestedTransportAttribute", "class_uri": "src/main/java/org/ice4j/attribute/RequestedTransportAttribute.java.RequestedTransportAttribute", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "char", "classes": []}, "docstring": "\nReturns the length of this attribute's body.\n@return the length of this attribute's value (8 bytes).\n"}, {"uris": "src/main/java/org/ice4j/attribute/RequestedTransportAttribute.java.RequestedTransportAttribute.[byte[]]encode()", "name": "encode", "arg_nums": 0, "params": [], "return_type": "byte[]", "signature": "@Override\n    public byte[] encode()", "original_string": "    @Override\n    public byte[] encode()\n    {\n        byte binValue[] = new byte[HEADER_LENGTH + DATA_LENGTH];\n\n        //Type\n        binValue[0] = (byte)(getAttributeType() >> 8);\n        binValue[1] = (byte)(getAttributeType() & 0x00FF);\n        //Length\n        binValue[2] = (byte)(getDataLength() >> 8);\n        binValue[3] = (byte)(getDataLength() & 0x00FF);\n        //Data\n        binValue[4] = transportProtocol;\n        binValue[5] = 0x00;\n        binValue[6] = 0x00;\n        binValue[7] = 0x00;\n\n        return binValue;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/RequestedTransportAttribute.java", "class_name": "RequestedTransportAttribute", "class_uri": "src/main/java/org/ice4j/attribute/RequestedTransportAttribute.java.RequestedTransportAttribute", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "byte[]", "classes": []}, "docstring": "\nReturns a binary representation of this attribute.\n@return a binary representation of this attribute.\n"}, {"uris": "src/main/java/org/ice4j/attribute/RequestedTransportAttribute.java.RequestedTransportAttribute.[void]decodeAttributeBody(byte[],char,char)", "name": "decodeAttributeBody", "arg_nums": 3, "params": [{"name": "attributeValue", "type": "byte[]"}, {"name": "offset", "type": "char"}, {"name": "length", "type": "char"}], "return_type": "void", "signature": "@Override\n    void decodeAttributeBody(byte[] attributeValue, char offset, char length)", "original_string": "    @Override\n    void decodeAttributeBody(byte[] attributeValue, char offset, char length)\n        throws StunException\n    {\n        if (length != 4)\n        {\n            throw new StunException(\"length invalid\");\n        }\n\n        transportProtocol = attributeValue[offset];\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/RequestedTransportAttribute.java", "class_name": "RequestedTransportAttribute", "class_uri": "src/main/java/org/ice4j/attribute/RequestedTransportAttribute.java.RequestedTransportAttribute", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets this attribute's fields according to attributeValue array.\n@param attributeValue a binary array containing this attribute's field\n                      values and NOT containing the attribute header.\n@param offset the position where attribute values begin (most often\n         offset is equal to the index of the first byte after\n         length)\n@param length the length of the binary array.\n@throws StunException if attrubteValue contains invalid data.\n"}, {"uris": "src/main/java/org/ice4j/attribute/RequestedTransportAttribute.java.RequestedTransportAttribute.[void]setRequestedTransport(byte)", "name": "setRequestedTransport", "arg_nums": 1, "params": [{"name": "transportProtocol", "type": "byte"}], "return_type": "void", "signature": "public void setRequestedTransport(byte transportProtocol)", "original_string": "    public void setRequestedTransport(byte transportProtocol)\n    {\n        this.transportProtocol = transportProtocol;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/RequestedTransportAttribute.java", "class_name": "RequestedTransportAttribute", "class_uri": "src/main/java/org/ice4j/attribute/RequestedTransportAttribute.java.RequestedTransportAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSet the transport protocol.\n@param transportProtocol transport protocol\n"}, {"uris": "src/main/java/org/ice4j/attribute/RequestedTransportAttribute.java.RequestedTransportAttribute.[int]getRequestedTransport()", "name": "getRequestedTransport", "arg_nums": 0, "params": [], "return_type": "int", "signature": "public int getRequestedTransport()", "original_string": "    public int getRequestedTransport()\n    {\n        return transportProtocol;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/RequestedTransportAttribute.java", "class_name": "RequestedTransportAttribute", "class_uri": "src/main/java/org/ice4j/attribute/RequestedTransportAttribute.java.RequestedTransportAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\nGet the transport protocol.\n@return transport protocol\n"}, {"uris": "src/main/java/org/ice4j/attribute/MappedAddressAttribute.java.MappedAddressAttribute.[]MappedAddressAttribute()", "name": "MappedAddressAttribute", "arg_nums": 0, "params": [], "return_type": "", "signature": "MappedAddressAttribute()", "original_string": "    MappedAddressAttribute()\n    {\n        super(MAPPED_ADDRESS);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/MappedAddressAttribute.java", "class_name": "MappedAddressAttribute", "class_uri": "src/main/java/org/ice4j/attribute/MappedAddressAttribute.java.MappedAddressAttribute", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "docstring": "\nConstructor.\n"}, {"uris": "src/main/java/org/ice4j/attribute/OptionalAttribute.java.OptionalAttribute.[]OptionalAttribute(char)", "name": "OptionalAttribute", "arg_nums": 1, "params": [{"name": "attributeType", "type": "char"}], "return_type": "", "signature": "protected OptionalAttribute(char attributeType)", "original_string": "    protected OptionalAttribute(char attributeType)\n    {\n        super(attributeType);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/OptionalAttribute.java", "class_name": "OptionalAttribute", "class_uri": "src/main/java/org/ice4j/attribute/OptionalAttribute.java.OptionalAttribute", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/org/ice4j/attribute/OptionalAttribute.java.OptionalAttribute.[void]decodeAttributeBody(byte[],char,char)", "name": "decodeAttributeBody", "arg_nums": 3, "params": [{"name": "attributeValue", "type": "byte[]"}, {"name": "offset", "type": "char"}, {"name": "length", "type": "char"}], "return_type": "void", "signature": "void decodeAttributeBody(byte[] attributeValue, char offset, char length)", "original_string": "    void decodeAttributeBody(byte[] attributeValue, char offset, char length)\n        throws StunException\n    {\n        this.attributeValue = new byte[length];\n        System.arraycopy(attributeValue, offset, this.attributeValue, 0,\n                length);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/OptionalAttribute.java", "class_name": "OptionalAttribute", "class_uri": "src/main/java/org/ice4j/attribute/OptionalAttribute.java.OptionalAttribute", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets this attribute's fields according to attributeValue array.\n\n@param attributeValue a binary array containing this attribute's\n  field values and NOT containing the attribute header.\n@param offset the position where attribute values begin (most often\n  offset is equal to the index of the first byte after length)\n@param length the length of the binary array.\n@throws StunException if attrubteValue contains invalid data.\n"}, {"uris": "src/main/java/org/ice4j/attribute/OptionalAttribute.java.OptionalAttribute.[byte[]]encode()", "name": "encode", "arg_nums": 0, "params": [], "return_type": "byte[]", "signature": "public byte[] encode()", "original_string": "    public byte[] encode()\n    {\n        char type = getAttributeType();\n\n        byte binValue[] = new byte[HEADER_LENGTH + attributeValue.length];\n\n        //Type\n        binValue[0] = (byte)(type >> 8);\n        binValue[1] = (byte)(type & 0x00FF);\n        //Length\n        binValue[2] = (byte)(getDataLength() >> 8);\n        binValue[3] = (byte)(getDataLength() & 0x00FF);\n\n        System.arraycopy(attributeValue, 0,\n                         binValue, HEADER_LENGTH, attributeValue.length);\n\n        return binValue;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/OptionalAttribute.java", "class_name": "OptionalAttribute", "class_uri": "src/main/java/org/ice4j/attribute/OptionalAttribute.java.OptionalAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "byte[]", "classes": []}, "docstring": "\nReturns a binary representation of this attribute.\n\n@return a binary representation of this attribute.\n"}, {"uris": "src/main/java/org/ice4j/attribute/OptionalAttribute.java.OptionalAttribute.[char]getDataLength()", "name": "getDataLength", "arg_nums": 0, "params": [], "return_type": "char", "signature": "public char getDataLength()", "original_string": "    public char getDataLength()\n    {\n        return (char)attributeValue.length;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/OptionalAttribute.java", "class_name": "OptionalAttribute", "class_uri": "src/main/java/org/ice4j/attribute/OptionalAttribute.java.OptionalAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "char", "classes": []}, "docstring": "\nReturns the length of this attribute's body.\n\n@return the length of this attribute's value.\n"}, {"uris": "src/main/java/org/ice4j/attribute/OptionalAttribute.java.OptionalAttribute.[String]getName()", "name": "getName", "arg_nums": 0, "params": [], "return_type": "String", "signature": "public String getName()", "original_string": "    public String getName()\n    {\n        return \"Unknown Attribute\";\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/OptionalAttribute.java", "class_name": "OptionalAttribute", "class_uri": "src/main/java/org/ice4j/attribute/OptionalAttribute.java.OptionalAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns the human readable name of this attribute.\n\n@return this attribute's name.\n"}, {"uris": "src/main/java/org/ice4j/attribute/OptionalAttribute.java.OptionalAttribute.[byte[]]getBody()", "name": "getBody", "arg_nums": 0, "params": [], "return_type": "byte[]", "signature": "public byte[] getBody()", "original_string": "    public byte[] getBody()\n    {\n        return attributeValue;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/OptionalAttribute.java", "class_name": "OptionalAttribute", "class_uri": "src/main/java/org/ice4j/attribute/OptionalAttribute.java.OptionalAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "byte[]", "classes": []}, "docstring": "\nReturns a reference to the unparsed body of this attribute.\n\n@return a reference to this attribute's unparsed value.\n"}, {"uris": "src/main/java/org/ice4j/attribute/OptionalAttribute.java.OptionalAttribute.[void]setBody(byte[],int,int)", "name": "setBody", "arg_nums": 3, "params": [{"name": "body", "type": "byte[]"}, {"name": "offset", "type": "int"}, {"name": "length", "type": "int"}], "return_type": "void", "signature": "public void setBody(byte[] body, int offset, int length)", "original_string": "    public void setBody(byte[] body, int offset, int length)\n    {\n        this.attributeValue = new byte[length];\n        System.arraycopy(body, offset, this.attributeValue, 0, length);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/OptionalAttribute.java", "class_name": "OptionalAttribute", "class_uri": "src/main/java/org/ice4j/attribute/OptionalAttribute.java.OptionalAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCopies the speicified byte array segment as the body of this attribute.\n\n@param body the body to copy\n@param offset the position to start\n@param length the length to copy\n"}, {"uris": "src/main/java/org/ice4j/attribute/OptionalAttribute.java.OptionalAttribute.[boolean]equals(Object)", "name": "equals", "arg_nums": 1, "params": [{"name": "obj", "type": "Object"}], "return_type": "boolean", "signature": "public boolean equals(Object obj)", "original_string": "    public boolean equals(Object obj)\n    {\n        if (! (obj instanceof OptionalAttribute) )\n            return false;\n\n        return\n            (obj == this\n             || Arrays.equals(((OptionalAttribute)obj).\n                              attributeValue, attributeValue));\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/OptionalAttribute.java", "class_name": "OptionalAttribute", "class_uri": "src/main/java/org/ice4j/attribute/OptionalAttribute.java.OptionalAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nCompares two STUN Attributes. Two attributes are considered equal when they\nhave the same type length and value.\n\n@param obj the object to compare this attribute with.\n@return true if the attributes are equal and false otherwise.\n"}, {"uris": "src/main/java/org/ice4j/attribute/IceControlAttribute.java.IceControlAttribute.[]IceControlAttribute(boolean)", "name": "IceControlAttribute", "arg_nums": 1, "params": [{"name": "isControlling", "type": "boolean"}], "return_type": "", "signature": "IceControlAttribute(boolean isControlling)", "original_string": "    IceControlAttribute(boolean isControlling)\n    {\n        super(isControlling ? ICE_CONTROLLING : ICE_CONTROLLED);\n        this.isControlling = isControlling;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/IceControlAttribute.java", "class_name": "IceControlAttribute", "class_uri": "src/main/java/org/ice4j/attribute/IceControlAttribute.java.IceControlAttribute", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "docstring": "\nConstructs an ICE-CONTROLLING or an ICE-CONTROLLED attribute depending\non the value of <tt>isControlling</tt>.\n\n@param isControlling indicates the kind of attribute we are trying to\ncreate\n"}, {"uris": "src/main/java/org/ice4j/attribute/IceControlAttribute.java.IceControlAttribute.[void]decodeAttributeBody(byte[],char,char)", "name": "decodeAttributeBody", "arg_nums": 3, "params": [{"name": "attributeValue", "type": "byte[]"}, {"name": "offset", "type": "char"}, {"name": "length", "type": "char"}], "return_type": "void", "signature": "void decodeAttributeBody(byte[] attributeValue, char offset, char length)", "original_string": "    void decodeAttributeBody(byte[] attributeValue, char offset, char length)\n            throws StunException\n    {\n        // array used to hold the intermediate long values reconstructed from\n        // the attributeValue array\n\n        // Reading in the network byte order (Big-Endian)\n        tieBreaker = ((attributeValue[offset++] & 0xffL) << 56)\n                  | ((attributeValue[offset++] & 0xffL) << 48)\n                  | ((attributeValue[offset++] & 0xffL) << 40)\n                  | ((attributeValue[offset++] & 0xffL) << 32)\n                  | ((attributeValue[offset++] & 0xffL) << 24)\n                  | ((attributeValue[offset++] & 0xffL) << 16)\n                  | ((attributeValue[offset++] & 0xffL) <<  8)\n                  | (attributeValue[offset]  & 0xffL);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/IceControlAttribute.java", "class_name": "IceControlAttribute", "class_uri": "src/main/java/org/ice4j/attribute/IceControlAttribute.java.IceControlAttribute", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets this attribute's fields according to attributeValue array.\n\n@param attributeValue a binary array containing this attribute's field\n                      values and NOT containing the attribute header.\n@param offset the position where attribute values begin (most often\n                 offset is equal to the index of the first byte after\n                 length)\n@param length the length of the attribute data.\n\n@throws StunException if attrubteValue contains invalid data.\n"}, {"uris": "src/main/java/org/ice4j/attribute/IceControlAttribute.java.IceControlAttribute.[byte[]]encode()", "name": "encode", "arg_nums": 0, "params": [], "return_type": "byte[]", "signature": "public byte[] encode()", "original_string": "    public byte[] encode()\n    {\n        char type = getAttributeType();\n        byte[] binValue = new byte[HEADER_LENGTH + getDataLength()];\n\n        //Type\n        binValue[0] = (byte)(type >> 8);\n        binValue[1] = (byte)(type & 0x00FF);\n\n        //Length\n        binValue[2] = (byte)(getDataLength() >> 8);\n        binValue[3] = (byte)(getDataLength() & 0x00FF);\n\n        //Tie-Breaker\n        binValue[4]  = (byte)((tieBreaker & 0xFF00000000000000L) >> 56);\n        binValue[5]  = (byte)((tieBreaker & 0x00FF000000000000L) >> 48);\n        binValue[6]  = (byte)((tieBreaker & 0x0000FF0000000000L) >> 40);\n        binValue[7]  = (byte)((tieBreaker & 0x000000FF00000000L) >> 32);\n        binValue[8]  = (byte)((tieBreaker & 0x00000000FF000000L) >> 24);\n        binValue[9]  = (byte)((tieBreaker & 0x0000000000FF0000L) >> 16);\n        binValue[10] = (byte)((tieBreaker & 0x000000000000FF00L) >> 8);\n        binValue[11] = (byte)( tieBreaker & 0x00000000000000FFL);\n\n        return binValue;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/IceControlAttribute.java", "class_name": "IceControlAttribute", "class_uri": "src/main/java/org/ice4j/attribute/IceControlAttribute.java.IceControlAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "byte[]", "classes": []}, "docstring": "\nReturns a binary representation of this attribute.\n\n@return a binary representation of this attribute.\n"}, {"uris": "src/main/java/org/ice4j/attribute/IceControlAttribute.java.IceControlAttribute.[boolean]equals(Object)", "name": "equals", "arg_nums": 1, "params": [{"name": "obj", "type": "Object"}], "return_type": "boolean", "signature": "public boolean equals(Object obj)", "original_string": "    public boolean equals(Object obj)\n    {\n        if (!(obj instanceof IceControlAttribute))\n            return false;\n\n        if (obj == this)\n            return true;\n\n        IceControlAttribute iceControlAtt = (IceControlAttribute)obj;\n        if (iceControlAtt.getAttributeType() != getAttributeType()\n            || iceControlAtt.isControlling != isControlling\n            || iceControlAtt.getDataLength() != DATA_LENGTH_ICE_CONTROL\n            || getTieBreaker() != iceControlAtt.getTieBreaker())\n        {\n            return false;\n        }\n\n        return true;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/IceControlAttribute.java", "class_name": "IceControlAttribute", "class_uri": "src/main/java/org/ice4j/attribute/IceControlAttribute.java.IceControlAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nCompares two STUN Attributes. Attributes are considered equal when their\ntype, length, and all data are the same.\n\n@param obj the object to compare this attribute with.\n\n@return true if the attributes are equal and false otherwise.\n"}, {"uris": "src/main/java/org/ice4j/attribute/IceControlAttribute.java.IceControlAttribute.[char]getDataLength()", "name": "getDataLength", "arg_nums": 0, "params": [], "return_type": "char", "signature": "public char getDataLength()", "original_string": "    public char getDataLength()\n    {\n        return DATA_LENGTH_ICE_CONTROL;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/IceControlAttribute.java", "class_name": "IceControlAttribute", "class_uri": "src/main/java/org/ice4j/attribute/IceControlAttribute.java.IceControlAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "char", "classes": []}, "docstring": "\nReturns the data length of this attribute\n\n@return    the data length of this attribute\n"}, {"uris": "src/main/java/org/ice4j/attribute/IceControlAttribute.java.IceControlAttribute.[String]getName()", "name": "getName", "arg_nums": 0, "params": [], "return_type": "String", "signature": "public String getName()", "original_string": "    public String getName()\n    {\n        return isControlling ? \"ICE-CONTROLLING\" : \"ICE-CONTROLLED\";\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/IceControlAttribute.java", "class_name": "IceControlAttribute", "class_uri": "src/main/java/org/ice4j/attribute/IceControlAttribute.java.IceControlAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns the human readable name of this attribute.\n\n@return this attribute's name.\n"}, {"uris": "src/main/java/org/ice4j/attribute/IceControlAttribute.java.IceControlAttribute.[void]setTieBreaker(long)", "name": "setTieBreaker", "arg_nums": 1, "params": [{"name": "tieBreaker", "type": "long"}], "return_type": "void", "signature": "public void setTieBreaker(long tieBreaker)", "original_string": "    public void setTieBreaker(long tieBreaker)\n    {\n        this.tieBreaker = tieBreaker;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/IceControlAttribute.java", "class_name": "IceControlAttribute", "class_uri": "src/main/java/org/ice4j/attribute/IceControlAttribute.java.IceControlAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets the tie-breaker value.\n\n@param tieBreaker the the tie-breaker value\n"}, {"uris": "src/main/java/org/ice4j/attribute/IceControlAttribute.java.IceControlAttribute.[long]getTieBreaker()", "name": "getTieBreaker", "arg_nums": 0, "params": [], "return_type": "long", "signature": "public long getTieBreaker()", "original_string": "    public long getTieBreaker()\n    {\n        return tieBreaker;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/IceControlAttribute.java", "class_name": "IceControlAttribute", "class_uri": "src/main/java/org/ice4j/attribute/IceControlAttribute.java.IceControlAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "long", "classes": []}, "docstring": "\nReturns the value of the tie-breaker.\n\n@return the value of the tie-breaker.\n"}, {"uris": "src/main/java/org/ice4j/attribute/Attribute.java.Attribute.[]Attribute(char)", "name": "Attribute", "arg_nums": 1, "params": [{"name": "attributeType", "type": "char"}], "return_type": "", "signature": "protected Attribute(char attributeType)", "original_string": "    protected Attribute(char attributeType)\n    {\n        setAttributeType(attributeType);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/Attribute.java", "class_name": "Attribute", "class_uri": "src/main/java/org/ice4j/attribute/Attribute.java.Attribute", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nCreates an empty STUN message attribute.\n\n@param attributeType the type of the attribute.\n"}, {"uris": "src/main/java/org/ice4j/attribute/Attribute.java.Attribute.[char]getDataLength()", "name": "getDataLength", "arg_nums": 0, "params": [], "return_type": "char", "signature": "public abstract char getDataLength()", "original_string": "    public abstract char getDataLength();", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/Attribute.java", "class_name": "Attribute", "class_uri": "src/main/java/org/ice4j/attribute/Attribute.java.Attribute", "attributes": {"modifiers": "public abstract", "marker_annotations": [], "non_marker_annotations": ["public", "abstract"], "comments": [], "return_type": "char", "classes": []}, "docstring": "\nReturns the length of this attribute's body.\n\n@return the length of this attribute's value.\n"}, {"uris": "src/main/java/org/ice4j/attribute/Attribute.java.Attribute.[String]getName()", "name": "getName", "arg_nums": 0, "params": [], "return_type": "String", "signature": "public abstract String getName()", "original_string": "    public abstract String getName();", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/Attribute.java", "class_name": "Attribute", "class_uri": "src/main/java/org/ice4j/attribute/Attribute.java.Attribute", "attributes": {"modifiers": "public abstract", "marker_annotations": [], "non_marker_annotations": ["public", "abstract"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns the human readable name of this attribute. Attribute names do\nnot really matter from the protocol point of view. They are only used\nfor debugging and readability.\n\n@return this attribute's name.\n"}, {"uris": "src/main/java/org/ice4j/attribute/Attribute.java.Attribute.[char]getAttributeType()", "name": "getAttributeType", "arg_nums": 0, "params": [], "return_type": "char", "signature": "public char getAttributeType()", "original_string": "    public char getAttributeType()\n    {\n        return attributeType;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/Attribute.java", "class_name": "Attribute", "class_uri": "src/main/java/org/ice4j/attribute/Attribute.java.Attribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "char", "classes": []}, "docstring": "\nReturns the attribute's type.\n\n@return the type of this attribute.\n"}, {"uris": "src/main/java/org/ice4j/attribute/Attribute.java.Attribute.[void]setAttributeType(char)", "name": "setAttributeType", "arg_nums": 1, "params": [{"name": "type", "type": "char"}], "return_type": "void", "signature": "protected void setAttributeType(char type)", "original_string": "    protected void setAttributeType(char type)\n    {\n        this.attributeType = type;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/Attribute.java", "class_name": "Attribute", "class_uri": "src/main/java/org/ice4j/attribute/Attribute.java.Attribute", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets the attribute's type.\n\n@param type the new type of this attribute\n"}, {"uris": "src/main/java/org/ice4j/attribute/Attribute.java.Attribute.[boolean]equals(Object)", "name": "equals", "arg_nums": 1, "params": [{"name": "obj", "type": "Object"}], "return_type": "boolean", "signature": "@Override\n    public abstract boolean equals(Object obj)", "original_string": "    @Override\n    public abstract boolean equals(Object obj);", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/Attribute.java", "class_name": "Attribute", "class_uri": "src/main/java/org/ice4j/attribute/Attribute.java.Attribute", "attributes": {"modifiers": "@Override\n    public abstract", "marker_annotations": ["@Override"], "non_marker_annotations": ["public", "abstract"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nCompares two STUN Attributes. Two attributes are considered equal when\nthey have the same type length and value.\n\n@param obj the object to compare this attribute with.\n\n@return true if the attributes are equal and false otherwise.\n"}, {"uris": "src/main/java/org/ice4j/attribute/Attribute.java.Attribute.[byte[]]encode()", "name": "encode", "arg_nums": 0, "params": [], "return_type": "byte[]", "signature": "public abstract byte[] encode()", "original_string": "    public abstract byte[] encode();", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/Attribute.java", "class_name": "Attribute", "class_uri": "src/main/java/org/ice4j/attribute/Attribute.java.Attribute", "attributes": {"modifiers": "public abstract", "marker_annotations": [], "non_marker_annotations": ["public", "abstract"], "comments": [], "return_type": "byte[]", "classes": []}, "docstring": "\nReturns a binary representation of this attribute.\n\n@return a binary representation of this attribute.\n"}, {"uris": "src/main/java/org/ice4j/attribute/Attribute.java.Attribute.[void]setLocationInMessage(int)", "name": "setLocationInMessage", "arg_nums": 1, "params": [{"name": "index", "type": "int"}], "return_type": "void", "signature": "public void setLocationInMessage(int index)", "original_string": "    public void setLocationInMessage(int index)\n    {\n        this.locationInMessage = index;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/Attribute.java", "class_name": "Attribute", "class_uri": "src/main/java/org/ice4j/attribute/Attribute.java.Attribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nFor attributes that have arriving in incoming messages, this method\nstores their original location in the binary array so that we could\nlater more easily verify attributes like MESSAGE-INTEGRITY.\n\n@param index the original location of this attribute in the datagram\nwe got off the wire\n"}, {"uris": "src/main/java/org/ice4j/attribute/Attribute.java.Attribute.[int]getLocationInMessage()", "name": "getLocationInMessage", "arg_nums": 0, "params": [], "return_type": "int", "signature": "public int getLocationInMessage()", "original_string": "    public int getLocationInMessage()\n    {\n        return this.locationInMessage;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/Attribute.java", "class_name": "Attribute", "class_uri": "src/main/java/org/ice4j/attribute/Attribute.java.Attribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\nFor attributes that have arriving in incoming messages, this method\nreturns their original location in the binary array so that we could\nlater more easily verify attributes like MESSAGE-INTEGRITY.\n\n@return the original location of this attribute in the datagram\nwe got off the wire or -1 if this is not an incoming {@link Attribute}\n"}, {"uris": "src/main/java/org/ice4j/attribute/Attribute.java.Attribute.[void]decodeAttributeBody(byte[],char,char)", "name": "decodeAttributeBody", "arg_nums": 3, "params": [{"name": "attributeValue", "type": "byte[]"}, {"name": "offset", "type": "char"}, {"name": "length", "type": "char"}], "return_type": "void", "signature": "abstract void decodeAttributeBody( byte[] attributeValue,\n                                       char   offset,\n                                       char   length)", "original_string": "    abstract void decodeAttributeBody( byte[] attributeValue,\n                                       char   offset,\n                                       char   length)\n        throws StunException;", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/Attribute.java", "class_name": "Attribute", "class_uri": "src/main/java/org/ice4j/attribute/Attribute.java.Attribute", "attributes": {"modifiers": "abstract", "marker_annotations": [], "non_marker_annotations": ["abstract"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets this attribute's fields according to attributeValue array.\n\n@param attributeValue a binary array containing this attribute's field\nvalues and NOT containing the attribute header.\n@param offset the position where attribute values begin (most often\noffset is equal to the index of the first byte after length)\n@param length the length of the binary array.\n\n@throws StunException if attrubteValue contains invalid data.\n"}, {"uris": "src/main/java/org/ice4j/attribute/DataAttribute.java.DataAttribute.[]DataAttribute()", "name": "DataAttribute", "arg_nums": 0, "params": [], "return_type": "", "signature": "protected DataAttribute()", "original_string": "    protected DataAttribute()\n    {\n        this(true);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/DataAttribute.java", "class_name": "DataAttribute", "class_uri": "src/main/java/org/ice4j/attribute/DataAttribute.java.DataAttribute", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nCreates a new instance of this class with padding enabled.\n"}, {"uris": "src/main/java/org/ice4j/attribute/DataAttribute.java.DataAttribute.[]DataAttribute(boolean)", "name": "DataAttribute", "arg_nums": 1, "params": [{"name": "padding", "type": "boolean"}], "return_type": "", "signature": "protected DataAttribute(boolean padding)", "original_string": "    protected DataAttribute(boolean padding)\n    {\n        super(DATA);\n\n        this.padding = padding;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/DataAttribute.java", "class_name": "DataAttribute", "class_uri": "src/main/java/org/ice4j/attribute/DataAttribute.java.DataAttribute", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nCreates a new instance of this class.\n@param padding true to pad the data if the length is not on a word\nboundary.\n"}, {"uris": "src/main/java/org/ice4j/attribute/DataAttribute.java.DataAttribute.[void]decodeAttributeBody(byte[],char,char)", "name": "decodeAttributeBody", "arg_nums": 3, "params": [{"name": "attributeValue", "type": "byte[]"}, {"name": "offset", "type": "char"}, {"name": "length", "type": "char"}], "return_type": "void", "signature": "void decodeAttributeBody(byte[] attributeValue, char offset, char length)", "original_string": "    void decodeAttributeBody(byte[] attributeValue, char offset, char length)\n        throws StunException\n    {\n        data = new byte[length];\n          System.arraycopy(attributeValue, offset, data, 0, length);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/DataAttribute.java", "class_name": "DataAttribute", "class_uri": "src/main/java/org/ice4j/attribute/DataAttribute.java.DataAttribute", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCopies the value of the data attribute from the specified\nattributeValue.\n@param attributeValue a binary array containing this attribute's\n  field values and NOT containing the attribute header.\n@param offset the position where attribute values begin (most often\n  offset is equal to the index of the first byte after length)\n@param length the length of the binary array.\n@throws StunException if attributeValue contains invalid data.\n"}, {"uris": "src/main/java/org/ice4j/attribute/DataAttribute.java.DataAttribute.[byte[]]encode()", "name": "encode", "arg_nums": 0, "params": [], "return_type": "byte[]", "signature": "public byte[] encode()", "original_string": "    public byte[] encode()\n    {\n        char dataLength = getDataLength();\n        char type = getAttributeType();\n        byte binary[]\n            = new byte[\n                    HEADER_LENGTH\n                        + dataLength\n                        + (padding ? ((4 - dataLength % 4) % 4) : 0)];\n\n        //Type\n        binary[0] = (byte)(type >> 8);\n        binary[1] = (byte)(type & 0x00FF);\n\n        //Length\n        binary[2] = (byte)(dataLength >> 8);\n        binary[3] = (byte)(dataLength & 0x00FF);\n\n        //data\n        System.arraycopy(data, 0, binary, 4, dataLength);\n\n        return binary;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/DataAttribute.java", "class_name": "DataAttribute", "class_uri": "src/main/java/org/ice4j/attribute/DataAttribute.java.DataAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "byte[]", "classes": []}, "docstring": "\nReturns a binary representation of this attribute.\n@return a binary representation of this attribute.\n"}, {"uris": "src/main/java/org/ice4j/attribute/DataAttribute.java.DataAttribute.[char]getDataLength()", "name": "getDataLength", "arg_nums": 0, "params": [], "return_type": "char", "signature": "public char getDataLength()", "original_string": "    public char getDataLength()\n    {\n        return (char)data.length;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/DataAttribute.java", "class_name": "DataAttribute", "class_uri": "src/main/java/org/ice4j/attribute/DataAttribute.java.DataAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "char", "classes": []}, "docstring": "\nReturns the length of this attribute's body.\n@return the length of this attribute's value.\n"}, {"uris": "src/main/java/org/ice4j/attribute/DataAttribute.java.DataAttribute.[String]getName()", "name": "getName", "arg_nums": 0, "params": [], "return_type": "String", "signature": "public String getName()", "original_string": "    public String getName()\n    {\n        return NAME;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/DataAttribute.java", "class_name": "DataAttribute", "class_uri": "src/main/java/org/ice4j/attribute/DataAttribute.java.DataAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns the human readable name of this attribute.\n\n@return this attribute's name.\n"}, {"uris": "src/main/java/org/ice4j/attribute/DataAttribute.java.DataAttribute.[byte[]]getData()", "name": "getData", "arg_nums": 0, "params": [], "return_type": "byte[]", "signature": "public byte[] getData()", "original_string": "    public byte[] getData()\n    {\n        return (data == null) ? null : data.clone();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/DataAttribute.java", "class_name": "DataAttribute", "class_uri": "src/main/java/org/ice4j/attribute/DataAttribute.java.DataAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "byte[]", "classes": []}, "docstring": "\nReturns a (cloned) byte array containing the data value of the data\nattribute.\n@return the binary array containing the data.\n"}, {"uris": "src/main/java/org/ice4j/attribute/DataAttribute.java.DataAttribute.[void]setData(byte[])", "name": "setData", "arg_nums": 1, "params": [{"name": "data", "type": "byte[]"}], "return_type": "void", "signature": "public void setData(byte[] data)", "original_string": "    public void setData(byte[] data)\n    {\n        if (data == null)\n        {\n            this.data = null;\n            return;\n        }\n\n        this.data = new byte[data.length];\n        System.arraycopy(data, 0, this.data, 0, data.length);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/DataAttribute.java", "class_name": "DataAttribute", "class_uri": "src/main/java/org/ice4j/attribute/DataAttribute.java.DataAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCopies the specified binary array into the the data value of the data\nattribute.\n\n@param data the binary array containing the data.\n"}, {"uris": "src/main/java/org/ice4j/attribute/DataAttribute.java.DataAttribute.[boolean]equals(Object)", "name": "equals", "arg_nums": 1, "params": [{"name": "obj", "type": "Object"}], "return_type": "boolean", "signature": "public boolean equals(Object obj)", "original_string": "    public boolean equals(Object obj)\n    {\n        if (! (obj instanceof DataAttribute))\n            return false;\n\n        if (obj == this)\n            return true;\n\n        DataAttribute att = (DataAttribute) obj;\n        if (att.getAttributeType() != getAttributeType()\n                || att.getDataLength() != getDataLength()\n                || !Arrays.equals( att.data, data))\n            return false;\n\n        return true;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/DataAttribute.java", "class_name": "DataAttribute", "class_uri": "src/main/java/org/ice4j/attribute/DataAttribute.java.DataAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nCompares two STUN Attributes. Two attributes are considered equal when\nthey have the same type length and value.\n@param obj the object to compare this attribute with.\n@return true if the attributes are equal and false otherwise.\n"}, {"uris": "src/main/java/org/ice4j/attribute/ChangedAddressAttribute.java.ChangedAddressAttribute.[]ChangedAddressAttribute()", "name": "ChangedAddressAttribute", "arg_nums": 0, "params": [], "return_type": "", "signature": "public ChangedAddressAttribute()", "original_string": "    public ChangedAddressAttribute()\n    {\n        super(CHANGED_ADDRESS);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/ChangedAddressAttribute.java", "class_name": "ChangedAddressAttribute", "class_uri": "src/main/java/org/ice4j/attribute/ChangedAddressAttribute.java.ChangedAddressAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nCreates a CHANGED_ADDRESS attribute\n"}, {"uris": "src/main/java/org/ice4j/attribute/UseCandidateAttribute.java.UseCandidateAttribute.[]UseCandidateAttribute()", "name": "UseCandidateAttribute", "arg_nums": 0, "params": [], "return_type": "", "signature": "protected UseCandidateAttribute()", "original_string": "    protected UseCandidateAttribute()\n    {\n        super(USE_CANDIDATE);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/UseCandidateAttribute.java", "class_name": "UseCandidateAttribute", "class_uri": "src/main/java/org/ice4j/attribute/UseCandidateAttribute.java.UseCandidateAttribute", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nConstructor.\n"}, {"uris": "src/main/java/org/ice4j/attribute/UseCandidateAttribute.java.UseCandidateAttribute.[void]decodeAttributeBody(byte[],char,char)", "name": "decodeAttributeBody", "arg_nums": 3, "params": [{"name": "attributeValue", "type": "byte[]"}, {"name": "offset", "type": "char"}, {"name": "length", "type": "char"}], "return_type": "void", "signature": "void decodeAttributeBody(byte[] attributeValue, char offset, char length)", "original_string": "    void decodeAttributeBody(byte[] attributeValue, char offset, char length)\n            throws StunException\n    {\n        // Do nothing, empty attribute body\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/UseCandidateAttribute.java", "class_name": "UseCandidateAttribute", "class_uri": "src/main/java/org/ice4j/attribute/UseCandidateAttribute.java.UseCandidateAttribute", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nDecodes the USE-CANDIDATE attribute's body, which is empty\n\n@param attributeValue a binary array containing this attribute's\n  field values and NOT containing the attribute header.\n@param offset the position where attribute values begin (most often\n  offset is equal to the index of the first byte after length)\n@param length the length of the binary array.\n@throws StunException if attrubteValue contains invalid data.\n"}, {"uris": "src/main/java/org/ice4j/attribute/UseCandidateAttribute.java.UseCandidateAttribute.[byte[]]encode()", "name": "encode", "arg_nums": 0, "params": [], "return_type": "byte[]", "signature": "public byte[] encode()", "original_string": "    public byte[] encode()\n    {\n        char type = getAttributeType();\n        byte[] binValue = new byte[HEADER_LENGTH + DATA_LENGTH_USE_CANDIDATE];\n\n        // Type\n        binValue[0] = (byte)(type >> 8);\n        binValue[1] = (byte)(type & 0x00FF);\n\n        // Length\n        binValue[2] = (byte)(DATA_LENGTH_USE_CANDIDATE >> 8);\n        binValue[3] = (byte)(DATA_LENGTH_USE_CANDIDATE & 0x00FF);\n\n        return binValue;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/UseCandidateAttribute.java", "class_name": "UseCandidateAttribute", "class_uri": "src/main/java/org/ice4j/attribute/UseCandidateAttribute.java.UseCandidateAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "byte[]", "classes": []}, "docstring": "\nReturns a binary representation of this attribute.\n\n@return a binary representation of this attribute.\n"}, {"uris": "src/main/java/org/ice4j/attribute/UseCandidateAttribute.java.UseCandidateAttribute.[boolean]equals(Object)", "name": "equals", "arg_nums": 1, "params": [{"name": "obj", "type": "Object"}], "return_type": "boolean", "signature": "public boolean equals(Object obj)", "original_string": "    public boolean equals(Object obj)\n    {\n        if (!(obj instanceof UseCandidateAttribute))\n            return false;\n\n        if (obj == this)\n            return true;\n\n        UseCandidateAttribute useCandidateAtt = (UseCandidateAttribute)obj;\n        if (useCandidateAtt.getAttributeType() != getAttributeType()\n            || useCandidateAtt.getDataLength() != getDataLength())\n            return false;\n\n        return true;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/UseCandidateAttribute.java", "class_name": "UseCandidateAttribute", "class_uri": "src/main/java/org/ice4j/attribute/UseCandidateAttribute.java.UseCandidateAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nCompares two STUN Attributes. Two attributes are considered equal when\nthey have the same type, length and value.\n\n@param obj the object to compare this attribute with.\n@return true if the attributes are equal and false otherwise.\n"}, {"uris": "src/main/java/org/ice4j/attribute/UseCandidateAttribute.java.UseCandidateAttribute.[char]getDataLength()", "name": "getDataLength", "arg_nums": 0, "params": [], "return_type": "char", "signature": "public char getDataLength()", "original_string": "    public char getDataLength()\n    {\n        return DATA_LENGTH_USE_CANDIDATE;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/UseCandidateAttribute.java", "class_name": "UseCandidateAttribute", "class_uri": "src/main/java/org/ice4j/attribute/UseCandidateAttribute.java.UseCandidateAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "char", "classes": []}, "docstring": "\nReturns the length of this attribute's body.\n\n@return the length of this attribute's value.\n"}, {"uris": "src/main/java/org/ice4j/attribute/UseCandidateAttribute.java.UseCandidateAttribute.[String]getName()", "name": "getName", "arg_nums": 0, "params": [], "return_type": "String", "signature": "public String getName()", "original_string": "    public String getName()\n    {\n        return \"USE-CANDIDATE\";\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/UseCandidateAttribute.java", "class_name": "UseCandidateAttribute", "class_uri": "src/main/java/org/ice4j/attribute/UseCandidateAttribute.java.UseCandidateAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns the human readable name of this attribute.\n\n@return this attribute's name.\n"}, {"uris": "src/main/java/org/ice4j/attribute/NonceAttribute.java.NonceAttribute.[]NonceAttribute()", "name": "NonceAttribute", "arg_nums": 0, "params": [], "return_type": "", "signature": "NonceAttribute()", "original_string": "    NonceAttribute()\n    {\n        super(NONCE);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/NonceAttribute.java", "class_name": "NonceAttribute", "class_uri": "src/main/java/org/ice4j/attribute/NonceAttribute.java.NonceAttribute", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "docstring": "\nConstructor.\n"}, {"uris": "src/main/java/org/ice4j/attribute/NonceAttribute.java.NonceAttribute.[void]decodeAttributeBody(byte[],char,char)", "name": "decodeAttributeBody", "arg_nums": 3, "params": [{"name": "attributeValue", "type": "byte[]"}, {"name": "offset", "type": "char"}, {"name": "length", "type": "char"}], "return_type": "void", "signature": "void decodeAttributeBody(byte[] attributeValue, char offset, char length)", "original_string": "    void decodeAttributeBody(byte[] attributeValue, char offset, char length)\n        throws StunException\n    {\n        nonce = new byte[length];\n        System.arraycopy(attributeValue, offset, nonce, 0, length);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/NonceAttribute.java", "class_name": "NonceAttribute", "class_uri": "src/main/java/org/ice4j/attribute/NonceAttribute.java.NonceAttribute", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCopies the value of the nonce attribute from the specified\nattributeValue.\n@param attributeValue a binary array containing this attribute's\n  field values and NOT containing the attribute header.\n@param offset the position where attribute values begin (most often\n  offset is equal to the index of the first byte after length)\n@param length the length of the binary array.\n@throws StunException if attributeValue contains invalid data.\n"}, {"uris": "src/main/java/org/ice4j/attribute/NonceAttribute.java.NonceAttribute.[byte[]]encode()", "name": "encode", "arg_nums": 0, "params": [], "return_type": "byte[]", "signature": "public byte[] encode()", "original_string": "    public byte[] encode()\n    {\n        char type = getAttributeType();\n        byte binValue[]\n            = new byte[HEADER_LENGTH + getDataLength() + (getDataLength() % 4)];\n\n        //Type\n        binValue[0] = (byte)(type >> 8);\n        binValue[1] = (byte)(type & 0x00FF);\n\n        //Length\n        binValue[2] = (byte)(getDataLength() >> 8);\n        binValue[3] = (byte)(getDataLength() & 0x00FF);\n\n        /* nonce */\n        System.arraycopy(nonce, 0, binValue, 4, (int)getDataLength());\n\n        return binValue;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/NonceAttribute.java", "class_name": "NonceAttribute", "class_uri": "src/main/java/org/ice4j/attribute/NonceAttribute.java.NonceAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "byte[]", "classes": []}, "docstring": "\nReturns a binary representation of this attribute.\n@return a binary representation of this attribute.\n"}, {"uris": "src/main/java/org/ice4j/attribute/NonceAttribute.java.NonceAttribute.[char]getDataLength()", "name": "getDataLength", "arg_nums": 0, "params": [], "return_type": "char", "signature": "public char getDataLength()", "original_string": "    public char getDataLength()\n    {\n        return (char)nonce.length;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/NonceAttribute.java", "class_name": "NonceAttribute", "class_uri": "src/main/java/org/ice4j/attribute/NonceAttribute.java.NonceAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "char", "classes": []}, "docstring": "\nReturns the length of this attribute's body.\n@return the length of this attribute's value.\n"}, {"uris": "src/main/java/org/ice4j/attribute/NonceAttribute.java.NonceAttribute.[String]getName()", "name": "getName", "arg_nums": 0, "params": [], "return_type": "String", "signature": "public String getName()", "original_string": "    public String getName()\n    {\n        return NAME;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/NonceAttribute.java", "class_name": "NonceAttribute", "class_uri": "src/main/java/org/ice4j/attribute/NonceAttribute.java.NonceAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns the human readable name of this attribute.\n@return this attribute's name.\n"}, {"uris": "src/main/java/org/ice4j/attribute/NonceAttribute.java.NonceAttribute.[byte[]]getNonce()", "name": "getNonce", "arg_nums": 0, "params": [], "return_type": "byte[]", "signature": "public byte[] getNonce()", "original_string": "    public byte[] getNonce()\n    {\n        return (nonce == null) ? null : nonce.clone();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/NonceAttribute.java", "class_name": "NonceAttribute", "class_uri": "src/main/java/org/ice4j/attribute/NonceAttribute.java.NonceAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "byte[]", "classes": []}, "docstring": "\nReturns a (cloned) byte array containing the data value of the nonce\nattribute.\n@return the binary array containing the nonce.\n"}, {"uris": "src/main/java/org/ice4j/attribute/NonceAttribute.java.NonceAttribute.[void]setNonce(byte[])", "name": "setNonce", "arg_nums": 1, "params": [{"name": "nonce", "type": "byte[]"}], "return_type": "void", "signature": "public void setNonce(byte[] nonce)", "original_string": "    public void setNonce(byte[] nonce)\n    {\n        this.nonce = (nonce == null) ? null : nonce.clone();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/NonceAttribute.java", "class_name": "NonceAttribute", "class_uri": "src/main/java/org/ice4j/attribute/NonceAttribute.java.NonceAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCopies the specified binary array into the the data value of the nonce\nattribute.\n@param nonce the binary array containing the nonce.\n"}, {"uris": "src/main/java/org/ice4j/attribute/NonceAttribute.java.NonceAttribute.[boolean]equals(Object)", "name": "equals", "arg_nums": 1, "params": [{"name": "obj", "type": "Object"}], "return_type": "boolean", "signature": "public boolean equals(Object obj)", "original_string": "    public boolean equals(Object obj)\n    {\n        if (obj == this)\n            return true;\n        if (! (obj instanceof NonceAttribute))\n            return false;\n\n        NonceAttribute att = (NonceAttribute) obj;\n\n        return\n            (att.getAttributeType() == getAttributeType()\n                && att.getDataLength() == getDataLength()\n                && Arrays.equals(att.nonce, nonce));\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/NonceAttribute.java", "class_name": "NonceAttribute", "class_uri": "src/main/java/org/ice4j/attribute/NonceAttribute.java.NonceAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nCompares two STUN Attributes. Two attributes are considered equal when they\nhave the same type length and value.\n@param obj the object to compare this attribute with.\n@return true if the attributes are equal and false otherwise.\n"}, {"uris": "src/main/java/org/ice4j/attribute/AttributeDecoder.java.AttributeDecoder.[Attribute]decode(byte[],int,int)", "name": "decode", "arg_nums": 3, "params": [{"name": "bytes", "type": "byte[]"}, {"name": "offset", "type": "int"}, {"name": "length", "type": "int"}], "return_type": "Attribute", "signature": "public static Attribute decode(byte[] bytes,\n                                   int   offset,\n                                   int   length)", "original_string": "    public static Attribute decode(byte[] bytes,\n                                   int   offset,\n                                   int   length)\n        throws StunException\n    {\n        if (bytes == null || bytes.length < Attribute.HEADER_LENGTH)\n        {\n            throw new StunException( StunException.ILLEGAL_ARGUMENT,\n                         \"Could not decode the specified binary array.\");\n        }\n\n        //Discover attribute type\n        char attributeType = (char)\n            (((bytes[offset] & 0xFF) << 8) | (bytes[offset + 1] & 0xFF));\n        char attributeLength = (char)\n            (((bytes[offset + 2] & 0xFF) << 8) | (bytes[offset + 3] & 0xFF));\n\n        if (attributeLength > bytes.length - offset )\n            throw new StunException( StunException.ILLEGAL_ARGUMENT,\n                            \"Could not decode the specified binary array.\");\n\n        Attribute decodedAttribute = null;\n\n        switch(attributeType)\n        {\n            /* STUN attributes */\n            case Attribute.CHANGE_REQUEST:\n                decodedAttribute = new ChangeRequestAttribute(); break;\n            case Attribute.CHANGED_ADDRESS:\n                decodedAttribute = new ChangedAddressAttribute(); break;\n            case Attribute.MAPPED_ADDRESS:\n                decodedAttribute = new MappedAddressAttribute(); break;\n            case Attribute.ERROR_CODE:\n                decodedAttribute = new ErrorCodeAttribute(); break;\n            case Attribute.MESSAGE_INTEGRITY:\n                decodedAttribute = new MessageIntegrityAttribute(); break;\n            //case Attribute.PASSWORD: //handle as an unknown attribute\n            case Attribute.REFLECTED_FROM:\n                decodedAttribute = new ReflectedFromAttribute(); break;\n            case Attribute.RESPONSE_ADDRESS:\n                decodedAttribute = new ResponseAddressAttribute(); break;\n            case Attribute.SOURCE_ADDRESS:\n                decodedAttribute = new SourceAddressAttribute(); break;\n            case Attribute.UNKNOWN_ATTRIBUTES:\n                decodedAttribute = new UnknownAttributesAttribute(); break;\n            case Attribute.XOR_MAPPED_ADDRESS:\n                decodedAttribute = new XorMappedAddressAttribute(); break;\n            case Attribute.XOR_ONLY:\n                decodedAttribute = new XorOnlyAttribute(); break;\n            case Attribute.SOFTWARE:\n                decodedAttribute = new SoftwareAttribute(); break;\n            case Attribute.USERNAME:\n                decodedAttribute = new UsernameAttribute(); break;\n            case Attribute.REALM:\n                decodedAttribute = new RealmAttribute(); break;\n            case Attribute.NONCE:\n                decodedAttribute = new NonceAttribute(); break;\n            case Attribute.FINGERPRINT:\n                decodedAttribute = new FingerprintAttribute(); break;\n            case Attribute.ALTERNATE_SERVER:\n                decodedAttribute = new AlternateServerAttribute(); break;\n            case Attribute.CHANNEL_NUMBER:\n                decodedAttribute = new ChannelNumberAttribute(); break;\n            case Attribute.LIFETIME:\n                decodedAttribute = new LifetimeAttribute(); break;\n            case Attribute.XOR_PEER_ADDRESS:\n                decodedAttribute = new XorPeerAddressAttribute(); break;\n            case Attribute.DATA:\n                decodedAttribute = new DataAttribute(); break;\n            case Attribute.XOR_RELAYED_ADDRESS:\n                decodedAttribute = new XorRelayedAddressAttribute(); break;\n            case Attribute.EVEN_PORT:\n                decodedAttribute = new EvenPortAttribute(); break;\n            case Attribute.REQUESTED_TRANSPORT:\n                decodedAttribute = new RequestedTransportAttribute(); break;\n            case Attribute.DONT_FRAGMENT:\n                decodedAttribute = new DontFragmentAttribute(); break;\n            case Attribute.RESERVATION_TOKEN:\n                decodedAttribute = new ReservationTokenAttribute(); break;\n            case Attribute.PRIORITY:\n                decodedAttribute = new PriorityAttribute(); break;\n            case Attribute.ICE_CONTROLLING:\n                decodedAttribute = new IceControllingAttribute(); break;\n            case Attribute.ICE_CONTROLLED:\n                decodedAttribute = new IceControlledAttribute(); break;\n            case Attribute.USE_CANDIDATE:\n                decodedAttribute = new UseCandidateAttribute(); break;\n            case Attribute.REQUESTED_ADDRESS_FAMILY:\n                decodedAttribute = new RequestedAddressFamilyAttribute(); break;\n            case Attribute.CONNECTION_ID:\n                decodedAttribute = new ConnectionIdAttribute(); break;\n            //According to rfc3489 we should silently ignore unknown attributes.\n            default: decodedAttribute\n                = new OptionalAttribute( Attribute.UNKNOWN_OPTIONAL_ATTRIBUTE);\n                break;\n        }\n\n        decodedAttribute.setAttributeType(attributeType);\n        decodedAttribute.setLocationInMessage(offset);\n\n        decodedAttribute.decodeAttributeBody(bytes,\n                (char)(Attribute.HEADER_LENGTH + offset), attributeLength);\n\n        return decodedAttribute;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/AttributeDecoder.java", "class_name": "AttributeDecoder", "class_uri": "src/main/java/org/ice4j/attribute/AttributeDecoder.java.AttributeDecoder", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Attribute", "classes": []}, "docstring": "\nDecodes the specified binary array and returns the corresponding\nattribute object.\n\n@param bytes the binary array that should be decoded.\n@param offset the index where the message starts.\n@param length the number of bytes that the message is long.\n\n@return An object representing the attribute encoded in bytes or null if\nthe attribute was not recognized.\n\n@throws StunException if bytes is not a valid STUN attribute.\n"}, {"uris": "src/main/java/org/ice4j/attribute/ResponseAddressAttribute.java.ResponseAddressAttribute.[]ResponseAddressAttribute()", "name": "ResponseAddressAttribute", "arg_nums": 0, "params": [], "return_type": "", "signature": "public ResponseAddressAttribute()", "original_string": "    public ResponseAddressAttribute()\n    {\n        super(RESPONSE_ADDRESS);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/ResponseAddressAttribute.java", "class_name": "ResponseAddressAttribute", "class_uri": "src/main/java/org/ice4j/attribute/ResponseAddressAttribute.java.ResponseAddressAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nCreates a RESPONSE_ADDRESS attribute\n"}, {"uris": "src/main/java/org/ice4j/attribute/AlternateServerAttribute.java.AlternateServerAttribute.[]AlternateServerAttribute()", "name": "AlternateServerAttribute", "arg_nums": 0, "params": [], "return_type": "", "signature": "AlternateServerAttribute()", "original_string": "    AlternateServerAttribute()\n    {\n        super(ALTERNATE_SERVER);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/AlternateServerAttribute.java", "class_name": "AlternateServerAttribute", "class_uri": "src/main/java/org/ice4j/attribute/AlternateServerAttribute.java.AlternateServerAttribute", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "docstring": "\nConstructor.\n"}, {"uris": "src/main/java/org/ice4j/attribute/ChannelNumberAttribute.java.ChannelNumberAttribute.[]ChannelNumberAttribute()", "name": "ChannelNumberAttribute", "arg_nums": 0, "params": [], "return_type": "", "signature": "ChannelNumberAttribute()", "original_string": "    ChannelNumberAttribute()\n    {\n        super(CHANNEL_NUMBER);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/ChannelNumberAttribute.java", "class_name": "ChannelNumberAttribute", "class_uri": "src/main/java/org/ice4j/attribute/ChannelNumberAttribute.java.ChannelNumberAttribute", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "docstring": "\nConstructor.\n"}, {"uris": "src/main/java/org/ice4j/attribute/ChannelNumberAttribute.java.ChannelNumberAttribute.[boolean]equals(Object)", "name": "equals", "arg_nums": 1, "params": [{"name": "obj", "type": "Object"}], "return_type": "boolean", "signature": "@Override\n    public boolean equals(Object obj)", "original_string": "    @Override\n    public boolean equals(Object obj)\n    {\n        if (! (obj instanceof ChannelNumberAttribute))\n            return false;\n\n        if (obj == this)\n            return true;\n\n        ChannelNumberAttribute att = (ChannelNumberAttribute) obj;\n        if (att.getAttributeType()   != getAttributeType()\n                || att.getDataLength()   != getDataLength()\n                /* compare data */\n                || att.channelNumber != channelNumber\n           )\n            return false;\n\n        return true;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/ChannelNumberAttribute.java", "class_name": "ChannelNumberAttribute", "class_uri": "src/main/java/org/ice4j/attribute/ChannelNumberAttribute.java.ChannelNumberAttribute", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nCompares two STUN Attributes. Attributes are considered equal when their\ntype, length, and all data are the same.\n@param obj the object to compare this attribute with.\n@return true if the attributes are equal and false otherwise.\n"}, {"uris": "src/main/java/org/ice4j/attribute/ChannelNumberAttribute.java.ChannelNumberAttribute.[String]getName()", "name": "getName", "arg_nums": 0, "params": [], "return_type": "String", "signature": "@Override\n    public String getName()", "original_string": "    @Override\n    public String getName()\n    {\n        return NAME;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/ChannelNumberAttribute.java", "class_name": "ChannelNumberAttribute", "class_uri": "src/main/java/org/ice4j/attribute/ChannelNumberAttribute.java.ChannelNumberAttribute", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns the human readable name of this attribute. Attribute names do\nnot really matter from the protocol point of view. They are only used\nfor debugging and readability.\n@return this attribute's name.\n"}, {"uris": "src/main/java/org/ice4j/attribute/ChannelNumberAttribute.java.ChannelNumberAttribute.[char]getDataLength()", "name": "getDataLength", "arg_nums": 0, "params": [], "return_type": "char", "signature": "@Override\n    public char getDataLength()", "original_string": "    @Override\n    public char getDataLength()\n    {\n        return DATA_LENGTH;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/ChannelNumberAttribute.java", "class_name": "ChannelNumberAttribute", "class_uri": "src/main/java/org/ice4j/attribute/ChannelNumberAttribute.java.ChannelNumberAttribute", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "char", "classes": []}, "docstring": "\nReturns the length of this attribute's body.\n@return the length of this attribute's value (8 bytes).\n"}, {"uris": "src/main/java/org/ice4j/attribute/ChannelNumberAttribute.java.ChannelNumberAttribute.[byte[]]encode()", "name": "encode", "arg_nums": 0, "params": [], "return_type": "byte[]", "signature": "@Override\n    public byte[] encode()", "original_string": "    @Override\n    public byte[] encode()\n    {\n        byte binValue[] = new byte[HEADER_LENGTH + DATA_LENGTH];\n\n        //Type\n        binValue[0] = (byte)(getAttributeType() >> 8);\n        binValue[1] = (byte)(getAttributeType() & 0x00FF);\n        //Length\n        binValue[2] = (byte)(getDataLength() >> 8);\n        binValue[3] = (byte)(getDataLength() & 0x00FF);\n        //Data\n        binValue[4] = (byte)((channelNumber >> 8) & 0xff);\n        binValue[5] = (byte)((channelNumber) & 0xff);\n        binValue[6] = 0x00;\n        binValue[7] = 0x00;\n\n        return binValue;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/ChannelNumberAttribute.java", "class_name": "ChannelNumberAttribute", "class_uri": "src/main/java/org/ice4j/attribute/ChannelNumberAttribute.java.ChannelNumberAttribute", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "byte[]", "classes": []}, "docstring": "\nReturns a binary representation of this attribute.\n@return a binary representation of this attribute.\n"}, {"uris": "src/main/java/org/ice4j/attribute/ChannelNumberAttribute.java.ChannelNumberAttribute.[void]decodeAttributeBody(byte[],char,char)", "name": "decodeAttributeBody", "arg_nums": 3, "params": [{"name": "attributeValue", "type": "byte[]"}, {"name": "offset", "type": "char"}, {"name": "length", "type": "char"}], "return_type": "void", "signature": "@Override\n    void decodeAttributeBody(byte[] attributeValue, char offset, char length)", "original_string": "    @Override\n    void decodeAttributeBody(byte[] attributeValue, char offset, char length)\n        throws StunException\n    {\n        if (length != 4)\n        {\n            throw new StunException(\"length invalid\");\n        }\n\n        channelNumber =\n            ((char) ((attributeValue[offset] << 8) \n                | (attributeValue[offset + 1] & 0xFF)));\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/ChannelNumberAttribute.java", "class_name": "ChannelNumberAttribute", "class_uri": "src/main/java/org/ice4j/attribute/ChannelNumberAttribute.java.ChannelNumberAttribute", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets this attribute's fields according to attributeValue array.\n@param attributeValue a binary array containing this attribute's field\n                      values and NOT containing the attribute header.\n@param offset the position where attribute values begin (most often\n         offset is equal to the index of the first byte after\n         length)\n@param length the length of the binary array.\n@throws StunException if attrubteValue contains invalid data.\n"}, {"uris": "src/main/java/org/ice4j/attribute/ChannelNumberAttribute.java.ChannelNumberAttribute.[void]setChannelNumber(char)", "name": "setChannelNumber", "arg_nums": 1, "params": [{"name": "channelNumber", "type": "char"}], "return_type": "void", "signature": "public void setChannelNumber(char channelNumber)", "original_string": "    public void setChannelNumber(char channelNumber)\n    {\n        this.channelNumber = channelNumber;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/ChannelNumberAttribute.java", "class_name": "ChannelNumberAttribute", "class_uri": "src/main/java/org/ice4j/attribute/ChannelNumberAttribute.java.ChannelNumberAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSet the channel number.\n@param channelNumber channel number\n"}, {"uris": "src/main/java/org/ice4j/attribute/ChannelNumberAttribute.java.ChannelNumberAttribute.[char]getChannelNumber()", "name": "getChannelNumber", "arg_nums": 0, "params": [], "return_type": "char", "signature": "public char getChannelNumber()", "original_string": "    public char getChannelNumber()\n    {\n        return channelNumber;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/ChannelNumberAttribute.java", "class_name": "ChannelNumberAttribute", "class_uri": "src/main/java/org/ice4j/attribute/ChannelNumberAttribute.java.ChannelNumberAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "char", "classes": []}, "docstring": "\nGet the channel number.\n@return channel number\n"}, {"uris": "src/main/java/org/ice4j/attribute/ChannelNumberAttribute.java.ChannelNumberAttribute.[boolean]isValidRange(char)", "name": "isValidRange", "arg_nums": 1, "params": [{"name": "channelNo", "type": "char"}], "return_type": "boolean", "signature": "public static boolean isValidRange(char channelNo)", "original_string": "    public static boolean isValidRange(char channelNo)\n    {\n        if (channelNo >= 0x4000)\n        {\n            return true;\n        }\n        return false;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/ChannelNumberAttribute.java", "class_name": "ChannelNumberAttribute", "class_uri": "src/main/java/org/ice4j/attribute/ChannelNumberAttribute.java.ChannelNumberAttribute", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nDetermines if the channelNo is in valid range.\n@param channelNo the channelNo to validate.\n@return true if channnelNo is &gt;= 0x4000.\n"}, {"uris": "src/main/java/org/ice4j/attribute/ConnectionIdAttribute.java.ConnectionIdAttribute.[]ConnectionIdAttribute()", "name": "ConnectionIdAttribute", "arg_nums": 0, "params": [], "return_type": "", "signature": "protected ConnectionIdAttribute()", "original_string": "    protected ConnectionIdAttribute() \n    {\n        super(CONNECTION_ID);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/ConnectionIdAttribute.java", "class_name": "ConnectionIdAttribute", "class_uri": "src/main/java/org/ice4j/attribute/ConnectionIdAttribute.java.ConnectionIdAttribute", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nConstructor.\n"}, {"uris": "src/main/java/org/ice4j/attribute/ConnectionIdAttribute.java.ConnectionIdAttribute.[char]getDataLength()", "name": "getDataLength", "arg_nums": 0, "params": [], "return_type": "char", "signature": "@Override\n    public char getDataLength()", "original_string": "    @Override\n    public char getDataLength() \n    {\n        return DATA_LENGTH;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/ConnectionIdAttribute.java", "class_name": "ConnectionIdAttribute", "class_uri": "src/main/java/org/ice4j/attribute/ConnectionIdAttribute.java.ConnectionIdAttribute", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "char", "classes": []}, "docstring": "\nReturns the length of this attribute body.\n@return the length of this attribute value (4 bytes).\n"}, {"uris": "src/main/java/org/ice4j/attribute/ConnectionIdAttribute.java.ConnectionIdAttribute.[String]getName()", "name": "getName", "arg_nums": 0, "params": [], "return_type": "String", "signature": "@Override\n    public String getName()", "original_string": "    @Override\n    public String getName() \n    {\n        return NAME;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/ConnectionIdAttribute.java", "class_name": "ConnectionIdAttribute", "class_uri": "src/main/java/org/ice4j/attribute/ConnectionIdAttribute.java.ConnectionIdAttribute", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns the human readable name of this attribute. Attribute names do\nnot really matter from the protocol point of view. They are only used\nfor debugging and readability.\n@return this attribute's name.\n"}, {"uris": "src/main/java/org/ice4j/attribute/ConnectionIdAttribute.java.ConnectionIdAttribute.[boolean]equals(Object)", "name": "equals", "arg_nums": 1, "params": [{"name": "obj", "type": "Object"}], "return_type": "boolean", "signature": "@Override\n    public boolean equals(Object obj)", "original_string": "    @Override\n    public boolean equals(Object obj) \n    {\n        if (! (obj instanceof ConnectionIdAttribute))\n            return false;\n\n        if (obj == this)\n            return true;\n\n        ConnectionIdAttribute att = (ConnectionIdAttribute) obj;\n        if (att.getAttributeType() != getAttributeType()\n                || att.getDataLength() != getDataLength()\n                /* compare data */\n                || att.connectionIdValue != this.connectionIdValue\n           )\n            return false;\n\n        return true;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/ConnectionIdAttribute.java", "class_name": "ConnectionIdAttribute", "class_uri": "src/main/java/org/ice4j/attribute/ConnectionIdAttribute.java.ConnectionIdAttribute", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nCompares two TURN Attributes. Attributes are considered equal when their\ntype, length, and all data are the same.\n@param obj the object to compare this attribute with.\n@return true if the attributes are equal and false otherwise.\n"}, {"uris": "src/main/java/org/ice4j/attribute/ConnectionIdAttribute.java.ConnectionIdAttribute.[byte[]]encode()", "name": "encode", "arg_nums": 0, "params": [], "return_type": "byte[]", "signature": "@Override\n    public byte[] encode()", "original_string": "    @Override\n    public byte[] encode() \n    {\n        byte binValue[] = new byte[HEADER_LENGTH + DATA_LENGTH];\n\n        //Type\n        binValue[0] = (byte)(getAttributeType() >> 8);\n        binValue[1] = (byte)(getAttributeType() & 0x00FF);\n        //Length\n        binValue[2] = (byte)(getDataLength() >> 8);\n        binValue[3] = (byte)(getDataLength() & 0x00FF);\n        //Data\n        binValue[4] = (byte) (connectionIdValue >> 24);\n        binValue[5] = (byte) ((connectionIdValue & 0x00ff0000) >> 16);\n        binValue[6] = (byte) ((connectionIdValue & 0x0000ff00) >> 8);\n        binValue[7] = (byte) (connectionIdValue & 0x000000ff);\n\n        return binValue;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/ConnectionIdAttribute.java", "class_name": "ConnectionIdAttribute", "class_uri": "src/main/java/org/ice4j/attribute/ConnectionIdAttribute.java.ConnectionIdAttribute", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "byte[]", "classes": []}, "docstring": "\nReturns a binary representation of this attribute.\n@return a binary representation of this attribute.\n"}, {"uris": "src/main/java/org/ice4j/attribute/ConnectionIdAttribute.java.ConnectionIdAttribute.[void]decodeAttributeBody(byte[],char,char)", "name": "decodeAttributeBody", "arg_nums": 3, "params": [{"name": "attributeValue", "type": "byte[]"}, {"name": "offset", "type": "char"}, {"name": "length", "type": "char"}], "return_type": "void", "signature": "@Override\n    void decodeAttributeBody(byte[] attributeValue, char offset, char length)", "original_string": "    @Override\n    void decodeAttributeBody(byte[] attributeValue, char offset, char length) \n        throws StunException\n    {\n        if (length != DATA_LENGTH)\n        {\n            throw new StunException(\"length invalid: \" + length);\n        }\n\n        connectionIdValue = attributeValue[offset] & 0xff;\n\n        connectionIdValue = connectionIdValue << 8 |\n            (attributeValue[offset+1] & 0xff);\n\n        connectionIdValue = connectionIdValue << 8 |\n            (attributeValue[offset+2] & 0xff);\n\n        connectionIdValue = connectionIdValue << 8 |\n            (attributeValue[offset+3] & 0xff);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/ConnectionIdAttribute.java", "class_name": "ConnectionIdAttribute", "class_uri": "src/main/java/org/ice4j/attribute/ConnectionIdAttribute.java.ConnectionIdAttribute", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets this attribute's fields according to attributeValue array.\n@param attributeValue a binary array containing this attribute's field\n                      values and NOT containing the attribute header.\n@param offset the position where attribute values begin (most often\n         offset is equal to the index of the first byte after\n         length)\n@param length the length of the binary array.\n@throws StunException if attributeValue contains invalid data.\n"}, {"uris": "src/main/java/org/ice4j/attribute/ConnectionIdAttribute.java.ConnectionIdAttribute.[int]getConnectionIdValue()", "name": "getConnectionIdValue", "arg_nums": 0, "params": [], "return_type": "int", "signature": "public int getConnectionIdValue()", "original_string": "    public int getConnectionIdValue() \n    {\n        return connectionIdValue;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/ConnectionIdAttribute.java", "class_name": "ConnectionIdAttribute", "class_uri": "src/main/java/org/ice4j/attribute/ConnectionIdAttribute.java.ConnectionIdAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\nGets the Connection-Id Value\n@return Connection-Id Value\n"}, {"uris": "src/main/java/org/ice4j/attribute/ConnectionIdAttribute.java.ConnectionIdAttribute.[void]setConnectionIdValue(int)", "name": "setConnectionIdValue", "arg_nums": 1, "params": [{"name": "connectionIdValue", "type": "int"}], "return_type": "void", "signature": "public void setConnectionIdValue(int connectionIdValue)", "original_string": "    public void setConnectionIdValue(int connectionIdValue) \n    {    \n        this.connectionIdValue = connectionIdValue;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/ConnectionIdAttribute.java", "class_name": "ConnectionIdAttribute", "class_uri": "src/main/java/org/ice4j/attribute/ConnectionIdAttribute.java.ConnectionIdAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets the Connection-Id Value\n@param connectionIdValue the connection Id value.\n"}, {"uris": "src/main/java/org/ice4j/attribute/XorPeerAddressAttribute.java.XorPeerAddressAttribute.[]XorPeerAddressAttribute()", "name": "XorPeerAddressAttribute", "arg_nums": 0, "params": [], "return_type": "", "signature": "XorPeerAddressAttribute()", "original_string": "    XorPeerAddressAttribute()\n    {\n        super(XOR_PEER_ADDRESS);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/XorPeerAddressAttribute.java", "class_name": "XorPeerAddressAttribute", "class_uri": "src/main/java/org/ice4j/attribute/XorPeerAddressAttribute.java.XorPeerAddressAttribute", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "docstring": "\nConstructor.\n"}, {"uris": "src/main/java/org/ice4j/attribute/MagicCookieAttribute.java.MagicCookieAttribute.[]MagicCookieAttribute()", "name": "MagicCookieAttribute", "arg_nums": 0, "params": [], "return_type": "", "signature": "MagicCookieAttribute()", "original_string": "    MagicCookieAttribute()\n    {\n        super(MAGIC_COOKIE);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/MagicCookieAttribute.java", "class_name": "MagicCookieAttribute", "class_uri": "src/main/java/org/ice4j/attribute/MagicCookieAttribute.java.MagicCookieAttribute", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "docstring": "\nConstructor.\n"}, {"uris": "src/main/java/org/ice4j/attribute/MagicCookieAttribute.java.MagicCookieAttribute.[String]getName()", "name": "getName", "arg_nums": 0, "params": [], "return_type": "String", "signature": "public String getName()", "original_string": "    public String getName()\n    {\n        return NAME;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/MagicCookieAttribute.java", "class_name": "MagicCookieAttribute", "class_uri": "src/main/java/org/ice4j/attribute/MagicCookieAttribute.java.MagicCookieAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns the human readable name of this attribute. Attribute names do\nnot really matter from the protocol point of view. They are only used\nfor debugging and readability.\n\n@return this attribute's name.\n"}, {"uris": "src/main/java/org/ice4j/attribute/MagicCookieAttribute.java.MagicCookieAttribute.[char]getDataLength()", "name": "getDataLength", "arg_nums": 0, "params": [], "return_type": "char", "signature": "public char getDataLength()", "original_string": "    public char getDataLength()\n    {\n        return DATA_LENGTH;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/MagicCookieAttribute.java", "class_name": "MagicCookieAttribute", "class_uri": "src/main/java/org/ice4j/attribute/MagicCookieAttribute.java.MagicCookieAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "char", "classes": []}, "docstring": "\nReturns the length of this attribute's body.\n\n@return the length of this attribute's value (8 bytes).\n"}, {"uris": "src/main/java/org/ice4j/attribute/MagicCookieAttribute.java.MagicCookieAttribute.[boolean]equals(Object)", "name": "equals", "arg_nums": 1, "params": [{"name": "obj", "type": "Object"}], "return_type": "boolean", "signature": "public boolean equals(Object obj)", "original_string": "    public boolean equals(Object obj)\n    {\n        if (! (obj instanceof MagicCookieAttribute))\n            return false;\n\n        if (obj == this)\n            return true;\n\n        MagicCookieAttribute att = (MagicCookieAttribute) obj;\n        if (att.getAttributeType()   != getAttributeType()\n                || att.getDataLength() != getDataLength()\n                /* compare data */\n                || att.value != value\n           )\n            return false;\n\n        return true;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/MagicCookieAttribute.java", "class_name": "MagicCookieAttribute", "class_uri": "src/main/java/org/ice4j/attribute/MagicCookieAttribute.java.MagicCookieAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nCompares two STUN Attributes. Attributes are considered equal when their\ntype, length, and all data are the same.\n\n@param obj the object to compare this attribute with.\n@return true if the attributes are equal and false otherwise.\n"}, {"uris": "src/main/java/org/ice4j/attribute/MagicCookieAttribute.java.MagicCookieAttribute.[byte[]]encode()", "name": "encode", "arg_nums": 0, "params": [], "return_type": "byte[]", "signature": "public byte[] encode()", "original_string": "    public byte[] encode()\n    {\n        byte binValue[] = new byte[HEADER_LENGTH + DATA_LENGTH];\n\n        //Type\n        binValue[0] = (byte)(getAttributeType() >> 8);\n        binValue[1] = (byte)(getAttributeType() & 0x00FF);\n        //Length\n        binValue[2] = (byte)(getDataLength() >> 8);\n        binValue[3] = (byte)(getDataLength() & 0x00FF);\n        //Data\n        binValue[4] = (byte)((value >> 24) & 0xff);\n        binValue[5] = (byte)((value >> 16) & 0xff);\n        binValue[6] = (byte)((value >> 8) & 0xff);\n        binValue[7] = (byte)((value) & 0xff);\n\n        return binValue;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/MagicCookieAttribute.java", "class_name": "MagicCookieAttribute", "class_uri": "src/main/java/org/ice4j/attribute/MagicCookieAttribute.java.MagicCookieAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "byte[]", "classes": []}, "docstring": "\nReturns a binary representation of this attribute.\n\n@return a binary representation of this attribute.\n"}, {"uris": "src/main/java/org/ice4j/attribute/MagicCookieAttribute.java.MagicCookieAttribute.[void]decodeAttributeBody(byte[],char,char)", "name": "decodeAttributeBody", "arg_nums": 3, "params": [{"name": "attributeValue", "type": "byte[]"}, {"name": "offset", "type": "char"}, {"name": "length", "type": "char"}], "return_type": "void", "signature": "void decodeAttributeBody(byte[] attributeValue, char offset, char length)", "original_string": "    void decodeAttributeBody(byte[] attributeValue, char offset, char length)\n            throws StunException\n    {\n        if (length != 4)\n        {\n            throw new StunException(\"length invalid\");\n        }\n\n        value = ((attributeValue[0] << 24) & 0xff000000) +\n            ((attributeValue[1] << 16) & 0x00ff0000) +\n            ((attributeValue[2] << 8) & 0x0000ff00) +\n            (attributeValue[3] & 0x000000ff);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/MagicCookieAttribute.java", "class_name": "MagicCookieAttribute", "class_uri": "src/main/java/org/ice4j/attribute/MagicCookieAttribute.java.MagicCookieAttribute", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets this attribute's fields according to attributeValue array.\n\n@param attributeValue a binary array containing this attribute's field\n                      values and NOT containing the attribute header.\n@param offset the position where attribute values begin (most often\n         offset is equal to the index of the first byte after\n         length)\n@param length the length of the binary array.\n@throws StunException if attrubteValue contains invalid data.\n"}, {"uris": "src/main/java/org/ice4j/attribute/DontFragmentAttribute.java.DontFragmentAttribute.[]DontFragmentAttribute()", "name": "DontFragmentAttribute", "arg_nums": 0, "params": [], "return_type": "", "signature": "DontFragmentAttribute()", "original_string": "    DontFragmentAttribute()\n    {\n        super(DONT_FRAGMENT);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/DontFragmentAttribute.java", "class_name": "DontFragmentAttribute", "class_uri": "src/main/java/org/ice4j/attribute/DontFragmentAttribute.java.DontFragmentAttribute", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "docstring": "\nConstructor.\n"}, {"uris": "src/main/java/org/ice4j/attribute/DontFragmentAttribute.java.DontFragmentAttribute.[boolean]equals(Object)", "name": "equals", "arg_nums": 1, "params": [{"name": "obj", "type": "Object"}], "return_type": "boolean", "signature": "public boolean equals(Object obj)", "original_string": "    public boolean equals(Object obj)\n    {\n        if (! (obj instanceof DontFragmentAttribute))\n            return false;\n\n        return true;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/DontFragmentAttribute.java", "class_name": "DontFragmentAttribute", "class_uri": "src/main/java/org/ice4j/attribute/DontFragmentAttribute.java.DontFragmentAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nCompares two STUN Attributes. Attributes are considered equal when their\ntype, length, and all data are the same.\n@param obj the object to compare this attribute with.\n@return true if the attributes are equal and false otherwise.\n"}, {"uris": "src/main/java/org/ice4j/attribute/DontFragmentAttribute.java.DontFragmentAttribute.[String]getName()", "name": "getName", "arg_nums": 0, "params": [], "return_type": "String", "signature": "public String getName()", "original_string": "    public String getName()\n    {\n        return NAME;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/DontFragmentAttribute.java", "class_name": "DontFragmentAttribute", "class_uri": "src/main/java/org/ice4j/attribute/DontFragmentAttribute.java.DontFragmentAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns the human readable name of this attribute. Attribute names do\nnot really matter from the protocol point of view. They are only used\nfor debugging and readability.\n@return this attribute's name.\n"}, {"uris": "src/main/java/org/ice4j/attribute/DontFragmentAttribute.java.DontFragmentAttribute.[char]getDataLength()", "name": "getDataLength", "arg_nums": 0, "params": [], "return_type": "char", "signature": "public char getDataLength()", "original_string": "    public char getDataLength()\n    {\n        return DATA_LENGTH;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/DontFragmentAttribute.java", "class_name": "DontFragmentAttribute", "class_uri": "src/main/java/org/ice4j/attribute/DontFragmentAttribute.java.DontFragmentAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "char", "classes": []}, "docstring": "\nReturns the length of this attribute's body.\n@return the length of this attribute's value (8 bytes).\n"}, {"uris": "src/main/java/org/ice4j/attribute/DontFragmentAttribute.java.DontFragmentAttribute.[byte[]]encode()", "name": "encode", "arg_nums": 0, "params": [], "return_type": "byte[]", "signature": "public byte[] encode()", "original_string": "    public byte[] encode()\n    {\n        /* there is no data */\n        byte binValue[] = new byte[HEADER_LENGTH];\n\n        //Type\n        binValue[0] = (byte)(getAttributeType() >> 8);\n        binValue[1] = (byte)(getAttributeType() & 0x00FF);\n        //Length\n        binValue[2] = (byte)(getDataLength() >> 8);\n        binValue[3] = (byte)(getDataLength() & 0x00FF);\n\n        return binValue;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/DontFragmentAttribute.java", "class_name": "DontFragmentAttribute", "class_uri": "src/main/java/org/ice4j/attribute/DontFragmentAttribute.java.DontFragmentAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "byte[]", "classes": []}, "docstring": "\nReturns a binary representation of this attribute.\n@return a binary representation of this attribute.\n"}, {"uris": "src/main/java/org/ice4j/attribute/DontFragmentAttribute.java.DontFragmentAttribute.[void]decodeAttributeBody(byte[],char,char)", "name": "decodeAttributeBody", "arg_nums": 3, "params": [{"name": "attributeValue", "type": "byte[]"}, {"name": "offset", "type": "char"}, {"name": "length", "type": "char"}], "return_type": "void", "signature": "void decodeAttributeBody(byte[] attributeValue, char offset, char length)", "original_string": "    void decodeAttributeBody(byte[] attributeValue, char offset, char length)\n        throws StunException\n    {\n        if (length != 0)\n        {\n            throw new StunException(\"length invalid\");\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/DontFragmentAttribute.java", "class_name": "DontFragmentAttribute", "class_uri": "src/main/java/org/ice4j/attribute/DontFragmentAttribute.java.DontFragmentAttribute", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets this attribute's fields according to attributeValue array.\n@param attributeValue a binary array containing this attribute's field\n                      values and NOT containing the attribute header.\n@param offset the position where attribute values begin (most often\n         offset is equal to the index of the first byte after\n         length)\n@param length the length of the binary array.\n@throws StunException if attrubteValue contains invalid data.\n"}, {"uris": "src/main/java/org/ice4j/attribute/FingerprintAttribute.java.FingerprintAttribute.[]FingerprintAttribute()", "name": "FingerprintAttribute", "arg_nums": 0, "params": [], "return_type": "", "signature": "FingerprintAttribute()", "original_string": "    FingerprintAttribute()\n    {\n        super(FINGERPRINT);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/FingerprintAttribute.java", "class_name": "FingerprintAttribute", "class_uri": "src/main/java/org/ice4j/attribute/FingerprintAttribute.java.FingerprintAttribute", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "docstring": "\nCreates a <tt>FingerPrintAttribute</tt> instance.\n"}, {"uris": "src/main/java/org/ice4j/attribute/FingerprintAttribute.java.FingerprintAttribute.[byte[]]getChecksum()", "name": "getChecksum", "arg_nums": 0, "params": [], "return_type": "byte[]", "signature": "public byte[] getChecksum()", "original_string": "    public byte[] getChecksum()\n    {\n        return crc;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/FingerprintAttribute.java", "class_name": "FingerprintAttribute", "class_uri": "src/main/java/org/ice4j/attribute/FingerprintAttribute.java.FingerprintAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "byte[]", "classes": []}, "docstring": "\nReturns the CRC32 checksum that this attribute is carrying. Only makes\nsense for incoming messages and hence only set for them.\n\n@return the CRC32 checksum that this attribute is carrying or\n<tt>null</tt> if it has not been set.\n"}, {"uris": "src/main/java/org/ice4j/attribute/FingerprintAttribute.java.FingerprintAttribute.[char]getDataLength()", "name": "getDataLength", "arg_nums": 0, "params": [], "return_type": "char", "signature": "public char getDataLength()", "original_string": "    public char getDataLength()\n    {\n        return 4;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/FingerprintAttribute.java", "class_name": "FingerprintAttribute", "class_uri": "src/main/java/org/ice4j/attribute/FingerprintAttribute.java.FingerprintAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "char", "classes": []}, "docstring": "\nReturns the length of this attribute's body.\n\n@return the length of this attribute's value.\n"}, {"uris": "src/main/java/org/ice4j/attribute/FingerprintAttribute.java.FingerprintAttribute.[String]getName()", "name": "getName", "arg_nums": 0, "params": [], "return_type": "String", "signature": "public String getName()", "original_string": "    public String getName()\n    {\n        return NAME;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/FingerprintAttribute.java", "class_name": "FingerprintAttribute", "class_uri": "src/main/java/org/ice4j/attribute/FingerprintAttribute.java.FingerprintAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns the human readable name of this attribute.\n\n@return this attribute's name.\n"}, {"uris": "src/main/java/org/ice4j/attribute/FingerprintAttribute.java.FingerprintAttribute.[boolean]equals(Object)", "name": "equals", "arg_nums": 1, "params": [{"name": "obj", "type": "Object"}], "return_type": "boolean", "signature": "public boolean equals(Object obj)", "original_string": "    public boolean equals(Object obj)\n    {\n        if (! (obj instanceof FingerprintAttribute))\n            return false;\n\n        if (obj == this)\n            return true;\n\n        FingerprintAttribute att = (FingerprintAttribute) obj;\n        if (att.getAttributeType() != getAttributeType()\n                || att.getDataLength() != getDataLength())\n        {\n            return false;\n        }\n\n        return true;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/FingerprintAttribute.java", "class_name": "FingerprintAttribute", "class_uri": "src/main/java/org/ice4j/attribute/FingerprintAttribute.java.FingerprintAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nCompares two STUN Attributes. Two attributes are considered equal when\nthey have the same type length and value.\n\n@param obj the object to compare this attribute with.\n\n@return true if the attributes are equal and false otherwise.\n"}, {"uris": "src/main/java/org/ice4j/attribute/FingerprintAttribute.java.FingerprintAttribute.[byte[]]encode()", "name": "encode", "arg_nums": 0, "params": [], "return_type": "byte[]", "signature": "public byte[] encode()", "original_string": "    public byte[] encode()\n        throws UnsupportedOperationException\n    {\n        throw new UnsupportedOperationException(\n                        \"ContentDependentAttributes should be encoded \"\n                        + \"through the contend-dependent encode method\");\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/FingerprintAttribute.java", "class_name": "FingerprintAttribute", "class_uri": "src/main/java/org/ice4j/attribute/FingerprintAttribute.java.FingerprintAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "byte[]", "classes": []}, "docstring": "\nReturns a binary representation of this attribute.\n\n@return nothing\n@throws UnsupportedOperationException since {@link\nContentDependentAttribute}s should be encoded through the content\ndependent encode method.\n"}, {"uris": "src/main/java/org/ice4j/attribute/FingerprintAttribute.java.FingerprintAttribute.[byte[]]encode(StunStack,byte[],int,int)", "name": "encode", "arg_nums": 4, "params": [{"name": "stunStack", "type": "StunStack"}, {"name": "content", "type": "byte[]"}, {"name": "offset", "type": "int"}, {"name": "length", "type": "int"}], "return_type": "byte[]", "signature": "public byte[] encode(\n            StunStack stunStack,\n            byte[] content, int offset, int length)", "original_string": "    public byte[] encode(\n            StunStack stunStack,\n            byte[] content, int offset, int length)\n    {\n        char type = getAttributeType();\n        byte binValue[] = new byte[HEADER_LENGTH + getDataLength()];\n\n        //Type\n        binValue[0] = (byte)(type >> 8);\n        binValue[1] = (byte)(type & 0x00FF);\n        //Length\n        binValue[2] = (byte)(getDataLength() >> 8);\n        binValue[3] = (byte)(getDataLength() & 0x00FF);\n\n        //calculate the check sum\n        byte[] xorCrc32 = calculateXorCRC32(content, offset, length);\n\n        //copy into the attribute;\n        binValue[4] = xorCrc32[0];\n        binValue[5] = xorCrc32[1];\n        binValue[6] = xorCrc32[2];\n        binValue[7] = xorCrc32[3];\n\n        return binValue;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/FingerprintAttribute.java", "class_name": "FingerprintAttribute", "class_uri": "src/main/java/org/ice4j/attribute/FingerprintAttribute.java.FingerprintAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "byte[]", "classes": []}, "docstring": "\nReturns a binary representation of this attribute.\n\n@param stunStack the <tt>StunStack</tt> in the context of which the\nrequest to encode this <tt>ContentDependentAttribute</tt> is being made\n@param content the content of the message that this attribute will be\ntransported in\n@param offset the <tt>content</tt>-related offset where the actual\ncontent starts.\n@param length the length of the content in the <tt>content</tt> array.\n\n@return a binary representation of this attribute valid for the message\nwith the specified <tt>content</tt>.\n"}, {"uris": "src/main/java/org/ice4j/attribute/FingerprintAttribute.java.FingerprintAttribute.[void]decodeAttributeBody(byte[],char,char)", "name": "decodeAttributeBody", "arg_nums": 3, "params": [{"name": "attributeValue", "type": "byte[]"}, {"name": "offset", "type": "char"}, {"name": "length", "type": "char"}], "return_type": "void", "signature": "public void decodeAttributeBody( byte[] attributeValue,\n                                     char offset,\n                                     char length)", "original_string": "    public void decodeAttributeBody( byte[] attributeValue,\n                                     char offset,\n                                     char length)\n        throws StunException\n    {\n        if (length != 4)\n        {\n            throw new StunException(\"length invalid\");\n        }\n\n        byte[] incomingCrcBytes = new byte[4];\n\n        incomingCrcBytes[0] = attributeValue[offset];\n        incomingCrcBytes[1] = attributeValue[offset + 1];\n        incomingCrcBytes[2] = attributeValue[offset + 2];\n        incomingCrcBytes[3] = attributeValue[offset + 3];\n\n        this.crc = incomingCrcBytes;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/FingerprintAttribute.java", "class_name": "FingerprintAttribute", "class_uri": "src/main/java/org/ice4j/attribute/FingerprintAttribute.java.FingerprintAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets this attribute's fields according to the message and attributeValue\narrays.\n\n@param attributeValue a binary array containing this attribute's field\nvalues and NOT containing the attribute header.\n@param offset the position where attribute values begin (most often\noffset is equal to the index of the first byte after length)\n@param length the length of the binary array.\nthe start of this attribute.\n\n@throws StunException if attrubteValue contains invalid data.\n"}, {"uris": "src/main/java/org/ice4j/attribute/FingerprintAttribute.java.FingerprintAttribute.[byte[]]calculateXorCRC32(byte[],int,int)", "name": "calculateXorCRC32", "arg_nums": 3, "params": [{"name": "message", "type": "byte[]"}, {"name": "offset", "type": "int"}, {"name": "len", "type": "int"}], "return_type": "byte[]", "signature": "public static byte[] calculateXorCRC32(byte[] message, int offset, int len)", "original_string": "    public static byte[] calculateXorCRC32(byte[] message, int offset, int len)\n    {\n        //now check whether the CRC really is what it's supposed to be.\n        //re calculate the check sum\n        CRC32 checksum = new CRC32();\n        checksum.update(message, offset, len);\n\n        long crc = checksum.getValue();\n        byte[] xorCRC32 = new byte[4];\n\n        xorCRC32[0] = (byte)((byte)((crc >> 24) & 0xff) ^ XOR_MASK[0]);\n        xorCRC32[1] = (byte)((byte)((crc >> 16) & 0xff) ^ XOR_MASK[1]);\n        xorCRC32[2] = (byte)((byte)((crc >> 8)  & 0xff) ^ XOR_MASK[2]);\n        xorCRC32[3] = (byte)((byte) (crc        & 0xff) ^ XOR_MASK[3]);\n\n        return xorCRC32;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/FingerprintAttribute.java", "class_name": "FingerprintAttribute", "class_uri": "src/main/java/org/ice4j/attribute/FingerprintAttribute.java.FingerprintAttribute", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "byte[]", "classes": []}, "docstring": "\nCalculates and returns the CRC32 checksum for <tt>message</tt> after\napplying the <tt>XOR_MASK</tt> specified by RFC 5389.\n\n@param message the message whose checksum we'd like to have\n@param offset the location in <tt>message</tt> where the actual message\nstarts.\n@param len the number of message bytes in <tt>message</tt>\n\n@return the CRC value that should be sent in a <tt>FINGERPRINT</tt>\nattribute traveling in the <tt>message</tt> message.\n"}, {"uris": "src/main/java/org/ice4j/attribute/LifetimeAttribute.java.LifetimeAttribute.[]LifetimeAttribute()", "name": "LifetimeAttribute", "arg_nums": 0, "params": [], "return_type": "", "signature": "LifetimeAttribute()", "original_string": "    LifetimeAttribute()\n    {\n        super(LIFETIME);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/LifetimeAttribute.java", "class_name": "LifetimeAttribute", "class_uri": "src/main/java/org/ice4j/attribute/LifetimeAttribute.java.LifetimeAttribute", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "docstring": "\nConstructor.\n"}, {"uris": "src/main/java/org/ice4j/attribute/LifetimeAttribute.java.LifetimeAttribute.[boolean]equals(Object)", "name": "equals", "arg_nums": 1, "params": [{"name": "obj", "type": "Object"}], "return_type": "boolean", "signature": "@Override\n    public boolean equals(Object obj)", "original_string": "    @Override\n    public boolean equals(Object obj)\n    {\n        if (! (obj instanceof LifetimeAttribute))\n            return false;\n\n        if (obj == this)\n            return true;\n\n        LifetimeAttribute att = (LifetimeAttribute) obj;\n        if (att.getAttributeType() != getAttributeType()\n                || att.getDataLength() != getDataLength()\n                /* compare data */\n                || att.lifetime != lifetime\n           )\n            return false;\n\n        return true;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/LifetimeAttribute.java", "class_name": "LifetimeAttribute", "class_uri": "src/main/java/org/ice4j/attribute/LifetimeAttribute.java.LifetimeAttribute", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nCompares two STUN Attributes. Attributes are considered equal when their\ntype, length, and all data are the same.\n@param obj the object to compare this attribute with.\n@return true if the attributes are equal and false otherwise.\n"}, {"uris": "src/main/java/org/ice4j/attribute/LifetimeAttribute.java.LifetimeAttribute.[String]getName()", "name": "getName", "arg_nums": 0, "params": [], "return_type": "String", "signature": "@Override\n    public String getName()", "original_string": "    @Override\n    public String getName()\n    {\n        return NAME;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/LifetimeAttribute.java", "class_name": "LifetimeAttribute", "class_uri": "src/main/java/org/ice4j/attribute/LifetimeAttribute.java.LifetimeAttribute", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns the human readable name of this attribute. Attribute names do\nnot really matter from the protocol point of view. They are only used\nfor debugging and readability.\n@return this attribute's name.\n"}, {"uris": "src/main/java/org/ice4j/attribute/LifetimeAttribute.java.LifetimeAttribute.[char]getDataLength()", "name": "getDataLength", "arg_nums": 0, "params": [], "return_type": "char", "signature": "@Override\n    public char getDataLength()", "original_string": "    @Override\n    public char getDataLength()\n    {\n        return DATA_LENGTH;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/LifetimeAttribute.java", "class_name": "LifetimeAttribute", "class_uri": "src/main/java/org/ice4j/attribute/LifetimeAttribute.java.LifetimeAttribute", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "char", "classes": []}, "docstring": "\nReturns the length of this attribute's body.\n@return the length of this attribute's value (8 bytes).\n"}, {"uris": "src/main/java/org/ice4j/attribute/LifetimeAttribute.java.LifetimeAttribute.[byte[]]encode()", "name": "encode", "arg_nums": 0, "params": [], "return_type": "byte[]", "signature": "@Override\n    public byte[] encode()", "original_string": "    @Override\n    public byte[] encode()\n    {\n        byte binValue[] = new byte[HEADER_LENGTH + DATA_LENGTH];\n\n        //Type\n        binValue[0] = (byte)(getAttributeType() >> 8);\n        binValue[1] = (byte)(getAttributeType() & 0x00FF);\n        //Length\n        binValue[2] = (byte)(getDataLength() >> 8);\n        binValue[3] = (byte)(getDataLength() & 0x00FF);\n        //Data\n        binValue[4] = (byte)((lifetime >> 24) & 0xff);\n        binValue[5] = (byte)((lifetime >> 16) & 0xff);\n        binValue[6] = (byte)((lifetime >> 8) & 0xff);\n        binValue[7] = (byte)((lifetime) & 0xff);\n\n        return binValue;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/LifetimeAttribute.java", "class_name": "LifetimeAttribute", "class_uri": "src/main/java/org/ice4j/attribute/LifetimeAttribute.java.LifetimeAttribute", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "byte[]", "classes": []}, "docstring": "\nReturns a binary representation of this attribute.\n@return a binary representation of this attribute.\n"}, {"uris": "src/main/java/org/ice4j/attribute/LifetimeAttribute.java.LifetimeAttribute.[void]decodeAttributeBody(byte[],char,char)", "name": "decodeAttributeBody", "arg_nums": 3, "params": [{"name": "attributeValue", "type": "byte[]"}, {"name": "offset", "type": "char"}, {"name": "length", "type": "char"}], "return_type": "void", "signature": "@Override\n    void decodeAttributeBody(byte[] attributeValue, char offset, char length)", "original_string": "    @Override\n    void decodeAttributeBody(byte[] attributeValue, char offset, char length)\n        throws StunException\n    {\n        if (length != 4)\n        {\n            throw new StunException(\"length invalid\");\n        }\n\n        lifetime = ((attributeValue[offset] << 24) & 0xff000000) +\n            ((attributeValue[offset + 1] << 16) & 0x00ff0000) +\n            ((attributeValue[offset + 2] << 8) & 0x0000ff00) +\n            (attributeValue[offset + 3] & 0x000000ff);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/LifetimeAttribute.java", "class_name": "LifetimeAttribute", "class_uri": "src/main/java/org/ice4j/attribute/LifetimeAttribute.java.LifetimeAttribute", "attributes": {"modifiers": "@Override", "marker_annotations": ["@Override"], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets this attribute's fields according to attributeValue array.\n@param attributeValue a binary array containing this attribute's field\n                      values and NOT containing the attribute header.\n@param offset the position where attribute values begin (most often\n         offset is equal to the index of the first byte after\n         length)\n@param length the length of the binary array.\n@throws StunException if attrubteValue contains invalid data.\n"}, {"uris": "src/main/java/org/ice4j/attribute/LifetimeAttribute.java.LifetimeAttribute.[void]setLifetime(int)", "name": "setLifetime", "arg_nums": 1, "params": [{"name": "lifetime", "type": "int"}], "return_type": "void", "signature": "public void setLifetime(int lifetime)", "original_string": "    public void setLifetime(int lifetime)\n    {\n        this.lifetime = lifetime;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/LifetimeAttribute.java", "class_name": "LifetimeAttribute", "class_uri": "src/main/java/org/ice4j/attribute/LifetimeAttribute.java.LifetimeAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSet the lifetime.\n@param lifetime lifetime\n"}, {"uris": "src/main/java/org/ice4j/attribute/LifetimeAttribute.java.LifetimeAttribute.[int]getLifetime()", "name": "getLifetime", "arg_nums": 0, "params": [], "return_type": "int", "signature": "public int getLifetime()", "original_string": "    public int getLifetime()\n    {\n        return lifetime;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/attribute/LifetimeAttribute.java", "class_name": "LifetimeAttribute", "class_uri": "src/main/java/org/ice4j/attribute/LifetimeAttribute.java.LifetimeAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\nGet the lifetime.\n@return lifetime\n"}, {"uris": "src/main/java/org/ice4j/security/LongTermCredential.java.LongTermCredential.[byte[]]getBytes(String)", "name": "getBytes", "arg_nums": 1, "params": [{"name": "s", "type": "String"}], "return_type": "byte[]", "signature": "public static byte[] getBytes(String s)", "original_string": "    public static byte[] getBytes(String s)\n    {\n        if (s == null)\n            return null;\n        else\n        {\n            try\n            {\n                return s.getBytes(\"UTF-8\");\n            }\n            catch (UnsupportedEncodingException ueex)\n            {\n                throw new UndeclaredThrowableException(ueex);\n            }\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/security/LongTermCredential.java", "class_name": "LongTermCredential", "class_uri": "src/main/java/org/ice4j/security/LongTermCredential.java.LongTermCredential", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "byte[]", "classes": []}, "docstring": "\nEncodes a specific <tt>String</tt> into a sequence of <tt>byte</tt>s\nusing the UTF-8 charset, storing the result into a new <tt>byte</tt>\narray.\n\n@param s the <tt>String</tt> to encode\n@return a new array of <tt>byte</tt>s which represents the encoding of\nthe specified <tt>String</tt> using the UTF-8 charset\n"}, {"uris": "src/main/java/org/ice4j/security/LongTermCredential.java.LongTermCredential.[String]toString(byte[])", "name": "toString", "arg_nums": 1, "params": [{"name": "bytes", "type": "byte[]"}], "return_type": "String", "signature": "public static String toString(byte[] bytes)", "original_string": "    public static String toString(byte[] bytes)\n    {\n        if (bytes == null)\n            return null;\n        else\n        {\n            try\n            {\n                return new String(bytes, \"UTF-8\");\n            }\n            catch (UnsupportedEncodingException ueex)\n            {\n                throw new UndeclaredThrowableException(ueex);\n            }\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/security/LongTermCredential.java", "class_name": "LongTermCredential", "class_uri": "src/main/java/org/ice4j/security/LongTermCredential.java.LongTermCredential", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nConstructs a new <tt>String</tt> by decoding a specific array of\n<tt>byte</tt>s using the UTF-8 charset. The length of the new\n<tt>String</tt> is a function of the charset, and hence may not be equal\nto the length of the <tt>byte</tt> array.\n\n@param bytes the <tt>byte</tt>s to be decoded into characters\n@return a new <tt>String</tt> which has been decoded from the specified\narray of <tt>byte</tt>s using the UTF-8 charset\n"}, {"uris": "src/main/java/org/ice4j/security/LongTermCredential.java.LongTermCredential.[]LongTermCredential()", "name": "LongTermCredential", "arg_nums": 0, "params": [], "return_type": "", "signature": "protected LongTermCredential()", "original_string": "    protected LongTermCredential()\n    {\n        this((byte[]) null, (byte[]) null);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/security/LongTermCredential.java", "class_name": "LongTermCredential", "class_uri": "src/main/java/org/ice4j/security/LongTermCredential.java.LongTermCredential", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>LongTermCredential</tt> instance with no username\nand no password. Extenders should override {@link #getUsername()} and\n{@link #getPassword()} to provide the username and the password,\nrespectively, when requested.\n"}, {"uris": "src/main/java/org/ice4j/security/LongTermCredential.java.LongTermCredential.[]LongTermCredential(byte[],byte[])", "name": "LongTermCredential", "arg_nums": 2, "params": [{"name": "username", "type": "byte[]"}, {"name": "password", "type": "byte[]"}], "return_type": "", "signature": "public LongTermCredential(byte[] username, byte[] password)", "original_string": "    public LongTermCredential(byte[] username, byte[] password)\n    {\n        this.username = (username == null) ? null : username.clone();\n        this.password = (password == null) ? null : password.clone();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/security/LongTermCredential.java", "class_name": "LongTermCredential", "class_uri": "src/main/java/org/ice4j/security/LongTermCredential.java.LongTermCredential", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>LongTermCredential</tt> instance with a specific\nusername and a specific password.\n\n@param username the username to initialize the new instance with\n@param password the password to initialize the new instance with\n"}, {"uris": "src/main/java/org/ice4j/security/LongTermCredential.java.LongTermCredential.[]LongTermCredential(String,String)", "name": "LongTermCredential", "arg_nums": 2, "params": [{"name": "username", "type": "String"}, {"name": "password", "type": "String"}], "return_type": "", "signature": "public LongTermCredential(String username, String password)", "original_string": "    public LongTermCredential(String username, String password)\n    {\n        this(getBytes(username), getBytes(password));\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/security/LongTermCredential.java", "class_name": "LongTermCredential", "class_uri": "src/main/java/org/ice4j/security/LongTermCredential.java.LongTermCredential", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>LongTermCredential</tt> instance with a specific\nusername and a specific password.\n\n@param username the username to initialize the new instance with\n@param password the password to initialize the new instance with\n"}, {"uris": "src/main/java/org/ice4j/security/LongTermCredential.java.LongTermCredential.[byte[]]getPassword()", "name": "getPassword", "arg_nums": 0, "params": [], "return_type": "byte[]", "signature": "public byte[] getPassword()", "original_string": "    public byte[] getPassword()\n    {\n        return (password == null) ? null : password.clone();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/security/LongTermCredential.java", "class_name": "LongTermCredential", "class_uri": "src/main/java/org/ice4j/security/LongTermCredential.java.LongTermCredential", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "byte[]", "classes": []}, "docstring": "\nGets the password of this <tt>LongTermCredential</tt>.\n\n@return an array of <tt>byte</tt>s which represents the password of this\n<tt>LongTermCredential</tt>\n"}, {"uris": "src/main/java/org/ice4j/security/LongTermCredential.java.LongTermCredential.[byte[]]getUsername()", "name": "getUsername", "arg_nums": 0, "params": [], "return_type": "byte[]", "signature": "public byte[] getUsername()", "original_string": "    public byte[] getUsername()\n    {\n        return (username == null) ? null : username.clone();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/security/LongTermCredential.java", "class_name": "LongTermCredential", "class_uri": "src/main/java/org/ice4j/security/LongTermCredential.java.LongTermCredential", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "byte[]", "classes": []}, "docstring": "\nGets the username of this <tt>LongTermCredential</tt>.\n\n@return an array of <tt>byte</tt>s which represents the username of this\n<tt>LongTermCredential</tt>\n"}, {"uris": "src/main/java/org/ice4j/security/LongTermCredential.java.LongTermCredential.[int]hashCode()", "name": "hashCode", "arg_nums": 0, "params": [], "return_type": "int", "signature": "@Override\n    public int hashCode()", "original_string": "    @Override\n    public int hashCode()\n    {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + Arrays.hashCode(password);\n        result = prime * result + Arrays.hashCode(username);\n        return result;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/security/LongTermCredential.java", "class_name": "LongTermCredential", "class_uri": "src/main/java/org/ice4j/security/LongTermCredential.java.LongTermCredential", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": ""}, {"uris": "src/main/java/org/ice4j/security/LongTermCredential.java.LongTermCredential.[boolean]equals(Object)", "name": "equals", "arg_nums": 1, "params": [{"name": "o", "type": "Object"}], "return_type": "boolean", "signature": "@Override\n    public boolean equals(Object o)", "original_string": "    @Override\n    public boolean equals(Object o)\n    {\n        if (o instanceof LongTermCredential)\n        {\n            LongTermCredential ltc = (LongTermCredential) o;\n            if (Arrays.equals(\n                this.username, ltc.username) && Arrays.equals(\n                this.password, ltc.password))\n            {\n                return true;\n            }\n        }\n        return false;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/security/LongTermCredential.java", "class_name": "LongTermCredential", "class_uri": "src/main/java/org/ice4j/security/LongTermCredential.java.LongTermCredential", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "src/main/java/org/ice4j/security/LongTermCredentialSession.java.LongTermCredentialSession.[]LongTermCredentialSession(LongTermCredential,byte[])", "name": "LongTermCredentialSession", "arg_nums": 2, "params": [{"name": "longTermCredential", "type": "LongTermCredential"}, {"name": "realm", "type": "byte[]"}], "return_type": "", "signature": "public LongTermCredentialSession(\n            LongTermCredential longTermCredential,\n            byte[] realm)", "original_string": "    public LongTermCredentialSession(\n            LongTermCredential longTermCredential,\n            byte[] realm)\n    {\n        this.longTermCredential = longTermCredential;\n        this.realm = (realm == null) ? null : realm.clone();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/security/LongTermCredentialSession.java", "class_name": "LongTermCredentialSession", "class_uri": "src/main/java/org/ice4j/security/LongTermCredentialSession.java.LongTermCredentialSession", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>LongTermCredentialSession</tt> instance which\nis to represent a use of a specific <tt>LongTermCredential</tt> in a\nspecific realm.\n\n@param longTermCredential the <tt>LongTermCredential</tt> a use of\nwhich is to be represented by the new instance\n@param realm the realm in which the specified\n<tt>LongTermCredential</tt> is to be used\n"}, {"uris": "src/main/java/org/ice4j/security/LongTermCredentialSession.java.LongTermCredentialSession.[void]addAttributes(Request)", "name": "addAttributes", "arg_nums": 1, "params": [{"name": "request", "type": "Request"}], "return_type": "void", "signature": "public void addAttributes(Request request)", "original_string": "    public void addAttributes(Request request)\n        throws StunException\n    {\n        MessageFactory.addLongTermCredentialAttributes(\n                request,\n                getUsername(), getRealm(), getNonce());\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/security/LongTermCredentialSession.java", "class_name": "LongTermCredentialSession", "class_uri": "src/main/java/org/ice4j/security/LongTermCredentialSession.java.LongTermCredentialSession", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nAdds the <tt>Attribute</tt>s to a specific <tt>Request</tt> which support\nthe long-term credential mechanism using the <tt>LongTermCredential</tt>\nassociated with this instance.\n\n@param request the <tt>Request</tt> in which the <tt>Attribute</tt>\nsupporting the STUN long-term credential mechanism are to be added\n@throws StunException if anything goes wrong while adding the\n<tt>Attribute</tt>s to <tt>request</tt> which support the STUN long-term\ncredential mechanism\n"}, {"uris": "src/main/java/org/ice4j/security/LongTermCredentialSession.java.LongTermCredentialSession.[boolean]checkLocalUserName(String)", "name": "checkLocalUserName", "arg_nums": 1, "params": [{"name": "username", "type": "String"}], "return_type": "boolean", "signature": "public boolean checkLocalUserName(String username)", "original_string": "    public boolean checkLocalUserName(String username)\n    {\n        /*\n         * The value of USERNAME is a variable-length value. It MUST contain\n         * a UTF-8 [RFC3629] encoded sequence of less than 513 bytes, and\n         * MUST have been processed using SASLprep [RFC4013].\n         */\n        return usernameEquals(LongTermCredential.getBytes(username));\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/security/LongTermCredentialSession.java", "class_name": "LongTermCredentialSession", "class_uri": "src/main/java/org/ice4j/security/LongTermCredentialSession.java.LongTermCredentialSession", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nDetermines whether <tt>username</tt> is currently known to this authority\n\n@param username the user name whose validity we'd like to check\n@return <tt>true</tt> if <tt>username</tt> is known to this\n<tt>CredentialsAuthority</tt>; <tt>false</tt>, otherwise\n@see CredentialsAuthority#checkLocalUserName(String)\n"}, {"uris": "src/main/java/org/ice4j/security/LongTermCredentialSession.java.LongTermCredentialSession.[byte[]]getLocalKey(String)", "name": "getLocalKey", "arg_nums": 1, "params": [{"name": "username", "type": "String"}], "return_type": "byte[]", "signature": "public byte[] getLocalKey(String username)", "original_string": "    public byte[] getLocalKey(String username)\n    {\n        if (!checkLocalUserName(username))\n            return null;\n\n        // MD5(username \":\" realm \":\" SASLprep(password))\n        StringBuilder localKeyBuilder = new StringBuilder();\n\n        if (username != null)\n            localKeyBuilder.append(username);\n        localKeyBuilder.append(':');\n\n        String realm = LongTermCredential.toString(getRealm());\n\n        if (realm != null)\n            localKeyBuilder.append(realm);\n        localKeyBuilder.append(':');\n\n        String password = LongTermCredential.toString(getPassword());\n\n        if (password != null)\n        {\n            // TODO SASLprep\n            localKeyBuilder.append(password);\n        }\n\n        MessageDigest md5;\n\n        try\n        {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        }\n        catch (NoSuchAlgorithmException nsaex)\n        {\n            throw new UndeclaredThrowableException(nsaex);\n        }\n        return\n            md5.digest(LongTermCredential.getBytes(localKeyBuilder.toString()));\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/security/LongTermCredentialSession.java", "class_name": "LongTermCredentialSession", "class_uri": "src/main/java/org/ice4j/security/LongTermCredentialSession.java.LongTermCredentialSession", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "byte[]", "classes": []}, "docstring": "\nReturns the key (password) that corresponds to the specified local\nusername or user frag,  an empty array if there was no password for\nthat username or <tt>null</tt> if the username is not a local user\nname recognized by this <tt>CredentialsAuthority</tt>.\n\n@param username the local user name or user frag whose credentials\nwe'd like to obtain\n@return the key (password) that corresponds to the specified local\nusername or user frag,  an empty array if there was no password for\nthat username or <tt>null</tt> if the username is not a local user\nname recognized by this <tt>CredentialsAuthority</tt>\n@see CredentialsAuthority#getLocalKey(String)\n"}, {"uris": "src/main/java/org/ice4j/security/LongTermCredentialSession.java.LongTermCredentialSession.[byte[]]getNonce()", "name": "getNonce", "arg_nums": 0, "params": [], "return_type": "byte[]", "signature": "public byte[] getNonce()", "original_string": "    public byte[] getNonce()\n    {\n        return (nonce == null) ? null : nonce.clone();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/security/LongTermCredentialSession.java", "class_name": "LongTermCredentialSession", "class_uri": "src/main/java/org/ice4j/security/LongTermCredentialSession.java.LongTermCredentialSession", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "byte[]", "classes": []}, "docstring": "\nGets the value of the NONCE attribute currently associated with the use\nof the <tt>LongTermCredential</tt> represented by this instance.\n\n@return the value of the NONCE attribute currently associated with the\nuse of the <tt>LongTermCredential</tt> represented by this instance\n"}, {"uris": "src/main/java/org/ice4j/security/LongTermCredentialSession.java.LongTermCredentialSession.[byte[]]getPassword()", "name": "getPassword", "arg_nums": 0, "params": [], "return_type": "byte[]", "signature": "public byte[] getPassword()", "original_string": "    public byte[] getPassword()\n    {\n        return longTermCredential.getPassword();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/security/LongTermCredentialSession.java", "class_name": "LongTermCredentialSession", "class_uri": "src/main/java/org/ice4j/security/LongTermCredentialSession.java.LongTermCredentialSession", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "byte[]", "classes": []}, "docstring": "\nGets the password of the <tt>LongTermCredential</tt> used by this\ninstance.\n\n@return the password of the <tt>LongTermCredential</tt> used by this\ninstance\n"}, {"uris": "src/main/java/org/ice4j/security/LongTermCredentialSession.java.LongTermCredentialSession.[byte[]]getRealm()", "name": "getRealm", "arg_nums": 0, "params": [], "return_type": "byte[]", "signature": "public byte[] getRealm()", "original_string": "    public byte[] getRealm()\n    {\n        return (realm == null) ? null : realm.clone();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/security/LongTermCredentialSession.java", "class_name": "LongTermCredentialSession", "class_uri": "src/main/java/org/ice4j/security/LongTermCredentialSession.java.LongTermCredentialSession", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "byte[]", "classes": []}, "docstring": "\nGets the realm (i.e. the value of the REALM attribute) in which this\ninstance uses the <tt>LongTermCredential</tt> associated with it.\n\n@return the realm (i.e. the value of the REALM attribute) in which this\ninstance uses the <tt>LongTermCredential</tt> associated with it\n"}, {"uris": "src/main/java/org/ice4j/security/LongTermCredentialSession.java.LongTermCredentialSession.[byte[]]getRemoteKey(String,String)", "name": "getRemoteKey", "arg_nums": 2, "params": [{"name": "username", "type": "String"}, {"name": "media", "type": "String"}], "return_type": "byte[]", "signature": "public byte[] getRemoteKey(String username, String media)", "original_string": "    public byte[] getRemoteKey(String username, String media)\n    {\n        // The password is the same on the local and the remote sides.\n        return getLocalKey(username);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/security/LongTermCredentialSession.java", "class_name": "LongTermCredentialSession", "class_uri": "src/main/java/org/ice4j/security/LongTermCredentialSession.java.LongTermCredentialSession", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "byte[]", "classes": []}, "docstring": "\nReturns the key (password) that corresponds to the specified remote\nusername or user frag,  an empty array if there was no password for\nthat username or <tt>null</tt> if the username is not a remote user\nname recognized by this <tt>CredentialsAuthority</tt>.\n\n@param username the remote user name or user frag whose credentials\nwe'd like to obtain\n@param media not used\n@return the key (password) that corresponds to the specified remote\nusername or user frag,  an empty array if there was no password for\nthat username or <tt>null</tt> if the username is not a remote user\nname recognized by this <tt>CredentialsAuthority</tt>\n@see CredentialsAuthority#getRemoteKey(String, String)\n"}, {"uris": "src/main/java/org/ice4j/security/LongTermCredentialSession.java.LongTermCredentialSession.[byte[]]getUsername()", "name": "getUsername", "arg_nums": 0, "params": [], "return_type": "byte[]", "signature": "public byte[] getUsername()", "original_string": "    public byte[] getUsername()\n    {\n        return longTermCredential.getUsername();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/security/LongTermCredentialSession.java", "class_name": "LongTermCredentialSession", "class_uri": "src/main/java/org/ice4j/security/LongTermCredentialSession.java.LongTermCredentialSession", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "byte[]", "classes": []}, "docstring": "\nGets the username of the <tt>LongTermCredential</tt> used by this\ninstance.\n\n@return the username of the <tt>LongTermCredential</tt> used by this\ninstance\n"}, {"uris": "src/main/java/org/ice4j/security/LongTermCredentialSession.java.LongTermCredentialSession.[boolean]realmEquals(byte[])", "name": "realmEquals", "arg_nums": 1, "params": [{"name": "realm", "type": "byte[]"}], "return_type": "boolean", "signature": "public boolean realmEquals(byte[] realm)", "original_string": "    public boolean realmEquals(byte[] realm)\n    {\n        return\n            (realm == null)\n                ? (this.realm == null)\n                : Arrays.equals(realm, this.realm);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/security/LongTermCredentialSession.java", "class_name": "LongTermCredentialSession", "class_uri": "src/main/java/org/ice4j/security/LongTermCredentialSession.java.LongTermCredentialSession", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nDetermines whether the realm of this <tt>LongTermCredentialSession</tt>\nis equal to a specific realm.\n\n@param realm the realm to compare for equality to the realm of this\n<tt>LongTermCredentialSession</tt>\n@return <tt>true</tt> if the specified <tt>realm</tt> is equal to the\nrealm of this <tt>LongTermCredentialSession</tt>; otherwise,\n<tt>false</tt>\n"}, {"uris": "src/main/java/org/ice4j/security/LongTermCredentialSession.java.LongTermCredentialSession.[void]setNonce(byte[])", "name": "setNonce", "arg_nums": 1, "params": [{"name": "nonce", "type": "byte[]"}], "return_type": "void", "signature": "public void setNonce(byte[] nonce)", "original_string": "    public void setNonce(byte[] nonce)\n    {\n        this.nonce = (nonce == null) ? null : nonce.clone();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/security/LongTermCredentialSession.java", "class_name": "LongTermCredentialSession", "class_uri": "src/main/java/org/ice4j/security/LongTermCredentialSession.java.LongTermCredentialSession", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets the value of the NONCE attribute to be associated with the use of\nthe <tt>LongTermCredential</tt> represented by this instance.\n\n@param nonce the value of the NONCE attribute to be associated with the\nuse of the <tt>LongTermCredential</tt> represented by this instance\n"}, {"uris": "src/main/java/org/ice4j/security/LongTermCredentialSession.java.LongTermCredentialSession.[boolean]usernameEquals(byte[])", "name": "usernameEquals", "arg_nums": 1, "params": [{"name": "username", "type": "byte[]"}], "return_type": "boolean", "signature": "public boolean usernameEquals(byte[] username)", "original_string": "    public boolean usernameEquals(byte[] username)\n    {\n        byte[] thisUsername = getUsername();\n\n        return\n            (username == null)\n                ? (thisUsername == null)\n                : Arrays.equals(username, thisUsername);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/security/LongTermCredentialSession.java", "class_name": "LongTermCredentialSession", "class_uri": "src/main/java/org/ice4j/security/LongTermCredentialSession.java.LongTermCredentialSession", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nDetermines whether the username of the <tt>LongTermCredential</tt> used\nby this instance is equal to a specific username.\n\n@param username the username to compare for equality to the username of\nthe <tt>LongTermCredential</tt> used by this instance\n@return <tt>true</tt> if the specified <tt>username</tt> is equal to the\nusername of the <tt>LongTermCredential</tt> used by this instance;\notherwise, <tt>false</tt>\n"}, {"uris": "src/main/java/org/ice4j/security/CredentialsAuthority.java.CredentialsAuthority.[byte[]]getLocalKey(String)", "name": "getLocalKey", "arg_nums": 1, "params": [{"name": "username", "type": "String"}], "return_type": "byte[]", "signature": "public byte[] getLocalKey(String username)", "original_string": "    public byte[] getLocalKey(String username);", "default_arguments": null, "file": "src/main/java/org/ice4j/security/CredentialsAuthority.java", "class_name": "CredentialsAuthority", "class_uri": "src/main/java/org/ice4j/security/CredentialsAuthority.java.CredentialsAuthority", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "byte[]", "classes": []}, "docstring": "\nReturns the key (password) that corresponds to the specified local\nusername or user frag,  an empty array if there was no password for that\nusername or <tt>null</tt> if the username is not a local user name\nrecognized by this <tt>CredentialsAuthority</tt>.\n\n@param username the local user name or user frag whose credentials we'd\nlike to obtain.\n\n@return the key (password) that corresponds to the specified local\nusername or user frag,  an empty array if there was no password for that\nusername or <tt>null</tt> if the username is not a local user name\nrecognized by this <tt>CredentialsAuthority</tt>.\n"}, {"uris": "src/main/java/org/ice4j/security/CredentialsAuthority.java.CredentialsAuthority.[byte[]]getRemoteKey(String,String)", "name": "getRemoteKey", "arg_nums": 2, "params": [{"name": "username", "type": "String"}, {"name": "media", "type": "String"}], "return_type": "byte[]", "signature": "public byte[] getRemoteKey(String username, String media)", "original_string": "    public byte[] getRemoteKey(String username, String media);", "default_arguments": null, "file": "src/main/java/org/ice4j/security/CredentialsAuthority.java", "class_name": "CredentialsAuthority", "class_uri": "src/main/java/org/ice4j/security/CredentialsAuthority.java.CredentialsAuthority", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "byte[]", "classes": []}, "docstring": "\nReturns the key (password) that corresponds to the specified remote\nusername or user frag,  an empty array if there was no password for that\nusername or <tt>null</tt> if the username is not a remote user name\nrecognized by this <tt>CredentialsAuthority</tt>.\n\n@param username the remote user name or user frag whose credentials we'd\nlike to obtain.\n@param media the media name that we want to get remote key.\n\n@return the key (password) that corresponds to the specified remote\nusername or user frag,  an empty array if there was no password for that\nusername or <tt>null</tt> if the username is not a remote user name\nrecognized by this <tt>CredentialsAuthority</tt>.\n"}, {"uris": "src/main/java/org/ice4j/security/CredentialsAuthority.java.CredentialsAuthority.[boolean]checkLocalUserName(String)", "name": "checkLocalUserName", "arg_nums": 1, "params": [{"name": "username", "type": "String"}], "return_type": "boolean", "signature": "public boolean checkLocalUserName(String username)", "original_string": "    public boolean checkLocalUserName(String username);", "default_arguments": null, "file": "src/main/java/org/ice4j/security/CredentialsAuthority.java", "class_name": "CredentialsAuthority", "class_uri": "src/main/java/org/ice4j/security/CredentialsAuthority.java.CredentialsAuthority", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nVerifies whether <tt>username</tt> is currently known to this authority\nand returns <tt>true</tt> if so. Returns <tt>false</tt> otherwise.\n\n@param username the user name whose validity we'd like to check.\n\n@return <tt>true</tt> if <tt>username</tt> is known to this\n<tt>CredentialsAuthority</tt> and <tt>false</tt> otherwise.\n"}, {"uris": "src/main/java/org/ice4j/security/CredentialsManager.java.CredentialsManager.[boolean]checkLocalUserName(String)", "name": "checkLocalUserName", "arg_nums": 1, "params": [{"name": "username", "type": "String"}], "return_type": "boolean", "signature": "public boolean checkLocalUserName(String username)", "original_string": "    public boolean checkLocalUserName(String username)\n    {\n        for (CredentialsAuthority auth : getAuthorities())\n        {\n            if (auth.checkLocalUserName(username))\n                return true;\n        }\n        return false;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/security/CredentialsManager.java", "class_name": "CredentialsManager", "class_uri": "src/main/java/org/ice4j/security/CredentialsManager.java.CredentialsManager", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nVerifies whether <tt>username</tt> is currently known to any of the\n{@link CredentialsAuthority}s registered with this manager and\nand returns <tt>true</tt> if so. Returns <tt>false</tt> otherwise.\n\n@param username the user name whose validity we'd like to check.\n\n@return <tt>true</tt> if <tt>username</tt> is known to any of the\n<tt>CredentialsAuthority</tt>s registered here and <tt>false</tt>\notherwise.\n"}, {"uris": "src/main/java/org/ice4j/security/CredentialsManager.java.CredentialsManager.[CredentialsAuthority[]]getAuthorities()", "name": "getAuthorities", "arg_nums": 0, "params": [], "return_type": "CredentialsAuthority[]", "signature": "private CredentialsAuthority[] getAuthorities()", "original_string": "    private CredentialsAuthority[] getAuthorities()\n    {\n        synchronized (authorities)\n        {\n            if (unmodifiableAuthorities == null)\n            {\n                unmodifiableAuthorities\n                    = authorities.toArray(\n                            new CredentialsAuthority[authorities.size()]);\n            }\n            return unmodifiableAuthorities;\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/security/CredentialsManager.java", "class_name": "CredentialsManager", "class_uri": "src/main/java/org/ice4j/security/CredentialsManager.java.CredentialsManager", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "CredentialsAuthority[]", "classes": []}, "docstring": "\nGets the list of <tt>CredentialsAuthority</tt>s registered with this\nmanager as being able to provide credentials. <b>Warning</b>: the\nreturned value is an internal state of this instance and is to be\nconsidered unmodifiable.\n\n@return the list of <tt>CredentialsAuthority</tt>s registered with this\nmanager as being able to provide credentials. <b>Warning</b>: the\nreturned value is an internal state of this instance and is to be\nconsidered unmodifiable.\n"}, {"uris": "src/main/java/org/ice4j/security/CredentialsManager.java.CredentialsManager.[byte[]]getLocalKey(String)", "name": "getLocalKey", "arg_nums": 1, "params": [{"name": "username", "type": "String"}], "return_type": "byte[]", "signature": "public byte[] getLocalKey(String username)", "original_string": "    public byte[] getLocalKey(String username)\n    {\n        for (CredentialsAuthority auth : getAuthorities())\n        {\n            byte[] passwd = auth.getLocalKey(username);\n\n            if (passwd != null)\n                return passwd;\n        }\n        return null;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/security/CredentialsManager.java", "class_name": "CredentialsManager", "class_uri": "src/main/java/org/ice4j/security/CredentialsManager.java.CredentialsManager", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "byte[]", "classes": []}, "docstring": "\nQueries all currently registered {@link CredentialsAuthority}s for a\npassword corresponding to the specified local <tt>username</tt> or user\nfrag and returns the first non-<tt>null</tt> one.\n\n@param username a local user name or user frag whose credentials we'd\nlike to obtain.\n\n@return <tt>null</tt> if username was not a recognized local user name\nfor none of the currently registered <tt>CredentialsAuthority</tt>s or\na <tt>byte</tt> array containing the first non-<tt>null</tt> password\nthat one of them returned.\n"}, {"uris": "src/main/java/org/ice4j/security/CredentialsManager.java.CredentialsManager.[byte[]]getRemoteKey(String,String)", "name": "getRemoteKey", "arg_nums": 2, "params": [{"name": "username", "type": "String"}, {"name": "media", "type": "String"}], "return_type": "byte[]", "signature": "public byte[] getRemoteKey(String username, String media)", "original_string": "    public byte[] getRemoteKey(String username, String media)\n    {\n        for (CredentialsAuthority auth : getAuthorities())\n        {\n            byte[] passwd = auth.getRemoteKey(username, media);\n\n            if (passwd != null)\n            {\n                /** @todo: we should probably add SASLprep here.*/\n                return passwd;\n            }\n        }\n        return null;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/security/CredentialsManager.java", "class_name": "CredentialsManager", "class_uri": "src/main/java/org/ice4j/security/CredentialsManager.java.CredentialsManager", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "byte[]", "classes": []}, "docstring": "\nQueries all currently registered {@link CredentialsAuthority}s for a\npassword corresponding to the specified remote <tt>username</tt> or user\nfrag and returns the first non-<tt>null</tt> one.\n\n@param username a remote user name or user frag whose credentials we'd\nlike to obtain.\n@param media the media name that we want to get remote key.\n\n@return <tt>null</tt> if username was not a recognized remote user name\nfor none of the currently registered <tt>CredentialsAuthority</tt>s or\na <tt>byte</tt> array containing the first non-<tt>null</tt> password\nthat one of them returned.\n"}, {"uris": "src/main/java/org/ice4j/security/CredentialsManager.java.CredentialsManager.[void]registerAuthority(CredentialsAuthority)", "name": "registerAuthority", "arg_nums": 1, "params": [{"name": "authority", "type": "CredentialsAuthority"}], "return_type": "void", "signature": "public void registerAuthority(CredentialsAuthority authority)", "original_string": "    public void registerAuthority(CredentialsAuthority authority)\n    {\n        synchronized (authorities)\n        {\n            if (!authorities.contains(authority) && authorities.add(authority))\n                unmodifiableAuthorities = null;\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/security/CredentialsManager.java", "class_name": "CredentialsManager", "class_uri": "src/main/java/org/ice4j/security/CredentialsManager.java.CredentialsManager", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nAdds <tt>authority</tt> to the list of {@link CredentialsAuthority}s\nregistered with this manager.\n\n@param authority the {@link CredentialsAuthority} to add to this manager.\n"}, {"uris": "src/main/java/org/ice4j/security/CredentialsManager.java.CredentialsManager.[void]unregisterAuthority(CredentialsAuthority)", "name": "unregisterAuthority", "arg_nums": 1, "params": [{"name": "authority", "type": "CredentialsAuthority"}], "return_type": "void", "signature": "public void unregisterAuthority(CredentialsAuthority authority)", "original_string": "    public void unregisterAuthority(CredentialsAuthority authority)\n    {\n        synchronized (authorities)\n        {\n            if (authorities.remove(authority))\n                unmodifiableAuthorities = null;\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/security/CredentialsManager.java", "class_name": "CredentialsManager", "class_uri": "src/main/java/org/ice4j/security/CredentialsManager.java.CredentialsManager", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nRemoves <tt>authority</tt> from the list of {@link CredentialsAuthority}s\nregistered with this manager.\n\n@param authority the {@link CredentialsAuthority} to remove from this\nmanager.\n"}, {"uris": "src/main/java/org/ice4j/util/PeriodicRunnable.java.PeriodicRunnable.[]PeriodicRunnable(ScheduledExecutorService,ExecutorService)", "name": "PeriodicRunnable", "arg_nums": 2, "params": [{"name": "timer", "type": "ScheduledExecutorService"}, {"name": "executor", "type": "ExecutorService"}], "return_type": "", "signature": "protected PeriodicRunnable(\n        ScheduledExecutorService timer,\n        ExecutorService executor)", "original_string": "    protected PeriodicRunnable(\n        ScheduledExecutorService timer,\n        ExecutorService executor)\n    {\n        if (timer == null)\n        {\n            throw new IllegalArgumentException(\"timer is null\");\n        }\n        if (executor == null)\n        {\n            throw new IllegalArgumentException(\"executor is null\");\n        }\n        this.timer = timer;\n        this.executor = executor;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/util/PeriodicRunnable.java", "class_name": "PeriodicRunnable", "class_uri": "src/main/java/org/ice4j/util/PeriodicRunnable.java.PeriodicRunnable", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nCreate instance of {@link PeriodicRunnable} with specified timer and\nexecutor.\n@param timer an {@link ScheduledExecutorService} which is used to\n             periodic triggering of {@link #run()} execution.\n@param executor an {@link ExecutorService} to perform actual execution\n                of {@link #run()}.\n"}, {"uris": "src/main/java/org/ice4j/util/PeriodicRunnable.java.PeriodicRunnable.[Duration]getDelayUntilNextRun()", "name": "getDelayUntilNextRun", "arg_nums": 0, "params": [], "return_type": "Duration", "signature": "protected abstract Duration getDelayUntilNextRun()", "original_string": "    protected abstract Duration getDelayUntilNextRun();", "default_arguments": null, "file": "src/main/java/org/ice4j/util/PeriodicRunnable.java", "class_name": "PeriodicRunnable", "class_uri": "src/main/java/org/ice4j/util/PeriodicRunnable.java.PeriodicRunnable", "attributes": {"modifiers": "protected abstract", "marker_annotations": [], "non_marker_annotations": ["protected", "abstract"], "comments": [], "return_type": "Duration", "classes": []}, "docstring": "\nGet delay before next execution of {@link #run()}.\n@return non-negative value if execution of {@link #run()} should be\nperformed with specified delay, negative value if execution should not\nbe done.\n"}, {"uris": "src/main/java/org/ice4j/util/PeriodicRunnable.java.PeriodicRunnable.[void]run()", "name": "run", "arg_nums": 0, "params": [], "return_type": "void", "signature": "protected abstract void run()", "original_string": "    protected abstract void run();", "default_arguments": null, "file": "src/main/java/org/ice4j/util/PeriodicRunnable.java", "class_name": "PeriodicRunnable", "class_uri": "src/main/java/org/ice4j/util/PeriodicRunnable.java.PeriodicRunnable", "attributes": {"modifiers": "protected abstract", "marker_annotations": [], "non_marker_annotations": ["protected", "abstract"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nPeriodically executed method on {@link #executor}'s thread.\n"}, {"uris": "src/main/java/org/ice4j/util/PeriodicRunnable.java.PeriodicRunnable.[void]schedule()", "name": "schedule", "arg_nums": 0, "params": [], "return_type": "void", "signature": "public void schedule()", "original_string": "    public void schedule()\n    {\n        if (running)\n        {\n            return;\n        }\n\n        final Duration delay =\n            getDelayUntilNextRun();\n\n        scheduleNextRun(delay);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/util/PeriodicRunnable.java", "class_name": "PeriodicRunnable", "class_uri": "src/main/java/org/ice4j/util/PeriodicRunnable.java.PeriodicRunnable", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSchedules periodic execution of {@link #run()} on {@link #executor}'s\nthread.\n"}, {"uris": "src/main/java/org/ice4j/util/PeriodicRunnable.java.PeriodicRunnable.[void]cancel()", "name": "cancel", "arg_nums": 0, "params": [], "return_type": "void", "signature": "public void cancel()", "original_string": "    public void cancel()\n    {\n        if (!running)\n        {\n            return;\n        }\n\n        synchronized (syncRoot)\n        {\n            if (running)\n            {\n                running = false;\n\n                if (scheduledSubmit != null)\n                {\n                    scheduledSubmit.cancel(true);\n                    scheduledSubmit = null;\n                }\n\n                if (submittedExecute != null)\n                {\n                    submittedExecute.cancel(true);\n                    submittedExecute = null;\n                }\n            }\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/util/PeriodicRunnable.java", "class_name": "PeriodicRunnable", "class_uri": "src/main/java/org/ice4j/util/PeriodicRunnable.java.PeriodicRunnable", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCancels periodic execution of {@link #run()} on {@link #executor}'s\nthread.\n"}, {"uris": "src/main/java/org/ice4j/util/PeriodicRunnable.java.PeriodicRunnable.[void]scheduleNextRun(Duration)", "name": "scheduleNextRun", "arg_nums": 1, "params": [{"name": "delay", "type": "Duration"}], "return_type": "void", "signature": "private void scheduleNextRun(Duration delay)", "original_string": "    private void scheduleNextRun(Duration delay)\n    {\n        synchronized (syncRoot)\n        {\n            final boolean isRecurrentRun = submittedExecute != null;\n            if (isRecurrentRun && !running)\n            {\n                // was cancelled\n                return;\n            }\n\n            if (delay.isNegative())\n            {\n                running = false;\n                scheduledSubmit = null;\n                submittedExecute = null;\n                return;\n            }\n\n            running = true;\n\n            if (delay.isZero())\n            {\n                submitExecuteRun();\n            }\n            else\n            {\n                scheduledSubmit = timer.schedule(\n                    this::submitExecuteRun,\n                    delay.toNanos(),\n                    TimeUnit.NANOSECONDS);\n            }\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/util/PeriodicRunnable.java", "class_name": "PeriodicRunnable", "class_uri": "src/main/java/org/ice4j/util/PeriodicRunnable.java.PeriodicRunnable", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nPerform either cancellation or actual scheduling based on delay until\nnext run.\n@param delay delay before next execution of {@link #run()}.\n"}, {"uris": "src/main/java/org/ice4j/util/PeriodicRunnable.java.PeriodicRunnable.[void]submitExecuteRun()", "name": "submitExecuteRun", "arg_nums": 0, "params": [], "return_type": "void", "signature": "private void submitExecuteRun()", "original_string": "    private void submitExecuteRun()\n    {\n        if (!running)\n        {\n            return;\n        }\n        synchronized (syncRoot)\n        {\n            if (!running)\n            {\n                return;\n            }\n            submittedExecute = this.executor.submit(this::executeRun);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/util/PeriodicRunnable.java", "class_name": "PeriodicRunnable", "class_uri": "src/main/java/org/ice4j/util/PeriodicRunnable.java.PeriodicRunnable", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSubmit execution of {@link #run()} into {@link #executor}'s thread\nif not cancelled.\n"}, {"uris": "src/main/java/org/ice4j/util/PeriodicRunnable.java.PeriodicRunnable.[void]executeRun()", "name": "executeRun", "arg_nums": 0, "params": [], "return_type": "void", "signature": "private void executeRun()", "original_string": "    private void executeRun()\n    {\n        if (!running)\n        {\n            return;\n        }\n\n        try\n        {\n            this.run();\n        }\n        catch (Exception e)\n        {\n            logger.warn(\"Exception in run(), will retry.\", e);\n        }\n        finally\n        {\n            if (running)\n            {\n                final Duration delayMillis =\n                    getDelayUntilNextRun();\n\n                scheduleNextRun(delayMillis);\n            }\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/util/PeriodicRunnable.java", "class_name": "PeriodicRunnable", "class_uri": "src/main/java/org/ice4j/util/PeriodicRunnable.java.PeriodicRunnable", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nPerform execution of {@link #run()} with further re-schedule of\nexecution if not cancelled\n"}, {"uris": "src/main/java/org/ice4j/util/PeriodicRunnable.java.PeriodicRunnable.[PeriodicRunnable]create(ScheduledExecutorService,ExecutorService,Duration,Runnable)", "name": "create", "arg_nums": 4, "params": [{"name": "timer", "type": "ScheduledExecutorService"}, {"name": "executor", "type": "ExecutorService"}, {"name": "period", "type": "Duration"}, {"name": "r", "type": "Runnable"}], "return_type": "PeriodicRunnable", "signature": "static PeriodicRunnable create(\n        ScheduledExecutorService timer,\n        ExecutorService executor,\n        Duration period,\n        Runnable r)", "original_string": "    static PeriodicRunnable create(\n        ScheduledExecutorService timer,\n        ExecutorService executor,\n        Duration period,\n        Runnable r)\n    {\n        return new PeriodicRunnable(timer, executor)\n        {\n            @Override\n            protected Duration getDelayUntilNextRun()\n            {\n                return period;\n            }\n\n            @Override\n            protected void run()\n            {\n                r.run();\n            }\n        };\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/util/PeriodicRunnable.java", "class_name": "PeriodicRunnable", "class_uri": "src/main/java/org/ice4j/util/PeriodicRunnable.java.PeriodicRunnable", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "PeriodicRunnable", "classes": []}, "docstring": "\nConstructs {@link PeriodicRunnable} for {@link Runnable} with provided\ntimer, executor and fixed delay.\nfixed delay.\n@param timer {@link ScheduledExecutorService} to be used as timer\n@param executor {@link ExecutorService} to execute provided runnable\n@param period delay between subsequent execution of runnable\n@param r {@link Runnable} to for periodic execution.\n@return {@link PeriodicRunnable} instance constructed with provided\narguments\n"}, {"uris": "src/main/java/org/ice4j/util/Ice4jLogFormatter.java.Ice4jLogFormatter.[String]format(LogRecord)", "name": "format", "arg_nums": 1, "params": [{"name": "record", "type": "LogRecord"}], "return_type": "String", "signature": "public synchronized String format(LogRecord record)", "original_string": "    public synchronized String format(LogRecord record)\n    {\n        StringBuffer sb = new StringBuffer();\n\n        //current time\n        Calendar cal = Calendar.getInstance();\n        int hour = cal.get(Calendar.HOUR_OF_DAY);\n        int minutes = cal.get(Calendar.MINUTE);\n        int seconds = cal.get(Calendar.SECOND);\n        int millis = cal.get(Calendar.MILLISECOND);\n\n        sb.append(twoDigFmt.format(hour)).append(':');\n        sb.append(twoDigFmt.format(minutes)).append(':');\n        sb.append(twoDigFmt.format(seconds)).append('.');\n        sb.append(threeDigFmt.format(millis)).append(' ');\n\n        //log level\n        sb.append(record.getLevel().getLocalizedName());\n        sb.append(\": \");\n\n        //caller method\n        int lineNumber = inferCaller(record);\n        String loggerName = record.getLoggerName();\n\n        if (loggerName == null)\n            loggerName = record.getSourceClassName();\n\n        if (loggerName.startsWith(\"net.java.sip.communicator.\"))\n        {\n            sb.append(loggerName.substring(\"net.java.sip.communicator.\"\n                                           .length()));\n        }\n        else\n            sb.append(record.getLoggerName());\n\n        if (record.getSourceMethodName() != null)\n        {\n            sb.append(\".\");\n            sb.append(record.getSourceMethodName());\n\n            //include the line number if we have it.\n            if (lineNumber != -1)\n                sb.append(\"().\").append(Integer.toString(lineNumber));\n            else\n                sb.append(\"()\");\n        }\n        sb.append(\" \");\n        sb.append(record.getMessage());\n        sb.append(lineSeparator);\n        if (record.getThrown() != null)\n        {\n            try\n            {\n                StringWriter sw = new StringWriter();\n                PrintWriter pw = new PrintWriter(sw);\n                record.getThrown().printStackTrace(pw);\n                pw.close();\n                sb.append(sw.toString());\n            }\n            catch (Exception ex)\n            {\n            }\n        }\n        return sb.toString();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/util/Ice4jLogFormatter.java", "class_name": "Ice4jLogFormatter", "class_uri": "src/main/java/org/ice4j/util/Ice4jLogFormatter.java.Ice4jLogFormatter", "attributes": {"modifiers": "public synchronized", "marker_annotations": [], "non_marker_annotations": ["public", "synchronized"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nFormat the given LogRecord.\n@param record the log record to be formatted.\n@return a formatted log record\n"}, {"uris": "src/main/java/org/ice4j/util/Ice4jLogFormatter.java.Ice4jLogFormatter.[int]inferCaller(LogRecord)", "name": "inferCaller", "arg_nums": 1, "params": [{"name": "record", "type": "LogRecord"}], "return_type": "int", "signature": "private int inferCaller(LogRecord record)", "original_string": "    private int inferCaller(LogRecord record)\n    {\n        // Get the stack trace.\n        StackTraceElement stack[] = (new Throwable()).getStackTrace();\n\n        //the line number that the caller made the call from\n        int lineNumber = -1;\n\n        // First, search back to a method in the SIP Communicator Logger class.\n        int ix = 0;\n        while (ix < stack.length)\n        {\n            StackTraceElement frame = stack[ix];\n            String cname = frame.getClassName();\n            if (cname.equals(\"net.java.sip.communicator.util.Logger\"))\n            {\n                break;\n            }\n            ix++;\n        }\n        // Now search for the first frame before the SIP Communicator Logger class.\n        while (ix < stack.length)\n        {\n            StackTraceElement frame = stack[ix];\n            lineNumber=stack[ix].getLineNumber();\n            String cname = frame.getClassName();\n            if (!cname.equals(\"net.java.sip.communicator.util.Logger\"))\n            {\n                // We've found the relevant frame.\n                record.setSourceClassName(cname);\n                record.setSourceMethodName(frame.getMethodName());\n                break;\n            }\n            ix++;\n        }\n\n        return lineNumber;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/util/Ice4jLogFormatter.java", "class_name": "Ice4jLogFormatter", "class_uri": "src/main/java/org/ice4j/util/Ice4jLogFormatter.java.Ice4jLogFormatter", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\nTry to extract the name of the class and method that called the current\nlog statement.\n\n@param record the logrecord where class and method name should be stored.\n\n@return the line number that the call was made from in the caller.\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/IPseudoTcpNotify.java.IPseudoTcpNotify.[void]OnTcpOpen(PseudoTCPBase)", "name": "OnTcpOpen", "arg_nums": 1, "params": [{"name": "tcp", "type": "PseudoTCPBase"}], "return_type": "void", "signature": "void OnTcpOpen(PseudoTCPBase tcp)", "original_string": "    void OnTcpOpen(PseudoTCPBase tcp);", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/IPseudoTcpNotify.java", "class_name": "IPseudoTcpNotify", "class_uri": "src/main/java/org/ice4j/pseudotcp/IPseudoTcpNotify.java.IPseudoTcpNotify", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCalled when tcp enters opened state\n@param tcp \n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/IPseudoTcpNotify.java.IPseudoTcpNotify.[void]OnTcpReadable(PseudoTCPBase)", "name": "OnTcpReadable", "arg_nums": 1, "params": [{"name": "tcp", "type": "PseudoTCPBase"}], "return_type": "void", "signature": "void OnTcpReadable(PseudoTCPBase tcp)", "original_string": "    void OnTcpReadable(PseudoTCPBase tcp);", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/IPseudoTcpNotify.java", "class_name": "IPseudoTcpNotify", "class_uri": "src/main/java/org/ice4j/pseudotcp/IPseudoTcpNotify.java.IPseudoTcpNotify", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCalled when any data is available in read buffer\n@param tcp \n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/IPseudoTcpNotify.java.IPseudoTcpNotify.[void]OnTcpWriteable(PseudoTCPBase)", "name": "OnTcpWriteable", "arg_nums": 1, "params": [{"name": "tcp", "type": "PseudoTCPBase"}], "return_type": "void", "signature": "void OnTcpWriteable(PseudoTCPBase tcp)", "original_string": "    void OnTcpWriteable(PseudoTCPBase tcp);", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/IPseudoTcpNotify.java", "class_name": "IPseudoTcpNotify", "class_uri": "src/main/java/org/ice4j/pseudotcp/IPseudoTcpNotify.java.IPseudoTcpNotify", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCalled when there is free space available in the send buffer\n@param tcp \n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/IPseudoTcpNotify.java.IPseudoTcpNotify.[void]OnTcpClosed(PseudoTCPBase,IOException)", "name": "OnTcpClosed", "arg_nums": 2, "params": [{"name": "tcp", "type": "PseudoTCPBase"}, {"name": "e", "type": "IOException"}], "return_type": "void", "signature": "void OnTcpClosed(PseudoTCPBase tcp, IOException e)", "original_string": "    void OnTcpClosed(PseudoTCPBase tcp, IOException e);", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/IPseudoTcpNotify.java", "class_name": "IPseudoTcpNotify", "class_uri": "src/main/java/org/ice4j/pseudotcp/IPseudoTcpNotify.java.IPseudoTcpNotify", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCalled when tcp enters closed state\n@param tcp\n@param e null means no error\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/IPseudoTcpNotify.java.IPseudoTcpNotify.[WriteResult]TcpWritePacket(PseudoTCPBase,byte[],int)", "name": "TcpWritePacket", "arg_nums": 3, "params": [{"name": "tcp", "type": "PseudoTCPBase"}, {"name": "buffer", "type": "byte[]"}, {"name": "len", "type": "int"}], "return_type": "WriteResult", "signature": "WriteResult TcpWritePacket(PseudoTCPBase tcp, byte[] buffer, int len)", "original_string": "    WriteResult TcpWritePacket(PseudoTCPBase tcp, byte[] buffer, int len);", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/IPseudoTcpNotify.java", "class_name": "IPseudoTcpNotify", "class_uri": "src/main/java/org/ice4j/pseudotcp/IPseudoTcpNotify.java.IPseudoTcpNotify", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "WriteResult", "classes": []}, "docstring": "\nCalled when protocol requests packet transfer through the network.\n@param tcp\n@param buffer data\n@param len data length\n@return the result, see {@link WriteResult} description for more info\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/SSegment.java.SSegment.[]SSegment(long,long,boolean)", "name": "SSegment", "arg_nums": 3, "params": [{"name": "s", "type": "long"}, {"name": "l", "type": "long"}, {"name": "c", "type": "boolean"}], "return_type": "", "signature": "SSegment(long s, long l, boolean c)", "original_string": "    SSegment(long s, long l, boolean c)\n    {\n        seq = s;\n        len = l;\n        xmit = 0;\n        bCtrl = c;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/SSegment.java", "class_name": "SSegment", "class_uri": "src/main/java/org/ice4j/pseudotcp/SSegment.java.SSegment", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpNotify.java.PseudoTcpNotify.[void]onTcpOpen(PseudoTCPBase)", "name": "onTcpOpen", "arg_nums": 1, "params": [{"name": "tcp", "type": "PseudoTCPBase"}], "return_type": "void", "signature": "void onTcpOpen(PseudoTCPBase tcp)", "original_string": "    void onTcpOpen(PseudoTCPBase tcp);", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpNotify.java", "class_name": "PseudoTcpNotify", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpNotify.java.PseudoTcpNotify", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCalled when TCP enters opened state\n@param tcp the socket that was opened\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpNotify.java.PseudoTcpNotify.[void]onTcpReadable(PseudoTCPBase)", "name": "onTcpReadable", "arg_nums": 1, "params": [{"name": "tcp", "type": "PseudoTCPBase"}], "return_type": "void", "signature": "void onTcpReadable(PseudoTCPBase tcp)", "original_string": "    void onTcpReadable(PseudoTCPBase tcp);", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpNotify.java", "class_name": "PseudoTcpNotify", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpNotify.java.PseudoTcpNotify", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCalled when any data is available in read buffer\n@param tcp the socket that became readable\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpNotify.java.PseudoTcpNotify.[void]onTcpWriteable(PseudoTCPBase)", "name": "onTcpWriteable", "arg_nums": 1, "params": [{"name": "tcp", "type": "PseudoTCPBase"}], "return_type": "void", "signature": "void onTcpWriteable(PseudoTCPBase tcp)", "original_string": "    void onTcpWriteable(PseudoTCPBase tcp);", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpNotify.java", "class_name": "PseudoTcpNotify", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpNotify.java.PseudoTcpNotify", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCalled when there is free space available in the send buffer\n@param tcp the socket that became writable\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpNotify.java.PseudoTcpNotify.[void]onTcpClosed(PseudoTCPBase,IOException)", "name": "onTcpClosed", "arg_nums": 2, "params": [{"name": "tcp", "type": "PseudoTCPBase"}, {"name": "e", "type": "IOException"}], "return_type": "void", "signature": "void onTcpClosed(PseudoTCPBase tcp, IOException e)", "original_string": "    void onTcpClosed(PseudoTCPBase tcp, IOException e);", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpNotify.java", "class_name": "PseudoTcpNotify", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpNotify.java.PseudoTcpNotify", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCalled when tcp enters closed state\n@param tcp the socket that was closed\n@param e null means no error\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpNotify.java.PseudoTcpNotify.[WriteResult]tcpWritePacket(PseudoTCPBase,byte[],int)", "name": "tcpWritePacket", "arg_nums": 3, "params": [{"name": "tcp", "type": "PseudoTCPBase"}, {"name": "buffer", "type": "byte[]"}, {"name": "len", "type": "int"}], "return_type": "WriteResult", "signature": "WriteResult tcpWritePacket(PseudoTCPBase tcp, byte[] buffer, int len)", "original_string": "    WriteResult tcpWritePacket(PseudoTCPBase tcp, byte[] buffer, int len);", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpNotify.java", "class_name": "PseudoTcpNotify", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpNotify.java.PseudoTcpNotify", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "WriteResult", "classes": []}, "docstring": "\nCalled when protocol requests packet transfer through the network.\n@param tcp the socket on which the write occurred\n@param buffer the data that was written\n@param len data length\n@return the result, see {@link WriteResult} description for more info\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketFactory.java.PseudoTcpSocketFactory.[Socket]createSocket(String,int)", "name": "createSocket", "arg_nums": 2, "params": [{"name": "host", "type": "String"}, {"name": "port", "type": "int"}], "return_type": "Socket", "signature": "public Socket createSocket(String host, int port)", "original_string": "    public Socket createSocket(String host, int port)\n        throws IOException,\n               UnknownHostException\n    {\n        Socket socket = createSocket();\n        connectSocket(socket, new InetSocketAddress(host, port));\n        return socket;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketFactory.java", "class_name": "PseudoTcpSocketFactory", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketFactory.java.PseudoTcpSocketFactory", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Socket", "classes": []}, "docstring": "\nCreates a socket and connects it to the specified \nport number at the specified address.\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketFactory.java.PseudoTcpSocketFactory.[Socket]createSocket(InetAddress,int)", "name": "createSocket", "arg_nums": 2, "params": [{"name": "host", "type": "InetAddress"}, {"name": "port", "type": "int"}], "return_type": "Socket", "signature": "public Socket createSocket(InetAddress host, int port)", "original_string": "    public Socket createSocket(InetAddress host, int port) throws IOException\n    {\n        Socket socket = createSocket();\n        connectSocket(socket, new InetSocketAddress(host, port));\n        return socket;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketFactory.java", "class_name": "PseudoTcpSocketFactory", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketFactory.java.PseudoTcpSocketFactory", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Socket", "classes": []}, "docstring": "\nCreates a socket and connect it to the specified remote address \non the specified remote port.\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketFactory.java.PseudoTcpSocketFactory.[void]connectSocket(Socket,InetSocketAddress)", "name": "connectSocket", "arg_nums": 2, "params": [{"name": "socket", "type": "Socket"}, {"name": "remoteSockAddr", "type": "InetSocketAddress"}], "return_type": "void", "signature": "private void connectSocket(Socket socket, InetSocketAddress remoteSockAddr)", "original_string": "    private void connectSocket(Socket socket, InetSocketAddress remoteSockAddr)\n        throws IOException\n    {\n        socket.connect(remoteSockAddr, DEFAULT_CONNECT_TIMEOUT);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketFactory.java", "class_name": "PseudoTcpSocketFactory", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketFactory.java.PseudoTcpSocketFactory", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketFactory.java.PseudoTcpSocketFactory.[Socket]createBoundSocket(InetSocketAddress)", "name": "createBoundSocket", "arg_nums": 1, "params": [{"name": "sockAddr", "type": "InetSocketAddress"}], "return_type": "Socket", "signature": "public Socket createBoundSocket(InetSocketAddress sockAddr)", "original_string": "    public Socket createBoundSocket(InetSocketAddress sockAddr) \n        throws IOException\n    {\n        return new PseudoTcpSocket(\n            new PseudoTcpSocketImpl(DEFAULT_CONVERSATION_ID,\n                new DatagramSocket(sockAddr)));\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketFactory.java", "class_name": "PseudoTcpSocketFactory", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketFactory.java.PseudoTcpSocketFactory", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Socket", "classes": []}, "docstring": "\nCreates socket bound to local <tt>sockAddr</tt>\n@param sockAddr address for the pseudo socket\n@return socket bound to local address\n@throws IOException if the socket could not be opened, or the socket\ncould not bind to the specified local port.\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketFactory.java.PseudoTcpSocketFactory.[Socket]createSocket(String,int,InetAddress,int)", "name": "createSocket", "arg_nums": 4, "params": [{"name": "host", "type": "String"}, {"name": "port", "type": "int"}, {"name": "localHost", "type": "InetAddress"}, {"name": "localPort", "type": "int"}], "return_type": "Socket", "signature": "public Socket createSocket(String host, \n                               int port, \n                               InetAddress localHost,\n                               int localPort)", "original_string": "    public Socket createSocket(String host, \n                               int port, \n                               InetAddress localHost,\n                               int localPort)\n        throws IOException, \n               UnknownHostException\n    {\n        Socket socket = createBoundSocket(\n                        new InetSocketAddress(localHost, localPort));\n        connectSocket(socket, new InetSocketAddress(host, port));\n        return socket;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketFactory.java", "class_name": "PseudoTcpSocketFactory", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketFactory.java.PseudoTcpSocketFactory", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Socket", "classes": []}, "docstring": "\n Creates a socket and connects it to the specified remote host at the specified remote port.\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketFactory.java.PseudoTcpSocketFactory.[Socket]createSocket(InetAddress,int,InetAddress,int)", "name": "createSocket", "arg_nums": 4, "params": [{"name": "address", "type": "InetAddress"}, {"name": "port", "type": "int"}, {"name": "localAddress", "type": "InetAddress"}, {"name": "localPort", "type": "int"}], "return_type": "Socket", "signature": "public Socket createSocket(InetAddress address, int port,\n        InetAddress localAddress, int localPort)", "original_string": "    public Socket createSocket(InetAddress address, int port,\n        InetAddress localAddress, int localPort) throws IOException\n    {\n        Socket socket = createBoundSocket(\n            new InetSocketAddress(localAddress, localPort));\n        connectSocket(socket, new InetSocketAddress(address, port));\n        return socket;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketFactory.java", "class_name": "PseudoTcpSocketFactory", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketFactory.java.PseudoTcpSocketFactory", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Socket", "classes": []}, "docstring": "\nCreates a socket and connects it to the specified remote host on the specified remote port.\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketFactory.java.PseudoTcpSocketFactory.[PseudoTcpSocket]createSocket(DatagramSocket)", "name": "createSocket", "arg_nums": 1, "params": [{"name": "datagramSocket", "type": "DatagramSocket"}], "return_type": "PseudoTcpSocket", "signature": "public PseudoTcpSocket createSocket(DatagramSocket datagramSocket)", "original_string": "    public PseudoTcpSocket createSocket(DatagramSocket datagramSocket) \n        throws SocketException\n    {        \n        return new PseudoTcpSocket(\n            new PseudoTcpSocketImpl(DEFAULT_CONVERSATION_ID, datagramSocket));\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketFactory.java", "class_name": "PseudoTcpSocketFactory", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketFactory.java.PseudoTcpSocketFactory", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "PseudoTcpSocket", "classes": []}, "docstring": "\nCreates a socket that will run on given <tt>datagramSocket</tt>\n\n@param datagramSocket the socket to run on\n@return new socket running on given <tt>datagramSocket</tt>\n@throws SocketException if there is an error in the underlying protocol,\nsuch as a TCP error.\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketFactory.java.PseudoTcpSocketFactory.[PseudoTcpSocket]createSocket()", "name": "createSocket", "arg_nums": 0, "params": [], "return_type": "PseudoTcpSocket", "signature": "@Override\n    public PseudoTcpSocket createSocket()", "original_string": "    @Override\n    public PseudoTcpSocket createSocket() \n        throws SocketException\n    {        \n        return new PseudoTcpSocket(\n            new PseudoTcpSocketImpl(DEFAULT_CONVERSATION_ID));\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketFactory.java", "class_name": "PseudoTcpSocketFactory", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketFactory.java.PseudoTcpSocketFactory", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "PseudoTcpSocket", "classes": []}, "docstring": "\nCreates the PseudoTcp socket and binds it to any available port\non the local host machine.  The socket will be bound to the\n{@link InetAddress#isAnyLocalAddress wildcard} address,\nan IP address chosen by the kernel.\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketFactory.java.PseudoTcpSocketFactory.[SocketImpl]createSocketImpl()", "name": "createSocketImpl", "arg_nums": 0, "params": [], "return_type": "SocketImpl", "signature": "public SocketImpl createSocketImpl()", "original_string": "    public SocketImpl createSocketImpl()\n    {\n        try\n        {\n            return new PseudoTcpSocketImpl(DEFAULT_CONVERSATION_ID);\n        }\n        catch (SocketException e)\n        {\n            throw new RuntimeException(e);\n        }        \n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketFactory.java", "class_name": "PseudoTcpSocketFactory", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketFactory.java.PseudoTcpSocketFactory", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "SocketImpl", "classes": []}, "docstring": ""}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[]PseudoTCPBase(PseudoTcpNotify,long)", "name": "PseudoTCPBase", "arg_nums": 2, "params": [{"name": "notify", "type": "PseudoTcpNotify"}, {"name": "conv", "type": "long"}], "return_type": "", "signature": "public PseudoTCPBase(PseudoTcpNotify notify, long conv)", "original_string": "    public PseudoTCPBase(PseudoTcpNotify notify, long conv)\n    {\n        m_notify = notify;\n        m_shutdown = EnShutdown.SD_NONE;\n        m_rbuf_len = DEFAULT_RCV_BUF_SIZE;\n        m_rbuf = new ByteFifoBuffer(m_rbuf_len);\n        m_sbuf_len = DEFAULT_SND_BUF_SIZE;\n        m_sbuf = new ByteFifoBuffer(m_sbuf_len);\n        // Sanity check on buffer sizes (needed for OnTcpWriteable notification logic)\n        assert m_rbuf_len + MIN_PACKET < m_sbuf_len;\n        long now = now();\n\n        m_state = PseudoTcpState.TCP_LISTEN;\n        m_conv = conv;\n        m_rcv_wnd = m_rbuf_len;\n        m_rwnd_scale = m_swnd_scale = 0;\n        m_snd_nxt = 0;\n        m_snd_wnd = 1;\n        m_snd_una = m_rcv_nxt = 0;\n        m_bReadEnable = true;\n        m_bWriteEnable = false;\n        m_t_ack = 0;\n\n        m_msslevel = 0;\n        m_largest = 0;\n        assert MIN_PACKET > PACKET_OVERHEAD;\n        m_mss = MIN_PACKET - PACKET_OVERHEAD;\n        m_mtu_advise = MAX_PACKET;\n\n        m_rto_base = 0;\n\n        m_cwnd = 2 * m_mss;\n        m_ssthresh = m_rbuf_len;\n        m_lastrecv = m_lastsend = m_lasttraffic = now;\n        m_bOutgoing = false;\n\n        m_dup_acks = 0;\n        m_recover = 0;\n\n        m_ts_recent = m_ts_lastack = 0;\n\n        m_rx_rto = DEF_RTO;\n        m_rx_srtt = m_rx_rttvar = 0;\n\n        m_use_nagling = true;\n        m_ack_delay = DEF_ACK_DELAY;\n        m_support_wnd_scale = false;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java", "class_name": "PseudoTCPBase", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\n\n@param notify {@link PseudoTcpNotify} implementation\n@param conv the conversation number used by this instance\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[void]connect()", "name": "connect", "arg_nums": 0, "params": [], "return_type": "void", "signature": "public void connect()", "original_string": "    public void connect() throws IOException\n    {\n        if (m_state != PseudoTcpState.TCP_LISTEN)\n        {\n            //m_error = PseudoTcpError.EINVAL;\n            throw new IOException(\"Invalid socket state: \"+m_state);\n        }\n\n        m_state = PseudoTcpState.TCP_SYN_SENT;\n        logger.log(Level.FINE, \"State: TCP_SYN_SENT\", \"\");\n\n        queueConnectMessage();\n        attemptSend(SendFlags.sfNone);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java", "class_name": "PseudoTCPBase", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nEnqueues connect message and starts connection procedure\n\n@throws IOException if the protocol is not in initial state\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[void]notifyMTU(int)", "name": "notifyMTU", "arg_nums": 1, "params": [{"name": "mtu", "type": "int"}], "return_type": "void", "signature": "public void notifyMTU(int mtu)", "original_string": "    public void notifyMTU(int mtu)\n    {\n        m_mtu_advise = mtu;\n        if (m_state == PseudoTcpState.TCP_ESTABLISHED)\n        {\n            adjustMTU();\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java", "class_name": "PseudoTCPBase", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSet the MTU (maximum transmission unit) value\n\n@param mtu the new MTU value\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[int]getMTU()", "name": "getMTU", "arg_nums": 0, "params": [], "return_type": "int", "signature": "public int getMTU()", "original_string": "    public int getMTU()\n    {\n        return (int)m_mtu_advise;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java", "class_name": "PseudoTCPBase", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\n\n@return MTU value\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[long]now()", "name": "now", "arg_nums": 0, "params": [], "return_type": "long", "signature": "public static long now()", "original_string": "    public static long now()\n    {\n        return (System.nanoTime() / 1000000) & 0xFFFFFFFFL;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java", "class_name": "PseudoTCPBase", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "long", "classes": []}, "docstring": "\n@return current timestamp limited to 32 bits\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[long]getNextClock(long)", "name": "getNextClock", "arg_nums": 1, "params": [{"name": "now", "type": "long"}], "return_type": "long", "signature": "public long getNextClock(long now)", "original_string": "    public long getNextClock(long now)\n    {\n        return clock_check(now);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java", "class_name": "PseudoTCPBase", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "long", "classes": []}, "docstring": "\nEvaluate next interval between <tt>getNextClock</tt> calls.\nIt is based on current protocol action timeout\n\n@param now current timestamp\n@return next interval\n\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[void]notifyClock(long)", "name": "notifyClock", "arg_nums": 1, "params": [{"name": "now", "type": "long"}], "return_type": "void", "signature": "public void notifyClock(long now)", "original_string": "    public void notifyClock(long now)\n    {\n        /*if (logger.isLoggable(Level.FINEST))\n        {\n            logger.log(Level.FINEST, debugName + \" update clock \" + now);\n        }*/\n        if (m_state == PseudoTcpState.TCP_CLOSED)\n        {\n            return;\n        }\n\n        // Check if it's time to retransmit a segment\n        if (m_rto_base > 0 && (timeDiff(m_rto_base + m_rx_rto, now) <= 0))\n        {\n            assert !m_slist.isEmpty();\n            // retransmit segments\n            if (logger.isLoggable(Level.FINER))\n            {\n                logger.log(Level.FINER, \"timeout retransmit (rto: \" + m_rx_rto\n                    + \")(rto_base: \" + m_rto_base + \") (now: \" + now + \") (dup_acks: \"\n                    + m_dup_acks + \")\");\n            }\n            if (!transmit(m_slist.get(0), now))\n            {\n                closedown(new IOException(\"Connection aborted\"));\n                return;\n            }\n\n            long nInFlight = m_snd_nxt - m_snd_una;\n            m_ssthresh = Math.max(nInFlight / 2, 2 * m_mss);\n            //Logger.Log(LS_INFO)\n            //  << \"m_ssthresh: \" << m_ssthresh << \"  nInFlight: \" << nInFlight << \"  m_mss: \" << m_mss;\n            m_cwnd = m_mss;\n\n            // Back off retransmit timer.  Note: the limit is lower when connecting.\n            long rto_limit = (m_state.ordinal() < PseudoTcpState.TCP_ESTABLISHED.ordinal())\n                ? DEF_RTO : MAX_RTO;\n            m_rx_rto = Math.min(rto_limit, m_rx_rto * 2);\n            m_rto_base = now;\n        }\n\n        // Check if it's time to probe closed windows\n        if ((getM_snd_wnd() == 0) && (timeDiff(m_lastsend + m_rx_rto, now) <= 0))\n        {\n            if (timeDiff(now, m_lastrecv) >= 15000)\n            {\n                closedown(new IOException(\"Connection aborted\"));\n                return;\n            }\n            // probe the window\n            packet(m_snd_nxt - 1, (short) 0, 0, 0);\n            m_lastsend = now;\n\n            // back off retransmit timer\n            m_rx_rto = Math.min(MAX_RTO, m_rx_rto * 2);\n        }\n\n        // Check if it's time to send delayed acks\n        long timeDiff = timeDiff(m_t_ack + m_ack_delay, now);\n        if (m_t_ack > 0 && (timeDiff <= 0))\n        {\n            packet(m_snd_nxt, (short) 0, 0, 0);\n        }\n\n        if (PSEUDO_KEEPALIVE) // Check for idle timeout\n        {\n            if ((m_state == PseudoTcpState.TCP_ESTABLISHED)\n                && (timeDiff(m_lastrecv + IDLE_TIMEOUT, now) <= 0))\n            {\n                closedown(new IOException(\"Connection aborted\"));\n                return;\n            }\n\n            // Check for ping timeout (to keep udp mapping open)\n            if ((m_state == PseudoTcpState.TCP_ESTABLISHED)\n                && (timeDiff(m_lasttraffic + (m_bOutgoing ? IDLE_PING * 3 / 2 : IDLE_PING), now) <= 0))\n            {\n                packet(m_snd_nxt, (short) 0, 0, 0);\n            }\n\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java", "class_name": "PseudoTCPBase", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nThis method should be called in time intervals retrieved \nfrom <tt>getNextClock</tt>\n\n@param now current timestamp\n@see PseudoTCPBase#getNextClock(long)\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[boolean]notifyPacket(byte[],int)", "name": "notifyPacket", "arg_nums": 2, "params": [{"name": "buffer", "type": "byte[]"}, {"name": "len", "type": "int"}], "return_type": "boolean", "signature": "synchronized public boolean notifyPacket(byte[] buffer, int len)", "original_string": "    synchronized public boolean notifyPacket(byte[] buffer, int len)\n    {\n        if (len > MAX_PACKET)\n        {\n            logger.log(Level.WARNING, debugName + \" packet too large\");\n            return false;\n        }\n        return parse(buffer, len);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java", "class_name": "PseudoTCPBase", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase", "attributes": {"modifiers": "synchronized public", "marker_annotations": [], "non_marker_annotations": ["synchronized", "public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nUse this method to notify protocol about packets received from the\nnetwork\n\n@param buffer packet's data\n@param len data length\n@return true if packet was successfully parsed\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[long]getOption(Option)", "name": "getOption", "arg_nums": 1, "params": [{"name": "opt", "type": "Option"}], "return_type": "long", "signature": "long getOption(Option opt)", "original_string": "    long getOption(Option opt)\n    {\n        if (opt == Option.OPT_NODELAY)\n        {\n            return m_use_nagling ? 0 : 1;\n        }\n        else\n        {\n            if (opt == Option.OPT_ACKDELAY)\n            {\n                return m_ack_delay;\n            }\n            else\n            {\n                if (opt == Option.OPT_SNDBUF)\n                {\n                    return m_sbuf_len;\n                }\n                else\n                {\n                    assert opt == Option.OPT_RCVBUF;\n                    return m_rbuf_len;\n                }\n            }\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java", "class_name": "PseudoTCPBase", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "long", "classes": []}, "docstring": "\nRetrieve option's value. See {@link Option} for available options\n\n@param opt option which value will be retrieved\n@return option's value\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[void]setOption(Option,long)", "name": "setOption", "arg_nums": 2, "params": [{"name": "opt", "type": "Option"}, {"name": "value", "type": "long"}], "return_type": "void", "signature": "void setOption(Option opt, long value)", "original_string": "    void setOption(Option opt, long value)\n    {\n        if (opt == Option.OPT_NODELAY)\n        {\n            m_use_nagling = value == 0;\n        }\n        else\n        {\n            if (opt == Option.OPT_ACKDELAY)\n            {\n                m_ack_delay = value;\n            }\n            else\n            {\n                if (opt == Option.OPT_SNDBUF)\n                {\n                    assert m_state == PseudoTcpState.TCP_LISTEN;\n                    resizeSendBuffer((int)value);\n                }\n                else\n                {\n                    assert opt == Option.OPT_RCVBUF;\n                    assert m_state == PseudoTcpState.TCP_LISTEN;\n                    resizeReceiveBuffer((int)value);\n                }\n            }\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java", "class_name": "PseudoTCPBase", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets {@link Option} value\n\n@param opt option whose value will be set\n@param value the value to be set\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[long]getCongestionWindow()", "name": "getCongestionWindow", "arg_nums": 0, "params": [], "return_type": "long", "signature": "long getCongestionWindow()", "original_string": "    long getCongestionWindow()\n    {\n        return m_cwnd;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java", "class_name": "PseudoTCPBase", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "long", "classes": []}, "docstring": "\n\n@return congestion window size\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[long]getBytesInFlight()", "name": "getBytesInFlight", "arg_nums": 0, "params": [], "return_type": "long", "signature": "long getBytesInFlight()", "original_string": "    long getBytesInFlight()\n    {\n        return m_snd_nxt - m_snd_una;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java", "class_name": "PseudoTCPBase", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "long", "classes": []}, "docstring": "\n\n@return bytes in flight\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[long]getBytesBufferedNotSent()", "name": "getBytesBufferedNotSent", "arg_nums": 0, "params": [], "return_type": "long", "signature": "long getBytesBufferedNotSent()", "original_string": "    long getBytesBufferedNotSent()\n    {\n        long buffered_bytes = m_sbuf.getBuffered();\n        return m_snd_una + buffered_bytes - m_snd_nxt;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java", "class_name": "PseudoTCPBase", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "long", "classes": []}, "docstring": "\n\n@return bytes buffered, but not sent yet\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[int]getAvailable()", "name": "getAvailable", "arg_nums": 0, "params": [], "return_type": "int", "signature": "int getAvailable()", "original_string": "    int getAvailable()\n    {\n        return m_rbuf.getBuffered();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java", "class_name": "PseudoTCPBase", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "int", "classes": []}, "docstring": "\n\n@return bytes available in receive buffer\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[int]getAvailableSendBuffer()", "name": "getAvailableSendBuffer", "arg_nums": 0, "params": [], "return_type": "int", "signature": "int getAvailableSendBuffer()", "original_string": "    int getAvailableSendBuffer()\n    {\n        return m_sbuf.getWriteRemaining();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java", "class_name": "PseudoTCPBase", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "int", "classes": []}, "docstring": "\n\n@return space available in the send buffer\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[long]getRoundTripTimeEstimateMs()", "name": "getRoundTripTimeEstimateMs", "arg_nums": 0, "params": [], "return_type": "long", "signature": "long getRoundTripTimeEstimateMs()", "original_string": "    long getRoundTripTimeEstimateMs()\n    {\n        return m_rx_srtt;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java", "class_name": "PseudoTCPBase", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "long", "classes": []}, "docstring": "\n\n@return round trip time estimate in ms\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[int]recv(byte[],int,int)", "name": "recv", "arg_nums": 3, "params": [{"name": "buffer", "type": "byte[]"}, {"name": "offset", "type": "int"}, {"name": "len", "type": "int"}], "return_type": "int", "signature": "public synchronized int recv(byte[] buffer, int offset, int len)", "original_string": "    public synchronized int recv(byte[] buffer, int offset, int len) throws IOException\n    {\n        if (m_state != PseudoTcpState.TCP_ESTABLISHED)\n        {\n            throw new IOException(\"Socket not connected\");\n        }\n\n        int read = m_rbuf.read(buffer, offset, len);\n\n        // If there's no data in |m_rbuf|.\n        if (read == 0)\n        {\n            m_bReadEnable = true;\n            return 0;\n        }\n        assert read != -1;\n\n        int available_space = m_rbuf.getWriteRemaining();\n        if (available_space - m_rcv_wnd >= Math.min(m_rbuf_len / 8, m_mss))\n        {\n            boolean bWasClosed = (m_rcv_wnd == 0); // !?! Not sure about this was closed business\n            m_rcv_wnd = available_space;\n\n            if (bWasClosed)\n            {\n                attemptSend(SendFlags.sfImmediateAck);\n            }\n        }\n        return read;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java", "class_name": "PseudoTCPBase", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase", "attributes": {"modifiers": "public synchronized", "marker_annotations": [], "non_marker_annotations": ["public", "synchronized"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\nReads the data available in receive buffer. This method returns 0 if\nthere's no data available at the moment.\n\n@param buffer destination buffer\n@param offset destination buffer's offset\n@param len bytes to be read\n@return byte count actually read\n@throws IOException if the protocol is not in the connected state\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[int]recv(byte[],int)", "name": "recv", "arg_nums": 2, "params": [{"name": "buffer", "type": "byte[]"}, {"name": "len", "type": "int"}], "return_type": "int", "signature": "public int recv(byte[] buffer, int len)", "original_string": "    public int recv(byte[] buffer, int len) throws IOException\n    {\n        return recv(buffer, 0, len);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java", "class_name": "PseudoTCPBase", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\nReads the data available in receive buffer. This method returns 0 if\nthere's no data available at the moment.\n\n@param buffer destination buffer\n@param len bytes to be read\n@return received byte count\n@throws IOException if the protocol is not in the connected state\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[int]send(byte[],int)", "name": "send", "arg_nums": 2, "params": [{"name": "buffer", "type": "byte[]"}, {"name": "len", "type": "int"}], "return_type": "int", "signature": "public int send(byte[] buffer, int len)", "original_string": "    public int send(byte[] buffer, int len) throws IOException\n    {\n        return send(buffer, 0, len);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java", "class_name": "PseudoTCPBase", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\nEnqueues data in the send buffer\n\n@param buffer source data buffer\n@param len bytes count to be sent\n@return sent byte count\n@throws IOException if the protocol is not in connected state\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[int]send(byte[],int,int)", "name": "send", "arg_nums": 3, "params": [{"name": "buffer", "type": "byte[]"}, {"name": "offset", "type": "int"}, {"name": "len", "type": "int"}], "return_type": "int", "signature": "public synchronized int send(byte[] buffer, int offset, int len)", "original_string": "    public synchronized int send(byte[] buffer, int offset, int len)\n        throws IOException\n    {\n        if (m_state != PseudoTcpState.TCP_ESTABLISHED)\n        {\n            throw new IOException(\"Socket not connected\");\n        }\n\n        long available_space;\n        available_space = m_sbuf.getWriteRemaining();\n\n        if (available_space == 0)\n        {\n            m_bWriteEnable = true;\n            return 0;\n        }\n\n        int written = queue(buffer, offset, len, false);\n        attemptSend(SendFlags.sfNone);\n        return written;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java", "class_name": "PseudoTCPBase", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase", "attributes": {"modifiers": "public synchronized", "marker_annotations": [], "non_marker_annotations": ["public", "synchronized"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\nEnqueues data in the send buffer\n\n@param buffer source data buffer\n@param offset offset of the source data buffer\n@param len bytes count to be sent\n@return bytes count written to the send buffer\n@throws IOException if the protocol is not in connected state\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[void]close(boolean)", "name": "close", "arg_nums": 1, "params": [{"name": "force", "type": "boolean"}], "return_type": "void", "signature": "void close(boolean force)", "original_string": "    void close(boolean force)\n    {\n        logger.log(Level.FINE, debugName + \" close (\" + force + \")\");\n        m_shutdown = force ? EnShutdown.SD_FORCEFUL : EnShutdown.SD_GRACEFUL;\n        if (force)\n        {\n            m_state = PseudoTcpState.TCP_CLOSED;\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java", "class_name": "PseudoTCPBase", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nShuts down the protocol which enters closed state\n\n@param force if true all data received from this moment will be discarded\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[int]queue(byte[],int,int,boolean)", "name": "queue", "arg_nums": 4, "params": [{"name": "buffer", "type": "byte[]"}, {"name": "offset", "type": "int"}, {"name": "len", "type": "int"}, {"name": "bCtrl", "type": "boolean"}], "return_type": "int", "signature": "int queue(byte[] buffer, int offset, int len, boolean bCtrl)", "original_string": "    int queue(byte[] buffer, int offset, int len, boolean bCtrl)\n    {\n        int available_space;\n        available_space = m_sbuf.getWriteRemaining();\n        if (len > available_space)\n        {\n            assert !bCtrl;\n            len = available_space;\n        }\n\n        // We can concatenate data if the last segment is the same type\n        // (control v. regular data), and has not been transmitted yet\n        SSegment back = null;\n        if (!m_slist.isEmpty())\n        {\n            back = m_slist.get(m_slist.size() - 1);\n        }\n        if (back != null && (back.bCtrl == bCtrl) && (back.xmit == 0))\n        {\n            back.len += len;\n        }\n        else\n        {\n            long snd_buffered;\n            snd_buffered = m_sbuf.getBuffered();\n            SSegment sseg = new SSegment(\n                m_snd_una + snd_buffered,\n                len,\n                bCtrl);\n            //m_slist.push_back(sseg);\n            if (logger.isLoggable(Level.FINEST))\n            {\n                logger.log(Level.FINEST, debugName + \" enqueued send segment seq: \"\n                    + sseg.seq + \" len: \" + sseg.len);\n            }\n            m_slist.add(sseg);\n        }\n\n        int written = m_sbuf.write(buffer, offset, len);\n        return written;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java", "class_name": "PseudoTCPBase", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "int", "classes": []}, "docstring": "\nEnqueues data segment in the send buffer\n\n@param buffer source buffer\n@param offset source buffer's offset\n@param len data length\n@param bCtrl true for control data\n@return written byte count\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[WriteResult]packet(long,short,long,long)", "name": "packet", "arg_nums": 4, "params": [{"name": "seq", "type": "long"}, {"name": "flags", "type": "short"}, {"name": "offset", "type": "long"}, {"name": "len", "type": "long"}], "return_type": "WriteResult", "signature": "WriteResult packet(long seq, short flags, long offset, long len)", "original_string": "    WriteResult packet(long seq, short flags, long offset, long len)\n    {\n        assert HEADER_SIZE + len <= MAX_PACKET;\n\n        long now = now();\n\n        byte[] buffer = new byte[HEADER_SIZE + (int)len];\n        long_to_bytes(m_conv, buffer, 0);\n        long_to_bytes(seq, buffer, 4);\n        long_to_bytes(m_rcv_nxt, buffer, 8);\n        buffer[12] = 0;\n        buffer[13] = (byte) (flags & 0xFF);\n        short_to_bytes(m_rcv_wnd >> m_rwnd_scale, buffer, 14);\n\n        // Timestamp computations\n        long_to_bytes(now, buffer, 16);\n        long_to_bytes(m_ts_recent, buffer, 20);\n        m_ts_lastack = m_rcv_nxt;\n\n        if (len > 0)\n        {\n            int bytes_read = m_sbuf.readOffset(buffer, HEADER_SIZE,\n                                               (int) len,\n                                               (int) offset);\n            assert bytes_read == len;\n        }\n        if (logger.isLoggable(Level.FINE))\n        {\n            logger.log(Level.FINE, \"<-- \" + debugName + \" <CONV=\" + m_conv + \"><FLG=\"\n                + flags + \"><SEQ=\" + seq + \":\" + (seq + len) + \"><ACK=\" + m_rcv_nxt + \">\"\n                + \"<WND=\" + m_rcv_wnd + \"><SCALE=\" + m_rwnd_scale + \"><TS=\" + now\n                + \"><TSR=\" + m_ts_recent + \"><LEN=\" + len + \">\");\n        }\n        WriteResult wres = m_notify.tcpWritePacket(this,\n                                                   buffer,\n                                                   (int) len + HEADER_SIZE);\n        /**\n         * Note: When len is 0, this is an ACK packet. We don't read the return\n         * value for those, and thus we won't retry. So go ahead and treat the\n         * packet as a success (basically simulate as if it were dropped), which\n         * will prevent our timers from being messed up.\n         */\n        if ((wres != WriteResult.WR_SUCCESS) && (0 != len))\n        {\n            return wres;\n        }\n        m_t_ack = 0;\n        if (len > 0)\n        {\n            m_lastsend = now;\n        }\n        m_lasttraffic = now;\n        m_bOutgoing = true;\n\n        return WriteResult.WR_SUCCESS;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java", "class_name": "PseudoTCPBase", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "WriteResult", "classes": []}, "docstring": "\nCreates a packet starting at <tt>offset</tt> in the send buffer of\nspecified length and sends it with help of <tt>PseudoTcpNotify</tt>.\n\n@param seq used sequence number\n@param flags\n@param offset in the send buffer\n@param len length of data from\n@return <tt>WriteResult</tt> returned by <tt>PseudoTcpNotify</tt>\n\n@see PseudoTcpNotify\n@see WriteResult\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[Segment]parseSeg(byte[],int)", "name": "parseSeg", "arg_nums": 2, "params": [{"name": "buffer", "type": "byte[]"}, {"name": "size", "type": "int"}], "return_type": "Segment", "signature": "public static Segment parseSeg(byte[] buffer, int size)", "original_string": "    public static Segment parseSeg(byte[] buffer, int size)\n    {\n        if (size < 12)\n        {\n            return null;\n        }\n\n        Segment seg = new Segment();\n        seg.conv = bytes_to_long(buffer, 0);\n        seg.seq = bytes_to_long(buffer, 4);\n        seg.ack = bytes_to_long(buffer, 8);\n        seg.flags = buffer[13];\n        seg.wnd = bytes_to_short(buffer, 14);\n\n        seg.tsval = bytes_to_long(buffer, 16);\n        seg.tsecr = bytes_to_long(buffer, 20);\n\n        seg.data = copy_buffer(buffer, HEADER_SIZE, size - HEADER_SIZE);\n        seg.len = size - HEADER_SIZE;\n        \n        return seg;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java", "class_name": "PseudoTCPBase", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Segment", "classes": []}, "docstring": "\nMethod can be used in debugging utilities to parse PTCP segment\n@param buffer data to parse\n@param size length of the data in the buffer\n@return the parsed segment\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[String]segToStr(Segment)", "name": "segToStr", "arg_nums": 1, "params": [{"name": "seg", "type": "Segment"}], "return_type": "String", "signature": "public static String segToStr(Segment seg)", "original_string": "    public static String segToStr(Segment seg)\n    {\n        String data=\"data: \";\n        for (byte b : seg.data)\n        {\n            data += b;\n        }\n        return \"<CONV=\" + seg.conv + \"><FLG=\" + seg.flags + \"><SEQ=\" \n            + seg.seq + \":\" + (seg.seq + seg.len) + \"><ACK=\" + seg.ack\n            + \"><WND=\" + seg.wnd + \"><TS=\" + seg.tsval\n            + \"><TSR=\" + seg.tsecr + \"><LEN=\" + seg.len + \"> \"+data;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java", "class_name": "PseudoTCPBase", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nCan be used to convert segments to text\n\n@param seg the {@link Segment} to format\n@return segment in readable text form\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[boolean]parse(byte[],int)", "name": "parse", "arg_nums": 2, "params": [{"name": "buffer", "type": "byte[]"}, {"name": "size", "type": "int"}], "return_type": "boolean", "signature": "boolean parse(byte[] buffer, int size)", "original_string": "    boolean parse(byte[] buffer, int size)\n    {\n        if (size < 12)\n        {\n            return false;\n        }\n\n        Segment seg = parseSeg(buffer, size);\n\n        if (logger.isLoggable(Level.FINE))\n        {\n            logger.log(Level.FINE,\n                       \"--> \" + debugName + \"<CONV=\" + seg.conv + \"><FLG=\" + seg.flags\n                + \"><SEQ=\" + seg.seq + \":\" + (seg.seq + seg.len) + \"><ACK=\" + seg.ack\n                + \"><WND=\" + seg.wnd + \"><SCALE=\" + m_swnd_scale + \"><TS=\" + seg.tsval\n                + \"><TSR=\" + seg.tsecr + \"><LEN=\" + seg.len + \">\");\n        }\n        return process(seg);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java", "class_name": "PseudoTCPBase", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nCreates new segment from the data in <tt>buffer</tt> which is processed\nby the protocol.\n\n@param buffer source buffer\n@param size data length\n@return true if successfully parsed the data\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[long]clock_check(long)", "name": "clock_check", "arg_nums": 1, "params": [{"name": "now", "type": "long"}], "return_type": "long", "signature": "long clock_check(long now)", "original_string": "    long clock_check(long now)\n    {\n        if (m_shutdown == EnShutdown.SD_FORCEFUL)\n        {\n            return -1;\n        }\n\n        long nTimeout;\n        long snd_buffered;\n        snd_buffered = m_sbuf.getBuffered();\n        if ((m_shutdown == EnShutdown.SD_GRACEFUL)\n            && ((m_state != PseudoTcpState.TCP_ESTABLISHED)\n            || ((snd_buffered == 0) && (m_t_ack == 0))))\n        {\n            return -1;\n        }\n\n        if (m_state == PseudoTcpState.TCP_CLOSED)\n        {\n            return CLOSED_TIMEOUT;\n        }\n\n        nTimeout = DEFAULT_TIMEOUT;\n\n        if (m_t_ack > 0)\n        {\n            nTimeout = Math.min(nTimeout, timeDiff(m_t_ack + m_ack_delay, now));\n        }\n        if (m_rto_base > 0)\n        {\n            nTimeout = Math.min(nTimeout, timeDiff(m_rto_base + m_rx_rto, now));\n        }\n        if (getM_snd_wnd() == 0)\n        {\n            nTimeout = Math.min(nTimeout, timeDiff(m_lastsend + m_rx_rto, now));\n        }\n        if (PSEUDO_KEEPALIVE)\n        {\n            if (m_state == PseudoTcpState.TCP_ESTABLISHED)\n            {\n                nTimeout = Math.min(\n                    nTimeout,\n                    timeDiff(m_lasttraffic + (m_bOutgoing ? IDLE_PING * 3 / 2 : IDLE_PING), now));\n            }\n        }\n        //nTimeout is used on wait methods, so cannot be equal to 0\n        return nTimeout <= 0 ? 1 : nTimeout;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java", "class_name": "PseudoTCPBase", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "long", "classes": []}, "docstring": "\nCalculates timeout in ms for current operation\n\n@param now current timestamp in ms\n@return next timeout or -1 in case of an error\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[boolean]process(Segment)", "name": "process", "arg_nums": 1, "params": [{"name": "seg", "type": "Segment"}], "return_type": "boolean", "signature": "boolean process(Segment seg)", "original_string": "    boolean process(Segment seg)\n    {\n        // If this is the wrong conversation, send a reset!?! (with the correct conversation?)\n        if (seg.conv != m_conv)\n        {\n            //if ((seg.flags & FLAG_RST) == 0) {\n            //  packet(tcb, seg.ack, 0, FLAG_RST, 0, 0);\n            //}\n            //closedown(new IOException(\n            //    debugName + \" wrong conversation number, this: \" + m_conv\n            //    + \" remote: \" + seg.conv));\n            logger.info(debugName + \" wrong conversation number, this: \" + m_conv\n            + \" remote: \" + seg.conv);\n            return false;\n        }\n\n        long now = now();\n        m_lasttraffic = m_lastrecv = now;\n        m_bOutgoing = false;\n\n        if (m_state == PseudoTcpState.TCP_CLOSED)\n        {\n            // !?! send reset?\n            closedown(new IOException(debugName + \" in closed state\"));\n            return false;\n        }\n\n        // Check if this is a reset segment\n        if ((seg.flags & FLAG_RST) > 0)\n        {\n            //closedown(PseudoTcpError.ECONNRESET);\n            closedown(new IOException(\"Connection reset\"));\n            return false;\n        }\n\n        // Check for control data\n        boolean bConnect = false;\n        if ((seg.flags & FLAG_CTL) > 0)\n        {\n            if (seg.len == 0)\n            {\n                logger.log(Level.SEVERE, debugName + \" Missing control code\");\n                return false;\n            }\n            else\n            {\n                if (seg.data[0] == CTL_CONNECT)\n                {\n                    bConnect = true;\n\n                    // TCP options are in the remainder of the payload after CTL_CONNECT.\n                    if (!parseOptions(seg.data, 1, seg.len - 1))\n                    {\n                        return false;\n                    }\n\n                    if (m_state == PseudoTcpState.TCP_LISTEN)\n                    {\n                        m_state = PseudoTcpState.TCP_SYN_RECEIVED;\n                        logger.log(Level.FINE,\n                                   debugName + \" State: TCP_SYN_RECEIVED\");\n                        //m_notify->associate(addr);\n                        queueConnectMessage();\n                    }\n                    else\n                    {\n                        if (m_state == PseudoTcpState.TCP_SYN_SENT)\n                        {\n                            m_state = PseudoTcpState.TCP_ESTABLISHED;\n                            logger.log(Level.FINE,\n                                       debugName + \" State: TCP_ESTABLISHED\");\n                            adjustMTU();\n                            if (m_notify != null)\n                            {\n                                m_notify.onTcpOpen(this);\n                            }\n                            //notify(evOpen);\n                        }\n                    }\n                }\n                else\n                {\n                    logger.log(Level.SEVERE,\n                               debugName + \" Unknown control code: \" + seg.data[0]);\n                    return false;\n                }\n            }\n        }\n\n        // Update timestamp\n        if ((seg.seq <= m_ts_lastack) && (m_ts_lastack < seg.seq + seg.len))\n        {\n            m_ts_recent = seg.tsval;\n        }\n\n        // Check if this is a valuable ack\n        if ((seg.ack > m_snd_una) && (seg.ack <= m_snd_nxt))\n        {\n            // Calculate round-trip time\n            if (seg.tsecr > 0)\n            {\n                long rtt = timeDiff(now, seg.tsecr);\n                assert rtt >= 0;\n                if (m_rx_srtt == 0)\n                {\n                    m_rx_srtt = rtt;\n                    m_rx_rttvar = rtt / 2;\n                }\n                else\n                {\n                    m_rx_rttvar = (3 * m_rx_rttvar + Math.abs(rtt - m_rx_srtt)) / 4;\n                    m_rx_srtt = (7 * m_rx_srtt + rtt) / 8;\n                }\n                m_rx_rto = bound(MIN_RTO, m_rx_srtt\n                    + Math.max(1, 4 * m_rx_rttvar),\n                                 MAX_RTO);\n                if (logger.isLoggable(Level.FINER))\n                {\n                    logger.log(Level.FINER,\n                               \"rtt: \" + rtt + \" srtt: \" + m_rx_srtt + \" rto: \" + m_rx_rto);\n                }\n            }\n\n            m_snd_wnd = seg.wnd << m_swnd_scale;\n            //setWindowWithScale(seg.wnd, getM_swnd_scale());\n            //setM_snd_wnd(seg.wnd << m_swnd_scale);\n\n            long nAcked = seg.ack - m_snd_una;\n            synchronized (ack_notify)\n            {\n                \n                m_snd_una = seg.ack;\n\n                m_rto_base = (m_snd_una == m_snd_nxt) ? 0 : now;\n\n                m_sbuf.consumeReadData((int) nAcked);\n            \n                if (logger.isLoggable(Level.FINER))\n                {\n                    logger.log(Level.FINER,\n                               debugName + \" acked: \" + nAcked\n                        + \" m_snd_una: \" + m_snd_una);\n                }\n                ack_notify.notifyAll();\n            }\n\n            for (long nFree = nAcked; nFree > 0;)\n            {\n                assert !m_slist.isEmpty();\n                if (nFree < m_slist.get(0).len)\n                {\n                    m_slist.get(0).len -= nFree;\n                    m_slist.get(0).seq += nFree;\n                    nFree = 0;\n                }\n                else\n                {\n                    if (m_slist.get(0).len > m_largest)\n                    {\n                        m_largest = m_slist.get(0).len;\n                    }\n                    nFree -= m_slist.get(0).len;\n                    m_slist.remove(0);\n                    //m_slist.pop_front();\n                }\n            }\n\n            if (m_dup_acks >= 3)\n            {\n                if (m_snd_una >= m_recover)\n                { // NewReno\n                    long nInFlight = m_snd_nxt - m_snd_una;\n                    m_cwnd = Math.min(m_ssthresh, nInFlight + m_mss); // (Fast Retransmit)\n                    logger.log(Level.FINE, \"exit recovery\");\n                    m_dup_acks = 0;\n                }\n                else\n                {\n                    logger.log(Level.FINE, \"recovery retransmit\");\n                    if (!transmit(m_slist.get(0), now))\n                    {\n                        //closedown(PseudoTcpError.ECONNABORTED);\n                        closedown(new IOException(\"Connection aborted\"));\n                        return false;\n                    }\n                    m_cwnd += m_mss - Math.min(nAcked, m_cwnd);\n                }\n            }\n            else\n            {\n                m_dup_acks = 0;\n                // Slow start, congestion avoidance\n                if (m_cwnd < m_ssthresh)\n                {\n                    m_cwnd += m_mss;\n                }\n                else\n                {\n                    m_cwnd += Math.max(1, m_mss * m_mss / m_cwnd);\n                }\n            }\n        }\n        else\n        {\n            if (seg.ack == m_snd_una)\n            {\n                // !?! Note, tcp says don't do this... but otherwise how does a closed window become open?\n                //setWindowWithScale(seg.wnd, getM_swnd_scale());\n                m_snd_wnd = seg.wnd << m_swnd_scale;\n                //setM_snd_wnd(seg.wnd << m_swnd_scale);\n\n                // Check duplicate acks\n                if (seg.len > 0)\n                {\n                    // it's a dup ack, but with a data payload, so don't modify m_dup_acks\n                }\n                else\n                {\n                    if (m_snd_una != m_snd_nxt)\n                    {\n                        m_dup_acks += 1;\n                        if (m_dup_acks == 3)\n                        { // (Fast Retransmit)\n                            if (logger.isLoggable(Level.FINE))\n                            {\n                                logger.log(Level.FINE,\n                                           debugName + \" enter recovery\");\n                                logger.log(Level.FINE,\n                                           debugName + \" recovery retransmit\");\n                            }\n                            if (!transmit(m_slist.get(0), now))\n                            {\n                                closedown(new IOException(\"Connection aborted\"));\n                                //closedown(PseudoTcpError.ECONNABORTED);\n                                return false;\n                            }\n                            m_recover = m_snd_nxt;\n                            long nInFlight = m_snd_nxt - m_snd_una;\n                            m_ssthresh = Math.max(nInFlight / 2, 2 * m_mss);\n                            //Logger.Log(LS_INFO)\n                            //  << \"m_ssthresh: \" << m_ssthresh << \"  nInFlight: \" << nInFlight << \"  m_mss: \" << m_mss;\n                            m_cwnd = m_ssthresh + 3 * m_mss;\n                        }\n                        else\n                        {\n                            if (m_dup_acks > 3)\n                            {\n                                m_cwnd += m_mss;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        m_dup_acks = 0;\n                    }\n                }\n            }\n        }\n        // !?! A bit hacky\n        if ((m_state == PseudoTcpState.TCP_SYN_RECEIVED) && !bConnect)\n        {\n            m_state = PseudoTcpState.TCP_ESTABLISHED;\n            logger.log(Level.FINE, debugName + \" State: TCP_ESTABLISHED\");\n            adjustMTU();\n            if (m_notify != null)\n            {\n                m_notify.onTcpOpen(this);\n            }\n            //notify(evOpen);\n        }\n        // If we make room in the send queue, notify the user\n        // The goal it to make sure we always have at least enough data to fill the\n        // window.  We'd like to notify the app when we are halfway to that point.\n        long kIdealRefillSize = (m_sbuf_len + m_rbuf_len) / 2;\n        long snd_buffered = m_sbuf.getBuffered();\n        if (m_bWriteEnable && snd_buffered < kIdealRefillSize)\n        {\n            m_bWriteEnable = false;\n            if (m_notify != null)\n            {\n                m_notify.onTcpWriteable(this);\n            }\n            //notify(evWrite);\n        }\n        // Conditions were acks must be sent:\n        // 1) Segment is too old (they missed an ACK) (immediately)\n        // 2) Segment is too new (we missed a segment) (immediately)\n        // 3) Segment has data (so we need to ACK!) (delayed)\n        // ... so the only time we don't need to ACK, is an empty segment that points to rcv_nxt!\n        SendFlags sflags = SendFlags.sfNone;\n        if (seg.seq != m_rcv_nxt)\n        {\n            sflags = SendFlags.sfImmediateAck; // (Fast Recovery)\n        }\n        else\n        {\n            if (seg.len\n                != 0)\n            {\n                if (m_ack_delay == 0)\n                {\n                    sflags = SendFlags.sfImmediateAck;\n                }\n                else\n                {\n                    sflags = SendFlags.sfDelayedAck;\n                }\n            }\n        }\n\n        if (sflags == SendFlags.sfImmediateAck)\n        {\n            if (seg.seq > m_rcv_nxt)\n            {\n                logger.log(Level.FINER,\n                           \"too new, seq.seq=\" + seg.seq\n                                + \", seg.len=\" + seg.len\n                                + \", m_rcv_nxt=\" + m_rcv_nxt);\n            }\n            else\n            {\n                if (seg.seq + seg.len <= m_rcv_nxt)\n                {\n                    logger.log(Level.FINER,\n                               \"too old, seq.seq=\" + seg.seq\n                                    + \", seg.len=\" + seg.len\n                                    + \", m_rcv_nxt=\" + m_rcv_nxt);\n                }\n            }\n        }\n\n        // Adjust the incoming segment to fit our receive buffer\n        if (seg.seq < m_rcv_nxt)\n        {\n            long nAdjust = m_rcv_nxt - seg.seq;\n            if (nAdjust < seg.len)\n            {\n                seg.seq += nAdjust;\n                seg.data = scrollBuffer(seg.data, (int)nAdjust);\n                seg.len -= nAdjust;\n            }\n            else\n            {\n                seg.len = 0;\n            }\n        }\n        long available_space = m_rbuf.getWriteRemaining();\n        if ((seg.seq + seg.len - m_rcv_nxt) > available_space)\n        {\n            long nAdjust = seg.seq + seg.len - m_rcv_nxt - available_space;\n            if (nAdjust < seg.len)\n            {\n                seg.len -= nAdjust;\n            }\n            else\n            {\n                seg.len = 0;\n            }\n        }\n        boolean bIgnoreData = ((seg.flags & FLAG_CTL) > 0) || (m_shutdown != EnShutdown.SD_NONE);\n        boolean bNewData = false;\n        if (seg.len > 0)\n        {\n            if (bIgnoreData)\n            {\n                if (seg.seq == m_rcv_nxt)\n                {\n                    m_rcv_nxt += seg.len;\n                }\n            }\n            else\n            {\n                long nOffset = seg.seq - m_rcv_nxt;\n\n                int result = m_rbuf.writeOffset(seg.data, seg.len,\n                                                (int) nOffset);\n                assert result == seg.len;\n\n                if (seg.seq == m_rcv_nxt)\n                {\n                    if (logger.isLoggable(Level.FINEST))\n                    {\n                        logger.log(Level.FINEST,\n                                   \"Avail space: \" + available_space\n                            + \" seg.len: \" + seg.len);\n                    }\n                    m_rbuf.consumeWriteBuffer(seg.len);\n                    m_rcv_nxt += seg.len;\n                    m_rcv_wnd -= seg.len;\n                    bNewData = true;\n\n\n                    Iterator<RSegment> iter = m_rlist.iterator();\n                    List<RSegment> toBeRemoved = new ArrayList<>();\n                    while (iter.hasNext())\n                    {\n                        RSegment it = iter.next();\n                        if (it.seq > m_rcv_nxt)\n                        {\n                            break;\n                        }\n                        if (it.seq + it.len > m_rcv_nxt)\n                        {\n                            sflags = SendFlags.sfImmediateAck; // (Fast Recovery)\n                            long nAdjust = (it.seq + it.len) - m_rcv_nxt;\n                            if (logger.isLoggable(Level.FINE))\n                            {\n                                logger.log(Level.FINE,\n                                           \"Recovered \" + nAdjust + \" bytes (\"\n                                    + m_rcv_nxt + \" -> \" + (m_rcv_nxt + nAdjust)\n                                    + \")\");\n                            }\n                            m_rbuf.consumeWriteBuffer((int) nAdjust);\n                            m_rcv_nxt += nAdjust;\n                            m_rcv_wnd -= nAdjust;\n                        }\n                        toBeRemoved.add(it);\n                    }\n                    m_rlist.removeAll(toBeRemoved);\n                }\n                else\n                {\n                    if (logger.isLoggable(Level.FINE))\n                    {\n                        logger.log(Level.FINE,\n                                   \"Saving \" + seg.len + \" bytes (\" + seg.seq\n                            + \" -> \" + (seg.seq + seg.len) + \")\");\n                    }\n                    RSegment rseg = new RSegment(seg.seq, seg.len);\n                    int insertPos;\n                    for (insertPos = 0; insertPos < m_rlist.size(); insertPos++)\n                    {\n                        RSegment it = m_rlist.get(insertPos);\n                        if (it.seq >= rseg.seq)\n                        {\n                            break;\n                        }\n                    }\n                    m_rlist.add(insertPos, rseg);\n                }\n            }\n        }\n\n        attemptSend(sflags);\n        // If we have new data, notify the user\n        if (bNewData && m_bReadEnable)\n        {\n            m_bReadEnable = false;\n            if (m_notify != null)\n            {\n                m_notify.onTcpReadable(this);\n            }\n            //notify(evRead);\n        }\n        return true;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java", "class_name": "PseudoTCPBase", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nProcess given segment\n\n@param seg\n@return false in case of error\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[long]timeDiff(long,long)", "name": "timeDiff", "arg_nums": 2, "params": [{"name": "later", "type": "long"}, {"name": "earlier", "type": "long"}], "return_type": "long", "signature": "private static long timeDiff(long later, long earlier)", "original_string": "    private static long timeDiff(long later, long earlier)\n    {\n        return later - earlier;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java", "class_name": "PseudoTCPBase", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "long", "classes": []}, "docstring": "\nUtil time method\n\n@param later timestamp in ms\n@param earlier timestamp in ms\n@return difference between <tt>later</tt> and <tt>earlier</tt>\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[void]long_to_bytes(long,byte[],int)", "name": "long_to_bytes", "arg_nums": 3, "params": [{"name": "anUnsignedInt", "type": "long"}, {"name": "buf", "type": "byte[]"}, {"name": "offset", "type": "int"}], "return_type": "void", "signature": "private static void long_to_bytes(long anUnsignedInt, byte[] buf, int offset)", "original_string": "    private static void long_to_bytes(long anUnsignedInt, byte[] buf, int offset)\n    {\n        buf[offset] = (byte) ((anUnsignedInt & 0xFF000000L) >>> 24);\n        buf[offset + 1] = (byte) ((anUnsignedInt & 0x00FF0000L) >>> 16);\n        buf[offset + 2] = (byte) ((anUnsignedInt & 0x0000FF00L) >>> 8);\n        buf[offset + 3] = (byte) ((anUnsignedInt & 0x000000FFL));\n        //java.nio.ByteBuffer.wrap(buffer, offset, 4).putInt((int) (m_conv & 0xFFFFFFFFL));\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java", "class_name": "PseudoTCPBase", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nStores 32 bit unsigned int in a buffer at specified offset\n\n@param anUnsignedInt\n@param buf destination buffer\n@param offset destination buffer's offset\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[void]short_to_bytes(int,byte[],int)", "name": "short_to_bytes", "arg_nums": 3, "params": [{"name": "anUnsignedShort", "type": "int"}, {"name": "buf", "type": "byte[]"}, {"name": "offset", "type": "int"}], "return_type": "void", "signature": "private static void short_to_bytes(int anUnsignedShort, byte[] buf, int offset)", "original_string": "    private static void short_to_bytes(int anUnsignedShort, byte[] buf, int offset)\n    {\n        buf[offset] = (byte) ((anUnsignedShort & 0xFF00) >>> 8);\n        buf[offset + 1] = (byte) ((anUnsignedShort & 0x00FF));\n        //java.nio.ByteBuffer.wrap(buffer, offset, 2).putShort((short) (shrt & 0xFFFF));\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java", "class_name": "PseudoTCPBase", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nStores 16 bit unsigned int in the buffer at specified offset\n\n@param anUnsignedShort\n@param buf destination buffer\n@param offset destination buffer's offset\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[long]bytes_to_long(byte[],int)", "name": "bytes_to_long", "arg_nums": 2, "params": [{"name": "buffer", "type": "byte[]"}, {"name": "offset", "type": "int"}], "return_type": "long", "signature": "private static long bytes_to_long(byte[] buffer, int offset)", "original_string": "    private static long bytes_to_long(byte[] buffer, int offset)\n    {\n        int fByte = (0x000000FF & ((int) buffer[offset]));\n        int sByte = (0x000000FF & ((int) buffer[offset + 1]));\n        int tByte = (0x000000FF & ((int) buffer[offset + 2]));\n        int foByte = (0x000000FF & ((int) buffer[offset + 3]));\n        return ((long) (fByte << 24\n            | sByte << 16\n            | tByte << 8\n            | foByte))\n            & 0xFFFFFFFFL;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java", "class_name": "PseudoTCPBase", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "long", "classes": []}, "docstring": "\nReads 32 bit unsigned int from the buffer at specified offset\n\n@param buffer\n@param offset\n@return 32 bit unsigned value\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[int]bytes_to_short(byte[],int)", "name": "bytes_to_short", "arg_nums": 2, "params": [{"name": "buffer", "type": "byte[]"}, {"name": "offset", "type": "int"}], "return_type": "int", "signature": "private static int bytes_to_short(byte[] buffer, int offset)", "original_string": "    private static int bytes_to_short(byte[] buffer, int offset)\n    {\n        int fByte = (0x000000FF & ((int) buffer[offset]));\n        int sByte = (0x000000FF & ((int) buffer[offset + 1]));\n        return ((fByte << 8\n            | sByte))\n            & 0xFFFF;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java", "class_name": "PseudoTCPBase", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\nReads 16 bit unsigned int from the buffer at specified offset\n\n@param buffer\n@param offset\n@return 16 bit unsigned int\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[byte[]]copy_buffer(byte[],int,int)", "name": "copy_buffer", "arg_nums": 3, "params": [{"name": "buffer", "type": "byte[]"}, {"name": "sOffset", "type": "int"}, {"name": "len", "type": "int"}], "return_type": "byte[]", "signature": "private static byte[] copy_buffer(byte[] buffer, int sOffset, int len)", "original_string": "    private static byte[] copy_buffer(byte[] buffer, int sOffset, int len)\n    {\n        byte[] newData = new byte[len];\n        System.arraycopy(buffer, sOffset, newData, 0, len);\n        return newData;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java", "class_name": "PseudoTCPBase", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "byte[]", "classes": []}, "docstring": "\nWrapped system function arrayCopy\n\n@param buffer source buffer\n@param sOffset source buffer offset\n@param len bytes count to be copied\n@return new buffer size of <tt>len</tt>\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[long]bound(long,long,long)", "name": "bound", "arg_nums": 3, "params": [{"name": "lower", "type": "long"}, {"name": "middle", "type": "long"}, {"name": "upper", "type": "long"}], "return_type": "long", "signature": "private long bound(long lower, long middle, long upper)", "original_string": "    private long bound(long lower, long middle, long upper)\n    {\n        return Math.min(Math.max(lower, middle), upper);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java", "class_name": "PseudoTCPBase", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "long", "classes": []}, "docstring": "\n\n@param lower\n@param middle\n@param upper\n@return\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[byte[]]scrollBuffer(byte[],int)", "name": "scrollBuffer", "arg_nums": 2, "params": [{"name": "data", "type": "byte[]"}, {"name": "nAdjust", "type": "int"}], "return_type": "byte[]", "signature": "private byte[] scrollBuffer(byte[] data, int nAdjust)", "original_string": "    private byte[] scrollBuffer(byte[] data, int nAdjust)\n    {\n        byte[] newBuffer = new byte[data.length - nAdjust];\n        System.arraycopy(data, nAdjust, newBuffer, 0, newBuffer.length);\n        return newBuffer;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java", "class_name": "PseudoTCPBase", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "byte[]", "classes": []}, "docstring": ""}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[boolean]transmit(SSegment,long)", "name": "transmit", "arg_nums": 2, "params": [{"name": "seg", "type": "SSegment"}, {"name": "now", "type": "long"}], "return_type": "boolean", "signature": "boolean transmit(SSegment seg, long now)", "original_string": "    boolean transmit(SSegment seg, long now)\n    {\n        //  Logger.Log(LS_INFO) << \"seg->xmit: \"<< seg->xmit;\n        if (seg.xmit >= ((m_state == PseudoTcpState.TCP_ESTABLISHED) ? 15 : 30))\n        {\n            logger.log(Level.FINE, \"too many retransmits\");\n            return false;\n        }\n\n        long nTransmit = Math.min(seg.len, m_mss);\n\n        while (true)\n        {\n            long seq = seg.seq;\n            short flags = (seg.bCtrl ? FLAG_CTL : 0);\n            WriteResult wres = packet(seq,\n                                      flags,\n                                      seg.seq - m_snd_una,\n                                      nTransmit);\n\n            if (wres == WriteResult.WR_SUCCESS)\n            {\n                break;\n            }\n\n            if (wres == WriteResult.WR_FAIL)\n            {\n                logger.log(Level.WARNING, \"packet failed\");\n                return false;\n            }\n\n            assert wres == WriteResult.WR_TOO_LARGE;\n\n            while (true)\n            {\n                if (PACKET_MAXIMUMS[(m_msslevel + 1)] == 0)\n                {\n                    logger.log(Level.INFO, \"MTU too small\");\n                    return false;\n                }\n                // !?! We need to break up all outstanding and pending packets and then retransmit!?!\n\n                m_mss = PACKET_MAXIMUMS[++m_msslevel] - PACKET_OVERHEAD;\n                m_cwnd = 2 * m_mss; // I added this... haven't researched actual formula\n                if (m_mss < nTransmit)\n                {\n                    nTransmit = m_mss;\n                    break;\n                }\n            }\n            if (logger.isLoggable(Level.INFO))\n            {\n                logger.log(Level.INFO, \"Adjusting mss to \" + m_mss + \" bytes\");\n            }\n        }\n\n        if (nTransmit < seg.len)\n        {\n            if (logger.isLoggable(Level.INFO))\n            {\n                logger.log(Level.INFO, \"mss reduced to \" + m_mss);\n            }\n            SSegment subseg = new SSegment(seg.seq + nTransmit,\n                                           seg.len - nTransmit, seg.bCtrl);\n            //subseg.tstamp = seg->tstamp;\n            subseg.xmit = seg.xmit;\n            seg.len = nTransmit;\n\n            //SList::iterator next = seg;                        \n            m_slist.add(m_slist.indexOf(seg) + 1, subseg);\n        }\n\n        if (seg.xmit == 0)\n        {\n            m_snd_nxt += seg.len;\n        }\n        seg.xmit += 1;\n        //seg->tstamp = now;\n        if (m_rto_base == 0)\n        {\n            m_rto_base = now;\n        }\n\n        return true;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java", "class_name": "PseudoTCPBase", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nTransmits given segment\n\n@param seg segment to be sent\n@param now current timestamp\n@return false in case of error\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[void]attemptSend(SendFlags)", "name": "attemptSend", "arg_nums": 1, "params": [{"name": "sflags", "type": "SendFlags"}], "return_type": "void", "signature": "void attemptSend(SendFlags sflags)", "original_string": "    void attemptSend(SendFlags sflags)\n    {\n        long now = now();\n\n        if (timeDiff(now, m_lastsend) > m_rx_rto)\n        {\n            m_cwnd = m_mss;\n        }\n        boolean bFirst = true;\n\n        while (true)\n        {\n            long cwnd = m_cwnd;\n            if ((m_dup_acks == 1) || (m_dup_acks == 2))\n            { // Limited Transmit\n                cwnd += m_dup_acks * m_mss;\n            }\n            long nWindow = Math.min(getM_snd_wnd(), cwnd);\n            long nInFlight = m_snd_nxt - m_snd_una;\n            long nUseable = (nInFlight < nWindow) ? (nWindow - nInFlight) : 0;\n\n            long snd_buffered = m_sbuf.getBuffered();\n            /*\n             * System.out.println(\"is available? buffered: \" + snd_buffered + \"\n             * inFlight: \" + nInFlight + \" m_mss: \" + m_mss + \" m_snd_wnd: \" +\n             * getM_snd_wnd() + \" cwnd: \" + cwnd + \" nWindow: \" + nWindow + \"\n             * nUseable: \" + nUseable);\n             */\n            long nAvailable = Math.min(snd_buffered - nInFlight, m_mss);\n\n            if (nAvailable > nUseable)\n            {\n                if (nUseable * 4 < nWindow)\n                {\n                    // RFC 813 - avoid SWS\n                    logger.log(Level.FINER,\n                               \"RFC 813 - avoid SWS(nAvailable = 0)\");\n                    nAvailable = 0;\n                }\n                else\n                {\n                    nAvailable = nUseable;\n                }\n            }\n\n            if (bFirst)\n            {\n                long available_space = m_sbuf.getWriteRemaining();\n\n                bFirst = false;\n                if (logger.isLoggable(Level.FINE))\n                {\n                    logger.log(Level.FINE,\n                               \"[cwnd: \" + m_cwnd + \" nWindow: \" + nWindow\n                        + \" nInFlight: \" + nInFlight + \" nAvailable: \" + nAvailable\n                        + \" nQueued: \" + snd_buffered + \" nEmpty: \" + available_space\n                        + \" ssthresh: \" + m_ssthresh + \"]\");\n                }\n            }\n\n            if (nAvailable == 0)\n            {\n                if (sflags == SendFlags.sfNone)\n                {\n                    logger.log(Level.FINEST, \"nAvailable == 0: quit\");\n                    return;\n                }\n\n                // If this is an immediate ack, or the second delayed ack\n                if ((sflags == SendFlags.sfImmediateAck) || (m_t_ack > 0))\n                {\n                    packet(m_snd_nxt, (short) 0, 0, 0);\n                    logger.log(Level.FINER, \"Immediate ack: \");\n                }\n                else\n                {\n                    m_t_ack = now();\n                    if (logger.isLoggable(Level.FINER))\n                    {\n                        logger.log(\n                            Level.FINER, \"Delayed ack, m_t_ack: \" + m_t_ack);\n                    }\n                }\n                return;\n            }\n\n            // Nagle's algorithm.\n            // If there is data already in-flight, and we haven't a full segment of\n            // data ready to send then hold off until we get more to send, or the\n            // in-flight data is acknowledged.\n            if (m_use_nagling && (m_snd_nxt > m_snd_una) && (nAvailable < m_mss))\n            {\n                logger.log(Level.FINER, \"wait until more data is acked\");\n                return;\n            }\n\n            // Find the next segment to transmit\n            SSegment seg = null;\n            Iterator<SSegment> iter = m_slist.iterator();\n            do\n            {\n                SSegment it = iter.next();\n                if (it.xmit == 0)\n                {\n                    seg = it;\n                    break;\n                }\n            }\n            while (iter.hasNext());\n\n            assert seg != null;\n\n            // If the segment is too large, break it into two\n            if (seg.len > nAvailable)\n            {\n                logger.log(Level.FINEST, \"Break a segment into 2\");\n                SSegment subseg = new SSegment(\n                    seg.seq + nAvailable,\n                    seg.len - nAvailable,\n                    seg.bCtrl);\n                seg.len = nAvailable;\n                //m_slist.insert(++it, subseg);\n                m_slist.add(m_slist.indexOf(seg) + 1, subseg);\n            }\n            if (logger.isLoggable(Level.FINEST))\n            {\n                logger.log(Level.FINEST,\n                           \"TRANSMIT SEGMENT seq: \" + seg.seq\n                    + \" len: \" + seg.len);\n            }\n            if (!transmit(seg, now))\n            {\n                logger.log(Level.SEVERE, \"transmit failed\");\n                // TODO: consider closing socket\n                return;\n            }\n\n            sflags = SendFlags.sfNone;\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java", "class_name": "PseudoTCPBase", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nThis method checks if it's time to send a packet(ack or retransmit\nanything)\n\n@param sflags\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[void]closedown(IOException)", "name": "closedown", "arg_nums": 1, "params": [{"name": "e", "type": "IOException"}], "return_type": "void", "signature": "void closedown(IOException e)", "original_string": "    void closedown(IOException e)\n    {\n        logger.log(Level.FINE, debugName + \" State: TCP_CLOSED \");\n        m_state = PseudoTcpState.TCP_CLOSED;\n        if (m_notify != null)\n        {\n            m_notify.onTcpClosed(this, e);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java", "class_name": "PseudoTCPBase", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nThis metod is called in case of en error. Tcp enters closed state and\nnotifies listener about it.\n\n@param e exception to be propagated\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[void]adjustMTU()", "name": "adjustMTU", "arg_nums": 0, "params": [], "return_type": "void", "signature": "void adjustMTU()", "original_string": "    void adjustMTU()\n    {\n        // Determine our current mss level, so that we can adjust appropriately later\n        for (m_msslevel = 0; PACKET_MAXIMUMS[(m_msslevel + 1)] > 0; ++m_msslevel)\n        {\n            if (PACKET_MAXIMUMS[m_msslevel] <= m_mtu_advise)\n            {\n                break;\n            }\n        }\n        m_mss = m_mtu_advise - PACKET_OVERHEAD;\n        // !?! Should we reset m_largest here?        \n        logger.log(Level.FINE, \"Adjusting mss to \" + m_mss + \" bytes\");\n\n        // Enforce minimums on ssthresh and cwnd\n        m_ssthresh = Math.max(m_ssthresh, 2 * m_mss);\n        m_cwnd = Math.max(m_cwnd, m_mss);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java", "class_name": "PseudoTCPBase", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nAdjusts MTU\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[boolean]isReceiveBufferFull()", "name": "isReceiveBufferFull", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "boolean isReceiveBufferFull()", "original_string": "    boolean isReceiveBufferFull()\n    {\n        return m_rbuf.getWriteRemaining() == 0;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java", "class_name": "PseudoTCPBase", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\n\n@return true if receive buffer is full\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[void]disableWindowScale()", "name": "disableWindowScale", "arg_nums": 0, "params": [], "return_type": "void", "signature": "void disableWindowScale()", "original_string": "    void disableWindowScale()\n    {\n        m_support_wnd_scale = false;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java", "class_name": "PseudoTCPBase", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nDisables window scaling. Must be called before the connection is\nestablished.\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[void]queueConnectMessage()", "name": "queueConnectMessage", "arg_nums": 0, "params": [], "return_type": "void", "signature": "void queueConnectMessage()", "original_string": "    void queueConnectMessage()\n    {\n        byte[] buff = null;        \n        if (m_support_wnd_scale)\n        {\n            buff = new byte[4];\n            buff[1] = TCP_OPT_WND_SCALE & 0xFF;\n            buff[2] = 1;\n            buff[3] = (byte) (m_rwnd_scale & 0xFF);\n        }\n        else\n        {\n            buff = new byte[1];\n        }\n        buff[0] = CTL_CONNECT & 0xFF;\n        m_snd_wnd = buff.length;\n        queue(buff, 0, buff.length, true);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java", "class_name": "PseudoTCPBase", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nEnqueues connect message\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[boolean]parseOptions(byte[],int,int)", "name": "parseOptions", "arg_nums": 3, "params": [{"name": "data", "type": "byte[]"}, {"name": "offset", "type": "int"}, {"name": "len", "type": "int"}], "return_type": "boolean", "signature": "boolean parseOptions(byte[] data, int offset, int len)", "original_string": "    boolean parseOptions(byte[] data, int offset, int len)\n    {\n        List<Short> options_specified = new ArrayList<>();\n\n        // See http://www.freesoft.org/CIE/Course/Section4/8.htm for\n        // parsing the options list.\n        java.nio.ByteBuffer buf = java.nio.ByteBuffer.wrap(data, offset, len);\n        while (buf.hasRemaining())\n        {\n            short kind = TCP_OPT_EOL;\n            short tmp = buf.get();\n            if (tmp != -1)\n            {\n                kind = tmp;\n            }\n            if (kind == TCP_OPT_EOL)\n            {\n                // End of option list.\n                break;\n            }\n            else\n            {\n                if (kind == TCP_OPT_NOOP)\n                {\n                    // No op.\n                    continue;\n                }\n            }\n\n            // Length of this option.\n            assert len != 0;\n            //UNUSED(len);\n            short opt_len = buf.get();\n\n            // Content of this option.\n            if (opt_len <= buf.remaining())\n            {\n                byte[] opt_data = new byte[opt_len];\n                buf.get(opt_data);\n                applyOption(kind, opt_data, opt_len);\n            }\n            else\n            {\n                logger.log(Level.SEVERE, \n                    \"Invalid option length received: \"+opt_len\n                    +\" data len: \"+buf.remaining());\n                return false;\n            }\n            options_specified.add(kind);\n        }\n\n        if (!options_specified.contains(TCP_OPT_WND_SCALE))\n        {\n            logger.log(Level.WARNING, \"Peer doesn't support window scaling\");\n            if (getM_rwnd_scale() > 0)\n            {\n                // Peer doesn't support TCP options and window scaling.\n                // Revert receive buffer size to default value.\n                resizeReceiveBuffer(DEFAULT_RCV_BUF_SIZE);\n                m_swnd_scale = 0;\n            }\n        }\n        return true;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java", "class_name": "PseudoTCPBase", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nParse and process option in given buffer/offset/length\n\n@param data source buffer\n@param offset source offset\n@param len byte count\n@return true if options were properly parsed\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[void]applyOption(short,byte[],long)", "name": "applyOption", "arg_nums": 3, "params": [{"name": "kind", "type": "short"}, {"name": "data", "type": "byte[]"}, {"name": "len", "type": "long"}], "return_type": "void", "signature": "void applyOption(short kind, byte[] data, long len)", "original_string": "    void applyOption(short kind, byte[] data, long len)\n    {\n        if (kind == TCP_OPT_MSS)\n        {\n            logger.log(\n                Level.WARNING,\n                \"Peer specified MSS option which is not supported.\");\n            // TODO: Implement.\n        }\n        else\n        {\n            if (kind == TCP_OPT_WND_SCALE)\n            {\n                // Window scale factor.\n                // http://www.ietf.org/rfc/rfc1323.txt\n                if (len != 1)\n                {\n                    logger.log(Level.SEVERE, \"Invalid window scale option received.\");\n                    return;\n                }\n                applyWindowScaleOption(data[0]);\n            }\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java", "class_name": "PseudoTCPBase", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nApplies <tt>kind</tt> of option and it's data\n\n@param kind option type\n@param data option's data buffer\n@param len data length\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[void]applyWindowScaleOption(short)", "name": "applyWindowScaleOption", "arg_nums": 1, "params": [{"name": "scale_factor", "type": "short"}], "return_type": "void", "signature": "void applyWindowScaleOption(short scale_factor)", "original_string": "    void applyWindowScaleOption(short scale_factor)\n    {\n        m_swnd_scale = scale_factor;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java", "class_name": "PseudoTCPBase", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nApplies window scale option with given <tt>scale_factor</tt>\n\n@param scale_factor\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[void]resizeSendBuffer(int)", "name": "resizeSendBuffer", "arg_nums": 1, "params": [{"name": "new_size", "type": "int"}], "return_type": "void", "signature": "void resizeSendBuffer(int new_size)", "original_string": "    void resizeSendBuffer(int new_size)\n    {\n        m_sbuf_len = new_size;\n        m_sbuf.setCapacity(new_size);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java", "class_name": "PseudoTCPBase", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nResizes send buffer to <tt>new_size</tt>\n\n@param new_size\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[void]resizeReceiveBuffer(int)", "name": "resizeReceiveBuffer", "arg_nums": 1, "params": [{"name": "new_size", "type": "int"}], "return_type": "void", "signature": "void resizeReceiveBuffer(int new_size)", "original_string": "    void resizeReceiveBuffer(int new_size)\n    {\n        short scale_factor = 0;\n\n        // Determine the scale factor such that the scaled window size can fit\n        // in a 16-bit unsigned integer.\n        while (new_size > 0xFFFF)\n        {\n            ++scale_factor;\n            new_size >>= 1;\n        }\n\n        // Determine the proper size of the buffer.\n        new_size <<= scale_factor;\n        boolean result = m_rbuf.setCapacity(new_size);\n\n        // Make sure the new buffer is large enough to contain data in the old\n        // buffer. This should always be true because this method is called either\n        // before connection is established or when peers are exchanging connect\n        // messages.\n        assert result;\n        m_rbuf_len = new_size;\n        m_rwnd_scale = scale_factor;\n        m_ssthresh = new_size;\n\n        int available_space = m_rbuf.getWriteRemaining();\n        m_rcv_wnd = available_space;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java", "class_name": "PseudoTCPBase", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nResizes receive buffer to <tt>new_size</tt>\n\n@param new_size\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[int]getM_snd_wnd()", "name": "getM_snd_wnd", "arg_nums": 0, "params": [], "return_type": "int", "signature": "int getM_snd_wnd()", "original_string": "    int getM_snd_wnd()\n    {\n        return m_snd_wnd;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java", "class_name": "PseudoTCPBase", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "int", "classes": []}, "docstring": "\n@return send window size\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[PseudoTcpState]getState()", "name": "getState", "arg_nums": 0, "params": [], "return_type": "PseudoTcpState", "signature": "public PseudoTcpState getState()", "original_string": "    public PseudoTcpState getState()\n    {\n        return m_state;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java", "class_name": "PseudoTCPBase", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "PseudoTcpState", "classes": []}, "docstring": "\n\n@return current @link{PseudoTcpState}\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[int]getSendBufferSize()", "name": "getSendBufferSize", "arg_nums": 0, "params": [], "return_type": "int", "signature": "int getSendBufferSize()", "original_string": "    int getSendBufferSize()\n    {\n        return m_sbuf_len;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java", "class_name": "PseudoTCPBase", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "int", "classes": []}, "docstring": "\n\n@return send buffer's length\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[int]getRecvBufferSize()", "name": "getRecvBufferSize", "arg_nums": 0, "params": [], "return_type": "int", "signature": "int getRecvBufferSize()", "original_string": "    int getRecvBufferSize()\n    {\n        return m_rbuf_len;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java", "class_name": "PseudoTCPBase", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "int", "classes": []}, "docstring": "\n\n@return receive buffer's length\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[short]getM_rwnd_scale()", "name": "getM_rwnd_scale", "arg_nums": 0, "params": [], "return_type": "short", "signature": "public short getM_rwnd_scale()", "original_string": "    public short getM_rwnd_scale()\n    {\n        return m_rwnd_scale;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java", "class_name": "PseudoTCPBase", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "short", "classes": []}, "docstring": "\n@return the receive window scale\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[short]getM_swnd_scale()", "name": "getM_swnd_scale", "arg_nums": 0, "params": [], "return_type": "short", "signature": "public short getM_swnd_scale()", "original_string": "    public short getM_swnd_scale()\n    {\n        return m_swnd_scale;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java", "class_name": "PseudoTCPBase", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "short", "classes": []}, "docstring": "\n@return the send window scale\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[Object]getAckNotify()", "name": "getAckNotify", "arg_nums": 0, "params": [], "return_type": "Object", "signature": "public Object getAckNotify()", "original_string": "    public Object getAckNotify()\n    {\n        return ack_notify;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java", "class_name": "PseudoTCPBase", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object", "classes": []}, "docstring": ""}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[long]getConversationID()", "name": "getConversationID", "arg_nums": 0, "params": [], "return_type": "long", "signature": "long getConversationID()", "original_string": "    long getConversationID()\n    {\n        return m_conv;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java", "class_name": "PseudoTCPBase", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "long", "classes": []}, "docstring": ""}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[void]setConversationID(long)", "name": "setConversationID", "arg_nums": 1, "params": [{"name": "convID", "type": "long"}], "return_type": "void", "signature": "void setConversationID(long convID)", "original_string": "    void setConversationID(long convID)\n    {\n        if (m_state != PseudoTcpState.TCP_LISTEN)\n            throw new IllegalStateException();\n        this.m_conv = convID;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java", "class_name": "PseudoTCPBase", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java.PseudoTcpSocket.[]PseudoTcpSocket(PseudoTcpSocketImpl)", "name": "PseudoTcpSocket", "arg_nums": 1, "params": [{"name": "socketImpl", "type": "PseudoTcpSocketImpl"}], "return_type": "", "signature": "PseudoTcpSocket(PseudoTcpSocketImpl socketImpl)", "original_string": "    PseudoTcpSocket(PseudoTcpSocketImpl socketImpl) \n        throws SocketException \n    {\n        super(socketImpl);\n        this.socketImpl = socketImpl;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java", "class_name": "PseudoTcpSocket", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java.PseudoTcpSocket", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java.PseudoTcpSocket.[long]getConversationID()", "name": "getConversationID", "arg_nums": 0, "params": [], "return_type": "long", "signature": "public long getConversationID()", "original_string": "    public long getConversationID()\n    {\n        return socketImpl.getConversationID();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java", "class_name": "PseudoTcpSocket", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java.PseudoTcpSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "long", "classes": []}, "docstring": "\n\n@return PseudoTCP conversation ID\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java.PseudoTcpSocket.[void]setConversationID(long)", "name": "setConversationID", "arg_nums": 1, "params": [{"name": "convID", "type": "long"}], "return_type": "void", "signature": "public void setConversationID(long convID)", "original_string": "    public void setConversationID(long convID)\n        throws IllegalStateException\n    {\n        socketImpl.setConversationID(convID);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java", "class_name": "PseudoTcpSocket", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java.PseudoTcpSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSet conversation ID for the socket\nMust be called on unconnected socket\n\n@param convID the conversation ID to set\n@throws IllegalStateException when called on connected or closed socket\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java.PseudoTcpSocket.[void]setMTU(int)", "name": "setMTU", "arg_nums": 1, "params": [{"name": "mtu", "type": "int"}], "return_type": "void", "signature": "public void setMTU(int mtu)", "original_string": "    public void setMTU(int mtu)\n    {\n        socketImpl.setMTU(mtu);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java", "class_name": "PseudoTcpSocket", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java.PseudoTcpSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets MTU (maximum transmission unit) value\n@param mtu  the MTU value\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java.PseudoTcpSocket.[int]getMTU()", "name": "getMTU", "arg_nums": 0, "params": [], "return_type": "int", "signature": "public int getMTU()", "original_string": "    public int getMTU()\n    {\n        return socketImpl.getMTU();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java", "class_name": "PseudoTcpSocket", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java.PseudoTcpSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\nGets MTU (maximum transmission unit) value\n@return MTU value\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java.PseudoTcpSocket.[long]getOption(Option)", "name": "getOption", "arg_nums": 1, "params": [{"name": "option", "type": "Option"}], "return_type": "long", "signature": "public long getOption(Option option)", "original_string": "    public long getOption(Option option)\n    {\n        return socketImpl.getPTCPOption(option);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java", "class_name": "PseudoTcpSocket", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java.PseudoTcpSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "long", "classes": []}, "docstring": "\nSets an {@link Option} on this socket.\n@return PseudoTCP option value\n\n@param option the option to set on this socket.\n@see Option\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java.PseudoTcpSocket.[void]setOption(Option,long)", "name": "setOption", "arg_nums": 2, "params": [{"name": "option", "type": "Option"}, {"name": "optValue", "type": "long"}], "return_type": "void", "signature": "public void setOption(Option option, long optValue)", "original_string": "    public void setOption(Option option, long optValue)\n    {\n        socketImpl.setPTCPOption(option, optValue);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java", "class_name": "PseudoTcpSocket", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java.PseudoTcpSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\n\n@param option PseudoTCP option to set\n@param optValue option's value\n\n@see Option\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java.PseudoTcpSocket.[void]accept(int)", "name": "accept", "arg_nums": 1, "params": [{"name": "timeout", "type": "int"}], "return_type": "void", "signature": "public void accept(int timeout)", "original_string": "    public void accept(int timeout) \n        throws IOException\n    {\n        socketImpl.accept(timeout);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java", "class_name": "PseudoTcpSocket", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java.PseudoTcpSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nBlocking method waits for connection.\n\n@param timeout for this operation in ms\n@throws IOException If socket gets closed or timeout expires\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java.PseudoTcpSocket.[void]setDebugName(String)", "name": "setDebugName", "arg_nums": 1, "params": [{"name": "debugName", "type": "String"}], "return_type": "void", "signature": "public void setDebugName(String debugName)", "original_string": "    public void setDebugName(String debugName)\n    {\n        socketImpl.setDebugName(debugName);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java", "class_name": "PseudoTcpSocket", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java.PseudoTcpSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets debug name that will be displayed in log messages for this socket\n@param debugName the name of this socket for debug messages\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java.PseudoTcpSocket.[PseudoTcpState]getState()", "name": "getState", "arg_nums": 0, "params": [], "return_type": "PseudoTcpState", "signature": "public PseudoTcpState getState()", "original_string": "    public PseudoTcpState getState()\n    {\n        return socketImpl.getState();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java", "class_name": "PseudoTcpSocket", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java.PseudoTcpSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "PseudoTcpState", "classes": []}, "docstring": "\nReturns current <tt>PseudoTcpState</tt> of this socket\n@return current <tt>PseudoTcpState</tt>\n\n@see PseudoTcpState\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java.PseudoTcpSocket.[boolean]isConnected()", "name": "isConnected", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "@Override\n    public boolean isConnected()", "original_string": "    @Override\n    public boolean isConnected() \n    {\n        return getState() == PseudoTcpState.TCP_ESTABLISHED;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java", "class_name": "PseudoTcpSocket", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java.PseudoTcpSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java.PseudoTcpSocket.[boolean]isConnecting()", "name": "isConnecting", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "public boolean isConnecting()", "original_string": "    public boolean isConnecting()\n    {\n        PseudoTcpState currentState = getState();\n        return currentState == PseudoTcpState.TCP_ESTABLISHED\n            || currentState == PseudoTcpState.TCP_SYN_RECEIVED\n            || currentState == PseudoTcpState.TCP_SYN_SENT;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java", "class_name": "PseudoTcpSocket", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java.PseudoTcpSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\n\n@return true if socket is connected or is trying to connect\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java.PseudoTcpSocket.[boolean]isClosed()", "name": "isClosed", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "@Override\n    public boolean isClosed()", "original_string": "    @Override\n    public boolean isClosed()\n    {\n        return getState() == PseudoTcpState.TCP_CLOSED;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java", "class_name": "PseudoTcpSocket", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java.PseudoTcpSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java.PseudoTcpSocket.[void]connect(SocketAddress)", "name": "connect", "arg_nums": 1, "params": [{"name": "endpoint", "type": "SocketAddress"}], "return_type": "void", "signature": "@Override\n    public void connect(SocketAddress endpoint)", "original_string": "    @Override\n    public void connect(SocketAddress endpoint)\n            throws IOException\n    {\n        this.connect(endpoint, 0);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java", "class_name": "PseudoTcpSocket", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java.PseudoTcpSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\n{@inheritDoc}\n\nConnects without the timeout.\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java.PseudoTcpSocket.[void]checkDestination(int)", "name": "checkDestination", "arg_nums": 1, "params": [{"name": "dstPort", "type": "int"}], "return_type": "void", "signature": "private void checkDestination(int dstPort)", "original_string": "    private void checkDestination(int dstPort)\n    {\n        if (dstPort < 0 || dstPort > 65535)\n        {\n            throw new IllegalArgumentException(\"Port out of range: \" + dstPort);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java", "class_name": "PseudoTcpSocket", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java.PseudoTcpSocket", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nChecks destination port number.\n\n@param dstPort the destination port to check.\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java.PseudoTcpSocket.[void]connect(SocketAddress,int)", "name": "connect", "arg_nums": 2, "params": [{"name": "remoteAddr", "type": "SocketAddress"}, {"name": "timeout", "type": "int"}], "return_type": "void", "signature": "@Override\n    public void connect(SocketAddress remoteAddr, int timeout)", "original_string": "    @Override\n    public void connect(SocketAddress remoteAddr, int timeout)\n            throws IOException\n    {\n        if (isClosed())\n        {\n            throw new SocketException(\"Socket is closed\");\n        }\n        if (timeout < 0)\n        {\n            throw new IllegalArgumentException(\"timeout < 0\");\n        }\n        if (isConnected())\n        {\n            throw new SocketException(\"Already connected\");\n        }\n        if (remoteAddr == null)\n        {\n            throw new IllegalArgumentException(\"remoteAddr == null\");\n        }\n        if (!(remoteAddr instanceof InetSocketAddress))\n        {\n            throw new IllegalArgumentException(\n                    \"Remote address not an InetSocketAddress: \" +\n                            remoteAddr.getClass());\n        }\n        InetSocketAddress inetAddr = (InetSocketAddress) remoteAddr;\n        if (inetAddr.getAddress() == null)\n        {\n            throw new UnknownHostException(\n                    \"Host is unresolved: \" + inetAddr.getHostName());\n        }\n\n        int port = inetAddr.getPort();\n        checkDestination(port);\n\n        synchronized (connectLock)\n        {\n            try\n            {\n                socketImpl.connect(remoteAddr, timeout);\n            }\n            catch (IOException e)\n            {\n                socketImpl.close();\n                throw e;\n            }\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java", "class_name": "PseudoTcpSocket", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java.PseudoTcpSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\n{@inheritDoc}\n\nOn Android, we must not use the default <tt>connect</tt> implementation,\nbecause that one deals directly with physical resources, while we create\na socket on top of another socket.\n\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java.PseudoTcpSocket.[void]close()", "name": "close", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Override\n    public synchronized void close()", "original_string": "    @Override\n    public synchronized void close()\n            throws IOException\n    {\n        synchronized (closeLock)\n        {\n            if (isClosed())\n                return;\n            socketImpl.close();\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java", "class_name": "PseudoTcpSocket", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java.PseudoTcpSocket", "attributes": {"modifiers": "@Override\n    public synchronized", "marker_annotations": ["@Override"], "non_marker_annotations": ["public", "synchronized"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java.PseudoTcpSocket.[OutputStream]getOutputStream()", "name": "getOutputStream", "arg_nums": 0, "params": [], "return_type": "OutputStream", "signature": "@Override\n    public OutputStream getOutputStream()", "original_string": "    @Override\n    public OutputStream getOutputStream() throws IOException\n    {\n        return socketImpl.getOutputStream();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java", "class_name": "PseudoTcpSocket", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java.PseudoTcpSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "OutputStream", "classes": []}, "docstring": ""}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java.PseudoTcpSocket.[void]accept(SocketAddress,int)", "name": "accept", "arg_nums": 2, "params": [{"name": "remoteAddress", "type": "SocketAddress"}, {"name": "timeout", "type": "int"}], "return_type": "void", "signature": "public void accept(SocketAddress remoteAddress, int timeout)", "original_string": "    public void accept(SocketAddress remoteAddress, int timeout)\n            throws IOException\n    {\n        socketImpl.accept(remoteAddress, timeout);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java", "class_name": "PseudoTcpSocket", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java.PseudoTcpSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nAllows to set up the remote address directly.\nOtherwise, when using the other <tt>accept</tt> methods,\nthe first address from which a packet is received, is considered\nthe remote address.\n\n@param remoteAddress the one and only remote address that will be\n                     accepted as remote packet's source\n@param timeout connection accept timeout value in milliseconds, after\n               which the exception will be thrown.\n@throws IOException if socket is closed or timeout expires\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java.PseudoTcpSocket.[FileDescriptor]getFileDescriptor()", "name": "getFileDescriptor", "arg_nums": 0, "params": [], "return_type": "FileDescriptor", "signature": "public FileDescriptor getFileDescriptor()", "original_string": "    public FileDescriptor getFileDescriptor()\n    {\n        return socketImpl.getFileDescriptor();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java", "class_name": "PseudoTcpSocket", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java.PseudoTcpSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "FileDescriptor", "classes": []}, "docstring": "\nReturn the <tt>FileDescriptor</tt> of the underlying socket.\n@return the <tt>FileDescriptor</tt> of the underlying socket.\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[]PseudoTcpSocketImpl(long,DatagramSocket)", "name": "PseudoTcpSocketImpl", "arg_nums": 2, "params": [{"name": "conv_id", "type": "long"}, {"name": "sock", "type": "DatagramSocket"}], "return_type": "", "signature": "public PseudoTcpSocketImpl(long conv_id, DatagramSocket sock)", "original_string": "    public PseudoTcpSocketImpl(long conv_id, DatagramSocket sock)\n    {\n        pseudoTcp = new PseudoTCPBase(this, conv_id);\n        //Default MTU\n        setMTU(1450);\n        this.socket = sock;\n        //TODO: find out if this call is required\n        /*try\n        {\n            setOption(SO_TIMEOUT, 0);\n        }\n        catch (SocketException e)\n        {\n            throw new RuntimeException(e);\n        }*/\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java", "class_name": "PseudoTcpSocketImpl", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\n\n@param conv_id conversation id, must be the same on both sides\n@param sock datagram socket used for network operations\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[]PseudoTcpSocketImpl(long)", "name": "PseudoTcpSocketImpl", "arg_nums": 1, "params": [{"name": "conv_id", "type": "long"}], "return_type": "", "signature": "public PseudoTcpSocketImpl(long conv_id)", "original_string": "    public PseudoTcpSocketImpl(long conv_id)\n        throws SocketException\n    {\n        this(conv_id, new DatagramSocket());\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java", "class_name": "PseudoTcpSocketImpl", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nThis constructor creates <tt>DatagramSocket</tt> with random port. Should\nbe used for clients.\n\n@param conv_id conversation id, must be the same on both sides\n@throws SocketException\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[]PseudoTcpSocketImpl(long,int)", "name": "PseudoTcpSocketImpl", "arg_nums": 2, "params": [{"name": "conv_id", "type": "long"}, {"name": "local_port", "type": "int"}], "return_type": "", "signature": "public PseudoTcpSocketImpl(long conv_id, int local_port)", "original_string": "    public PseudoTcpSocketImpl(long conv_id, int local_port)\n        throws SocketException\n    {\n        this(conv_id, new DatagramSocket(local_port));\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java", "class_name": "PseudoTcpSocketImpl", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nBinds <tt>DatagramSocket</tt> to given <tt>local_port</tt>\n\n@param conv_id conversation id, must be the same on both sides\n@param local_port the local port that will be used for this socket\n@throws SocketException\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[]PseudoTcpSocketImpl(long,String,int)", "name": "PseudoTcpSocketImpl", "arg_nums": 3, "params": [{"name": "conv_id", "type": "long"}, {"name": "local_ip", "type": "String"}, {"name": "local_port", "type": "int"}], "return_type": "", "signature": "public PseudoTcpSocketImpl(long conv_id, String local_ip, int local_port)", "original_string": "    public PseudoTcpSocketImpl(long conv_id, String local_ip, int local_port)\n        throws SocketException,\n               UnknownHostException\n    {\n        this(conv_id, new DatagramSocket(local_port,\n                                         InetAddress.getByName(local_ip)));\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java", "class_name": "PseudoTcpSocketImpl", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nCreates DatagramSocket for <tt>local_ip</tt>:<tt>local_port</tt>\n\n@param conv_id conversation id, must be the same on both sides\n@param local_ip used by <tt>DatagramSocket</tt>\n@param local_port used by <tt>DatagramSocket</tt>\n@throws SocketException\n@throws UnknownHostException\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[void]setMTU(int)", "name": "setMTU", "arg_nums": 1, "params": [{"name": "mtu", "type": "int"}], "return_type": "void", "signature": "public void setMTU(int mtu)", "original_string": "    public void setMTU(int mtu)\n    {\n        this.pseudoTcp.notifyMTU(mtu);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java", "class_name": "PseudoTcpSocketImpl", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets the MTU parameter for this socket\n@param mtu the MTU value\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[int]getMTU()", "name": "getMTU", "arg_nums": 0, "params": [], "return_type": "int", "signature": "public int getMTU()", "original_string": "    public int getMTU()\n    {\n        return pseudoTcp.getMTU();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java", "class_name": "PseudoTcpSocketImpl", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\n\n@return current MTU set\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[long]getConversationID()", "name": "getConversationID", "arg_nums": 0, "params": [], "return_type": "long", "signature": "long getConversationID()", "original_string": "    long getConversationID()\n    {\n        return pseudoTcp.getConversationID();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java", "class_name": "PseudoTcpSocketImpl", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "long", "classes": []}, "docstring": ""}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[void]setConversationID(long)", "name": "setConversationID", "arg_nums": 1, "params": [{"name": "convID", "type": "long"}], "return_type": "void", "signature": "void setConversationID(long convID)", "original_string": "    void setConversationID(long convID)\n    {\n        pseudoTcp.setConversationID(convID);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java", "class_name": "PseudoTcpSocketImpl", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[void]setDebugName(String)", "name": "setDebugName", "arg_nums": 1, "params": [{"name": "debugName", "type": "String"}], "return_type": "void", "signature": "public void setDebugName(String debugName)", "original_string": "    public void setDebugName(String debugName)\n    {\n        this.pseudoTcp.debugName = debugName;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java", "class_name": "PseudoTcpSocketImpl", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets debug name that will be displayed in log messages for this socket\n@param debugName the debug name to set \n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[void]create(boolean)", "name": "create", "arg_nums": 1, "params": [{"name": "stream", "type": "boolean"}], "return_type": "void", "signature": "@Override\n    protected void create(boolean stream)", "original_string": "    @Override\n    protected void create(boolean stream) \n        throws IOException\n    {\n        //no effect        \n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java", "class_name": "PseudoTcpSocketImpl", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl", "attributes": {"modifiers": "@Override\n    protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCreates either a stream or a datagram socket.\n@param stream if true, create a stream socket; otherwise, create a datagram socket.\n@throws IOException if an I/O error occurs while creating the socket.\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[void]connect(String,int)", "name": "connect", "arg_nums": 2, "params": [{"name": "host", "type": "String"}, {"name": "port", "type": "int"}], "return_type": "void", "signature": "@Override\n    protected void connect(String host, int port)", "original_string": "    @Override\n    protected void connect(String host, int port) \n        throws IOException\n    {\n        doConnect(new InetSocketAddress(InetAddress.getByName(host), port), 0);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java", "class_name": "PseudoTcpSocketImpl", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl", "attributes": {"modifiers": "@Override\n    protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nConnects this socket to the specified port on the named host.\n@param host the name of the remote host.\n@param port the port number.\n@throws IOException \n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[void]connect(InetAddress,int)", "name": "connect", "arg_nums": 2, "params": [{"name": "address", "type": "InetAddress"}, {"name": "port", "type": "int"}], "return_type": "void", "signature": "@Override\n    protected void connect(InetAddress address, int port)", "original_string": "    @Override\n    protected void connect(InetAddress address, int port) \n        throws IOException\n    {\n        connect(address.getHostAddress(), port);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java", "class_name": "PseudoTcpSocketImpl", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl", "attributes": {"modifiers": "@Override\n    protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nConnects this socket to the specified port number on the specified host.\n@param address the IP address of the remote host.\n@param port the port number.\n@throws IOException if an I/O error occurs when attempting a connection.\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[void]connect(SocketAddress,int)", "name": "connect", "arg_nums": 2, "params": [{"name": "address", "type": "SocketAddress"}, {"name": "timeout", "type": "int"}], "return_type": "void", "signature": "@Override\n    protected void connect(SocketAddress address, int timeout)", "original_string": "    @Override\n    protected void connect(SocketAddress address, int timeout) \n        throws IOException\n    {\n        InetSocketAddress inetAddr = (InetSocketAddress) address;\n        doConnect(inetAddr, timeout);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java", "class_name": "PseudoTcpSocketImpl", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl", "attributes": {"modifiers": "@Override\n    protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nConnects this socket to the specified port number on the specified host. \nA timeout of zero is interpreted as an infinite timeout. \nThe connection will then block until established or an error occurs.\n@param address the Socket address of the remote host.\n@param timeout the timeout value, in milliseconds, or zero for no timeout.\n@throws IOException if an I/O error occurs when attempting a connection.\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[void]bind(InetAddress,int)", "name": "bind", "arg_nums": 2, "params": [{"name": "host", "type": "InetAddress"}, {"name": "port", "type": "int"}], "return_type": "void", "signature": "@Override\n    public void bind(InetAddress host, int port)", "original_string": "    @Override\n    public void bind(InetAddress host, int port) \n        throws IOException\n    {\n        if (socket != null)\n            socket.close();\n        InetSocketAddress newAddr = new InetSocketAddress(host.getHostAddress(), port);\n        this.socket = new DatagramSocket(newAddr);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java", "class_name": "PseudoTcpSocketImpl", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nBinds this socket to the specified port number on the specified host.\n@param host the IP address of the remote host.\n@param port the port number.\n@throws IOException \n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[void]listen(int)", "name": "listen", "arg_nums": 1, "params": [{"name": "backlog", "type": "int"}], "return_type": "void", "signature": "@Override\n    protected void listen(int backlog)", "original_string": "    @Override\n    protected void listen(int backlog) \n        throws IOException\n    {\n        throw new UnsupportedOperationException(\"Not supported yet.\");\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java", "class_name": "PseudoTcpSocketImpl", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl", "attributes": {"modifiers": "@Override\n    protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets the maximum queue length for incoming connection \nindications (a request to connect) to the count argument. \nIf a connection indication arrives when the queue is full,\nthe connection is refused.\n@param backlog the maximum length of the queue.\n@throws IOException if an I/O error occurs when creating the queue.\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[void]setOption(int,Object)", "name": "setOption", "arg_nums": 2, "params": [{"name": "optID", "type": "int"}, {"name": "value", "type": "Object"}], "return_type": "void", "signature": "@Override\n    public void setOption(int optID, Object value)", "original_string": "    @Override\n    public void setOption(int optID, Object value) \n        throws SocketException\n    {\n        //TODO: map options to PTCP options/method calls\n        options.put(optID, value);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java", "class_name": "PseudoTcpSocketImpl", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[Object]getOption(int)", "name": "getOption", "arg_nums": 1, "params": [{"name": "optID", "type": "int"}], "return_type": "Object", "signature": "@Override\n    public Object getOption(int optID)", "original_string": "    @Override\n    public Object getOption(int optID) \n        throws SocketException\n    {\n        //TODO: map options to PTCP options/method calls\n        if (optID == SocketOptions.TCP_NODELAY)\n        {\n            Object ret = options.get(Option.OPT_NODELAY.ordinal());\n            return ret != null;\n        }\n\n        Object option = options.get(optID);\n        if (option == null)\n        {\n            logger.warning(\"Asked for unknown optID\" + optID);\n        }\n        return option;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java", "class_name": "PseudoTcpSocketImpl", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object", "classes": []}, "docstring": ""}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[long]getPTCPOption(Option)", "name": "getPTCPOption", "arg_nums": 1, "params": [{"name": "opt", "type": "Option"}], "return_type": "long", "signature": "public long getPTCPOption(Option opt)", "original_string": "    public long getPTCPOption(Option opt)\n    {\n        if (Option.OPT_READ_TIMEOUT == opt)\n        {\n            return this.readTimeout;\n        }\n        else if (Option.OPT_WRITE_TIMEOUT == opt)\n        {\n            return this.writeTimeout;\n        }\n        else\n        {\n            return pseudoTcp.getOption(opt);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java", "class_name": "PseudoTcpSocketImpl", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "long", "classes": []}, "docstring": ""}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[void]setPTCPOption(Option,long)", "name": "setPTCPOption", "arg_nums": 2, "params": [{"name": "opt", "type": "Option"}, {"name": "optValue", "type": "long"}], "return_type": "void", "signature": "public void setPTCPOption(Option opt, long optValue)", "original_string": "    public void setPTCPOption(Option opt, long optValue)\n    {\n        if (Option.OPT_WRITE_TIMEOUT == opt)\n        {\n            this.writeTimeout = optValue >= 0 ? optValue : 0;\n        }\n        else if (Option.OPT_READ_TIMEOUT == opt)\n        {\n            this.readTimeout = optValue >= 0 ? optValue : 0;\n        }\n        else\n        {\n            pseudoTcp.setOption(opt, optValue);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java", "class_name": "PseudoTcpSocketImpl", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[void]doConnect(InetSocketAddress,long)", "name": "doConnect", "arg_nums": 2, "params": [{"name": "remoteAddress", "type": "InetSocketAddress"}, {"name": "timeout", "type": "long"}], "return_type": "void", "signature": "void doConnect(InetSocketAddress remoteAddress, long timeout)", "original_string": "    void doConnect(InetSocketAddress remoteAddress, long timeout)\n        throws IOException\n    {\n        logger.fine(\"Connecting to \"+remoteAddress);\n        this.remoteAddr = remoteAddress;\n        startThreads();\n        pseudoTcp.connect();\n        updateClock();\n        boolean noTimeout = timeout <= 0;\n        try\n        {\n            long elapsed = 0;\n            //Here the threads is blocked untill we reach TCP_ESTABLISHED state\n            //There's also check for timeout for that op\n            synchronized (state_notify)\n            {\n                while (pseudoTcp.getState() != PseudoTcpState.TCP_ESTABLISHED\n                    &&  (noTimeout || (elapsed < timeout)) )\n                {\n                    long start = System.nanoTime();\n                    state_notify.wait(timeout);\n                    elapsed += TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start);\n                }\n                if (pseudoTcp.getState() != PseudoTcpState.TCP_ESTABLISHED)\n                {\n                    throw new IOException(\"Connect timeout\");\n                }\n            }\n        }\n        catch (InterruptedException ex)\n        {\n            close();\n            throw new IOException(\"Connect aborted\");\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java", "class_name": "PseudoTcpSocketImpl", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nStart connection procedure\n\n@param remoteAddress to which this socket connects to\n@param timeout for this operation in ms\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[void]accept(SocketAddress,int)", "name": "accept", "arg_nums": 2, "params": [{"name": "remoteAddress", "type": "SocketAddress"}, {"name": "timeout", "type": "int"}], "return_type": "void", "signature": "void accept(SocketAddress remoteAddress, int timeout)", "original_string": "    void accept(SocketAddress remoteAddress, int timeout)\n        throws IOException\n    {\n        this.remoteAddr = remoteAddress;\n        accept(timeout);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java", "class_name": "PseudoTcpSocketImpl", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nBlocking method waits for connection.\n\n@param remoteAddress the one and only address that will be\n                     accepted as the source for remote packets\n@param timeout for this operation in ms\n@throws IOException If socket gets closed or timeout expires\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[void]accept(int)", "name": "accept", "arg_nums": 1, "params": [{"name": "timeout", "type": "int"}], "return_type": "void", "signature": "void accept(int timeout)", "original_string": "    void accept(int timeout)\n        throws IOException\n    {\n        try\n        {\n            startThreads();\n            PseudoTcpState state = pseudoTcp.getState();\n            if (state == PseudoTcpState.TCP_CLOSED)\n            {\n                throw new IOException(\"Socket closed\");\n            }\n            if (pseudoTcp.getState() != PseudoTcpState.TCP_ESTABLISHED)\n            {\n                synchronized (state_notify)\n                {\n                    state_notify.wait(timeout);\n                }\n            }\n            if (pseudoTcp.getState() != PseudoTcpState.TCP_ESTABLISHED)\n            {\n                throw new IOException(\"Accept timeout\");\n            }\n        }\n        catch (InterruptedException ex)\n        {\n            IOException e = new IOException(\"Accept aborted\");\n            pseudoTcp.closedown(e);\n            throw e;\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java", "class_name": "PseudoTcpSocketImpl", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nBlocking method waits for connection.\n\n@param timeout for this operation in ms\n@throws IOException If socket gets closed or timeout expires\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[void]accept(SocketImpl)", "name": "accept", "arg_nums": 1, "params": [{"name": "s", "type": "SocketImpl"}], "return_type": "void", "signature": "@Override\n    protected void accept(SocketImpl s)", "original_string": "    @Override\n    protected void accept(SocketImpl s)\n                        throws IOException\n    {\n        //TODO: not sure how this should work\n        int timeout = 5000;\n        accept(timeout);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java", "class_name": "PseudoTcpSocketImpl", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl", "attributes": {"modifiers": "@Override\n    protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nAccepts a connection.\n@param s the accepted connection.\n@throws IOException if an I/O error occurs when accepting the connection.\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[PseudoTcpState]getState()", "name": "getState", "arg_nums": 0, "params": [], "return_type": "PseudoTcpState", "signature": "public PseudoTcpState getState()", "original_string": "    public PseudoTcpState getState()\n    {\n        return pseudoTcp.getState();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java", "class_name": "PseudoTcpSocketImpl", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "PseudoTcpState", "classes": []}, "docstring": "\n\n@return current TCP state\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[void]updateClock()", "name": "updateClock", "arg_nums": 0, "params": [], "return_type": "void", "signature": "private void updateClock()", "original_string": "    private void updateClock()\n    {\n        scheduleClockTask(0);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java", "class_name": "PseudoTcpSocketImpl", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nInterrupts clock thread's wait method to force time update\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[void]startThreads()", "name": "startThreads", "arg_nums": 0, "params": [], "return_type": "void", "signature": "private void startThreads()", "original_string": "    private void startThreads()\n    {\n        pseudoTcp.notifyClock(PseudoTCPBase.now());\n        receiveThread = new Thread(new Runnable()\n        {\n            @Override\n            public void run()\n            {\n                receivePackets();\n            }\n        }, \"PseudoTcpReceiveThread\");\n\n        runReceive = true;\n        runClock = true;\n        receiveThread.start();\n        scheduleClockTask(0);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java", "class_name": "PseudoTcpSocketImpl", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nStarts all threads required by the socket\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[void]onTcpOpen(PseudoTCPBase)", "name": "onTcpOpen", "arg_nums": 1, "params": [{"name": "tcp", "type": "PseudoTCPBase"}], "return_type": "void", "signature": "@Override\n    public void onTcpOpen(PseudoTCPBase tcp)", "original_string": "    @Override\n    public void onTcpOpen(PseudoTCPBase tcp)\n    {\n        logger.log(Level.FINE, \"tcp opened\");\n        //Release threads blocked at state_notify monitor object.\n        synchronized (state_notify)\n        {\n            state_notify.notifyAll();\n        }\n        //TCP is considered writeable at this point\n        onTcpWriteable(tcp);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java", "class_name": "PseudoTcpSocketImpl", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nImplements <tt>PseudoTcpNotify</tt>\nCalled when TCP enters connected state.\n\n@param tcp the {@link PseudoTCPBase} that caused an event\n@see PseudoTcpNotify#onTcpOpen(PseudoTCPBase)\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[void]onTcpReadable(PseudoTCPBase)", "name": "onTcpReadable", "arg_nums": 1, "params": [{"name": "tcp", "type": "PseudoTCPBase"}], "return_type": "void", "signature": "@Override\n    public void onTcpReadable(PseudoTCPBase tcp)", "original_string": "    @Override\n    public void onTcpReadable(PseudoTCPBase tcp)\n    {\n        if (logger.isLoggable(Level.FINER))\n        {\n            logger.log(\n                Level.FINER,\n                \"TCP READABLE data available for reading: \"+tcp.getAvailable());\n        }\n        //release all thread blocked at read_notify monitor\n        synchronized (read_notify)\n        {\n            read_notify.notifyAll();\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java", "class_name": "PseudoTcpSocketImpl", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nImplements <tt>PseudoTcpNotify</tt>\n\n@param tcp the {@link PseudoTCPBase} that caused an event\n@see PseudoTcpNotify#onTcpReadable(PseudoTCPBase)\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[void]onTcpWriteable(PseudoTCPBase)", "name": "onTcpWriteable", "arg_nums": 1, "params": [{"name": "tcp", "type": "PseudoTCPBase"}], "return_type": "void", "signature": "@Override\n    public void onTcpWriteable(PseudoTCPBase tcp)", "original_string": "    @Override\n    public void onTcpWriteable(PseudoTCPBase tcp)\n    {\n\n        logger.log(Level.FINER, \"stream writeable\");\n        //release all threads blocked at write monitor\n        synchronized (write_notify)\n        {\n            write_notify.notifyAll();\n        }\n        //writeSemaphore.release(1);        \n        logger.log(Level.FINER, \"write notified - now !\");\n\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java", "class_name": "PseudoTcpSocketImpl", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nImplements <tt>PseudoTcpNotify</tt>\n\n@param tcp the {@link PseudoTCPBase} that caused an event\n@see PseudoTcpNotify#onTcpWriteable(PseudoTCPBase)\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[void]onTcpClosed(PseudoTCPBase,IOException)", "name": "onTcpClosed", "arg_nums": 2, "params": [{"name": "tcp", "type": "PseudoTCPBase"}, {"name": "e", "type": "IOException"}], "return_type": "void", "signature": "@Override\n    public void onTcpClosed(PseudoTCPBase tcp, IOException e)", "original_string": "    @Override\n    public void onTcpClosed(PseudoTCPBase tcp, IOException e)\n    {\n        if (e != null)\n        {\n            //e.printStackTrace();\n            logger.log(Level.SEVERE, \"PseudoTcp closed: \" + e);\n        }\n        else\n        {\n            logger.log(Level.FINE, \"PseudoTcp closed\");\n        }\n        runReceive = false;\n        runClock = false;\n        this.exception = e;\n        releaseAllLocks();\n        cancelClockTask(true);\n\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java", "class_name": "PseudoTcpSocketImpl", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nImplements <tt>PseudoTcpNotify</tt>\n\n@param tcp the {@link PseudoTCPBase} that caused an event\n@param e the <tt>Exception</tt> which is the reason for closing socket,\n or <tt>null</tt> if there wasn't any\n\n@see PseudoTcpNotify#onTcpClosed(PseudoTCPBase, IOException)\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[void]releaseAllLocks()", "name": "releaseAllLocks", "arg_nums": 0, "params": [], "return_type": "void", "signature": "private void releaseAllLocks()", "original_string": "    private void releaseAllLocks()\n    {\n        synchronized (read_notify)\n        {\n            read_notify.notifyAll();\n        }\n        synchronized (write_notify)\n        {\n            write_notify.notifyAll();\n        }\n        synchronized (state_notify)\n        {\n            state_notify.notifyAll();\n        }\n        //this interrupt won't work for DatagramSocket read packet operation\n        //receiveThread.interrupt();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java", "class_name": "PseudoTcpSocketImpl", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nReleases all monitor objects so that the threads will check their \"run\nflags\"\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[void]joinAllThreads()", "name": "joinAllThreads", "arg_nums": 0, "params": [], "return_type": "void", "signature": "private void joinAllThreads()", "original_string": "    private void joinAllThreads() throws InterruptedException\n    {\n        receiveThread.join();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java", "class_name": "PseudoTcpSocketImpl", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nJoins all running threads\n\n@throws InterruptedException\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[WriteResult]tcpWritePacket(PseudoTCPBase,byte[],int)", "name": "tcpWritePacket", "arg_nums": 3, "params": [{"name": "tcp", "type": "PseudoTCPBase"}, {"name": "buffer", "type": "byte[]"}, {"name": "len", "type": "int"}], "return_type": "WriteResult", "signature": "@Override\n    public WriteResult tcpWritePacket(PseudoTCPBase tcp, byte[] buffer, int len)", "original_string": "    @Override\n    public WriteResult tcpWritePacket(PseudoTCPBase tcp, byte[] buffer, int len)\n    {\n        if (logger.isLoggable(Level.FINEST))\n        {\n            logger.log(Level.FINEST,\n                       \"write packet to network length \" + len\n                            + \" address \" + remoteAddr);\n        }\n        try\n        {\n            //TODO: in case the packet is too long it should return WR_TOO_LARGE\n            DatagramPacket packet = new DatagramPacket(buffer, len, remoteAddr);\n            socket.send(packet);\n            return WriteResult.WR_SUCCESS;\n        }\n        catch (IOException ex)\n        {\n            logger.log(Level.SEVERE, \"TcpWritePacket exception: \" + ex);\n            return WriteResult.WR_FAIL;\n        }\n\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java", "class_name": "PseudoTcpSocketImpl", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "WriteResult", "classes": []}, "docstring": "\nImplements <tt>PseudoTcpNotify</tt>\n\n@param tcp the {@link PseudoTCPBase} that caused an event\n@param buffer the buffer containing packet data\n@param len packet data length in bytes\n@return operation result\n\n@see PseudoTcpNotify#tcpWritePacket(PseudoTCPBase, byte[], int)\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[void]receivePackets()", "name": "receivePackets", "arg_nums": 0, "params": [], "return_type": "void", "signature": "private void receivePackets()", "original_string": "    private void receivePackets()\n    {\n        byte[] buffer = new byte[DATAGRAM_RCV_BUFFER_SIZE];\n        DatagramPacket packet = new DatagramPacket(buffer,\n                                                   DATAGRAM_RCV_BUFFER_SIZE);\n        while (runReceive)\n        {\n            try\n            {\n                socket.receive(packet);\n                //Here is the binding point for remote socket if wasn't\n                //specified earlier\n                if (remoteAddr == null)\n                {\n                    remoteAddr = packet.getSocketAddress();\n                    logger.log(Level.WARNING,\n                               \"Remote addr not set previously, setting to \"\n                                       + remoteAddr);\n                }\n                else\n                {\n                    if (!packet.getSocketAddress().equals(remoteAddr))\n                    {\n                        logger.log(Level.WARNING,\n                                   \"Ignoring packet from \" + packet.getAddress()\n                                    + \":\" + packet.getPort()\n                                    + \" should be: \" + remoteAddr);\n                        continue;\n                    }                    \n                }\n                synchronized (pseudoTcp)\n                {\n                    pseudoTcp.notifyPacket(buffer, packet.getLength());\n                    //we need to update the clock after new packet is receivied\n                    updateClock();\n                }\n            }\n            catch (IOException ex)\n            {\n                //this exception occurs even when the socket \n                //is closed with the close operation, so we check\n                //here if this exception is important\n                if (runReceive)\n                {\n                    logger.log(Level.SEVERE,\n                              \"ReceivePackets exception: \" + ex);\n                    pseudoTcp.closedown(ex);\n                }\n                break;\n            }\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java", "class_name": "PseudoTcpSocketImpl", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nReceives packets from the network and passes them to TCP logic class\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[void]runClock()", "name": "runClock", "arg_nums": 0, "params": [], "return_type": "void", "signature": "private void runClock()", "original_string": "    private void runClock()\n    {\n        if (!runClock)\n        {\n            return;\n        }\n        long sleep;\n\n        synchronized (pseudoTcp)\n        {\n            pseudoTcp.notifyClock(PseudoTCPBase.now());\n            sleep = pseudoTcp.getNextClock(PseudoTCPBase.now());\n        }\n\n        //there might be negative interval even if there's no error\n        if (sleep == -1)\n        {\n            releaseAllLocks();\n            if (exception != null)\n            {\n                logger.log(Level.SEVERE,\n                           \"STATE: \" + pseudoTcp.getState()\n                           + \" ERROR: \" + exception.getMessage());\n            }\n        }\n        else\n        {\n            //logger.log(Level.FINEST, \"Clock sleep for \" + sleep);\n            scheduleClockTask(sleep);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java", "class_name": "PseudoTcpSocketImpl", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nMethod runs cyclic notification about time progress for TCP logic class\nIt runs in a separate thread\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[void]scheduleClockTask(long)", "name": "scheduleClockTask", "arg_nums": 1, "params": [{"name": "sleep", "type": "long"}], "return_type": "void", "signature": "private void scheduleClockTask(long sleep)", "original_string": "    private void scheduleClockTask(long sleep)\n    {\n        synchronized (clockTaskRunner)\n        {\n            // Cancel any existing tasks, to make sure we don't run duplicates.\n            cancelClockTask(false);\n            if (runClock)\n            {\n                currentlyScheduledClockTask\n                    = clockExecutor.schedule(\n                            clockTaskRunner, sleep, TimeUnit.MILLISECONDS);\n            }\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java", "class_name": "PseudoTcpSocketImpl", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[void]cancelClockTask(boolean)", "name": "cancelClockTask", "arg_nums": 1, "params": [{"name": "interruptIfRunning", "type": "boolean"}], "return_type": "void", "signature": "private void cancelClockTask(boolean interruptIfRunning)", "original_string": "    private void cancelClockTask(boolean interruptIfRunning)\n    {\n        // Copy the reference, in case it changes.\n        ScheduledFuture<?> taskToCancel = this.currentlyScheduledClockTask;\n        if (taskToCancel != null)\n        {\n            taskToCancel.cancel(interruptIfRunning);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java", "class_name": "PseudoTcpSocketImpl", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[OutputStream]getOutputStream()", "name": "getOutputStream", "arg_nums": 0, "params": [], "return_type": "OutputStream", "signature": "@Override\n    public OutputStream getOutputStream()", "original_string": "    @Override\n    public OutputStream getOutputStream()\n        throws IOException\n    {\n        if (outputstream == null)\n        {\n            outputstream = new PseudoTcpOutputStream();\n        }\n        return outputstream;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java", "class_name": "PseudoTcpSocketImpl", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "OutputStream", "classes": []}, "docstring": "\nReturns an output stream for this socket.\n@return an output stream for writing to this socket.\n@throws IOException if an I/O error occurs when creating the output stream.\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[InputStream]getInputStream()", "name": "getInputStream", "arg_nums": 0, "params": [], "return_type": "InputStream", "signature": "@Override\n    public InputStream getInputStream()", "original_string": "    @Override\n    public InputStream getInputStream()\n        throws IOException\n    {\n        if (inputStream == null)\n        {\n            inputStream = new PseudoTcpInputStream();\n        }\n        return inputStream;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java", "class_name": "PseudoTcpSocketImpl", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "InputStream", "classes": []}, "docstring": "\nReturns an input stream for this socket.\n@return a stream for reading from this socket.\n@throws IOException \n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[int]available()", "name": "available", "arg_nums": 0, "params": [], "return_type": "int", "signature": "@Override\n    protected int available()", "original_string": "    @Override\n    protected int available()\n        throws IOException\n    {\n        return getInputStream().available();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java", "class_name": "PseudoTcpSocketImpl", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl", "attributes": {"modifiers": "@Override\n    protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\nReturns the number of bytes that can be read from this socket without blocking.\n@return the number of bytes that can be read from this socket without blocking.\n@throws IOException if an I/O error occurs when determining the number of bytes available.\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[void]close()", "name": "close", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Override\n    public void close()", "original_string": "    @Override\n    public void close()\n        throws IOException\n    {\n        try\n        {\n            pseudoTcp.close(true);\n            //System.out.println(\"ON CLOSE: in flight \"+pseudoTcp.getBytesInFlight());\n            //System.out.println(\"ON CLOSE: buff not sent \"+pseudoTcp.getBytesBufferedNotSent());\n            onTcpClosed(pseudoTcp, null);\n            socket.close();\n            joinAllThreads();\n            //UpdateClock();\n            //TODO: closing procedure\n            //Here the thread should be blocked until TCP\n            //reaches CLOSED state, but there's no closing procedure\n            /*\n             * synchronized(state_notify){ while(pseudoTcp.getState() !=\n             * PseudoTcpState.TCP_CLOSED){ try { state_notify.wait(); } catch\n             * (InterruptedException ex) { throw new IOException(\"Close\n             * connection aborted\"); } } }\n             */\n        }\n        catch (InterruptedException ex)\n        {\n            throw new IOException(\"Closing socket interrupted\", ex);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java", "class_name": "PseudoTcpSocketImpl", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCloses this socket.\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[void]sendUrgentData(int)", "name": "sendUrgentData", "arg_nums": 1, "params": [{"name": "data", "type": "int"}], "return_type": "void", "signature": "@Override\n    protected void sendUrgentData(int data)", "original_string": "    @Override\n    protected void sendUrgentData(int data)\n        throws IOException\n    {\n        throw new RuntimeException(\"Sending urgent data is not supported\");\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java", "class_name": "PseudoTcpSocketImpl", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl", "attributes": {"modifiers": "@Override\n    protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSend one byte of urgent data on the socket. The byte to be sent is the low eight bits of the parameter\n@param data The byte of data to send\n@throws IOException if there is an error sending the data.\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[FileDescriptor]getFileDescriptor()", "name": "getFileDescriptor", "arg_nums": 0, "params": [], "return_type": "FileDescriptor", "signature": "@Override\n    protected FileDescriptor getFileDescriptor()", "original_string": "    @Override\n    protected FileDescriptor getFileDescriptor()\n    {\n        return fd;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java", "class_name": "PseudoTcpSocketImpl", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl", "attributes": {"modifiers": "@Override\n    protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "FileDescriptor", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[void]shutdownInput()", "name": "shutdownInput", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Override\n    protected void shutdownInput()", "original_string": "    @Override\n    protected void shutdownInput()\n            throws IOException\n    {\n        throw new IOException(\"Method not implemented!\");\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java", "class_name": "PseudoTcpSocketImpl", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl", "attributes": {"modifiers": "@Override\n    protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[void]shutdownOutput()", "name": "shutdownOutput", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Override\n    protected void shutdownOutput()", "original_string": "    @Override\n    protected void shutdownOutput()\n            throws IOException\n    {\n        throw new IOException(\"Method not implemented!\");\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java", "class_name": "PseudoTcpSocketImpl", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl", "attributes": {"modifiers": "@Override\n    protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[InetAddress]getInetAddress()", "name": "getInetAddress", "arg_nums": 0, "params": [], "return_type": "InetAddress", "signature": "@Override\n    protected InetAddress getInetAddress()", "original_string": "    @Override\n    protected InetAddress getInetAddress()\n    {\n        return ((InetSocketAddress) remoteAddr).getAddress();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java", "class_name": "PseudoTcpSocketImpl", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl", "attributes": {"modifiers": "@Override\n    protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "InetAddress", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[int]getPort()", "name": "getPort", "arg_nums": 0, "params": [], "return_type": "int", "signature": "@Override\n    protected int getPort()", "original_string": "    @Override\n    protected int getPort()\n    {\n        return ((InetSocketAddress) remoteAddr).getPort();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java", "class_name": "PseudoTcpSocketImpl", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl", "attributes": {"modifiers": "@Override\n    protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[boolean]supportsUrgentData()", "name": "supportsUrgentData", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "@Override\n    protected boolean supportsUrgentData()", "original_string": "    @Override\n    protected boolean supportsUrgentData()\n    {\n        return false;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java", "class_name": "PseudoTcpSocketImpl", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl", "attributes": {"modifiers": "@Override\n    protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[int]getLocalPort()", "name": "getLocalPort", "arg_nums": 0, "params": [], "return_type": "int", "signature": "@Override\n    protected int getLocalPort()", "original_string": "    @Override\n    protected int getLocalPort()\n    {\n        return socket.getLocalPort();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java", "class_name": "PseudoTcpSocketImpl", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl", "attributes": {"modifiers": "@Override\n    protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[void]setPerformancePreferences(int,int,int)", "name": "setPerformancePreferences", "arg_nums": 3, "params": [{"name": "connectionTime", "type": "int"}, {"name": "latency", "type": "int"}, {"name": "bandwidth", "type": "int"}], "return_type": "void", "signature": "@Override\n    protected void setPerformancePreferences(int connectionTime,\n                                             int latency,\n                                             int bandwidth)", "original_string": "    @Override\n    protected void setPerformancePreferences(int connectionTime,\n                                             int latency,\n                                             int bandwidth)\n    {\n        throw new UnsupportedOperationException(\"setPerformancePreferences\");\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java", "class_name": "PseudoTcpSocketImpl", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl", "attributes": {"modifiers": "@Override\n    protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpJavaSocket.java.PseudoTcpJavaSocket.[]PseudoTcpJavaSocket(long)", "name": "PseudoTcpJavaSocket", "arg_nums": 1, "params": [{"name": "conv_id", "type": "long"}], "return_type": "", "signature": "public PseudoTcpJavaSocket(long conv_id)", "original_string": "    public PseudoTcpJavaSocket(long conv_id) throws SocketException {\n        super(new PseudoTcpSocketImpl(conv_id));\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpJavaSocket.java", "class_name": "PseudoTcpJavaSocket", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpJavaSocket.java.PseudoTcpJavaSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpJavaSocket.java.PseudoTcpJavaSocket.[]PseudoTcpJavaSocket(long,DatagramSocket)", "name": "PseudoTcpJavaSocket", "arg_nums": 2, "params": [{"name": "conv_id", "type": "long"}, {"name": "socket", "type": "DatagramSocket"}], "return_type": "", "signature": "public PseudoTcpJavaSocket(long conv_id, DatagramSocket socket)", "original_string": "    public PseudoTcpJavaSocket(long conv_id, DatagramSocket socket)\n            throws SocketException {\n        super(new PseudoTcpSocketImpl(conv_id, socket));\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/PseudoTcpJavaSocket.java", "class_name": "PseudoTcpJavaSocket", "class_uri": "src/main/java/org/ice4j/pseudotcp/PseudoTcpJavaSocket.java.PseudoTcpJavaSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/org/ice4j/pseudotcp/RSegment.java.RSegment.[]RSegment(long,long)", "name": "RSegment", "arg_nums": 2, "params": [{"name": "seq", "type": "long"}, {"name": "len", "type": "long"}], "return_type": "", "signature": "public RSegment(long seq, long len)", "original_string": "    public RSegment(long seq, long len)\n    {\n        this.seq = seq;\n        this.len = len;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/RSegment.java", "class_name": "RSegment", "class_uri": "src/main/java/org/ice4j/pseudotcp/RSegment.java.RSegment", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java.ByteFifoBuffer.[]ByteFifoBuffer(int)", "name": "ByteFifoBuffer", "arg_nums": 1, "params": [{"name": "len", "type": "int"}], "return_type": "", "signature": "public ByteFifoBuffer(int len)", "original_string": "    public ByteFifoBuffer(int len)\n    {\n        array = new byte[len];\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java", "class_name": "ByteFifoBuffer", "class_uri": "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java.ByteFifoBuffer", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nCreates buffer of specified size\n\n@param len buffer's size\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java.ByteFifoBuffer.[int]length()", "name": "length", "arg_nums": 0, "params": [], "return_type": "int", "signature": "public int length()", "original_string": "    public int length()\n    {\n        return array.length;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java", "class_name": "ByteFifoBuffer", "class_uri": "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java.ByteFifoBuffer", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\n@return buffer's capacity\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java.ByteFifoBuffer.[int]read(byte[],int)", "name": "read", "arg_nums": 2, "params": [{"name": "out_buffer", "type": "byte[]"}, {"name": "count", "type": "int"}], "return_type": "int", "signature": "public int read(byte[] out_buffer, int count)", "original_string": "    public int read(byte[] out_buffer, int count)\n    {\n        return read(out_buffer, 0, count);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java", "class_name": "ByteFifoBuffer", "class_uri": "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java.ByteFifoBuffer", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\nReads <tt>count</tt> bytes into <tt>out_buffer</tt>. \nCurrent read position is incremented by count of bytes \nthat has been successfully read.\n\n@param out_buffer read count bytes into this buffer\n@param count number of bytes to read into the out_buffer\n@return bytes successfully read\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java.ByteFifoBuffer.[int]read(byte[],int,int)", "name": "read", "arg_nums": 3, "params": [{"name": "out_buffer", "type": "byte[]"}, {"name": "buff_offset", "type": "int"}, {"name": "count", "type": "int"}], "return_type": "int", "signature": "public int read(byte[] out_buffer, int buff_offset, int count)", "original_string": "    public int read(byte[] out_buffer, int buff_offset, int count) {\n        count = readLimit(count);\n        if (count > 0)\n        {\n            readOp(out_buffer, buff_offset, count, array, read_pos, array.length);\n            read_pos = (read_pos + count) % array.length;\n            buffered -= count;\n        }\n        return count;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java", "class_name": "ByteFifoBuffer", "class_uri": "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java.ByteFifoBuffer", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\nRead with buffer offset\n\n@param out_buffer read count bytes into this buffer\n@param buff_offset offset where to start writing into out_buffer\n@param count bytes to read\n@return read byte count\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java.ByteFifoBuffer.[int]readLimit(int)", "name": "readLimit", "arg_nums": 1, "params": [{"name": "desiredReadCount", "type": "int"}], "return_type": "int", "signature": "private int readLimit(int desiredReadCount)", "original_string": "    private int readLimit(int desiredReadCount)\n    {\n        return desiredReadCount > buffered ? buffered : desiredReadCount;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java", "class_name": "ByteFifoBuffer", "class_uri": "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java.ByteFifoBuffer", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\nLimits <tt>desiredReadCount</tt> to count that is actually available\n@param desiredReadCount desired amount of bytes to read\n@return min(buffered, desiredReadCount)\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java.ByteFifoBuffer.[void]readOp(byte[],int,int,byte[],int,int)", "name": "readOp", "arg_nums": 6, "params": [{"name": "outBuffer", "type": "byte[]"}, {"name": "dst_buff_offset", "type": "int"}, {"name": "count", "type": "int"}, {"name": "srcBuffer", "type": "byte[]"}, {"name": "read_pos", "type": "int"}, {"name": "buff_len", "type": "int"}], "return_type": "void", "signature": "private static void readOp(byte[] outBuffer, int dst_buff_offset, int count,\n                               byte[] srcBuffer, int read_pos, int buff_len)", "original_string": "    private static void readOp(byte[] outBuffer, int dst_buff_offset, int count,\n                               byte[] srcBuffer, int read_pos, int buff_len)\n    {\n        if (read_pos + count <= buff_len)\n        {\n            //single operation\n            System.arraycopy(srcBuffer, read_pos, outBuffer, dst_buff_offset, \n                                                             count);\n        }\n        else\n        {\n            //two operations\n            int tillEndCount = buff_len - read_pos;\n            System.arraycopy(srcBuffer, read_pos, outBuffer,\n                             dst_buff_offset, tillEndCount);\n            int fromStartCount = count - tillEndCount;\n            System.arraycopy(srcBuffer, 0, outBuffer,\n                             dst_buff_offset + tillEndCount, fromStartCount);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java", "class_name": "ByteFifoBuffer", "class_uri": "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java.ByteFifoBuffer", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nUtility method used for read operations\n@param outBuffer\n@param dst_buff_offset\n@param count\n@param srcBuffer\n@param read_pos\n@param buff_len \n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java.ByteFifoBuffer.[int]getWriteRemaining()", "name": "getWriteRemaining", "arg_nums": 0, "params": [], "return_type": "int", "signature": "public int getWriteRemaining()", "original_string": "    public int getWriteRemaining()\n    {\n        return array.length - buffered;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java", "class_name": "ByteFifoBuffer", "class_uri": "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java.ByteFifoBuffer", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\n\n@return space left in buffer for write\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java.ByteFifoBuffer.[int]getBuffered()", "name": "getBuffered", "arg_nums": 0, "params": [], "return_type": "int", "signature": "public int getBuffered()", "original_string": "    public int getBuffered()\n    {\n        return buffered;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java", "class_name": "ByteFifoBuffer", "class_uri": "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java.ByteFifoBuffer", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\n\n@return bytes stored in buffer and available for reading\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java.ByteFifoBuffer.[int]write(byte[],int)", "name": "write", "arg_nums": 2, "params": [{"name": "buffer", "type": "byte[]"}, {"name": "count", "type": "int"}], "return_type": "int", "signature": "public int write(byte[] buffer, int count)", "original_string": "    public int write(byte[] buffer, int count)\n    {\n        return write(buffer, 0, count);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java", "class_name": "ByteFifoBuffer", "class_uri": "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java.ByteFifoBuffer", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\nWrites <tt>count</tt> of bytes from the <tt>buffer</tt>\n\n@param buffer data to write into the buffer\n@param count number of bytes to read from the buffer\n@return bytes successfully written to buffer\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java.ByteFifoBuffer.[int]write(byte[],int,int)", "name": "write", "arg_nums": 3, "params": [{"name": "data", "type": "byte[]"}, {"name": "offset", "type": "int"}, {"name": "count", "type": "int"}], "return_type": "int", "signature": "public int write(byte[] data, int offset, int count)", "original_string": "    public int write(byte[] data, int offset, int count)\n    {\n        /*\n         * System.out.println(\"----write \" + this + \" \" + len + \" buffered \" +\n         * GetBuffered() + \" buff avail: \" + GetWriteRemaining());\n         */\n        count = writeLimit(count);\n        writeOp(data, offset, count, array, write_pos, array.length);\n        write_pos = (write_pos + count) % array.length;\n        buffered += count;\n        /*\n         * System.out.println(\"----write \"+this+\" \"+len+\" buffered\n         * \"+GetBuffered()); for(int i=0; i < len; i++){\n         * System.out.println(\"WDATA: \"+data[i]); }\n         */\n        return count;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java", "class_name": "ByteFifoBuffer", "class_uri": "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java.ByteFifoBuffer", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\nWrites data into the buffer.\n\n@param data source data\n@param offset source buffer's offset\n@param count number of bytes to read from the buffer\n@return byte count actually read\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java.ByteFifoBuffer.[void]writeOp(byte[],int,int,byte[],int,int)", "name": "writeOp", "arg_nums": 6, "params": [{"name": "inBuffer", "type": "byte[]"}, {"name": "inOffset", "type": "int"}, {"name": "count", "type": "int"}, {"name": "outBuffer", "type": "byte[]"}, {"name": "write_pos", "type": "int"}, {"name": "buff_len", "type": "int"}], "return_type": "void", "signature": "private static void writeOp(byte[] inBuffer,\n                                int inOffset,\n                                int count,\n                                byte[] outBuffer,\n                                int write_pos,\n                                int buff_len)", "original_string": "    private static void writeOp(byte[] inBuffer,\n                                int inOffset,\n                                int count,\n                                byte[] outBuffer,\n                                int write_pos,\n                                int buff_len)\n    {\n        if ((write_pos + count) <= buff_len)\n        {\n            //single op\n            System.arraycopy(inBuffer, inOffset, outBuffer, write_pos, count);\n        }\n        else\n        {\n            //till end and from beginning\n            int tillEndCount;\n            int fromStartCount;\n            tillEndCount = buff_len - write_pos;\n            fromStartCount = count - tillEndCount;\n            System.arraycopy(inBuffer, inOffset, outBuffer,\n                             write_pos, tillEndCount);\n            System.arraycopy(inBuffer, inOffset + tillEndCount,\n                             outBuffer, 0, fromStartCount);            \n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java", "class_name": "ByteFifoBuffer", "class_uri": "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java.ByteFifoBuffer", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nUtility method for write operations\n@param inBuffer\n@param inOffset\n@param count\n@param outBuffer\n@param write_pos\n@param buff_len \n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java.ByteFifoBuffer.[int]writeLimit(int)", "name": "writeLimit", "arg_nums": 1, "params": [{"name": "desiredWriteCount", "type": "int"}], "return_type": "int", "signature": "private int writeLimit(int desiredWriteCount)", "original_string": "    private int writeLimit(int desiredWriteCount)\n    {\n        return desiredWriteCount > (array.length - buffered) ? \n            (array.length - buffered) : desiredWriteCount;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java", "class_name": "ByteFifoBuffer", "class_uri": "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java.ByteFifoBuffer", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\nLimits <tt>desiredWriteCount</tt> to what's actually available\n@param desiredWriteCount\n@return \n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java.ByteFifoBuffer.[void]assertWriteLimit(int)", "name": "assertWriteLimit", "arg_nums": 1, "params": [{"name": "newWrPos", "type": "int"}], "return_type": "void", "signature": "private void assertWriteLimit(int newWrPos)", "original_string": "    private void assertWriteLimit(int newWrPos)\n        throws IllegalArgumentException\n    {\n        int spaceReq;\n        int availSpace = getWriteRemaining();\n        if (newWrPos < write_pos)\n        {\n            spaceReq = newWrPos + (array.length - write_pos);\n        }\n        else\n        {\n            spaceReq = newWrPos - write_pos;\n        }\n\n        if (spaceReq > availSpace)\n        {\n            throw new IllegalArgumentException();\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java", "class_name": "ByteFifoBuffer", "class_uri": "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java.ByteFifoBuffer", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nChecks if new write position is correct\n\n@param newWrPos new write position\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java.ByteFifoBuffer.[void]consumeWriteBuffer(int)", "name": "consumeWriteBuffer", "arg_nums": 1, "params": [{"name": "count", "type": "int"}], "return_type": "void", "signature": "public void consumeWriteBuffer(int count)", "original_string": "    public void consumeWriteBuffer(int count)\n        throws IllegalArgumentException,\n               BufferOverflowException\n    {\n        if (count > getWriteRemaining())\n        {\n            throw new BufferOverflowException();\n        }\n        if (count < 0)\n        {\n            throw new IllegalArgumentException();\n        }\n        int newPos = (write_pos + count) % array.length;\n        assertWriteLimit(newPos);\n        \n        write_pos = newPos;\n        buffered += count;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java", "class_name": "ByteFifoBuffer", "class_uri": "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java.ByteFifoBuffer", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nAdvances current buffer's write position by <tt>count</tt> bytes\n\n@param count number of bytes to move forward\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java.ByteFifoBuffer.[boolean]setCapacity(int)", "name": "setCapacity", "arg_nums": 1, "params": [{"name": "new_size", "type": "int"}], "return_type": "boolean", "signature": "public boolean setCapacity(int new_size)", "original_string": "    public boolean setCapacity(int new_size)\n    {\n        if (new_size < getBuffered())\n        {\n            return false;\n        }\n        byte[] newBuff = new byte[new_size];\n        readOp(newBuff, 0, buffered, array, read_pos, array.length);\n        this.array = newBuff;\n        return true;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java", "class_name": "ByteFifoBuffer", "class_uri": "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java.ByteFifoBuffer", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nSets new buffer's capacity\n\n@param new_size number of bytes\n@return <tt>true</tt> if operation is possible to perform, that is if new\nbuffered data fits into new buffer\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java.ByteFifoBuffer.[void]consumeReadData(int)", "name": "consumeReadData", "arg_nums": 1, "params": [{"name": "count", "type": "int"}], "return_type": "void", "signature": "public void consumeReadData(int count)", "original_string": "    public void consumeReadData(int count)\n        throws IllegalArgumentException,\n               BufferUnderflowException\n    {\n        /*\n         * System.out.println(\"Consume read \" + this + \" \" + count + \" read pos:\n         * \" + read_pos);\n         */\n        if (count > buffered)\n        {\n            throw new BufferUnderflowException();\n        }\n        if (count < 0)\n        {\n            throw new IllegalArgumentException();\n        }\n        this.read_pos = (read_pos + count) % array.length;\n        buffered -= count;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java", "class_name": "ByteFifoBuffer", "class_uri": "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java.ByteFifoBuffer", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nAligns current read position by <tt>count</tt>\n\n@param count number of bytes to move the read position\n@throws BufferUnderflowException if new position exceeds buffered data\ncount\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java.ByteFifoBuffer.[int]readOffset(byte[],int,int,int)", "name": "readOffset", "arg_nums": 4, "params": [{"name": "dst_buff", "type": "byte[]"}, {"name": "dst_buff_offset", "type": "int"}, {"name": "count", "type": "int"}, {"name": "offset", "type": "int"}], "return_type": "int", "signature": "public int readOffset(byte[] dst_buff,\n                          int dst_buff_offset,\n                          int count,\n                          int offset)", "original_string": "    public int readOffset(byte[] dst_buff,\n                          int dst_buff_offset,\n                          int count,\n                          int offset)\n    {\n        //TODO: not sure if should decrease read count or throw an exception\n        /*\n         * System.out.println(\"Read dst offset \" + dst_buff_offset + \" offset \"\n         * + offset + \" len \" + count + \" \" + this);\n         */\n        int read_offset = (this.read_pos + offset) % array.length;\n        readOp(dst_buff, dst_buff_offset, count, array, read_offset, array.length);\n\n        return count;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java", "class_name": "ByteFifoBuffer", "class_uri": "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java.ByteFifoBuffer", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\nReads <tt>count</tt> bytes from buffer without storing new read position\n\n@param dst_buff buffer to write the read data to\n@param dst_buff_offset offset of destination buffer\n@param count bytes to read\n@param offset from current read position\n@return bytes successfully read\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java.ByteFifoBuffer.[int]writeOffset(byte[],int,int)", "name": "writeOffset", "arg_nums": 3, "params": [{"name": "data", "type": "byte[]"}, {"name": "count", "type": "int"}, {"name": "nOffset", "type": "int"}], "return_type": "int", "signature": "public int writeOffset(byte[] data, int count, int nOffset)", "original_string": "    public int writeOffset(byte[] data, int count, int nOffset)\n        throws BufferOverflowException\n    {\n        if (count > getWriteRemaining())\n        {\n            throw new BufferOverflowException();\n        }\n        if (count < 0)\n        {\n            throw new IllegalArgumentException();\n        }\n        int offWritePos = (this.write_pos + nOffset) % array.length;\n        count = writeLimit(count);\n        assertWriteLimit(offWritePos + count);\n        writeOp(data, 0, count, array, offWritePos, array.length);\n        \n        return count;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java", "class_name": "ByteFifoBuffer", "class_uri": "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java.ByteFifoBuffer", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\nWrites <tt>count</tt> bytes from <tt>data</tt> to the buffer without\naffecting buffer's write position\n\n@param data the data to write to the buffer\n@param count number of bytes to read from data\n@param nOffset from buffer's write position\n@return bytes successfully written\n"}, {"uris": "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java.ByteFifoBuffer.[void]resetReadPosition()", "name": "resetReadPosition", "arg_nums": 0, "params": [], "return_type": "void", "signature": "public void resetReadPosition()", "original_string": "    public void resetReadPosition()\n    {\n        this.read_pos = 0;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java", "class_name": "ByteFifoBuffer", "class_uri": "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java.ByteFifoBuffer", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java.ByteFifoBuffer.[void]resetWritePosition()", "name": "resetWritePosition", "arg_nums": 0, "params": [], "return_type": "void", "signature": "public void resetWritePosition()", "original_string": "    public void resetWritePosition()\n    {\n        this.write_pos = 0;\n        this.buffered = 0;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java", "class_name": "ByteFifoBuffer", "class_uri": "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java.ByteFifoBuffer", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/org/ice4j/ice/NetworkUtils.java.NetworkUtils.[boolean]isValidPortNumber(int)", "name": "isValidPortNumber", "arg_nums": 1, "params": [{"name": "port", "type": "int"}], "return_type": "boolean", "signature": "public static boolean isValidPortNumber(int port)", "original_string": "    public static boolean isValidPortNumber(int port)\n    {\n        return MIN_PORT_NUMBER <= port && port <= MAX_PORT_NUMBER;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/NetworkUtils.java", "class_name": "NetworkUtils", "class_uri": "src/main/java/org/ice4j/ice/NetworkUtils.java.NetworkUtils", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nDetermines whether <tt>port</tt> is a valid port number bindable by an\napplication (i.e. an integer between 1024 and 65535).\n\n@param port the port number that we'd like verified.\n\n@return <tt>true</tt> if port is a valid and bindable port number and\n<tt>false</tt> otherwise.\n"}, {"uris": "src/main/java/org/ice4j/ice/NetworkUtils.java.NetworkUtils.[String]stripScopeID(String)", "name": "stripScopeID", "arg_nums": 1, "params": [{"name": "ipv6Address", "type": "String"}], "return_type": "String", "signature": "public static String stripScopeID(String ipv6Address)", "original_string": "    public static String stripScopeID(String ipv6Address)\n    {\n        int scopeStart = ipv6Address.indexOf('%');\n\n        if (scopeStart == -1)\n            return ipv6Address;\n\n        ipv6Address = ipv6Address.substring(0, scopeStart);\n\n        //in case this was an IPv6 literal and we remove the closing bracket,\n        //put it back in now.\n        if (ipv6Address.charAt(0) == '['\n            && ipv6Address.charAt(ipv6Address.length()-1) != ']')\n        {\n            ipv6Address += ']';\n        }\n\n        return ipv6Address;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/NetworkUtils.java", "class_name": "NetworkUtils", "class_uri": "src/main/java/org/ice4j/ice/NetworkUtils.java.NetworkUtils", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns a <tt>String</tt> that is guaranteed not to contain an address\nscope specified (i.e. removes the %scopeID at the end of IPv6 addresses\nreturned by Java. Takes into account the presence or absence of square\nbrackets encompassing the address.\n\n@param ipv6Address the address whose scope ID we'd like to get rid of.\n\n@return the newly form address containing no scope ID.\n"}, {"uris": "src/main/java/org/ice4j/ice/TcpHostCandidate.java.TcpHostCandidate.[]TcpHostCandidate(TransportAddress,Component)", "name": "TcpHostCandidate", "arg_nums": 2, "params": [{"name": "transportAddress", "type": "TransportAddress"}, {"name": "parentComponent", "type": "Component"}], "return_type": "", "signature": "public TcpHostCandidate(TransportAddress transportAddress,\n                            Component parentComponent)", "original_string": "    public TcpHostCandidate(TransportAddress transportAddress,\n                            Component parentComponent)\n    {\n        super(transportAddress, parentComponent);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/TcpHostCandidate.java", "class_name": "TcpHostCandidate", "class_uri": "src/main/java/org/ice4j/ice/TcpHostCandidate.java.TcpHostCandidate", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>TcpHostCandidate</tt>.\n\n@param transportAddress the transport address of this\n<tt>TcpHostCandidate</tt>.\n@param parentComponent the <tt>Component</tt> that this candidate\nbelongs to.\n"}, {"uris": "src/main/java/org/ice4j/ice/TcpHostCandidate.java.TcpHostCandidate.[IceSocketWrapper]getCandidateIceSocketWrapper(SocketAddress)", "name": "getCandidateIceSocketWrapper", "arg_nums": 1, "params": [{"name": "remoteAddress", "type": "SocketAddress"}], "return_type": "IceSocketWrapper", "signature": "@Override\n    protected IceSocketWrapper getCandidateIceSocketWrapper(\n            SocketAddress remoteAddress)", "original_string": "    @Override\n    protected IceSocketWrapper getCandidateIceSocketWrapper(\n            SocketAddress remoteAddress)\n    {\n        for (IceSocketWrapper socket : sockets)\n        {\n            if (socket.getTCPSocket().getRemoteSocketAddress()\n                .equals(remoteAddress))\n                return socket;\n        }\n\n        return null;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/TcpHostCandidate.java", "class_name": "TcpHostCandidate", "class_uri": "src/main/java/org/ice4j/ice/TcpHostCandidate.java.TcpHostCandidate", "attributes": {"modifiers": "@Override\n    protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "IceSocketWrapper", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/ice/TcpHostCandidate.java.TcpHostCandidate.[void]addSocket(IceSocketWrapper)", "name": "addSocket", "arg_nums": 1, "params": [{"name": "socket", "type": "IceSocketWrapper"}], "return_type": "void", "signature": "public void addSocket(IceSocketWrapper socket)", "original_string": "    public void addSocket(IceSocketWrapper socket)\n    {\n        sockets.add(socket);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/TcpHostCandidate.java", "class_name": "TcpHostCandidate", "class_uri": "src/main/java/org/ice4j/ice/TcpHostCandidate.java.TcpHostCandidate", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/org/ice4j/ice/TcpHostCandidate.java.TcpHostCandidate.[void]free()", "name": "free", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Override\n    protected void free()", "original_string": "    @Override\n    protected void free()\n    {\n        StunStack stunStack = getStunStack();\n        TransportAddress localAddr = getTransportAddress();\n\n        for (IceSocketWrapper socket : sockets)\n        {\n            //remove our sockets from the stack.\n            Socket tcpSocket = socket.getTCPSocket();\n\n            stunStack.removeSocket(\n                    localAddr,\n                    new TransportAddress(\n                            tcpSocket.getInetAddress(),\n                            tcpSocket.getPort(),\n                            Transport.TCP));\n\n            socket.close();\n        }\n\n        super.free();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/TcpHostCandidate.java", "class_name": "TcpHostCandidate", "class_uri": "src/main/java/org/ice4j/ice/TcpHostCandidate.java.TcpHostCandidate", "attributes": {"modifiers": "@Override\n    protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": ""}, {"uris": "src/main/java/org/ice4j/ice/ComponentSocket.java.ComponentSocket.[]ComponentSocket(Component,org.jitsi.utils.logging2.Logger)", "name": "ComponentSocket", "arg_nums": 2, "params": [{"name": "component", "type": "Component"}, {"name": "parentLogger", "type": "org.jitsi.utils.logging2.Logger"}], "return_type": "", "signature": "ComponentSocket(Component component, org.jitsi.utils.logging2.Logger parentLogger)", "original_string": "    ComponentSocket(Component component, org.jitsi.utils.logging2.Logger parentLogger)\n        throws SocketException\n    {\n        super(parentLogger);\n\n        this.component = component;\n        component.getParentStream().addPairChangeListener(this);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/ComponentSocket.java", "class_name": "ComponentSocket", "class_uri": "src/main/java/org/ice4j/ice/ComponentSocket.java.ComponentSocket", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new {@link MergingDatagramSocket} instance.\n@throws SocketException\n"}, {"uris": "src/main/java/org/ice4j/ice/ComponentSocket.java.ComponentSocket.[boolean]accept(DatagramPacket)", "name": "accept", "arg_nums": 1, "params": [{"name": "p", "type": "DatagramPacket"}], "return_type": "boolean", "signature": "protected boolean accept(DatagramPacket p)", "original_string": "    protected boolean accept(DatagramPacket p)\n    {\n        return authorizedAddresses.contains(p.getSocketAddress());\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/ComponentSocket.java", "class_name": "ComponentSocket", "class_uri": "src/main/java/org/ice4j/ice/ComponentSocket.java.ComponentSocket", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\n{@inheritDoc}\n</p>\nVerifies that the source of the packet is an authorized remote address.\n"}, {"uris": "src/main/java/org/ice4j/ice/ComponentSocket.java.ComponentSocket.[void]addAuthorizedAddress(SocketAddress)", "name": "addAuthorizedAddress", "arg_nums": 1, "params": [{"name": "address", "type": "SocketAddress"}], "return_type": "void", "signature": "private void addAuthorizedAddress(SocketAddress address)", "original_string": "    private void addAuthorizedAddress(SocketAddress address)\n    {\n        synchronized (authorizedAddressesSyncRoot)\n        {\n            if (authorizedAddresses.contains(address))\n            {\n                return;\n            }\n\n            logger.info(\"Adding allowed address: \" + TransportAddress.redact(address));\n\n            Set<SocketAddress> newSet = new HashSet<>();\n            newSet.addAll(authorizedAddresses);\n            newSet.add(address);\n\n            authorizedAddresses = newSet;\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/ComponentSocket.java", "class_name": "ComponentSocket", "class_uri": "src/main/java/org/ice4j/ice/ComponentSocket.java.ComponentSocket", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nAdds a specific address to the list of authorized remote addresses.\n@param address the address to add.\n"}, {"uris": "src/main/java/org/ice4j/ice/ComponentSocket.java.ComponentSocket.[void]propertyChange(PropertyChangeEvent)", "name": "propertyChange", "arg_nums": 1, "params": [{"name": "event", "type": "PropertyChangeEvent"}], "return_type": "void", "signature": "@Override\n    public void propertyChange(PropertyChangeEvent event)", "original_string": "    @Override\n    public void propertyChange(PropertyChangeEvent event)\n    {\n        if (!(event.getSource() instanceof CandidatePair))\n        {\n            return;\n        }\n\n        CandidatePair pair = (CandidatePair) event.getSource();\n        if (!pair.getParentComponent().equals(component))\n        {\n            // Events are fired by the IceMediaStream, which might have\n            // multiple components. Make sure that we only handle events for\n            // our own component.\n            return;\n        }\n\n        String propertyName = event.getPropertyName();\n        if (IceMediaStream.PROPERTY_PAIR_STATE_CHANGED.equals(propertyName))\n        {\n            CandidatePairState newState\n                = (CandidatePairState) event.getNewValue();\n\n            if (CandidatePairState.SUCCEEDED.equals(newState))\n            {\n                addAuthorizedAddress(\n                        pair.getRemoteCandidate().getTransportAddress());\n            }\n        }\n        else if (IceMediaStream.PROPERTY_PAIR_NOMINATED.equals(propertyName))\n        {\n            synchronized (initializedActiveSyncRoot)\n            {\n                if (initializedActive)\n                {\n                    return;\n                }\n\n                // Find the remote address and the correct socket to be used by\n                // the pair.\n                LocalCandidate localCandidate = pair.getLocalCandidate();\n                LocalCandidate base = localCandidate.getBase();\n                if (base != null)\n                {\n                    localCandidate = base;\n                }\n\n                TransportAddress remoteAddress = null;\n                RemoteCandidate remoteCandidate = pair.getRemoteCandidate();\n                if (remoteCandidate != null)\n                {\n                    remoteAddress = remoteCandidate.getTransportAddress();\n                }\n\n                // The local candidate may have more than one associated socket.\n                // Make sure we get the one for the remote address that we are\n                // going to use.\n                IceSocketWrapper socketWrapper\n                    = localCandidate\n                    .getCandidateIceSocketWrapper(remoteAddress);\n\n                initializeActive(socketWrapper, remoteAddress);\n                initializedActive = true;\n            }\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/ComponentSocket.java", "class_name": "ComponentSocket", "class_uri": "src/main/java/org/ice4j/ice/ComponentSocket.java.ComponentSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\n{@inheritDoc}\n</p>\nHandles property change events coming from ICE pairs.\n@param event\n"}, {"uris": "src/main/java/org/ice4j/ice/ComponentSocket.java.ComponentSocket.[void]close()", "name": "close", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Override\n    public void close()", "original_string": "    @Override\n    public void close()\n    {\n        try\n        {\n            super.close();\n        }\n        finally\n        {\n            Component component = this.component;\n            if (component != null)\n            {\n                component.getParentStream().removePairStateChangeListener(this);\n                this.component = null;\n            }\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/ComponentSocket.java", "class_name": "ComponentSocket", "class_uri": "src/main/java/org/ice4j/ice/ComponentSocket.java.ComponentSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[IceMediaStream]build(Agent,String)", "name": "build", "arg_nums": 2, "params": [{"name": "parentAgent", "type": "Agent"}, {"name": "name", "type": "String"}], "return_type": "IceMediaStream", "signature": "public static IceMediaStream build(Agent parentAgent, String name)", "original_string": "    public static IceMediaStream build(Agent parentAgent, String name)\n    {\n        return new IceMediaStream(parentAgent, name);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/IceMediaStream.java", "class_name": "IceMediaStream", "class_uri": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "IceMediaStream", "classes": []}, "docstring": "\nUse builder pattern to provide an immutable IceMediaStream instance.\n\n@param name the name of the media stream\n@param parentAgent the agent that is handling the session that this\nmedia stream is a part of\n@return IceMediaStream\n"}, {"uris": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[]IceMediaStream(Agent,String)", "name": "IceMediaStream", "arg_nums": 2, "params": [{"name": "parentAgent", "type": "Agent"}, {"name": "name", "type": "String"}], "return_type": "", "signature": "protected IceMediaStream(Agent parentAgent, String name)", "original_string": "    protected IceMediaStream(Agent parentAgent, String name)\n    {\n        logger = parentAgent.getLogger().createChildLogger(\n                IceMediaStream.class.getName(),\n                Collections.singletonMap(\"name\", name));\n        this.name = name;\n        this.parentAgent = parentAgent;\n        checkList = new CheckList(this);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/IceMediaStream.java", "class_name": "IceMediaStream", "class_uri": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>IceMediaStream</tt> object.\n\n@param name the name of the media stream\n@param parentAgent the agent that is handling the session that this\nmedia stream is a part of\n"}, {"uris": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[Component]createComponent(KeepAliveStrategy,boolean)", "name": "createComponent", "arg_nums": 2, "params": [{"name": "keepAliveStrategy", "type": "KeepAliveStrategy"}, {"name": "useComponentSocket", "type": "boolean"}], "return_type": "Component", "signature": "protected Component createComponent(\n            KeepAliveStrategy keepAliveStrategy,\n            boolean useComponentSocket)", "original_string": "    protected Component createComponent(\n            KeepAliveStrategy keepAliveStrategy,\n            boolean useComponentSocket)\n    {\n        Component component;\n\n        synchronized (components)\n        {\n            component\n                = new Component(\n                    ++lastComponentID,\n                    this,\n                    keepAliveStrategy,\n                    useComponentSocket,\n                    logger);\n            components.put(component.getComponentID(), component);\n        }\n\n        return component;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/IceMediaStream.java", "class_name": "IceMediaStream", "class_uri": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Component", "classes": []}, "docstring": "\nCreates and adds a component to this media-stream\nThe component ID is incremented to the next integer value\nwhen creating the component so make sure you keep that in mind in case\nassigning a specific component ID is important to you.\n\n@param keepAliveStrategy the keep-alive strategy, which dictates which\ncandidates pairs are going to be kept alive.\n@param useComponentSocket whether the \"component socket\" should be used\nor not. See {@link AgentConfig#getUseComponentSocket()}.\n\n@return the newly created stream <tt>Component</tt> after adding it to\nthe stream first.\n"}, {"uris": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[String]getName()", "name": "getName", "arg_nums": 0, "params": [], "return_type": "String", "signature": "public String getName()", "original_string": "    public String getName()\n    {\n        return name;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/IceMediaStream.java", "class_name": "IceMediaStream", "class_uri": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns the name of this <tt>IceMediaStream</tt>.\n\n@return the name of this <tt>IceMediaStream</tt>.\n"}, {"uris": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[String]toString()", "name": "toString", "arg_nums": 0, "params": [], "return_type": "String", "signature": "@Override\n    public String toString()", "original_string": "    @Override\n    public String toString()\n    {\n        StringBuilder buff\n            = new StringBuilder( \"media stream:\")\n                .append(getName());\n\n        buff.append(\" (component count=\")\n            .append(getComponentCount())\n            .append(\")\");\n\n        for (Component cmp : getComponents())\n            buff.append(\"\\n\").append(cmp);\n\n        return buff.toString();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/IceMediaStream.java", "class_name": "IceMediaStream", "class_uri": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns a <tt>String</tt> representation of this media stream.\n\n@return a <tt>String</tt> representation of this media stream.\n"}, {"uris": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[Component]getComponent(int)", "name": "getComponent", "arg_nums": 1, "params": [{"name": "id", "type": "int"}], "return_type": "Component", "signature": "public Component getComponent(int id)", "original_string": "    public Component getComponent(int id)\n    {\n        synchronized(components)\n        {\n            return components.get(id);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/IceMediaStream.java", "class_name": "IceMediaStream", "class_uri": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Component", "classes": []}, "docstring": "\nReturns the <tt>Component</tt> with the specified <tt>id</tt> or\n<tt>null</tt> if no such component exists in this stream.\n\n@param id the identifier of the component we are looking for.\n\n@return  the <tt>Component</tt> with the specified <tt>id</tt> or\n<tt>null</tt> if no such component exists in this stream.\n"}, {"uris": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[List<Component>]getComponents()", "name": "getComponents", "arg_nums": 0, "params": [], "return_type": "List<Component>", "signature": "public List<Component> getComponents()", "original_string": "    public List<Component> getComponents()\n    {\n        synchronized(components)\n        {\n            return new ArrayList<>(components.values());\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/IceMediaStream.java", "class_name": "IceMediaStream", "class_uri": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<Component>", "classes": []}, "docstring": "\nReturns the list of <tt>Component</tt>s currently registered with this\nstream.\n\n@return a non-null list of <tt>Component</tt>s currently registered with\nthis stream.\n"}, {"uris": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[int]getComponentCount()", "name": "getComponentCount", "arg_nums": 0, "params": [], "return_type": "int", "signature": "public int getComponentCount()", "original_string": "    public int getComponentCount()\n    {\n        synchronized(components)\n        {\n            return components.size();\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/IceMediaStream.java", "class_name": "IceMediaStream", "class_uri": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\nReturns the number of <tt>Component</tt>s currently registered with this\nstream.\n\n@return the number of <tt>Component</tt>s currently registered with this\nstream.\n"}, {"uris": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[List<Integer>]getComponentIDs()", "name": "getComponentIDs", "arg_nums": 0, "params": [], "return_type": "List<Integer>", "signature": "public List<Integer> getComponentIDs()", "original_string": "    public List<Integer> getComponentIDs()\n    {\n        synchronized(components)\n        {\n            return new ArrayList<>(components.keySet());\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/IceMediaStream.java", "class_name": "IceMediaStream", "class_uri": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<Integer>", "classes": []}, "docstring": "\nReturns the IDs of all <tt>Component</tt>s currently registered with this\nstream.\n\n@return a non-null list of IDs corresponding to the <tt>Component</tt>s\ncurrently registered with this stream.\n"}, {"uris": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[Agent]getParentAgent()", "name": "getParentAgent", "arg_nums": 0, "params": [], "return_type": "Agent", "signature": "public Agent getParentAgent()", "original_string": "    public Agent getParentAgent()\n    {\n        return parentAgent;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/IceMediaStream.java", "class_name": "IceMediaStream", "class_uri": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Agent", "classes": []}, "docstring": "\nReturns a reference to the <tt>Agent</tt> that this stream belongs to.\n\n@return a reference to the <tt>Agent</tt> that this stream belongs to.\n"}, {"uris": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[void]free()", "name": "free", "arg_nums": 0, "params": [], "return_type": "void", "signature": "protected void free()", "original_string": "    protected void free()\n    {\n        List<Component> components;\n\n        synchronized (this.components)\n        {\n            components = getComponents();\n            this.components.clear();\n        }\n        /*\n         * Free the components outside the synchronized block because a deadlock\n         * has been reported (by Carl Hasselskog). The execution flow is not the\n         * same as when freeing the components inside the synchronized block\n         * because in the latter case an exception thrown by Component#free()\n         * will leave subsequent components in IceMediaStream#componenets. But\n         * there is no indication that such behaviour is expected.\n         */\n        for (Component component : components)\n            component.free();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/IceMediaStream.java", "class_name": "IceMediaStream", "class_uri": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nRemoves this stream and all <tt>Candidate</tt>s associated with its child\n<tt>Component</tt>s.\n"}, {"uris": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[void]removeComponent(Component)", "name": "removeComponent", "arg_nums": 1, "params": [{"name": "component", "type": "Component"}], "return_type": "void", "signature": "public void removeComponent(Component component)", "original_string": "    public void removeComponent(Component component)\n    {\n        synchronized (components)\n        {\n            components.remove(component.getComponentID());\n        }\n        /*\n         * There is no known reason why the component should be freed with\n         * synchronization by components. However, the freeing outside the\n         * synchronization block will surely decrease the chances of a deadlock.\n         * Besides, Component#free() has really been reported involved in a\n         * deadlock.\n         */\n        component.free();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/IceMediaStream.java", "class_name": "IceMediaStream", "class_uri": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nRemoves <tt>component</tt> and all its <tt>Candidate</tt>s from the\nthis stream and releases all associated resources that they had\nallocated (like sockets for example)\n\n@param component the <tt>Component</tt> we'd like to remove and free.\n"}, {"uris": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[void]initCheckList()", "name": "initCheckList", "arg_nums": 0, "params": [], "return_type": "void", "signature": "protected void initCheckList()", "original_string": "    protected void initCheckList()\n    {\n        //first init the check list.\n        synchronized(checkList)\n        {\n            checkList.clear();\n            createCheckList(checkList);\n\n            orderCheckList();\n            pruneCheckList(checkList);\n            logger.trace(() -> \"Checklist initialized.\");\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/IceMediaStream.java", "class_name": "IceMediaStream", "class_uri": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCreates, initializes and orders the list of candidate pairs that would\nbe used for the connectivity checks for all components in this stream.\n"}, {"uris": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[void]createCheckList(List<CandidatePair>)", "name": "createCheckList", "arg_nums": 1, "params": [{"name": "checkList", "type": "List<CandidatePair>"}], "return_type": "void", "signature": "protected void createCheckList(List<CandidatePair> checkList)", "original_string": "    protected void createCheckList(List<CandidatePair> checkList)\n    {\n        for (Component cmp : getComponents())\n            createCheckList(cmp, checkList);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/IceMediaStream.java", "class_name": "IceMediaStream", "class_uri": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCreates and adds to <tt>checkList</tt> all the <tt>CandidatePair</tt>s\nin all <tt>Component</tt>s of this stream.\n\n@param checkList the list that we need to update with the new pairs.\n"}, {"uris": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[void]createCheckList(Component,List<CandidatePair>)", "name": "createCheckList", "arg_nums": 2, "params": [{"name": "component", "type": "Component"}, {"name": "checkList", "type": "List<CandidatePair>"}], "return_type": "void", "signature": "private void createCheckList(final Component           component,\n                                 final List<CandidatePair> checkList)", "original_string": "    private void createCheckList(final Component           component,\n                                 final List<CandidatePair> checkList)\n    {\n        List<LocalCandidate> localCnds = component.getLocalCandidates();\n        List<RemoteCandidate> remoteCnds = component.getRemoteCandidates();\n        LocalCandidate upnpBase = null;\n\n        for (LocalCandidate lc : localCnds)\n        {\n            // XXX do we assume a single UPNPCandidate here?\n            if (lc instanceof UPNPCandidate)\n                upnpBase = lc.getBase();\n        }\n\n        for (LocalCandidate localCnd : localCnds)\n        {\n            // Don't take into consideration UPnP base candidate\n            if (localCnd == upnpBase)\n                continue;\n\n            for (RemoteCandidate remoteCnd : remoteCnds)\n            {\n                if (localCnd.canReach(remoteCnd)\n                        && remoteCnd.getTransportAddress().getPort() != 0)\n                {\n                    CandidatePair pair\n                        = getParentAgent()\n                            .createCandidatePair(localCnd, remoteCnd);\n                    checkList.add(pair);\n                }\n            }\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/IceMediaStream.java", "class_name": "IceMediaStream", "class_uri": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCreates and adds to <tt>checkList</tt> all the <tt>CandidatePair</tt>s\nin <tt>component</tt>.\n\n@param component the <tt>Component</tt> whose candidates we need to\npair and extract.\n@param checkList the list that we need to update with the new pairs.\n"}, {"uris": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[void]orderCheckList()", "name": "orderCheckList", "arg_nums": 0, "params": [], "return_type": "void", "signature": "private void orderCheckList()", "original_string": "    private void orderCheckList()\n    {\n        Collections.sort(checkList, CandidatePair.comparator);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/IceMediaStream.java", "class_name": "IceMediaStream", "class_uri": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nOrders this stream's pair check list in decreasing order of pair\npriority. If two pairs have identical priority, the ordering amongst\nthem is arbitrary.\n"}, {"uris": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[void]pruneCheckList(List<CandidatePair>)", "name": "pruneCheckList", "arg_nums": 1, "params": [{"name": "checkList", "type": "List<CandidatePair>"}], "return_type": "void", "signature": "protected void pruneCheckList(List<CandidatePair> checkList)", "original_string": "    protected void pruneCheckList(List<CandidatePair> checkList)\n    {\n        //a list that we only use for storing pairs that we've already gone\n        //through. The list is destroyed at the end of this method.\n        List<CandidatePair> tmpCheckList = new ArrayList<>(checkList.size());\n\n        Iterator<CandidatePair> ckListIter = checkList.iterator();\n\n        while (ckListIter.hasNext())\n        {\n            CandidatePair pair = ckListIter.next();\n\n            //drop all pairs above MAX_CHECK_LIST_SIZE.\n            if (tmpCheckList.size() > maxCheckListSize)\n            {\n                ckListIter.remove();\n                continue;\n            }\n\n            //replace local server reflexive candidates with their base.\n            LocalCandidate localCnd = pair.getLocalCandidate();\n            if ( localCnd.getType()\n                        == CandidateType.SERVER_REFLEXIVE_CANDIDATE)\n            {\n                pair.setLocalCandidate(localCnd.getBase());\n\n                //if the new pair corresponds to another one with a higher\n                //priority, then remove it.\n                if (tmpCheckList.contains(pair))\n                {\n                    ckListIter.remove();\n                    continue;\n                }\n            }\n\n            tmpCheckList.add(pair);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/IceMediaStream.java", "class_name": "IceMediaStream", "class_uri": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\n Removes or, as per the ICE spec, \"prunes\" pairs that we don't need to\n run checks for. For example, since we cannot send requests directly\n from a reflexive candidate, but only from its base, we go through the\n sorted list of candidate pairs and in every pair where the local\n candidate is server reflexive, we replace the local server reflexive\n candidate with its base. Once this has been done, we remove each pair\n where the local and remote candidates are identical to the local and\n remote candidates of a pair higher up on the priority list.\n <br>\n In addition, in order to limit the attacks described in Section 18.5.2\n of the ICE spec, we limit the total number of pairs and hence\n (connectivity checks) to a specific value, (a total of 100 by default).\n\n@param checkList the checklist to prune\n"}, {"uris": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[CheckList]getCheckList()", "name": "getCheckList", "arg_nums": 0, "params": [], "return_type": "CheckList", "signature": "public CheckList getCheckList()", "original_string": "    public CheckList getCheckList()\n    {\n        return checkList;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/IceMediaStream.java", "class_name": "IceMediaStream", "class_uri": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "CheckList", "classes": []}, "docstring": "\nReturns the list of <tt>CandidatePair</tt>s to be used in checks for\nthis stream.\n\n@return the list of <tt>CandidatePair</tt>s to be used in checks for\nthis stream.\n"}, {"uris": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[void]setMaxCheckListSize(int)", "name": "setMaxCheckListSize", "arg_nums": 1, "params": [{"name": "nSize", "type": "int"}], "return_type": "void", "signature": "protected void setMaxCheckListSize(int nSize)", "original_string": "    protected void setMaxCheckListSize(int nSize)\n    {\n        this.maxCheckListSize = nSize;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/IceMediaStream.java", "class_name": "IceMediaStream", "class_uri": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets the maximum number of pairs that we should have in our check list.\n\n@param nSize the size of our check list.\n"}, {"uris": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[LocalCandidate]findLocalCandidate(TransportAddress,LocalCandidate)", "name": "findLocalCandidate", "arg_nums": 2, "params": [{"name": "address", "type": "TransportAddress"}, {"name": "base", "type": "LocalCandidate"}], "return_type": "LocalCandidate", "signature": "public LocalCandidate findLocalCandidate(TransportAddress address, LocalCandidate base)", "original_string": "    public LocalCandidate findLocalCandidate(TransportAddress address, LocalCandidate base)\n    {\n        for (Component component : components.values())\n        {\n            LocalCandidate localCandidate\n                    = component.findLocalCandidate(address, base);\n\n            if (localCandidate != null)\n            {\n                return localCandidate;\n            }\n        }\n\n        return null;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/IceMediaStream.java", "class_name": "IceMediaStream", "class_uri": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "LocalCandidate", "classes": []}, "docstring": "\nReturns the local <tt>LocalCandidate</tt> with the specified\n<tt>address</tt> if it belongs to any of this stream's components\nor <tt>null</tt> otherwise. If {@code base} is also specified, tries to\nfind a candidate whose base matches {@code base}.\n\n@param address the {@link TransportAddress} we are looking for.\n@param base an optional base to match.\n\n@return  the local <tt>LocalCandidate</tt> with the specified\n<tt>address</tt> if it belongs to any of this stream's components\nor <tt>null</tt> otherwise.\n"}, {"uris": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[RemoteCandidate]findRemoteCandidate(TransportAddress)", "name": "findRemoteCandidate", "arg_nums": 1, "params": [{"name": "remoteAddress", "type": "TransportAddress"}], "return_type": "RemoteCandidate", "signature": "public RemoteCandidate findRemoteCandidate(TransportAddress remoteAddress)", "original_string": "    public RemoteCandidate findRemoteCandidate(TransportAddress remoteAddress)\n    {\n        for ( Component cmp : components.values())\n        {\n            RemoteCandidate cnd = cmp.findRemoteCandidate(remoteAddress);\n\n            if (cnd != null)\n                return cnd;\n        }\n\n        return null;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/IceMediaStream.java", "class_name": "IceMediaStream", "class_uri": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "RemoteCandidate", "classes": []}, "docstring": "\nReturns the local <tt>Candidate</tt> with the specified\n<tt>remoteAddress</tt> if it belongs to any of this stream's {@link\nComponent}s or <tt>null</tt> if it doesn't.\n\n@param remoteAddress the {@link TransportAddress} we are looking for.\n\n@return the local <tt>Candidate</tt> with the specified\n<tt>remoteAddress</tt> if it belongs to any of this stream's {@link\nComponent}s or <tt>null</tt> if it doesn't.\n\n"}, {"uris": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[CandidatePair]findCandidatePair(TransportAddress,TransportAddress)", "name": "findCandidatePair", "arg_nums": 2, "params": [{"name": "localAddress", "type": "TransportAddress"}, {"name": "remoteAddress", "type": "TransportAddress"}], "return_type": "CandidatePair", "signature": "public CandidatePair findCandidatePair(TransportAddress localAddress,\n                                           TransportAddress remoteAddress)", "original_string": "    public CandidatePair findCandidatePair(TransportAddress localAddress,\n                                           TransportAddress remoteAddress)\n    {\n        synchronized(checkList)\n        {\n            for (CandidatePair pair : checkList)\n            {\n                if (pair.getLocalCandidate().getTransportAddress()\n                            .equals(localAddress)\n                        && pair.getRemoteCandidate().getTransportAddress()\n                                .equals(remoteAddress))\n                {\n                    return pair;\n                }\n            }\n        }\n        return null;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/IceMediaStream.java", "class_name": "IceMediaStream", "class_uri": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "CandidatePair", "classes": []}, "docstring": "\nReturns the {@link CandidatePair} with the specified remote and local\naddresses or <tt>null</tt> if neither of the {@link CheckList}s in this\nstream contain such a pair.\n\n@param localAddress the local {@link TransportAddress} of the pair we\nare looking for.\n@param remoteAddress the remote {@link TransportAddress} of the pair we\nare looking for.\n\n@return the {@link CandidatePair} with the specified remote and local\naddresses or <tt>null</tt> if neither of the {@link CheckList}s in this\nstream contain such a pair.\n"}, {"uris": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[CandidatePair]findCandidatePair(String,String)", "name": "findCandidatePair", "arg_nums": 2, "params": [{"name": "localUFrag", "type": "String"}, {"name": "remoteUFrag", "type": "String"}], "return_type": "CandidatePair", "signature": "public CandidatePair findCandidatePair(String localUFrag,\n                                           String remoteUFrag)", "original_string": "    public CandidatePair findCandidatePair(String localUFrag,\n                                           String remoteUFrag)\n    {\n        synchronized(checkList)\n        {\n            for (CandidatePair pair : checkList)\n            {\n                LocalCandidate local = pair.getLocalCandidate();\n                RemoteCandidate remote = pair.getRemoteCandidate();\n\n                if (local.getUfrag().equals(remoteUFrag)\n                        && remote.getUfrag().equals(localUFrag))\n                {\n                    return pair;\n                }\n            }\n        }\n        return null;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/IceMediaStream.java", "class_name": "IceMediaStream", "class_uri": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "CandidatePair", "classes": []}, "docstring": "\nReturns the {@link CandidatePair} with the specified remote and local\naddresses or <tt>null</tt> if neither of the {@link CheckList}s in this\nstream contain such a pair.\n\n@param localUFrag local user fragment\n@param remoteUFrag remote user fragment\n@return the {@link CandidatePair} with the specified remote and local\naddresses or <tt>null</tt> if neither of the {@link CheckList}s in this\nstream contain such a pair.\n"}, {"uris": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[int]countHostCandidates()", "name": "countHostCandidates", "arg_nums": 0, "params": [], "return_type": "int", "signature": "protected int countHostCandidates()", "original_string": "    protected int countHostCandidates()\n    {\n        int num = 0;\n\n        synchronized (components)\n        {\n            for (Component cmp : components.values())\n                num += cmp.countLocalHostCandidates();\n        }\n\n        return num;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/IceMediaStream.java", "class_name": "IceMediaStream", "class_uri": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\nReturns the number of host {@link Candidate}s in this stream.\n\n@return the number of host {@link Candidate}s in this stream.\n"}, {"uris": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[void]addToCheckList(CandidatePair)", "name": "addToCheckList", "arg_nums": 1, "params": [{"name": "candidatePair", "type": "CandidatePair"}], "return_type": "void", "signature": "protected void addToCheckList(CandidatePair candidatePair)", "original_string": "    protected void addToCheckList(CandidatePair candidatePair)\n    {\n        synchronized(checkList)\n        {\n            checkList.add(candidatePair);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/IceMediaStream.java", "class_name": "IceMediaStream", "class_uri": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nAdds <tt>candidatePair</tt> to this stream's check list. The method\nis meant for use during the connectivity checks phase when new pairs\nwith remote PEER-REFLEXIVE-CANDIDATEs are discovered.\n\n@param candidatePair the pair that we'd like to add to this streams.\n"}, {"uris": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[void]addToValidList(CandidatePair)", "name": "addToValidList", "arg_nums": 1, "params": [{"name": "pair", "type": "CandidatePair"}], "return_type": "void", "signature": "protected void addToValidList(CandidatePair pair)", "original_string": "    protected void addToValidList(CandidatePair pair)\n    {\n        synchronized (validList)\n        {\n            if (!validList.contains(pair))\n                validList.add(pair);\n        }\n\n        pair.validate();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/IceMediaStream.java", "class_name": "IceMediaStream", "class_uri": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nAdds <tt>pair</tt> to the <tt>valid list</tt> that this stream is\nmaintaining.\n\n@param pair the {@link CandidatePair} to add to our valid list.\n"}, {"uris": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[boolean]validListContainsFoundation(String)", "name": "validListContainsFoundation", "arg_nums": 1, "params": [{"name": "foundation", "type": "String"}], "return_type": "boolean", "signature": "protected boolean validListContainsFoundation(String foundation)", "original_string": "    protected boolean validListContainsFoundation(String foundation)\n    {\n        synchronized(validList)\n        {\n            for (CandidatePair pair : validList)\n            {\n                if (pair.getFoundation().equals(foundation))\n                    return true;\n            }\n        }\n        return false;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/IceMediaStream.java", "class_name": "IceMediaStream", "class_uri": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nReturns <tt>true</tt> if this stream's <tt>validList</tt> contains a\npair with the specified <tt>foundation</tt> and <tt>false</tt> otherwise.\n\n@param foundation the foundation String we'd like to search our\nvalidList for.\n\n@return <tt>true</tt> if this stream's <tt>validList</tt> contains a\npair with the specified <tt>foundation</tt> and <tt>false</tt> otherwise.\n"}, {"uris": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[boolean]validListContainsNomineeForComponent(Component)", "name": "validListContainsNomineeForComponent", "arg_nums": 1, "params": [{"name": "component", "type": "Component"}], "return_type": "boolean", "signature": "protected boolean validListContainsNomineeForComponent(Component component)", "original_string": "    protected boolean validListContainsNomineeForComponent(Component component)\n    {\n        synchronized (validList)\n        {\n            for (CandidatePair pair : validList)\n            {\n                if (pair.isNominated()\n                        && pair.getParentComponent() == component)\n                {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/IceMediaStream.java", "class_name": "IceMediaStream", "class_uri": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nReturns <tt>true</tt> if this stream's <tt>validList</tt> contains a\npair that is nominated for the specified <tt>Component</tt> and\n<tt>false</tt> otherwise.\n\n@param component the <tt>Component</tt> we'd like to search our\nvalidList for.\n\n@return <tt>true</tt> if this stream's <tt>validList</tt> contains a\npair that is nominated for the specified <tt>Component</tt> and\n<tt>false</tt> otherwise.\n"}, {"uris": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[boolean]validListContainsAllComponents()", "name": "validListContainsAllComponents", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "protected boolean validListContainsAllComponents()", "original_string": "    protected boolean validListContainsAllComponents()\n    {\n        for (Component cmp : getComponents())\n        {\n            if (getValidPair(cmp) == null)\n            {\n                //it looks like there's at least one component we don't have a\n                //valid candidate for.\n                return false;\n            }\n        }\n        return true;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/IceMediaStream.java", "class_name": "IceMediaStream", "class_uri": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nReturns <tt>true</tt> if this stream's valid list contains at least\none {@link CandidatePair} for each {@link Component} of the stream and\n<tt>false</tt> otherwise.\n\n@return <tt>true</tt> if this stream's valid list contains at least\none {@link CandidatePair} for each {@link Component} of the stream and\n<tt>false</tt> otherwise.\n"}, {"uris": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[boolean]allComponentsAreNominated()", "name": "allComponentsAreNominated", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "protected boolean allComponentsAreNominated()", "original_string": "    protected boolean allComponentsAreNominated()\n    {\n        List<Component> components = getComponents();\n\n        synchronized (validList)\n        {\n            for (CandidatePair pair : validList)\n            {\n                if (pair.isNominated())\n                    components.remove(pair.getParentComponent());\n            }\n        }\n\n        return components.isEmpty();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/IceMediaStream.java", "class_name": "IceMediaStream", "class_uri": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nReturns <tt>true</tt> if there is at least one nominated {@link\nCandidatePair} in the valid list for every {@link Component} of this\nstream and <tt>false</tt> otherwise.\n\n@return <tt>true</tt> if there is at least one nominated {@link\nCandidatePair} in the valid list for every {@link Component} of this\nstream and <tt>false</tt> otherwise.\n"}, {"uris": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[boolean]allComponentsHaveSelected()", "name": "allComponentsHaveSelected", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "protected boolean allComponentsHaveSelected()", "original_string": "    protected boolean allComponentsHaveSelected()\n    {\n        for (Component component : getComponents())\n        {\n            if (component.getSelectedPair() == null)\n                return false;\n        }\n        return true;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/IceMediaStream.java", "class_name": "IceMediaStream", "class_uri": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nReturns <tt>false</tt> if there is at least one nominated {@link\nCandidatePair} who doesn't have a selected address yet, and <tt>true</tt>\notherwise.\n\n@return <tt>false</tt> if there is at least one nominated {@link\nCandidatePair} who doesn't have a selected address yet, and <tt>true</tt>\notherwise.\n"}, {"uris": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[CandidatePair]getValidPair(Component)", "name": "getValidPair", "arg_nums": 1, "params": [{"name": "component", "type": "Component"}], "return_type": "CandidatePair", "signature": "protected CandidatePair getValidPair(Component component)", "original_string": "    protected CandidatePair getValidPair(Component component)\n    {\n        synchronized (validList)\n        {\n            for (CandidatePair pair : validList)\n            {\n                if (pair.getParentComponent() == component)\n                    return pair;\n            }\n        }\n        return null;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/IceMediaStream.java", "class_name": "IceMediaStream", "class_uri": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "CandidatePair", "classes": []}, "docstring": "\nReturns the first {@link CandidatePair} stored in this stream's valid\nlist, that belongs to the specified <tt>component</tt>.\n\n@param component the {@link Component} we'd like to obtain a valid\npair for.\n\n@return a valid {@link CandidatePair} for the specified\n<tt>component</tt> if at least one exists, and <tt>null</tt> otherwise.\n"}, {"uris": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[void]addPairChangeListener(PropertyChangeListener)", "name": "addPairChangeListener", "arg_nums": 1, "params": [{"name": "l", "type": "PropertyChangeListener"}], "return_type": "void", "signature": "public void addPairChangeListener(PropertyChangeListener l)", "original_string": "    public void addPairChangeListener(PropertyChangeListener l)\n    {\n        synchronized (streamListeners)\n        {\n            if (!streamListeners.contains(l))\n                streamListeners.add(l);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/IceMediaStream.java", "class_name": "IceMediaStream", "class_uri": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nAdds <tt>l</tt> to the list of listeners registered for property changes\nif {@link CandidatePair}s. We add such listeners in the stream, rather\nthan having them in the candidate pair itself, because we don't want all\npairs to keep lists of references to the same listeners.\n\n@param l the listener to register.\n"}, {"uris": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[void]removePairStateChangeListener(PropertyChangeListener)", "name": "removePairStateChangeListener", "arg_nums": 1, "params": [{"name": "l", "type": "PropertyChangeListener"}], "return_type": "void", "signature": "public void removePairStateChangeListener(PropertyChangeListener l)", "original_string": "    public void removePairStateChangeListener(PropertyChangeListener l)\n    {\n        synchronized (streamListeners)\n        {\n            streamListeners.remove(l);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/IceMediaStream.java", "class_name": "IceMediaStream", "class_uri": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nRemoves <tt>l</tt> from the list of listeners registered for property\nchanges.\n\n@param l the listener to remove.\n"}, {"uris": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[void]firePairPropertyChange(CandidatePair,String,Object,Object)", "name": "firePairPropertyChange", "arg_nums": 4, "params": [{"name": "source", "type": "CandidatePair"}, {"name": "propertyName", "type": "String"}, {"name": "oldValue", "type": "Object"}, {"name": "newValue", "type": "Object"}], "return_type": "void", "signature": "protected void firePairPropertyChange(CandidatePair source,\n                                          String        propertyName,\n                                          Object        oldValue,\n                                          Object        newValue)", "original_string": "    protected void firePairPropertyChange(CandidatePair source,\n                                          String        propertyName,\n                                          Object        oldValue,\n                                          Object        newValue)\n    {\n        PropertyChangeListener[] ls;\n\n        synchronized (streamListeners)\n        {\n            ls\n                = streamListeners.toArray(\n                        new PropertyChangeListener[streamListeners.size()]);\n        }\n\n        PropertyChangeEvent ev\n            = new PropertyChangeEvent(source, propertyName, oldValue, newValue);\n\n        for (PropertyChangeListener l : ls)\n            l.propertyChange(ev);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/IceMediaStream.java", "class_name": "IceMediaStream", "class_uri": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCreates a new {@link PropertyChangeEvent} and delivers it to all\ncurrently registered state listeners.\n\n@param source the {@link CandidatePair} whose property has just changed.\n@param propertyName the name of the property that changed.\n@param oldValue the old value of the property that changed.\n@param newValue the new value of the property that changed.\n"}, {"uris": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[void]setRemoteUfrag(String)", "name": "setRemoteUfrag", "arg_nums": 1, "params": [{"name": "remoteUfrag", "type": "String"}], "return_type": "void", "signature": "public void setRemoteUfrag(String remoteUfrag)", "original_string": "    public void setRemoteUfrag(String remoteUfrag)\n    {\n        this.remoteUfrag = remoteUfrag;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/IceMediaStream.java", "class_name": "IceMediaStream", "class_uri": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSpecifies the user name that we received from the remote peer.\n\n@param remoteUfrag the user name that we received from the remote peer.\n"}, {"uris": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[String]getRemoteUfrag()", "name": "getRemoteUfrag", "arg_nums": 0, "params": [], "return_type": "String", "signature": "public String getRemoteUfrag()", "original_string": "    public String getRemoteUfrag()\n    {\n        return remoteUfrag;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/IceMediaStream.java", "class_name": "IceMediaStream", "class_uri": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns the user name that we received from the remote peer or\n<tt>null</tt> if we haven't received a user name from them yet.\n\n@return the user name that we received from the remote peer or\n<tt>null</tt> if we haven't received a user name from them yet.\n"}, {"uris": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[void]setRemotePassword(String)", "name": "setRemotePassword", "arg_nums": 1, "params": [{"name": "remotePassword", "type": "String"}], "return_type": "void", "signature": "public void setRemotePassword(String remotePassword)", "original_string": "    public void setRemotePassword(String remotePassword)\n    {\n        this.remotePassword = remotePassword;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/IceMediaStream.java", "class_name": "IceMediaStream", "class_uri": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSpecifies the password that we received from the remote peer.\n\n@param remotePassword the user name that we received from the remote\npeer.\n"}, {"uris": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[String]getRemotePassword()", "name": "getRemotePassword", "arg_nums": 0, "params": [], "return_type": "String", "signature": "public String getRemotePassword()", "original_string": "    public String getRemotePassword()\n    {\n        return remotePassword;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/IceMediaStream.java", "class_name": "IceMediaStream", "class_uri": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns the password that we received from the remote peer or\n<tt>null</tt> if we haven't received a password from them yet.\n\n@return the password that we received from the remote peer or\n<tt>null</tt> if we haven't received a password from them yet.\n"}, {"uris": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[Logger]getLogger()", "name": "getLogger", "arg_nums": 0, "params": [], "return_type": "Logger", "signature": "public Logger getLogger()", "original_string": "    public Logger getLogger()\n    {\n        return logger;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/IceMediaStream.java", "class_name": "IceMediaStream", "class_uri": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Logger", "classes": []}, "docstring": ""}, {"uris": "src/main/java/org/ice4j/ice/CandidatePrioritizer.java.CandidatePrioritizer.[int]compareCandidates(Candidate<?>,Candidate<?>)", "name": "compareCandidates", "arg_nums": 2, "params": [{"name": "c1", "type": "Candidate<?>"}, {"name": "c2", "type": "Candidate<?>"}], "return_type": "int", "signature": "public static int compareCandidates(Candidate<?> c1, Candidate<?> c2)", "original_string": "    public static int compareCandidates(Candidate<?> c1, Candidate<?> c2)\n    {\n        if (c1.getPriority() < c2.getPriority())\n            return 1;\n        else if (c1.getPriority() == c2.getPriority())\n            return 0;\n        else //if(c1.getPriority() > c2.getPriority())\n            return -1;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/CandidatePrioritizer.java", "class_name": "CandidatePrioritizer", "class_uri": "src/main/java/org/ice4j/ice/CandidatePrioritizer.java.CandidatePrioritizer", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\nCompares the two <tt>Candidate</tt>s based on their priority and\nreturns a negative integer, zero, or a positive integer as the first\n<tt>Candidate</tt> has a lower, equal, or greater priority than the\nsecond.\n\n@param c1 the first <tt>Candidate</tt> to compare.\n@param c2 the second <tt>Candidate</tt> to compare.\n\n@return a negative integer, zero, or a positive integer as the first\n        <tt>Candidate</tt> has a lower, equal,\n        or greater priority than the\n        second.\n"}, {"uris": "src/main/java/org/ice4j/ice/CandidatePrioritizer.java.CandidatePrioritizer.[int]compare(Candidate<?>,Candidate<?>)", "name": "compare", "arg_nums": 2, "params": [{"name": "c1", "type": "Candidate<?>"}, {"name": "c2", "type": "Candidate<?>"}], "return_type": "int", "signature": "public int compare(Candidate<?> c1, Candidate<?> c2)", "original_string": "    public int compare(Candidate<?> c1, Candidate<?> c2)\n    {\n        return CandidatePrioritizer.compareCandidates(c1, c2);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/CandidatePrioritizer.java", "class_name": "CandidatePrioritizer", "class_uri": "src/main/java/org/ice4j/ice/CandidatePrioritizer.java.CandidatePrioritizer", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\nCompares the two <tt>Candidate</tt>s based on their priority and\nreturns a negative integer, zero, or a positive integer as the first\n<tt>Candidate</tt> has a lower, equal, or greater priority than the\nsecond.\n\n@param c1 the first <tt>Candidate</tt> to compare.\n@param c2 the second <tt>Candidate</tt> to compare.\n\n@return a negative integer, zero, or a positive integer as the first\n        <tt>Candidate</tt> has a lower, equal,\n        or greater priority than the\n        second.\n"}, {"uris": "src/main/java/org/ice4j/ice/CandidatePrioritizer.java.CandidatePrioritizer.[boolean]equals(Object)", "name": "equals", "arg_nums": 1, "params": [{"name": "obj", "type": "Object"}], "return_type": "boolean", "signature": "public boolean equals(Object obj)", "original_string": "    public boolean equals(Object obj)\n    {\n        return (obj instanceof CandidatePrioritizer);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/CandidatePrioritizer.java", "class_name": "CandidatePrioritizer", "class_uri": "src/main/java/org/ice4j/ice/CandidatePrioritizer.java.CandidatePrioritizer", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nIndicates whether some other object is &quot;equal to&quot; this\nComparator.  This method must obey the general contract of\n<tt>Object.equals(Object)</tt>.  Additionally, this method can return\n<tt>true</tt> <i>only</i> if the specified Object is also a\ncomparator and it imposes the same ordering as this comparator. Thus,\n<code>comp1.equals(comp2)</code> implies that\n<tt>sgn(comp1.compare(o1, o2))==sgn(comp2.compare(o1, o2))</tt> for\nevery object reference <tt>o1</tt> and <tt>o2</tt>.<p>\n<p>\nNote that it is <i>always</i> safe <i>not</i> to override\n<tt>Object.equals(Object)</tt>.  However, overriding this method may,\nin some cases, improve performance by allowing programs to determine\nthat two distinct Comparators impose the same order.\n</p>\n\n@param obj the reference object with which to compare.\n\n@return <code>true</code> only if the specified object is also\n        a comparator and it imposes the same ordering as this\n        comparator.\n\n@see Object#equals(Object)\n@see Object#hashCode()\n"}, {"uris": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[]CandidatePair(LocalCandidate,RemoteCandidate)", "name": "CandidatePair", "arg_nums": 2, "params": [{"name": "localCandidate", "type": "LocalCandidate"}, {"name": "remoteCandidate", "type": "RemoteCandidate"}], "return_type": "", "signature": "public CandidatePair(LocalCandidate localCandidate,\n                         RemoteCandidate remoteCandidate)", "original_string": "    public CandidatePair(LocalCandidate localCandidate,\n                         RemoteCandidate remoteCandidate)\n    {\n        this.localCandidate = localCandidate;\n        this.remoteCandidate = remoteCandidate;\n\n        computePriority();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/CandidatePair.java", "class_name": "CandidatePair", "class_uri": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nCreates a <tt>CandidatePair</tt> instance mapping <tt>localCandidate</tt>\nto <tt>remoteCandidate</tt>.\n\n@param localCandidate the local candidate of the pair.\n@param remoteCandidate the remote candidate of the pair.\n"}, {"uris": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[String]getFoundation()", "name": "getFoundation", "arg_nums": 0, "params": [], "return_type": "String", "signature": "public String getFoundation()", "original_string": "    public String getFoundation()\n    {\n        return localCandidate.getFoundation()\n            + remoteCandidate.getFoundation();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/CandidatePair.java", "class_name": "CandidatePair", "class_uri": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns the foundation of this <tt>CandidatePair</tt>. The foundation\nof a <tt>CandidatePair</tt> is just the concatenation of the foundations\nof its two candidates. Initially, only the candidate pairs with unique\nfoundations are tested. The other candidate pairs are marked \"frozen\".\nWhen the connectivity checks for a candidate pair succeed, the other\ncandidate pairs with the same foundation are unfrozen. This avoids\nrepeated checking of components which are superficially more attractive\nbut in fact are likely to fail.\n\n@return the foundation of this candidate pair, which is a concatenation\nof the foundations of the remote and local candidates.\n"}, {"uris": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[LocalCandidate]getLocalCandidate()", "name": "getLocalCandidate", "arg_nums": 0, "params": [], "return_type": "LocalCandidate", "signature": "public LocalCandidate getLocalCandidate()", "original_string": "    public LocalCandidate getLocalCandidate()\n    {\n        return localCandidate;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/CandidatePair.java", "class_name": "CandidatePair", "class_uri": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "LocalCandidate", "classes": []}, "docstring": "\nReturns the <tt>LocalCandidate</tt> of this <tt>CandidatePair</tt>.\n\n@return the local <tt>Candidate</tt> of this <tt>CandidatePair</tt>.\n"}, {"uris": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[void]setLocalCandidate(LocalCandidate)", "name": "setLocalCandidate", "arg_nums": 1, "params": [{"name": "localCnd", "type": "LocalCandidate"}], "return_type": "void", "signature": "protected void setLocalCandidate(LocalCandidate localCnd)", "original_string": "    protected void setLocalCandidate(LocalCandidate localCnd)\n    {\n        this.localCandidate = localCnd;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/CandidatePair.java", "class_name": "CandidatePair", "class_uri": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets the <tt>LocalCandidate</tt> of this <tt>CandidatePair</tt>.\n\n@param localCnd the local <tt>Candidate</tt> of this\n<tt>CandidatePair</tt>.\n"}, {"uris": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[RemoteCandidate]getRemoteCandidate()", "name": "getRemoteCandidate", "arg_nums": 0, "params": [], "return_type": "RemoteCandidate", "signature": "public RemoteCandidate getRemoteCandidate()", "original_string": "    public RemoteCandidate getRemoteCandidate()\n    {\n        return remoteCandidate;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/CandidatePair.java", "class_name": "CandidatePair", "class_uri": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "RemoteCandidate", "classes": []}, "docstring": "\nReturns the remote candidate of this <tt>CandidatePair</tt>.\n\n@return the remote <tt>Candidate</tt> of this <tt>CandidatePair</tt>.\n"}, {"uris": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[void]setRemoteCandidate(RemoteCandidate)", "name": "setRemoteCandidate", "arg_nums": 1, "params": [{"name": "remoteCnd", "type": "RemoteCandidate"}], "return_type": "void", "signature": "protected void setRemoteCandidate(RemoteCandidate remoteCnd)", "original_string": "    protected void setRemoteCandidate(RemoteCandidate remoteCnd)\n    {\n        this.remoteCandidate = remoteCnd;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/CandidatePair.java", "class_name": "CandidatePair", "class_uri": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets the <tt>RemoteCandidate</tt> of this <tt>CandidatePair</tt>.\n\n@param remoteCnd the local <tt>Candidate</tt> of this\n<tt>CandidatePair</tt>.\n"}, {"uris": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[CandidatePairState]getState()", "name": "getState", "arg_nums": 0, "params": [], "return_type": "CandidatePairState", "signature": "public CandidatePairState getState()", "original_string": "    public CandidatePairState getState()\n    {\n        return state;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/CandidatePair.java", "class_name": "CandidatePair", "class_uri": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "CandidatePairState", "classes": []}, "docstring": "\nReturns the state of this <tt>CandidatePair</tt>. Each candidate pair has\na state that is assigned once the check list for each media stream has\nbeen computed. The ICE RFC defines five potential values that the state\ncan have. They are represented here with the <tt>CandidatePairState</tt>\nenumeration.\n\n@return the <tt>CandidatePairState</tt> that this candidate pair is\ncurrently in.\n"}, {"uris": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[void]setStateFailed()", "name": "setStateFailed", "arg_nums": 0, "params": [], "return_type": "void", "signature": "public void setStateFailed()", "original_string": "    public void setStateFailed()\n    {\n        setState(CandidatePairState.FAILED, null);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/CandidatePair.java", "class_name": "CandidatePair", "class_uri": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets the <tt>CandidatePairState</tt> of this pair to\n{@link CandidatePairState#FAILED}. This method should only be called by\nthe ICE agent, during the execution of the ICE procedures.\n"}, {"uris": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[void]setStateFrozen()", "name": "setStateFrozen", "arg_nums": 0, "params": [], "return_type": "void", "signature": "public void setStateFrozen()", "original_string": "    public void setStateFrozen()\n    {\n        setState(CandidatePairState.FROZEN, null);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/CandidatePair.java", "class_name": "CandidatePair", "class_uri": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets the <tt>CandidatePairState</tt> of this pair to\n{@link CandidatePairState#FROZEN}. This method should only be called by\nthe ICE agent, during the execution of the ICE procedures.\n"}, {"uris": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[void]setStateInProgress(TransactionID)", "name": "setStateInProgress", "arg_nums": 1, "params": [{"name": "tranID", "type": "TransactionID"}], "return_type": "void", "signature": "public void setStateInProgress(TransactionID tranID)", "original_string": "    public void setStateInProgress(TransactionID tranID)\n    {\n        setState(CandidatePairState.IN_PROGRESS, tranID);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/CandidatePair.java", "class_name": "CandidatePair", "class_uri": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets the <tt>CandidatePairState</tt> of this pair to\n{@link CandidatePairState#FROZEN}. This method should only be called by\nthe ICE agent, during the execution of the ICE procedures.\n\n@param tranID the {@link TransactionID} that we are using for the\nconnectivity check in case we are entering the <tt>In-Progress</tt>\nstate and <tt>null</tt> otherwise.\n"}, {"uris": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[void]setStateSucceeded()", "name": "setStateSucceeded", "arg_nums": 0, "params": [], "return_type": "void", "signature": "public void setStateSucceeded()", "original_string": "    public void setStateSucceeded()\n    {\n        setState(CandidatePairState.SUCCEEDED, null);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/CandidatePair.java", "class_name": "CandidatePair", "class_uri": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets the <tt>CandidatePairState</tt> of this pair to\n{@link CandidatePairState#SUCCEEDED}. This method should only be called\nby the ICE agent, during the execution of the ICE procedures.\n"}, {"uris": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[void]setStateWaiting()", "name": "setStateWaiting", "arg_nums": 0, "params": [], "return_type": "void", "signature": "public void setStateWaiting()", "original_string": "    public void setStateWaiting()\n    {\n        setState(CandidatePairState.WAITING, null);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/CandidatePair.java", "class_name": "CandidatePair", "class_uri": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets the <tt>CandidatePairState</tt> of this pair to\n{@link CandidatePairState#WAITING}. This method should only be called by\nthe ICE agent, during the execution of the ICE procedures.\n"}, {"uris": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[void]setState(CandidatePairState,TransactionID)", "name": "setState", "arg_nums": 2, "params": [{"name": "newState", "type": "CandidatePairState"}, {"name": "tranID", "type": "TransactionID"}], "return_type": "void", "signature": "private synchronized void setState(CandidatePairState newState,\n                                       TransactionID      tranID)", "original_string": "    private synchronized void setState(CandidatePairState newState,\n                                       TransactionID      tranID)\n        throws IllegalArgumentException\n    {\n        CandidatePairState oldState = this.state;\n\n        this.state = newState;\n\n        if (newState == CandidatePairState.IN_PROGRESS)\n        {\n            if (tranID == null)\n            {\n                throw new IllegalArgumentException(\n                        \"Putting a pair into the In-Progress state MUST be\"\n                            + \" accompanied with the TransactionID of the\"\n                            + \" connectivity check.\");\n            }\n        }\n        else\n        {\n            if (tranID != null)\n            {\n                throw new IllegalArgumentException(\n                        \"How could you have a transaction for a pair that's not\"\n                            + \" in the In-Progress state?\");\n            }\n        }\n        this.connCheckTranID = tranID;\n\n        getParentComponent().getParentStream().firePairPropertyChange(\n                this,\n                IceMediaStream.PROPERTY_PAIR_STATE_CHANGED,\n                oldState,\n                newState);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/CandidatePair.java", "class_name": "CandidatePair", "class_uri": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair", "attributes": {"modifiers": "private synchronized", "marker_annotations": [], "non_marker_annotations": ["private", "synchronized"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets the <tt>CandidatePairState</tt> of this pair to <tt>state</tt>. This\nmethod should only be called by the ice agent, during the execution of\nthe ICE procedures. Note that passing a <tt>null</tt> transaction for the\n{@link CandidatePairState#IN_PROGRESS} or a non-<tt>null</tt> for any\nother state would cause an {@link IllegalArgumentException} to be thrown.\n\n@param newState the state that this candidate pair is to enter.\n@param tranID the {@link TransactionID} that we are using for the\nconnectivity check in case we are entering the <tt>In-Progress</tt>\nstate and <tt>null</tt> otherwise.\n\n@throws IllegalArgumentException if state is {@link CandidatePairState\n#IN_PROGRESS} and <tt>tranID</tt> is <tt>null</tt>.\n"}, {"uris": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[boolean]isFrozen()", "name": "isFrozen", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "public boolean isFrozen()", "original_string": "    public boolean isFrozen()\n    {\n        return this.getState().equals(CandidatePairState.FROZEN);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/CandidatePair.java", "class_name": "CandidatePair", "class_uri": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nDetermines whether this candidate pair is frozen or not. Initially, only\nthe candidate pairs with unique foundations are tested. The other\ncandidate pairs are marked \"frozen\". When the connectivity checks for a\ncandidate pair succeed, the other candidate pairs with the same\nfoundation are unfrozen.\n\n@return true if this candidate pair is frozen and false otherwise.\n"}, {"uris": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[Candidate<?>]getControllingAgentCandidate()", "name": "getControllingAgentCandidate", "arg_nums": 0, "params": [], "return_type": "Candidate<?>", "signature": "public Candidate<?> getControllingAgentCandidate()", "original_string": "    public Candidate<?> getControllingAgentCandidate()\n    {\n        return (getLocalCandidate().getParentComponent().getParentStream()\n                        .getParentAgent().isControlling())\n                    ? getLocalCandidate()\n                    : getRemoteCandidate();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/CandidatePair.java", "class_name": "CandidatePair", "class_uri": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Candidate<?>", "classes": []}, "docstring": "\nReturns the candidate in this pair that belongs to the controlling agent.\n\n@return a reference to the <tt>Candidate</tt> instance that comes from\nthe controlling agent.\n"}, {"uris": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[Candidate<?>]getControlledAgentCandidate()", "name": "getControlledAgentCandidate", "arg_nums": 0, "params": [], "return_type": "Candidate<?>", "signature": "public Candidate<?> getControlledAgentCandidate()", "original_string": "    public Candidate<?> getControlledAgentCandidate()\n    {\n        return (getLocalCandidate().getParentComponent().getParentStream()\n                        .getParentAgent().isControlling())\n                    ? getRemoteCandidate()\n                    : getLocalCandidate();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/CandidatePair.java", "class_name": "CandidatePair", "class_uri": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Candidate<?>", "classes": []}, "docstring": "\nReturns the candidate in this pair that belongs to the controlled agent.\n\n@return a reference to the <tt>Candidate</tt> instance that comes from\nthe controlled agent.\n"}, {"uris": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[void]computePriority()", "name": "computePriority", "arg_nums": 0, "params": [], "return_type": "void", "signature": "protected void computePriority()", "original_string": "    protected void computePriority()\n    {\n        // Use g and d as local and remote candidate priority names to fit the\n        // definition in the RFC.\n        long g = getControllingAgentCandidate().getPriority();\n        long d = getControlledAgentCandidate().getPriority();\n        long min, max, expr;\n\n        if (g > d)\n        {\n            min = d;\n            max = g;\n            expr = 1L;\n        }\n        else\n        {\n            min = g;\n            max = d;\n            expr = 0L;\n        }\n\n        this.priority = MATH_POW_2_32 * min + 2 * max + expr;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/CandidatePair.java", "class_name": "CandidatePair", "class_uri": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nA candidate pair priority is computed the following way:<br>\nLet G be the priority for the candidate provided by the controlling\nagent. Let D be the priority for the candidate provided by the\ncontrolled agent. The priority for a pair is computed as:\n<p>\n<i>pair priority = 2^32*MIN(G,D) + 2*MAX(G,D) + (G&gt;D?1:0)</i>\n<p>\nThis formula ensures a unique priority for each pair. Once the priority\nis assigned, the agent sorts the candidate pairs in decreasing order of\npriority. If two pairs have identical priority, the ordering amongst\nthem is arbitrary.\n"}, {"uris": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[long]getPriority()", "name": "getPriority", "arg_nums": 0, "params": [], "return_type": "long", "signature": "public long getPriority()", "original_string": "    public long getPriority()\n    {\n        return priority;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/CandidatePair.java", "class_name": "CandidatePair", "class_uri": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "long", "classes": []}, "docstring": "\nReturns the priority of this pair.\n\n@return the priority of this pair.\n"}, {"uris": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[int]compareTo(CandidatePair)", "name": "compareTo", "arg_nums": 1, "params": [{"name": "candidatePair", "type": "CandidatePair"}], "return_type": "int", "signature": "public int compareTo(CandidatePair candidatePair)", "original_string": "    public int compareTo(CandidatePair candidatePair)\n    {\n        long thisPri = getPriority();\n        long otherPri = candidatePair.getPriority();\n\n        return (thisPri < otherPri) ? 1 : (thisPri == otherPri) ? 0 : -1;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/CandidatePair.java", "class_name": "CandidatePair", "class_uri": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\nCompares this <tt>CandidatePair</tt> with the specified object for order.\nReturns a negative integer, zero, or a positive integer as this\n<tt>CandidatePair</tt>'s priority is greater than, equal to, or less than\nthe one of the specified object thus insuring that higher priority pairs\nwill come first.<p>\n\n@param   candidatePair the Object to be compared.\n@return  a negative integer, zero, or a positive integer as this\n<tt>CandidatePair</tt>'s priority is greater than, equal to, or less than\nthe one of the specified object.\n\n@throws ClassCastException if the specified object's type prevents it\n        from being compared to this Object.\n"}, {"uris": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[boolean]equals(Object)", "name": "equals", "arg_nums": 1, "params": [{"name": "obj", "type": "Object"}], "return_type": "boolean", "signature": "@Override\n    public boolean equals(Object obj)", "original_string": "    @Override\n    public boolean equals(Object obj)\n    {\n        if (! (obj instanceof CandidatePair))\n            return false;\n\n        CandidatePair candidatePair = (CandidatePair) obj;\n\n        // XXX DO NOT change this method to also depend on other pair properties\n        // because ConnectivityCheckClient counts on it only using the\n        // candidates for comparisons.\n        return\n            localCandidate.equals(candidatePair.localCandidate)\n                && remoteCandidate.equals(candidatePair.remoteCandidate);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/CandidatePair.java", "class_name": "CandidatePair", "class_uri": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nCompares this <tt>CandidatePair</tt> to <tt>obj</tt> and returns\n<tt>true</tt> if pairs have equal local and equal remote candidates and\n<tt>false</tt> otherwise.\n\n@param obj the <tt>Object</tt> that we'd like to compare this pair to.\n@return <tt>true</tt> if pairs have equal local and equal remote\ncandidates and <tt>false</tt> otherwise.\n"}, {"uris": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[int]hashCode()", "name": "hashCode", "arg_nums": 0, "params": [], "return_type": "int", "signature": "@Override\n    public int hashCode()", "original_string": "    @Override\n    public int hashCode()\n    {\n        // Even if the following hashCode algorithm has drawbacks because of it\n        // simplicity, it is better than nothing because at least it allows\n        // CandidatePair to be used as a HashMap key.\n        // XXX While localCandidate is not final, the parentComponent is\n        // supposedly effectively final.\n        return getLocalCandidate().getParentComponent().hashCode();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/CandidatePair.java", "class_name": "CandidatePair", "class_uri": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[String]toString()", "name": "toString", "arg_nums": 0, "params": [], "return_type": "String", "signature": "@Override\n    public String toString()", "original_string": "    @Override\n    public String toString()\n    {\n        return\n            \"CandidatePair (State=\" + getState() + \" Priority=\" + getPriority()\n                + \"):\\n\\tLocalCandidate=\" + getLocalCandidate()\n                + \"\\n\\tRemoteCandidate=\" + getRemoteCandidate();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/CandidatePair.java", "class_name": "CandidatePair", "class_uri": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns a String representation of this <tt>CandidatePair</tt>.\n\n@return a String representation of the object.\n"}, {"uris": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[String]toRedactedString()", "name": "toRedactedString", "arg_nums": 0, "params": [], "return_type": "String", "signature": "public String toRedactedString()", "original_string": "    public String toRedactedString()\n    {\n        return\n                \"CandidatePair (State=\" + getState() + \" Priority=\" + getPriority()\n                        + \"):\\n\\tLocalCandidate=\" + getLocalCandidate()\n                        + \"\\n\\tRemoteCandidate=\" + getRemoteCandidate().toRedactedString();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/CandidatePair.java", "class_name": "CandidatePair", "class_uri": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns a String representation of this <tt>CandidatePair</tt>, with the remote\ncandidate IP address redacted if redaction is enabled.\n\n@return a String representation of the object.\n"}, {"uris": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[String]toShortString()", "name": "toShortString", "arg_nums": 0, "params": [], "return_type": "String", "signature": "public String toShortString()", "original_string": "    public String toShortString()\n    {\n        return getLocalCandidate().toShortString()\n                + \" -> \" + getRemoteCandidate().toShortString()\n                + \" (\" + getParentComponent().toShortString() + \")\";\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/CandidatePair.java", "class_name": "CandidatePair", "class_uri": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns a short String representation of this <tt>CandidatePair</tt>.\n\n@return a short String representation of the object.\n"}, {"uris": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[String]toRedactedShortString()", "name": "toRedactedShortString", "arg_nums": 0, "params": [], "return_type": "String", "signature": "public String toRedactedShortString()", "original_string": "    public String toRedactedShortString()\n    {\n        return getLocalCandidate().toShortString()\n                + \" -> \" + getRemoteCandidate().toRedactedShortString()\n                + \" (\" + getParentComponent().toShortString() + \")\";\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/CandidatePair.java", "class_name": "CandidatePair", "class_uri": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns a short String representation of this <tt>CandidatePair</tt>,\nwith the remote candidate IP address redacted if redaction is enabled.\n\n@return a redacted short String representation of the object.\n"}, {"uris": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[Component]getParentComponent()", "name": "getParentComponent", "arg_nums": 0, "params": [], "return_type": "Component", "signature": "public Component getParentComponent()", "original_string": "    public Component getParentComponent()\n    {\n        return getLocalCandidate().getParentComponent();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/CandidatePair.java", "class_name": "CandidatePair", "class_uri": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Component", "classes": []}, "docstring": "\nReturns the <tt>Component</tt> that this pair belongs to.\n\n@return the <tt>Component</tt> that this pair belongs to.\n"}, {"uris": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[TransactionID]getConnectivityCheckTransaction()", "name": "getConnectivityCheckTransaction", "arg_nums": 0, "params": [], "return_type": "TransactionID", "signature": "public TransactionID getConnectivityCheckTransaction()", "original_string": "    public TransactionID getConnectivityCheckTransaction()\n    {\n        return connCheckTranID;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/CandidatePair.java", "class_name": "CandidatePair", "class_uri": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "TransactionID", "classes": []}, "docstring": "\nReturns the {@link TransactionID} used in the connectivity check\nassociated with this {@link CandidatePair} when it's in the\n{@link CandidatePairState#IN_PROGRESS} or <tt>null</tt> if it's in\nany other state.\n\n@return the {@link TransactionID} used in the connectivity check\nassociated with this {@link CandidatePair} when it's in the\n{@link CandidatePairState#IN_PROGRESS} or <tt>null</tt> if it's in\nany other state.\n"}, {"uris": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[void]setUseCandidateSent()", "name": "setUseCandidateSent", "arg_nums": 0, "params": [], "return_type": "void", "signature": "public void setUseCandidateSent()", "original_string": "    public void setUseCandidateSent()\n    {\n        this.useCandidateSent = true;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/CandidatePair.java", "class_name": "CandidatePair", "class_uri": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nRaises the <tt>useCandidateSent</tt> flag for this pair.\n"}, {"uris": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[boolean]useCandidateSent()", "name": "useCandidateSent", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "public boolean useCandidateSent()", "original_string": "    public boolean useCandidateSent()\n    {\n        return useCandidateSent;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/CandidatePair.java", "class_name": "CandidatePair", "class_uri": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nReturns <tt>true</tt> if someone has previously raised this pair's\n<tt>useCandidateSent</tt> flag and <tt>false</tt> otherwise.\n\n@return <tt>true</tt> if someone has previously raised this pair's\n<tt>useCandidate</tt> flag and <tt>false</tt> otherwise.\n"}, {"uris": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[void]setUseCandidateReceived()", "name": "setUseCandidateReceived", "arg_nums": 0, "params": [], "return_type": "void", "signature": "public void setUseCandidateReceived()", "original_string": "    public void setUseCandidateReceived()\n    {\n        this.useCandidate = true;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/CandidatePair.java", "class_name": "CandidatePair", "class_uri": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nRaises the <tt>useCandidate</tt> flag for this pair.\n"}, {"uris": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[boolean]useCandidateReceived()", "name": "useCandidateReceived", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "public boolean useCandidateReceived()", "original_string": "    public boolean useCandidateReceived()\n    {\n        return useCandidate;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/CandidatePair.java", "class_name": "CandidatePair", "class_uri": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nReturns <tt>true</tt> if someone has previously raised this pair's\n<tt>useCandidate</tt> flag and <tt>false</tt> otherwise.\n\n@return <tt>true</tt> if someone has previously raised this pair's\n<tt>useCandidate</tt> flag and <tt>false</tt> otherwise.\n"}, {"uris": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[void]nominate()", "name": "nominate", "arg_nums": 0, "params": [], "return_type": "void", "signature": "public void nominate()", "original_string": "    public void nominate()\n    {\n        this.isNominated = true;\n        getParentComponent().getParentStream().firePairPropertyChange(\n                this,\n                IceMediaStream.PROPERTY_PAIR_NOMINATED,\n                /* oldValue */ false,\n                /* newValue */ true);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/CandidatePair.java", "class_name": "CandidatePair", "class_uri": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets this pair's nominated flag to <tt>true</tt>. If a valid candidate\npair has its nominated flag set, it means that it may be selected by ICE\nfor sending and receiving media.\n"}, {"uris": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[boolean]isNominated()", "name": "isNominated", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "public boolean isNominated()", "original_string": "    public boolean isNominated()\n    {\n        return this.isNominated;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/CandidatePair.java", "class_name": "CandidatePair", "class_uri": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nReturns the value of this pair's nominated flag. If a valid candidate\npair has its nominated flag set, it means that it may be selected by ICE\nfor sending and receiving media.\n\n@return <tt>true</tt> if this pair has already been nominated for\nselection and <tt>false</tt> otherwise.\n"}, {"uris": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[boolean]isValid()", "name": "isValid", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "public boolean isValid()", "original_string": "    public boolean isValid()\n    {\n        return isValid;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/CandidatePair.java", "class_name": "CandidatePair", "class_uri": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nReturns <tt>true</tt> if this pair has been confirmed by a connectivity\ncheck response and <tt>false</tt> otherwise.\n\n@return <tt>true</tt> if this pair has been confirmed by a connectivity\ncheck response and <tt>false</tt> otherwise.\n"}, {"uris": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[void]validate()", "name": "validate", "arg_nums": 0, "params": [], "return_type": "void", "signature": "protected void validate()", "original_string": "    protected void validate()\n    {\n        this.isValid = true;\n        getParentComponent().getParentStream().firePairPropertyChange(\n                this,\n                IceMediaStream.PROPERTY_PAIR_VALIDATED,\n                false,\n                true);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/CandidatePair.java", "class_name": "CandidatePair", "class_uri": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nMarks this pair as valid. Should only be used internally.\n"}, {"uris": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[long]getConsentFreshness()", "name": "getConsentFreshness", "arg_nums": 0, "params": [], "return_type": "long", "signature": "public long getConsentFreshness()", "original_string": "    public long getConsentFreshness()\n    {\n        return consentFreshness;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/CandidatePair.java", "class_name": "CandidatePair", "class_uri": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "long", "classes": []}, "docstring": "\nGets the time in milliseconds of the latest consent freshness\nconfirmation.\n\n@return the time in milliseconds of the latest consent freshness\nconfirmation\n"}, {"uris": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[void]setConsentFreshness()", "name": "setConsentFreshness", "arg_nums": 0, "params": [], "return_type": "void", "signature": "void setConsentFreshness()", "original_string": "    void setConsentFreshness()\n    {\n        setConsentFreshness(System.currentTimeMillis());\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/CandidatePair.java", "class_name": "CandidatePair", "class_uri": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets the time in milliseconds of the latest consent freshness\nconfirmation to now.\n"}, {"uris": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[void]setConsentFreshness(long)", "name": "setConsentFreshness", "arg_nums": 1, "params": [{"name": "consentFreshness", "type": "long"}], "return_type": "void", "signature": "void setConsentFreshness(long consentFreshness)", "original_string": "    void setConsentFreshness(long consentFreshness)\n    {\n        if (this.consentFreshness != consentFreshness)\n        {\n            long oldValue = this.consentFreshness;\n\n            this.consentFreshness = consentFreshness;\n\n            long newValue = this.consentFreshness;\n\n            getParentComponent().getParentStream().firePairPropertyChange(\n                    this,\n                    IceMediaStream.PROPERTY_PAIR_CONSENT_FRESHNESS_CHANGED,\n                    oldValue,\n                    newValue);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/CandidatePair.java", "class_name": "CandidatePair", "class_uri": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets the time in milliseconds of the latest consent freshness\nconfirmation to a specific time.\n\n@param consentFreshness the time in milliseconds of the latest consent\nfreshness to be set on this <tt>CandidatePair</tt>\n"}, {"uris": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[DatagramSocket]getDatagramSocket()", "name": "getDatagramSocket", "arg_nums": 0, "params": [], "return_type": "DatagramSocket", "signature": "@Deprecated\n    public DatagramSocket getDatagramSocket()", "original_string": "    @Deprecated\n    public DatagramSocket getDatagramSocket()\n    {\n        IceSocketWrapper wrapper = getIceSocketWrapper();\n        return wrapper == null ? null : wrapper.getUDPSocket();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/CandidatePair.java", "class_name": "CandidatePair", "class_uri": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair", "attributes": {"modifiers": "@Deprecated\n    public", "marker_annotations": ["@Deprecated"], "non_marker_annotations": ["public"], "comments": [], "return_type": "DatagramSocket", "classes": []}, "docstring": "\nReturns the UDP <tt>DatagramSocket</tt> (if any) for this\n<tt>CandidatePair</tt>.\n@return the UDP <tt>DatagramSocket</tt> (if any) for this\n<tt>CandidatePair</tt>.\n"}, {"uris": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[Socket]getSocket()", "name": "getSocket", "arg_nums": 0, "params": [], "return_type": "Socket", "signature": "@Deprecated\n    public Socket getSocket()", "original_string": "    @Deprecated\n    public Socket getSocket()\n    {\n        return null;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/CandidatePair.java", "class_name": "CandidatePair", "class_uri": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair", "attributes": {"modifiers": "@Deprecated\n    public", "marker_annotations": ["@Deprecated"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Socket", "classes": []}, "docstring": "\nReturns the TCP <tt>Socket</tt> (if any) for this <tt>CandidatePair</tt>.\n@return the TCP <tt>Socket</tt> (if any) for this <tt>CandidatePair</tt>.\n"}, {"uris": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[IceSocketWrapper]getIceSocketWrapper()", "name": "getIceSocketWrapper", "arg_nums": 0, "params": [], "return_type": "IceSocketWrapper", "signature": "@Deprecated\n    public IceSocketWrapper getIceSocketWrapper()", "original_string": "    @Deprecated\n    public IceSocketWrapper getIceSocketWrapper()\n    {\n        IceSocketWrapper componentSocket\n            = getParentComponent().getSocketWrapper();\n        // If the merging socket is used, all candidate pairs just refer to the\n        // component.\n        if (componentSocket != null)\n        {\n            return getParentComponent().getSocketWrapper();\n        }\n\n        LocalCandidate localCandidate = getLocalCandidate();\n        if (localCandidate == null)\n        {\n            return null;\n        }\n\n        LocalCandidate base = localCandidate.getBase();\n        if (base != null)\n        {\n            localCandidate = base;\n        }\n\n        RemoteCandidate remoteCandidate = getRemoteCandidate();\n        if (remoteCandidate != null)\n        {\n            SocketAddress remoteAddress\n                = remoteCandidate.getTransportAddress();\n            if (remoteAddress != null)\n            {\n                return localCandidate.getCandidateIceSocketWrapper(remoteAddress);\n            }\n        }\n\n        return localCandidate.getCandidateIceSocketWrapper();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/CandidatePair.java", "class_name": "CandidatePair", "class_uri": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair", "attributes": {"modifiers": "@Deprecated\n    public", "marker_annotations": ["@Deprecated"], "non_marker_annotations": ["public"], "comments": [], "return_type": "IceSocketWrapper", "classes": []}, "docstring": "\nReturns the <tt>IceSocketWrapper</tt> for this <tt>CandidatePair</tt>.\n@return  the <tt>IceSocketWrapper</tt> for this <tt>CandidatePair</tt>.\n"}, {"uris": "src/main/java/org/ice4j/ice/ConnectivityCheckServer.java.ConnectivityCheckServer.[]ConnectivityCheckServer(Agent)", "name": "ConnectivityCheckServer", "arg_nums": 1, "params": [{"name": "parentAgent", "type": "Agent"}], "return_type": "", "signature": "public ConnectivityCheckServer(Agent parentAgent)", "original_string": "    public ConnectivityCheckServer(Agent parentAgent)\n    {\n        this.parentAgent = parentAgent;\n        logger = parentAgent.getLogger().createChildLogger(this.getClass().getName());\n\n        stunStack = this.parentAgent.getStunStack();\n        stunStack.getCredentialsManager().registerAuthority(this);\n\n        start();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/ConnectivityCheckServer.java", "class_name": "ConnectivityCheckServer", "class_uri": "src/main/java/org/ice4j/ice/ConnectivityCheckServer.java.ConnectivityCheckServer", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nCreates a new <tt>ConnectivityCheckServer</tt> setting\n<tt>parentAgent</tt> as the agent that will be used for retrieving\ninformation such as user fragments for example.\n\n@param parentAgent the <tt>Agent</tt> that is creating this instance.\n"}, {"uris": "src/main/java/org/ice4j/ice/ConnectivityCheckServer.java.ConnectivityCheckServer.[boolean]isAlive()", "name": "isAlive", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "boolean isAlive()", "original_string": "    boolean isAlive()\n    {\n        return alive;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/ConnectivityCheckServer.java", "class_name": "ConnectivityCheckServer", "class_uri": "src/main/java/org/ice4j/ice/ConnectivityCheckServer.java.ConnectivityCheckServer", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nReturns a boolean value indicating whether we have received a STUN\nrequest or not.\n\nNote that this should NOT be taken as an indication that the negotiation\nhas succeeded, it merely indicates that we have received ANY STUN\nrequest, even invalid ones (e.g. with the wrong username or ufrag). It is\ncompletely unrelated/independent from the ICE spec and it's only meant to\nbe used for debugging purposes.\n\n@return a boolean value indicating whether we have received a STUN\nrequest or not.\n"}, {"uris": "src/main/java/org/ice4j/ice/ConnectivityCheckServer.java.ConnectivityCheckServer.[void]processRequest(StunMessageEvent)", "name": "processRequest", "arg_nums": 1, "params": [{"name": "evt", "type": "StunMessageEvent"}], "return_type": "void", "signature": "public void processRequest(StunMessageEvent evt)", "original_string": "    public void processRequest(StunMessageEvent evt)\n        throws IllegalArgumentException\n    {\n        logger.trace(() -> \"Received request \" + evt);\n\n        alive = true;\n\n        Request request = (Request)evt.getMessage();\n\n        //ignore incoming requests that are not meant for the local user.\n        //normally the stack will get rid of faulty user names but we could\n        //still see messages not meant for this server if both peers or running\n        //on this same instance of the stack.\n        UsernameAttribute uname = (UsernameAttribute)request\n            .getAttribute(Attribute.USERNAME);\n\n        if ( uname == null\n            || !checkLocalUserName(new String(uname.getUsername())))\n        {\n            return;\n        }\n\n        //detect role conflicts\n        if ( ( parentAgent.isControlling()\n                    && request.containsAttribute(Attribute.ICE_CONTROLLING))\n            || ( ! parentAgent.isControlling()\n                        && request.containsAttribute(Attribute.ICE_CONTROLLED)))\n        {\n            if (!repairRoleConflict(evt))\n                return;\n        }\n\n        long priority = 0;\n        boolean useCandidate\n            = request.containsAttribute(Attribute.USE_CANDIDATE);\n        String username = new String(uname.getUsername());\n        //caller gave us the entire username.\n        String remoteUfrag = null;\n        String localUFrag = null;\n\n        priority = extractPriority(request);\n        int colon = username.indexOf(\":\");\n        remoteUfrag = username.substring(0, colon);\n\n        //tell our address handler we saw a new remote address;\n        boolean respond = parentAgent.incomingCheckReceived(evt.getRemoteAddress(),\n                evt.getLocalAddress(), priority, remoteUfrag, localUFrag,\n                useCandidate);\n\n        Response response;\n\n        if (respond)\n        {\n            response = MessageFactory.createBindingResponse(request, evt.getRemoteAddress());\n        }\n        else\n        {\n            response = MessageFactory.createBindingErrorResponse(\n                    ErrorCodeAttribute.FORBIDDEN,\n                    \"Cannot add new remote candidates in current ICE state\");\n        }\n\n        /* add USERNAME and MESSAGE-INTEGRITY attribute in the response */\n\n        /* The responses utilize the same usernames and passwords as the\n         * requests\n         */\n        Attribute usernameAttribute =\n            AttributeFactory.createUsernameAttribute(uname.getUsername());\n        response.putAttribute(usernameAttribute);\n\n        Attribute messageIntegrityAttribute =\n            AttributeFactory.createMessageIntegrityAttribute(\n                    new String(uname.getUsername()));\n        response.putAttribute(messageIntegrityAttribute);\n\n        try\n        {\n            stunStack.sendResponse(evt.getTransactionID().getBytes(),\n                    response, evt.getLocalAddress(), evt.getRemoteAddress());\n        }\n        catch (Exception e)\n        {\n            logger.info(\"Failed to send \" + response\n                        + \" through \" + evt.getLocalAddress() + \"\\n\" +\n                        e.toString());\n            //try to trigger a 500 response although if this one failed,\n            //then chances are the 500 will fail too.\n            throw new RuntimeException(\"Failed to send a response\", e);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/ConnectivityCheckServer.java", "class_name": "ConnectivityCheckServer", "class_uri": "src/main/java/org/ice4j/ice/ConnectivityCheckServer.java.ConnectivityCheckServer", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nHandles the {@link Request} delivered in <tt>evt</tt> by possibly\nqueuing a triggered check and sending a success or an error response\ndepending on how processing goes.\n\n@param evt the {@link StunMessageEvent} containing the {@link Request}\nthat we need to process.\n\n@throws IllegalArgumentException if the request is malformed and the\nstack needs to reply with a 400 Bad Request response.\n"}, {"uris": "src/main/java/org/ice4j/ice/ConnectivityCheckServer.java.ConnectivityCheckServer.[long]extractPriority(Request)", "name": "extractPriority", "arg_nums": 1, "params": [{"name": "request", "type": "Request"}], "return_type": "long", "signature": "private long extractPriority(Request request)", "original_string": "    private long extractPriority(Request request)\n        throws IllegalArgumentException\n    {\n        //make sure we have a priority attribute and ignore otherwise.\n        PriorityAttribute priorityAttr\n            = (PriorityAttribute)request.getAttribute(Attribute.PRIORITY);\n\n        //apply tie-breaking\n\n        //extract priority\n        if (priorityAttr == null)\n        {\n            logger.debug(() -> \"Received a connectivity check with\"\n                    + \"no PRIORITY attribute. Discarding.\");\n\n            throw new IllegalArgumentException(\"Missing PRIORITY attribute!\");\n        }\n\n        return priorityAttr.getPriority();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/ConnectivityCheckServer.java", "class_name": "ConnectivityCheckServer", "class_uri": "src/main/java/org/ice4j/ice/ConnectivityCheckServer.java.ConnectivityCheckServer", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "long", "classes": []}, "docstring": "\nReturns the value of the {@link PriorityAttribute} in <tt>request</tt> if\nthere is one or throws an <tt>IllegalArgumentException</tt> with the\ncorresponding message.\n\n@param request the {@link Request} whose priority we'd like to obtain.\n\n@return the value of the {@link PriorityAttribute} in <tt>request</tt> if\nthere is one\n\n@throws IllegalArgumentException if the request does not contain a\nPRIORITY attribute and the stack needs to respond with a 400 Bad Request\n{@link Response}.\n"}, {"uris": "src/main/java/org/ice4j/ice/ConnectivityCheckServer.java.ConnectivityCheckServer.[boolean]repairRoleConflict(StunMessageEvent)", "name": "repairRoleConflict", "arg_nums": 1, "params": [{"name": "evt", "type": "StunMessageEvent"}], "return_type": "boolean", "signature": "private boolean repairRoleConflict(StunMessageEvent evt)", "original_string": "    private boolean repairRoleConflict(StunMessageEvent evt)\n    {\n        final Message req = evt.getMessage();\n        final boolean selfIceControlling = parentAgent.isControlling();\n\n        // If the agent is in the controlling role, and the\n        // ICE-CONTROLLING attribute is present in the request:\n        final boolean bothControllingConflict = selfIceControlling &&\n            req.containsAttribute(Attribute.ICE_CONTROLLING);\n\n        // If the agent is in the controlled role, and the ICE-CONTROLLED\n        // attribute is present in the request:\n        final boolean bothControlledConflict = !selfIceControlling &&\n            req.containsAttribute(Attribute.ICE_CONTROLLED);\n\n        if (!(bothControllingConflict || bothControlledConflict))\n        {\n            // we don't have a role conflict\n            return true;\n        }\n\n        final long selfTieBreaker = parentAgent.getTieBreaker();\n\n        final IceControlAttribute theirIceControl = bothControllingConflict\n            ? (IceControlAttribute)req.getAttribute(Attribute.ICE_CONTROLLING)\n            : (IceControlAttribute)req.getAttribute(Attribute.ICE_CONTROLLED);\n\n        final long theirTieBreaker = theirIceControl.getTieBreaker();\n\n        // If the agent's tie-breaker is larger than or equal to the\n        // contents of the ICE control attribute, the agent generates\n        // a Binding error response and includes an ERROR-CODE attribute\n        // with a value of 487 (Role Conflict) but retains its role.\n        if (Long.compareUnsigned(selfTieBreaker, theirTieBreaker) >= 0)\n        {\n            final UsernameAttribute requestUserName = (UsernameAttribute)req\n                .getAttribute(Attribute.USERNAME);\n\n            final Response response =\n                MessageFactory.createBindingErrorResponse(\n                    ErrorCodeAttribute.ROLE_CONFLICT);\n\n            final Attribute messageIntegrityAttribute =\n                AttributeFactory.createMessageIntegrityAttribute(\n                    new String(requestUserName.getUsername()));\n            response.putAttribute(messageIntegrityAttribute);\n\n            try\n            {\n                stunStack.sendResponse(\n                    evt.getTransactionID().getBytes(),\n                    response,\n                    evt.getLocalAddress(),\n                    evt.getRemoteAddress());\n                return false;\n            }\n            catch(Exception exc)\n            {\n                //rethrow so that we would send a 500 response instead.\n                throw new RuntimeException(\"Failed to send a 487\", exc);\n            }\n        }\n        //If the agent's tie-breaker is less than the contents of the\n        //ICE control attribute, the agent toggles its ICE control role.\n        else\n        {\n            final String selfNextControlState\n                = selfIceControlling ? \"controlled\" : \"controlling\";\n            logger.trace(() ->\n                \"Switching to \" + selfNextControlState + \" because \" +\n                \" theirTieBreaker= \" + theirTieBreaker + \" and \" +\n                \"selfTieBreaker= \" + selfTieBreaker);\n            parentAgent.setControlling(!selfIceControlling);\n            return true;\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/ConnectivityCheckServer.java", "class_name": "ConnectivityCheckServer", "class_uri": "src/main/java/org/ice4j/ice/ConnectivityCheckServer.java.ConnectivityCheckServer", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nResolves a role conflicts by either sending a <tt>487 Role Conflict</tt>\nresponse or by changing this server's parent agent role. The method\nreturns <tt>true</tt> if the role conflict is silently resolved and\nprocessing can continue. It returns <tt>false</tt> if we had to reply\nwith a 487 and processing needs to stop until a repaired request is\nreceived.\n\n@param evt the {@link StunMessageEvent} containing the\n<tt>ICE-CONTROLLING</tt> or <tt>ICE-CONTROLLED</tt> attribute that\nallowed us to detect the role conflict.\n\n@return <tt>true</tt> if the role conflict is silently resolved and\nprocessing can continue and <tt>false</tt> otherwise.\n"}, {"uris": "src/main/java/org/ice4j/ice/ConnectivityCheckServer.java.ConnectivityCheckServer.[boolean]checkLocalUserName(String)", "name": "checkLocalUserName", "arg_nums": 1, "params": [{"name": "username", "type": "String"}], "return_type": "boolean", "signature": "public boolean checkLocalUserName(String username)", "original_string": "    public boolean checkLocalUserName(String username)\n    {\n        String ufrag = null;\n\n        int colon = username.indexOf(\":\");\n\n        if (colon < 0)\n        {\n            //caller gave us a ufrag\n            ufrag = username;\n        }\n        else\n        {\n            //caller gave us the entire username.\n            ufrag = username.substring(0, colon);\n        }\n\n        return ufrag.equals(parentAgent.getLocalUfrag());\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/ConnectivityCheckServer.java", "class_name": "ConnectivityCheckServer", "class_uri": "src/main/java/org/ice4j/ice/ConnectivityCheckServer.java.ConnectivityCheckServer", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nVerifies whether <tt>username</tt> is currently known to this server\nand returns <tt>true</tt> if so. Returns <tt>false</tt> otherwise.\n\n@param username the user name whose validity we'd like to check.\n\n@return <tt>true</tt> if <tt>username</tt> is known to this\n<tt>ConnectivityCheckServer</tt> and <tt>false</tt> otherwise.\n"}, {"uris": "src/main/java/org/ice4j/ice/ConnectivityCheckServer.java.ConnectivityCheckServer.[byte[]]getLocalKey(String)", "name": "getLocalKey", "arg_nums": 1, "params": [{"name": "username", "type": "String"}], "return_type": "byte[]", "signature": "public byte[] getLocalKey(String username)", "original_string": "    public byte[] getLocalKey(String username)\n    {\n        return\n            checkLocalUserName(username)\n                ? parentAgent.getLocalPassword().getBytes()\n                : null;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/ConnectivityCheckServer.java", "class_name": "ConnectivityCheckServer", "class_uri": "src/main/java/org/ice4j/ice/ConnectivityCheckServer.java.ConnectivityCheckServer", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "byte[]", "classes": []}, "docstring": "\nImplements the {@link CredentialsAuthority#getLocalKey(String)} method in\na way that would return this handler's parent agent password if\n<tt>username</tt> is either the local ufrag or the username that the\nagent's remote peer was expected to use.\n\n@param username the local ufrag that we should return a password for.\n\n@return this handler's parent agent local password if <tt>username</tt>\nequals the local ufrag and <tt>null</tt> otherwise.\n"}, {"uris": "src/main/java/org/ice4j/ice/ConnectivityCheckServer.java.ConnectivityCheckServer.[byte[]]getRemoteKey(String,String)", "name": "getRemoteKey", "arg_nums": 2, "params": [{"name": "username", "type": "String"}, {"name": "media", "type": "String"}], "return_type": "byte[]", "signature": "public byte[] getRemoteKey(String username, String media)", "original_string": "    public byte[] getRemoteKey(String username, String media)\n    {\n        IceMediaStream stream = parentAgent.getStream(media);\n        if (stream == null)\n        {\n            return null;\n        }\n\n        //support both the case where username is the local fragment or the\n        //entire user name.\n        int colon = username.indexOf(\":\");\n\n        if (colon < 0)\n        {\n            //caller gave us a ufrag\n            if (username.equals(stream.getRemoteUfrag()))\n                return stream.getRemotePassword().getBytes();\n        }\n        else\n        {\n            //caller gave us the entire username.\n            if (username.equals(parentAgent.generateLocalUserName(media)))\n            {\n                if (stream.getRemotePassword() != null)\n                    return stream.getRemotePassword().getBytes();\n            }\n        }\n        return null;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/ConnectivityCheckServer.java", "class_name": "ConnectivityCheckServer", "class_uri": "src/main/java/org/ice4j/ice/ConnectivityCheckServer.java.ConnectivityCheckServer", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "byte[]", "classes": []}, "docstring": "\nImplements the {@link CredentialsAuthority#getRemoteKey(String, String)}\nmethod in a way that would return this handler's parent agent remote\npassword if <tt>username</tt> is either the remote ufrag or the username\nthat we are expected to use when querying the remote peer.\n\n@param username the remote ufrag that we should return a password for.\n@param media the media name that we want to get remote key.\n\n@return this handler's parent agent remote password if <tt>username</tt>\nequals the remote ufrag and <tt>null</tt> otherwise.\n"}, {"uris": "src/main/java/org/ice4j/ice/ConnectivityCheckServer.java.ConnectivityCheckServer.[void]start()", "name": "start", "arg_nums": 0, "params": [], "return_type": "void", "signature": "public void start()", "original_string": "    public void start()\n    {\n        if (!started)\n        {\n            stunStack.addRequestListener(this);\n            started = true;\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/ConnectivityCheckServer.java", "class_name": "ConnectivityCheckServer", "class_uri": "src/main/java/org/ice4j/ice/ConnectivityCheckServer.java.ConnectivityCheckServer", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nStarts this <tt>ConnectivityCheckServer</tt>. If it is not currently\nrunning, does nothing.\n"}, {"uris": "src/main/java/org/ice4j/ice/ConnectivityCheckServer.java.ConnectivityCheckServer.[void]stop()", "name": "stop", "arg_nums": 0, "params": [], "return_type": "void", "signature": "public void stop()", "original_string": "    public void stop()\n    {\n        stunStack.removeRequestListener(this);\n        started = false;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/ConnectivityCheckServer.java", "class_name": "ConnectivityCheckServer", "class_uri": "src/main/java/org/ice4j/ice/ConnectivityCheckServer.java.ConnectivityCheckServer", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nStops this <tt>ConnectivityCheckServer</tt>. A stopped\n<tt>ConnectivityCheckServer</tt> can be restarted by calling\n{@link #start()} on it.\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[]Agent()", "name": "Agent", "arg_nums": 0, "params": [], "return_type": "", "signature": "public Agent()", "original_string": "    public Agent()\n    {\n        this(null, null);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nCreates an empty <tt>Agent</tt> with no streams, and no address.\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[]Agent(Logger)", "name": "Agent", "arg_nums": 1, "params": [{"name": "parentLogger", "type": "Logger"}], "return_type": "", "signature": "public Agent(Logger parentLogger)", "original_string": "    public Agent(Logger parentLogger)\n    {\n        this(null, parentLogger);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[]Agent(String,Logger)", "name": "Agent", "arg_nums": 2, "params": [{"name": "ufragPrefix", "type": "String"}, {"name": "parentLogger", "type": "Logger"}], "return_type": "", "signature": "public Agent(String ufragPrefix, Logger parentLogger)", "original_string": "    public Agent(String ufragPrefix, Logger parentLogger)\n    {\n        SecureRandom random = new SecureRandom();\n\n        String ufrag = ufragPrefix == null ? \"\" : ufragPrefix;\n        ufrag += new BigInteger(24, random).toString(32);\n        ufrag += BigInteger.valueOf(System.currentTimeMillis()).toString(32);\n        ufrag = ensureIceAttributeLength(ufrag, /* min */ 4, /* max */ 256);\n        this.ufrag = ufrag;\n        if (parentLogger != null)\n        {\n\n            logger = parentLogger.createChildLogger(\n                    this.getClass().getName(),\n                    Collections.singletonMap(\"ufrag\", this.ufrag));\n        }\n        else\n        {\n            logger = new LoggerImpl(Agent.class.getName(), new LogContext(\"ufrag\", this.ufrag));\n        }\n\n        connCheckServer = new ConnectivityCheckServer(this);\n        connCheckClient = new ConnectivityCheckClient(\n            this, agentTasksScheduler, agentTasksExecutor);\n\n        //add the FINGERPRINT attribute to all messages.\n        System.setProperty(StackProperties.ALWAYS_SIGN, \"true\");\n\n        password\n            = ensureIceAttributeLength(\n                    new BigInteger(128, random).toString(32),\n                    /* min */ 22, /* max */ 256);\n\n        tieBreaker = random.nextLong() & 0x7FFFFFFFFFFFFFFFL;\n        nominator = new DefaultNominator(this);\n\n        for (MappingCandidateHarvester harvester\n                    : MappingCandidateHarvesters.getHarvesters())\n        {\n            addCandidateHarvester(harvester);\n        }\n\n        logger.debug(() -> \"Created a new Agent: \" + this.toString() +\n            \" with ICE controlling role = \" + this.isControlling);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nCreates an empty <tt>Agent</tt> with no streams, and no address.\n@param ufragPrefix an optional prefix to the generated local ICE username\nfragment.\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[void]setTieBreaker(long)", "name": "setTieBreaker", "arg_nums": 1, "params": [{"name": "tieBreakerInput", "type": "long"}], "return_type": "void", "signature": "public void setTieBreaker(long tieBreakerInput)", "original_string": "    public void setTieBreaker(long tieBreakerInput)\n    {\n        tieBreaker = tieBreakerInput;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets the tie breaker value. Note that to this should be set early (before\nconnectivity checks start).\n@param tieBreakerInput the value to set.\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[IceMediaStream]createMediaStream(String)", "name": "createMediaStream", "arg_nums": 1, "params": [{"name": "mediaStreamName", "type": "String"}], "return_type": "IceMediaStream", "signature": "public IceMediaStream createMediaStream(String mediaStreamName)", "original_string": "    public IceMediaStream createMediaStream(String mediaStreamName)\n    {\n        logger.debug(() -> \"Create media stream for \" + mediaStreamName);\n\n        IceMediaStream mediaStream\n            = new IceMediaStream(Agent.this, mediaStreamName);\n\n        mediaStreams.put(mediaStreamName, mediaStream);\n\n        // Since we add a new stream, we must wait to add the component and the\n        // remote candidates before starting to \"RUN\" this Agent.\n        // This is useful if this Agent is already in COMPLETED state\n        // (isStarted() == true) due to a previous successful ICE procedure:\n        // this way incoming connectivity checks are registered in the\n        // preDiscoveredPairsQueue until this Agent is in RUNNING state.\n        this.setState(IceProcessingState.WAITING);\n\n        return mediaStream;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "IceMediaStream", "classes": []}, "docstring": "\nCreates a new media stream and stores it.\n\n@param mediaStreamName the name of the media stream\n\n@return the newly created and stored <tt>IceMediaStream</tt>\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[Component]createComponent(IceMediaStream,int,int,int)", "name": "createComponent", "arg_nums": 4, "params": [{"name": "stream", "type": "IceMediaStream"}, {"name": "preferredPort", "type": "int"}, {"name": "minPort", "type": "int"}, {"name": "maxPort", "type": "int"}], "return_type": "Component", "signature": "public Component createComponent(\n            IceMediaStream stream,\n            int preferredPort,\n            int minPort,\n            int maxPort)", "original_string": "    public Component createComponent(\n            IceMediaStream stream,\n            int preferredPort,\n            int minPort,\n            int maxPort)\n        throws IllegalArgumentException,\n               IOException,\n                BindException\n    {\n        return createComponent(\n                stream,\n                preferredPort, minPort, maxPort,\n                KeepAliveStrategy.SELECTED_ONLY,\n                config.getUseComponentSocket());\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Component", "classes": []}, "docstring": "\nCreates a new {@link Component} for the specified <tt>stream</tt> and\nallocates potentially all local candidates that should belong to it.\n\n@param stream the {@link IceMediaStream} that the new {@link Component}\nshould belong to.\n@param preferredPort the port number that should be tried first when\nbinding local <tt>Candidate</tt> sockets for this <tt>Component</tt>.\n@param minPort the port number where we should first try to bind before\nmoving to the next one (i.e. <tt>minPort + 1</tt>)\n@param maxPort the maximum port number where we should try binding\nbefore giving up and throwing an exception.\n\n@return the newly created {@link Component} and with a list containing\nall and only local candidates.\n\n@throws IllegalArgumentException if either <tt>minPort</tt> or\n<tt>maxPort</tt> is not a valid port number or if <tt>minPort &gt;\nmaxPort</tt>, or if <tt>transport</tt> is not currently supported.\n@throws IOException if an error occurs while the underlying resolver lib\nis using sockets.\n@throws BindException if we couldn't find a free port between\n<tt>minPort</tt> and <tt>maxPort</tt> before reaching the maximum allowed\nnumber of retries.\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[Component]createComponent(IceMediaStream,int,int,int,KeepAliveStrategy)", "name": "createComponent", "arg_nums": 5, "params": [{"name": "stream", "type": "IceMediaStream"}, {"name": "preferredPort", "type": "int"}, {"name": "minPort", "type": "int"}, {"name": "maxPort", "type": "int"}, {"name": "keepAliveStrategy", "type": "KeepAliveStrategy"}], "return_type": "Component", "signature": "public Component createComponent(\n        IceMediaStream stream,\n        int preferredPort,\n        int minPort,\n        int maxPort,\n        KeepAliveStrategy keepAliveStrategy)", "original_string": "    public Component createComponent(\n        IceMediaStream stream,\n        int preferredPort,\n        int minPort,\n        int maxPort,\n        KeepAliveStrategy keepAliveStrategy)\n        throws IllegalArgumentException,\n               IOException,\n               BindException\n    {\n        return createComponent(\n            stream,\n            preferredPort,\n            minPort,\n            maxPort,\n            keepAliveStrategy,\n            true);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Component", "classes": []}, "docstring": "\nCreates a new {@link Component} for the specified <tt>stream</tt> and\nallocates potentially all local candidates that should belong to it.\n\n@param stream the {@link IceMediaStream} that the new {@link Component}\nshould belong to.\n@param preferredPort the port number that should be tried first when\nbinding local <tt>Candidate</tt> sockets for this <tt>Component</tt>.\n@param minPort the port number where we should first try to bind before\nmoving to the next one (i.e. <tt>minPort + 1</tt>)\n@param maxPort the maximum port number where we should try binding\nbefore giving up and throwing an exception.\n@param keepAliveStrategy the keep-alive strategy, which dictates which\ncandidates pairs are going to be kept alive.\n\n@return the newly created {@link Component} and with a list containing\nall and only local candidates.\n\n@throws IllegalArgumentException if either <tt>minPort</tt> or\n<tt>maxPort</tt> is not a valid port number or if <tt>minPort &gt;\nmaxPort</tt>, or if <tt>transport</tt> is not currently supported.\n@throws IOException if an error occurs while the underlying resolver lib\nis using sockets.\n@throws BindException if we couldn't find a free port between\n<tt>minPort</tt> and <tt>maxPort</tt> before reaching the maximum allowed\nnumber of retries.\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[Component]createComponent(IceMediaStream,int,int,int,KeepAliveStrategy,boolean)", "name": "createComponent", "arg_nums": 6, "params": [{"name": "stream", "type": "IceMediaStream"}, {"name": "preferredPort", "type": "int"}, {"name": "minPort", "type": "int"}, {"name": "maxPort", "type": "int"}, {"name": "keepAliveStrategy", "type": "KeepAliveStrategy"}, {"name": "useComponentSocket", "type": "boolean"}], "return_type": "Component", "signature": "public Component createComponent(\n        IceMediaStream stream,\n        int preferredPort,\n        int minPort,\n        int maxPort,\n        KeepAliveStrategy keepAliveStrategy,\n        boolean useComponentSocket)", "original_string": "    public Component createComponent(\n        IceMediaStream stream,\n        int preferredPort,\n        int minPort,\n        int maxPort,\n        KeepAliveStrategy keepAliveStrategy,\n        boolean useComponentSocket)\n        throws IllegalArgumentException,\n               IOException,\n               BindException\n    {\n        Component component = stream.createComponent(keepAliveStrategy, useComponentSocket);\n\n        gatherCandidates(component, preferredPort, minPort, maxPort);\n\n        /*\n         * Lyubomir: After we've gathered the LocalCandidate for a Component and\n         * before we've made them available to the caller, we have to make sure\n         * that the ConnectivityCheckServer is started. If there's been a\n         * previous connectivity establishment which has completed, it has\n         * stopped the ConnectivityCheckServer. If the ConnectivityCheckServer is\n         * not started after we've made the gathered LocalCandidates available\n         * to the caller, the caller may send them and a connectivity check may\n         * arrive from the remote Agent.\n         */\n        connCheckServer.start();\n\n        return component;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Component", "classes": []}, "docstring": "\nCreates a new {@link Component} for the specified <tt>stream</tt> and\nallocates potentially all local candidates that should belong to it.\n\nIf 0, 0, 0 are specified for preferred, min and max port, an ephemeral port will be used instead.\n\n@param stream the {@link IceMediaStream} that the new {@link Component}\nshould belong to.\n@param preferredPort the port number that should be tried first when\nbinding local <tt>Candidate</tt> sockets for this <tt>Component</tt>.\n@param minPort the port number where we should first try to bind before\nmoving to the next one (i.e. <tt>minPort + 1</tt>)\n@param maxPort the maximum port number where we should try binding\nbefore giving up and throwing an exception.\n@param keepAliveStrategy the keep-alive strategy, which dictates which\ncandidates pairs are going to be kept alive.\n@param useComponentSocket whether to use the component socket mode (in\nwhich case the socket is available through the {@link Component} directly),\nor not (in which case the socket is available through the selected\n{@link CandidatePair}).\n\n@return the newly created {@link Component} and with a list containing\nall and only local candidates.\n\n@throws IllegalArgumentException if either <tt>minPort</tt> or\n<tt>maxPort</tt> is not a valid port number or if <tt>minPort &gt;\nmaxPort</tt>, or if <tt>transport</tt> is not currently supported.\n@throws IOException if an error occurs while the underlying resolver lib\nis using sockets.\n@throws BindException if we couldn't find a free port between\n<tt>minPort</tt> and <tt>maxPort</tt> before reaching the maximum allowed\nnumber of retries.\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[Component]createComponent(IceMediaStream,KeepAliveStrategy,boolean)", "name": "createComponent", "arg_nums": 3, "params": [{"name": "stream", "type": "IceMediaStream"}, {"name": "keepAliveStrategy", "type": "KeepAliveStrategy"}, {"name": "useComponentSocket", "type": "boolean"}], "return_type": "Component", "signature": "public Component createComponent(\n            IceMediaStream stream,\n            KeepAliveStrategy keepAliveStrategy,\n            boolean useComponentSocket)", "original_string": "    public Component createComponent(\n            IceMediaStream stream,\n            KeepAliveStrategy keepAliveStrategy,\n            boolean useComponentSocket)\n            throws IllegalArgumentException, IOException\n    {\n        return createComponent(stream, 0, 0, 0, keepAliveStrategy, useComponentSocket);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Component", "classes": []}, "docstring": "\nCreates a new {@link Component} for the specified {@code stream} and allocates potentially all local\ncandidates that should belong to it.\n\nIf dynamic ports are enabled, an ephemeral port will be used.\n\n@param stream the {@link IceMediaStream} that the new {@link Component} should belong to.\n@param keepAliveStrategy the keep-alive strategy, which dictates which\ncandidates pairs are going to be kept alive.\n@param useComponentSocket whether to use the component socket mode (in\nwhich case the socket is available through the {@link Component} directly),\nor not (in which case the socket is available through the selected {@link CandidatePair}).\n\n@return the newly created {@link Component} and with a list containing all and only local candidates.\n@throws IOException if an error occurs while the underlying resolver lib is using sockets.\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[CandidatePair]createCandidatePair(LocalCandidate,RemoteCandidate)", "name": "createCandidatePair", "arg_nums": 2, "params": [{"name": "local", "type": "LocalCandidate"}, {"name": "remote", "type": "RemoteCandidate"}], "return_type": "CandidatePair", "signature": "protected CandidatePair createCandidatePair(\n            LocalCandidate local,\n            RemoteCandidate remote)", "original_string": "    protected CandidatePair createCandidatePair(\n            LocalCandidate local,\n            RemoteCandidate remote)\n    {\n        return new CandidatePair(local, remote);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "CandidatePair", "classes": []}, "docstring": "\nInitializes a new {@link CandidatePair} instance from a\n{@link LocalCandidate} and a {@link RemoteCandidate}. The method\nrepresents a {@code CandidatePair} factory and is preferable to\nexplicitly calling the {@code CandidatePair} constructor because it\nallows this {@code Agent} to easily track the initialization of its\n{@code CandidatePair}s.\n\n@param local the {@code LocalCandidate} to initialize the new instance\nwith\n@param remote the {@code RemoteCandidate} to initialize the new instance\nwith\n@return a new {@code CandidatePair} instance initializes with\n{@code local} and {@code remote}\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[void]setUseDynamicPorts(boolean)", "name": "setUseDynamicPorts", "arg_nums": 1, "params": [{"name": "value", "type": "boolean"}], "return_type": "void", "signature": "public void setUseDynamicPorts(boolean value)", "original_string": "    public void setUseDynamicPorts(boolean value)\n    {\n        useDynamicPorts = value;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets the flag for whether this {@link Agent} instance should use dynamic ports.\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[void]gatherCandidates(Component,int,int,int)", "name": "gatherCandidates", "arg_nums": 4, "params": [{"name": "component", "type": "Component"}, {"name": "preferredPort", "type": "int"}, {"name": "minPort", "type": "int"}, {"name": "maxPort", "type": "int"}], "return_type": "void", "signature": "private void gatherCandidates( Component      component,\n                                   int            preferredPort,\n                                   int            minPort,\n                                   int            maxPort)", "original_string": "    private void gatherCandidates( Component      component,\n                                   int            preferredPort,\n                                   int            minPort,\n                                   int            maxPort)\n        throws IllegalArgumentException,\n               IOException\n    {\n        logger.info(\"Gathering candidates for component \" +\n                component.toShortString() +\".\");\n\n        if (useDynamicPorts)\n        {\n            hostCandidateHarvester.harvest(component, preferredPort, minPort, maxPort, Transport.UDP);\n        }\n        else\n        {\n            if (hostHarvesters.isEmpty())\n                logger.warn(\"No host harvesters available!\");\n        }\n\n        for (CandidateHarvester harvester : hostHarvesters)\n        {\n            harvester.harvest(component);\n        }\n\n        if (component.getLocalCandidateCount() == 0)\n            logger.warn(\"Failed to gather any host candidates!\");\n\n        //in case we are not trickling, apply other harvesters here\n        if (!isTrickling())\n        {\n            harvestingStarted = true; //raise a flag to warn on a second call.\n            harvesters.harvest(component);\n        }\n\n        logger.debug(() -> \"Candidate count in first harvest: \" +\n            component.getLocalCandidateCount());\n\n        // Emil: Because of trickle, we now assign foundations, compute\n        // priorities, and eliminate redundancies while adding candidates on a\n        // component. This means that we no longer need to do it here, where we\n        // did before.\n        //computeFoundations(component);\n        //component.prioritizeCandidates();\n        //component.eliminateRedundantCandidates();\n\n        //select the candidate to put in the media line.\n        component.selectDefaultCandidate();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nUses all <tt>CandidateHarvester</tt>s currently registered with this\n<tt>Agent</tt> to obtain whatever addresses they can discover.\n<p>\nNot that the method would only use existing harvesters so make sure\nyou've registered all harvesters that you would want to use before\ncalling it.\n</p>\nIf 0, 0, 0 are specified for preferred, min and max port, an ephemeral port will be used instead.\n\n@param component the <tt>Component</tt> that we'd like to gather\ncandidates for.\n@param preferredPort the port number that should be tried first when\nbinding local <tt>Candidate</tt> sockets for this <tt>Component</tt>.\n@param minPort the port number where we should first try to bind before\nmoving to the next one (i.e. <tt>minPort + 1</tt>)\n@param maxPort the maximum port number where we should try binding\nbefore giving up and throwing an exception.\n\n@throws IllegalArgumentException if either <tt>minPort</tt> or\n<tt>maxPort</tt> is not a valid port number or if <tt>minPort &gt;\nmaxPort</tt>.\n@throws IOException if an error occurs while the underlying resolver lib\nis gathering candidates and we end up without even a single one.\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[void]startCandidateTrickle(TrickleCallback)", "name": "startCandidateTrickle", "arg_nums": 1, "params": [{"name": "trickleCallback", "type": "TrickleCallback"}], "return_type": "void", "signature": "public void startCandidateTrickle(TrickleCallback trickleCallback)", "original_string": "    public void startCandidateTrickle(TrickleCallback trickleCallback)\n        throws IllegalStateException\n    {\n        if (!isTrickling())\n        {\n            throw new IllegalStateException(\n                \"Trying to start trickling without enabling it on the agent!\");\n        }\n\n        if (harvestingStarted)\n        {\n            logger.warn(\n                \"Hmmm ... why are you harvesting twice? You shouldn't be!\");\n        }\n\n        //create a list of components and start harvesting\n        List<Component> components = new LinkedList<>();\n\n        for (IceMediaStream stream : getStreams())\n        {\n            components.addAll(stream.getComponents());\n        }\n\n        harvesters.harvest(components, trickleCallback);\n\n        //tell the tricklers that we are done (the WebRTC way, with null):\n        trickleCallback.onIceCandidates(null);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nStarts an asynchronous(?) harvest across all components and reports newly\ndiscovered candidates to <tt>trickleCallback</tt>.\n\n@param trickleCallback the callback that will be notified for all newly\ndiscovered candidates.\n\n@throws IllegalStateException if we try calling this method without being\nin a trickling state.\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[void]startConnectivityEstablishment()", "name": "startConnectivityEstablishment", "arg_nums": 0, "params": [], "return_type": "void", "signature": "public void startConnectivityEstablishment()", "original_string": "    public void startConnectivityEstablishment()\n    {\n        synchronized(startLock)\n        {\n            logger.info(\"Start ICE connectivity establishment.\");\n            shutdown = false;\n            pruneNonMatchedStreams();\n\n            try\n            {\n                initCheckLists();\n            }\n            catch(ArithmeticException e)\n            {\n                setState(IceProcessingState.FAILED);\n                return;\n            }\n\n            //change state before we actually send checks so that we don't\n            //miss responses and hence the possibility to nominate a pair.\n            setState(IceProcessingState.RUNNING);\n\n            //if we have received connectivity checks before RUNNING state,\n            //trigger a check for those candidate pairs.\n            if (this.preDiscoveredPairsQueue.size() > 0)\n            {\n                logger.info(\n                        \"Trigger checks for pairs that were received before \"\n                            + \"running state\");\n\n                for (CandidatePair cp : preDiscoveredPairsQueue)\n                {\n                    triggerCheck(cp);\n                }\n\n                preDiscoveredPairsQueue.clear();\n            }\n\n            connCheckClient.startChecks();\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nInitializes all stream check lists and begins the checks.\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[void]pruneNonMatchedStreams()", "name": "pruneNonMatchedStreams", "arg_nums": 0, "params": [], "return_type": "void", "signature": "private void pruneNonMatchedStreams()", "original_string": "    private void pruneNonMatchedStreams()\n    {\n        // The previous behavior allows users of ice4j to run an Agent with\n        // remote candidates for only some of the streams/components, in which\n        // case the component without remote candidates are removed here, and\n        // so they do not cause an ICE failure if they fail to connect.\n        // In order to allow operation without remote candidates, we only prune\n        // if we detect that there is at least one component with some remote\n        // candidates.\n        boolean prune = false;\n        for (IceMediaStream stream : getStreams())\n        {\n            for (Component component : stream.getComponents())\n            {\n                if (component.getRemoteCandidateCount() > 0)\n                    prune = true;\n                if (prune)\n                    break;\n            }\n        }\n\n        if (prune)\n        {\n            for (IceMediaStream stream : getStreams())\n            {\n                for (Component component : stream.getComponents())\n                {\n                    if (component.getRemoteCandidateCount() == 0)\n                        stream.removeComponent(component);\n                }\n\n                if (stream.getComponentCount() == 0)\n                    removeStream(stream);\n            }\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\n<tt>Free()</tt>s and removes from this agent components or entire streams\nif they do not contain remote candidates. A possible reason for this\ncould be the fact that the remote party canceled some of the streams or\nthat it is using rtcp-mux or bundle.\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[boolean]isStarted()", "name": "isStarted", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "public boolean isStarted()", "original_string": "    public boolean isStarted()\n    {\n        return state != IceProcessingState.WAITING\n            && state != IceProcessingState.COMPLETED\n            && state != IceProcessingState.TERMINATED;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nIndicates whether this {@link Agent} is currently in the process of\nrunning connectivity checks and establishing connectivity. Connectivity\nestablishment is considered to have started after both {@link Agent}s\nhave exchanged their media descriptions. Determining whether the actual\nprocess has started is important, for example, when determining whether\na remote address we've just discovered is peer reflexive or not.\nIf ICE has started and we don't know about the address then we should\nadd it to the list of candidates. Otherwise we should hold to it until\nit does and check later.\n<p>\nNote that an {@link Agent} would be ready to and will send responses to\nconnectivity checks as soon as it streams get created, which is well\nbefore we actually start the checks.\n\n@return <tt>true</tt> after media descriptions have been exchanged both\nways and connectivity checks have started (regardless of their current\nstate) and <tt>false</tt> otherwise.\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[boolean]isOver()", "name": "isOver", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "public boolean isOver()", "original_string": "    public boolean isOver()\n    {\n        IceProcessingState state = getState();\n\n        return (state != null) && state.isOver();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nIndicates whether this {@link Agent} has finished ICE processing.\n\n@return <tt>true</tt> if ICE processing is in the {@link\nIceProcessingState#FAILED}, {@link IceProcessingState#COMPLETED} or\n{@link IceProcessingState#TERMINATED} and <tt>false</tt> otherwise.\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[IceProcessingState]getState()", "name": "getState", "arg_nums": 0, "params": [], "return_type": "IceProcessingState", "signature": "public IceProcessingState getState()", "original_string": "    public IceProcessingState getState()\n    {\n        return state;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "IceProcessingState", "classes": []}, "docstring": "\nReturns the state of ICE processing for this <tt>Agent</tt>.\n\n@return the state of ICE processing for this <tt>Agent</tt>.\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[void]addStateChangeListener(PropertyChangeListener)", "name": "addStateChangeListener", "arg_nums": 1, "params": [{"name": "l", "type": "PropertyChangeListener"}], "return_type": "void", "signature": "public void addStateChangeListener(PropertyChangeListener l)", "original_string": "    public void addStateChangeListener(PropertyChangeListener l)\n    {\n        synchronized (stateListeners)\n        {\n            if (!stateListeners.contains(l))\n                stateListeners.add(l);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nAdds <tt>l</tt> to the list of listeners tracking changes of the\n{@link IceProcessingState} of this <tt>Agent</tt>\n\n@param l the listener to register.\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[void]removeStateChangeListener(PropertyChangeListener)", "name": "removeStateChangeListener", "arg_nums": 1, "params": [{"name": "l", "type": "PropertyChangeListener"}], "return_type": "void", "signature": "public void removeStateChangeListener(PropertyChangeListener l)", "original_string": "    public void removeStateChangeListener(PropertyChangeListener l)\n    {\n        synchronized (stateListeners)\n        {\n            stateListeners.remove(l);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nRemoves <tt>l</tt> from the list of listeners tracking changes of the\n{@link IceProcessingState} of this <tt>Agent</tt>\n\n@param l the listener to remove.\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[void]fireStateChange(IceProcessingState,IceProcessingState)", "name": "fireStateChange", "arg_nums": 2, "params": [{"name": "oldState", "type": "IceProcessingState"}, {"name": "newState", "type": "IceProcessingState"}], "return_type": "void", "signature": "private void fireStateChange(IceProcessingState oldState,\n                                 IceProcessingState newState)", "original_string": "    private void fireStateChange(IceProcessingState oldState,\n                                 IceProcessingState newState)\n    {\n        PropertyChangeListener[] stateListenersCopy;\n\n        synchronized (stateListeners)\n        {\n            stateListenersCopy\n                = stateListeners.toArray(NO_STATE_CHANGE_LISTENERS);\n        }\n\n        if (stateListenersCopy.length != 0)\n        {\n            PropertyChangeEvent evt\n                = new PropertyChangeEvent(\n                        this,\n                        PROPERTY_ICE_PROCESSING_STATE,\n                        oldState, newState);\n\n            for (PropertyChangeListener l : stateListenersCopy)\n                l.propertyChange(evt);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCreates a new {@link PropertyChangeEvent} and delivers it to all\ncurrently registered state listeners.\n\n@param oldState the {@link IceProcessingState} we had before the change\n@param newState the {@link IceProcessingState} we had after the change\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[boolean]setState(IceProcessingState)", "name": "setState", "arg_nums": 1, "params": [{"name": "newState", "type": "IceProcessingState"}], "return_type": "boolean", "signature": "private boolean setState(IceProcessingState newState)", "original_string": "    private boolean setState(IceProcessingState newState)\n    {\n        IceProcessingState oldState;\n        synchronized (stateSyncRoot)\n        {\n            oldState = state;\n            this.state = newState;\n        }\n\n        if (!oldState.equals(newState))\n        {\n            logger.info(\"ICE state changed from \" + oldState + \" to \"\n                            + newState + \".\");\n            fireStateChange(oldState, newState);\n\n            return true;\n        }\n\n        return false;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nSets the {@link IceProcessingState} of this <tt>Agent</tt> to\n<tt>newState</tt> and triggers the corresponding change event.\n\n@param newState the new state of ICE processing for this <tt>Agent</tt>.\n@return <tt>true</tt> iff the state of this <tt>Agent</tt> changed as\na result of this call.\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[void]initCheckLists()", "name": "initCheckLists", "arg_nums": 0, "params": [], "return_type": "void", "signature": "protected void initCheckLists()", "original_string": "    protected void initCheckLists()\n    {\n        // First init the check list.\n        List<IceMediaStream> streams = getStreamsWithPendingConnectivityEstablishment();\n        int streamCount = streams.size();\n\n        if (streamCount > 0)\n        {\n            int maxCheckListSizePerStream = config.getMaxCheckListSize() / streamCount;\n\n            for (IceMediaStream stream : streams)\n            {\n                logger.info(\"Init checklist for stream \" + stream.getName());\n                stream.setMaxCheckListSize(maxCheckListSizePerStream);\n                stream.initCheckList();\n            }\n\n            // Init the states of the first media stream as per 5245\n            streams.get(0).getCheckList().computeInitialCheckListPairStates();\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCreates, initializes and orders the list of candidate pairs that would\nbe used for the connectivity checks for all components in this stream.\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[void]addCandidateHarvester(CandidateHarvester)", "name": "addCandidateHarvester", "arg_nums": 1, "params": [{"name": "harvester", "type": "CandidateHarvester"}], "return_type": "void", "signature": "public void addCandidateHarvester(CandidateHarvester harvester)", "original_string": "    public void addCandidateHarvester(CandidateHarvester harvester)\n    {\n        if (harvester.isHostHarvester())\n            hostHarvesters.add(harvester);\n        else\n            harvesters.add(harvester);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nAdds <tt>harvester</tt> to the list of harvesters that this agent will\nuse when gathering <tt>Candidate</tt>s.\n\n@param harvester a <tt>CandidateHarvester</tt> that this agent should use\nwhen gathering candidates.\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[CandidateHarvesterSet]getHarvesters()", "name": "getHarvesters", "arg_nums": 0, "params": [], "return_type": "CandidateHarvesterSet", "signature": "public CandidateHarvesterSet getHarvesters()", "original_string": "    public CandidateHarvesterSet getHarvesters()\n    {\n        return harvesters;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "CandidateHarvesterSet", "classes": []}, "docstring": "\nReturns the set of harvesters currently in use by this agent.\n\n@return the set of harvesters currently in use by this agent.\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[String]getLocalUfrag()", "name": "getLocalUfrag", "arg_nums": 0, "params": [], "return_type": "String", "signature": "public String getLocalUfrag()", "original_string": "    public String getLocalUfrag()\n    {\n        return ufrag;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns that user name that should be advertised in session descriptions\ncontaining ICE data from this agent.\n\n@return that user name that should be advertised in session descriptions\ncontaining ICE data from this agent.\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[String]getLocalPassword()", "name": "getLocalPassword", "arg_nums": 0, "params": [], "return_type": "String", "signature": "public String getLocalPassword()", "original_string": "    public String getLocalPassword()\n    {\n        return password;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns that password that should be advertised in session descriptions\ncontaining ICE data from this agent.\n\n@return that password that should be advertised in session descriptions\ncontaining ICE data from this agent.\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[String]generateLocalUserName(String)", "name": "generateLocalUserName", "arg_nums": 1, "params": [{"name": "media", "type": "String"}], "return_type": "String", "signature": "public String generateLocalUserName(String media)", "original_string": "    public String generateLocalUserName(String media)\n    {\n        IceMediaStream stream = getStream(media);\n        String ret;\n\n        if (stream == null)\n        {\n            ret = null;\n            logger.warn(\n                    \"Agent contains no IceMediaStream with name \" + media\n                        + \"!\");\n        }\n        else\n        {\n            String remoteUfrag = stream.getRemoteUfrag();\n\n            if (remoteUfrag == null)\n            {\n                ret = null;\n                logger.warn(\n                        \"Remote ufrag of IceMediaStream with name \" + media\n                            + \" is null!\");\n            }\n            else\n            {\n                ret = remoteUfrag + \":\" + getLocalUfrag();\n            }\n        }\n        return ret;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns the user name that this <tt>Agent</tt> should use in connectivity\nchecks for outgoing Binding Requests. According to RFC 5245, a Binding\nRequest serving as a connectivity check MUST utilize the STUN short term\ncredential mechanism. The username for the credential is formed by\nconcatenating the username fragment provided by the peer with the\nusername fragment of the agent sending the request, separated by a\ncolon (\":\").  The password is equal to the password provided by the peer.\nFor example, consider the case where agent L is the offerer, and agent R\nis the answerer.  Agent L included a username fragment of LFRAG for its\ncandidates, and a password of LPASS.  Agent R provided a username\nfragment of RFRAG and a password of RPASS.  A connectivity check from L\nto R (and its response of course) utilize the username RFRAG:LFRAG and a\npassword of RPASS.  A connectivity check from R to L (and its response)\nutilize the username LFRAG:RFRAG and a password of LPASS.\n\n@param media media name that we want to generate local username for.\n@return a user name that this <tt>Agent</tt> can use in connectivity\ncheck for outgoing Binding Requests.\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[String]generateRemoteUserName(String)", "name": "generateRemoteUserName", "arg_nums": 1, "params": [{"name": "media", "type": "String"}], "return_type": "String", "signature": "public String generateRemoteUserName(String media)", "original_string": "    public String generateRemoteUserName(String media)\n    {\n        IceMediaStream stream = getStream(media);\n\n        return\n            (stream == null)\n                ? null\n                : (getLocalUfrag() + \":\" + stream.getRemoteUfrag());\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns the user name that we should expect a peer <tt>Agent</tt> to use\nin connectivity checks for Binding Requests its sending our way.\nAccording to RFC 5245, a Binding Request serving as a connectivity check\nMUST utilize the STUN short term credential mechanism. The username for\nthe credential is formed by concatenating the username fragment provided\nby the peer with the username fragment of the agent sending the request,\nseparated by a colon (\":\").  The password is equal to the password\nprovided by the peer. For example, consider the case where agent\nL is the offerer, and agent R is the answerer.  Agent L\nincluded a username fragment of LFRAG for its candidates,\nand a password of LPASS.  Agent R provided a username fragment\nof RFRAG and a password of RPASS.  A connectivity check from L\nto R (and its response of course) utilize the username RFRAG:LFRAG and a\npassword of RPASS.  A connectivity check from R to L (and its response)\nutilize the username LFRAG:RFRAG and a password of LPASS.\n\n@param media media name that we want to generate local username for.\n@return a user name that a peer <tt>Agent</tt> would use in connectivity\ncheck for outgoing Binding Requests.\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[String]generateLocalUserName(RemoteCandidate,LocalCandidate)", "name": "generateLocalUserName", "arg_nums": 2, "params": [{"name": "remoteCandidate", "type": "RemoteCandidate"}, {"name": "localCandidate", "type": "LocalCandidate"}], "return_type": "String", "signature": "public String generateLocalUserName(RemoteCandidate remoteCandidate,\n            LocalCandidate localCandidate)", "original_string": "    public String generateLocalUserName(RemoteCandidate remoteCandidate,\n            LocalCandidate localCandidate)\n    {\n        return generateUserName(remoteCandidate, localCandidate);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns the user name that this <tt>Agent</tt> should use in connectivity\nchecks for outgoing Binding Requests in a Google Talk session.\n\n@param remoteCandidate remote candidate\n@param localCandidate local candidate\n@return a user name that this <tt>Agent</tt> can use in connectivity\ncheck for outgoing Binding Requests.\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[String]generateRemoteUserName(RemoteCandidate,LocalCandidate)", "name": "generateRemoteUserName", "arg_nums": 2, "params": [{"name": "remoteCandidate", "type": "RemoteCandidate"}, {"name": "localCandidate", "type": "LocalCandidate"}], "return_type": "String", "signature": "public String generateRemoteUserName(RemoteCandidate remoteCandidate,\n            LocalCandidate localCandidate)", "original_string": "    public String generateRemoteUserName(RemoteCandidate remoteCandidate,\n            LocalCandidate localCandidate)\n    {\n        return generateUserName(localCandidate, remoteCandidate);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns the user name that we should expect a peer <tt>Agent</tt> to use\nin connectivity checks for Binding Requests its sending our way in a\nGoogle Talk session.\n\n@param remoteCandidate remote candidate\n@param localCandidate local candidate\n@return a user name that a peer <tt>Agent</tt> would use in connectivity\ncheck for outgoing Binding Requests.\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[String]generateUserName(Candidate<?>,Candidate<?>)", "name": "generateUserName", "arg_nums": 2, "params": [{"name": "candidate1", "type": "Candidate<?>"}, {"name": "candidate2", "type": "Candidate<?>"}], "return_type": "String", "signature": "private String generateUserName(\n            Candidate<?> candidate1,\n            Candidate<?> candidate2)", "original_string": "    private String generateUserName(\n            Candidate<?> candidate1,\n            Candidate<?> candidate2)\n    {\n        /*\n         * FIXME Are the invocations of Candidate.getUfrag() necessary for their\n         * side effects alone? For example, to make sure that neither of the\n         * Candidates is null?\n         */\n        candidate1.getUfrag();\n        candidate2.getUfrag();\n\n        return null;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns the user name that we should expect a peer <tt>Agent</tt> to use\nin connectivity checks for Binding Requests its sending our way in a\nGoogle Talk session.\n\n@param candidate1 The first candidate of a candidatePair.\n@param candidate2 The second candidate of a candidatePair.\n@return a user name that a peer <tt>Agent</tt> would use in connectivity\ncheck for outgoing Binding Requests.\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[FoundationsRegistry]getFoundationsRegistry()", "name": "getFoundationsRegistry", "arg_nums": 0, "params": [], "return_type": "FoundationsRegistry", "signature": "public final FoundationsRegistry getFoundationsRegistry()", "original_string": "    public final FoundationsRegistry getFoundationsRegistry()\n    {\n        return foundationsRegistry;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "return_type": "FoundationsRegistry", "classes": []}, "docstring": "\nReturns the {@link FoundationsRegistry} this agent is using to assign\ncandidate foundations. We use the <tt>FoundationsRegistry</tt> to keep\ntrack of the foundations we assign within a session (i.e. the entire life\ntime of an <tt>Agent</tt>)\n@return the {@link FoundationsRegistry} of this agent\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[IceMediaStream]getStream(String)", "name": "getStream", "arg_nums": 1, "params": [{"name": "name", "type": "String"}], "return_type": "IceMediaStream", "signature": "public IceMediaStream getStream(String name)", "original_string": "    public IceMediaStream getStream(String name)\n    {\n        synchronized(mediaStreams)\n        {\n            return mediaStreams.get(name);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "IceMediaStream", "classes": []}, "docstring": "\nReturns the <tt>IceMediaStream</tt> with the specified <tt>name</tt> or\n<tt>null</tt> if no such stream has been registered with this\n<tt>Agent</tt> yet.\n\n@param name the name of the stream that we'd like to obtain a reference\nto.\n\n@return the <tt>IceMediaStream</tt> with the specified <tt>name</tt> or\n<tt>null</tt> if no such stream has been registered with this\n<tt>Agent</tt> yet.\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[List<String>]getStreamNames()", "name": "getStreamNames", "arg_nums": 0, "params": [], "return_type": "List<String>", "signature": "public List<String> getStreamNames()", "original_string": "    public List<String> getStreamNames()\n    {\n        synchronized(mediaStreams)\n        {\n            return new LinkedList<>(mediaStreams.keySet());\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<String>", "classes": []}, "docstring": "\nReturns a <tt>List</tt> containing the names of all currently registered\nmedia streams.\n\n@return a <tt>List</tt> containing the names of all currently registered\nmedia streams.\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[List<IceMediaStream>]getStreams()", "name": "getStreams", "arg_nums": 0, "params": [], "return_type": "List<IceMediaStream>", "signature": "public List<IceMediaStream> getStreams()", "original_string": "    public List<IceMediaStream> getStreams()\n    {\n        synchronized(mediaStreams)\n        {\n            return new LinkedList<>(mediaStreams.values());\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<IceMediaStream>", "classes": []}, "docstring": "\nReturns a <tt>List</tt> containing all <tt>IceMediaStream</tt>s currently\nregistered with this agent.\n\n@return a <tt>List</tt> containing all <tt>IceMediaStream</tt>s currently\nregistered with this agent.\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[int]getStreamCount()", "name": "getStreamCount", "arg_nums": 0, "params": [], "return_type": "int", "signature": "public int getStreamCount()", "original_string": "    public int getStreamCount()\n    {\n        synchronized(mediaStreams)\n        {\n            return mediaStreams.size();\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\nReturns the number of <tt>IceMediaStream</tt>s currently registered with\nthis agent.\n\n@return  the number of <tt>IceMediaStream</tt>s currently registered with\nthis agent.\n\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[List<IceMediaStream>]getStreamsWithPendingConnectivityEstablishment()", "name": "getStreamsWithPendingConnectivityEstablishment", "arg_nums": 0, "params": [], "return_type": "List<IceMediaStream>", "signature": "List<IceMediaStream> getStreamsWithPendingConnectivityEstablishment()", "original_string": "    List<IceMediaStream> getStreamsWithPendingConnectivityEstablishment()\n    {\n        /*\n         * Lyubomir: We want to support establishing connectivity for streams\n         * which have been created after connectivity has been established for\n         * previously created streams. That is why we will remove the streams\n         * which have their connectivity checks completed or failed i.e. these\n         * streams have been handled by a previous connectivity establishment.\n         */\n        List<IceMediaStream> streams = getStreams();\n        Iterator<IceMediaStream> streamIter = streams.iterator();\n\n        while (streamIter.hasNext())\n        {\n            IceMediaStream stream = streamIter.next();\n            CheckList checkList = stream.getCheckList();\n            CheckListState checkListState = checkList.getState();\n\n            if (CheckListState.COMPLETED.equals(checkListState)\n                    || CheckListState.FAILED.equals(checkListState))\n                streamIter.remove();\n        }\n        return streams;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "List<IceMediaStream>", "classes": []}, "docstring": "\nGets the <tt>IceMediaStream</tt>s registered with this <tt>Agent</tt> for\nwhich connectivity establishment is pending. For example, after a set of\n<tt>IceMediaStream</tt>s is registered with this <tt>Agent</tt>,\nconnectivity establishment completes for them and then a new set of\n<tt>IceMediaStream</tt>s is registered with this <tt>Agent</tt>, the\n<tt>IceMediaStream</tt>s with pending connectivity establishment are\nthose from the second set.\n\n@return a <tt>List</tt> of the <tt>IceMediaStream</tt>s registered with\nthis <tt>Agent</tt> for which connectivity is pending.\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[StunStack]getStunStack()", "name": "getStunStack", "arg_nums": 0, "params": [], "return_type": "StunStack", "signature": "public synchronized StunStack getStunStack()", "original_string": "    public synchronized StunStack getStunStack()\n    {\n        if (stunStack == null)\n            stunStack = new StunStack();\n        return stunStack;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "public synchronized", "marker_annotations": [], "non_marker_annotations": ["public", "synchronized"], "comments": [], "return_type": "StunStack", "classes": []}, "docstring": "\nGets the <tt>StunStack</tt> used by this <tt>Agent</tt>.\n\n@return the <tt>StunStack</tt> used by this <tt>Agent</tt>\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[void]setStunStack(StunStack)", "name": "setStunStack", "arg_nums": 1, "params": [{"name": "stunStack", "type": "StunStack"}], "return_type": "void", "signature": "public void setStunStack(StunStack stunStack)", "original_string": "    public void setStunStack(StunStack stunStack)\n    {\n        this.stunStack = stunStack;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets the <tt>StunStack</tt> used by this <tt>Agent</tt>.\n\n@param stunStack the stunStack to be used by this Agent.\n\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[int]getActiveCheckListCount()", "name": "getActiveCheckListCount", "arg_nums": 0, "params": [], "return_type": "int", "signature": "protected int getActiveCheckListCount()", "original_string": "    protected int getActiveCheckListCount()\n    {\n        synchronized(mediaStreams)\n        {\n            int i=0;\n            Collection<IceMediaStream> streams = mediaStreams.values();\n\n            for (IceMediaStream stream : streams)\n            {\n                if (stream.getCheckList().isActive())\n                    i++;\n            }\n\n            return i;\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\nReturns the number of {@link CheckList}s that are currently active.\n\n@return the number of {@link CheckList}s that are currently active.\n\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[String]toString()", "name": "toString", "arg_nums": 0, "params": [], "return_type": "String", "signature": "@Override\n    public String toString()", "original_string": "    @Override\n    public String toString()\n    {\n        StringBuilder buff = new StringBuilder(\"ICE Agent (stream-count=\");\n\n        buff.append(getStreamCount());\n        buff.append(\" ice-pwd:\").append(getLocalPassword());\n        buff.append(\" ice-ufrag:\").append(getLocalUfrag());\n        buff.append(\" tie-breaker:\").append(getTieBreaker());\n        buff.append(\"):\\n\");\n\n        for (IceMediaStream stream : getStreams())\n        {\n            buff.append(stream).append(\"\\n\");\n        }\n\n        return buff.toString();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns a <tt>String</tt> representation of this agent.\n\n@return a <tt>String</tt> representation of this agent.\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[long]getTieBreaker()", "name": "getTieBreaker", "arg_nums": 0, "params": [], "return_type": "long", "signature": "public long getTieBreaker()", "original_string": "    public long getTieBreaker()\n    {\n        return tieBreaker;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "long", "classes": []}, "docstring": "\nReturns this agent's tie-breaker number. The tie-breaker number is used\nin connectivity checks to detect and repair the case where both agents\nbelieve to have the controlling or the controlled role.\n\n@return  this agent's tie-breaker number\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[void]setControlling(boolean)", "name": "setControlling", "arg_nums": 1, "params": [{"name": "isControlling", "type": "boolean"}], "return_type": "void", "signature": "public void setControlling(boolean isControlling)", "original_string": "    public void setControlling(boolean isControlling)\n    {\n        if (this.isControlling != isControlling)\n        {\n            this.logger.info(() -> \"Changing agent \" + this.toString() +\n                \" role from controlling = \" + this.isControlling +\n                \" to controlling = \" + isControlling);\n        }\n\n        this.isControlling = isControlling;\n\n        //in case we have already initialized our check lists we'd need to\n        //recompute pair priorities.\n        for (IceMediaStream stream : getStreams())\n        {\n            CheckList list = stream.getCheckList();\n\n            if (list != null)\n            {\n                list.recomputePairPriorities();\n            }\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSpecifies whether this agent has the controlling role in an ICE exchange.\n\n@param isControlling <tt>true</tt> if this is to be the controlling\n<tt>Agent</tt> and <tt>false</tt> otherwise.\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[void]removeStream(IceMediaStream)", "name": "removeStream", "arg_nums": 1, "params": [{"name": "stream", "type": "IceMediaStream"}], "return_type": "void", "signature": "public void removeStream(IceMediaStream stream)", "original_string": "    public void removeStream(IceMediaStream stream)\n    {\n        synchronized (mediaStreams)\n        {\n            mediaStreams.remove(stream.getName());\n        }\n        /*\n         * XXX The invocation of IceMediaStream#free() on stream has been moved\n         * out of the synchronized block in order to reduce the chances of a\n         * deadlock. There was no obvious reason why it should stay in the\n         * synchronized block at the time of the modification.\n         */\n        stream.free();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nRemoves <tt>stream</tt> and all its child <tt>Component</tt>s and\n<tt>Candidate</tt>s from the this agent and releases all resources that\nthey had allocated (like sockets for example)\n\n@param stream the <tt>Component</tt> we'd like to remove and free.\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[boolean]isControlling()", "name": "isControlling", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "public boolean isControlling()", "original_string": "    public boolean isControlling()\n    {\n        return isControlling;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nDetermines whether this agent has the controlling role in an ICE\nexchange.\n\n@return <tt>true</tt> if this is to be the controlling <tt>Agent</tt>\nand <tt>false</tt> otherwise.\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[LocalCandidate]findLocalCandidate(TransportAddress)", "name": "findLocalCandidate", "arg_nums": 1, "params": [{"name": "address", "type": "TransportAddress"}], "return_type": "LocalCandidate", "signature": "public LocalCandidate findLocalCandidate(TransportAddress address)", "original_string": "    public LocalCandidate findLocalCandidate(TransportAddress address)\n    {\n        return findLocalCandidate(address, null);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "LocalCandidate", "classes": []}, "docstring": "\nReturns the local <tt>LocalCandidate</tt> with the specified\n<tt>address</tt> if it belongs to any of this {@link Agent}'s\nstreams or <tt>null</tt> if it doesn't.\n\n@param address the {@link TransportAddress} we are looking for.\n\n@return the local <tt>LocalCandidate</tt> with the specified\n<tt>address</tt> if it belongs to any of this {@link Agent}'s\nstreams or <tt>null</tt> if it doesn't.\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[LocalCandidate]findLocalCandidate(TransportAddress,LocalCandidate)", "name": "findLocalCandidate", "arg_nums": 2, "params": [{"name": "address", "type": "TransportAddress"}, {"name": "base", "type": "LocalCandidate"}], "return_type": "LocalCandidate", "signature": "public LocalCandidate findLocalCandidate(\n            TransportAddress address,\n            LocalCandidate base)", "original_string": "    public LocalCandidate findLocalCandidate(\n            TransportAddress address,\n            LocalCandidate base)\n    {\n        for (IceMediaStream stream : mediaStreams.values())\n        {\n            LocalCandidate localCandidate\n                    = stream.findLocalCandidate(address, base);\n\n            if (localCandidate != null)\n            {\n                return localCandidate;\n            }\n        }\n        return null;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "LocalCandidate", "classes": []}, "docstring": "\nReturns the local <tt>LocalCandidate</tt> with the specified\n<tt>address</tt> if it belongs to any of this {@link Agent}'s\nstreams or <tt>null</tt> if it doesn't. If {@code base} is also specified,\ntries to find a candidate whose base matches {@code base}.\n\n@param address the {@link TransportAddress} we are looking for.\n@param base an optional base to match.\n\n@return the local <tt>LocalCandidate</tt> with the specified\n<tt>address</tt> if it belongs to any of this {@link Agent}'s\nstreams or <tt>null</tt> if it doesn't.\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[RemoteCandidate]findRemoteCandidate(TransportAddress)", "name": "findRemoteCandidate", "arg_nums": 1, "params": [{"name": "remoteAddress", "type": "TransportAddress"}], "return_type": "RemoteCandidate", "signature": "public RemoteCandidate findRemoteCandidate(TransportAddress remoteAddress)", "original_string": "    public RemoteCandidate findRemoteCandidate(TransportAddress remoteAddress)\n    {\n        for (IceMediaStream stream : mediaStreams.values())\n        {\n            RemoteCandidate cnd = stream.findRemoteCandidate(remoteAddress);\n\n            if (cnd != null)\n            {\n                return cnd;\n            }\n        }\n        return null;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "RemoteCandidate", "classes": []}, "docstring": "\nReturns the remote <tt>Candidate</tt> with the specified\n<tt>remoteAddress</tt> if it belongs to any of this {@link Agent}'s\nstreams or <tt>null</tt> if it doesn't.\n\n@param remoteAddress the {@link TransportAddress} we are looking for.\n\n@return the remote <tt>Candidate</tt> with the specified\n<tt>remoteAddress</tt> if it belongs to any of this {@link Agent}'s\nstreams or <tt>null</tt> if it doesn't.\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[CandidatePair]findCandidatePair(TransportAddress,TransportAddress)", "name": "findCandidatePair", "arg_nums": 2, "params": [{"name": "localAddress", "type": "TransportAddress"}, {"name": "remoteAddress", "type": "TransportAddress"}], "return_type": "CandidatePair", "signature": "public CandidatePair findCandidatePair(TransportAddress localAddress,\n                                           TransportAddress remoteAddress)", "original_string": "    public CandidatePair findCandidatePair(TransportAddress localAddress,\n                                           TransportAddress remoteAddress)\n    {\n        synchronized(mediaStreams)\n        {\n            for (IceMediaStream stream : mediaStreams.values())\n            {\n                CandidatePair pair\n                    = stream.findCandidatePair(localAddress, remoteAddress);\n\n                if (pair != null )\n                    return pair;\n            }\n        }\n        return null;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "CandidatePair", "classes": []}, "docstring": "\nReturns the {@link CandidatePair} with the specified remote and local\naddresses or <tt>null</tt> if neither of the {@link CheckList}s in this\n{@link Agent}'s streams contain such a pair.\n\n@param localAddress the local {@link TransportAddress} of the pair we\nare looking for.\n@param remoteAddress the remote {@link TransportAddress} of the pair we\nare looking for.\n\n@return the {@link CandidatePair} with the specified remote and local\naddresses or <tt>null</tt> if neither of the {@link CheckList}s in this\n{@link Agent}'s streams contain such a pair.\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[CandidatePair]findCandidatePair(String,String)", "name": "findCandidatePair", "arg_nums": 2, "params": [{"name": "localUFrag", "type": "String"}, {"name": "remoteUFrag", "type": "String"}], "return_type": "CandidatePair", "signature": "public CandidatePair findCandidatePair(String localUFrag,\n                                           String remoteUFrag)", "original_string": "    public CandidatePair findCandidatePair(String localUFrag,\n                                           String remoteUFrag)\n    {\n        synchronized(mediaStreams)\n        {\n            for (IceMediaStream stream : mediaStreams.values())\n            {\n                CandidatePair pair\n                    = stream.findCandidatePair(localUFrag, remoteUFrag);\n\n                if (pair != null )\n                    return pair;\n            }\n        }\n        return null;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "CandidatePair", "classes": []}, "docstring": "\nReturns the {@link CandidatePair} with the specified remote and local\naddresses or <tt>null</tt> if neither of the {@link CheckList}s in this\n{@link Agent}'s streams contain such a pair.\n\n@param localUFrag local user fragment\n@param remoteUFrag remote user fragment\n@return the {@link CandidatePair} with the specified remote and local\naddresses or <tt>null</tt> if neither of the {@link CheckList}s in this\n{@link Agent}'s streams contain such a pair.\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[boolean]incomingCheckReceived(TransportAddress,TransportAddress,long,String,String,boolean)", "name": "incomingCheckReceived", "arg_nums": 6, "params": [{"name": "remoteAddress", "type": "TransportAddress"}, {"name": "localAddress", "type": "TransportAddress"}, {"name": "priority", "type": "long"}, {"name": "remoteUFrag", "type": "String"}, {"name": "localUFrag", "type": "String"}, {"name": "useCandidate", "type": "boolean"}], "return_type": "boolean", "signature": "protected boolean incomingCheckReceived(TransportAddress remoteAddress,\n                                         TransportAddress localAddress,\n                                         long             priority,\n                                         String           remoteUFrag,\n                                         String           localUFrag,\n                                         boolean          useCandidate)", "original_string": "    protected boolean incomingCheckReceived(TransportAddress remoteAddress,\n                                         TransportAddress localAddress,\n                                         long             priority,\n                                         String           remoteUFrag,\n                                         String           localUFrag,\n                                         boolean          useCandidate)\n    {\n        String ufrag = null;\n        LocalCandidate localCandidate = findLocalCandidate(localAddress);\n\n        if (localCandidate == null)\n        {\n            logger.info(\"No localAddress for this incoming checks: \" +\n                    localAddress);\n            return false;\n        }\n\n        Component parentComponent = localCandidate.getParentComponent();\n        RemoteCandidate remoteCandidate\n            = new RemoteCandidate(\n                remoteAddress,\n                parentComponent,\n                CandidateType.PEER_REFLEXIVE_CANDIDATE,\n                foundationsRegistry.obtainFoundationForPeerReflexiveCandidate(),\n                priority,\n                // We can not know the related candidate of a remote peer\n                // reflexive candidate. We must set it to \"null\".\n                null,\n                ufrag);\n\n        CandidatePair triggeredPair\n            = createCandidatePair(localCandidate, remoteCandidate);\n\n        logger.debug(() -> \"set use-candidate \" + useCandidate + \" for pair \" +\n            triggeredPair.toRedactedShortString());\n        if (useCandidate)\n        {\n            triggeredPair.setUseCandidateReceived();\n        }\n\n        synchronized(startLock)\n        {\n            if (state == IceProcessingState.WAITING)\n            {\n                logger.debug(() -> \"Receive STUN checks before our ICE has started\");\n                //we are not started yet so we'd better wait until we get the\n                //remote candidates in case we are holding to a new PR one.\n                this.preDiscoveredPairsQueue.add(triggeredPair);\n            }\n            else if (state == IceProcessingState.FAILED)\n            {\n                // Failure is permanent, currently.\n            }\n            else //Running, Connected or Terminated.\n            {\n                logger.debug(() -> \"Received check from \"\n                    + triggeredPair.toRedactedShortString() + \" triggered a check.\");\n\n                // We have been started, and have not failed (yet). If this is\n                // a new pair, handle it (even if we have already completed).\n                return triggerCheck(triggeredPair);\n            }\n        }\n        return true;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nNotifies the implementation that the {@link ConnectivityCheckServer} has\njust received a message on <tt>localAddress</tt> originating at\n<tt>remoteAddress</tt> carrying the specified <tt>priority</tt>. This\nwill cause us to schedule a triggered check for the corresponding\nremote candidate and potentially to the discovery of a PEER-REFLEXIVE\ncandidate.\n\n@param remoteAddress the address that we've just seen, and that is\npotentially a peer-reflexive address.\n@param localAddress the address that we were contacted on.\n@param priority the priority that the remote party assigned to\n@param remoteUFrag the user fragment that we should be using when and if\nwe decide to send a check to <tt>remoteAddress</tt>.\n@param localUFrag local user fragment\n@param useCandidate indicates whether the incoming check\n{@link org.ice4j.message.Request} contained the USE-CANDIDATE ICE\nattribute.\n@return Whether the response to the check should get a success response\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[boolean]triggerCheck(CandidatePair)", "name": "triggerCheck", "arg_nums": 1, "params": [{"name": "triggerPair", "type": "CandidatePair"}], "return_type": "boolean", "signature": "private boolean triggerCheck(CandidatePair triggerPair)", "original_string": "    private boolean triggerCheck(CandidatePair triggerPair)\n    {\n        //first check whether we already know about the remote address in case\n        //we've just discovered a peer-reflexive candidate.\n        CandidatePair knownPair\n            = findCandidatePair(\n                triggerPair.getLocalCandidate().getTransportAddress(),\n                triggerPair.getRemoteCandidate().getTransportAddress());\n\n        IceMediaStream parentStream = triggerPair.getLocalCandidate()\n            .getParentComponent().getParentStream();\n\n        if (knownPair != null)\n        {\n            boolean useCand = triggerPair.useCandidateReceived();\n\n            //if the incoming request contained a USE-CANDIDATE attribute then\n            //make sure we don't lose this piece of info.\n            if (useCand)\n                knownPair.setUseCandidateReceived();\n\n            triggerPair = knownPair;\n\n            //we already know about the remote address so we only need to\n            //trigger a check for the existing pair\n\n            if (knownPair.getState() == CandidatePairState.SUCCEEDED )\n            {\n                //7.2.1.5. Updating the Nominated Flag\n                if (!isControlling() && useCand)\n                {\n                    logger.debug(() -> \"update nominated flag\");\n                    // If the Binding request received by the agent had the\n                    // USE-CANDIDATE attribute set, and the agent is in the\n                    // controlled role, the agent looks at the state of the\n                    // pair ....\n                    // If the state of this pair is Succeeded, it means that a\n                    // previous check generated by this pair produced a\n                    // successful response. This would have caused the agent to\n                    // construct a valid pair when that success response was\n                    // received. The agent now sets the nominated flag in the\n                    // valid pair to true.\n                    nominationConfirmed( triggerPair );\n\n                    //the above may have caused us to exit, and so we need to\n                    //make the call below in order to make sure that we update\n                    //ICE processing state.\n                    checkListStatesUpdated();\n                }\n\n                return true;\n            }\n\n            // RFC 5245: If the state of that pair is In-Progress, the agent\n            // cancels the in-progress transaction.\n            if (knownPair.getState() == CandidatePairState.IN_PROGRESS )\n            {\n                TransactionID checkTransaction\n                    = knownPair.getConnectivityCheckTransaction();\n\n                getStunStack().cancelTransaction(checkTransaction);\n            }\n        }\n        else\n        {\n            //it appears that we've just discovered a peer-reflexive address.\n            // RFC 5245: If the pair is not already on the check list:\n            // The pair is inserted into the check list based on its priority\n            // Its state is set to Waiting [and it] is enqueued into the\n            // triggered check queue.\n            //\n            // Local addition: if we're already stopped, we're never going to send the\n            // check for the triggered pair, so don't enqueue it.\n            if (connCheckClient.isStopped())\n            {\n                return false;\n            }\n            if (triggerPair.getParentComponent().getSelectedPair() == null)\n                logger.info(\"Add peer CandidatePair with new reflexive \" +\n                        \"address to checkList: \" + triggerPair.toRedactedString());\n            parentStream.addToCheckList(triggerPair);\n        }\n\n        // RFC 5245: The agent MUST create a new connectivity check for that\n        // pair (representing a new STUN Binding request transaction) by\n        // enqueueing the pair in the triggered check queue.  The state of\n        // the pair is then changed to Waiting.\n        // Emil: This actually applies for all cases.\n        /*\n         * Lyubomir: The connectivity checks for a CheckList are started\n         * elsewhere as soon as and only if the CheckList changes from frozen\n         * to unfrozen. Since CheckList#scheduleTriggeredCheck will change\n         * triggerPair to Waiting and will thus unfreeze its CheckList, make\n         * sure that the connectivity checks for the CheckList are started.\n         * Otherwise, the connectivity checks for the CheckList may never be\n         * started (which may make the Agent remain running forever).\n         */\n        CheckList checkList = parentStream.getCheckList();\n        boolean wasFrozen = checkList.isFrozen();\n\n        checkList.scheduleTriggeredCheck(triggerPair);\n        if (wasFrozen && !checkList.isFrozen())\n            connCheckClient.startChecks(checkList);\n\n        return true;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nEither queues a triggered check for <tt>triggeredPair</tt> or, in case\nthere's already a pair with the specified remote and local addresses,\nputs it in the queue instead.\n\n@param triggerPair the pair containing the local and remote candidate\nthat we'd need to trigger a check for.\n@return Whether a triggered check was started\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[void]validatePair(CandidatePair)", "name": "validatePair", "arg_nums": 1, "params": [{"name": "validPair", "type": "CandidatePair"}], "return_type": "void", "signature": "protected void validatePair(CandidatePair validPair)", "original_string": "    protected void validatePair(CandidatePair validPair)\n    {\n        Component parentComponent = validPair.getParentComponent();\n        IceMediaStream parentStream = parentComponent.getParentStream();\n\n        parentStream.addToValidList(validPair);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nAdds <tt>pair</tt> to that list of valid candidates for its parent\nstream.\n\n@param validPair the {@link CandidatePair} we'd like to validate.\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[void]nominate(CandidatePair)", "name": "nominate", "arg_nums": 1, "params": [{"name": "pair", "type": "CandidatePair"}], "return_type": "void", "signature": "public synchronized void nominate(CandidatePair pair)", "original_string": "    public synchronized void nominate(CandidatePair pair)\n        throws IllegalStateException\n    {\n        if (!isControlling())\n        {\n            throw new IllegalStateException(\n                    \"Only controlling agents can nominate pairs\");\n        }\n\n        Component parentComponent = pair.getParentComponent();\n        IceMediaStream parentStream = parentComponent.getParentStream();\n\n        //If the pair is not already nominated and if its parent component\n        //does not already contain a nominated pair - nominate it.\n        if (!pair.isNominated()\n              && !parentStream.validListContainsNomineeForComponent(\n                      parentComponent))\n        {\n            logger.info(\"verify if nominated pair answer again\");\n            pair.nominate();\n            parentStream.getCheckList().scheduleTriggeredCheck(pair);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "public synchronized", "marker_annotations": [], "non_marker_annotations": ["public", "synchronized"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nRaises <tt>pair</tt>'s nomination flag and schedules a triggered check.\nApplications only need to use this method if they disable this\n<tt>Agent</tt>'s internal nomination and implement their own nominator\nand turn off nominations in this agent.\n\n@param pair the {@link CandidatePair} that we'd like to nominate and that\nwe'd like to schedule a triggered check for.\n\n@throws IllegalStateException if this <tt>Agent</tt> is not a controlling\nagent and can therefore not nominate pairs.\n\n@see Agent#setNominationStrategy(NominationStrategy)\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[NominationStrategy]getNominationStrategy()", "name": "getNominationStrategy", "arg_nums": 0, "params": [], "return_type": "NominationStrategy", "signature": "public NominationStrategy getNominationStrategy()", "original_string": "    public NominationStrategy getNominationStrategy()\n    {\n        return this.nominator.getStrategy();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "NominationStrategy", "classes": []}, "docstring": "\nReturns the {@link NominationStrategy} that we use in order to\ndecide if and when we should nominate valid pairs.\n\n@return the strategy that we are using for nominating\nvalid {@link CandidatePair}s.\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[void]setNominationStrategy(NominationStrategy)", "name": "setNominationStrategy", "arg_nums": 1, "params": [{"name": "strategy", "type": "NominationStrategy"}], "return_type": "void", "signature": "public void setNominationStrategy(NominationStrategy strategy)", "original_string": "    public void setNominationStrategy(NominationStrategy strategy)\n    {\n        this.nominator.setStrategy(strategy);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSpecifies the {@link NominationStrategy} that we should use in order to\ndecide if and when we should nominate valid pairs.\n\n@param strategy the strategy that we'd like to use for nominating\nvalid {@link CandidatePair}s.\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[void]nominationConfirmed(CandidatePair)", "name": "nominationConfirmed", "arg_nums": 1, "params": [{"name": "nominatedPair", "type": "CandidatePair"}], "return_type": "void", "signature": "protected void nominationConfirmed(CandidatePair nominatedPair)", "original_string": "    protected void nominationConfirmed(CandidatePair nominatedPair)\n    {\n        nominatedPair.nominate();\n\n        Component parentComponent = nominatedPair.getParentComponent();\n        IceMediaStream parentStream = parentComponent.getParentStream();\n        CheckList checkList = parentStream.getCheckList();\n\n        if ( checkList.getState() == CheckListState.RUNNING )\n        {\n            checkList.handleNominationConfirmed(nominatedPair);\n        }\n\n        //Once there is at least one nominated pair in the valid list for\n        //every component of the media stream and the state of the\n        //check list is Running\n        if (parentStream.allComponentsHaveSelected()\n           && checkList.getState() == CheckListState.RUNNING)\n        {\n            //The agent MUST change the state of processing for its check\n            //list for that media stream to Completed.\n            checkList.setState(CheckListState.COMPLETED);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nIndicates that we have received a response to a request that either\ncontained the <tt>USE-CANDIDATE</tt> attribute or was triggered by an\nincoming request that did.\n\n@param nominatedPair the {@link CandidatePair} whose nomination has\njust been confirmed.\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[void]checkListStatesUpdated()", "name": "checkListStatesUpdated", "arg_nums": 0, "params": [], "return_type": "void", "signature": "protected void checkListStatesUpdated()", "original_string": "    protected void checkListStatesUpdated()\n    {\n        boolean allListsEnded = true;\n        boolean atLeastOneListSucceeded = false;\n\n        if (getState().isEstablished())\n        {\n            return;\n        }\n\n        List<IceMediaStream> streams = getStreams();\n\n        for (IceMediaStream stream : streams)\n        {\n            CheckListState checkListState = stream.getCheckList().getState();\n\n            if (checkListState == CheckListState.RUNNING)\n            {\n                allListsEnded = false;\n                break;\n            }\n            else if (checkListState == CheckListState.COMPLETED)\n            {\n                logger.info(\"CheckList of stream \" + stream.getName() +\n                        \" is COMPLETED\");\n                atLeastOneListSucceeded = true;\n            }\n        }\n\n\n        if (!allListsEnded)\n        {\n            return;\n        }\n\n        if (!atLeastOneListSucceeded)\n        {\n            //all lists ended but none succeeded. No love today ;(\n            if (logger.isInfoEnabled())\n            {\n                if (connCheckClient.isAlive()\n                    || connCheckServer.isAlive())\n                {\n                    logger.info(\"Suspicious ICE connectivity failure. Checks\" +\n                        \" failed but the remote end was able to reach us.\");\n                }\n\n                logger.info(\"ICE state is FAILED\");\n            }\n\n            terminate(IceProcessingState.FAILED);\n            return;\n        }\n\n        //Once the state of each check list is Completed:\n        //The agent sets the state of ICE processing overall to Completed.\n        if (getState() != IceProcessingState.RUNNING)\n        {\n            //Oh, seems like we already did this.\n            return;\n        }\n\n        // The race condition in which another thread enters COMPLETED right\n        // under our nose here has been observed (and not in a single instance)\n        // So check that we did indeed just trigger the change.\n        if (!setState(IceProcessingState.COMPLETED))\n        {\n            return;\n        }\n\n        // keep ICE running (answer STUN Binding requests, send STUN Binding\n        // indications or requests)\n        scheduleStunKeepAlive();\n\n        scheduleTermination();\n\n        //print logs for the types of addresses we chose.\n        logCandTypes();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nAfter updating check list states as a result of an incoming response\nor a timeout event the method goes through all check lists and tries\nto assess the state of ICE processing.\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[void]logCandTypes()", "name": "logCandTypes", "arg_nums": 0, "params": [], "return_type": "void", "signature": "private void logCandTypes()", "original_string": "    private void logCandTypes()\n    {\n        List<IceMediaStream> strms = getStreams();\n\n        for (IceMediaStream stream : strms)\n        {\n            for (Component component : stream.getComponents())\n            {\n                CandidatePair selectedPair = component.getSelectedPair();\n\n                StringBuffer buf\n                    = new StringBuffer( \"Harvester used for selected pair for \");\n                buf.append(component.toShortString());\n                buf.append(\": \");\n\n                if (selectedPair == null)\n                {\n                    buf.append(\"none (conn checks failed)\");\n                    logger.info(buf.toString());\n                    continue;\n                }\n\n                Candidate<?> localCnd = selectedPair.getLocalCandidate();\n\n                TransportAddress serverAddr = localCnd.getStunServerAddress();\n\n                buf.append(localCnd.getType());\n\n                if (serverAddr != null)\n                {\n                    buf.append(\" (STUN server = \");\n                    buf.append(serverAddr);\n                    buf.append(\")\");\n                }\n                else\n                {\n                    TransportAddress relayAddr\n                        = localCnd.getRelayServerAddress();\n\n                    if (relayAddr != null)\n                    {\n                        buf.append(\" (relay = \");\n                        buf.append(relayAddr);\n                        buf.append(\")\");\n                    }\n                }\n                logger.info(buf.toString());\n            }\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nGoes through all streams and components and prints into the logs the type\nof local candidates that were selected as well as the server that\nwere used (if any) to obtain them.\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[int]countHostCandidates()", "name": "countHostCandidates", "arg_nums": 0, "params": [], "return_type": "int", "signature": "protected int countHostCandidates()", "original_string": "    protected int countHostCandidates()\n    {\n        int num = 0;\n\n        synchronized (mediaStreams)\n        {\n            Collection<IceMediaStream> streamsCol = mediaStreams.values();\n\n            for (IceMediaStream stream : streamsCol)\n            {\n                num += stream.countHostCandidates();\n            }\n        }\n\n        return num;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\nReturns the number of host {@link Candidate}s in this {@link Agent}.\n\n@return the number of host {@link Candidate}s in this {@link Agent}.\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[void]setTa(long)", "name": "setTa", "arg_nums": 1, "params": [{"name": "taValue", "type": "long"}], "return_type": "void", "signature": "public void setTa(long taValue)", "original_string": "    public void setTa(long taValue)\n    {\n        this.taValue = taValue;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nLets the application specify a custom value for the <tt>Ta</tt> timer\nso that we don't calculate one.\n\n@param taValue the value of the <tt>Ta</tt> timer that the application\nwould like us to use rather than calculate one.\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[long]calculateTa()", "name": "calculateTa", "arg_nums": 0, "params": [], "return_type": "long", "signature": "protected long calculateTa()", "original_string": "    protected long calculateTa()\n    {\n        //if application specified a value - use it. other wise return ....\n        // eeeer ... a \"dynamically\" calculated one ;)\n        if (taValue != -1)\n            return taValue;\n\n        /* RFC 5245 says that Ta is:\n         *\n         *     Ta_i = (stun_packet_size / rtp_packet_size) * rtp_ptime\n         *\n         *                               1\n         *         Ta = MAX (20ms, ------------------- )\n         *                               k\n         *                             ----\n         *                             \\        1\n         *                              >    ------\n         *                             /       Ta_i\n         *                             ----\n         *                              i=1\n         *\n         * In this implementation we assume equal values of\n         * stun_packet_size and rtp_packet_size. rtp_ptime is also assumed to be\n         * 20ms. One day we should probably let the application modify them.\n         * Until then however the above formula would always be equal to.\n         *                            1\n         *         Ta = MAX (20ms, ------- )\n         *                            k\n         *                           ---\n         *                            20\n         * which gives us Ta = MAX (20ms, 20/k) which is always 20.\n         */\n        return 20;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "long", "classes": []}, "docstring": "\nCalculates the value of the <tt>Ta</tt> pace timer according to the\nnumber and type of {@link IceMediaStream}s this agent will be using.\n<p>\nDuring the gathering phase of ICE (Section 4.1.1) and while ICE is\nperforming connectivity checks (Section 7), an agent sends STUN and\nTURN transactions.  These transactions are paced at a rate of one\nevery <tt>Ta</tt> milliseconds.\n<p>\nAs per RFC 5245, the value of <tt>Ta</tt> should be configurable so if\nsomeone has set a value of their own, we return that value rather than\ncalculating a new one.\n\n@return the value of the <tt>Ta</tt> pace timer according to the\nnumber and type of {@link IceMediaStream}s this agent will be using or\na pre-configured value if the application has set one.\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[long]calculateStunHarvestRTO()", "name": "calculateStunHarvestRTO", "arg_nums": 0, "params": [], "return_type": "long", "signature": "protected long calculateStunHarvestRTO()", "original_string": "    protected long calculateStunHarvestRTO()\n    {\n        /* RFC 5245 says:\n         * RTO = MAX (100ms, Ta * (number of pairs))\n         * where the number of pairs refers to the number of pairs of candidates\n         * with STUN or TURN servers.\n         *\n         * Go figure what \"pairs of candidates with STUN or TURN servers\" means.\n         * Let's assume they meant the number stun transactions we'll start\n         * while harvesting.\n         */\n\n        return Math.max(100, calculateTa() * 2 * countHostCandidates());\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "long", "classes": []}, "docstring": "\nCalculates the value of the retransmission timer to use in STUN\ntransactions, while harvesting addresses (not to confuse with the RTO\nfor the STUN transactions used in connectivity checks).\n\n@return the value of the retransmission timer to use in STUN\ntransactions, while harvesting addresses.\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[long]calculateStunConnCheckRTO()", "name": "calculateStunConnCheckRTO", "arg_nums": 0, "params": [], "return_type": "long", "signature": "protected long calculateStunConnCheckRTO()", "original_string": "    protected long calculateStunConnCheckRTO()\n    {\n        /* RFC 5245 says:\n         * For connectivity checks, RTO SHOULD be configurable and SHOULD have\n         * a default of:\n         *\n         * RTO = MAX (100ms, Ta*N * (Num-Waiting + Num-In-Progress))\n         *\n         * where Num-Waiting is the number of checks in the check list in the\n         * Waiting state, Num-In-Progress is the number of checks in the\n         * In-Progress state, and N is the number of checks to be performed.\n         *\n         * Emil: I am not sure I like the formula so we'll simply be returning\n         * 100 for the time being.\n         */\n        return 100;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "long", "classes": []}, "docstring": "\nCalculates the value of the retransmission timer to use in STUN\ntransactions, used in connectivity checks (not to confused with the RTO\nfor the STUN address harvesting).\n\n@return the value of the retransmission timer to use in STUN connectivity\ncheck transactions..\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[void]scheduleTermination()", "name": "scheduleTermination", "arg_nums": 0, "params": [], "return_type": "void", "signature": "private void scheduleTermination()", "original_string": "    private void scheduleTermination()\n    {\n        /*\n         * RFC 5245 says: Once ICE processing has reached the Completed state for\n         * all peers for media streams using those candidates, the agent SHOULD\n         * wait an additional three seconds, and then it MAY cease responding to\n         * checks or generating triggered checks on that candidate.  It MAY free\n         * the candidate at that time.\n         * <p>\n         * This method is scheduling such a termination.\n         */\n        boolean runTerminationImmediately = false;\n\n        synchronized (terminationFutureSyncRoot)\n        {\n            if (terminationFuture == null)\n            {\n                long terminationDelay = config.getTerminationDelay().toMillis();\n\n                if (terminationDelay > 0)\n                {\n                    terminationFuture\n                        = agentTasksScheduler.schedule(\n                            terminationRunnable,\n                            terminationDelay,\n                            TimeUnit.MILLISECONDS);\n                }\n                else\n                {\n                    runTerminationImmediately = true;\n                }\n            }\n        }\n\n        if (runTerminationImmediately)\n        {\n            terminationRunnable.run();\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nInitializes and starts the {@link #terminationFuture}\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[void]scheduleStunKeepAlive()", "name": "scheduleStunKeepAlive", "arg_nums": 0, "params": [], "return_type": "void", "signature": "private void scheduleStunKeepAlive()", "original_string": "    private void scheduleStunKeepAlive()\n    {\n        boolean noKeepAlives\n            = StackProperties.getBoolean(\n                StackProperties.NO_KEEP_ALIVES,\n                false);\n        if (noKeepAlives || !stunKeepAliveRunner.shouldRunStunKeepAlive())\n        {\n            return;\n        }\n\n        stunKeepAliveRunner.schedule();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSchedules repeated background task which sends STUN keep-alives\nonce this <tt>Agent</tt> is <tt>COMPLETED</tt>.\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[void]terminate(IceProcessingState)", "name": "terminate", "arg_nums": 1, "params": [{"name": "terminationState", "type": "IceProcessingState"}], "return_type": "void", "signature": "private void terminate(IceProcessingState terminationState)", "original_string": "    private void terminate(IceProcessingState terminationState)\n    {\n        if (!IceProcessingState.FAILED.equals(terminationState)\n                && !IceProcessingState.TERMINATED.equals(terminationState))\n            throw new IllegalArgumentException(\"terminationState\");\n\n        // stop making any checks.\n        connCheckClient.stop();\n\n        //do not stop the conn check server here because it may still need to\n        //process STUN Binding Requests that remote agents may send our way.\n        //we'll do this in \"free()\" instead.\n        //connCheckServer.stop();\n\n        setState(terminationState);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTerminates this <tt>Agent</tt> by stopping the handling of connectivity\nchecks and setting a specific termination state on it.\n\n@param terminationState the state that we'd like processing to terminate\nwith i.e. either {@link IceProcessingState#TERMINATED} or\n{@link IceProcessingState#FAILED}\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[String]ensureIceAttributeLength(String,int,int)", "name": "ensureIceAttributeLength", "arg_nums": 3, "params": [{"name": "s", "type": "String"}, {"name": "min", "type": "int"}, {"name": "max", "type": "int"}], "return_type": "String", "signature": "private String ensureIceAttributeLength(String s, int min, int max)", "original_string": "    private String ensureIceAttributeLength(String s, int min, int max)\n    {\n        if (s == null)\n            throw new NullPointerException(\"s\");\n        if (min < 0)\n            throw new IllegalArgumentException(\"min \" + min);\n        if (max < min)\n            throw new IllegalArgumentException(\"max \" + max);\n\n        int length = s.length();\n        int numberOfIceCharsToAdd = min - length;\n\n        if (numberOfIceCharsToAdd > 0)\n        {\n            StringBuilder sb = new StringBuilder(min);\n\n            for (; numberOfIceCharsToAdd > 0; --numberOfIceCharsToAdd)\n            {\n                sb.append('0');\n            }\n            sb.append(s);\n            s = sb.toString();\n        }\n        else if (max < length)\n        {\n            s = s.substring(0, max);\n        }\n        return s;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nAdds or removes ICE characters (i.e. ALPHA, DIGIT, +, or /) to or from a\nspecific <tt>String</tt> in order to produce a <tt>String</tt> with a\nlength within a specific range.\n\n@param s the <tt>String</tt> to add or remove characters to or from in\ncase its length is less than <tt>min</tt> or greater than <tt>max</tt>\n@param min the minimum length in (ICE) characters of the returned\n<tt>String</tt>\n@param max the maximum length in (ICE) characters of the returned\n<tt>String</tt>\n@return <tt>s</tt> if its length is greater than or equal to\n<tt>min</tt> and less than or equal to <tt>max</tt>; a new\n<tt>String</tt> which is equal to <tt>s</tt> with prepended ICE\ncharacters if the length of <tt>s</tt> is less than <tt>min</tt>; a new\n<tt>String</tt> which is composed of the first <tt>max</tt> characters of\n<tt>s</tt> if the length of <tt>s</tt> is greater than <tt>max</tt>\n@throws IllegalArgumentException if <tt>min</tt> is negative or\n<tt>max</tt> is less than <tt>min</tt>\n@throws NullPointerException if <tt>s</tt> is equal to <tt>null</tt>\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[void]finalize()", "name": "finalize", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Override\n    protected void finalize()", "original_string": "    @Override\n    protected void finalize()\n        throws Throwable\n    {\n        free();\n\n        super.finalize();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "@Override\n    protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCalled by the garbage collector when garbage collection determines that\nthere are no more references to this instance. Calls {@link #free()} on\nthis instance.\n\n@throws Throwable if anything goes wrong and the finalization of this\ninstance is to be halted\n@see #free()\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[void]free()", "name": "free", "arg_nums": 0, "params": [], "return_type": "void", "signature": "public void free()", "original_string": "    public void free()\n    {\n        logger.debug(() -> \"Free ICE agent\");\n\n        shutdown = true;\n\n        //stop sending keep alives (STUN Binding Indications).\n        stunKeepAliveRunner.cancel();\n\n        // cancel termination timer in case agent is freed\n        // before termination timer is triggered\n        synchronized (terminationFutureSyncRoot)\n        {\n            if (terminationFuture != null)\n            {\n                terminationFuture.cancel(true);\n                terminationFuture = null;\n            }\n        }\n\n        //stop responding to STUN Binding Requests.\n        connCheckServer.stop();\n\n        /*\n         * Set the IceProcessingState#TERMINATED state on this Agent unless it\n         * is in a termination state already.\n         */\n        IceProcessingState state = getState();\n\n        if (!IceProcessingState.FAILED.equals(state)\n             && !IceProcessingState.TERMINATED.equals(state))\n        {\n            terminate(IceProcessingState.TERMINATED);\n        }\n\n        /* Stop all outstanding transactions */\n        getStunStack().shutDown();\n\n        // Free its IceMediaStreams, Components and Candidates.\n        boolean interrupted = false;\n\n        logger.debug(() -> \"remove streams\");\n        for (IceMediaStream stream : getStreams())\n        {\n            try\n            {\n                removeStream(stream);\n                logger.debug(\"remove stream \" + stream.getName());\n            }\n            catch (Throwable t)\n            {\n                logger.debug(() ->\n                        \"remove stream \" + stream.getName() + \" failed: \" + t);\n                if (t instanceof InterruptedException)\n                    interrupted = true;\n                else if (t instanceof ThreadDeath)\n                    throw (ThreadDeath) t;\n            }\n        }\n        if (interrupted)\n            Thread.currentThread().interrupt();\n\n        logger.debug(() -> \"ICE agent freed\");\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nPrepares this <tt>Agent</tt> for garbage collection by ending all related\nprocesses and freeing its <tt>IceMediaStream</tt>s, <tt>Component</tt>s\nand <tt>Candidate</tt>s. This method will also place the agent in the\nterminated state in case it wasn't already there.\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[int]getGeneration()", "name": "getGeneration", "arg_nums": 0, "params": [], "return_type": "int", "signature": "public int getGeneration()", "original_string": "    public int getGeneration()\n    {\n        return generation;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\nReturns the current generation of this ICE Agent. A generation is an\nindex, starting at 0, that enables the parties to keep track of updates\nto the candidate throughout the life of the session.\n\n@return the current generation of this ICE Agent\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[void]setGeneration(int)", "name": "setGeneration", "arg_nums": 1, "params": [{"name": "generation", "type": "int"}], "return_type": "void", "signature": "public void setGeneration(int generation)", "original_string": "    public void setGeneration(int generation)\n    {\n        this.generation = generation;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSpecifies the current generation of this ICE Agent. A generation is an\nindex, starting at 0, that enables the parties to keep track of updates\nto the candidate throughout the life of the session.\n\n@param generation the current generation of this ICE Agent\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[CandidatePair]getSelectedPair(String)", "name": "getSelectedPair", "arg_nums": 1, "params": [{"name": "streamName", "type": "String"}], "return_type": "CandidatePair", "signature": "private CandidatePair getSelectedPair(String streamName)", "original_string": "    private CandidatePair getSelectedPair(String streamName)\n    {\n        IceMediaStream stream = getStream(streamName);\n        if (stream != null)\n        {\n            Component component = stream.getComponent(Component.RTP);\n            if (component != null)\n                return component.getSelectedPair();\n        }\n        return null;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "CandidatePair", "classes": []}, "docstring": "\nReturns the selected pair for the RTP component for the ICE media stream\nwith name <tt>streamName</tt> of this Agent, or <tt>null</tt>.\n\n@param streamName The stream name.\n\n@return the selected pair for the RTP component for the ICE media stream\nwith name <tt>streamName</tt> of this Agent, or <tt>null</tt>.\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[LocalCandidate]getSelectedLocalCandidate(String)", "name": "getSelectedLocalCandidate", "arg_nums": 1, "params": [{"name": "streamName", "type": "String"}], "return_type": "LocalCandidate", "signature": "public LocalCandidate getSelectedLocalCandidate(String streamName)", "original_string": "    public LocalCandidate getSelectedLocalCandidate(String streamName)\n    {\n        CandidatePair candidatePair = getSelectedPair(streamName);\n\n        return\n            (candidatePair == null) ? null : candidatePair.getLocalCandidate();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "LocalCandidate", "classes": []}, "docstring": "\nReturns the selected local candidate for this Agent.\n\n@param streamName The stream name (AUDIO, VIDEO);\n\n@return The selected local candidate for this Agent. Null if no pair is\nselected.\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[RemoteCandidate]getSelectedRemoteCandidate(String)", "name": "getSelectedRemoteCandidate", "arg_nums": 1, "params": [{"name": "streamName", "type": "String"}], "return_type": "RemoteCandidate", "signature": "public RemoteCandidate getSelectedRemoteCandidate(String streamName)", "original_string": "    public RemoteCandidate getSelectedRemoteCandidate(String streamName)\n    {\n        CandidatePair candidatePair = getSelectedPair(streamName);\n\n        return\n            (candidatePair == null) ? null : candidatePair.getRemoteCandidate();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "RemoteCandidate", "classes": []}, "docstring": "\nReturns the selected remote candidate for this Agent.\n\n@param streamName The stream name (AUDIO, VIDEO);\n\n@return The selected remote candidate for this Agent. Null if no pair is\nselected.\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[boolean]isTrickling()", "name": "isTrickling", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "public boolean isTrickling()", "original_string": "    public boolean isTrickling()\n    {\n        return trickle;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nIndicates whether this agent is currently set to trickle candidates\nrather than gathering them synchronously while components are being\nadded. When trickling is turned on, the agent will only gather host\naddresses for newly added components. When trickling is off, all\nharvesting for a specific component will be executed when that component\nis being added.\n\n@return <tt>false</tt> if this agent is configured to perform all\nharvesting when components are being added and <tt>false</tt> otherwise.\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[void]setTrickling(boolean)", "name": "setTrickling", "arg_nums": 1, "params": [{"name": "trickle", "type": "boolean"}], "return_type": "void", "signature": "public void setTrickling(boolean trickle)", "original_string": "    public void setTrickling(boolean trickle)\n    {\n        this.trickle = trickle;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nDetermines whether this agent will trickle candidates rather than\ngather them synchronously while components are being added. When\ntrickling is turned on, the agent will only gather host addresses for\nnewly added components. When trickling is off, all harvesting for a\nspecific component will be executed when that component is being added.\n\n@param trickle <tt>false</tt> if this agent is configured to perform all\nharvesting when components are being added and <tt>false</tt> otherwise.\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[long]getHarvestingTime(String)", "name": "getHarvestingTime", "arg_nums": 1, "params": [{"name": "harvesterName", "type": "String"}], "return_type": "long", "signature": "public long getHarvestingTime(String harvesterName)", "original_string": "    public long getHarvestingTime(String harvesterName)\n    {\n        long harvestingTime = 0;\n\n        for (CandidateHarvester harvester : harvesters)\n        {\n            if (harvester.getClass().getName().endsWith(harvesterName))\n            {\n                harvestingTime\n                    = harvester.getHarvestStatistics().getHarvestDuration();\n                // There may be several harvester with the same class name.\n                // Thus, returns only an active one (if any).\n                if (harvestingTime != 0)\n                {\n                    return harvestingTime;\n                }\n            }\n        }\n\n        return 0;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "long", "classes": []}, "docstring": "\nReturns the harvesting time (in ms) for the harvester given in parameter.\n\n@param harvesterName The class name if the harvester.\n\n@return The harvesting time (in ms) for the harvester given in parameter.\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[int]getHarvestCount(String)", "name": "getHarvestCount", "arg_nums": 1, "params": [{"name": "harvesterName", "type": "String"}], "return_type": "int", "signature": "public int getHarvestCount(String harvesterName)", "original_string": "    public int getHarvestCount(String harvesterName)\n    {\n        int harvestCount;\n\n        for (CandidateHarvester harvester : harvesters)\n        {\n            if (harvester.getClass().getName().endsWith(harvesterName))\n            {\n                harvestCount\n                    = harvester.getHarvestStatistics().getHarvestCount();\n                // There may be several harvester with the same class name.\n                // Thus, returns only an active one (if any).\n                if (harvestCount != 0)\n                {\n                    return harvestCount;\n                }\n            }\n        }\n\n        return 0;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\nReturns the number of harvests that a harvester with a specific class\nname has completed so far.\n\n@param harvesterName the class name of the harvester for which the\nnumber of completed harvests is to be returned\n@return the number of harvests that the harvester with the specified\n<tt>harvesterName</tt> has completed so far if such a harvester exists\nand has completed at least one harvest; otherwise, zero\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[long]getTotalHarvestingTime()", "name": "getTotalHarvestingTime", "arg_nums": 0, "params": [], "return_type": "long", "signature": "public long getTotalHarvestingTime()", "original_string": "    public long getTotalHarvestingTime()\n    {\n        long harvestDuration = 0;\n\n        for (CandidateHarvester harvester : harvesters)\n        {\n            harvestDuration\n                += harvester.getHarvestStatistics().getHarvestDuration();\n        }\n\n        return harvestDuration;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "long", "classes": []}, "docstring": "\nReturns the combined harvesting time for all harvesters in this agent.\n\n@return the total time this agent has spent harvesting.\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[int]getHarvestCount()", "name": "getHarvestCount", "arg_nums": 0, "params": [], "return_type": "int", "signature": "public int getHarvestCount()", "original_string": "    public int getHarvestCount()\n    {\n        int harvestCount = 0;\n\n        for (CandidateHarvester harvester : harvesters)\n        {\n            harvestCount += harvester.getHarvestStatistics().getHarvestCount();\n        }\n\n        return harvestCount;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\nReturns the total number of harvests completed by this agent. Normally,\nthis number should be equal to <tt>NB_HARVESTERS * NB_COMPONENTS</tt> but\ncould be less, for example, if some harvesters were disabled for\ninefficiency.\n\n@return the number of harvests this agent has completed.\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[boolean]getPerformConsentFreshness()", "name": "getPerformConsentFreshness", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "public boolean getPerformConsentFreshness()", "original_string": "    public boolean getPerformConsentFreshness()\n    {\n        return performConsentFreshness;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nGets the indicator which determines whether this <tt>Agent</tt> is to\nperform consent freshness.\n\n@return <tt>true</tt> if this <tt>Agent</tt> is to perform consent\nfreshness; otherwise, <tt>false</tt>\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[void]setPerformConsentFreshness(boolean)", "name": "setPerformConsentFreshness", "arg_nums": 1, "params": [{"name": "performConsentFreshness", "type": "boolean"}], "return_type": "void", "signature": "public void setPerformConsentFreshness(boolean performConsentFreshness)", "original_string": "    public void setPerformConsentFreshness(boolean performConsentFreshness)\n    {\n        this.performConsentFreshness = performConsentFreshness;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets the indicator which determines whether this <tt>Agent</tt> is to\nperform consent freshness.\n\n@param performConsentFreshness <tt>true</tt> if this <tt>Agent</tt> is to\nperform consent freshness; otherwise, <tt>false</tt>\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[void]setLoggingLevel(Level)", "name": "setLoggingLevel", "arg_nums": 1, "params": [{"name": "level", "type": "Level"}], "return_type": "void", "signature": "public void setLoggingLevel(Level level)", "original_string": "    public void setLoggingLevel(Level level)\n    {\n        logger.setLevel(level);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets the logging level for this {@link Agent} and its components.\n@param level the level to set.\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[Level]getLoggingLevel()", "name": "getLoggingLevel", "arg_nums": 0, "params": [], "return_type": "Level", "signature": "public Level getLoggingLevel()", "original_string": "    public Level getLoggingLevel()\n    {\n        return logger.getLevel();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Level", "classes": []}, "docstring": "\nGets the logging level for this {@link Agent} and its components.\n"}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent.[Logger]getLogger()", "name": "getLogger", "arg_nums": 0, "params": [], "return_type": "Logger", "signature": "protected Logger getLogger()", "original_string": "    protected Logger getLogger()\n    {\n        return logger;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Agent.java", "class_name": "Agent", "class_uri": "src/main/java/org/ice4j/ice/Agent.java.Agent", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Logger", "classes": []}, "docstring": "\n@return this {@link Agent}'s {@link Logger}.\n"}, {"uris": "src/main/java/org/ice4j/ice/DefaultNominator.java.DefaultNominator.[]DefaultNominator(Agent)", "name": "DefaultNominator", "arg_nums": 1, "params": [{"name": "parentAgent", "type": "Agent"}], "return_type": "", "signature": "public DefaultNominator(Agent parentAgent)", "original_string": "    public DefaultNominator(Agent parentAgent)\n    {\n        this.parentAgent = parentAgent;\n        logger = parentAgent.getLogger().createChildLogger(this.getClass().getName());\n        parentAgent.addStateChangeListener(this);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/DefaultNominator.java", "class_name": "DefaultNominator", "class_uri": "src/main/java/org/ice4j/ice/DefaultNominator.java.DefaultNominator", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nCreates a new instance of this nominator using <tt>parentAgent</tt> as\na reference to the <tt>Agent</tt> instance that we should use to\nnominate pairs.\n\n@param parentAgent the {@link Agent} that created us.\n"}, {"uris": "src/main/java/org/ice4j/ice/DefaultNominator.java.DefaultNominator.[void]propertyChange(PropertyChangeEvent)", "name": "propertyChange", "arg_nums": 1, "params": [{"name": "ev", "type": "PropertyChangeEvent"}], "return_type": "void", "signature": "public void propertyChange(PropertyChangeEvent ev)", "original_string": "    public void propertyChange(PropertyChangeEvent ev)\n    {\n        String propertyName = ev.getPropertyName();\n\n        if (Agent.PROPERTY_ICE_PROCESSING_STATE.equals(propertyName))\n        {\n            if (ev.getNewValue() != IceProcessingState.RUNNING)\n                return;\n\n            for (IceMediaStream stream : parentAgent.getStreams())\n            {\n                stream.addPairChangeListener(this);\n                stream.getCheckList().addStateChangeListener(this);\n            }\n        }\n\n        if (!parentAgent.isControlling() //CONTROLLED agents cannot nominate\n                || strategy == NominationStrategy.NONE)\n        {\n            return;\n        }\n\n        if (ev.getSource() instanceof CandidatePair)\n        {\n            // STUN Usage for Consent Freshness is of no concern here.\n            if (IceMediaStream.PROPERTY_PAIR_CONSENT_FRESHNESS_CHANGED.equals(propertyName))\n            {\n                return;\n            }\n\n            CandidatePair validPair = (CandidatePair) ev.getSource();\n            Component parentComponent = validPair.getParentComponent();\n            IceMediaStream parentStream = parentComponent.getParentStream();\n\n            // do not nominate pair if there is currently a nominated pair for\n            // the component\n            if (parentStream.validListContainsNomineeForComponent(parentComponent))\n            {\n                logger.debug(() ->\n                        \"Keep-alive for pair: \" + validPair.toRedactedShortString());\n                return;\n            }\n        }\n\n        if (strategy == NominationStrategy.NOMINATE_FIRST_VALID)\n            strategyNominateFirstValid(ev);\n        else if (strategy == NominationStrategy.NOMINATE_HIGHEST_PRIO)\n            strategyNominateHighestPrio(ev);\n        else if (strategy\n                == NominationStrategy.NOMINATE_FIRST_HOST_OR_REFLEXIVE_VALID)\n            strategyNominateFirstHostOrReflexiveValid(ev);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/DefaultNominator.java", "class_name": "DefaultNominator", "class_uri": "src/main/java/org/ice4j/ice/DefaultNominator.java.DefaultNominator", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTracks changes of state in {@link IceMediaStream}s and {@link\nCheckList}s.\n\n@param ev the event that we should use in case it means we should\nnominate someone.\n"}, {"uris": "src/main/java/org/ice4j/ice/DefaultNominator.java.DefaultNominator.[void]strategyNominateFirstValid(PropertyChangeEvent)", "name": "strategyNominateFirstValid", "arg_nums": 1, "params": [{"name": "evt", "type": "PropertyChangeEvent"}], "return_type": "void", "signature": "private void strategyNominateFirstValid(PropertyChangeEvent evt)", "original_string": "    private void strategyNominateFirstValid(PropertyChangeEvent evt)\n    {\n        if (IceMediaStream.PROPERTY_PAIR_VALIDATED\n                    .equals(evt.getPropertyName()))\n        {\n            CandidatePair validPair = (CandidatePair)evt.getSource();\n\n            logger.info(\"Nominate (first valid): \" + validPair.toRedactedShortString()\n                + \".\");\n            parentAgent.nominate(validPair);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/DefaultNominator.java", "class_name": "DefaultNominator", "class_uri": "src/main/java/org/ice4j/ice/DefaultNominator.java.DefaultNominator", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nImplements a basic nomination strategy that consists in nominating the\nfirst pair that has become valid for a check list.\n\n@param evt the {@link PropertyChangeEvent} containing the pair which\nhas been validated.\n"}, {"uris": "src/main/java/org/ice4j/ice/DefaultNominator.java.DefaultNominator.[void]strategyNominateHighestPrio(PropertyChangeEvent)", "name": "strategyNominateHighestPrio", "arg_nums": 1, "params": [{"name": "ev", "type": "PropertyChangeEvent"}], "return_type": "void", "signature": "private void strategyNominateHighestPrio(PropertyChangeEvent ev)", "original_string": "    private void strategyNominateHighestPrio(PropertyChangeEvent ev)\n    {\n        String pname = ev.getPropertyName();\n\n        if (IceMediaStream.PROPERTY_PAIR_VALIDATED.equals(pname)\n                || (IceMediaStream.PROPERTY_PAIR_STATE_CHANGED.equals(pname)\n                        && (ev.getNewValue() == CandidatePairState.FAILED)))\n        {\n            CandidatePair validPair = (CandidatePair) ev.getSource();\n            Component parentComponent = validPair.getParentComponent();\n            IceMediaStream parentStream = parentComponent.getParentStream();\n            CheckList parentCheckList = parentStream.getCheckList();\n\n            if (!parentCheckList.allChecksCompleted())\n                return;\n\n            for (Component component : parentStream.getComponents())\n            {\n                CandidatePair pair = parentStream.getValidPair(component);\n\n                if (pair != null)\n                {\n                    logger.info(\n                            \"Nominate (highest priority): \"\n                                + validPair.toRedactedShortString());\n                    parentAgent.nominate(pair);\n                }\n            }\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/DefaultNominator.java", "class_name": "DefaultNominator", "class_uri": "src/main/java/org/ice4j/ice/DefaultNominator.java.DefaultNominator", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nImplements a nomination strategy that allows checks for several (or all)\npairs in a check list to conclude before nominating the one with the\nhighest priority.\n\n@param ev the {@link PropertyChangeEvent} containing the new state and\nthe source {@link CheckList}.\n"}, {"uris": "src/main/java/org/ice4j/ice/DefaultNominator.java.DefaultNominator.[NominationStrategy]getStrategy()", "name": "getStrategy", "arg_nums": 0, "params": [], "return_type": "NominationStrategy", "signature": "public NominationStrategy getStrategy()", "original_string": "    public NominationStrategy getStrategy()\n    {\n        return strategy;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/DefaultNominator.java", "class_name": "DefaultNominator", "class_uri": "src/main/java/org/ice4j/ice/DefaultNominator.java.DefaultNominator", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "NominationStrategy", "classes": []}, "docstring": "\nThe {@link NominationStrategy} that this nominator is using when\ndeciding whether or not a valid {@link CandidatePair} is suitable for\nnomination.\n\n@return the {@link NominationStrategy} we are using.\n"}, {"uris": "src/main/java/org/ice4j/ice/DefaultNominator.java.DefaultNominator.[void]setStrategy(NominationStrategy)", "name": "setStrategy", "arg_nums": 1, "params": [{"name": "strategy", "type": "NominationStrategy"}], "return_type": "void", "signature": "public void setStrategy(NominationStrategy strategy)", "original_string": "    public void setStrategy(NominationStrategy strategy)\n    {\n        this.strategy = strategy;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/DefaultNominator.java", "class_name": "DefaultNominator", "class_uri": "src/main/java/org/ice4j/ice/DefaultNominator.java.DefaultNominator", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nThe {@link NominationStrategy} that this nominator should use when\ndeciding whether or not a valid {@link CandidatePair} is suitable for\nnomination.\n\n@param strategy the {@link NominationStrategy} we should be using.\n"}, {"uris": "src/main/java/org/ice4j/ice/DefaultNominator.java.DefaultNominator.[void]strategyNominateFirstHostOrReflexiveValid(PropertyChangeEvent)", "name": "strategyNominateFirstHostOrReflexiveValid", "arg_nums": 1, "params": [{"name": "evt", "type": "PropertyChangeEvent"}], "return_type": "void", "signature": "private void strategyNominateFirstHostOrReflexiveValid(\n            PropertyChangeEvent evt)", "original_string": "    private void strategyNominateFirstHostOrReflexiveValid(\n            PropertyChangeEvent evt)\n    {\n        if (IceMediaStream.PROPERTY_PAIR_VALIDATED.equals(evt.getPropertyName()))\n        {\n            CandidatePair validPair = (CandidatePair) evt.getSource();\n\n            Component component = validPair.getParentComponent();\n            LocalCandidate localCandidate = validPair.getLocalCandidate();\n            boolean isRelayed\n                = (localCandidate instanceof RelayedCandidate)\n                    || localCandidate.getType().equals(\n                            CandidateType.RELAYED_CANDIDATE)\n                    || validPair.getRemoteCandidate().getType().equals(\n                            CandidateType.RELAYED_CANDIDATE);\n            boolean nominate = false;\n\n            synchronized (validatedCandidates)\n            {\n                TimerTask task\n                    = validatedCandidates.get(component.toShortString());\n\n                if (isRelayed && task == null)\n                {\n                    /* armed a timer and see if a host or server reflexive pair\n                     * gets nominated. Otherwise nominate the relayed candidate\n                     * pair\n                     */\n                    Timer timer = new Timer();\n                    task = new RelayedCandidateTask(validPair);\n\n                    logger.info(\"Wait timeout to nominate relayed candidate\");\n                    timer.schedule(task, 0);\n                    validatedCandidates.put(component.toShortString(), task);\n                }\n                else if (!isRelayed)\n                {\n                    // host or server reflexive candidate pair\n                    if (task != null)\n                    {\n                        task.cancel();\n                        logger.info(\n                                \"Found a better candidate pair to nominate for \"\n                                    + component.toShortString());\n                    }\n\n                    logger.info(\n                            \"Nominate (first highest valid): \"\n                                + validPair.toRedactedShortString());\n                    nominate = true;\n                }\n            }\n\n            if (nominate)\n                parentAgent.nominate(validPair);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/DefaultNominator.java", "class_name": "DefaultNominator", "class_uri": "src/main/java/org/ice4j/ice/DefaultNominator.java.DefaultNominator", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nImplements a nomination strategy that consists in nominating directly\nhost or server reflexive pair that has become valid for a\ncheck list. For relayed pair, a timer is armed to see if no other host or\nserver reflexive pair gets validated prior to timeout, the relayed ones\ngets nominated.\n\n@param evt the {@link PropertyChangeEvent} containing the pair which\nhas been validated.\n"}, {"uris": "src/main/java/org/ice4j/ice/LocalCandidate.java.LocalCandidate.[]LocalCandidate(TransportAddress,Component,CandidateType,CandidateExtendedType,LocalCandidate)", "name": "LocalCandidate", "arg_nums": 5, "params": [{"name": "transportAddress", "type": "TransportAddress"}, {"name": "parentComponent", "type": "Component"}, {"name": "type", "type": "CandidateType"}, {"name": "extendedType", "type": "CandidateExtendedType"}, {"name": "relatedCandidate", "type": "LocalCandidate"}], "return_type": "", "signature": "public LocalCandidate(TransportAddress transportAddress,\n                          Component        parentComponent,\n                          CandidateType    type,\n                          CandidateExtendedType extendedType,\n                          LocalCandidate  relatedCandidate)", "original_string": "    public LocalCandidate(TransportAddress transportAddress,\n                          Component        parentComponent,\n                          CandidateType    type,\n                          CandidateExtendedType extendedType,\n                          LocalCandidate  relatedCandidate)\n\n    {\n        super(transportAddress, parentComponent, type, relatedCandidate);\n        logger = parentComponent.getLogger().createChildLogger(this.getClass().getName());\n        this.extendedType = extendedType;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/LocalCandidate.java", "class_name": "LocalCandidate", "class_uri": "src/main/java/org/ice4j/ice/LocalCandidate.java.LocalCandidate", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nCreates a <tt>LocalCandidate</tt> instance for the specified transport\naddress and properties.\n\n@param transportAddress  the transport address that this candidate is\nencapsulating.\n@param parentComponent the <tt>Component</tt> that this candidate\nbelongs to.\n@param type the <tt>CandidateType</tt> for this <tt>Candidate</tt>.\n@param extendedType The type of method used to discover this candidate\n(\"host\", \"upnp\", \"stun peer reflexive\", \"stun server reflexive\", \"turn\nrelayed\", \"google turn relayed\", \"google tcp turn relayed\" or \"jingle\nnode\").\n@param relatedCandidate the relatedCandidate: null for a host candidate,\nthe base address (host candidate) for a reflexive candidate, the mapped\naddress (the mapped address of the TURN allocate response) for a relayed\ncandidate.\n"}, {"uris": "src/main/java/org/ice4j/ice/LocalCandidate.java.LocalCandidate.[DatagramSocket]getDatagramSocket()", "name": "getDatagramSocket", "arg_nums": 0, "params": [], "return_type": "DatagramSocket", "signature": "@Deprecated\n    public DatagramSocket getDatagramSocket()", "original_string": "    @Deprecated\n    public DatagramSocket getDatagramSocket()\n    {\n        IceSocketWrapper wrapper = getIceSocketWrapper();\n        return wrapper == null ? null : wrapper.getUDPSocket();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/LocalCandidate.java", "class_name": "LocalCandidate", "class_uri": "src/main/java/org/ice4j/ice/LocalCandidate.java.LocalCandidate", "attributes": {"modifiers": "@Deprecated\n    public", "marker_annotations": ["@Deprecated"], "non_marker_annotations": ["public"], "comments": [], "return_type": "DatagramSocket", "classes": []}, "docstring": "\nGets the <tt>DatagramSocket</tt> associated with this\n<tt>Candidate</tt>.\n\n@return the <tt>DatagramSocket</tt> associated with this\n<tt>Candidate</tt>\n\n@deprecated This should be used by the library only. Users of ice4j\nshould use {@link org.ice4j.ice.Component#getSocket()} instead.\n"}, {"uris": "src/main/java/org/ice4j/ice/LocalCandidate.java.LocalCandidate.[Socket]getSocket()", "name": "getSocket", "arg_nums": 0, "params": [], "return_type": "Socket", "signature": "@Deprecated\n    public Socket getSocket()", "original_string": "    @Deprecated\n    public Socket getSocket()\n    {\n        return null;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/LocalCandidate.java", "class_name": "LocalCandidate", "class_uri": "src/main/java/org/ice4j/ice/LocalCandidate.java.LocalCandidate", "attributes": {"modifiers": "@Deprecated\n    public", "marker_annotations": ["@Deprecated"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Socket", "classes": []}, "docstring": "\nGets the <tt>Socket</tt> associated with this\n<tt>Candidate</tt>.\n\n@return the <tt>Socket</tt> associated with this\n<tt>Candidate</tt>\n\n@deprecated This should be used by the library only. Users of ice4j\nshould use {@link org.ice4j.ice.Component#getSocket()} instead.\n"}, {"uris": "src/main/java/org/ice4j/ice/LocalCandidate.java.LocalCandidate.[IceSocketWrapper]getIceSocketWrapper()", "name": "getIceSocketWrapper", "arg_nums": 0, "params": [], "return_type": "IceSocketWrapper", "signature": "protected IceSocketWrapper getIceSocketWrapper()", "original_string": "    protected IceSocketWrapper getIceSocketWrapper()\n    {\n        return getParentComponent().getSocketWrapper();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/LocalCandidate.java", "class_name": "LocalCandidate", "class_uri": "src/main/java/org/ice4j/ice/LocalCandidate.java.LocalCandidate", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "IceSocketWrapper", "classes": []}, "docstring": "\n@return the {@link IceSocketWrapper} instance of the {@link Component}\nwhich owns this {@link LocalCandidate}. Note that this IS NOT an\ninstance specific to this {@link LocalCandidate}. See\n{@link #getCandidateIceSocketWrapper()}.\n"}, {"uris": "src/main/java/org/ice4j/ice/LocalCandidate.java.LocalCandidate.[IceSocketWrapper]getCandidateIceSocketWrapper()", "name": "getCandidateIceSocketWrapper", "arg_nums": 0, "params": [], "return_type": "IceSocketWrapper", "signature": "protected abstract IceSocketWrapper getCandidateIceSocketWrapper()", "original_string": "    protected abstract IceSocketWrapper getCandidateIceSocketWrapper();", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/LocalCandidate.java", "class_name": "LocalCandidate", "class_uri": "src/main/java/org/ice4j/ice/LocalCandidate.java.LocalCandidate", "attributes": {"modifiers": "protected abstract", "marker_annotations": [], "non_marker_annotations": ["protected", "abstract"], "comments": [], "return_type": "IceSocketWrapper", "classes": []}, "docstring": "\n@return the {@link IceSocketWrapper} instance, if any, associated with\nthis candidate. Note that this IS NOT the instance which should be used\nfor reading and writing by the application, and SHOULD NOT be used from\noutside ice4j (even if a subclass exposes it as public). Also see\n{@link #getIceSocketWrapper()}.\n"}, {"uris": "src/main/java/org/ice4j/ice/LocalCandidate.java.LocalCandidate.[IceSocketWrapper]getCandidateIceSocketWrapper(SocketAddress)", "name": "getCandidateIceSocketWrapper", "arg_nums": 1, "params": [{"name": "remoteAddress", "type": "SocketAddress"}], "return_type": "IceSocketWrapper", "signature": "protected IceSocketWrapper getCandidateIceSocketWrapper(\n        SocketAddress remoteAddress)", "original_string": "    protected IceSocketWrapper getCandidateIceSocketWrapper(\n        SocketAddress remoteAddress)\n    {\n        // The default implementation just refers to the method which doesn't\n        // involve a remove address. Extenders which support multiple instances\n        // mapped by remote address should override.\n        return getCandidateIceSocketWrapper();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/LocalCandidate.java", "class_name": "LocalCandidate", "class_uri": "src/main/java/org/ice4j/ice/LocalCandidate.java.LocalCandidate", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "IceSocketWrapper", "classes": []}, "docstring": "\n@return the {@link IceSocketWrapper} instance for this candidate,\nassociated with a particular remote address.\n@param remoteAddress the remote address for which to return an\nassociated socket.\n"}, {"uris": "src/main/java/org/ice4j/ice/LocalCandidate.java.LocalCandidate.[IceSocketWrapper]getStunSocket(TransportAddress)", "name": "getStunSocket", "arg_nums": 1, "params": [{"name": "serverAddress", "type": "TransportAddress"}], "return_type": "IceSocketWrapper", "signature": "public IceSocketWrapper getStunSocket(TransportAddress serverAddress)", "original_string": "    public IceSocketWrapper getStunSocket(TransportAddress serverAddress)\n    {\n        IceSocketWrapper hostSocket = getCandidateIceSocketWrapper();\n\n        if (hostSocket != null\n              && hostSocket.getTCPSocket() != null)\n        {\n            Socket tcpSocket = hostSocket.getTCPSocket();\n            Socket tcpStunSocket = null;\n\n            if (tcpSocket instanceof MultiplexingSocket)\n            {\n                DatagramPacketFilter stunDatagramPacketFilter\n                    = createStunDatagramPacketFilter(serverAddress);\n                Throwable exception = null;\n\n                try\n                {\n                    tcpStunSocket\n                        = ((MultiplexingSocket) tcpSocket)\n                            .getSocket(stunDatagramPacketFilter);\n                }\n                catch (SocketException sex) //don't u just luv da name? ;)\n                {\n                    logger.error(\"Failed to acquire Socket\"\n                                   + \" specific to STUN communication.\",\n                               sex);\n                    exception = sex;\n                }\n                if (tcpStunSocket == null)\n                {\n                    throw\n                        new IllegalStateException(\n                                \"Failed to acquire Socket\"\n                                    + \" specific to STUN communication\",\n                                exception);\n                }\n            }\n            else\n            {\n                throw\n                    new IllegalStateException(\n                            \"The socket of \"\n                                + getClass().getSimpleName()\n                                + \" must be a MultiplexingSocket \" +\n                                        \"instance\");\n            }\n\n            IceTcpSocketWrapper stunSocket = null;\n            try\n            {\n                stunSocket = new IceTcpSocketWrapper(tcpStunSocket);\n            }\n            catch(IOException e)\n            {\n                logger.info(\"Failed to create IceTcpSocketWrapper \" + e);\n            }\n\n            return stunSocket;\n        }\n        else if (hostSocket != null\n                   && hostSocket.getUDPSocket() != null)\n        {\n            DatagramSocket udpSocket = hostSocket.getUDPSocket();\n            DatagramSocket udpStunSocket = null;\n\n            if (udpSocket instanceof MultiplexingDatagramSocket)\n            {\n                DatagramPacketFilter stunDatagramPacketFilter\n                    = createStunDatagramPacketFilter(serverAddress);\n                Throwable exception = null;\n\n                try\n                {\n                    udpStunSocket\n                        = ((MultiplexingDatagramSocket) udpSocket)\n                            .getSocket(stunDatagramPacketFilter);\n                }\n                catch (SocketException sex) //don't u just luv da name? ;)\n                {\n                    logger.error(\"Failed to acquire DatagramSocket\"\n                                   + \" specific to STUN communication.\",\n                               sex);\n                    exception = sex;\n                }\n                if (udpStunSocket == null)\n                {\n                    throw\n                        new IllegalStateException(\n                                \"Failed to acquire DatagramSocket\"\n                                    + \" specific to STUN communication\",\n                                exception);\n                }\n            }\n            else\n            {\n                throw\n                    new IllegalStateException(\n                            \"The socket of \"\n                                + getClass().getSimpleName()\n                                + \" must be a MultiplexingDatagramSocket \" +\n                                        \"instance\");\n            }\n            return new IceUdpSocketWrapper(udpStunSocket);\n        }\n\n        return null;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/LocalCandidate.java", "class_name": "LocalCandidate", "class_uri": "src/main/java/org/ice4j/ice/LocalCandidate.java.LocalCandidate", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "IceSocketWrapper", "classes": []}, "docstring": "\nCreates if necessary and returns a <tt>DatagramSocket</tt> that would\ncapture all STUN packets arriving on this candidate's socket. If the\n<tt>serverAddress</tt> parameter is not <tt>null</tt> this socket would\nonly intercept packets originating at this address.\n\n@param serverAddress the address of the source we'd like to receive\npackets from or <tt>null</tt> if we'd like to intercept all STUN packets.\n\n@return the <tt>DatagramSocket</tt> that this candidate uses when sending\nand receiving STUN packets, while harvesting STUN candidates or\nperforming connectivity checks.\n"}, {"uris": "src/main/java/org/ice4j/ice/LocalCandidate.java.LocalCandidate.[StunStack]getStunStack()", "name": "getStunStack", "arg_nums": 0, "params": [], "return_type": "StunStack", "signature": "public StunStack getStunStack()", "original_string": "    public StunStack getStunStack()\n    {\n        return\n            getParentComponent()\n                .getParentStream()\n                    .getParentAgent()\n                        .getStunStack();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/LocalCandidate.java", "class_name": "LocalCandidate", "class_uri": "src/main/java/org/ice4j/ice/LocalCandidate.java.LocalCandidate", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "StunStack", "classes": []}, "docstring": "\nGets the <tt>StunStack</tt> associated with this <tt>Candidate</tt>.\n\n@return the <tt>StunStack</tt> associated with this <tt>Candidate</tt>\n"}, {"uris": "src/main/java/org/ice4j/ice/LocalCandidate.java.LocalCandidate.[StunDatagramPacketFilter]createStunDatagramPacketFilter(TransportAddress)", "name": "createStunDatagramPacketFilter", "arg_nums": 1, "params": [{"name": "serverAddress", "type": "TransportAddress"}], "return_type": "StunDatagramPacketFilter", "signature": "protected StunDatagramPacketFilter createStunDatagramPacketFilter(\n            TransportAddress serverAddress)", "original_string": "    protected StunDatagramPacketFilter createStunDatagramPacketFilter(\n            TransportAddress serverAddress)\n    {\n        return new StunDatagramPacketFilter(serverAddress);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/LocalCandidate.java", "class_name": "LocalCandidate", "class_uri": "src/main/java/org/ice4j/ice/LocalCandidate.java.LocalCandidate", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "StunDatagramPacketFilter", "classes": []}, "docstring": "\nCreates a new <tt>StunDatagramPacketFilter</tt> which is to capture STUN\nmessages and make them available to the <tt>DatagramSocket</tt> returned\nby {@link #getStunSocket(TransportAddress)}.\n\n@param serverAddress the address of the source we'd like to receive\npackets from or <tt>null</tt> if we'd like to intercept all STUN packets\n@return the <tt>StunDatagramPacketFilter</tt> which is to capture STUN\nmessages and make them available to the <tt>DatagramSocket</tt> returned\nby {@link #getStunSocket(TransportAddress)}\n"}, {"uris": "src/main/java/org/ice4j/ice/LocalCandidate.java.LocalCandidate.[void]free()", "name": "free", "arg_nums": 0, "params": [], "return_type": "void", "signature": "protected void free()", "original_string": "    protected void free()\n    {\n        // Close the socket associated with this LocalCandidate.\n        IceSocketWrapper socket = getCandidateIceSocketWrapper();\n\n        if (socket != null)\n        {\n            LocalCandidate base = getBase();\n\n            if ((base == null)\n                    || (base == this)\n                    || (base.getCandidateIceSocketWrapper() != socket))\n            {\n                //remove our socket from the stack.\n                getStunStack().removeSocket(getTransportAddress());\n\n                /*\n                 * Allow this LocalCandidate implementation to not create a\n                 * socket if it still hasn't created one.\n                 */\n                socket.close();\n            }\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/LocalCandidate.java", "class_name": "LocalCandidate", "class_uri": "src/main/java/org/ice4j/ice/LocalCandidate.java.LocalCandidate", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nFrees resources allocated by this candidate such as its\n<tt>DatagramSocket</tt>, for example. The <tt>socket</tt> of this\n<tt>LocalCandidate</tt> is closed only if it is not the <tt>socket</tt>\nof the <tt>base</tt> of this <tt>LocalCandidate</tt>.\n"}, {"uris": "src/main/java/org/ice4j/ice/LocalCandidate.java.LocalCandidate.[boolean]isDefault()", "name": "isDefault", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "@Override\n    public boolean isDefault()", "original_string": "    @Override\n    public boolean isDefault()\n    {\n        Component parentCmp = getParentComponent();\n\n        return (parentCmp != null) && equals(parentCmp.getDefaultCandidate());\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/LocalCandidate.java", "class_name": "LocalCandidate", "class_uri": "src/main/java/org/ice4j/ice/LocalCandidate.java.LocalCandidate", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nDetermines whether this <tt>Candidate</tt> is the default one for its\nparent component.\n\n@return <tt>true</tt> if this <tt>Candidate</tt> is the default for its\nparent component and <tt>false</tt> if it isn't or if it has no parent\nComponent yet.\n"}, {"uris": "src/main/java/org/ice4j/ice/LocalCandidate.java.LocalCandidate.[void]setUfrag(String)", "name": "setUfrag", "arg_nums": 1, "params": [{"name": "ufrag", "type": "String"}], "return_type": "void", "signature": "public void setUfrag(String ufrag)", "original_string": "    public void setUfrag(String ufrag)\n    {\n        this.ufrag = ufrag;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/LocalCandidate.java", "class_name": "LocalCandidate", "class_uri": "src/main/java/org/ice4j/ice/LocalCandidate.java.LocalCandidate", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSet the local ufrag.\n\n@param ufrag local ufrag\n"}, {"uris": "src/main/java/org/ice4j/ice/LocalCandidate.java.LocalCandidate.[String]getUfrag()", "name": "getUfrag", "arg_nums": 0, "params": [], "return_type": "String", "signature": "@Override\n    public String getUfrag()", "original_string": "    @Override\n    public String getUfrag()\n    {\n        return ufrag;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/LocalCandidate.java", "class_name": "LocalCandidate", "class_uri": "src/main/java/org/ice4j/ice/LocalCandidate.java.LocalCandidate", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nGet the local ufrag.\n\n@return local ufrag\n"}, {"uris": "src/main/java/org/ice4j/ice/LocalCandidate.java.LocalCandidate.[CandidateExtendedType]getExtendedType()", "name": "getExtendedType", "arg_nums": 0, "params": [], "return_type": "CandidateExtendedType", "signature": "public CandidateExtendedType getExtendedType()", "original_string": "    public CandidateExtendedType getExtendedType()\n    {\n        return this.extendedType;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/LocalCandidate.java", "class_name": "LocalCandidate", "class_uri": "src/main/java/org/ice4j/ice/LocalCandidate.java.LocalCandidate", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "CandidateExtendedType", "classes": []}, "docstring": "\nReturns the type of method used to discover this candidate (\"host\",\n\"upnp\", \"stun peer reflexive\", \"stun server reflexive\", \"turn relayed\",\n\"google turn relayed\", \"google tcp turn relayed\" or \"jingle node\").\n\n@return The type of method used to discover this candidate (\"host\",\n\"upnp\", \"stun peer reflexive\", \"stun server reflexive\", \"turn relayed\",\n\"google turn relayed\", \"google tcp turn relayed\" or \"jingle node\").\n"}, {"uris": "src/main/java/org/ice4j/ice/LocalCandidate.java.LocalCandidate.[void]setExtendedType(CandidateExtendedType)", "name": "setExtendedType", "arg_nums": 1, "params": [{"name": "extendedType", "type": "CandidateExtendedType"}], "return_type": "void", "signature": "public void setExtendedType(CandidateExtendedType extendedType)", "original_string": "    public void setExtendedType(CandidateExtendedType extendedType)\n    {\n        this.extendedType = extendedType;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/LocalCandidate.java", "class_name": "LocalCandidate", "class_uri": "src/main/java/org/ice4j/ice/LocalCandidate.java.LocalCandidate", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets the type of method used to discover this candidate (\"host\", \"upnp\",\n\"stun peer reflexive\", \"stun server reflexive\", \"turn relayed\", \"google\nturn relayed\", \"google tcp turn relayed\" or \"jingle node\").\n\n@param extendedType The type of method used to discover this candidate\n(\"host\", \"upnp\", \"stun peer reflexive\", \"stun server reflexive\", \"turn\nrelayed\", \"google turn relayed\", \"google tcp turn relayed\" or \"jingle\nnode\").\n"}, {"uris": "src/main/java/org/ice4j/ice/LocalCandidate.java.LocalCandidate.[LocalCandidate]findRelatedCandidate(TransportAddress)", "name": "findRelatedCandidate", "arg_nums": 1, "params": [{"name": "relatedAddress", "type": "TransportAddress"}], "return_type": "LocalCandidate", "signature": "@Override\n    protected LocalCandidate findRelatedCandidate(\n            TransportAddress relatedAddress)", "original_string": "    @Override\n    protected LocalCandidate findRelatedCandidate(\n            TransportAddress relatedAddress)\n    {\n        return getParentComponent().findLocalCandidate(relatedAddress);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/LocalCandidate.java", "class_name": "LocalCandidate", "class_uri": "src/main/java/org/ice4j/ice/LocalCandidate.java.LocalCandidate", "attributes": {"modifiers": "@Override\n    protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "LocalCandidate", "classes": []}, "docstring": "\nFind the candidate corresponding to the address given in parameter.\n\n@param relatedAddress The related address:\n- null for a host candidate,\n- the base address (host candidate) for a reflexive candidate,\n- the mapped address (the mapped address of the TURN allocate response)\nfor a relayed candidate.\n- null for a peer reflexive candidate : there is no way to know the\nrelated address.\n\n@return The related candidate corresponding to the address given in\nparameter:\n- null for a host candidate,\n- the base address (host candidate) for a reflexive candidate,\n- the mapped address (the mapped address of the TURN allocate response)\nfor a relayed candidate.\n- null for a peer reflexive candidate : there is no way to know the\nrelated address.\n"}, {"uris": "src/main/java/org/ice4j/ice/LocalCandidate.java.LocalCandidate.[boolean]isSSL()", "name": "isSSL", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "public boolean isSSL()", "original_string": "    public boolean isSSL()\n    {\n        return isSSL;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/LocalCandidate.java", "class_name": "LocalCandidate", "class_uri": "src/main/java/org/ice4j/ice/LocalCandidate.java.LocalCandidate", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nGets the value of the 'ssl' flag.\n@return the value of the 'ssl' flag.\n"}, {"uris": "src/main/java/org/ice4j/ice/LocalCandidate.java.LocalCandidate.[void]setSSL(boolean)", "name": "setSSL", "arg_nums": 1, "params": [{"name": "isSSL", "type": "boolean"}], "return_type": "void", "signature": "public void setSSL(boolean isSSL)", "original_string": "    public void setSSL(boolean isSSL)\n    {\n        this.isSSL = isSSL;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/LocalCandidate.java", "class_name": "LocalCandidate", "class_uri": "src/main/java/org/ice4j/ice/LocalCandidate.java.LocalCandidate", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets the value of the 'ssl' flag.\n@param isSSL the value to set.\n"}, {"uris": "src/main/java/org/ice4j/ice/UPNPCandidate.java.UPNPCandidate.[]UPNPCandidate(TransportAddress,LocalCandidate,Component,GatewayDevice)", "name": "UPNPCandidate", "arg_nums": 4, "params": [{"name": "transportAddress", "type": "TransportAddress"}, {"name": "base", "type": "LocalCandidate"}, {"name": "parentComponent", "type": "Component"}, {"name": "device", "type": "GatewayDevice"}], "return_type": "", "signature": "public UPNPCandidate(TransportAddress transportAddress,\n            LocalCandidate base, Component parentComponent,\n            GatewayDevice device)", "original_string": "    public UPNPCandidate(TransportAddress transportAddress,\n            LocalCandidate base, Component parentComponent,\n            GatewayDevice device)\n    {\n        super(  transportAddress,\n                parentComponent,\n                CandidateType.SERVER_REFLEXIVE_CANDIDATE,\n                CandidateExtendedType.UPNP_CANDIDATE,\n                base);\n\n        this.setBase(base);\n        this.device = device;\n        setStunServerAddress(transportAddress);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/UPNPCandidate.java", "class_name": "UPNPCandidate", "class_uri": "src/main/java/org/ice4j/ice/UPNPCandidate.java.UPNPCandidate", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nCreates a <tt>UPNPCandidate</tt> for the specified transport, address,\nand base.\n\n@param transportAddress  the transport address that this candidate is\nencapsulating.\n@param base the base candidate\n@param parentComponent the <tt>Component</tt> that this candidate\nbelongs to.\n@param device the UPnP gateway device\n"}, {"uris": "src/main/java/org/ice4j/ice/UPNPCandidate.java.UPNPCandidate.[void]free()", "name": "free", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Override\n    protected void free()", "original_string": "    @Override\n    protected void free()\n    {\n        // delete the port mapping\n        try\n        {\n            device.deletePortMapping(getTransportAddress().getPort(), \"UDP\");\n        }\n        catch(Exception e)\n        {\n        }\n\n        IceSocketWrapper socket = getCandidateIceSocketWrapper();\n        if (socket != null)\n        {\n            socket.close();\n        }\n\n        device = null;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/UPNPCandidate.java", "class_name": "UPNPCandidate", "class_uri": "src/main/java/org/ice4j/ice/UPNPCandidate.java.UPNPCandidate", "attributes": {"modifiers": "@Override\n    protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nFrees resources allocated by this candidate such as its\n<tt>DatagramSocket</tt>, for example. The <tt>socket</tt> of this\n<tt>LocalCandidate</tt> is closed only if it is not the <tt>socket</tt>\nof the <tt>base</tt> of this <tt>LocalCandidate</tt>.\n"}, {"uris": "src/main/java/org/ice4j/ice/UPNPCandidate.java.UPNPCandidate.[IceSocketWrapper]getCandidateIceSocketWrapper()", "name": "getCandidateIceSocketWrapper", "arg_nums": 0, "params": [], "return_type": "IceSocketWrapper", "signature": "@Override\n    public IceSocketWrapper getCandidateIceSocketWrapper()", "original_string": "    @Override\n    public IceSocketWrapper getCandidateIceSocketWrapper()\n    {\n        return getBase().getCandidateIceSocketWrapper();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/UPNPCandidate.java", "class_name": "UPNPCandidate", "class_uri": "src/main/java/org/ice4j/ice/UPNPCandidate.java.UPNPCandidate", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "IceSocketWrapper", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/ice/UPNPCandidate.java.UPNPCandidate.[IceSocketWrapper]getIceSocketWrapper()", "name": "getIceSocketWrapper", "arg_nums": 0, "params": [], "return_type": "IceSocketWrapper", "signature": "@Override\n    protected IceSocketWrapper getIceSocketWrapper()", "original_string": "    @Override\n    protected IceSocketWrapper getIceSocketWrapper()\n    {\n        return getBase().getIceSocketWrapper();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/UPNPCandidate.java", "class_name": "UPNPCandidate", "class_uri": "src/main/java/org/ice4j/ice/UPNPCandidate.java.UPNPCandidate", "attributes": {"modifiers": "@Override\n    protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "IceSocketWrapper", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/ice/RemoteCandidate.java.RemoteCandidate.[]RemoteCandidate(TransportAddress,Component,CandidateType,String,long,RemoteCandidate)", "name": "RemoteCandidate", "arg_nums": 6, "params": [{"name": "transportAddress", "type": "TransportAddress"}, {"name": "parentComponent", "type": "Component"}, {"name": "type", "type": "CandidateType"}, {"name": "foundation", "type": "String"}, {"name": "priority", "type": "long"}, {"name": "relatedCandidate", "type": "RemoteCandidate"}], "return_type": "", "signature": "public RemoteCandidate(\n            TransportAddress transportAddress,\n            Component        parentComponent,\n            CandidateType    type,\n            String           foundation,\n            long             priority,\n            RemoteCandidate  relatedCandidate)", "original_string": "    public RemoteCandidate(\n            TransportAddress transportAddress,\n            Component        parentComponent,\n            CandidateType    type,\n            String           foundation,\n            long             priority,\n            RemoteCandidate  relatedCandidate)\n    {\n        this(\n                transportAddress,\n                parentComponent,\n                type,\n                foundation,\n                priority,\n                relatedCandidate,\n                null);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/RemoteCandidate.java", "class_name": "RemoteCandidate", "class_uri": "src/main/java/org/ice4j/ice/RemoteCandidate.java.RemoteCandidate", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nCreates a <tt>RemoteCandidate</tt> instance for the specified transport\naddress and properties.\n\n@param transportAddress  the transport address that this candidate is\nencapsulating.\n@param parentComponent the <tt>Component</tt> that this candidate\nbelongs to.\n@param type the <tt>CandidateType</tt> for this <tt>Candidate</tt>.\n@param foundation the <tt>RemoteCandidate</tt>'s foundation as reported\nby the session description protocol.\n@param priority the <tt>RemoteCandidate</tt>'s priority as reported\nby the session description protocol.\n@param relatedCandidate the relatedCandidate: null for a host candidate,\nthe base address (host candidate) for a reflexive candidate, the mapped\naddress (the mapped address of the TURN allocate response) for a relayed\ncandidate.\n"}, {"uris": "src/main/java/org/ice4j/ice/RemoteCandidate.java.RemoteCandidate.[]RemoteCandidate(TransportAddress,Component,CandidateType,String,long,RemoteCandidate,String)", "name": "RemoteCandidate", "arg_nums": 7, "params": [{"name": "transportAddress", "type": "TransportAddress"}, {"name": "parentComponent", "type": "Component"}, {"name": "type", "type": "CandidateType"}, {"name": "foundation", "type": "String"}, {"name": "priority", "type": "long"}, {"name": "relatedCandidate", "type": "RemoteCandidate"}, {"name": "ufrag", "type": "String"}], "return_type": "", "signature": "public RemoteCandidate(\n            TransportAddress transportAddress,\n            Component        parentComponent,\n            CandidateType    type,\n            String           foundation,\n            long             priority,\n            RemoteCandidate  relatedCandidate,\n            String            ufrag)", "original_string": "    public RemoteCandidate(\n            TransportAddress transportAddress,\n            Component        parentComponent,\n            CandidateType    type,\n            String           foundation,\n            long             priority,\n            RemoteCandidate  relatedCandidate,\n            String            ufrag)\n    {\n        super(transportAddress, parentComponent, type, relatedCandidate);\n        setFoundation(foundation);\n        setPriority(priority);\n        this.ufrag = ufrag;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/RemoteCandidate.java", "class_name": "RemoteCandidate", "class_uri": "src/main/java/org/ice4j/ice/RemoteCandidate.java.RemoteCandidate", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nCreates a <tt>RemoteCandidate</tt> instance for the specified transport\naddress and properties.\n\n@param transportAddress  the transport address that this candidate is\nencapsulating.\n@param parentComponent the <tt>Component</tt> that this candidate\nbelongs to.\n@param type the <tt>CandidateType</tt> for this <tt>Candidate</tt>.\n@param foundation the <tt>RemoteCandidate</tt>'s foundation as reported\nby the session description protocol.\n@param priority the <tt>RemoteCandidate</tt>'s priority as reported\nby the session description protocol.\n@param relatedCandidate the relatedCandidate: null for a host candidate,\nthe base address (host candidate) for a reflexive candidate, the mapped\naddress (the mapped address of the TURN allocate response) for a relayed\ncandidate.\n@param ufrag ufrag for the remote candidate\n"}, {"uris": "src/main/java/org/ice4j/ice/RemoteCandidate.java.RemoteCandidate.[void]setPriority(long)", "name": "setPriority", "arg_nums": 1, "params": [{"name": "priority", "type": "long"}], "return_type": "void", "signature": "public void setPriority(long priority)", "original_string": "    public void setPriority(long priority)\n    {\n        super.priority = priority;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/RemoteCandidate.java", "class_name": "RemoteCandidate", "class_uri": "src/main/java/org/ice4j/ice/RemoteCandidate.java.RemoteCandidate", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets the priority of this <tt>RemoteCandidate</tt>. Priority is a unique\npriority number that MUST be a positive integer between 1 and\n(2**32 - 1). This priority will be set and used by ICE algorithms to\ndetermine the order of the connectivity checks and the relative\npreference for candidates.\n\n@param priority the priority number between 1 and (2**32 - 1).\n"}, {"uris": "src/main/java/org/ice4j/ice/RemoteCandidate.java.RemoteCandidate.[boolean]isDefault()", "name": "isDefault", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "@Override\n    public boolean isDefault()", "original_string": "    @Override\n    public boolean isDefault()\n    {\n        Component parentCmp = getParentComponent();\n\n        if (parentCmp == null)\n            return false;\n\n        return equals(parentCmp.getDefaultRemoteCandidate());\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/RemoteCandidate.java", "class_name": "RemoteCandidate", "class_uri": "src/main/java/org/ice4j/ice/RemoteCandidate.java.RemoteCandidate", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nDetermines whether this <tt>Candidate</tt> is the default one for its\nparent component.\n\n@return <tt>true</tt> if this <tt>Candidate</tt> is the default for its\nparent component and <tt>false</tt> if it isn't or if it has no parent\nComponent yet.\n"}, {"uris": "src/main/java/org/ice4j/ice/RemoteCandidate.java.RemoteCandidate.[String]getUfrag()", "name": "getUfrag", "arg_nums": 0, "params": [], "return_type": "String", "signature": "public String getUfrag()", "original_string": "    public String getUfrag()\n    {\n        return ufrag;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/RemoteCandidate.java", "class_name": "RemoteCandidate", "class_uri": "src/main/java/org/ice4j/ice/RemoteCandidate.java.RemoteCandidate", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nGet the remote ufrag.\n\n@return remote ufrag\n"}, {"uris": "src/main/java/org/ice4j/ice/RemoteCandidate.java.RemoteCandidate.[RemoteCandidate]findRelatedCandidate(TransportAddress)", "name": "findRelatedCandidate", "arg_nums": 1, "params": [{"name": "relatedAddress", "type": "TransportAddress"}], "return_type": "RemoteCandidate", "signature": "protected RemoteCandidate findRelatedCandidate(\n            TransportAddress relatedAddress)", "original_string": "    protected RemoteCandidate findRelatedCandidate(\n            TransportAddress relatedAddress)\n    {\n        return getParentComponent().findRemoteCandidate(relatedAddress);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/RemoteCandidate.java", "class_name": "RemoteCandidate", "class_uri": "src/main/java/org/ice4j/ice/RemoteCandidate.java.RemoteCandidate", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "RemoteCandidate", "classes": []}, "docstring": "\nFind the candidate corresponding to the address given in parameter.\n\n@param relatedAddress The related address:\n- null for a host candidate,\n- the base address (host candidate) for a reflexive candidate,\n- the mapped address (the mapped address of the TURN allocate response)\nfor a relayed candidate.\n- null for a peer reflexive candidate : there is no way to know the\nrelated address.\n\n@return The related candidate corresponding to the address given in\nparameter:\n- null for a host candidate,\n- the base address (host candidate) for a reflexive candidate,\n- the mapped address (the mapped address of the TURN allocate response)\nfor a relayed candidate.\n- null for a peer reflexive candidate : there is no way to know the\nrelated address.\n"}, {"uris": "src/main/java/org/ice4j/ice/PeerReflexiveCandidate.java.PeerReflexiveCandidate.[]PeerReflexiveCandidate(TransportAddress,Component,LocalCandidate,long)", "name": "PeerReflexiveCandidate", "arg_nums": 4, "params": [{"name": "transportAddress", "type": "TransportAddress"}, {"name": "parentComponent", "type": "Component"}, {"name": "base", "type": "LocalCandidate"}, {"name": "priority", "type": "long"}], "return_type": "", "signature": "public PeerReflexiveCandidate(TransportAddress transportAddress,\n                                  Component        parentComponent,\n                                  LocalCandidate   base,\n                                  long             priority)", "original_string": "    public PeerReflexiveCandidate(TransportAddress transportAddress,\n                                  Component        parentComponent,\n                                  LocalCandidate   base,\n                                  long             priority)\n    {\n        super(\n                transportAddress,\n                parentComponent,\n                CandidateType.PEER_REFLEXIVE_CANDIDATE,\n                CandidateExtendedType.STUN_PEER_REFLEXIVE_CANDIDATE,\n                base);\n        super.setBase(base);\n        super.priority = priority;\n        super.setTcpType(base.getTcpType());\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/PeerReflexiveCandidate.java", "class_name": "PeerReflexiveCandidate", "class_uri": "src/main/java/org/ice4j/ice/PeerReflexiveCandidate.java.PeerReflexiveCandidate", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nCreates a <tt>PeerReflexiveCandidate</tt> instance for the specified\ntransport address and properties.\n\n@param transportAddress  the transport address that this candidate is\nencapsulating.\n@param parentComponent the <tt>Component</tt> that this candidate\nbelongs to.\n@param base the base of a peer reflexive candidate base is the local\ncandidate of the candidate pair from which the STUN check was sent.\n@param priority the priority of the candidate.\n"}, {"uris": "src/main/java/org/ice4j/ice/PeerReflexiveCandidate.java.PeerReflexiveCandidate.[IceSocketWrapper]getCandidateIceSocketWrapper()", "name": "getCandidateIceSocketWrapper", "arg_nums": 0, "params": [], "return_type": "IceSocketWrapper", "signature": "@Override\n    public IceSocketWrapper getCandidateIceSocketWrapper()", "original_string": "    @Override\n    public IceSocketWrapper getCandidateIceSocketWrapper()\n    {\n        return getBase().getCandidateIceSocketWrapper();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/PeerReflexiveCandidate.java", "class_name": "PeerReflexiveCandidate", "class_uri": "src/main/java/org/ice4j/ice/PeerReflexiveCandidate.java.PeerReflexiveCandidate", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "IceSocketWrapper", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/ice/ConnectivityCheckClient.java.ConnectivityCheckClient.[]ConnectivityCheckClient(Agent,ScheduledExecutorService,ExecutorService)", "name": "ConnectivityCheckClient", "arg_nums": 3, "params": [{"name": "parentAgent", "type": "Agent"}, {"name": "scheduledExecutorService", "type": "ScheduledExecutorService"}, {"name": "executorService", "type": "ExecutorService"}], "return_type": "", "signature": "public ConnectivityCheckClient(\n        Agent parentAgent,\n        ScheduledExecutorService scheduledExecutorService,\n        ExecutorService executorService)", "original_string": "    public ConnectivityCheckClient(\n        Agent parentAgent,\n        ScheduledExecutorService scheduledExecutorService,\n        ExecutorService executorService)\n    {\n        this.parentAgent = parentAgent;\n        this.scheduledExecutorService = scheduledExecutorService;\n        this.executorService = executorService;\n        logger = parentAgent.getLogger().createChildLogger(this.getClass().getName());\n\n        stunStack = this.parentAgent.getStunStack();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/ConnectivityCheckClient.java", "class_name": "ConnectivityCheckClient", "class_uri": "src/main/java/org/ice4j/ice/ConnectivityCheckClient.java.ConnectivityCheckClient", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nCreates a new <tt>ConnectivityCheckClient</tt> setting\n<tt>parentAgent</tt> as the agent that will be used for retrieving\ninformation such as user fragments for example.\n\n@param parentAgent the <tt>Agent</tt> that is creating this instance.\n@param scheduledExecutorService the <tt>ScheduledExecutorService</tt>\n                                to execute clients tasks\n@param executorService the <tt>ExecutorService</tt> to execute\n                       background tasks of connectivity check client\n"}, {"uris": "src/main/java/org/ice4j/ice/ConnectivityCheckClient.java.ConnectivityCheckClient.[boolean]isAlive()", "name": "isAlive", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "boolean isAlive()", "original_string": "    boolean isAlive()\n    {\n        return alive;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/ConnectivityCheckClient.java", "class_name": "ConnectivityCheckClient", "class_uri": "src/main/java/org/ice4j/ice/ConnectivityCheckClient.java.ConnectivityCheckClient", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nReturns a boolean value indicating whether we have received a STUN\nresponse or not.\n\nNote that this should NOT be taken as an indication that the negotiation\nhas succeeded, it merely indicates that we have received ANY STUN\nresponse, possibly a BINDING_ERROR_RESPONSE. It is completely\nunrelated/independent from the ICE spec and it's only meant to be used\nfor debugging purposes.\n\n@return a boolean value indicating whether we have received a STUN\nresponse or not.\n"}, {"uris": "src/main/java/org/ice4j/ice/ConnectivityCheckClient.java.ConnectivityCheckClient.[void]startChecks()", "name": "startChecks", "arg_nums": 0, "params": [], "return_type": "void", "signature": "public void startChecks()", "original_string": "    public void startChecks()\n    {\n        List<IceMediaStream> streamsWithPendingConnectivityEstablishment\n            = parentAgent.getStreamsWithPendingConnectivityEstablishment();\n\n        if (streamsWithPendingConnectivityEstablishment.size() > 0)\n        {\n            logger.info(\"Start connectivity checks.\");\n            startChecks(\n                    streamsWithPendingConnectivityEstablishment\n                        .get(0).getCheckList());\n        }\n        else\n        {\n            logger.info(\"Not starting any checks, because there are no pending \"\n                                + \"streams.\");\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/ConnectivityCheckClient.java", "class_name": "ConnectivityCheckClient", "class_uri": "src/main/java/org/ice4j/ice/ConnectivityCheckClient.java.ConnectivityCheckClient", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nStarts client connectivity checks for the first {@link IceMediaStream}\nin our parent {@link Agent}. This method should only be called by\nthe parent {@link Agent} when connectivity establishment starts for a\nparticular check list.\n"}, {"uris": "src/main/java/org/ice4j/ice/ConnectivityCheckClient.java.ConnectivityCheckClient.[void]startChecks(CheckList)", "name": "startChecks", "arg_nums": 1, "params": [{"name": "checkList", "type": "CheckList"}], "return_type": "void", "signature": "public void startChecks(CheckList checkList)", "original_string": "    public void startChecks(CheckList checkList)\n    {\n        synchronized (paceMakers)\n        {\n            if (stopped)\n            {\n                return;\n            }\n            PaceMaker paceMaker = new PaceMaker(checkList);\n            paceMakers.add(paceMaker);\n            paceMaker.schedule();\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/ConnectivityCheckClient.java", "class_name": "ConnectivityCheckClient", "class_uri": "src/main/java/org/ice4j/ice/ConnectivityCheckClient.java.ConnectivityCheckClient", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nStarts client connectivity checks for the {@link CandidatePair}s in\n <tt>checkList</tt>\n\n@param checkList the {@link CheckList} to start client side connectivity\nchecks for.\n"}, {"uris": "src/main/java/org/ice4j/ice/ConnectivityCheckClient.java.ConnectivityCheckClient.[void]sendBindingIndicationForPair(CandidatePair)", "name": "sendBindingIndicationForPair", "arg_nums": 1, "params": [{"name": "candidatePair", "type": "CandidatePair"}], "return_type": "void", "signature": "protected void sendBindingIndicationForPair(CandidatePair candidatePair)", "original_string": "    protected void sendBindingIndicationForPair(CandidatePair candidatePair)\n    {\n        LocalCandidate localCandidate = candidatePair.getLocalCandidate();\n        Indication indication = MessageFactory.createBindingIndication();\n\n        try\n        {\n            stunStack.sendIndication(\n                    indication,\n                    candidatePair.getRemoteCandidate().getTransportAddress(),\n                    localCandidate.getBase().getTransportAddress());\n            logger.trace(() ->\n                    \"sending binding indication to pair \" + candidatePair);\n        }\n        catch (Exception ex)\n        {\n            IceSocketWrapper stunSocket = localCandidate.getStunSocket(null);\n\n            if (stunSocket != null)\n            {\n                logger.info(\"Failed to send \" + indication + \" through \"\n                            + stunSocket.getLocalSocketAddress() + \"\\n\" +\n                        ex.toString());\n            }\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/ConnectivityCheckClient.java", "class_name": "ConnectivityCheckClient", "class_uri": "src/main/java/org/ice4j/ice/ConnectivityCheckClient.java.ConnectivityCheckClient", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCreates a STUN Binding {@link Indication} to a candidate pair. It is used\nas a keep-alive.\n\n@param candidatePair that {@link CandidatePair} that we'd like to send\nan indication\n"}, {"uris": "src/main/java/org/ice4j/ice/ConnectivityCheckClient.java.ConnectivityCheckClient.[TransactionID]startCheckForPair(CandidatePair)", "name": "startCheckForPair", "arg_nums": 1, "params": [{"name": "candidatePair", "type": "CandidatePair"}], "return_type": "TransactionID", "signature": "protected TransactionID startCheckForPair(CandidatePair candidatePair)", "original_string": "    protected TransactionID startCheckForPair(CandidatePair candidatePair)\n    {\n        return startCheckForPair(candidatePair, -1, -1, -1);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/ConnectivityCheckClient.java", "class_name": "ConnectivityCheckClient", "class_uri": "src/main/java/org/ice4j/ice/ConnectivityCheckClient.java.ConnectivityCheckClient", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "TransactionID", "classes": []}, "docstring": "\nCreates a STUN {@link Request} containing the necessary PRIORITY and\nCONTROLLING/CONTROLLED attributes. Also stores a reference to\n<tt>candidatePair</tt> in the newly created transactionID so that we\ncould then refer back to it in subsequent response or failure events.\n\n@param candidatePair that {@link CandidatePair} that we'd like to start\na check for.\n\n@return a reference to the {@link TransactionID} used in the connectivity\ncheck client transaction or <tt>null</tt> if sending the check has\nfailed for some reason.\n"}, {"uris": "src/main/java/org/ice4j/ice/ConnectivityCheckClient.java.ConnectivityCheckClient.[TransactionID]startCheckForPair(CandidatePair,int,int,int)", "name": "startCheckForPair", "arg_nums": 4, "params": [{"name": "candidatePair", "type": "CandidatePair"}, {"name": "originalWaitInterval", "type": "int"}, {"name": "maxWaitInterval", "type": "int"}, {"name": "maxRetransmissions", "type": "int"}], "return_type": "TransactionID", "signature": "protected TransactionID startCheckForPair(\n            CandidatePair candidatePair,\n            int originalWaitInterval,\n            int maxWaitInterval,\n            int maxRetransmissions)", "original_string": "    protected TransactionID startCheckForPair(\n            CandidatePair candidatePair,\n            int originalWaitInterval,\n            int maxWaitInterval,\n            int maxRetransmissions)\n    {\n        LocalCandidate localCandidate = candidatePair.getLocalCandidate();\n        //we don't need to do a canReach() verification here as it has been\n        //already verified during the gathering process.\n\n        Request request = MessageFactory.createBindingRequest();\n\n        //the priority we'd like the remote party to use for a peer\n        //reflexive candidate if one is discovered as a consequence of this\n        //check.\n        PriorityAttribute priority\n            = AttributeFactory.createPriorityAttribute(\n                    localCandidate.computePriorityForType(\n                            CandidateType.PEER_REFLEXIVE_CANDIDATE));\n\n        request.putAttribute(priority);\n\n        //controlling controlled\n        if (parentAgent.isControlling())\n        {\n            request.putAttribute(\n                    AttributeFactory.createIceControllingAttribute(\n                            parentAgent.getTieBreaker()));\n\n            //if we are the controlling agent then we need to indicate our\n            //nominated pairs.\n            if (candidatePair.isNominated())\n            {\n                logger.debug(() ->\n                        \"Add USE-CANDIDATE in check for: \"\n                            + candidatePair.toRedactedShortString());\n                request.putAttribute(\n                        AttributeFactory.createUseCandidateAttribute());\n            }\n        }\n        else\n        {\n            request.putAttribute(\n                    AttributeFactory.createIceControlledAttribute(\n                            parentAgent.getTieBreaker()));\n        }\n\n        //credentials\n        String media\n            = candidatePair\n                .getParentComponent().getParentStream().getName();\n        String localUserName = parentAgent.generateLocalUserName(media);\n\n        if (localUserName == null)\n            return null;\n\n        UsernameAttribute unameAttr\n            = AttributeFactory.createUsernameAttribute(localUserName);\n\n        request.putAttribute(unameAttr);\n\n        // TODO Also implement SASL prepare\n        MessageIntegrityAttribute msgIntegrity\n            = AttributeFactory.createMessageIntegrityAttribute(\n                    localUserName);\n\n        // when we will encode the MESSAGE-INTEGRITY attribute (thus\n        // generate the HMAC-SHA1 authentication), we need to know the\n        // remote key of the current stream, that why we pass the media\n        // name.\n        msgIntegrity.setMedia(media);\n        request.putAttribute(msgIntegrity);\n\n        TransactionID tran = TransactionID.createNewTransactionID();\n\n        tran.setApplicationData(candidatePair);\n\n        if (logger.isDebugEnabled())\n        {\n            logger.debug(\n                    \"start check for \" + candidatePair.toRedactedShortString() + \" tid \"\n                            + tran);\n        }\n        try\n        {\n            tran\n                = stunStack.sendRequest(\n                        request,\n                        candidatePair\n                            .getRemoteCandidate().getTransportAddress(),\n                        localCandidate.getBase().getTransportAddress(),\n                        this,\n                        tran,\n                        originalWaitInterval,\n                        maxWaitInterval,\n                        maxRetransmissions);\n            if (logger.isTraceEnabled())\n            {\n                logger.trace(\"checking pair \" + candidatePair.toRedactedString() + \" tid \" + tran);\n            }\n        }\n        catch (NetAccessManager.SocketNotFoundException e)\n        {\n            logger.info(\"Could not start connectivity check: \" + e.getMessage());\n        }\n        catch (Exception ex)\n        {\n            tran = null;\n\n            IceSocketWrapper stunSocket = localCandidate.getStunSocket(null);\n\n            if (stunSocket != null)\n            {\n                String msg\n                    = \"Failed to send \" + request + \" through \"\n                        + stunSocket.getLocalSocketAddress() + \".\";\n\n                if ((ex instanceof NoRouteToHostException)\n                        || (ex.getMessage() != null\n                                && ex.getMessage().equals(\"No route to host\")))\n                {\n                    msg += \" No route to host.\";\n                    ex = null;\n                }\n                logger.info(msg + (ex == null ? \"\" : \"\\n\" + ex.toString()));\n            }\n            else\n            {\n                logger.warn(\"Failed to send \" + request, ex);\n            }\n        }\n\n        return tran;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/ConnectivityCheckClient.java", "class_name": "ConnectivityCheckClient", "class_uri": "src/main/java/org/ice4j/ice/ConnectivityCheckClient.java.ConnectivityCheckClient", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "TransactionID", "classes": []}, "docstring": "\nCreates a STUN {@link Request} containing the necessary PRIORITY and\nCONTROLLING/CONTROLLED attributes. Also stores a reference to\n<tt>candidatePair</tt> in the newly created transactionID so that we\ncould then refer back to it in subsequent response or failure events.\n\n@param candidatePair that {@link CandidatePair} that we'd like to start\na check for.\n@param originalWaitInterval\n@param maxWaitInterval\n@param maxRetransmissions\n@return a reference to the {@link TransactionID} used in the connectivity\ncheck client transaction or <tt>null</tt> if sending the check has\nfailed for some reason.\n"}, {"uris": "src/main/java/org/ice4j/ice/ConnectivityCheckClient.java.ConnectivityCheckClient.[void]processResponse(StunResponseEvent)", "name": "processResponse", "arg_nums": 1, "params": [{"name": "ev", "type": "StunResponseEvent"}], "return_type": "void", "signature": "public void processResponse(StunResponseEvent ev)", "original_string": "    public void processResponse(StunResponseEvent ev)\n    {\n        alive = true;\n\n        CandidatePair checkedPair\n            = (CandidatePair) ev.getTransactionID().getApplicationData();\n\n        //make sure that the response came from the right place.\n        if (!checkSymmetricAddresses(ev))\n        {\n            logger.info(\"Received a non-symmetric response for pair: \"\n                                + checkedPair.toRedactedShortString() + \". Failing.\");\n            checkedPair.setStateFailed();\n        }\n        else\n        {\n            Response response = ev.getResponse();\n            char messageType = response.getMessageType();\n\n            //handle error responses.\n            if (messageType == Response.BINDING_ERROR_RESPONSE)\n            {\n                if (!response.containsAttribute(Attribute.ERROR_CODE))\n                {\n                    logger.debug(() -> \"Received a malformed error response.\");\n                    return; //malformed error response\n                }\n\n                processErrorResponse(ev);\n            }\n            //handle success responses.\n            else if (messageType == Response.BINDING_SUCCESS_RESPONSE)\n            {\n                processSuccessResponse(ev);\n            }\n        }\n\n        //Regardless of whether the check was successful or failed, the\n        //completion of the transaction may require updating of check list and\n        //timer states.\n        updateCheckListAndTimerStates(checkedPair);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/ConnectivityCheckClient.java", "class_name": "ConnectivityCheckClient", "class_uri": "src/main/java/org/ice4j/ice/ConnectivityCheckClient.java.ConnectivityCheckClient", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nHandles the <tt>response</tt> as per the procedures described in RFC 5245\nor in other words, by either changing the state of the corresponding pair\nto FAILED, or SUCCEEDED, or rescheduling a check in case of a role\nconflict.\n\n@param ev the {@link StunResponseEvent} that contains the newly received\nresponse.\n"}, {"uris": "src/main/java/org/ice4j/ice/ConnectivityCheckClient.java.ConnectivityCheckClient.[void]updateCheckListAndTimerStates(CandidatePair)", "name": "updateCheckListAndTimerStates", "arg_nums": 1, "params": [{"name": "checkedPair", "type": "CandidatePair"}], "return_type": "void", "signature": "private void updateCheckListAndTimerStates(CandidatePair checkedPair)", "original_string": "    private void updateCheckListAndTimerStates(CandidatePair checkedPair)\n    {\n        IceMediaStream stream\n            = checkedPair.getParentComponent().getParentStream();\n        final CheckList checkList = stream.getCheckList();\n\n        if (stream.getParentAgent().getState().isEstablished())\n            return;\n\n        //If all of the pairs in the check list are now either in the Failed or\n        //Succeeded state:\n        if (checkList.allChecksCompleted())\n        {\n            //If there is not a pair in the valid list for each component of the\n            //media stream, the state of the check list is set to Failed.\n            if ( !stream.validListContainsAllComponents())\n            {\n                final String streamName = stream.getName();\n                if (!checkListCompletionCheckers.containsKey(streamName))\n                {\n                    logger.info(\"CheckList will failed in a few seconds\" +\n                        \" if no succeeded checks come\");\n\n                    Runnable checkLickCompletedChecker = new Runnable()\n                    {\n                        @Override\n                        public void run()\n                        {\n                            if (checkList.getState() != CheckListState.COMPLETED)\n                            {\n                                logger.info(\"CheckList for stream \" +\n                                    streamName + \" FAILED\");\n\n                                checkList.setState(CheckListState.FAILED);\n                                parentAgent.checkListStatesUpdated();\n                            }\n                        }\n                    };\n\n                    final ScheduledFuture<?> scheduledCheckerFuture\n                        = scheduledExecutorService.schedule(\n                            checkLickCompletedChecker,\n                            5000,\n                            TimeUnit.MILLISECONDS);\n\n                    final ScheduledFuture<?> existingCheckerFuture\n                        = checkListCompletionCheckers\n                            .putIfAbsent(streamName, scheduledCheckerFuture);\n                    if (existingCheckerFuture != null)\n                    {\n                        scheduledCheckerFuture.cancel(false);\n                    }\n                }\n            }\n\n            //For each frozen check list, the agent groups together all of the\n            //pairs with the same foundation, and for each group, sets the\n            //state of the pair with the lowest component ID to Waiting.  If\n            //there is more than one such pair, the one with the highest\n            //priority is used.\n            List<IceMediaStream> allOtherStreams = parentAgent.getStreams();\n\n            allOtherStreams.remove(stream);\n            for (IceMediaStream anotherStream : allOtherStreams)\n            {\n                CheckList anotherCheckList = anotherStream.getCheckList();\n\n                if (anotherCheckList.isFrozen())\n                {\n                    anotherCheckList.computeInitialCheckListPairStates();\n                    startChecks(anotherCheckList);\n                }\n            }\n        }\n\n        parentAgent.checkListStatesUpdated();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/ConnectivityCheckClient.java", "class_name": "ConnectivityCheckClient", "class_uri": "src/main/java/org/ice4j/ice/ConnectivityCheckClient.java.ConnectivityCheckClient", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nUpdates all check list and timer states after a check has completed\n(both if completion was successful or not). The method implements\nsection \"7.1.3.3. Check List and Timer State Updates\"\n\n@param checkedPair the pair whose check has just completed.\n"}, {"uris": "src/main/java/org/ice4j/ice/ConnectivityCheckClient.java.ConnectivityCheckClient.[void]processSuccessResponse(StunResponseEvent)", "name": "processSuccessResponse", "arg_nums": 1, "params": [{"name": "ev", "type": "StunResponseEvent"}], "return_type": "void", "signature": "private void processSuccessResponse(StunResponseEvent ev)", "original_string": "    private void processSuccessResponse(StunResponseEvent ev)\n    {\n        Response response = ev.getResponse();\n        Request  request  = ev.getRequest();\n\n        CandidatePair checkedPair\n            = (CandidatePair) ev.getTransactionID().getApplicationData();\n\n        TransportAddress mappedAddress = null;\n\n        if (!response.containsAttribute(Attribute.XOR_MAPPED_ADDRESS))\n        {\n            logger.debug(() -> \"Received a success response with no \"\n                    + \"XOR_MAPPED_ADDRESS attribute.\");\n            logger.info(\"Pair failed (no XOR-MAPPED-ADDRESS): \"\n                    + checkedPair.toRedactedShortString() + \".\");\n            checkedPair.setStateFailed();\n            return; //malformed error response\n        }\n\n        XorMappedAddressAttribute mappedAddressAttr\n            = (XorMappedAddressAttribute)\n                response.getAttribute(Attribute.XOR_MAPPED_ADDRESS);\n\n        mappedAddress\n            = mappedAddressAttr.getAddress(response.getTransactionID());\n\n        // XXX AddressAttribute always returns UDP based TransportAddress\n        if (checkedPair.getLocalCandidate().getTransport() == Transport.TCP)\n        {\n            mappedAddress\n                = new TransportAddress(\n                        mappedAddress.getAddress(),\n                        mappedAddress.getPort(),\n                        Transport.TCP);\n        }\n\n        // In some situations we may have more than one local candidate matching\n        // the mapped address. In this case we want to find the that matches\n        // the socket we received the response on.\n        LocalCandidate base = checkedPair.getLocalCandidate().getBase();\n        LocalCandidate validLocalCandidate\n                = parentAgent.findLocalCandidate(mappedAddress, base);\n\n        RemoteCandidate validRemoteCandidate = checkedPair.getRemoteCandidate();\n\n        // RFC 5245: The agent checks the mapped address from the STUN\n        // response. If the transport address does not match any of the\n        // local candidates that the agent knows about, the mapped address\n        // represents a new candidate -- a peer reflexive candidate.\n        if (validLocalCandidate == null)\n        {\n            //Like other candidates, PEER-REFLEXIVE candidates have a type,\n            //base, priority, and foundation.  They are computed as follows:\n            //o The type is equal to peer reflexive.\n            //o The base is the local candidate of the candidate\n            //  pair from which the STUN check was sent.\n            //o Its priority is set equal to the value of the PRIORITY attribute\n            //  in the Binding request.\n            long priority = 0;\n            PriorityAttribute prioAttr = (PriorityAttribute)request\n                .getAttribute(Attribute.PRIORITY);\n            priority = prioAttr.getPriority();\n\n            LocalCandidate peerReflexiveCandidate\n                = new PeerReflexiveCandidate(\n                        mappedAddress,\n                        checkedPair.getParentComponent(),\n                        checkedPair.getLocalCandidate(),\n                        priority);\n\n            peerReflexiveCandidate.setBase(checkedPair.getLocalCandidate());\n\n            //This peer reflexive candidate is then added to the list of local\n            //candidates for the media stream, so that it would be available for\n            //updated offers.\n            checkedPair.getParentComponent().addLocalCandidate(\n                    peerReflexiveCandidate);\n\n            //However, the peer reflexive candidate is not paired with other\n            //remote candidates. This is not necessary; a valid pair will be\n            //generated from it momentarily\n            validLocalCandidate = peerReflexiveCandidate;\n\n            if (checkedPair.getParentComponent().getSelectedPair() == null)\n            {\n                logger.info(\"Receive a peer-reflexive candidate: \"\n                    + peerReflexiveCandidate.getTransportAddress().toRedactedString()\n                    + \".\");\n            }\n        }\n\n        //check if the resulting valid pair was already in our check lists.\n        CandidatePair existingPair\n            = parentAgent.findCandidatePair(\n                    validLocalCandidate.getTransportAddress(),\n                    validRemoteCandidate.getTransportAddress());\n\n        // RFC 5245: 7.1.3.2.2. The agent constructs a candidate pair whose\n        // local candidate equals the mapped address of the response, and whose\n        // remote candidate equals the destination address to which the request\n        // was sent. This is called a valid pair, since it has been validated\n        // by a STUN connectivity check.\n        CandidatePair validPair\n            = (existingPair == null)\n                ? parentAgent.createCandidatePair(\n                        validLocalCandidate,\n                        validRemoteCandidate)\n                : existingPair;\n\n        // we synchronize here because the same pair object can be processed (in\n        // another thread) in Agent's triggerCheck. A controlled agent select\n        // its pair here if the pair has useCandidateReceived as true (set in\n        // triggerCheck) or in triggerCheck if the pair state is succeeded (set\n        // here). So be sure that if a binding response and a binding request\n        // (for the same check) from other peer come at the very same time, that\n        // we will trigger the nominationConfirmed (that will pass the pair as\n        // as selected if it is the first time).\n        synchronized (checkedPair)\n        {\n            //The agent sets the state of the pair that *generated* the check to\n            //Succeeded.  Note that, the pair which *generated* the check may be\n            //different than the valid pair constructed above\n            if (checkedPair.getParentComponent().getSelectedPair() == null)\n            {\n                logger.info(\"Pair succeeded: \" + checkedPair.toRedactedShortString()\n                                + \".\");\n            }\n            checkedPair.setStateSucceeded();\n        }\n\n        if (!validPair.isValid())\n        {\n            if (validPair.getParentComponent().getSelectedPair() == null)\n                logger.info(\"Pair validated: \" + validPair.toRedactedShortString()\n                    + \".\");\n            parentAgent.validatePair(validPair);\n        }\n\n        //The agent changes the states for all other Frozen pairs for the\n        //same media stream and same foundation to Waiting.\n        IceMediaStream parentStream\n            = checkedPair.getParentComponent().getParentStream();\n\n        synchronized (this)\n        {\n            Vector<CandidatePair> parentCheckList\n                = new Vector<>(parentStream.getCheckList());\n\n            for (CandidatePair pair : parentCheckList)\n            {\n                if (pair.getState() == CandidatePairState.FROZEN\n                        && checkedPair.getFoundation().equals(\n                                pair.getFoundation()))\n                {\n                    pair.setStateWaiting();\n                }\n            }\n        }\n\n        // The agent examines the check list for all other streams in turn. If\n        // the check list is active, the agent changes the state of all Frozen\n        // pairs in that check list whose foundation matches a pair in the valid\n        // list under consideration to Waiting.\n        List<IceMediaStream> allOtherStreams = parentAgent.getStreams();\n        allOtherStreams.remove(parentStream);\n\n        for (IceMediaStream stream : allOtherStreams)\n        {\n            CheckList checkList = stream.getCheckList();\n            boolean wasFrozen = checkList.isFrozen();\n\n            synchronized (checkList)\n            {\n                for (CandidatePair pair : checkList)\n                {\n                    if (parentStream.validListContainsFoundation(\n                                pair.getFoundation())\n                            && pair.getState() == CandidatePairState.FROZEN)\n                    {\n                        pair.setStateWaiting();\n                    }\n                }\n            }\n\n            //if the checklList is still frozen after the above operations,\n            //the agent groups together all of the pairs with the same\n            //foundation, and for each group, sets the state of the pair with\n            //the lowest component ID to Waiting.  If there is more than one\n            //such pair, the one with the highest priority is used.\n            if (checkList.isFrozen())\n                checkList.computeInitialCheckListPairStates();\n\n            if (wasFrozen)\n            {\n                logger.info(\"Start checks for checkList of stream \" +\n                        stream.getName() + \" that was frozen\");\n                startChecks(checkList);\n            }\n        }\n\n        if (validPair.getParentComponent().getSelectedPair() == null)\n        {\n            logger.info(\"IsControlling: \"  + parentAgent.isControlling() +\n                \" USE-CANDIDATE:\" +\n                    (request.containsAttribute(Attribute.USE_CANDIDATE) ||\n                        checkedPair.useCandidateSent())\n                + \".\");\n        }\n\n        //If the agent was a controlling agent, and it had included a USE-\n        //CANDIDATE attribute in the Binding request, the valid pair generated\n        //from that check has its nominated flag set to true.\n        if (parentAgent.isControlling()\n                && request.containsAttribute(Attribute.USE_CANDIDATE))\n        {\n            if (validPair.getParentComponent().getSelectedPair() == null)\n            {\n                logger.info(\"Nomination confirmed for pair: \"\n                    + validPair.toRedactedShortString()\n                    + \".\");\n                parentAgent.nominationConfirmed( validPair );\n            }\n            else\n            {\n                logger.debug(() ->\n                        \"Keep alive for pair: \" + validPair.toRedactedShortString());\n            }\n        }\n        //If the agent is the controlled agent, the response may be the result\n        //of a triggered check that was sent in response to a request that\n        //itself had the USE-CANDIDATE attribute.  This case is described in\n        //Section 7.2.1.5, and may now result in setting the nominated flag for\n        //the pair learned from the original request.\n        else if (!parentAgent.isControlling()\n                && checkedPair.useCandidateReceived()\n                && !checkedPair.isNominated())\n        {\n            if (checkedPair.getParentComponent().getSelectedPair() == null)\n            {\n                logger.info(\n                        \"Nomination confirmed for pair: \"\n                            + validPair.toRedactedShortString());\n                parentAgent.nominationConfirmed(checkedPair);\n            }\n            else\n            {\n                logger.debug(() ->\n                        \"Keep alive for pair: \" + validPair.toRedactedShortString());\n            }\n        }\n\n        // Selected pairs get their consent freshness confirmed.\n        // XXX Should we also confirm consent freshness for non-selected pairs?\n        if (checkedPair.equals(checkedPair.getParentComponent().getSelectedPair()))\n        {\n            checkedPair.setConsentFreshness();\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/ConnectivityCheckClient.java", "class_name": "ConnectivityCheckClient", "class_uri": "src/main/java/org/ice4j/ice/ConnectivityCheckClient.java.ConnectivityCheckClient", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nHandles STUN success responses as per the rules in RFC 5245.\n\n@param ev the event that delivered the error response.\n"}, {"uris": "src/main/java/org/ice4j/ice/ConnectivityCheckClient.java.ConnectivityCheckClient.[boolean]checkSymmetricAddresses(StunResponseEvent)", "name": "checkSymmetricAddresses", "arg_nums": 1, "params": [{"name": "evt", "type": "StunResponseEvent"}], "return_type": "boolean", "signature": "private boolean checkSymmetricAddresses(StunResponseEvent evt)", "original_string": "    private boolean checkSymmetricAddresses(StunResponseEvent evt)\n    {\n        CandidatePair pair\n            = ((CandidatePair) evt.getTransactionID().getApplicationData());\n        TransportAddress localAddr\n            = pair.getLocalCandidate().getBase().getTransportAddress();\n\n        return\n            localAddr.equals(evt.getLocalAddress())\n                && pair.getRemoteCandidate().getTransportAddress().equals(\n                        evt.getRemoteAddress());\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/ConnectivityCheckClient.java", "class_name": "ConnectivityCheckClient", "class_uri": "src/main/java/org/ice4j/ice/ConnectivityCheckClient.java.ConnectivityCheckClient", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nReturns <tt>true</tt> if the {@link Response} in <tt>evt</tt> had a\nsource or a destination address that match those of the {@link Request},\nor <tt>false</tt> otherwise.<p>\nRFC 5245: The agent MUST check that the source IP address and port of\nthe response equal the destination IP address and port to which the\nBinding request was sent, and that the destination IP address and\nport of the response match the source IP address and port from which\nthe Binding request was sent.  In other words, the source and\ndestination transport addresses in the request and responses are\nsymmetric.  If they are not symmetric, the agent sets the state of\nthe pair to Failed.\n\n@param evt the {@link StunResponseEvent} that contains the {@link\nResponse} we need to examine\n\n@return <tt>true</tt> if the {@link Response} in <tt>evt</tt> had a\nsource or a destination address that matched those of the\n{@link Request}, or <tt>false</tt> otherwise.\n"}, {"uris": "src/main/java/org/ice4j/ice/ConnectivityCheckClient.java.ConnectivityCheckClient.[void]processErrorResponse(StunResponseEvent)", "name": "processErrorResponse", "arg_nums": 1, "params": [{"name": "ev", "type": "StunResponseEvent"}], "return_type": "void", "signature": "private void processErrorResponse(StunResponseEvent ev)", "original_string": "    private void processErrorResponse(StunResponseEvent ev)\n    {\n        Response response = ev.getResponse();\n        Request originalRequest = ev.getRequest();\n\n        ErrorCodeAttribute errorAttr\n            = (ErrorCodeAttribute) response.getAttribute(Attribute.ERROR_CODE);\n        // GTalk error code is not RFC3489/RFC5389 compliant\n        // example: 400 becomes 0x01 0x90 with GTalk\n        // RFC3489/RFC5389 gives 0x04 0x00\n        int cl = errorAttr.getErrorClass();\n        int co = errorAttr.getErrorNumber() & 0xff;\n        char errorCode = errorAttr.getErrorCode();\n\n        CandidatePair pair\n            = (CandidatePair) ev.getTransactionID().getApplicationData();\n\n        logger.trace(() -> \"Received error code \" + ((int) errorCode));\n\n        //RESOLVE ROLE_CONFLICTS\n        if (errorCode == ErrorCodeAttribute.ROLE_CONFLICT)\n        {\n            boolean wasControlling\n                = originalRequest.containsAttribute(Attribute.ICE_CONTROLLING);\n\n            logger.trace(() -> \"Switching to isControlling=\" + !wasControlling);\n            parentAgent.setControlling(!wasControlling);\n\n            pair.getParentComponent().getParentStream().getCheckList()\n                .scheduleTriggeredCheck(pair);\n        }\n        else\n        {\n            int code = cl * 100 + co;\n            String reason = errorAttr.getReasonPhrase();\n            String trimmedReason = reason != null ? reason.trim() : null;\n            logger.info(\n                    \"Error response for pair: \" + pair.toRedactedShortString() +\n                    \", failing.  Code = \" + code +\n                    \"(class=\" + cl + \"; number=\" + co + \"): \" + trimmedReason);\n            pair.setStateFailed();\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/ConnectivityCheckClient.java", "class_name": "ConnectivityCheckClient", "class_uri": "src/main/java/org/ice4j/ice/ConnectivityCheckClient.java.ConnectivityCheckClient", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nIn case of a role conflict, changes the state of the agent and\nreschedules the check, in all other cases sets the corresponding peer\nstate to FAILED.\n\n@param ev the event that delivered the error response.\n"}, {"uris": "src/main/java/org/ice4j/ice/ConnectivityCheckClient.java.ConnectivityCheckClient.[void]processTimeout(StunTimeoutEvent)", "name": "processTimeout", "arg_nums": 1, "params": [{"name": "ev", "type": "StunTimeoutEvent"}], "return_type": "void", "signature": "public void processTimeout(StunTimeoutEvent ev)", "original_string": "    public void processTimeout(StunTimeoutEvent ev)\n    {\n        CandidatePair pair\n            = (CandidatePair) ev.getTransactionID() .getApplicationData();\n\n        logger.info(\"timeout for pair: \" + pair.toRedactedShortString() + \", failing.\");\n        pair.setStateFailed();\n        updateCheckListAndTimerStates(pair);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/ConnectivityCheckClient.java", "class_name": "ConnectivityCheckClient", "class_uri": "src/main/java/org/ice4j/ice/ConnectivityCheckClient.java.ConnectivityCheckClient", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets the state of the corresponding {@link CandidatePair} to\n{@link CandidatePairState#FAILED} and updates check list and timer\nstates.\n\n@param ev the {@link StunTimeoutEvent} containing the original\ntransaction and hence {@link CandidatePair} that's being checked.\n"}, {"uris": "src/main/java/org/ice4j/ice/ConnectivityCheckClient.java.ConnectivityCheckClient.[void]stop()", "name": "stop", "arg_nums": 0, "params": [], "return_type": "void", "signature": "public void stop()", "original_string": "    public void stop()\n    {\n        synchronized (paceMakers)\n        {\n            stopped = true;\n            while (true)\n            {\n                final PaceMaker paceMaker = paceMakers.poll();\n                if (paceMaker == null)\n                {\n                    break;\n                }\n                paceMaker.cancel();\n            }\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/ConnectivityCheckClient.java", "class_name": "ConnectivityCheckClient", "class_uri": "src/main/java/org/ice4j/ice/ConnectivityCheckClient.java.ConnectivityCheckClient", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nStops and removes all <tt>PaceMaker</tt>s.\n"}, {"uris": "src/main/java/org/ice4j/ice/ConnectivityCheckClient.java.ConnectivityCheckClient.[boolean]isStopped()", "name": "isStopped", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "public boolean isStopped()", "original_string": "    public boolean isStopped() {\n        synchronized (paceMakers) {\n            return stopped;\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/ConnectivityCheckClient.java", "class_name": "ConnectivityCheckClient", "class_uri": "src/main/java/org/ice4j/ice/ConnectivityCheckClient.java.ConnectivityCheckClient", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": ""}, {"uris": "src/main/java/org/ice4j/ice/HostCandidate.java.HostCandidate.[]HostCandidate(IceSocketWrapper,Component)", "name": "HostCandidate", "arg_nums": 2, "params": [{"name": "socket", "type": "IceSocketWrapper"}, {"name": "parentComponent", "type": "Component"}], "return_type": "", "signature": "public HostCandidate(IceSocketWrapper socket,\n                         Component        parentComponent)", "original_string": "    public HostCandidate(IceSocketWrapper socket,\n                         Component        parentComponent)\n    {\n        this(socket,\n             parentComponent,\n             Transport.UDP);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/HostCandidate.java", "class_name": "HostCandidate", "class_uri": "src/main/java/org/ice4j/ice/HostCandidate.java.HostCandidate", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nCreates a HostCandidate for the specified transport address.\n\n@param socket the {@link DatagramSocket} that communication associated\nwith this <tt>Candidate</tt> will be going through.\n@param parentComponent the <tt>Component</tt> that this candidate\nbelongs to.\n"}, {"uris": "src/main/java/org/ice4j/ice/HostCandidate.java.HostCandidate.[]HostCandidate(TransportAddress,Component)", "name": "HostCandidate", "arg_nums": 2, "params": [{"name": "transportAddress", "type": "TransportAddress"}, {"name": "parentComponent", "type": "Component"}], "return_type": "", "signature": "public HostCandidate(\n            TransportAddress transportAddress,\n            Component parentComponent)", "original_string": "    public HostCandidate(\n            TransportAddress transportAddress,\n            Component parentComponent)\n    {\n        super(transportAddress,\n              parentComponent,\n              CandidateType.HOST_CANDIDATE,\n              CandidateExtendedType.HOST_CANDIDATE,\n              null);\n\n        this.socket = null;\n        setBase(this);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/HostCandidate.java", "class_name": "HostCandidate", "class_uri": "src/main/java/org/ice4j/ice/HostCandidate.java.HostCandidate", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nCreates a HostCandidate for the specified transport address.\n\n@param transportAddress the transport address for the new\n<tt>HostCandidate</tt>.\n@param parentComponent the <tt>Component</tt> that this candidate\nbelongs to.\n"}, {"uris": "src/main/java/org/ice4j/ice/HostCandidate.java.HostCandidate.[]HostCandidate(IceSocketWrapper,Component,Transport)", "name": "HostCandidate", "arg_nums": 3, "params": [{"name": "socket", "type": "IceSocketWrapper"}, {"name": "parentComponent", "type": "Component"}, {"name": "transport", "type": "Transport"}], "return_type": "", "signature": "public HostCandidate(IceSocketWrapper socket,\n                         Component        parentComponent,\n                         Transport        transport)", "original_string": "    public HostCandidate(IceSocketWrapper socket,\n                         Component        parentComponent,\n                         Transport        transport)\n    {\n        super(new TransportAddress(socket.getLocalAddress(),\n                        socket.getLocalPort(), transport),\n              parentComponent,\n              CandidateType.HOST_CANDIDATE,\n              CandidateExtendedType.HOST_CANDIDATE,\n              null);\n\n        this.socket = socket;\n        setBase(this);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/HostCandidate.java", "class_name": "HostCandidate", "class_uri": "src/main/java/org/ice4j/ice/HostCandidate.java.HostCandidate", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nCreates a HostCandidate for the specified transport address.\n\n@param socket the {@link DatagramSocket} that communication associated\nwith this <tt>Candidate</tt> will be going through.\n@param parentComponent the <tt>Component</tt> that this candidate\nbelongs to.\n@param transport transport protocol used\n"}, {"uris": "src/main/java/org/ice4j/ice/HostCandidate.java.HostCandidate.[StunDatagramPacketFilter]createStunDatagramPacketFilter(TransportAddress)", "name": "createStunDatagramPacketFilter", "arg_nums": 1, "params": [{"name": "serverAddress", "type": "TransportAddress"}], "return_type": "StunDatagramPacketFilter", "signature": "@Override\n    protected StunDatagramPacketFilter createStunDatagramPacketFilter(\n            TransportAddress serverAddress)", "original_string": "    @Override\n    protected StunDatagramPacketFilter createStunDatagramPacketFilter(\n            TransportAddress serverAddress)\n    {\n        /*\n         * Since we support TURN as well, we have to be able to receive TURN\n         * messages as well.\n         */\n        return new TurnDatagramPacketFilter(serverAddress);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/HostCandidate.java", "class_name": "HostCandidate", "class_uri": "src/main/java/org/ice4j/ice/HostCandidate.java.HostCandidate", "attributes": {"modifiers": "@Override\n    protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "StunDatagramPacketFilter", "classes": []}, "docstring": "\nCreates a new <tt>StunDatagramPacketFilter</tt> which is to capture STUN\nmessages and make them available to the <tt>DatagramSocket</tt> returned\nby {@link #getStunSocket(TransportAddress)}.\n\n@param serverAddress the address of the source we'd like to receive\npackets from or <tt>null</tt> if we'd like to intercept all STUN packets\n@return the <tt>StunDatagramPacketFilter</tt> which is to capture STUN\nmessages and make them available to the <tt>DatagramSocket</tt> returned\nby {@link #getStunSocket(TransportAddress)}\n@see LocalCandidate#createStunDatagramPacketFilter(TransportAddress)\n"}, {"uris": "src/main/java/org/ice4j/ice/HostCandidate.java.HostCandidate.[IceSocketWrapper]getCandidateIceSocketWrapper()", "name": "getCandidateIceSocketWrapper", "arg_nums": 0, "params": [], "return_type": "IceSocketWrapper", "signature": "@Override\n    public IceSocketWrapper getCandidateIceSocketWrapper()", "original_string": "    @Override\n    public IceSocketWrapper getCandidateIceSocketWrapper()\n    {\n        return socket;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/HostCandidate.java", "class_name": "HostCandidate", "class_uri": "src/main/java/org/ice4j/ice/HostCandidate.java.HostCandidate", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "IceSocketWrapper", "classes": []}, "docstring": "\n{@inheritDoc}\nSHOULD NOT be used outside ice4j. Only exposed for use in the\norg.ice4j.socket package.\n"}, {"uris": "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[]Candidate(TransportAddress,Component,CandidateType,T)", "name": "Candidate", "arg_nums": 4, "params": [{"name": "transportAddress", "type": "TransportAddress"}, {"name": "parentComponent", "type": "Component"}, {"name": "type", "type": "CandidateType"}, {"name": "relatedCandidate", "type": "T"}], "return_type": "", "signature": "public Candidate(TransportAddress transportAddress,\n                     Component        parentComponent,\n                     CandidateType    type,\n                     T relatedCandidate)", "original_string": "    public Candidate(TransportAddress transportAddress,\n                     Component        parentComponent,\n                     CandidateType    type,\n                     T relatedCandidate)\n    {\n        this.transportAddress = transportAddress;\n        this.parentComponent = parentComponent;\n        this.candidateType = type;\n        this.relatedCandidate = relatedCandidate;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Candidate.java", "class_name": "Candidate", "class_uri": "src/main/java/org/ice4j/ice/Candidate.java.Candidate", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nCreates a candidate for the specified transport address and properties.\n\n@param transportAddress  the transport address that this candidate is\nencapsulating.\n@param parentComponent the <tt>Component</tt> that this candidate\nbelongs to.\n@param type the <tt>CandidateType</tt> for this <tt>Candidate</tt>.\n@param relatedCandidate The related candidate:\n- null for a host candidate,\n- the base address (host candidate) for a reflexive candidate,\n- the mapped address (the mapped address of the TURN allocate response)\nfor a relayed candidate.\n- null for a peer reflexive candidate : there is no way to know the\nrelated address.\n"}, {"uris": "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[CandidateType]getType()", "name": "getType", "arg_nums": 0, "params": [], "return_type": "CandidateType", "signature": "public CandidateType getType()", "original_string": "    public CandidateType getType()\n    {\n        return candidateType;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Candidate.java", "class_name": "Candidate", "class_uri": "src/main/java/org/ice4j/ice/Candidate.java.Candidate", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "CandidateType", "classes": []}, "docstring": "\nReturns the type of this candidate which should be an instance of the\n{@link CandidateType} enumeration.\n\n@return a <tt>CandidateType</tt> indicating the type of this\n<tt>Candidate</tt>.\n"}, {"uris": "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[void]setCandidateType(CandidateType)", "name": "setCandidateType", "arg_nums": 1, "params": [{"name": "candidateType", "type": "CandidateType"}], "return_type": "void", "signature": "public void setCandidateType(CandidateType candidateType)", "original_string": "    public void setCandidateType(CandidateType candidateType)\n    {\n        this.candidateType = candidateType;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Candidate.java", "class_name": "Candidate", "class_uri": "src/main/java/org/ice4j/ice/Candidate.java.Candidate", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets the type of this candidate which should be an instance of the\n{@link CandidateType} enumeration.\n\n@param candidateType a <tt>CandidateType</tt> instance indicating the\ntype of this <tt>Candidate</tt>.\n"}, {"uris": "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[String]getFoundation()", "name": "getFoundation", "arg_nums": 0, "params": [], "return_type": "String", "signature": "public String getFoundation()", "original_string": "    public String getFoundation()\n    {\n        return foundation;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Candidate.java", "class_name": "Candidate", "class_uri": "src/main/java/org/ice4j/ice/Candidate.java.Candidate", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns a <tt>String</tt> containing the foundation of this\n<tt>Candidate</tt>. A foundation is an arbitrary <tt>String</tt> that is\nthe same for candidates that have the same type, base IP address,\ntransport protocol (UDP, TCP, etc.) and STUN or TURN server. If any of\nthese are different then the foundation will be different. Two candidate\npairs with the same foundation pairs are likely to have similar network\ncharacteristics. Typically, candidates for RTP and RTCP streams will\nshare the same foundation. Foundations are used in the frozen algorithm.\n\n@return the foundation of this <tt>Candidate</tt>.\n"}, {"uris": "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[void]setFoundation(String)", "name": "setFoundation", "arg_nums": 1, "params": [{"name": "foundation", "type": "String"}], "return_type": "void", "signature": "public void setFoundation(String foundation)", "original_string": "    public void setFoundation(String foundation)\n    {\n        this.foundation = foundation;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Candidate.java", "class_name": "Candidate", "class_uri": "src/main/java/org/ice4j/ice/Candidate.java.Candidate", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets this <tt>Candidate</tt>'s foundation. A foundation is an arbitrary\nstring that is always the same for candidates that have the same type,\nbase IP address, protocol (UDP, TCP, etc.) and STUN or TURN server. If\nany of these are different then the foundation will be different. Two\ncandidate pairs with the same foundation pairs are likely to have similar\nnetwork characteristics. Foundations are used in the frozen algorithm.\n\n@param foundation the foundation of this <tt>Candidate</tt>.\n"}, {"uris": "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[T]getBase()", "name": "getBase", "arg_nums": 0, "params": [], "return_type": "T", "signature": "public T getBase()", "original_string": "    public T getBase()\n    {\n        return base;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Candidate.java", "class_name": "Candidate", "class_uri": "src/main/java/org/ice4j/ice/Candidate.java.Candidate", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "T", "classes": []}, "docstring": "\nReturns this <tt>Candidate</tt>'s base. The base of a server\nreflexive candidate is the host candidate from which it was derived.\nA host candidate is also said to have a base, equal to that candidate\nitself. Similarly, the base of a relayed candidate is that candidate\nitself.\n\n@return the base <tt>Candidate</tt> for this <tt>Candidate</tt>.\n"}, {"uris": "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[void]setBase(T)", "name": "setBase", "arg_nums": 1, "params": [{"name": "base", "type": "T"}], "return_type": "void", "signature": "public void setBase(T base)", "original_string": "    public void setBase(T base)\n    {\n        this.base = base;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Candidate.java", "class_name": "Candidate", "class_uri": "src/main/java/org/ice4j/ice/Candidate.java.Candidate", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets this <tt>Candidate</tt>'s base. The base of a server\nreflexive candidate is the host candidate from which it was derived.\nA host candidate is also said to have a base, equal to that candidate\nitself. Similarly, the base of a relayed candidate is that candidate\nitself.\n\n@param base the base <tt>Candidate</tt> of this <tt>Candidate</tt>.\n"}, {"uris": "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[long]getPriority()", "name": "getPriority", "arg_nums": 0, "params": [], "return_type": "long", "signature": "public long getPriority()", "original_string": "    public long getPriority()\n    {\n        return priority;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Candidate.java", "class_name": "Candidate", "class_uri": "src/main/java/org/ice4j/ice/Candidate.java.Candidate", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "long", "classes": []}, "docstring": "\nReturns the priority of this candidate. Priority is a unique priority\nnumber that MUST be a positive integer between 1 and (2**32 - 1). This\npriority will be set and used by ICE algorithms to  determine the order\nof the connectivity checks and the relative preference for candidates.\n\n@return a number between 1 and (2**32 - 1) indicating the priority of\nthis candidate.\n"}, {"uris": "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[TransportAddress]getTransportAddress()", "name": "getTransportAddress", "arg_nums": 0, "params": [], "return_type": "TransportAddress", "signature": "public TransportAddress getTransportAddress()", "original_string": "    public TransportAddress getTransportAddress()\n    {\n        return transportAddress;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Candidate.java", "class_name": "Candidate", "class_uri": "src/main/java/org/ice4j/ice/Candidate.java.Candidate", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "TransportAddress", "classes": []}, "docstring": "\nReturns the transport address that this candidate is representing.\n\n@return the TransportAddress encapsulated by this Candidate.\n"}, {"uris": "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[boolean]equals(Object)", "name": "equals", "arg_nums": 1, "params": [{"name": "obj", "type": "Object"}], "return_type": "boolean", "signature": "@Override\n    public boolean equals(Object obj)", "original_string": "    @Override\n    public boolean equals(Object obj)\n        throws NullPointerException\n    {\n        if (obj == this)\n            return true;\n\n        if (! (obj instanceof Candidate))\n            return false;\n\n        Candidate<?> candidate = (Candidate<?>) obj;\n\n        //compare candidate addresses\n        if (! candidate.getTransportAddress().equals(getTransportAddress()))\n            return false;\n\n        //compare bases\n        Candidate<?> base = getBase();\n        Candidate<?> candidateBase = candidate.getBase();\n        boolean baseEqualsCandidateBase;\n\n        if (base == null)\n        {\n            if (candidateBase != null)\n                return false;\n            else\n                baseEqualsCandidateBase = true;\n        }\n        else\n        {\n            // If this and candidate are bases of themselves, their bases are\n            // considered equal.\n            baseEqualsCandidateBase\n                = (base == this && candidateBase == candidate)\n                    || base.equals(candidateBase);\n        }\n\n        //compare other properties\n        return\n            baseEqualsCandidateBase\n                && getPriority() == candidate.getPriority()\n                && getType() == candidate.getType()\n                && getFoundation().equals(candidate.getFoundation());\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Candidate.java", "class_name": "Candidate", "class_uri": "src/main/java/org/ice4j/ice/Candidate.java.Candidate", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nIndicates whether some other Candidate is \"equal to\" this one. We\nconsider candidates equal when they are redundant, i.e.\n<p>\n@param obj the reference object with which to compare.\n<p>\n@return <code>true</code> if this <tt>Candidate</tt> is equal to the\nobj argument; <code>false</code> otherwise.\n\n@throws java.lang.NullPointerException if <tt>obj</tt> is null;\n"}, {"uris": "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[int]hashCode()", "name": "hashCode", "arg_nums": 0, "params": [], "return_type": "int", "signature": "@Override\n    public int hashCode()", "original_string": "    @Override\n    public int hashCode()\n    {\n        // Even if the following hashCode algorithm has drawbacks because of it\n        // simplicity, it is better than nothing because at least it allows\n        // Candidate and, respectively, CandidatePair to be used as HashMap\n        // keys.\n        return\n            getParentComponent().hashCode() + getTransportAddress().hashCode();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Candidate.java", "class_name": "Candidate", "class_uri": "src/main/java/org/ice4j/ice/Candidate.java.Candidate", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[Component]getParentComponent()", "name": "getParentComponent", "arg_nums": 0, "params": [], "return_type": "Component", "signature": "public Component getParentComponent()", "original_string": "    public Component getParentComponent()\n    {\n        return parentComponent;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Candidate.java", "class_name": "Candidate", "class_uri": "src/main/java/org/ice4j/ice/Candidate.java.Candidate", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Component", "classes": []}, "docstring": "\nReturns a reference to the <tt>Component</tt> that this candidate belongs\nto.\n\n@return a reference to the <tt>Component</tt> that this candidate belongs\nto.\n"}, {"uris": "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[long]computePriority()", "name": "computePriority", "arg_nums": 0, "params": [], "return_type": "long", "signature": "public long computePriority()", "original_string": "    public long computePriority()\n    {\n        this.priority = computePriorityForType(getType());\n\n        return this.priority;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Candidate.java", "class_name": "Candidate", "class_uri": "src/main/java/org/ice4j/ice/Candidate.java.Candidate", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "long", "classes": []}, "docstring": "\nComputes the priority for this <tt>Candidate</tt> based on the procedures\ndefined in the ICE specification..\n\n@return the priority for this <tt>Candidate</tt> as per the procedures\ndefined in the ICE specification..\n"}, {"uris": "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[long]computeGTalkPriority()", "name": "computeGTalkPriority", "arg_nums": 0, "params": [], "return_type": "long", "signature": "public long computeGTalkPriority()", "original_string": "    public long computeGTalkPriority()\n    {\n        this.priority = computeGTalkPriorityForType(getType());\n\n        return this.priority;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Candidate.java", "class_name": "Candidate", "class_uri": "src/main/java/org/ice4j/ice/Candidate.java.Candidate", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "long", "classes": []}, "docstring": "\nComputes the priority for this <tt>Candidate</tt> based on the procedures\ndefined in the Google Talk specification.\n\n@return the priority for this <tt>Candidate</tt> as per the procedures\ndefined in the ICE specification..\n"}, {"uris": "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[long]computePriorityForType(CandidateType)", "name": "computePriorityForType", "arg_nums": 1, "params": [{"name": "candidateType", "type": "CandidateType"}], "return_type": "long", "signature": "public long computePriorityForType(CandidateType candidateType)", "original_string": "    public long computePriorityForType(CandidateType candidateType)\n    {\n        //According to the ICE spec we compute priority this way:\n        //priority = (2^24)*(type preference) +\n        //           (2^8)*(local preference) +\n        //           (2^0)*(256 - component ID)\n\n        return (long) (getTypePreference(candidateType)  << 24) +\n               (long) (getLocalPreference()              << 8 ) +\n               (long) (256 - getParentComponent().getComponentID());\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Candidate.java", "class_name": "Candidate", "class_uri": "src/main/java/org/ice4j/ice/Candidate.java.Candidate", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "long", "classes": []}, "docstring": "\nComputes the priority this <tt>Candidate</tt> would have if it were of\nthe specified <tt>candidateType</tt> and based on the procedures\ndefined in the ICE specification. The reason we need this method in\naddition to the {@link #computePriority()} one is the need to be able\nto compute the priority of a peer reflexive <tt>candidate</tt> that we\nmight learn during connectivity checks through this <tt>Candidate</tt>.\n\n@param candidateType the hypothetical type that we'd like to use when\ncomputing the priority for this <tt>Candidate</tt>.\n\n@return the priority this <tt>Candidate</tt> would have had if it were\nof the specified <tt>candidateType</tt>.\n"}, {"uris": "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[long]computeGTalkPriorityForType(CandidateType)", "name": "computeGTalkPriorityForType", "arg_nums": 1, "params": [{"name": "candidateType", "type": "CandidateType"}], "return_type": "long", "signature": "public long computeGTalkPriorityForType(CandidateType candidateType)", "original_string": "    public long computeGTalkPriorityForType(CandidateType candidateType)\n    {\n        long priority = 0;\n\n        /* Google Talk priority is in range 0 - 1, we multiply this by 1000\n         * to have a long rather than float\n         */\n        if (candidateType == CandidateType.HOST_CANDIDATE)\n        {\n           priority += 0.95 * 1000 -\n               (this.getBase().getTransport() == Transport.TCP ? 200 : 0);\n        }\n        else if (candidateType == CandidateType.PEER_REFLEXIVE_CANDIDATE)\n        {\n            priority += (long)(0.9 * 1000) -\n                (this.getBase().getTransport() == Transport.TCP ? 200 : 0);\n        }\n        else if (candidateType == CandidateType.SERVER_REFLEXIVE_CANDIDATE)\n        {\n            priority += (long)(0.9 * 1000);\n        }\n        else //relayed candidates\n        {\n            priority += (long)(0.5 * 1000);\n        }\n\n        priority -= getParentComponent().getComponentID() - 1;\n\n        InetAddress addr = getTransportAddress().getAddress();\n\n        // IPv6 has better priority than IPv4\n        if (addr instanceof Inet6Address)\n        {\n            if (addr.isLinkLocalAddress())\n            {\n                priority += 40;\n            }\n            else\n                priority += 50;\n        }\n\n        return priority;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Candidate.java", "class_name": "Candidate", "class_uri": "src/main/java/org/ice4j/ice/Candidate.java.Candidate", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "long", "classes": []}, "docstring": "\nComputes the priority this <tt>Candidate</tt> would have if it were of\nthe specified <tt>candidateType</tt> and based on the procedures\ndefined in the Google Talk specification.\n\n@param candidateType the hypothetical type that we'd like to use when\ncomputing the priority for this <tt>Candidate</tt>.\n@return the priority this <tt>Candidate</tt> would have had if it were\nof the specified <tt>candidateType</tt>.\n"}, {"uris": "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[int]getTypePreference(CandidateType)", "name": "getTypePreference", "arg_nums": 1, "params": [{"name": "candidateType", "type": "CandidateType"}], "return_type": "int", "signature": "private static int getTypePreference(CandidateType candidateType)", "original_string": "    private static int getTypePreference(CandidateType candidateType)\n    {\n        int typePreference;\n\n        if (candidateType == CandidateType.HOST_CANDIDATE)\n        {\n            typePreference = MAX_TYPE_PREFERENCE; // 126\n        }\n        else if (candidateType == CandidateType.PEER_REFLEXIVE_CANDIDATE)\n        {\n            typePreference = 110;\n        }\n        else if (candidateType == CandidateType.SERVER_REFLEXIVE_CANDIDATE)\n        {\n            typePreference = 100;\n        }\n        else //relayed candidates\n        {\n            typePreference =  MIN_TYPE_PREFERENCE; // 0\n        }\n\n        return typePreference;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Candidate.java", "class_name": "Candidate", "class_uri": "src/main/java/org/ice4j/ice/Candidate.java.Candidate", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\nReturns the type preference that should be used when computing priority\nfor <tt>Candidate</tt>s of the specified <tt>candidateType</tt>.\nThe type preference MUST be an integer from <tt>0</tt> to <tt>126</tt>\ninclusive, and represents the preference for the type of the candidate\n(where the types are local, server reflexive, peer reflexive and\nrelayed). A <tt>126</tt> is the highest preference, and a <tt>0</tt> is\nthe lowest. Setting the value to a <tt>0</tt> means that candidates of\nthis type will only be used as a last resort.  The type preference MUST\nbe identical for all candidates of the same type and MUST be different\nfor candidates of different types.  The type preference for peer\nreflexive candidates MUST be higher than that of server reflexive\ncandidates.\n\n@param candidateType the <tt>CandidateType</tt> that we'd like to obtain\na preference for.\n\n@return the type preference for this <tt>Candidate</tt> as per the\nprocedures in the ICE specification.\n"}, {"uris": "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[int]getLocalPreference()", "name": "getLocalPreference", "arg_nums": 0, "params": [], "return_type": "int", "signature": "private int getLocalPreference()", "original_string": "    private int getLocalPreference()\n    {\n        //The ICE spec says: When there is only a single IP address, this value\n        //SHOULD be set to.\n        if (getParentComponent().countLocalHostCandidates() < 2)\n            return MAX_LOCAL_PREFERENCE;\n\n        //The ICE spec also says: Furthermore, if an agent is multi-homed and\n        //has multiple IP addresses, the local preference for host candidates\n        //from a VPN interface SHOULD have a priority of 0.\n        if (isVirtual())\n            return MIN_LOCAL_PREFERENCE;\n\n        InetAddress addr = getTransportAddress().getAddress();\n\n        //the following tries to reuse precedence from RFC 3484 but that's a\n        //bit tricky since it is not meant to be used exactly the way that\n        //Johnnie seems to think.\n\n        //prefer IPv6 to IPv4\n        if (addr instanceof Inet6Address)\n        {\n            //prefer link local addresses to global ones\n            if (addr.isLinkLocalAddress())\n                return 30;\n            else\n                return 40;\n        }\n        else\n        {\n            //IPv4\n            return 10;\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Candidate.java", "class_name": "Candidate", "class_uri": "src/main/java/org/ice4j/ice/Candidate.java.Candidate", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\nCalculates and returns the local preference for this <tt>Candidate</tt>\n<p>\nThe local preference MUST be an integer from <tt>0</tt> to <tt>65535</tt>\ninclusive. It represents a preference for the particular IP address from\nwhich the candidate was obtained, in cases where an agent is multihomed.\n<tt>65535</tt> represents the highest preference, and a zero, the lowest.\nWhen there is only a single IP address, this value SHOULD be set to\n<tt>65535</tt>. More generally, if there are multiple candidates for a\nparticular component for a particular media stream which have the same\ntype, the local preference MUST be unique for each one. In this\nspecification, this only happens for multihomed hosts.  If a host is\nmultihomed because it is dual stacked, the local preference SHOULD be\nset equal to the precedence value for IP addresses described in RFC 3484.\n</p>\n@return the local preference for this <tt>Candidate</tt>.\n"}, {"uris": "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[boolean]isVirtual()", "name": "isVirtual", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "public boolean isVirtual()", "original_string": "    public boolean isVirtual()\n    {\n        return virtual;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Candidate.java", "class_name": "Candidate", "class_uri": "src/main/java/org/ice4j/ice/Candidate.java.Candidate", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nDetermines whether the address associated with this candidate belongs to\na VPN interface. In many cases (e.g. when running on a 1.5 JVM) we won't\nbe able to determine whether an interface is virtual or not. If we are\nhowever (that is when running a more recent JVM) we will reflect it in\nthis property. Note that the <tt>isVirtual</tt> property is not really\nan ICE concept. The ICE specs only mention it and give basic guidelines\nas to how it should be handled so other implementations maybe dealing\nwith it differently.\n\n@return <tt>true</tt> if we were able to determine that the address\nassociated with this <tt>Candidate</tt> comes from a virtual interface\nand <tt>false</tt> if otherwise.\n"}, {"uris": "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[void]setVirtual(boolean)", "name": "setVirtual", "arg_nums": 1, "params": [{"name": "virtual", "type": "boolean"}], "return_type": "void", "signature": "public void setVirtual(boolean virtual)", "original_string": "    public void setVirtual(boolean virtual)\n    {\n        this.virtual = virtual;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Candidate.java", "class_name": "Candidate", "class_uri": "src/main/java/org/ice4j/ice/Candidate.java.Candidate", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSpecifies whether the address associated with this candidate belongs to\na VPN interface. In many cases (e.g. when running on a 1.5 JVM) we won't\nbe able to determine whether an interface is virtual or not. If we are\nhowever (that is when running a more recent JVM) we will reflect it in\nthis property. Note that the <tt>isVirtual</tt> property is not really\nan ICE concept. The ICE specs only mention it and give basic guidelines\nas to how it should be handled so other implementations maybe dealing\nwith it differently.\n\n@param virtual <tt>true</tt> if we were able to determine that the\naddress associated with this <tt>Candidate</tt> comes from a virtual\ninterface and <tt>false</tt> if otherwise.\n"}, {"uris": "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[TransportAddress]getStunServerAddress()", "name": "getStunServerAddress", "arg_nums": 0, "params": [], "return_type": "TransportAddress", "signature": "public TransportAddress getStunServerAddress()", "original_string": "    public TransportAddress getStunServerAddress()\n    {\n        return stunServerAddress;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Candidate.java", "class_name": "Candidate", "class_uri": "src/main/java/org/ice4j/ice/Candidate.java.Candidate", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "TransportAddress", "classes": []}, "docstring": "\nReturns the address of the STUN server that was used to obtain this\n<tt>Candidate</tt> or <tt>null</tt> if this is not a server reflexive\ncandidate.\n\n@return the address of the STUN server that was used to obtain this\n<tt>Candidate</tt> or <tt>null</tt> if this is not a server reflexive\ncandidate.\n"}, {"uris": "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[void]setStunServerAddress(TransportAddress)", "name": "setStunServerAddress", "arg_nums": 1, "params": [{"name": "address", "type": "TransportAddress"}], "return_type": "void", "signature": "protected void setStunServerAddress(TransportAddress address)", "original_string": "    protected void setStunServerAddress(TransportAddress address)\n    {\n        this.stunServerAddress = address;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Candidate.java", "class_name": "Candidate", "class_uri": "src/main/java/org/ice4j/ice/Candidate.java.Candidate", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets the address of the STUN server that was used to obtain this\n<tt>Candidate</tt>. Only makes sense if this is a relayed candidate.\n\n@param address the address of the STUN server that was used to obtain\nthis <tt>Candidate</tt> or <tt>null</tt> if this is not a server\nreflexive candidate.\n"}, {"uris": "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[TransportAddress]getRelayServerAddress()", "name": "getRelayServerAddress", "arg_nums": 0, "params": [], "return_type": "TransportAddress", "signature": "public TransportAddress getRelayServerAddress()", "original_string": "    public TransportAddress getRelayServerAddress()\n    {\n        return relayServerAddress;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Candidate.java", "class_name": "Candidate", "class_uri": "src/main/java/org/ice4j/ice/Candidate.java.Candidate", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "TransportAddress", "classes": []}, "docstring": "\nReturns the address of the relay server (i.e. TURN, Jingle Nodes, ...)\nthat was used to obtain this <tt>Candidate</tt> or <tt>null</tt> if this\nis not a relayed candidate.\n\n@return the address of the relay server that was used to obtain this\n<tt>Candidate</tt> or <tt>null</tt> if this is not a relayed candidate.\n"}, {"uris": "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[void]setRelayServerAddress(TransportAddress)", "name": "setRelayServerAddress", "arg_nums": 1, "params": [{"name": "address", "type": "TransportAddress"}], "return_type": "void", "signature": "protected void setRelayServerAddress(TransportAddress address)", "original_string": "    protected void setRelayServerAddress(TransportAddress address)\n    {\n        this.relayServerAddress = address;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Candidate.java", "class_name": "Candidate", "class_uri": "src/main/java/org/ice4j/ice/Candidate.java.Candidate", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets the address of the relay server (i.e. TURN, Jingle Nodes, ...) that\nwas used to obtain this <tt>Candidate</tt>. Only makes sense if this is a\n relayed candidate.\n\n@param address the address of the relay server that was used to obtain\nthis <tt>Candidate</tt> or <tt>null</tt> if this is not a relayed\ncandidate.\n"}, {"uris": "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[TransportAddress]getMappedAddress()", "name": "getMappedAddress", "arg_nums": 0, "params": [], "return_type": "TransportAddress", "signature": "public TransportAddress getMappedAddress()", "original_string": "    public TransportAddress getMappedAddress()\n    {\n        return mappedAddress;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Candidate.java", "class_name": "Candidate", "class_uri": "src/main/java/org/ice4j/ice/Candidate.java.Candidate", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "TransportAddress", "classes": []}, "docstring": "\nReturns the address that was returned to us a \"mapped address\" from a\nTURN or a STUN server in case this <tt>Candidate</tt> is relayed or\nreflexive and <tt>null</tt> otherwise. Note that the address returned by\nthis method would be equal to the transport address for reflexive\n<tt>Candidate</tt>s but not for relayed ones.\n\n@return the address that our TURN/STUN server returned as mapped if this\nis a relayed or a reflexive <tt>Candidate</tt> or <tt>null</tt> if this\nis a host candidate.\n"}, {"uris": "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[void]setMappedAddress(TransportAddress)", "name": "setMappedAddress", "arg_nums": 1, "params": [{"name": "address", "type": "TransportAddress"}], "return_type": "void", "signature": "protected void setMappedAddress(TransportAddress address)", "original_string": "    protected void setMappedAddress(TransportAddress address)\n    {\n        this.mappedAddress = address;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Candidate.java", "class_name": "Candidate", "class_uri": "src/main/java/org/ice4j/ice/Candidate.java.Candidate", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets the address that was returned to us a \"mapped address\" from a\nTURN or a STUN server in case this <tt>Candidate</tt> is relayed.\n\n@param address the address that our TURN/STUN server returned as mapped\nif this is a relayed or a reflexive <tt>Candidate</tt>.\n"}, {"uris": "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[Transport]getTransport()", "name": "getTransport", "arg_nums": 0, "params": [], "return_type": "Transport", "signature": "public Transport getTransport()", "original_string": "    public Transport getTransport()\n    {\n        return getTransportAddress().getTransport();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Candidate.java", "class_name": "Candidate", "class_uri": "src/main/java/org/ice4j/ice/Candidate.java.Candidate", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Transport", "classes": []}, "docstring": "\nReturns the <tt>Transport</tt> for this <tt>Candidate</tt>. This is a\nconvenience method only and it is equivalent to retrieving the transport\nof this <tt>Candidate</tt>'s transport address.\n\n@return the <tt>Transport</tt> that this <tt>Candidate</tt> was obtained\nfor/with.\n"}, {"uris": "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[TransportAddress]getRelatedAddress()", "name": "getRelatedAddress", "arg_nums": 0, "params": [], "return_type": "TransportAddress", "signature": "public TransportAddress getRelatedAddress()", "original_string": "    public TransportAddress getRelatedAddress()\n    {\n        if (getRelatedCandidate() != null)\n        {\n            return getRelatedCandidate().getTransportAddress();\n        }\n        return null;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Candidate.java", "class_name": "Candidate", "class_uri": "src/main/java/org/ice4j/ice/Candidate.java.Candidate", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "TransportAddress", "classes": []}, "docstring": "\nReturns a <tt>TransportAddress</tt> related to this <tt>Candidate</tt>.\nRelated addresses are present for server reflexive, peer reflexive and\nrelayed candidates. If a candidate is server or peer reflexive,\nthe related address is equal to the base of this <tt>Candidate</tt>.\nIf the candidate is relayed, the returned address is equal to the mapped\naddress. If the candidate is a host candidate then the method returns\n<tt>null</tt>.\n\n@return the <tt>TransportAddress</tt> of the base if this is a reflexive\ncandidate, the mapped address in the case of a relayed candidate, and\n<tt>null</tt> if this is a host or a remote candidate.\n"}, {"uris": "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[T]findRelatedCandidate(TransportAddress)", "name": "findRelatedCandidate", "arg_nums": 1, "params": [{"name": "relatedAddress", "type": "TransportAddress"}], "return_type": "T", "signature": "protected abstract T findRelatedCandidate(TransportAddress relatedAddress)", "original_string": "    protected abstract T findRelatedCandidate(TransportAddress relatedAddress);", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Candidate.java", "class_name": "Candidate", "class_uri": "src/main/java/org/ice4j/ice/Candidate.java.Candidate", "attributes": {"modifiers": "protected abstract", "marker_annotations": [], "non_marker_annotations": ["protected", "abstract"], "comments": [], "return_type": "T", "classes": []}, "docstring": "\nFind the candidate corresponding to the address given in parameter.\n\n@param relatedAddress The related address:\n- null for a host candidate,\n- the base address (host candidate) for a reflexive candidate,\n- the mapped address (the mapped address of the TURN allocate response)\nfor a relayed candidate.\n- null for a peer reflexive candidate : there is no way to know the\nrelated address.\n\n@return The related candidate corresponding to the address given in\nparameter:\n- null for a host candidate,\n- the base address (host candidate) for a reflexive candidate,\n- the mapped address (the mapped address of the TURN allocate response)\nfor a relayed candidate.\n- null for a peer reflexive candidate : there is no way to know the\nrelated address.\n"}, {"uris": "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[String]toString()", "name": "toString", "arg_nums": 0, "params": [], "return_type": "String", "signature": "@Override\n    public String toString()", "original_string": "    @Override\n    public String toString() {\n        return toString(false);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Candidate.java", "class_name": "Candidate", "class_uri": "src/main/java/org/ice4j/ice/Candidate.java.Candidate", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns a <tt>String</tt> representation of this <tt>Candidate</tt>\ncontaining its <tt>TransportAddress</tt>, base, foundation, priority and\nwhatever other properties may be relevant.\n\n@return a <tt>String</tt> representation of this <tt>Candidate</tt>.\n"}, {"uris": "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[String]toRedactedString()", "name": "toRedactedString", "arg_nums": 0, "params": [], "return_type": "String", "signature": "public String toRedactedString()", "original_string": "    public String toRedactedString() {\n        return toString(true);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Candidate.java", "class_name": "Candidate", "class_uri": "src/main/java/org/ice4j/ice/Candidate.java.Candidate", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns a <tt>String</tt> representation of this <tt>Candidate</tt>\ncontaining its <tt>TransportAddress</tt>, base, foundation, priority and\nwhatever other properties may be relevant, but with its IP address redacted if\nredaction is enabled.\n\n@return a redacted <tt>String</tt> representation of this <tt>Candidate</tt>.\n"}, {"uris": "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[String]toString(boolean)", "name": "toString", "arg_nums": 1, "params": [{"name": "redacted", "type": "boolean"}], "return_type": "String", "signature": "private String toString(boolean redacted)", "original_string": "    private String toString(boolean redacted)\n    {\n        StringBuilder buff = new StringBuilder(\"candidate:\");\n\n        buff.append(getFoundation());\n        buff.append(\" \").append(getParentComponent().getComponentID());\n        buff.append(\" \").append(getTransport());\n        buff.append(\" \").append(getPriority());\n        if (redacted && getType() != CandidateType.RELAYED_CANDIDATE)\n        {\n            buff.append(\" \").append(getTransportAddress().getRedactedAddress());\n        }\n        else\n        {\n            buff.append(\" \").append(getTransportAddress().getHostAddress());\n        }\n        buff.append(\" \").append(getTransportAddress().getPort());\n        buff.append(\" typ \").append(getType());\n\n        TransportAddress relAddr = getRelatedAddress();\n\n        if (relAddr != null)\n        {\n            buff.append(\" raddr \");\n            if (redacted)\n            {\n                buff.append(relAddr.getRedactedAddress());\n            }\n            else\n            {\n                buff.append(relAddr.getHostAddress());\n            }\n            buff.append(\" rport \").append(relAddr.getPort());\n        }\n\n        return buff.toString();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Candidate.java", "class_name": "Candidate", "class_uri": "src/main/java/org/ice4j/ice/Candidate.java.Candidate", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "String", "classes": []}, "docstring": ""}, {"uris": "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[String]toShortString()", "name": "toShortString", "arg_nums": 0, "params": [], "return_type": "String", "signature": "public String toShortString()", "original_string": "    public String toShortString()\n    {\n        return getTransportAddress() + \"/\" + getType();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Candidate.java", "class_name": "Candidate", "class_uri": "src/main/java/org/ice4j/ice/Candidate.java.Candidate", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns short <tt>String</tt> representation of this <tt>Candidate</tt>.\n@return short <tt>String</tt> representation of this <tt>Candidate</tt>.\n"}, {"uris": "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[String]toRedactedShortString()", "name": "toRedactedShortString", "arg_nums": 0, "params": [], "return_type": "String", "signature": "public String toRedactedShortString()", "original_string": "    public String toRedactedShortString()\n    {\n        if (getType() == CandidateType.RELAYED_CANDIDATE)\n        {\n            return toShortString();\n        }\n        return getTransportAddress().toRedactedString() + \"/\" + getType();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Candidate.java", "class_name": "Candidate", "class_uri": "src/main/java/org/ice4j/ice/Candidate.java.Candidate", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": ""}, {"uris": "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[int]getDefaultPreference()", "name": "getDefaultPreference", "arg_nums": 0, "params": [], "return_type": "int", "signature": "protected int getDefaultPreference()", "original_string": "    protected int getDefaultPreference()\n    {\n        // https://tools.ietf.org/html/rfc5245#section-4.1.4\n        //\n        // It is RECOMMENDED that default candidates be chosen based on the\n        // likelihood of those candidates to work with the peer that is being\n        // contacted.  It is RECOMMENDED that the default candidates are the\n        // relayed candidates (if relayed candidates are available), server\n        // reflexive candidates (if server reflexive candidates are available),\n        // and finally host candidates.\n\n        switch (getType())\n        {\n        case RELAYED_CANDIDATE:\n            return 30;\n\n        case SERVER_REFLEXIVE_CANDIDATE:\n            return 20;\n\n        case HOST_CANDIDATE:\n            // Prefer IPv4 as default since many servers would still freak out\n            // when seeing IPv6 address.\n            return getTransportAddress().isIPv6() ? 10 : 15;\n\n        default:\n            // WTF?\n            return 5;\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Candidate.java", "class_name": "Candidate", "class_uri": "src/main/java/org/ice4j/ice/Candidate.java.Candidate", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\nReturns an integer indicating the preference that this <tt>Candidate</tt>\nshould be considered with for becoming a default candidate.\n\n@return an integer indicating the preference that this <tt>Candidate</tt>\nshould be considered with for becoming a default candidate.\n"}, {"uris": "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[boolean]canReach(Candidate<?>)", "name": "canReach", "arg_nums": 1, "params": [{"name": "dst", "type": "Candidate<?>"}], "return_type": "boolean", "signature": "public boolean canReach(Candidate<?> dst)", "original_string": "    public boolean canReach(Candidate<?> dst)\n    {\n        return getTransportAddress().canReach(dst.getTransportAddress());\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Candidate.java", "class_name": "Candidate", "class_uri": "src/main/java/org/ice4j/ice/Candidate.java.Candidate", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nDetermines whether this <tt>Candidate</tt>'s<tt>TransportAddress</tt> is\ntheoretically usable for communication with that of <tt>dst</tt>. Same\nas calling:\n<p>\n <tt>getTransportAddress().canReach(dst.getTransportAddress())</tt>\n</p>\n\n@param dst the <tt>Candidate</tt> that we'd like to check for\nreachability from this one.\n\n@return <tt>true</tt> if this {@link Candidate} shares the same\n<tt>Transport</tt> and family as <tt>dst</tt> or <tt>false</tt>\notherwise.\n\n"}, {"uris": "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[boolean]isDefault()", "name": "isDefault", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "public abstract boolean isDefault()", "original_string": "    public abstract boolean isDefault();", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Candidate.java", "class_name": "Candidate", "class_uri": "src/main/java/org/ice4j/ice/Candidate.java.Candidate", "attributes": {"modifiers": "public abstract", "marker_annotations": [], "non_marker_annotations": ["public", "abstract"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nDetermines whether this <tt>Candidate</tt> is the default one for its\nparent component.\n\n@return <tt>true</tt> if this <tt>Candidate</tt> is the default for its\nparent component and <tt>false</tt> if it isn't or if it has no parent\nComponent yet.\n"}, {"uris": "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[String]getUfrag()", "name": "getUfrag", "arg_nums": 0, "params": [], "return_type": "String", "signature": "public abstract String getUfrag()", "original_string": "    public abstract String getUfrag();", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Candidate.java", "class_name": "Candidate", "class_uri": "src/main/java/org/ice4j/ice/Candidate.java.Candidate", "attributes": {"modifiers": "public abstract", "marker_annotations": [], "non_marker_annotations": ["public", "abstract"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nGet the local ufrag.\n\n@return local ufrag\n"}, {"uris": "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[TransportAddress]getHostAddress()", "name": "getHostAddress", "arg_nums": 0, "params": [], "return_type": "TransportAddress", "signature": "public TransportAddress getHostAddress()", "original_string": "    public TransportAddress getHostAddress()\n    {\n        switch (getType())\n        {\n            case SERVER_REFLEXIVE_CANDIDATE:\n                if (getBase() != null)\n                {\n                    return getBase().getHostAddress();\n                }\n                break;\n            case PEER_REFLEXIVE_CANDIDATE:\n                if (getBase() != null)\n                {\n                    return getBase().getHostAddress();\n                }\n                break;\n            case RELAYED_CANDIDATE:\n                if (getRelatedCandidate() != null)\n                {\n                    return getRelatedCandidate().getHostAddress();\n                }\n                break;\n            default: //host candidate\n                return getTransportAddress();\n        }\n        return null;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Candidate.java", "class_name": "Candidate", "class_uri": "src/main/java/org/ice4j/ice/Candidate.java.Candidate", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "TransportAddress", "classes": []}, "docstring": "\nReturns this candidate host address.\n\n@return This candidate host address.\n"}, {"uris": "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[TransportAddress]getReflexiveAddress()", "name": "getReflexiveAddress", "arg_nums": 0, "params": [], "return_type": "TransportAddress", "signature": "public TransportAddress getReflexiveAddress()", "original_string": "    public TransportAddress getReflexiveAddress()\n    {\n        switch (getType())\n        {\n            case SERVER_REFLEXIVE_CANDIDATE:\n                return getTransportAddress();\n            case PEER_REFLEXIVE_CANDIDATE:\n                return getTransportAddress();\n            case RELAYED_CANDIDATE:\n                // Corresponding to getMappedAddress();\n                if (getRelatedCandidate() != null)\n                {\n                    return getRelatedCandidate().getReflexiveAddress();\n                }\n                break;\n            default: //host candidate\n                return null;\n        }\n        return null;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Candidate.java", "class_name": "Candidate", "class_uri": "src/main/java/org/ice4j/ice/Candidate.java.Candidate", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "TransportAddress", "classes": []}, "docstring": "\nReturns this candidate reflexive address.\n\n@return This candidate reflexive address. Null if this candidate\ndoes not use a peer/server reflexive address.\n"}, {"uris": "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[TransportAddress]getRelayedAddress()", "name": "getRelayedAddress", "arg_nums": 0, "params": [], "return_type": "TransportAddress", "signature": "public TransportAddress getRelayedAddress()", "original_string": "    public TransportAddress getRelayedAddress()\n    {\n        switch (getType())\n        {\n            case SERVER_REFLEXIVE_CANDIDATE:\n                return null;\n            case PEER_REFLEXIVE_CANDIDATE:\n                return null;\n            case RELAYED_CANDIDATE:\n                return getTransportAddress();\n            default: //host candidate\n                return null;\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Candidate.java", "class_name": "Candidate", "class_uri": "src/main/java/org/ice4j/ice/Candidate.java.Candidate", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "TransportAddress", "classes": []}, "docstring": "\nReturns this candidate relayed address.\n\n@return This candidate relayed address. Null if this candidate\ndoes not use a relay.\n"}, {"uris": "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[T]getRelatedCandidate()", "name": "getRelatedCandidate", "arg_nums": 0, "params": [], "return_type": "T", "signature": "public T getRelatedCandidate()", "original_string": "    public T getRelatedCandidate()\n    {\n        if (this.relatedCandidate == null)\n        {\n            TransportAddress relatedAddress = null;\n            switch (getType())\n            {\n            case SERVER_REFLEXIVE_CANDIDATE:\n                if (getBase() != null)\n                {\n                    relatedAddress = getBase().getTransportAddress();\n                }\n                break;\n            case PEER_REFLEXIVE_CANDIDATE:\n                if (getBase() != null)\n                {\n                    relatedAddress = getBase().getTransportAddress();\n                }\n                break;\n            case RELAYED_CANDIDATE:\n                relatedAddress = getMappedAddress();\n                break;\n            default:\n                //host candidate\n                return null;\n            }\n            // Update the related candidate conforming to the related address.\n            this.relatedCandidate = findRelatedCandidate(relatedAddress);\n        }\n\n        return this.relatedCandidate;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Candidate.java", "class_name": "Candidate", "class_uri": "src/main/java/org/ice4j/ice/Candidate.java.Candidate", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "T", "classes": []}, "docstring": "\nReturns the related candidate corresponding to the address given in\nparameter:\n- null for a host candidate,\n- the base address (host candidate) for a reflexive candidate,\n- the mapped address (the mapped address of the TURN allocate response)\nfor a relayed candidate.\n- null for a peer reflexive candidate : there is no way to know the\nrelated address.\n\n@return The related candidate corresponding to the address given in\nparameter:\n- null for a host candidate,\n- the base address (host candidate) for a reflexive candidate,\n- the mapped address (the mapped address of the TURN allocate response)\nfor a relayed candidate.\n- null for a peer reflexive candidate : there is no way to know the\nrelated address.\n"}, {"uris": "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[int]compareTo(T)", "name": "compareTo", "arg_nums": 1, "params": [{"name": "candidate", "type": "T"}], "return_type": "int", "signature": "public int compareTo(T candidate)", "original_string": "    public int compareTo(T candidate)\n    {\n        return CandidatePrioritizer.compareCandidates(this, candidate);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Candidate.java", "class_name": "Candidate", "class_uri": "src/main/java/org/ice4j/ice/Candidate.java.Candidate", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\nCompares this <tt>Candidate</tt> with the specified one based on their\npriority and returns a negative integer, zero, or a positive integer if\nthis <tt>Candidate</tt> has a lower, equal, or greater priority than the\nsecond.\n\n@param candidate the second <tt>Candidate</tt> to compare.\n\n@return a negative integer, zero, or a positive integer as the first\n<tt>Candidate</tt> has a lower, equal, or greater priority than the\nsecond.\n"}, {"uris": "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[CandidateTcpType]getTcpType()", "name": "getTcpType", "arg_nums": 0, "params": [], "return_type": "CandidateTcpType", "signature": "public CandidateTcpType getTcpType()", "original_string": "    public CandidateTcpType getTcpType()\n    {\n        return tcpType;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Candidate.java", "class_name": "Candidate", "class_uri": "src/main/java/org/ice4j/ice/Candidate.java.Candidate", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "CandidateTcpType", "classes": []}, "docstring": "\nGets the <tt>CandidateTcpType</tt> for this <tt>Candidate</tt>.\n@return the <tt>CandidateTcpType</tt> for this <tt>Candidate</tt>.\n"}, {"uris": "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[void]setTcpType(CandidateTcpType)", "name": "setTcpType", "arg_nums": 1, "params": [{"name": "tcpType", "type": "CandidateTcpType"}], "return_type": "void", "signature": "public void setTcpType(CandidateTcpType tcpType)", "original_string": "    public void setTcpType(CandidateTcpType tcpType)\n    {\n        this.tcpType = tcpType;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Candidate.java", "class_name": "Candidate", "class_uri": "src/main/java/org/ice4j/ice/Candidate.java.Candidate", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets the <tt>CandidateTcpType</tt> for this <tt>Candidate</tt>.\n@param tcpType the <tt>CandidateTcpType</tt> to set.\n"}, {"uris": "src/main/java/org/ice4j/ice/GoogleRelayedCandidate.java.GoogleRelayedCandidate.[]GoogleRelayedCandidate(TransportAddress,GoogleTurnCandidateHarvest,TransportAddress,String,String)", "name": "GoogleRelayedCandidate", "arg_nums": 5, "params": [{"name": "transportAddress", "type": "TransportAddress"}, {"name": "turnCandidateHarvest", "type": "GoogleTurnCandidateHarvest"}, {"name": "mappedAddress", "type": "TransportAddress"}, {"name": "username", "type": "String"}, {"name": "password", "type": "String"}], "return_type": "", "signature": "public GoogleRelayedCandidate(\n            TransportAddress transportAddress,\n            GoogleTurnCandidateHarvest turnCandidateHarvest,\n            TransportAddress mappedAddress,\n            String username,\n            String password)", "original_string": "    public GoogleRelayedCandidate(\n            TransportAddress transportAddress,\n            GoogleTurnCandidateHarvest turnCandidateHarvest,\n            TransportAddress mappedAddress,\n            String username,\n            String password)\n    {\n        super(\n            transportAddress,\n            turnCandidateHarvest.hostCandidate.getParentComponent(),\n            CandidateType.RELAYED_CANDIDATE,\n            CandidateExtendedType.GOOGLE_TURN_RELAYED_CANDIDATE,\n            turnCandidateHarvest.hostCandidate.getParentComponent()\n                .findLocalCandidate(mappedAddress));\n\n        if (transportAddress.getTransport() == Transport.TCP)\n        {\n            super.setExtendedType(\n                    CandidateExtendedType.GOOGLE_TCP_TURN_RELAYED_CANDIDATE);\n        }\n\n        this.turnCandidateHarvest = turnCandidateHarvest;\n        this.username = username;\n        this.password = password;\n\n        // RFC 5245: The base of a relayed candidate is that candidate itself.\n        setBase(this);\n        setRelayServerAddress(turnCandidateHarvest.harvester.stunServer);\n        setMappedAddress(mappedAddress);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/GoogleRelayedCandidate.java", "class_name": "GoogleRelayedCandidate", "class_uri": "src/main/java/org/ice4j/ice/GoogleRelayedCandidate.java.GoogleRelayedCandidate", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>RelayedCandidate</tt> which is to represent a\nspecific <tt>TransportAddress</tt> harvested through a specific\n<tt>HostCandidate</tt> and a TURN server with a specific\n<tt>TransportAddress</tt>.\n\n@param transportAddress the <tt>TransportAddress</tt> to be represented\nby the new instance\n@param turnCandidateHarvest the <tt>TurnCandidateHarvest</tt> which has\nharvested the new instance\n@param mappedAddress the mapped <tt>TransportAddress</tt> reported by the\nTURN server with the delivery of the replayed <tt>transportAddress</tt>\nto be represented by the new instance\n@param username username (Send request to the Google relay server need\nit)\n@param password password (used with XMPP gingle candidates).\nit)\n"}, {"uris": "src/main/java/org/ice4j/ice/GoogleRelayedCandidate.java.GoogleRelayedCandidate.[GoogleRelayedCandidateDatagramSocket]getRelayedCandidateDatagramSocket()", "name": "getRelayedCandidateDatagramSocket", "arg_nums": 0, "params": [], "return_type": "GoogleRelayedCandidateDatagramSocket", "signature": "private synchronized GoogleRelayedCandidateDatagramSocket\n        getRelayedCandidateDatagramSocket()", "original_string": "    private synchronized GoogleRelayedCandidateDatagramSocket\n        getRelayedCandidateDatagramSocket()\n    {\n        if (relayedCandidateDatagramSocket == null)\n        {\n            try\n            {\n                relayedCandidateDatagramSocket\n                    = new GoogleRelayedCandidateDatagramSocket(\n                            this,\n                            turnCandidateHarvest,\n                            username);\n            }\n            catch (SocketException sex)\n            {\n                throw new UndeclaredThrowableException(sex);\n            }\n        }\n        return relayedCandidateDatagramSocket;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/GoogleRelayedCandidate.java", "class_name": "GoogleRelayedCandidate", "class_uri": "src/main/java/org/ice4j/ice/GoogleRelayedCandidate.java.GoogleRelayedCandidate", "attributes": {"modifiers": "private synchronized", "marker_annotations": [], "non_marker_annotations": ["private", "synchronized"], "comments": [], "return_type": "GoogleRelayedCandidateDatagramSocket", "classes": []}, "docstring": "\nGets the <tt>RelayedCandidateDatagramSocket</tt> of this\n<tt>RelayedCandidate</tt>.\n<p>\n<b>Note</b>: The method is part of the internal API of\n<tt>RelayedCandidate</tt> and <tt>TurnCandidateHarvest</tt> and is not\nintended for public use.\n</p>\n\n@return the <tt>RelayedCandidateDatagramSocket</tt> of this\n<tt>RelayedCandidate</tt>\n"}, {"uris": "src/main/java/org/ice4j/ice/GoogleRelayedCandidate.java.GoogleRelayedCandidate.[GoogleRelayedCandidateSocket]getRelayedCandidateSocket()", "name": "getRelayedCandidateSocket", "arg_nums": 0, "params": [], "return_type": "GoogleRelayedCandidateSocket", "signature": "private synchronized GoogleRelayedCandidateSocket\n        getRelayedCandidateSocket()", "original_string": "    private synchronized GoogleRelayedCandidateSocket\n        getRelayedCandidateSocket()\n    {\n        if (relayedCandidateSocket == null)\n        {\n            try\n            {\n                relayedCandidateSocket\n                    = new GoogleRelayedCandidateSocket(\n                        this,\n                        turnCandidateHarvest,\n                        username);\n            }\n            catch (SocketException sex)\n            {\n                throw new UndeclaredThrowableException(sex);\n            }\n        }\n        return relayedCandidateSocket;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/GoogleRelayedCandidate.java", "class_name": "GoogleRelayedCandidate", "class_uri": "src/main/java/org/ice4j/ice/GoogleRelayedCandidate.java.GoogleRelayedCandidate", "attributes": {"modifiers": "private synchronized", "marker_annotations": [], "non_marker_annotations": ["private", "synchronized"], "comments": [], "return_type": "GoogleRelayedCandidateSocket", "classes": []}, "docstring": "\nGets the <tt>RelayedCandidateDatagramSocket</tt> of this\n<tt>RelayedCandidate</tt>.\n<p>\n<b>Note</b>: The method is part of the internal API of\n<tt>RelayedCandidate</tt> and <tt>TurnCandidateHarvest</tt> and is not\nintended for public use.\n</p>\n\n@return the <tt>RelayedCandidateDatagramSocket</tt> of this\n<tt>RelayedCandidate</tt>\n"}, {"uris": "src/main/java/org/ice4j/ice/GoogleRelayedCandidate.java.GoogleRelayedCandidate.[IceSocketWrapper]getCandidateIceSocketWrapper()", "name": "getCandidateIceSocketWrapper", "arg_nums": 0, "params": [], "return_type": "IceSocketWrapper", "signature": "@Override\n    public synchronized IceSocketWrapper getCandidateIceSocketWrapper()", "original_string": "    @Override\n    public synchronized IceSocketWrapper getCandidateIceSocketWrapper()\n    {\n        if (socket == null)\n        {\n            try\n            {\n                if (getTransport() == Transport.UDP)\n                {\n                    socket\n                       = new IceUdpSocketWrapper(new MultiplexingDatagramSocket(\n                            getRelayedCandidateDatagramSocket()));\n                }\n                else if (getTransport() == Transport.TCP)\n                {\n                    final Socket s = getRelayedCandidateSocket();\n                    socket = new IceTcpSocketWrapper(new MultiplexingSocket(s));\n                }\n            }\n            catch (Exception sex)\n            {\n                throw new UndeclaredThrowableException(sex);\n            }\n        }\n        return socket;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/GoogleRelayedCandidate.java", "class_name": "GoogleRelayedCandidate", "class_uri": "src/main/java/org/ice4j/ice/GoogleRelayedCandidate.java.GoogleRelayedCandidate", "attributes": {"modifiers": "@Override\n    public synchronized", "marker_annotations": ["@Override"], "non_marker_annotations": ["public", "synchronized"], "comments": [], "return_type": "IceSocketWrapper", "classes": []}, "docstring": "\nGets the application-purposed <tt>DatagramSocket</tt> associated with\nthis <tt>Candidate</tt>.\n\n@return the <tt>DatagramSocket</tt> associated with this\n<tt>Candidate</tt>\n@see LocalCandidate#getCandidateIceSocketWrapper()\n"}, {"uris": "src/main/java/org/ice4j/ice/GoogleRelayedCandidate.java.GoogleRelayedCandidate.[String]getPassword()", "name": "getPassword", "arg_nums": 0, "params": [], "return_type": "String", "signature": "public String getPassword()", "original_string": "    public String getPassword()\n    {\n        return this.password;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/GoogleRelayedCandidate.java", "class_name": "GoogleRelayedCandidate", "class_uri": "src/main/java/org/ice4j/ice/GoogleRelayedCandidate.java.GoogleRelayedCandidate", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns the password for this candidate.\n@return the password for this candidate.\n"}, {"uris": "src/main/java/org/ice4j/ice/CheckList.java.CheckList.[]CheckList(IceMediaStream)", "name": "CheckList", "arg_nums": 1, "params": [{"name": "parentStream", "type": "IceMediaStream"}], "return_type": "", "signature": "protected CheckList(IceMediaStream parentStream)", "original_string": "    protected CheckList(IceMediaStream parentStream)\n    {\n        this.parentStream = parentStream;\n        logger = parentStream.getLogger().createChildLogger(this.getClass().getName());\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/CheckList.java", "class_name": "CheckList", "class_uri": "src/main/java/org/ice4j/ice/CheckList.java.CheckList", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nCreates a check list with the specified name.\n\n@param parentStream a reference to the parent {@link IceMediaStream}\nthat created us and that we belong to.\n"}, {"uris": "src/main/java/org/ice4j/ice/CheckList.java.CheckList.[CheckListState]getState()", "name": "getState", "arg_nums": 0, "params": [], "return_type": "CheckListState", "signature": "public CheckListState getState()", "original_string": "    public CheckListState getState()\n    {\n        return state;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/CheckList.java", "class_name": "CheckList", "class_uri": "src/main/java/org/ice4j/ice/CheckList.java.CheckList", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "CheckListState", "classes": []}, "docstring": "\nReturns the state of this check list.\n\n@return the <tt>CheckListState</tt> of this check list.\n"}, {"uris": "src/main/java/org/ice4j/ice/CheckList.java.CheckList.[void]setState(CheckListState)", "name": "setState", "arg_nums": 1, "params": [{"name": "newState", "type": "CheckListState"}], "return_type": "void", "signature": "protected void setState(CheckListState newState)", "original_string": "    protected void setState(CheckListState newState)\n    {\n        CheckListState oldState = this.state;\n        this.state = newState;\n\n        fireStateChange(oldState, newState);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/CheckList.java", "class_name": "CheckList", "class_uri": "src/main/java/org/ice4j/ice/CheckList.java.CheckList", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets the state of this list.\n\n@param newState the <tt>CheckListState</tt> for this list.\n"}, {"uris": "src/main/java/org/ice4j/ice/CheckList.java.CheckList.[void]scheduleTriggeredCheck(CandidatePair)", "name": "scheduleTriggeredCheck", "arg_nums": 1, "params": [{"name": "pair", "type": "CandidatePair"}], "return_type": "void", "signature": "protected void scheduleTriggeredCheck(CandidatePair pair)", "original_string": "    protected void scheduleTriggeredCheck(CandidatePair pair)\n    {\n        synchronized(triggeredCheckQueue)\n        {\n            if (!triggeredCheckQueue.contains(pair))\n            {\n                triggeredCheckQueue.add(pair);\n                pair.setStateWaiting();\n            }\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/CheckList.java", "class_name": "CheckList", "class_uri": "src/main/java/org/ice4j/ice/CheckList.java.CheckList", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nAdds <tt>pair</tt> to the local triggered check queue unless it's already\nthere. Additionally, the method sets the pair's state to {@link\nCandidatePairState#WAITING}.\n\n@param pair the pair to schedule a triggered check for.\n"}, {"uris": "src/main/java/org/ice4j/ice/CheckList.java.CheckList.[CandidatePair]popTriggeredCheck()", "name": "popTriggeredCheck", "arg_nums": 0, "params": [], "return_type": "CandidatePair", "signature": "protected CandidatePair popTriggeredCheck()", "original_string": "    protected CandidatePair popTriggeredCheck()\n    {\n        synchronized(triggeredCheckQueue)\n        {\n            if (triggeredCheckQueue.size() > 0)\n                return triggeredCheckQueue.remove(0);\n        }\n        return null;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/CheckList.java", "class_name": "CheckList", "class_uri": "src/main/java/org/ice4j/ice/CheckList.java.CheckList", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "CandidatePair", "classes": []}, "docstring": "\nReturns the first {@link CandidatePair} in the triggered check queue or\n<tt>null</tt> if that queue is empty.\n\n@return the first {@link CandidatePair} in the triggered check queue or\n<tt>null</tt> if that queue is empty.\n"}, {"uris": "src/main/java/org/ice4j/ice/CheckList.java.CheckList.[CandidatePair]getNextOrdinaryPairToCheck()", "name": "getNextOrdinaryPairToCheck", "arg_nums": 0, "params": [], "return_type": "CandidatePair", "signature": "protected synchronized CandidatePair getNextOrdinaryPairToCheck()", "original_string": "    protected synchronized CandidatePair getNextOrdinaryPairToCheck()\n    {\n        if (size() < 1)\n            return null;\n\n        CandidatePair highestPriorityPair = null;\n\n        for (CandidatePair pair : this)\n        {\n            if (pair.getState() == CandidatePairState.WAITING)\n            {\n                if (highestPriorityPair == null\n                   || pair.getPriority() > highestPriorityPair.getPriority())\n                {\n                    highestPriorityPair = pair;\n                }\n            }\n        }\n\n        if (highestPriorityPair != null)\n            return highestPriorityPair;\n\n        for (CandidatePair pair : this)\n        {\n            if (pair.getState() == CandidatePairState.FROZEN)\n            {\n                if (highestPriorityPair == null\n                   || pair.getPriority() > highestPriorityPair.getPriority())\n                {\n                    highestPriorityPair = pair;\n                    pair.setStateWaiting();\n                }\n            }\n        }\n\n        return highestPriorityPair; //return even if null\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/CheckList.java", "class_name": "CheckList", "class_uri": "src/main/java/org/ice4j/ice/CheckList.java.CheckList", "attributes": {"modifiers": "protected synchronized", "marker_annotations": [], "non_marker_annotations": ["protected", "synchronized"], "comments": [], "return_type": "CandidatePair", "classes": []}, "docstring": "\nReturns the next {@link CandidatePair} that is eligible for a regular\nconnectivity check. According to RFC 5245 this would be the highest\npriority pair that is in the <tt>Waiting</tt> state or, if there is\nno such pair, the highest priority <tt>Frozen</tt> {@link CandidatePair}.\n\n@return the next {@link CandidatePair} that is eligible for a regular\nconnectivity check, which would either be the highest priority\n<tt>Waiting</tt> pair or, when there's no such pair, the highest priority\n<tt>Frozen</tt> pair or <tt>null</tt> otherwise\n"}, {"uris": "src/main/java/org/ice4j/ice/CheckList.java.CheckList.[CandidatePair]findPairMatching(LocalCandidate,RemoteCandidate)", "name": "findPairMatching", "arg_nums": 2, "params": [{"name": "local", "type": "LocalCandidate"}, {"name": "remote", "type": "RemoteCandidate"}], "return_type": "CandidatePair", "signature": "public synchronized CandidatePair findPairMatching(LocalCandidate local, RemoteCandidate remote)", "original_string": "    public synchronized CandidatePair findPairMatching(LocalCandidate local, RemoteCandidate remote)\n    {\n        for (CandidatePair pair : this)\n        {\n            if (pair.getLocalCandidate() == local ||\n                pair.getLocalCandidate().getTransportAddress().equals(local.getTransportAddress()))\n            {\n                if (pair.getRemoteCandidate() == remote ||\n                    pair.getRemoteCandidate().getTransportAddress().equals(remote.getTransportAddress()))\n                    return pair;\n            }\n        }\n        return null;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/CheckList.java", "class_name": "CheckList", "class_uri": "src/main/java/org/ice4j/ice/CheckList.java.CheckList", "attributes": {"modifiers": "public synchronized", "marker_annotations": [], "non_marker_annotations": ["public", "synchronized"], "comments": [], "return_type": "CandidatePair", "classes": []}, "docstring": "\nReturns a pair which matches the specified local and remote candidates'\ntransport addresses, if any, otherwise null.\n"}, {"uris": "src/main/java/org/ice4j/ice/CheckList.java.CheckList.[boolean]isActive()", "name": "isActive", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "public synchronized boolean isActive()", "original_string": "    public synchronized boolean isActive()\n    {\n        for (CandidatePair pair : this)\n        {\n            if (pair.getState() == CandidatePairState.WAITING)\n                return true;\n        }\n        return false;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/CheckList.java", "class_name": "CheckList", "class_uri": "src/main/java/org/ice4j/ice/CheckList.java.CheckList", "attributes": {"modifiers": "public synchronized", "marker_annotations": [], "non_marker_annotations": ["public", "synchronized"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nDetermines whether this <tt>CheckList</tt> can be considered active.\nRFC 5245 says: A check list with at least one pair that is Waiting is\ncalled an active check list.\n\n@return <tt>true</tt> if this list is active and <tt>false</tt>\notherwise.\n"}, {"uris": "src/main/java/org/ice4j/ice/CheckList.java.CheckList.[boolean]allChecksCompleted()", "name": "allChecksCompleted", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "public synchronized boolean allChecksCompleted()", "original_string": "    public synchronized boolean allChecksCompleted()\n    {\n        for (CandidatePair pair : this)\n        {\n            CandidatePairState pairState = pair.getState();\n\n            if ((pairState != CandidatePairState.SUCCEEDED)\n                    && (pairState != CandidatePairState.FAILED))\n            {\n                return false;\n            }\n        }\n        return true;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/CheckList.java", "class_name": "CheckList", "class_uri": "src/main/java/org/ice4j/ice/CheckList.java.CheckList", "attributes": {"modifiers": "public synchronized", "marker_annotations": [], "non_marker_annotations": ["public", "synchronized"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nDetermines whether all checks in this <tt>CheckList</tt> have ended one\nway or another.\n\n@return <tt>true</tt> if all checks for pairs in this list have either\nsucceeded or failed (but non are are currently waiting or in progress)\nor <tt>false</tt> otherwise..\n"}, {"uris": "src/main/java/org/ice4j/ice/CheckList.java.CheckList.[boolean]isFrozen()", "name": "isFrozen", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "public synchronized boolean isFrozen()", "original_string": "    public synchronized boolean isFrozen()\n    {\n        for (CandidatePair pair : this)\n        {\n            if (pair.getState() != CandidatePairState.FROZEN)\n                return false;\n        }\n        return true;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/CheckList.java", "class_name": "CheckList", "class_uri": "src/main/java/org/ice4j/ice/CheckList.java.CheckList", "attributes": {"modifiers": "public synchronized", "marker_annotations": [], "non_marker_annotations": ["public", "synchronized"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nDetermines whether this <tt>CheckList</tt> can be considered frozen.\nRFC 5245 says: a check list with all pairs Frozen is called a frozen\ncheck list.\n\n@return <tt>true</tt> if all pairs in this list are frozen and\n<tt>false</tt> otherwise.\n"}, {"uris": "src/main/java/org/ice4j/ice/CheckList.java.CheckList.[String]toString()", "name": "toString", "arg_nums": 0, "params": [], "return_type": "String", "signature": "@Override\n    public String toString()", "original_string": "    @Override\n    public String toString()\n    {\n        StringBuilder buff = new StringBuilder(\"CheckList. (num pairs=\");\n        buff.append(size()).append(\")\\n\");\n\n        for (CandidatePair pair : this)\n            buff.append(pair).append(\"\\n\");\n\n        return buff.toString();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/CheckList.java", "class_name": "CheckList", "class_uri": "src/main/java/org/ice4j/ice/CheckList.java.CheckList", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns a <tt>String</tt> representation of this check list. It\nconsists of a list of the <tt>CandidatePair</tt>s in the order they\nwere inserted and enclosed in square brackets (<tt>\"[]\"</tt>). The method\nwould also call and use the content returned by every member\n<tt>CandidatePair</tt>.\n\n@return A <tt>String</tt> representation of this collection.\n"}, {"uris": "src/main/java/org/ice4j/ice/CheckList.java.CheckList.[void]computeInitialCheckListPairStates()", "name": "computeInitialCheckListPairStates", "arg_nums": 0, "params": [], "return_type": "void", "signature": "protected synchronized void computeInitialCheckListPairStates()", "original_string": "    protected synchronized void computeInitialCheckListPairStates()\n    {\n        Map<String, CandidatePair> pairsToWait = new Hashtable<>();\n\n        //first, determine the pairs that we'd need to put in the waiting state.\n        for (CandidatePair pair : this)\n        {\n            //we need to check whether the pair is already in the wait list. if\n            //so we'll compare it with this one and determine which of the two\n            //needs to stay.\n            CandidatePair prevPair = pairsToWait.get(pair.getFoundation());\n\n            if (prevPair == null)\n            {\n                //first pair with this foundation.\n                pairsToWait.put(pair.getFoundation(), pair);\n                continue;\n            }\n\n            //we already have a pair with the same foundation. determine which\n            //of the two has the lower component id and higher priority and\n            //keep that one in the list.\n            if ( prevPair.getParentComponent() == pair.getParentComponent())\n            {\n                if (pair.getPriority() > prevPair.getPriority())\n                {\n                    //need to replace the pair in the list.\n                    pairsToWait.put(pair.getFoundation(), pair);\n                }\n            }\n            else\n            {\n                if (pair.getParentComponent().getComponentID()\n                            < prevPair.getParentComponent().getComponentID())\n                {\n                    //need to replace the pair in the list.\n                    pairsToWait.put(pair.getFoundation(), pair);\n                }\n            }\n        }\n\n        //now put the pairs we've selected in the Waiting state.\n        for (CandidatePair pairToWait : pairsToWait.values())\n            pairToWait.setStateWaiting();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/CheckList.java", "class_name": "CheckList", "class_uri": "src/main/java/org/ice4j/ice/CheckList.java.CheckList", "attributes": {"modifiers": "protected synchronized", "marker_annotations": [], "non_marker_annotations": ["protected", "synchronized"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nComputes and resets states of all pairs in this check list. For all pairs\nwith the same foundation, we set the state of the pair with the lowest\ncomponent ID to Waiting. If there is more than one such pair, the one\nwith the highest priority is used.\n"}, {"uris": "src/main/java/org/ice4j/ice/CheckList.java.CheckList.[void]recomputePairPriorities()", "name": "recomputePairPriorities", "arg_nums": 0, "params": [], "return_type": "void", "signature": "protected synchronized void recomputePairPriorities()", "original_string": "    protected synchronized void recomputePairPriorities()\n    {\n        //first, determine the pairs that we'd need to put in the waiting state.\n        for (CandidatePair pair : this)\n            pair.computePriority();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/CheckList.java", "class_name": "CheckList", "class_uri": "src/main/java/org/ice4j/ice/CheckList.java.CheckList", "attributes": {"modifiers": "protected synchronized", "marker_annotations": [], "non_marker_annotations": ["protected", "synchronized"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nRecomputes priorities of all pairs in this <tt>CheckList</tt>. Method is\nuseful when an agent changes its <tt>isControlling</tt> property as a\nresult of a role conflict.\n"}, {"uris": "src/main/java/org/ice4j/ice/CheckList.java.CheckList.[void]handleNominationConfirmed(CandidatePair)", "name": "handleNominationConfirmed", "arg_nums": 1, "params": [{"name": "nominatedPair", "type": "CandidatePair"}], "return_type": "void", "signature": "protected synchronized void handleNominationConfirmed(\n                                                    CandidatePair nominatedPair)", "original_string": "    protected synchronized void handleNominationConfirmed(\n                                                    CandidatePair nominatedPair)\n    {\n        Component cmp = nominatedPair.getParentComponent();\n\n        if (cmp.getSelectedPair() != null)\n        {\n            return;\n        }\n\n        logger.info(\n                \"Selected pair for stream \" + cmp.toShortString() + \": \"\n                    + nominatedPair.toRedactedShortString());\n\n        cmp.setSelectedPair(nominatedPair);\n\n        Iterator<CandidatePair> pairsIter = iterator();\n        while (pairsIter.hasNext())\n        {\n            CandidatePair pair = pairsIter.next();\n            if (pair.getParentComponent() == cmp\n                 &&( pair.getState() == CandidatePairState.WAITING\n                     || pair.getState() == CandidatePairState.FROZEN\n                     || (pair.getState() == CandidatePairState.IN_PROGRESS\n                         && pair.getPriority() < nominatedPair.getPriority())))\n            {\n                pairsIter.remove();\n            }\n        }\n\n        synchronized(triggeredCheckQueue)\n        {\n            Iterator<CandidatePair> triggeredPairsIter\n                = triggeredCheckQueue.iterator();\n            while (triggeredPairsIter.hasNext())\n            {\n                CandidatePair pair = triggeredPairsIter.next();\n                if (pair.getParentComponent() == cmp\n                    &&( pair.getState() == CandidatePairState.WAITING\n                        || pair.getState() == CandidatePairState.FROZEN\n                        || (pair.getState() == CandidatePairState.IN_PROGRESS\n                            && pair.getPriority() < nominatedPair\n                                                        .getPriority())))\n                {\n                    triggeredPairsIter.remove();\n                }\n            }\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/CheckList.java", "class_name": "CheckList", "class_uri": "src/main/java/org/ice4j/ice/CheckList.java.CheckList", "attributes": {"modifiers": "protected synchronized", "marker_annotations": [], "non_marker_annotations": ["protected", "synchronized"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nRemoves from this <tt>CheckList</tt> and its associated triggered check\nqueue all {@link CandidatePair}s that are in the <tt>Waiting</tt> and\n<tt>Frozen</tt> states and that belong to the same {@link Component} as\n<tt>nominatedPair</tt>. Typically this will happen upon confirmation of\nthe nomination of one pair in that component. The procedure implemented\nhere represents one of the cases specified in RFC 5245, Section 8.1.2:\n<p>\nThe agent MUST remove all Waiting and Frozen pairs in the check\nlist and triggered check queue for the same component as the\nnominated pairs for that media stream.\n</p><p>\nIf an In-Progress pair in the check list is for the same component as a\nnominated pair, the agent SHOULD cease retransmissions for its check\nif its pair priority is lower than the lowest-priority nominated pair\nfor that component.\n</p>\n\n@param nominatedPair the {@link CandidatePair} whose nomination we need\nto handle.\n"}, {"uris": "src/main/java/org/ice4j/ice/CheckList.java.CheckList.[String]getName()", "name": "getName", "arg_nums": 0, "params": [], "return_type": "String", "signature": "public String getName()", "original_string": "    public String getName()\n    {\n        return parentStream.getName();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/CheckList.java", "class_name": "CheckList", "class_uri": "src/main/java/org/ice4j/ice/CheckList.java.CheckList", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns the name of this check list so that we could use it for debugging\npurposes.\n\n@return a name for this check list that we could use to distinguish it\nfrom other check lists while debugging.\n"}, {"uris": "src/main/java/org/ice4j/ice/CheckList.java.CheckList.[boolean]containsNomineeForComponent(Component)", "name": "containsNomineeForComponent", "arg_nums": 1, "params": [{"name": "component", "type": "Component"}], "return_type": "boolean", "signature": "@Deprecated\n    public synchronized boolean containsNomineeForComponent(\n                                                        Component component)", "original_string": "    @Deprecated\n    public synchronized boolean containsNomineeForComponent(\n                                                        Component component)\n    {\n        for (CandidatePair pair : this)\n        {\n            if (pair.isNominated() && pair.getParentComponent() == component)\n                return true;\n        }\n\n        return false;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/CheckList.java", "class_name": "CheckList", "class_uri": "src/main/java/org/ice4j/ice/CheckList.java.CheckList", "attributes": {"modifiers": "@Deprecated\n    public synchronized", "marker_annotations": ["@Deprecated"], "non_marker_annotations": ["public", "synchronized"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nReturns <tt>true</tt> if this <tt>CheckList</tt> already contains a\nnominated {@link CandidatePair} for the specified <tt>component</tt>\nand <tt>false</tt> otherwise.\n\n@param component the {@link Component} that we'd whose nominees we are\ninterested in.\n\n@return <tt>true</tt> if this <tt>CheckList</tt> already contains a\nnominated {@link CandidatePair} for the specified <tt>component</tt>\nand <tt>false</tt> otherwise.\n@deprecated This method takes into account only candidates in the\nchecklist. In case of peer reflexives candidates nominated, they do not\nappears in checklist but in valid list.\n"}, {"uris": "src/main/java/org/ice4j/ice/CheckList.java.CheckList.[void]addStateChangeListener(PropertyChangeListener)", "name": "addStateChangeListener", "arg_nums": 1, "params": [{"name": "l", "type": "PropertyChangeListener"}], "return_type": "void", "signature": "public void addStateChangeListener(PropertyChangeListener l)", "original_string": "    public void addStateChangeListener(PropertyChangeListener l)\n    {\n        synchronized(stateListeners)\n        {\n            if (!stateListeners.contains(l))\n                this.stateListeners.add(l);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/CheckList.java", "class_name": "CheckList", "class_uri": "src/main/java/org/ice4j/ice/CheckList.java.CheckList", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nAdds <tt>l</tt> to the list of listeners tracking changes of the\n{@link CheckListState} of this <tt>CheckList</tt>\n\n@param l the listener to register.\n"}, {"uris": "src/main/java/org/ice4j/ice/CheckList.java.CheckList.[void]removeStateChangeListener(PropertyChangeListener)", "name": "removeStateChangeListener", "arg_nums": 1, "params": [{"name": "l", "type": "PropertyChangeListener"}], "return_type": "void", "signature": "public void removeStateChangeListener(PropertyChangeListener l)", "original_string": "    public void removeStateChangeListener(PropertyChangeListener l)\n    {\n        synchronized(stateListeners)\n        {\n            this.stateListeners.remove(l);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/CheckList.java", "class_name": "CheckList", "class_uri": "src/main/java/org/ice4j/ice/CheckList.java.CheckList", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nRemoves <tt>l</tt> from the list of listeners tracking changes of the\n{@link CheckListState} of this <tt>CheckList</tt>\n\n@param l the listener to remove.\n"}, {"uris": "src/main/java/org/ice4j/ice/CheckList.java.CheckList.[void]fireStateChange(CheckListState,CheckListState)", "name": "fireStateChange", "arg_nums": 2, "params": [{"name": "oldState", "type": "CheckListState"}, {"name": "newState", "type": "CheckListState"}], "return_type": "void", "signature": "private void fireStateChange(CheckListState oldState,\n                                 CheckListState newState)", "original_string": "    private void fireStateChange(CheckListState oldState,\n                                 CheckListState newState)\n    {\n        List<PropertyChangeListener> listenersCopy;\n\n        synchronized(stateListeners)\n        {\n            listenersCopy = new LinkedList<>(stateListeners);\n        }\n\n        PropertyChangeEvent evt = new PropertyChangeEvent(\n                        this, PROPERTY_CHECK_LIST_STATE, oldState, newState);\n\n        for (PropertyChangeListener l : listenersCopy)\n        {\n            l.propertyChange(evt);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/CheckList.java", "class_name": "CheckList", "class_uri": "src/main/java/org/ice4j/ice/CheckList.java.CheckList", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCreates a new {@link PropertyChangeEvent} and delivers it to all\ncurrently registered state listeners.\n\n@param oldState the {@link CheckListState} we had before the change\n@param newState the {@link CheckListState} we had after the change\n"}, {"uris": "src/main/java/org/ice4j/ice/CheckList.java.CheckList.[void]addChecksListener(PropertyChangeListener)", "name": "addChecksListener", "arg_nums": 1, "params": [{"name": "l", "type": "PropertyChangeListener"}], "return_type": "void", "signature": "public void addChecksListener(PropertyChangeListener l)", "original_string": "    public void addChecksListener(PropertyChangeListener l)\n    {\n        synchronized(checkListeners)\n        {\n            if (!checkListeners.contains(l))\n            {\n                checkListeners.add(l);\n            }\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/CheckList.java", "class_name": "CheckList", "class_uri": "src/main/java/org/ice4j/ice/CheckList.java.CheckList", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nAdd a <tt>CheckListener</tt>. It will be notified when ordinary checks\nended.\n\n@param l <tt>CheckListener</tt> to add\n"}, {"uris": "src/main/java/org/ice4j/ice/CheckList.java.CheckList.[void]removeChecksListener(PropertyChangeListener)", "name": "removeChecksListener", "arg_nums": 1, "params": [{"name": "l", "type": "PropertyChangeListener"}], "return_type": "void", "signature": "public void removeChecksListener(PropertyChangeListener l)", "original_string": "    public void removeChecksListener(PropertyChangeListener l)\n    {\n        synchronized(checkListeners)\n        {\n            if (checkListeners.contains(l))\n            {\n                checkListeners.remove(l);\n            }\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/CheckList.java", "class_name": "CheckList", "class_uri": "src/main/java/org/ice4j/ice/CheckList.java.CheckList", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nRemove a <tt>CheckListener</tt>.\n\n@param l <tt>CheckListener</tt> to remove\n"}, {"uris": "src/main/java/org/ice4j/ice/CheckList.java.CheckList.[void]fireEndOfOrdinaryChecks()", "name": "fireEndOfOrdinaryChecks", "arg_nums": 0, "params": [], "return_type": "void", "signature": "protected void fireEndOfOrdinaryChecks()", "original_string": "    protected void fireEndOfOrdinaryChecks()\n    {\n        List<PropertyChangeListener> listenersCopy;\n\n        synchronized(checkListeners)\n        {\n            listenersCopy = new LinkedList<>(checkListeners);\n        }\n\n        PropertyChangeEvent evt = new PropertyChangeEvent(\n                        this, PROPERTY_CHECK_LIST_CHECKS, false, true);\n\n        for (PropertyChangeListener l : listenersCopy)\n        {\n            l.propertyChange(evt);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/CheckList.java", "class_name": "CheckList", "class_uri": "src/main/java/org/ice4j/ice/CheckList.java.CheckList", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCreates a new {@link PropertyChangeEvent} and delivers it to all\ncurrently registered checks listeners.\n"}, {"uris": "src/main/java/org/ice4j/ice/CheckList.java.CheckList.[IceMediaStream]getParentStream()", "name": "getParentStream", "arg_nums": 0, "params": [], "return_type": "IceMediaStream", "signature": "public IceMediaStream getParentStream()", "original_string": "    public IceMediaStream getParentStream()\n    {\n        return parentStream;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/CheckList.java", "class_name": "CheckList", "class_uri": "src/main/java/org/ice4j/ice/CheckList.java.CheckList", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "IceMediaStream", "classes": []}, "docstring": "\nReturns a reference to the {@link IceMediaStream} that created and that\nmaintains this check list.\n\n@return a reference to the {@link IceMediaStream} that this list belongs\nto.\n"}, {"uris": "src/main/java/org/ice4j/ice/FoundationsRegistry.java.FoundationsRegistry.[void]assignFoundation(Candidate<?>)", "name": "assignFoundation", "arg_nums": 1, "params": [{"name": "candidate", "type": "Candidate<?>"}], "return_type": "void", "signature": "public void assignFoundation(Candidate<?> candidate)", "original_string": "    public void assignFoundation(Candidate<?> candidate)\n    {\n        //create the foundation key String\n        CandidateType candidateType = candidate.getType();\n        String type = candidateType.toString();\n        String base\n                  = candidate.getBase().getTransportAddress().getHostAddress();\n        String server;\n\n        switch (candidateType)\n        {\n        case SERVER_REFLEXIVE_CANDIDATE:\n            TransportAddress serverAddress = candidate.getStunServerAddress();\n            server = (serverAddress == null)\n                        ? \"\"\n                        : serverAddress.getHostAddress();\n            break;\n        case RELAYED_CANDIDATE:\n            server = candidate.getRelayServerAddress().getHostAddress();\n            break;\n        default:\n            server = null;\n            break;\n        }\n\n        String transport = candidate.getTransport().toString();\n\n        StringBuffer foundationStringBuff = new StringBuffer(type);\n        foundationStringBuff.append(base);\n        if (server != null)\n            foundationStringBuff.append(server);\n\n        foundationStringBuff.append(transport);\n\n        String foundationString = foundationStringBuff.toString();\n\n        String foundationValue = null;\n        synchronized(foundations)\n        {\n            foundationValue = foundations.get(foundationString);\n\n            //obtain a new foundation number if we don't have one for this kind\n            //of candidates.\n            if (foundationValue == null)\n            {\n                foundationValue = Integer.toString(++lastAssignedFoundation);\n                foundations.put(foundationString, foundationValue);\n            }\n        }\n\n        candidate.setFoundation(foundationValue);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/FoundationsRegistry.java", "class_name": "FoundationsRegistry", "class_uri": "src/main/java/org/ice4j/ice/FoundationsRegistry.java.FoundationsRegistry", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nAssigns to <tt>candidate</tt> the foundation that corresponds to its\nbase, type and transport properties or a new one if no foundation has\nbeen generated yet for the specific combination.\n\n@param candidate the <tt>Candidate</tt> that we'd like to assign a\nfoundation to.\n"}, {"uris": "src/main/java/org/ice4j/ice/FoundationsRegistry.java.FoundationsRegistry.[String]obtainFoundationForPeerReflexiveCandidate()", "name": "obtainFoundationForPeerReflexiveCandidate", "arg_nums": 0, "params": [], "return_type": "String", "signature": "public String obtainFoundationForPeerReflexiveCandidate()", "original_string": "    public String obtainFoundationForPeerReflexiveCandidate()\n    {\n        return Integer.toString(lastAssignedRemoteFoundation++);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/FoundationsRegistry.java", "class_name": "FoundationsRegistry", "class_uri": "src/main/java/org/ice4j/ice/FoundationsRegistry.java.FoundationsRegistry", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns an (as far as you care) random foundation that could be assigned\nto a learned PEER-REFLEXIVE candidate.\n\n@return  a foundation <tt>String</tt> that could be assigned to a\nlearned PEER-REFLEXIVE candidate.\n"}, {"uris": "src/main/java/org/ice4j/ice/FoundationsRegistry.java.FoundationsRegistry.[int]size()", "name": "size", "arg_nums": 0, "params": [], "return_type": "int", "signature": "public int size()", "original_string": "    public int size()\n    {\n        return foundations.size();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/FoundationsRegistry.java", "class_name": "FoundationsRegistry", "class_uri": "src/main/java/org/ice4j/ice/FoundationsRegistry.java.FoundationsRegistry", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\nReturns the number of foundation <tt>String</tt>s that are currently\ntracked by the registry.\n\n@return the number of foundation <tt>String</tt>s that are currently\ntracked by this registry.\n"}, {"uris": "src/main/java/org/ice4j/ice/ServerReflexiveCandidate.java.ServerReflexiveCandidate.[]ServerReflexiveCandidate(TransportAddress,HostCandidate,TransportAddress,CandidateExtendedType)", "name": "ServerReflexiveCandidate", "arg_nums": 4, "params": [{"name": "address", "type": "TransportAddress"}, {"name": "base", "type": "HostCandidate"}, {"name": "stunSrvrAddr", "type": "TransportAddress"}, {"name": "extendedType", "type": "CandidateExtendedType"}], "return_type": "", "signature": "public ServerReflexiveCandidate(TransportAddress address,\n                                    HostCandidate    base,\n                                    TransportAddress stunSrvrAddr,\n                                    CandidateExtendedType extendedType)", "original_string": "    public ServerReflexiveCandidate(TransportAddress address,\n                                    HostCandidate    base,\n                                    TransportAddress stunSrvrAddr,\n                                    CandidateExtendedType extendedType)\n    {\n        this(\n                address,\n                base,\n                stunSrvrAddr,\n                null,\n                extendedType);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/ServerReflexiveCandidate.java", "class_name": "ServerReflexiveCandidate", "class_uri": "src/main/java/org/ice4j/ice/ServerReflexiveCandidate.java.ServerReflexiveCandidate", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nCreates a <tt>ServerReflexiveCandidate</tt> for the specified transport\naddress, and base.\n\n@param address the {@link TransportAddress} that this <tt>Candidate</tt>\nis representing.\n@param base the {@link HostCandidate} that this server reflexive\ncandidate was obtained through.\n@param stunSrvrAddr the {@link TransportAddress} of the stun server that\nreflected this candidate.\n@param extendedType The type of method used to discover this candidate\n(\"host\", \"upnp\", \"stun peer reflexive\", \"stun server reflexive\", \"turn\nrelayed\", \"google turn relayed\", \"google tcp turn relayed\" or \"jingle\nnode\").\n"}, {"uris": "src/main/java/org/ice4j/ice/ServerReflexiveCandidate.java.ServerReflexiveCandidate.[]ServerReflexiveCandidate(TransportAddress,HostCandidate,TransportAddress,StunCandidateHarvest,CandidateExtendedType)", "name": "ServerReflexiveCandidate", "arg_nums": 5, "params": [{"name": "address", "type": "TransportAddress"}, {"name": "base", "type": "HostCandidate"}, {"name": "stunSrvrAddr", "type": "TransportAddress"}, {"name": "stunHarvest", "type": "StunCandidateHarvest"}, {"name": "extendedType", "type": "CandidateExtendedType"}], "return_type": "", "signature": "public ServerReflexiveCandidate(TransportAddress address,\n                                    HostCandidate    base,\n                                    TransportAddress stunSrvrAddr,\n                                    StunCandidateHarvest stunHarvest,\n                                    CandidateExtendedType extendedType)", "original_string": "    public ServerReflexiveCandidate(TransportAddress address,\n                                    HostCandidate    base,\n                                    TransportAddress stunSrvrAddr,\n                                    StunCandidateHarvest stunHarvest,\n                                    CandidateExtendedType extendedType)\n    {\n        super(address,\n              base.getParentComponent(),\n              CandidateType.SERVER_REFLEXIVE_CANDIDATE,\n              extendedType,\n              base);\n\n        setBase(base);\n        setStunServerAddress(stunSrvrAddr);\n        this.stunHarvest = stunHarvest;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/ServerReflexiveCandidate.java", "class_name": "ServerReflexiveCandidate", "class_uri": "src/main/java/org/ice4j/ice/ServerReflexiveCandidate.java.ServerReflexiveCandidate", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nCreates a <tt>ServerReflexiveCandidate</tt> for the specified transport\naddress, and base.\n\n@param address the {@link TransportAddress} that this <tt>Candidate</tt>\nis representing.\n@param base the {@link HostCandidate} that this server reflexive\ncandidate was obtained through.\n@param stunSrvrAddr the {@link TransportAddress} of the stun server that\nreflected this candidate.\n@param stunHarvest the {@link StunCandidateHarvest}\n@param extendedType The type of method used to discover this candidate\n(\"host\", \"upnp\", \"stun peer reflexive\", \"stun server reflexive\", \"turn\nrelayed\", \"google turn relayed\", \"google tcp turn relayed\" or \"jingle\nnode\").\n"}, {"uris": "src/main/java/org/ice4j/ice/ServerReflexiveCandidate.java.ServerReflexiveCandidate.[IceSocketWrapper]getCandidateIceSocketWrapper()", "name": "getCandidateIceSocketWrapper", "arg_nums": 0, "params": [], "return_type": "IceSocketWrapper", "signature": "@Override\n    public IceSocketWrapper getCandidateIceSocketWrapper()", "original_string": "    @Override\n    public IceSocketWrapper getCandidateIceSocketWrapper()\n    {\n        return getBase().getCandidateIceSocketWrapper();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/ServerReflexiveCandidate.java", "class_name": "ServerReflexiveCandidate", "class_uri": "src/main/java/org/ice4j/ice/ServerReflexiveCandidate.java.ServerReflexiveCandidate", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "IceSocketWrapper", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/ice/ServerReflexiveCandidate.java.ServerReflexiveCandidate.[void]free()", "name": "free", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Override\n    public void free()", "original_string": "    @Override\n    public void free()\n    {\n        super.free();\n\n        if (stunHarvest != null)\n            stunHarvest.close();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/ServerReflexiveCandidate.java", "class_name": "ServerReflexiveCandidate", "class_uri": "src/main/java/org/ice4j/ice/ServerReflexiveCandidate.java.ServerReflexiveCandidate", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nFrees resources allocated by this candidate such as its\n<tt>DatagramSocket</tt>, for example. The <tt>socket</tt> of this\n<tt>LocalCandidate</tt> is closed only if it is not the <tt>socket</tt>\nof the <tt>base</tt> of this <tt>LocalCandidate</tt>.\n"}, {"uris": "src/main/java/org/ice4j/ice/Component.java.Component.[]Component(int,IceMediaStream,KeepAliveStrategy,Logger)", "name": "Component", "arg_nums": 4, "params": [{"name": "componentID", "type": "int"}, {"name": "mediaStream", "type": "IceMediaStream"}, {"name": "keepAliveStrategy", "type": "KeepAliveStrategy"}, {"name": "parentLogger", "type": "Logger"}], "return_type": "", "signature": "protected Component(int componentID,\n                        IceMediaStream mediaStream,\n                        KeepAliveStrategy keepAliveStrategy,\n                        Logger parentLogger)", "original_string": "    protected Component(int componentID,\n                        IceMediaStream mediaStream,\n                        KeepAliveStrategy keepAliveStrategy,\n                        Logger parentLogger)\n    {\n        this(componentID, mediaStream, keepAliveStrategy, true, parentLogger);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Component.java", "class_name": "Component", "class_uri": "src/main/java/org/ice4j/ice/Component.java.Component", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nCreates a new <tt>Component</tt> with the specified <tt>componentID</tt>\nas a child of the specified <tt>IceMediaStream</tt>.\n\n@param componentID the id of this component.\n@param mediaStream the {@link IceMediaStream} instance that would be the\nparent of this component.\n@deprecated\n"}, {"uris": "src/main/java/org/ice4j/ice/Component.java.Component.[]Component(int,IceMediaStream,KeepAliveStrategy,boolean,Logger)", "name": "Component", "arg_nums": 5, "params": [{"name": "componentID", "type": "int"}, {"name": "mediaStream", "type": "IceMediaStream"}, {"name": "keepAliveStrategy", "type": "KeepAliveStrategy"}, {"name": "useComponentSocket", "type": "boolean"}, {"name": "parentLogger", "type": "Logger"}], "return_type": "", "signature": "protected Component(int componentID,\n                        IceMediaStream mediaStream,\n                        KeepAliveStrategy keepAliveStrategy,\n                        boolean useComponentSocket,\n                        Logger parentLogger)", "original_string": "    protected Component(int componentID,\n                        IceMediaStream mediaStream,\n                        KeepAliveStrategy keepAliveStrategy,\n                        boolean useComponentSocket,\n                        Logger parentLogger)\n    {\n        // the max value for componentID is 256\n        this.componentID = componentID;\n        this.parentStream = mediaStream;\n        this.keepAliveStrategy\n            = Objects.requireNonNull(keepAliveStrategy, \"keepAliveStrategy\");\n        this.logger = parentLogger.createChildLogger(\n                this.getClass().getName(),\n                Collections.singletonMap(\"componentId\", Integer.toString(componentID))\n        );\n\n        if (useComponentSocket)\n        {\n            try\n            {\n                componentSocket = new ComponentSocket(this, logger);\n                socket = new MultiplexingDatagramSocket(componentSocket);\n                socketWrapper = new IceUdpSocketWrapper(socket);\n            }\n            catch (SocketException se)\n            {\n                throw new RuntimeException(se);\n            }\n        }\n        else\n        {\n            componentSocket = null;\n            socket = null;\n            socketWrapper = null;\n        }\n\n        mediaStream.addPairChangeListener(this);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Component.java", "class_name": "Component", "class_uri": "src/main/java/org/ice4j/ice/Component.java.Component", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nCreates a new <tt>Component</tt> with the specified <tt>componentID</tt>\nas a child of the specified <tt>IceMediaStream</tt>.\n\n@param componentID the id of this component.\n@param mediaStream the {@link IceMediaStream} instance that would be the\nparent of this component.\n@param useComponentSocket whether the component socket should be used.\n"}, {"uris": "src/main/java/org/ice4j/ice/Component.java.Component.[boolean]addLocalCandidate(LocalCandidate)", "name": "addLocalCandidate", "arg_nums": 1, "params": [{"name": "candidate", "type": "LocalCandidate"}], "return_type": "boolean", "signature": "public boolean addLocalCandidate(LocalCandidate candidate)", "original_string": "    public boolean addLocalCandidate(LocalCandidate candidate)\n    {\n        Agent agent = getParentStream().getParentAgent();\n\n        //assign foundation.\n        agent.getFoundationsRegistry().assignFoundation(candidate);\n\n        //compute priority\n        candidate.computePriority();\n\n        synchronized(localCandidates)\n        {\n            //check if we already have such a candidate (redundant)\n            LocalCandidate redundantCandidate = findRedundant(candidate);\n\n            if (redundantCandidate != null)\n            {\n                //if we get here, then it's clear we won't be adding anything\n                //we will just update something at best. We purposefully don't\n                //care about priorities because allowing candidate replace is\n                //tricky to handle on the signalling layer with trickle\n                return false;\n            }\n\n            localCandidates.add(candidate);\n\n            //we are done adding ... now let's just order by priority.\n            Collections.sort(localCandidates);\n\n            return true;\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Component.java", "class_name": "Component", "class_uri": "src/main/java/org/ice4j/ice/Component.java.Component", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nAdd a local candidate to this component. The method should only be\naccessed and local candidates added by the candidate harvesters\nregistered with the agent.\n\n@param candidate the candidate object to be added\n\n@return <tt>true</tt> if we actually added the new candidate or\n<tt>false</tt> in case we didn't because it was redundant to an existing\ncandidate.\n"}, {"uris": "src/main/java/org/ice4j/ice/Component.java.Component.[List<LocalCandidate>]getLocalCandidates()", "name": "getLocalCandidates", "arg_nums": 0, "params": [], "return_type": "List<LocalCandidate>", "signature": "public List<LocalCandidate> getLocalCandidates()", "original_string": "    public List<LocalCandidate> getLocalCandidates()\n    {\n        synchronized(localCandidates)\n        {\n            return new ArrayList<>(localCandidates);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Component.java", "class_name": "Component", "class_uri": "src/main/java/org/ice4j/ice/Component.java.Component", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<LocalCandidate>", "classes": []}, "docstring": "\nReturns a copy of the list containing all local candidates currently\nregistered in this component.\n\n@return Returns a copy of the list containing all local candidates\ncurrently registered in this <tt>Component</tt>.\n"}, {"uris": "src/main/java/org/ice4j/ice/Component.java.Component.[int]countLocalHostCandidates()", "name": "countLocalHostCandidates", "arg_nums": 0, "params": [], "return_type": "int", "signature": "public int countLocalHostCandidates()", "original_string": "    public int countLocalHostCandidates()\n    {\n        synchronized(localCandidates)\n        {\n            int count = 0;\n            for (Candidate<?> cand : localCandidates)\n            {\n                if ((cand.getType() == CandidateType.HOST_CANDIDATE)\n                        && !cand.isVirtual())\n                {\n                    count++;\n                }\n            }\n\n            return count;\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Component.java", "class_name": "Component", "class_uri": "src/main/java/org/ice4j/ice/Component.java.Component", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\nReturns the number of local host candidates currently registered in this\n<tt>Component</tt>.\n\n@return the number of local host candidates currently registered in this\n<tt>Component</tt>.\n"}, {"uris": "src/main/java/org/ice4j/ice/Component.java.Component.[int]getLocalCandidateCount()", "name": "getLocalCandidateCount", "arg_nums": 0, "params": [], "return_type": "int", "signature": "public int getLocalCandidateCount()", "original_string": "    public int getLocalCandidateCount()\n    {\n        synchronized(localCandidates)\n        {\n            return localCandidates.size();\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Component.java", "class_name": "Component", "class_uri": "src/main/java/org/ice4j/ice/Component.java.Component", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\nReturns the number of all local candidates currently registered in this\n<tt>Component</tt>.\n\n@return the number of all local candidates currently registered in this\n<tt>Component</tt>.\n"}, {"uris": "src/main/java/org/ice4j/ice/Component.java.Component.[void]addRemoteCandidate(RemoteCandidate)", "name": "addRemoteCandidate", "arg_nums": 1, "params": [{"name": "candidate", "type": "RemoteCandidate"}], "return_type": "void", "signature": "public void addRemoteCandidate(RemoteCandidate candidate)", "original_string": "    public void addRemoteCandidate(RemoteCandidate candidate)\n    {\n        logger.info(\"Add remote candidate for \" + toShortString()\n                            + \": \" + candidate.toRedactedShortString());\n\n        synchronized(remoteCandidates)\n        {\n            remoteCandidates.add(candidate);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Component.java", "class_name": "Component", "class_uri": "src/main/java/org/ice4j/ice/Component.java.Component", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nAdds a remote <tt>Candidate</tt>s to this media-stream\n<tt>Component</tt>.\n\n@param candidate the <tt>Candidate</tt> instance to add.\n"}, {"uris": "src/main/java/org/ice4j/ice/Component.java.Component.[void]addUpdateRemoteCandidates(RemoteCandidate)", "name": "addUpdateRemoteCandidates", "arg_nums": 1, "params": [{"name": "candidate", "type": "RemoteCandidate"}], "return_type": "void", "signature": "public void addUpdateRemoteCandidates(RemoteCandidate candidate)", "original_string": "    public void addUpdateRemoteCandidates(RemoteCandidate candidate)\n    {\n        logger.info(\"Update remote candidate for \" + toShortString() + \": \" +\n                candidate.getTransportAddress());\n\n        List<RemoteCandidate> existingCandidates = new LinkedList<>();\n        synchronized (remoteCandidates)\n        {\n            existingCandidates.addAll(remoteCandidates);\n        }\n\n        synchronized(remoteUpdateCandidates)\n        {\n            existingCandidates.addAll(remoteUpdateCandidates);\n\n            // Make sure we add no duplicates\n            TransportAddress transportAddress = candidate.getTransportAddress();\n            CandidateType type = candidate.getType();\n            for (RemoteCandidate existingCandidate : existingCandidates)\n            {\n                if (transportAddress\n                        .equals(existingCandidate.getTransportAddress())\n                    && type == existingCandidate.getType())\n                {\n                    logger.info(\"Not adding duplicate remote candidate: \"\n                                    + candidate.getTransportAddress());\n                    return;\n                }\n            }\n\n            remoteUpdateCandidates.add(candidate);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Component.java", "class_name": "Component", "class_uri": "src/main/java/org/ice4j/ice/Component.java.Component", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nUpdate the media-stream <tt>Component</tt> with the specified\n<tt>Candidate</tt>s. This would happen when performing trickle ICE.\n\n@param candidate new <tt>Candidate</tt> to add.\n"}, {"uris": "src/main/java/org/ice4j/ice/Component.java.Component.[void]updateRemoteCandidates()", "name": "updateRemoteCandidates", "arg_nums": 0, "params": [], "return_type": "void", "signature": "public void updateRemoteCandidates()", "original_string": "    public void updateRemoteCandidates()\n    {\n        List<CandidatePair> checkList;\n        List<RemoteCandidate> newRemoteCandidates;\n\n        synchronized(remoteUpdateCandidates)\n        {\n            if (remoteUpdateCandidates.size() == 0)\n                return;\n\n            newRemoteCandidates = new LinkedList<>(remoteUpdateCandidates);\n\n            List<LocalCandidate> localCnds = getLocalCandidates();\n\n            // remove UPnP base from local candidate\n            LocalCandidate upnpBase = null;\n            for (LocalCandidate lc : localCnds)\n            {\n                if (lc instanceof UPNPCandidate)\n                {\n                    upnpBase = lc.getBase();\n                }\n            }\n\n            checkList = new Vector<>();\n\n            for (LocalCandidate localCnd : localCnds)\n            {\n                if (localCnd == upnpBase)\n                    continue;\n\n                //pair each of the new remote candidates with each of our locals\n                for (RemoteCandidate remoteCnd : remoteUpdateCandidates)\n                {\n                    if (localCnd.canReach(remoteCnd)\n                            && remoteCnd.getTransportAddress().getPort() != 0)\n                    {\n                        // A single LocalCandidate might be/become connected\n                        // to more more than one remote address, and that's ok\n                        // (that is, we need to form pairs with them all).\n                        /*\n                        if (localCnd.getTransport() == Transport.TCP &&\n                            localCnd.getIceSocketWrapper().getTCPSocket().\n                                isConnected())\n                        {\n                            if (!localCnd.getIceSocketWrapper().getTCPSocket().\n                                getRemoteSocketAddress().equals(\n                                    remoteCnd.getTransportAddress()))\n                            {\n                                continue;\n                            }\n                        }\n                        */\n\n                        CandidatePair pair\n                            = getParentStream()\n                                .getParentAgent()\n                                    .createCandidatePair(localCnd, remoteCnd);\n                        checkList.add(pair);\n                    }\n                }\n            }\n            remoteUpdateCandidates.clear();\n        }\n\n        synchronized (remoteCandidates)\n        {\n            remoteCandidates.addAll(newRemoteCandidates);\n        }\n\n        //sort and prune update checklist\n        Collections.sort(checkList, CandidatePair.comparator);\n        parentStream.pruneCheckList(checkList);\n\n        if (parentStream.getCheckList().getState().equals(\n                CheckListState.RUNNING))\n        {\n            //add the updated CandidatePair list to the currently running\n            //checklist\n            CheckList streamCheckList = parentStream.getCheckList();\n            synchronized(streamCheckList)\n            {\n                for (CandidatePair pair : checkList)\n                {\n                    /* Check whether the pair is already in the check list.\n                     * (This can happen for pairs with remote peer-reflexive candidates,\n                     *  since those candidates aren't added to the candidate list even\n                     *  though the pair is added to the check list).\n                     */\n                    CandidatePair existingPair\n                        = streamCheckList.findPairMatching(pair.getLocalCandidate(), pair.getRemoteCandidate());\n                    if (existingPair != null)\n                    {\n                        logger.info(\"existing Pair updated: \" +\n                            existingPair.toRedactedShortString() +\n                            \" to \" + pair.toRedactedShortString() + \".\");\n                        existingPair.setRemoteCandidate(pair.getRemoteCandidate());\n                        existingPair.computePriority();\n                    }\n                    else\n                    {\n                        streamCheckList.add(pair);\n                        logger.info(\"new Pair added: \" + pair.toRedactedShortString()\n                            + \".\");\n                    }\n                }\n            }\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Component.java", "class_name": "Component", "class_uri": "src/main/java/org/ice4j/ice/Component.java.Component", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nUpdate ICE processing with new <tt>Candidate</tt>s.\n"}, {"uris": "src/main/java/org/ice4j/ice/Component.java.Component.[List<RemoteCandidate>]getRemoteCandidates()", "name": "getRemoteCandidates", "arg_nums": 0, "params": [], "return_type": "List<RemoteCandidate>", "signature": "public List<RemoteCandidate> getRemoteCandidates()", "original_string": "    public List<RemoteCandidate> getRemoteCandidates()\n    {\n        synchronized(remoteCandidates)\n        {\n            return new ArrayList<>(remoteCandidates);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Component.java", "class_name": "Component", "class_uri": "src/main/java/org/ice4j/ice/Component.java.Component", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<RemoteCandidate>", "classes": []}, "docstring": "\nReturns a copy of the list containing all remote candidates currently\nregistered in this component.\n\n@return Returns a copy of the list containing all remote candidates\ncurrently registered in this <tt>Component</tt>.\n"}, {"uris": "src/main/java/org/ice4j/ice/Component.java.Component.[void]addRemoteCandidates(List<RemoteCandidate>)", "name": "addRemoteCandidates", "arg_nums": 1, "params": [{"name": "candidates", "type": "List<RemoteCandidate>"}], "return_type": "void", "signature": "public void addRemoteCandidates(List<RemoteCandidate> candidates)", "original_string": "    public void addRemoteCandidates(List<RemoteCandidate> candidates)\n    {\n        synchronized(remoteCandidates)\n        {\n            remoteCandidates.addAll(candidates);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Component.java", "class_name": "Component", "class_uri": "src/main/java/org/ice4j/ice/Component.java.Component", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nAdds a List of remote <tt>Candidate</tt>s as reported by a remote agent.\n\n@param candidates the <tt>List</tt> of <tt>Candidate</tt>s reported by\nthe remote agent for this component.\n"}, {"uris": "src/main/java/org/ice4j/ice/Component.java.Component.[int]getRemoteCandidateCount()", "name": "getRemoteCandidateCount", "arg_nums": 0, "params": [], "return_type": "int", "signature": "public int getRemoteCandidateCount()", "original_string": "    public int getRemoteCandidateCount()\n    {\n        synchronized(remoteCandidates)\n        {\n            return remoteCandidates.size();\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Component.java", "class_name": "Component", "class_uri": "src/main/java/org/ice4j/ice/Component.java.Component", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\nReturns the number of all remote candidates currently registered in this\n<tt>Component</tt>.\n\n@return the number of all remote candidates currently registered in this\n<tt>Component</tt>.\n"}, {"uris": "src/main/java/org/ice4j/ice/Component.java.Component.[IceMediaStream]getParentStream()", "name": "getParentStream", "arg_nums": 0, "params": [], "return_type": "IceMediaStream", "signature": "public IceMediaStream getParentStream()", "original_string": "    public IceMediaStream getParentStream()\n    {\n        return parentStream;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Component.java", "class_name": "Component", "class_uri": "src/main/java/org/ice4j/ice/Component.java.Component", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "IceMediaStream", "classes": []}, "docstring": "\nReturns a reference to the <tt>IceMediaStream</tt> that this\n<tt>Component</tt> belongs to.\n\n@return  a reference to the <tt>IceMediaStream</tt> that this\n<tt>Component</tt> belongs to.\n"}, {"uris": "src/main/java/org/ice4j/ice/Component.java.Component.[int]getComponentID()", "name": "getComponentID", "arg_nums": 0, "params": [], "return_type": "int", "signature": "public int getComponentID()", "original_string": "    public int getComponentID()\n    {\n        return componentID;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Component.java", "class_name": "Component", "class_uri": "src/main/java/org/ice4j/ice/Component.java.Component", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\nReturns the ID of this <tt>Component</tt>. For RTP/RTCP flows this would\nbe <tt>1</tt> for RTP and 2 for <tt>RTCP</tt>.\n\n@return the ID of this <tt>Component</tt>.\n"}, {"uris": "src/main/java/org/ice4j/ice/Component.java.Component.[String]toString()", "name": "toString", "arg_nums": 0, "params": [], "return_type": "String", "signature": "public String toString()", "original_string": "    public String toString()\n    {\n        StringBuffer buff\n            = new StringBuffer(\"Component id=\").append(getComponentID());\n\n        buff.append(\" parent stream=\").append(getParentStream().getName());\n\n        //local candidates\n        int localCandidatesCount = getLocalCandidateCount();\n\n        if (localCandidatesCount > 0)\n        {\n            buff.append(\"\\n\")\n                .append(localCandidatesCount)\n                .append(\" Local candidates:\");\n            buff.append(\"\\ndefault candidate: \").append(getDefaultCandidate());\n\n            synchronized(localCandidates)\n            {\n                for (Candidate<?> cand : localCandidates)\n                {\n                    buff.append('\\n').append(cand.toString());\n                }\n            }\n        }\n        else\n        {\n            buff.append(\"\\nno local candidates.\");\n        }\n\n        //remote candidates\n        int remoteCandidatesCount = getRemoteCandidateCount();\n\n        if (remoteCandidatesCount > 0)\n        {\n            buff.append(\"\\n\")\n                .append(remoteCandidatesCount)\n                .append(\" Remote candidates:\");\n            Candidate<?> defaultRemoteCandidate = getDefaultRemoteCandidate();\n            buff.append(\"\\ndefault remote candidate: \");\n            if (defaultRemoteCandidate != null)\n            {\n                buff.append(defaultRemoteCandidate.toRedactedString());\n            }\n            else\n            {\n                buff.append(\"null\");\n            }\n\n            synchronized(remoteCandidates)\n            {\n                for (RemoteCandidate cand : remoteCandidates)\n                {\n                    buff.append(\"\\n\").append(cand.toRedactedString());\n                }\n            }\n        }\n        else\n        {\n            buff.append(\"\\nno remote candidates.\");\n        }\n\n        return buff.toString();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Component.java", "class_name": "Component", "class_uri": "src/main/java/org/ice4j/ice/Component.java.Component", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns a <tt>String</tt> representation of this <tt>Component</tt>\ncontaining its ID, parent stream name and any existing candidates.\n\n@return  a <tt>String</tt> representation of this <tt>Component</tt>\ncontaining its ID, parent stream name and any existing candidates.\n"}, {"uris": "src/main/java/org/ice4j/ice/Component.java.Component.[String]toShortString()", "name": "toShortString", "arg_nums": 0, "params": [], "return_type": "String", "signature": "public String toShortString()", "original_string": "    public String toShortString()\n    {\n        return parentStream.getName() + \".\" + getName();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Component.java", "class_name": "Component", "class_uri": "src/main/java/org/ice4j/ice/Component.java.Component", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns a short <tt>String</tt> representation of this\n<tt>Component</tt>.\n\n@return a short <tt>String</tt> representation of this\n<tt>Component</tt>.\n"}, {"uris": "src/main/java/org/ice4j/ice/Component.java.Component.[void]prioritizeCandidates()", "name": "prioritizeCandidates", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Deprecated\n    protected void prioritizeCandidates()", "original_string": "    @Deprecated\n    protected void prioritizeCandidates()\n    {\n        synchronized(localCandidates)\n        {\n            LocalCandidate[] candidates\n                = new LocalCandidate[localCandidates.size()];\n\n            localCandidates.toArray(candidates);\n\n            //first compute the actual priorities\n            for (Candidate<?> cand : candidates)\n            {\n                cand.computePriority();\n            }\n\n            //sort\n            Arrays.sort(candidates, candidatePrioritizer);\n\n            //now re-add the candidates in the order they've been sorted in.\n            localCandidates.clear();\n            for (LocalCandidate cand : candidates)\n                localCandidates.add(cand);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Component.java", "class_name": "Component", "class_uri": "src/main/java/org/ice4j/ice/Component.java.Component", "attributes": {"modifiers": "@Deprecated\n    protected", "marker_annotations": ["@Deprecated"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nComputes the priorities of all <tt>Candidate</tt>s and then sorts them\naccordingly.\n\n@deprecated candidates are now being prioritized upon addition and\ncalling this method is no longer necessary.\n"}, {"uris": "src/main/java/org/ice4j/ice/Component.java.Component.[void]eliminateRedundantCandidates()", "name": "eliminateRedundantCandidates", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Deprecated\n    protected void eliminateRedundantCandidates()", "original_string": "    @Deprecated\n    protected void eliminateRedundantCandidates()\n    {\n        /*\n         * Find and remove all candidates that have the same address and base as\n         * cand and a lower priority. The algorithm implemented bellow does rely\n         * on localCandidates being ordered in decreasing order (as said in its\n         * javadoc that the eliminateRedundantCandidates method is called only\n         * after prioritizeCandidates.\n         */\n        synchronized (localCandidates)\n        {\n            for (int i = 0; i < localCandidates.size(); i++)\n            {\n                LocalCandidate cand = localCandidates.get(i);\n\n                for (int j = i + 1; j < localCandidates.size();)\n                {\n                    LocalCandidate cand2 = localCandidates.get(j);\n\n                    if ((cand != cand2)\n                            && cand.getTransportAddress().equals(\n                                    cand2.getTransportAddress())\n                            && cand.getBase().equals(cand2.getBase())\n                            && (cand.getPriority() >= cand2.getPriority()))\n                    {\n                        localCandidates.remove(j);\n                        logger.trace(() -> \"eliminating redundant cand: \"+ cand2);\n                    }\n                    else\n                        j++;\n                }\n            }\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Component.java", "class_name": "Component", "class_uri": "src/main/java/org/ice4j/ice/Component.java.Component", "attributes": {"modifiers": "@Deprecated\n    protected", "marker_annotations": ["@Deprecated"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nEliminates redundant candidates, removing them from the specified\n<tt>component</tt>.  A candidate is redundant if its transport address\nequals another candidate, and its base equals the base of that other\ncandidate.  Note that two candidates can have the same transport address\nyet have different bases, and these would not be considered redundant.\nFrequently, a server reflexive candidate and a host candidate will be\nredundant when the agent is not behind a NAT.  The agent SHOULD eliminate\nthe redundant candidate with the lower priority which is why we have to\nrun this method only after prioritizing candidates.\n\n@deprecated redundancies are now being detected upon addition of\ncandidates and calling this method is no longer necessary.\n"}, {"uris": "src/main/java/org/ice4j/ice/Component.java.Component.[LocalCandidate]findRedundant(LocalCandidate)", "name": "findRedundant", "arg_nums": 1, "params": [{"name": "cand", "type": "LocalCandidate"}], "return_type": "LocalCandidate", "signature": "private LocalCandidate findRedundant(LocalCandidate cand)", "original_string": "    private LocalCandidate findRedundant(LocalCandidate cand)\n    {\n        synchronized (localCandidates)\n        {\n            for (LocalCandidate redundantCand : localCandidates)\n            {\n                if ((cand != redundantCand)\n                        && cand.getTransportAddress().equals(\n                                redundantCand.getTransportAddress())\n                        && cand.getBase().equals(redundantCand.getBase()))\n                {\n                    return redundantCand;\n                }\n            }\n        }\n\n        return null;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Component.java", "class_name": "Component", "class_uri": "src/main/java/org/ice4j/ice/Component.java.Component", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "LocalCandidate", "classes": []}, "docstring": "\nFinds and returns the first candidate that is redundant to <tt>cand</tt>.\nA candidate is redundant if its transport address equals another\ncandidate, and its base equals the base of that other candidate. Note\nthat two candidates can have the same transport address yet have\ndifferent bases, and these would not be considered redundant. Frequently,\na server reflexive candidate and a host candidate will be redundant when\nthe agent is not behind a NAT. The agent SHOULD eliminate the redundant\ncandidate with the lower priority which is why we have to run this method\nonly after prioritizing candidates.\n\n@param cand the {@link LocalCandidate} that we'd like to check for\nredundancies.\n\n@return the first candidate that is redundant to <tt>cand</tt> or\n<tt>null</tt> if there is no such candidate.\n"}, {"uris": "src/main/java/org/ice4j/ice/Component.java.Component.[LocalCandidate]getDefaultCandidate()", "name": "getDefaultCandidate", "arg_nums": 0, "params": [], "return_type": "LocalCandidate", "signature": "public LocalCandidate getDefaultCandidate()", "original_string": "    public LocalCandidate getDefaultCandidate()\n    {\n        return defaultCandidate;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Component.java", "class_name": "Component", "class_uri": "src/main/java/org/ice4j/ice/Component.java.Component", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "LocalCandidate", "classes": []}, "docstring": "\nReturns the <tt>Candidate</tt> that has been selected as the default\nfor this <tt>Component</tt> or <tt>null</tt> if no such\n<tt>Candidate</tt> has been selected yet. A candidate is said to be\ndefault if it would be the target of media from a non-ICE peer;\n\n@return the <tt>Candidate</tt> that has been selected as the default for\nthis <tt>Component</tt> or <tt>null</tt> if no such <tt>Candidate</tt>\nhas been selected yet\n"}, {"uris": "src/main/java/org/ice4j/ice/Component.java.Component.[Candidate<?>]getDefaultRemoteCandidate()", "name": "getDefaultRemoteCandidate", "arg_nums": 0, "params": [], "return_type": "Candidate<?>", "signature": "public Candidate<?> getDefaultRemoteCandidate()", "original_string": "    public Candidate<?> getDefaultRemoteCandidate()\n    {\n        return defaultRemoteCandidate;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Component.java", "class_name": "Component", "class_uri": "src/main/java/org/ice4j/ice/Component.java.Component", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Candidate<?>", "classes": []}, "docstring": "\nReturns the <tt>Candidate</tt> that the remote party has reported as\ndefault for this <tt>Component</tt> or <tt>null</tt> if no such\n<tt>Candidate</tt> has been reported yet. A candidate is said to be\ndefault if it would be the target of media from a non-ICE peer;\n\n@return the <tt>Candidate</tt> that the remote party has reported as\ndefault for this <tt>Component</tt> or <tt>null</tt> if no such\n<tt>Candidate</tt> has reported yet.\n"}, {"uris": "src/main/java/org/ice4j/ice/Component.java.Component.[void]setDefaultRemoteCandidate(Candidate<?>)", "name": "setDefaultRemoteCandidate", "arg_nums": 1, "params": [{"name": "candidate", "type": "Candidate<?>"}], "return_type": "void", "signature": "public void setDefaultRemoteCandidate(Candidate<?> candidate)", "original_string": "    public void setDefaultRemoteCandidate(Candidate<?> candidate)\n    {\n        this.defaultRemoteCandidate = candidate;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Component.java", "class_name": "Component", "class_uri": "src/main/java/org/ice4j/ice/Component.java.Component", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets the <tt>Candidate</tt> that the remote party has reported as\ndefault for this <tt>Component</tt>. A candidate is said to be\ndefault if it would be the target of media from a non-ICE peer;\n\n@param candidate the <tt>Candidate</tt> that the remote party has\nreported as default for this <tt>Component</tt>.\n"}, {"uris": "src/main/java/org/ice4j/ice/Component.java.Component.[void]selectDefaultCandidate()", "name": "selectDefaultCandidate", "arg_nums": 0, "params": [], "return_type": "void", "signature": "protected void selectDefaultCandidate()", "original_string": "    protected void selectDefaultCandidate()\n    {\n        synchronized(localCandidates)\n        {\n            for (LocalCandidate cand : localCandidates)\n            {\n                if ((defaultCandidate == null)\n                        || (defaultCandidate.getDefaultPreference()\n                                < cand.getDefaultPreference()))\n                {\n                    defaultCandidate = cand;\n                }\n            }\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Component.java", "class_name": "Component", "class_uri": "src/main/java/org/ice4j/ice/Component.java.Component", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSelects a <tt>Candidate</tt> that should be considered as the default\nfor this <tt>Component</tt>. A candidate is said to be default if it\nwould be the target of media from a non-ICE peer;\n<p>\nThe ICE specification RECOMMENDEDs that default candidates be chosen\nbased on the likelihood of those candidates to work with the peer that is\nbeing contacted. It is RECOMMENDED that the default candidates are the\nrelayed candidates (if relayed candidates are available), server\nreflexive candidates (if server reflexive candidates are available), and\nfinally host candidates.\n</p>\n"}, {"uris": "src/main/java/org/ice4j/ice/Component.java.Component.[void]free()", "name": "free", "arg_nums": 0, "params": [], "return_type": "void", "signature": "protected void free()", "original_string": "    protected void free()\n    {\n        synchronized (localCandidates)\n        {\n            /*\n             * Since the sockets of the non-HostCandidate LocalCandidates may\n             * depend on the socket of the HostCandidate for which they have\n             * been harvested, order the freeing.\n             */\n            CandidateType[] candidateTypes\n                = new CandidateType[]\n                        {\n                            CandidateType.RELAYED_CANDIDATE,\n                            CandidateType.PEER_REFLEXIVE_CANDIDATE,\n                            CandidateType.SERVER_REFLEXIVE_CANDIDATE\n                        };\n\n            for (CandidateType candidateType : candidateTypes)\n            {\n                Iterator<LocalCandidate> localCandidateIter\n                    = localCandidates.iterator();\n\n                while (localCandidateIter.hasNext())\n                {\n                    LocalCandidate localCandidate = localCandidateIter.next();\n\n                    if (candidateType.equals(localCandidate.getType()))\n                    {\n                        free(localCandidate);\n                        localCandidateIter.remove();\n                    }\n                }\n            }\n\n            // Free whatever's left.\n            Iterator<LocalCandidate> localCandidateIter\n                = localCandidates.iterator();\n\n            while (localCandidateIter.hasNext())\n            {\n                LocalCandidate localCandidate = localCandidateIter.next();\n\n                free(localCandidate);\n                localCandidateIter.remove();\n            }\n        }\n\n        getParentStream().removePairStateChangeListener(this);\n        keepAlivePairs.clear();\n        if (componentSocket != null)\n        {\n            componentSocket.close();\n        }\n        if (socket != null)\n        {\n            socket.close();\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Component.java", "class_name": "Component", "class_uri": "src/main/java/org/ice4j/ice/Component.java.Component", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nReleases all resources allocated by this <tt>Component</tt> and its\n<tt>Candidate</tt>s like sockets for example.\n"}, {"uris": "src/main/java/org/ice4j/ice/Component.java.Component.[void]free(LocalCandidate)", "name": "free", "arg_nums": 1, "params": [{"name": "localCandidate", "type": "LocalCandidate"}], "return_type": "void", "signature": "private void free(LocalCandidate localCandidate)", "original_string": "    private void free(LocalCandidate localCandidate)\n    {\n        try\n        {\n            localCandidate.free();\n        }\n        catch (Throwable t)\n        {\n            /*\n             * Don't let the failing of a single LocalCandidate to free itself\n             * to fail the freeing of the other LocalCandidates.\n             */\n            if (t instanceof ThreadDeath)\n                throw (ThreadDeath) t;\n            logger.info(() -> \"Failed to free LocalCandidate: \" + localCandidate);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Component.java", "class_name": "Component", "class_uri": "src/main/java/org/ice4j/ice/Component.java.Component", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nFrees a specific <tt>LocalCandidate</tt> and swallows any\n<tt>Throwable</tt> it throws while freeing itself in order to prevent its\nfailure to affect the rest of the execution.\n\n@param localCandidate the <tt>LocalCandidate</tt> to be freed\n"}, {"uris": "src/main/java/org/ice4j/ice/Component.java.Component.[LocalCandidate]findLocalCandidate(TransportAddress)", "name": "findLocalCandidate", "arg_nums": 1, "params": [{"name": "localAddress", "type": "TransportAddress"}], "return_type": "LocalCandidate", "signature": "public LocalCandidate findLocalCandidate(TransportAddress localAddress)", "original_string": "    public LocalCandidate findLocalCandidate(TransportAddress localAddress)\n    {\n        return findLocalCandidate(localAddress, null);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Component.java", "class_name": "Component", "class_uri": "src/main/java/org/ice4j/ice/Component.java.Component", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "LocalCandidate", "classes": []}, "docstring": "\nReturns the local <tt>LocalCandidate</tt> with the specified\n<tt>localAddress</tt> if it belongs to this component or <tt>null</tt>\nif it doesn't.\n\n@param localAddress the {@link TransportAddress} we are looking for.\n\n@return  the local <tt>LocalCandidate</tt> with the specified\n<tt>localAddress</tt> if it belongs to this component or <tt>null</tt>\nif it doesn't.\n"}, {"uris": "src/main/java/org/ice4j/ice/Component.java.Component.[LocalCandidate]findLocalCandidate(TransportAddress,LocalCandidate)", "name": "findLocalCandidate", "arg_nums": 2, "params": [{"name": "address", "type": "TransportAddress"}, {"name": "base", "type": "LocalCandidate"}], "return_type": "LocalCandidate", "signature": "public LocalCandidate findLocalCandidate(TransportAddress address, LocalCandidate base)", "original_string": "    public LocalCandidate findLocalCandidate(TransportAddress address, LocalCandidate base)\n    {\n        for (LocalCandidate localCandidate : localCandidates)\n        {\n            if (localCandidate.getTransportAddress().equals(address))\n            {\n                if (base == null || base.equals(localCandidate.getBase()))\n                {\n                    return localCandidate;\n                }\n            }\n        }\n        // In case the above loop failed to find a result because `base` was\n        // specified, fallback to the original behavior and return the first\n        // candidate matching `address` regardless of `base`.\n        for (LocalCandidate localCandidate : localCandidates)\n        {\n            if (localCandidate.getTransportAddress().equals(address))\n            {\n                logger.warn(\"Returning a candidate matching the address, \"\n                        + \"while no candidates match both address (\"\n                        + address + \") and base (\" + base +\"): \" + localCandidate\n                        + \" with base \" + localCandidate.getBase());\n                return localCandidate;\n            }\n        }\n\n        return null;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Component.java", "class_name": "Component", "class_uri": "src/main/java/org/ice4j/ice/Component.java.Component", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "LocalCandidate", "classes": []}, "docstring": "\nReturns the local <tt>LocalCandidate</tt> with the specified\n<tt>address</tt> if it belongs to this component or <tt>null</tt>\nif it doesn't. If {@code base} is also specified, tries to find a\ncandidate whose base matches {@code base}.\n\n@param address the {@link TransportAddress} we are looking for.\n@param base an optional base to match.\n\n@return  the local <tt>LocalCandidate</tt> with the specified\n<tt>address</tt> if it belongs to this component or <tt>null</tt>\nif it doesn't.\n"}, {"uris": "src/main/java/org/ice4j/ice/Component.java.Component.[RemoteCandidate]findRemoteCandidate(TransportAddress)", "name": "findRemoteCandidate", "arg_nums": 1, "params": [{"name": "remoteAddress", "type": "TransportAddress"}], "return_type": "RemoteCandidate", "signature": "public RemoteCandidate findRemoteCandidate(TransportAddress remoteAddress)", "original_string": "    public RemoteCandidate findRemoteCandidate(TransportAddress remoteAddress)\n    {\n        for (RemoteCandidate remoteCnd : remoteCandidates)\n        {\n            if (remoteCnd.getTransportAddress().equals(remoteAddress))\n            {\n                return remoteCnd;\n            }\n        }\n\n        return null;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Component.java", "class_name": "Component", "class_uri": "src/main/java/org/ice4j/ice/Component.java.Component", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "RemoteCandidate", "classes": []}, "docstring": "\nReturns the remote <tt>Candidate</tt> with the specified\n<tt>remoteAddress</tt> if it belongs to this {@link Component} or\n<tt>null</tt> if it doesn't.\n\n@param remoteAddress the {@link TransportAddress} we are looking for.\n\n@return the remote <tt>RemoteCandidate</tt> with the specified\n<tt>remoteAddress</tt> if it belongs to this component or <tt>null</tt>\nif it doesn't.\n"}, {"uris": "src/main/java/org/ice4j/ice/Component.java.Component.[void]setSelectedPair(CandidatePair)", "name": "setSelectedPair", "arg_nums": 1, "params": [{"name": "pair", "type": "CandidatePair"}], "return_type": "void", "signature": "protected void setSelectedPair(CandidatePair pair)", "original_string": "    protected void setSelectedPair(CandidatePair pair)\n    {\n        if (keepAliveStrategy == KeepAliveStrategy.SELECTED_ONLY)\n        {\n            keepAlivePairs.clear();\n        }\n        keepAlivePairs.add(pair);\n\n        this.selectedPair = pair;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Component.java", "class_name": "Component", "class_uri": "src/main/java/org/ice4j/ice/Component.java.Component", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets the {@link CandidatePair} selected for use by ICE processing and\nthat the application would use.\n\n@param pair the {@link CandidatePair} selected for use by ICE processing.\n"}, {"uris": "src/main/java/org/ice4j/ice/Component.java.Component.[CandidatePair]getSelectedPair()", "name": "getSelectedPair", "arg_nums": 0, "params": [], "return_type": "CandidatePair", "signature": "public CandidatePair getSelectedPair()", "original_string": "    public CandidatePair getSelectedPair()\n    {\n        return selectedPair;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Component.java", "class_name": "Component", "class_uri": "src/main/java/org/ice4j/ice/Component.java.Component", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "CandidatePair", "classes": []}, "docstring": "\nReturns the {@link CandidatePair} selected for use by ICE processing or\n<tt>null</tt> if no pair has been selected so far or if ICE processing\nhas failed.\n\n@return the {@link CandidatePair} selected for use by ICE processing or\n<tt>null</tt> if no pair has been selected so far or if ICE processing\nhas failed.\n"}, {"uris": "src/main/java/org/ice4j/ice/Component.java.Component.[String]getName()", "name": "getName", "arg_nums": 0, "params": [], "return_type": "String", "signature": "public String getName()", "original_string": "    public String getName()\n    {\n        if (componentID == RTP)\n        {\n            return \"RTP\";\n        }\n        else if (componentID == RTCP)\n        {\n            return \"RTCP\";\n        }\n        else\n        {\n            return Integer.toString(componentID);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Component.java", "class_name": "Component", "class_uri": "src/main/java/org/ice4j/ice/Component.java.Component", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns a human readable name that can be used in debug logs associated\nwith this component.\n\n@return \"RTP\" if the component ID is 1, \"RTCP\" if the component id is 2\nand the component id itself otherwise.\n"}, {"uris": "src/main/java/org/ice4j/ice/Component.java.Component.[Component]build(int,IceMediaStream,Logger)", "name": "build", "arg_nums": 3, "params": [{"name": "componentID", "type": "int"}, {"name": "mediaStream", "type": "IceMediaStream"}, {"name": "parentLogger", "type": "Logger"}], "return_type": "Component", "signature": "public static Component build(int componentID, IceMediaStream mediaStream, Logger parentLogger)", "original_string": "    public static Component build(int componentID, IceMediaStream mediaStream, Logger parentLogger)\n    {\n        return\n            new Component(\n                    componentID,\n                    mediaStream,\n                    KeepAliveStrategy.SELECTED_ONLY,\n                    AgentConfig.config.getUseComponentSocket(),\n                    parentLogger\n            );\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Component.java", "class_name": "Component", "class_uri": "src/main/java/org/ice4j/ice/Component.java.Component", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Component", "classes": []}, "docstring": "\nUse builder pattern to allow creation of immutable Component instances,\nfrom outside the current package.\n\n@param componentID the id of this component.\n@param mediaStream the {@link IceMediaStream} instance that would be the\nparent of this component.\n@return Component\n"}, {"uris": "src/main/java/org/ice4j/ice/Component.java.Component.[ComponentSocket]getComponentSocket()", "name": "getComponentSocket", "arg_nums": 0, "params": [], "return_type": "ComponentSocket", "signature": "public ComponentSocket getComponentSocket()", "original_string": "    public ComponentSocket getComponentSocket()\n    {\n        return componentSocket;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Component.java", "class_name": "Component", "class_uri": "src/main/java/org/ice4j/ice/Component.java.Component", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ComponentSocket", "classes": []}, "docstring": "\n@return the single socket for this {@link Component} which should be\nused for reading and writing data, if the component socket is enabled\nand {@code null} if it is not enabled.\n</p>\nThis is for ice4j internal use only! For reading/writing application\ndata, use {@link #getSocket()}.\n"}, {"uris": "src/main/java/org/ice4j/ice/Component.java.Component.[MultiplexingDatagramSocket]getSocket()", "name": "getSocket", "arg_nums": 0, "params": [], "return_type": "MultiplexingDatagramSocket", "signature": "public MultiplexingDatagramSocket getSocket()", "original_string": "    public MultiplexingDatagramSocket getSocket()\n    {\n        return socket;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Component.java", "class_name": "Component", "class_uri": "src/main/java/org/ice4j/ice/Component.java.Component", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "MultiplexingDatagramSocket", "classes": []}, "docstring": "\n@return the socket for this {@link Component}, which should be used for\nreading/writing application data. If the component socket is not enabled,\nthis returns {@code null} and users of the library should use the socket\ninstance from the desired candidate pair instead.\n"}, {"uris": "src/main/java/org/ice4j/ice/Component.java.Component.[IceSocketWrapper]getSocketWrapper()", "name": "getSocketWrapper", "arg_nums": 0, "params": [], "return_type": "IceSocketWrapper", "signature": "public IceSocketWrapper getSocketWrapper()", "original_string": "    public IceSocketWrapper getSocketWrapper()\n    {\n        return socketWrapper;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Component.java", "class_name": "Component", "class_uri": "src/main/java/org/ice4j/ice/Component.java.Component", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "IceSocketWrapper", "classes": []}, "docstring": "\n@return an {@link IceSocketWrapper} instance wrapping the socket for this\ncandidate (see {@link #getSocket()}).\n@deprecated Use {@link #getSocket()} directly. This is only introduced\nto ease the transition of applications which are already written to use\na {@link IceSocketWrapper} instance.\n"}, {"uris": "src/main/java/org/ice4j/ice/Component.java.Component.[Set<CandidatePair>]getKeepAlivePairs()", "name": "getKeepAlivePairs", "arg_nums": 0, "params": [], "return_type": "Set<CandidatePair>", "signature": "Set<CandidatePair> getKeepAlivePairs()", "original_string": "    Set<CandidatePair> getKeepAlivePairs()\n    {\n        return keepAlivePairs;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Component.java", "class_name": "Component", "class_uri": "src/main/java/org/ice4j/ice/Component.java.Component", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Set<CandidatePair>", "classes": []}, "docstring": "\n@return the set of candidate pairs which are to be kept alive.\n"}, {"uris": "src/main/java/org/ice4j/ice/Component.java.Component.[void]propertyChange(PropertyChangeEvent)", "name": "propertyChange", "arg_nums": 1, "params": [{"name": "event", "type": "PropertyChangeEvent"}], "return_type": "void", "signature": "@Override\n    public void propertyChange(PropertyChangeEvent event)", "original_string": "    @Override\n    public void propertyChange(PropertyChangeEvent event)\n    {\n        String propertyName = event.getPropertyName();\n        if (!(event.getSource() instanceof CandidatePair))\n        {\n            return;\n        }\n\n        CandidatePair pair = (CandidatePair) event.getSource();\n        if (!equals(pair.getParentComponent()))\n        {\n            // Events are fired by the IceMediaStream, which might have\n            // multiple components. Make sure that we only handle events for\n            // this component.\n            return;\n        }\n\n        boolean addToKeepAlive = false;\n\n        // We handle this case in setSelectedPair\n        if (keepAliveStrategy == KeepAliveStrategy.SELECTED_ONLY)\n            return;\n\n        if (IceMediaStream.PROPERTY_PAIR_STATE_CHANGED.equals(propertyName))\n        {\n            CandidatePairState newState\n                = (CandidatePairState) event.getNewValue();\n\n            if (CandidatePairState.SUCCEEDED.equals(newState))\n            {\n                if (keepAliveStrategy == KeepAliveStrategy.ALL_SUCCEEDED)\n                {\n                    addToKeepAlive = true;\n                }\n                else if (keepAliveStrategy == KeepAliveStrategy.SELECTED_AND_TCP)\n                {\n                    Transport transport\n                        = pair.getLocalCandidate().getTransport();\n                    addToKeepAlive = transport == Transport.TCP\n                        || transport == Transport.SSLTCP;\n\n                    // Pairs with a remote TCP port 9 cannot be checked.\n                    // Instead, the corresponding pair with the peer reflexive\n                    // candidate needs to be checked. However, we observe\n                    // such pairs transitioning into the SUCCEEDED state.\n                    // Ignore them.\n                    addToKeepAlive\n                        &= pair.getRemoteCandidate()\n                                .getTransportAddress().getPort() != 9;\n                }\n            }\n        }\n\n        if (addToKeepAlive && !keepAlivePairs.contains(pair))\n        {\n            keepAlivePairs.add(pair);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Component.java", "class_name": "Component", "class_uri": "src/main/java/org/ice4j/ice/Component.java.Component", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\n{@inheritDoc}\n</p>\nHandles events coming from candidate pairs.\n"}, {"uris": "src/main/java/org/ice4j/ice/Component.java.Component.[Logger]getLogger()", "name": "getLogger", "arg_nums": 0, "params": [], "return_type": "Logger", "signature": "public Logger getLogger()", "original_string": "    public Logger getLogger()\n    {\n        return logger;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Component.java", "class_name": "Component", "class_uri": "src/main/java/org/ice4j/ice/Component.java.Component", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Logger", "classes": []}, "docstring": ""}, {"uris": "src/main/java/org/ice4j/ice/Component.java.Component.[void]send(byte[],int,int)", "name": "send", "arg_nums": 3, "params": [{"name": "buffer", "type": "byte[]"}, {"name": "offset", "type": "int"}, {"name": "length", "type": "int"}], "return_type": "void", "signature": "public void send(byte[] buffer, int offset, int length)", "original_string": "    public void send(byte[] buffer, int offset, int length)\n            throws IOException\n    {\n        CandidatePair pair = getSelectedPair();\n        if (pair == null)\n        {\n            logger.debug(\"No selected pair, will try valid for sending\");\n            pair = parentStream.getValidPair(this);\n            if (pair == null)\n            {\n                throw new IOException(\"No valid pair.\");\n            }\n        }\n\n        LocalCandidate localCandidate = pair.getLocalCandidate();\n        if (localCandidate != null && localCandidate.getBase() != null)\n        {\n            localCandidate = localCandidate.getBase();\n        }\n        SocketAddress remoteAddress = pair.getRemoteCandidate().getTransportAddress();\n        IceSocketWrapper socket\n                = localCandidate == null ? null : localCandidate.getCandidateIceSocketWrapper(remoteAddress);\n\n        if (socket == null)\n        {\n            throw new IOException(\"No socket found to send on.\");\n        }\n\n        DatagramPacket p = new DatagramPacket(buffer, offset, length);\n        p.setSocketAddress(remoteAddress);\n        socket.send(p);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Component.java", "class_name": "Component", "class_uri": "src/main/java/org/ice4j/ice/Component.java.Component", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSend a packet to the remote side. Uses the last used candidate pair to find the right socket and remote address.\n"}, {"uris": "src/main/java/org/ice4j/ice/Component.java.Component.[void]handleBuffer(Buffer)", "name": "handleBuffer", "arg_nums": 1, "params": [{"name": "buffer", "type": "Buffer"}], "return_type": "void", "signature": "@Override\n    public void handleBuffer(@NotNull Buffer buffer)", "original_string": "    @Override\n    public void handleBuffer(@NotNull Buffer buffer)\n    {\n        BufferHandler bufferCallback = this.bufferCallback;\n\n        if (bufferCallback == null)\n        {\n            logger.warn(\n                    \"The push API is used while no buffer callback has been set, dropping a packet (use-push-api=\"\n                            + AbstractUdpListener.USE_PUSH_API + \").\");\n            BufferPool.returnBuffer.invoke(buffer);\n            return;\n        }\n\n        try\n        {\n            bufferCallback.handleBuffer(buffer);\n        }\n        catch (Exception e)\n        {\n            logger.warn(\"Buffer handling failed\", e);\n            BufferPool.returnBuffer.invoke(buffer);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Component.java", "class_name": "Component", "class_uri": "src/main/java/org/ice4j/ice/Component.java.Component", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nHandle a buffer that was received from one of the sockets and should be forwarded to the application.\n"}, {"uris": "src/main/java/org/ice4j/ice/Component.java.Component.[void]setBufferCallback(BufferHandler)", "name": "setBufferCallback", "arg_nums": 1, "params": [{"name": "bufferCallback", "type": "BufferHandler"}], "return_type": "void", "signature": "public void setBufferCallback(BufferHandler bufferCallback)", "original_string": "    public void setBufferCallback(BufferHandler bufferCallback)\n    {\n        this.bufferCallback = bufferCallback;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/Component.java", "class_name": "Component", "class_uri": "src/main/java/org/ice4j/ice/Component.java.Component", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSet the external callback to be used for the push API.\n@param bufferCallback the external callback\n"}, {"uris": "src/main/java/org/ice4j/ice/RelayedCandidate.java.RelayedCandidate.[]RelayedCandidate(TransportAddress,TurnCandidateHarvest,TransportAddress)", "name": "RelayedCandidate", "arg_nums": 3, "params": [{"name": "transportAddress", "type": "TransportAddress"}, {"name": "turnCandidateHarvest", "type": "TurnCandidateHarvest"}, {"name": "mappedAddress", "type": "TransportAddress"}], "return_type": "", "signature": "public RelayedCandidate(\n            TransportAddress transportAddress,\n            TurnCandidateHarvest turnCandidateHarvest,\n            TransportAddress mappedAddress)", "original_string": "    public RelayedCandidate(\n            TransportAddress transportAddress,\n            TurnCandidateHarvest turnCandidateHarvest,\n            TransportAddress mappedAddress)\n    {\n        super(\n            transportAddress,\n            turnCandidateHarvest.hostCandidate.getParentComponent(),\n            CandidateType.RELAYED_CANDIDATE,\n            CandidateExtendedType.TURN_RELAYED_CANDIDATE,\n            turnCandidateHarvest.hostCandidate.getParentComponent()\n                .findLocalCandidate(mappedAddress));\n\n        this.turnCandidateHarvest = turnCandidateHarvest;\n\n        // RFC 5245: The base of a relayed candidate is that candidate itself.\n        setBase(this);\n        setRelayServerAddress(turnCandidateHarvest.harvester.stunServer);\n        setMappedAddress(mappedAddress);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/RelayedCandidate.java", "class_name": "RelayedCandidate", "class_uri": "src/main/java/org/ice4j/ice/RelayedCandidate.java.RelayedCandidate", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>RelayedCandidate</tt> which is to represent a\nspecific <tt>TransportAddress</tt> harvested through a specific\n<tt>HostCandidate</tt> and a TURN server with a specific\n<tt>TransportAddress</tt>.\n\n@param transportAddress the <tt>TransportAddress</tt> to be represented\nby the new instance\n@param turnCandidateHarvest the <tt>TurnCandidateHarvest</tt> which has\nharvested the new instance\n@param mappedAddress the mapped <tt>TransportAddress</tt> reported by the\nTURN server with the delivery of the replayed <tt>transportAddress</tt>\nto be represented by the new instance\n"}, {"uris": "src/main/java/org/ice4j/ice/RelayedCandidate.java.RelayedCandidate.[RelayedCandidateDatagramSocket]getRelayedCandidateDatagramSocket()", "name": "getRelayedCandidateDatagramSocket", "arg_nums": 0, "params": [], "return_type": "RelayedCandidateDatagramSocket", "signature": "private synchronized RelayedCandidateDatagramSocket\n        getRelayedCandidateDatagramSocket()", "original_string": "    private synchronized RelayedCandidateDatagramSocket\n        getRelayedCandidateDatagramSocket()\n    {\n        if (relayedCandidateDatagramSocket == null)\n        {\n            try\n            {\n                relayedCandidateDatagramSocket\n                    = new RelayedCandidateDatagramSocket(\n                            this,\n                            turnCandidateHarvest);\n            }\n            catch (SocketException sex)\n            {\n                throw new UndeclaredThrowableException(sex);\n            }\n        }\n        return relayedCandidateDatagramSocket;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/RelayedCandidate.java", "class_name": "RelayedCandidate", "class_uri": "src/main/java/org/ice4j/ice/RelayedCandidate.java.RelayedCandidate", "attributes": {"modifiers": "private synchronized", "marker_annotations": [], "non_marker_annotations": ["private", "synchronized"], "comments": [], "return_type": "RelayedCandidateDatagramSocket", "classes": []}, "docstring": "\nGets the <tt>RelayedCandidateDatagramSocket</tt> of this\n<tt>RelayedCandidate</tt>.\n<p>\n<b>Note</b>: The method is part of the internal API of\n<tt>RelayedCandidate</tt> and <tt>TurnCandidateHarvest</tt> and is not\nintended for public use.\n</p>\n\n@return the <tt>RelayedCandidateDatagramSocket</tt> of this\n<tt>RelayedCandidate</tt>\n"}, {"uris": "src/main/java/org/ice4j/ice/RelayedCandidate.java.RelayedCandidate.[IceSocketWrapper]getCandidateIceSocketWrapper()", "name": "getCandidateIceSocketWrapper", "arg_nums": 0, "params": [], "return_type": "IceSocketWrapper", "signature": "@Override\n    public synchronized IceSocketWrapper getCandidateIceSocketWrapper()", "original_string": "    @Override\n    public synchronized IceSocketWrapper getCandidateIceSocketWrapper()\n    {\n        if (socket == null)\n        {\n            try\n            {\n                socket\n                    = new IceUdpSocketWrapper(new MultiplexingDatagramSocket(\n                            getRelayedCandidateDatagramSocket()));\n            }\n            catch (SocketException sex)\n            {\n                throw new UndeclaredThrowableException(sex);\n            }\n        }\n        return socket;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/RelayedCandidate.java", "class_name": "RelayedCandidate", "class_uri": "src/main/java/org/ice4j/ice/RelayedCandidate.java.RelayedCandidate", "attributes": {"modifiers": "@Override\n    public synchronized", "marker_annotations": ["@Override"], "non_marker_annotations": ["public", "synchronized"], "comments": [], "return_type": "IceSocketWrapper", "classes": []}, "docstring": "\nGets the application-purposed <tt>DatagramSocket</tt> associated with\nthis <tt>Candidate</tt>.\n\n@return the <tt>DatagramSocket</tt> associated with this\n<tt>Candidate</tt>\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/AbstractCandidateHarvester.java.AbstractCandidateHarvester.[HarvestStatistics]getHarvestStatistics()", "name": "getHarvestStatistics", "arg_nums": 0, "params": [], "return_type": "HarvestStatistics", "signature": "@Override\n    public HarvestStatistics getHarvestStatistics()", "original_string": "    @Override\n    public HarvestStatistics getHarvestStatistics()\n    {\n        return harvestStatistics;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/AbstractCandidateHarvester.java", "class_name": "AbstractCandidateHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/AbstractCandidateHarvester.java.AbstractCandidateHarvester", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "HarvestStatistics", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/AbstractCandidateHarvester.java.AbstractCandidateHarvester.[boolean]isHostHarvester()", "name": "isHostHarvester", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "@Override\n    public boolean isHostHarvester()", "original_string": "    @Override\n    public boolean isHostHarvester()\n    {\n        return false;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/AbstractCandidateHarvester.java", "class_name": "AbstractCandidateHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/AbstractCandidateHarvester.java.AbstractCandidateHarvester", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSetTask.java.CandidateHarvesterSetTask.[]CandidateHarvesterSetTask(CandidateHarvesterSetElement,Collection<Component>,TrickleCallback)", "name": "CandidateHarvesterSetTask", "arg_nums": 3, "params": [{"name": "harvester", "type": "CandidateHarvesterSetElement"}, {"name": "components", "type": "Collection<Component>"}, {"name": "trickleCallback", "type": "TrickleCallback"}], "return_type": "", "signature": "public CandidateHarvesterSetTask(\n            CandidateHarvesterSetElement harvester,\n            Collection<Component>        components,\n            TrickleCallback              trickleCallback)", "original_string": "    public CandidateHarvesterSetTask(\n            CandidateHarvesterSetElement harvester,\n            Collection<Component>        components,\n            TrickleCallback              trickleCallback)\n    {\n        this.harvester = harvester;\n        this.components = components;\n        this.trickleCallback = trickleCallback;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSetTask.java", "class_name": "CandidateHarvesterSetTask", "class_uri": "src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSetTask.java.CandidateHarvesterSetTask", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>CandidateHarvesterSetTask</tt> which is to\ncall {@link CandidateHarvester#harvest(org.ice4j.ice.Component)} on a\nspecific harvester and then as many harvesters as possible.\n\n@param harvester the <tt>CandidateHarvester</tt> on which the\nnew instance is to call\n@param components the <tt>Component</tt> whose candidates we are currently\ngathering.\n<tt>CandidateHarvester#harvest(Component)</tt> first\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSetTask.java.CandidateHarvesterSetTask.[CandidateHarvesterSetElement]getHarvester()", "name": "getHarvester", "arg_nums": 0, "params": [], "return_type": "CandidateHarvesterSetElement", "signature": "public CandidateHarvesterSetElement getHarvester()", "original_string": "    public CandidateHarvesterSetElement getHarvester()\n    {\n        return harvester;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSetTask.java", "class_name": "CandidateHarvesterSetTask", "class_uri": "src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSetTask.java.CandidateHarvesterSetTask", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "CandidateHarvesterSetElement", "classes": []}, "docstring": "\nGets the <tt>CandidateHarvester</tt> on which\n{@link CandidateHarvester#harvest(org.ice4j.ice.Component)} is being\ncalled.\n\n@return the <tt>CandidateHarvester</tt> on which\n<tt>CandidateHarvester#harvest(Component)</tt> is being called\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSetTask.java.CandidateHarvesterSetTask.[void]run()", "name": "run", "arg_nums": 0, "params": [], "return_type": "void", "signature": "public void run()", "original_string": "    public void run()\n    {\n        if (harvester == null || !harvester.isEnabled())\n            return;\n\n        for (Component component : components)\n        {\n            try\n            {\n                harvester.harvest(component, trickleCallback);\n            }\n            catch (Throwable t)\n            {\n                logger.info(\n                    \"disabling harvester due to exception: \" +\n                        t.getLocalizedMessage());\n                harvester.setEnabled(false);\n\n                if (t instanceof ThreadDeath)\n                    throw (ThreadDeath) t;\n            }\n        }\n\n        /*\n         * CandidateHarvester#harvest(Component) has been called on\n         * the harvester and its success or failure has been noted.\n         * Now forget the harvester because any failure to continue\n         * execution is surely not its fault.\n         */\n        harvester = null;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSetTask.java", "class_name": "CandidateHarvesterSetTask", "class_uri": "src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSetTask.java.CandidateHarvesterSetTask", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nRuns the actual harvesting for this component\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest.[]StunCandidateHarvest(StunCandidateHarvester,HostCandidate)", "name": "StunCandidateHarvest", "arg_nums": 2, "params": [{"name": "harvester", "type": "StunCandidateHarvester"}, {"name": "hostCandidate", "type": "HostCandidate"}], "return_type": "", "signature": "public StunCandidateHarvest(\n            StunCandidateHarvester harvester,\n            HostCandidate hostCandidate)", "original_string": "    public StunCandidateHarvest(\n            StunCandidateHarvester harvester,\n            HostCandidate hostCandidate)\n    {\n        this.harvester = harvester;\n        this.hostCandidate = hostCandidate;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java", "class_name": "StunCandidateHarvest", "class_uri": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>StunCandidateHarvest</tt> which is to represent the\nharvesting of STUN <tt>Candidate</tt>s for a specific\n<tt>HostCandidate</tt> performed by a specific\n<tt>StunCandidateHarvester</tt>.\n\n@param harvester the <tt>StunCandidateHarvester</tt> which is performing\nthe STUN harvesting\n@param hostCandidate the <tt>HostCandidate</tt> for which STUN\n<tt>Candidate</tt>s are to be harvested\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest.[boolean]addCandidate(LocalCandidate)", "name": "addCandidate", "arg_nums": 1, "params": [{"name": "candidate", "type": "LocalCandidate"}], "return_type": "boolean", "signature": "protected boolean addCandidate(LocalCandidate candidate)", "original_string": "    protected boolean addCandidate(LocalCandidate candidate)\n    {\n        boolean added;\n\n        //try to add the candidate to the component and then only add it to the\n        //harvest if it wasn't deemed redundant\n        if (!candidates.contains(candidate)\n                && hostCandidate.getParentComponent().addLocalCandidate(\n                        candidate))\n        {\n            added = candidates.add(candidate);\n        }\n        else\n        {\n            added = false;\n        }\n        return added;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java", "class_name": "StunCandidateHarvest", "class_uri": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nAdds a specific <tt>LocalCandidate</tt> to the list of\n<tt>LocalCandidate</tt>s harvested for {@link #hostCandidate} by this\nharvest.\n\n@param candidate the <tt>LocalCandidate</tt> to be added to the list of\n<tt>LocalCandidate</tt>s harvested for {@link #hostCandidate} by this\nharvest\n@return <tt>true</tt> if the list of <tt>LocalCandidate</tt>s changed as\na result of the method invocation; otherwise, <tt>false</tt>\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest.[boolean]addShortTermCredentialAttributes(Request)", "name": "addShortTermCredentialAttributes", "arg_nums": 1, "params": [{"name": "request", "type": "Request"}], "return_type": "boolean", "signature": "protected boolean addShortTermCredentialAttributes(Request request)", "original_string": "    protected boolean addShortTermCredentialAttributes(Request request)\n    {\n        String shortTermCredentialUsername\n            = harvester.getShortTermCredentialUsername();\n\n        if (shortTermCredentialUsername != null)\n        {\n            request.putAttribute(\n                    AttributeFactory.createUsernameAttribute(\n                            shortTermCredentialUsername));\n            request.putAttribute(\n                    AttributeFactory.createMessageIntegrityAttribute(\n                            shortTermCredentialUsername));\n            return true;\n        }\n        else\n            return false;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java", "class_name": "StunCandidateHarvest", "class_uri": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nAdds the <tt>Attribute</tt>s to a specific <tt>Request</tt> which support\nthe STUN short-term credential mechanism if the mechanism in question is\nutilized by this <tt>StunCandidateHarvest</tt> (i.e. by the associated\n<tt>StunCandidateHarvester</tt>).\n\n@param request the <tt>Request</tt> to which to add the\n<tt>Attribute</tt>s supporting the STUN short-term credential mechanism\nif the mechanism in question is utilized by this\n<tt>StunCandidateHarvest</tt>\n@return <tt>true</tt> if the STUN short-term credential mechanism is\nactually utilized by this <tt>StunCandidateHarvest</tt> for the specified\n<tt>request</tt>; otherwise, <tt>false</tt>\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest.[boolean]completedResolvingCandidate(Request,Response)", "name": "completedResolvingCandidate", "arg_nums": 2, "params": [{"name": "request", "type": "Request"}, {"name": "response", "type": "Response"}], "return_type": "boolean", "signature": "protected boolean completedResolvingCandidate(\n            Request request,\n            Response response)", "original_string": "    protected boolean completedResolvingCandidate(\n            Request request,\n            Response response)\n    {\n        if (!completedResolvingCandidate)\n        {\n            completedResolvingCandidate = true;\n            try\n            {\n                if (((response == null) || !response.isSuccessResponse())\n                        && (longTermCredentialSession != null))\n                {\n                    harvester\n                        .getStunStack()\n                            .getCredentialsManager()\n                                .unregisterAuthority(longTermCredentialSession);\n                    longTermCredentialSession = null;\n                }\n            }\n            finally\n            {\n                harvester.completedResolvingCandidate(this);\n            }\n        }\n        return completedResolvingCandidate;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java", "class_name": "StunCandidateHarvest", "class_uri": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nCompletes the harvesting of <tt>Candidate</tt>s for\n{@link #hostCandidate}. Notifies {@link #harvester} about the completion\nof the harvesting of <tt>Candidate</tt> for <tt>hostCandidate</tt>\nperformed by this <tt>StunCandidateHarvest</tt>.\n\n@param request the <tt>Request</tt> sent by this\n<tt>StunCandidateHarvest</tt> with which the harvesting of\n<tt>Candidate</tt>s for <tt>hostCandidate</tt> has completed\n@param response the <tt>Response</tt> received by this\n<tt>StunCandidateHarvest</tt>, if any, with which the harvesting of\n<tt>Candidate</tt>s for <tt>hostCandidate</tt> has completed\n@return <tt>true</tt> if the harvesting of <tt>Candidate</tt>s for\n<tt>hostCandidate</tt> performed by this <tt>StunCandidateHarvest</tt>\nhas completed; otherwise, <tt>false</tt>\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest.[boolean]containsCandidate(LocalCandidate)", "name": "containsCandidate", "arg_nums": 1, "params": [{"name": "candidate", "type": "LocalCandidate"}], "return_type": "boolean", "signature": "protected boolean containsCandidate(LocalCandidate candidate)", "original_string": "    protected boolean containsCandidate(LocalCandidate candidate)\n    {\n        if (candidate != null)\n        {\n            LocalCandidate[] candidates = getCandidates();\n\n            if ((candidates != null) && (candidates.length != 0))\n            {\n                for (LocalCandidate c : candidates)\n                {\n                    if (candidate.equals(c))\n                        return true;\n                }\n            }\n        }\n        return false;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java", "class_name": "StunCandidateHarvest", "class_uri": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nDetermines whether a specific <tt>LocalCandidate</tt> is contained in the\nlist of <tt>LocalCandidate</tt>s harvested for {@link #hostCandidate} by\nthis harvest.\n\n@param candidate the <tt>LocalCandidate</tt> to look for in the list of\n<tt>LocalCandidate</tt>s harvested for {@link #hostCandidate} by this\nharvest\n@return <tt>true</tt> if the list of <tt>LocalCandidate</tt>s contains\nthe specified <tt>candidate</tt>; otherwise, <tt>false</tt>\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest.[void]createCandidates(Response)", "name": "createCandidates", "arg_nums": 1, "params": [{"name": "response", "type": "Response"}], "return_type": "void", "signature": "protected void createCandidates(Response response)", "original_string": "    protected void createCandidates(Response response)\n    {\n        createServerReflexiveCandidate(response);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java", "class_name": "StunCandidateHarvest", "class_uri": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCreates new <tt>Candidate</tt>s determined by a specific STUN\n<tt>Response</tt>.\n\n@param response the received STUN <tt>Response</tt>\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest.[Message]createKeepAliveMessage(LocalCandidate)", "name": "createKeepAliveMessage", "arg_nums": 1, "params": [{"name": "candidate", "type": "LocalCandidate"}], "return_type": "Message", "signature": "protected Message createKeepAliveMessage(LocalCandidate candidate)", "original_string": "    protected Message createKeepAliveMessage(LocalCandidate candidate)\n        throws StunException\n    {\n        /*\n         * We'll not be keeping a STUN Binding alive for now. If we decide to in\n         * the future, we'll have to create a Binding Indication and add support\n         * for sending it.\n         */\n        if (CandidateType.SERVER_REFLEXIVE_CANDIDATE.equals(\n                candidate.getType()))\n            return null;\n        else\n        {\n            throw\n                new StunException(StunException.ILLEGAL_ARGUMENT, \"candidate\");\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java", "class_name": "StunCandidateHarvest", "class_uri": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Message", "classes": []}, "docstring": "\nCreates a new STUN <tt>Message</tt> to be sent to the STUN server\nassociated with the <tt>StunCandidateHarvester</tt> of this instance in\norder to keep a specific <tt>LocalCandidate</tt> (harvested by this\ninstance) alive.\n\n@param candidate the <tt>LocalCandidate</tt> (harvested by this instance)\nto create a new keep-alive STUN message for\n@return a new keep-alive STUN <tt>Message</tt> for the specified\n<tt>candidate</tt> or <tt>null</tt> if no keep-alive sending is to occur\n@throws StunException if anything goes wrong while creating the new\nkeep-alive STUN <tt>Message</tt> for the specified <tt>candidate</tt>\nor the candidate is of an unsupported <tt>CandidateType</tt>\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest.[Request]createRequestToRetry(Request)", "name": "createRequestToRetry", "arg_nums": 1, "params": [{"name": "request", "type": "Request"}], "return_type": "Request", "signature": "protected Request createRequestToRetry(Request request)", "original_string": "    protected Request createRequestToRetry(Request request)\n    {\n        switch (request.getMessageType())\n        {\n        case Message.BINDING_REQUEST:\n            return MessageFactory.createBindingRequest();\n        default:\n            throw new IllegalArgumentException(\"request.messageType\");\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java", "class_name": "StunCandidateHarvest", "class_uri": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Request", "classes": []}, "docstring": "\nCreates a new <tt>Request</tt> instance which is to be sent by this\n<tt>StunCandidateHarvest</tt> in order to retry a specific\n<tt>Request</tt>. For example, the long-term credential mechanism\ndictates that a <tt>Request</tt> is first sent by the client without any\ncredential-related attributes, then it gets challenged by the server and\nthe client retries the original <tt>Request</tt> with the appropriate\ncredential-related attributes in response.\n\n@param request the <tt>Request</tt> which is to be retried by this\n<tt>StunCandidateHarvest</tt>\n@return the new <tt>Request</tt> instance which is to be sent by this\n<tt>StunCandidateHarvest</tt> in order to retry the specified\n<tt>request</tt>\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest.[Request]createRequestToStartResolvingCandidate()", "name": "createRequestToStartResolvingCandidate", "arg_nums": 0, "params": [], "return_type": "Request", "signature": "protected Request createRequestToStartResolvingCandidate()", "original_string": "    protected Request createRequestToStartResolvingCandidate()\n    {\n        return MessageFactory.createBindingRequest();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java", "class_name": "StunCandidateHarvest", "class_uri": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Request", "classes": []}, "docstring": "\nCreates a new <tt>Request</tt> which is to be sent to\n{@link StunCandidateHarvester#stunServer} in order to start resolving\n{@link #hostCandidate}.\n\n@return a new <tt>Request</tt> which is to be sent to\n{@link StunCandidateHarvester#stunServer} in order to start resolving\n{@link #hostCandidate}\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest.[void]createSendKeepAliveMessageThread()", "name": "createSendKeepAliveMessageThread", "arg_nums": 0, "params": [], "return_type": "void", "signature": "private void createSendKeepAliveMessageThread()", "original_string": "    private void createSendKeepAliveMessageThread()\n    {\n        synchronized (sendKeepAliveMessageSyncRoot)\n        {\n            Thread t = new SendKeepAliveMessageThread(this);\n            t.setDaemon(true);\n            t.setName(\n                    getClass().getName() + \".sendKeepAliveMessageThread: \"\n                        + hostCandidate);\n\n            boolean started = false;\n\n            sendKeepAliveMessageThread = t;\n            try\n            {\n                t.start();\n                started = true;\n            }\n            finally\n            {\n                if (!started && (sendKeepAliveMessageThread == t))\n                    sendKeepAliveMessageThread = null;\n            }\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java", "class_name": "StunCandidateHarvest", "class_uri": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCreates and starts the {@link #sendKeepAliveMessageThread} which is to\nsend STUN keep-alive <tt>Message</tt>s to the STUN server associated with\nthe <tt>StunCandidateHarvester</tt> of this instance in order to keep the\n<tt>Candidate</tt>s harvested by this instance alive.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest.[void]createServerReflexiveCandidate(Response)", "name": "createServerReflexiveCandidate", "arg_nums": 1, "params": [{"name": "response", "type": "Response"}], "return_type": "void", "signature": "protected void createServerReflexiveCandidate(Response response)", "original_string": "    protected void createServerReflexiveCandidate(Response response)\n    {\n        TransportAddress addr = getMappedAddress(response);\n\n        if (addr != null)\n        {\n            ServerReflexiveCandidate srvrRflxCand\n                = createServerReflexiveCandidate(addr);\n\n            if (srvrRflxCand != null)\n            {\n                try\n                {\n                    addCandidate(srvrRflxCand);\n                }\n                finally\n                {\n                    // Free srvrRflxCand if it has not been consumed.\n                    if (!containsCandidate(srvrRflxCand))\n                    {\n                        try\n                        {\n                            srvrRflxCand.free();\n                        }\n                        catch (Exception ex)\n                        {\n                            if (logger.isLoggable(Level.FINE))\n                            {\n                                logger.log(\n                                        Level.FINE,\n                                        \"Failed to free\"\n                                            + \" ServerReflexiveCandidate: \"\n                                            + srvrRflxCand,\n                                        ex);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java", "class_name": "StunCandidateHarvest", "class_uri": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCreates a <tt>ServerReflexiveCandidate</tt> using {@link #hostCandidate}\nas its base and the <tt>XOR-MAPPED-ADDRESS</tt> attribute in\n<tt>response</tt> for the actual <tt>TransportAddress</tt> of the new\ncandidate. If the message is malformed and/or does not contain the\ncorresponding attribute, this method simply has no effect.\n\n@param response the STUN <tt>Response</tt> which is supposed to contain\nthe address we should use for the new candidate\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest.[ServerReflexiveCandidate]createServerReflexiveCandidate(TransportAddress)", "name": "createServerReflexiveCandidate", "arg_nums": 1, "params": [{"name": "transportAddress", "type": "TransportAddress"}], "return_type": "ServerReflexiveCandidate", "signature": "protected ServerReflexiveCandidate createServerReflexiveCandidate(\n            TransportAddress transportAddress)", "original_string": "    protected ServerReflexiveCandidate createServerReflexiveCandidate(\n            TransportAddress transportAddress)\n    {\n        return\n            new ServerReflexiveCandidate(\n                    transportAddress,\n                    hostCandidate,\n                    harvester.stunServer,\n                    CandidateExtendedType.STUN_SERVER_REFLEXIVE_CANDIDATE);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java", "class_name": "StunCandidateHarvest", "class_uri": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "ServerReflexiveCandidate", "classes": []}, "docstring": "\nCreates a new <tt>ServerReflexiveCandidate</tt> instance which is to\nrepresent a specific <tt>TransportAddress</tt> harvested through\n{@link #hostCandidate} and the STUN server associated with\n{@link #harvester}.\n\n@param transportAddress the <tt>TransportAddress</tt> to be represented\nby the new <tt>ServerReflexiveCandidate</tt> instance\n@return a new <tt>ServerReflexiveCandidate</tt> instance which represents\nthe specified <tt>TransportAddress</tt> harvested through\n{@link #hostCandidate} and the STUN server associated with\n{@link #harvester}\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest.[void]exitSendKeepAliveMessageThread()", "name": "exitSendKeepAliveMessageThread", "arg_nums": 0, "params": [], "return_type": "void", "signature": "private void exitSendKeepAliveMessageThread()", "original_string": "    private void exitSendKeepAliveMessageThread()\n    {\n        synchronized (sendKeepAliveMessageSyncRoot)\n        {\n            if (sendKeepAliveMessageThread == Thread.currentThread())\n                sendKeepAliveMessageThread = null;\n\n            /*\n             * Well, if the currentThread is finishing and this instance is\n             * still to send keep-alive messages, we'd better start another\n             * Thread for the purpose to continue the work that the\n             * currentThread was supposed to carry out.\n             */\n            if ((sendKeepAliveMessageThread == null)\n                    && (sendKeepAliveMessageInterval\n                         != SEND_KEEP_ALIVE_MESSAGE_INTERVAL_NOT_SPECIFIED))\n            {\n                createSendKeepAliveMessageThread();\n            }\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java", "class_name": "StunCandidateHarvest", "class_uri": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nRuns in {@link #sendKeepAliveMessageThread} to notify this instance that\n<tt>sendKeepAliveMessageThread</tt> is about to exit.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest.[int]getCandidateCount()", "name": "getCandidateCount", "arg_nums": 0, "params": [], "return_type": "int", "signature": "int getCandidateCount()", "original_string": "    int getCandidateCount()\n    {\n        return candidates.size();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java", "class_name": "StunCandidateHarvest", "class_uri": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "int", "classes": []}, "docstring": "\nGets the number of <tt>Candidate</tt>s harvested for\n{@link #hostCandidate} during this harvest.\n\n@return the number of <tt>Candidate</tt>s harvested for\n{@link #hostCandidate} during this harvest\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest.[LocalCandidate[]]getCandidates()", "name": "getCandidates", "arg_nums": 0, "params": [], "return_type": "LocalCandidate[]", "signature": "LocalCandidate[] getCandidates()", "original_string": "    LocalCandidate[] getCandidates()\n    {\n        return candidates.toArray(NO_CANDIDATES);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java", "class_name": "StunCandidateHarvest", "class_uri": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "LocalCandidate[]", "classes": []}, "docstring": "\nGets the <tt>Candidate</tt>s harvested for {@link #hostCandidate} during\nthis harvest.\n\n@return an array containing the <tt>Candidate</tt>s harvested for\n{@link #hostCandidate} during this harvest\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest.[TransportAddress]getMappedAddress(Response)", "name": "getMappedAddress", "arg_nums": 1, "params": [{"name": "response", "type": "Response"}], "return_type": "TransportAddress", "signature": "protected TransportAddress getMappedAddress(Response response)", "original_string": "    protected TransportAddress getMappedAddress(Response response)\n    {\n        Attribute attribute\n            = response.getAttribute(Attribute.XOR_MAPPED_ADDRESS);\n\n        if (attribute instanceof XorMappedAddressAttribute)\n        {\n            return\n                ((XorMappedAddressAttribute) attribute)\n                    .getAddress(response.getTransactionID());\n        }\n\n        // old STUN servers (RFC3489) send MAPPED-ADDRESS address\n        attribute\n            = response.getAttribute(Attribute.MAPPED_ADDRESS);\n\n        if (attribute instanceof MappedAddressAttribute)\n        {\n            return\n                ((MappedAddressAttribute) attribute)\n                    .getAddress();\n        }\n        else\n            return null;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java", "class_name": "StunCandidateHarvest", "class_uri": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "TransportAddress", "classes": []}, "docstring": "\nGets the <tt>TransportAddress</tt> specified in the XOR-MAPPED-ADDRESS\nattribute of a specific <tt>Response</tt>.\n\n@param response the <tt>Response</tt> from which the XOR-MAPPED-ADDRESS\nattribute is to be retrieved and its <tt>TransportAddress</tt> value is\nto be returned\n@return the <tt>TransportAddress</tt> specified in the XOR-MAPPED-ADDRESS\nattribute of <tt>response</tt>\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest.[boolean]processChallenge(byte[],byte[],Request,TransactionID)", "name": "processChallenge", "arg_nums": 4, "params": [{"name": "realm", "type": "byte[]"}, {"name": "nonce", "type": "byte[]"}, {"name": "request", "type": "Request"}, {"name": "requestTransactionID", "type": "TransactionID"}], "return_type": "boolean", "signature": "private boolean processChallenge(\n            byte[] realm,\n            byte[] nonce,\n            Request request,\n            TransactionID requestTransactionID)", "original_string": "    private boolean processChallenge(\n            byte[] realm,\n            byte[] nonce,\n            Request request,\n            TransactionID requestTransactionID)\n        throws StunException\n    {\n        UsernameAttribute usernameAttribute\n            = (UsernameAttribute) request.getAttribute(Attribute.USERNAME);\n\n        if (usernameAttribute == null)\n        {\n            if (longTermCredentialSession == null)\n            {\n                LongTermCredential longTermCredential\n                    = harvester.createLongTermCredential(this, realm);\n\n                if (longTermCredential == null)\n                {\n                    // The long-term credential mechanism is not being utilized.\n                    return false;\n                }\n                else\n                {\n                    longTermCredentialSession\n                        = new LongTermCredentialSession(\n                                longTermCredential,\n                                realm);\n                    harvester\n                        .getStunStack()\n                            .getCredentialsManager()\n                                .registerAuthority(longTermCredentialSession);\n                }\n            }\n            else\n            {\n                /*\n                 * If we're going to use the long-term credential to retry the\n                 * request, the long-term credential should be for the request\n                 * in terms of realm.\n                 */\n                if (!longTermCredentialSession.realmEquals(realm))\n                    return false;\n            }\n        }\n        else\n        {\n            /*\n             * If we sent a USERNAME in our request, then we had the long-term\n             * credential at the time we sent the request in question.\n             */\n            if (longTermCredentialSession == null)\n                return false;\n            else\n            {\n                /*\n                 * If we're going to use the long-term credential to retry the\n                 * request, the long-term credential should be for the request\n                 * in terms of username.\n                 */\n                if (!longTermCredentialSession.usernameEquals(\n                        usernameAttribute.getUsername()))\n                    return false;\n                else\n                {\n                    // And it terms of realm, of course.\n                    if (!longTermCredentialSession.realmEquals(realm))\n                        return false;\n                }\n            }\n        }\n\n        /*\n         * The nonce is either becoming known for the first time or being\n         * updated after the old one has gone stale.\n         */\n        longTermCredentialSession.setNonce(nonce);\n\n        Request retryRequest = createRequestToRetry(request);\n        TransactionID retryRequestTransactionID = null;\n\n        if (retryRequest != null)\n        {\n            if (requestTransactionID != null)\n            {\n                Object applicationData\n                    = requestTransactionID.getApplicationData();\n\n                if (applicationData != null)\n                {\n                    byte[] retryRequestTransactionIDAsBytes\n                        = retryRequest.getTransactionID();\n\n                    retryRequestTransactionID\n                        = (retryRequestTransactionIDAsBytes == null)\n                            ? TransactionID.createNewTransactionID()\n                            : TransactionID.createTransactionID(\n                                    harvester.getStunStack(),\n                                    retryRequestTransactionIDAsBytes);\n                    retryRequestTransactionID.setApplicationData(\n                            applicationData);\n                }\n            }\n            retryRequestTransactionID\n                = sendRequest(retryRequest, false, retryRequestTransactionID);\n        }\n        return (retryRequestTransactionID != null);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java", "class_name": "StunCandidateHarvest", "class_uri": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nNotifies this <tt>StunCandidateHarvest</tt> that a specific STUN\n<tt>Request</tt> has been challenged for a long-term credential (as the\nshort-term credential mechanism does not utilize challenging) in a\nspecific <tt>realm</tt> and with a specific <tt>nonce</tt>.\n\n@param realm the realm in which the specified STUN <tt>Request</tt> has\nbeen challenged for a long-term credential\n@param nonce the nonce with which the specified STUN <tt>Request</tt> has\nbeen challenged for a long-term credential\n@param request the STUN <tt>Request</tt> which has been challenged for a\nlong-term credential\n@param requestTransactionID the <tt>TransactionID</tt> of\n<tt>request</tt> because <tt>request</tt> only has it as a <tt>byte</tt>\narray and <tt>TransactionID</tt> is required for the\n<tt>applicationData</tt> property value\n@return <tt>true</tt> if the challenge has been processed and this\n<tt>StunCandidateHarvest</tt> is to continue processing STUN\n<tt>Response</tt>s; otherwise, <tt>false</tt>\n@throws StunException if anything goes wrong while processing the\nchallenge\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest.[boolean]processChallenge(Response,Request,TransactionID)", "name": "processChallenge", "arg_nums": 3, "params": [{"name": "response", "type": "Response"}, {"name": "request", "type": "Request"}, {"name": "transactionID", "type": "TransactionID"}], "return_type": "boolean", "signature": "private boolean processChallenge(\n            Response response,\n            Request request,\n            TransactionID transactionID)", "original_string": "    private boolean processChallenge(\n            Response response,\n            Request request,\n            TransactionID transactionID)\n        throws StunException\n    {\n        boolean retried = false;\n\n        if (response.getAttributeCount() > 0)\n        {\n            /*\n             * The response SHOULD NOT contain a USERNAME or\n             * MESSAGE-INTEGRITY attribute.\n             */\n            char[] excludedResponseAttributeTypes\n                = new char[]\n                        {\n                            Attribute.USERNAME,\n                            Attribute.MESSAGE_INTEGRITY\n                        };\n            boolean challenge = true;\n\n            for (char excludedResponseAttributeType\n                    : excludedResponseAttributeTypes)\n            {\n                if (response.containsAttribute(excludedResponseAttributeType))\n                {\n                    challenge = false;\n                    break;\n                }\n            }\n            if (challenge)\n            {\n                // This response MUST include a REALM value.\n                RealmAttribute realmAttribute\n                    = (RealmAttribute) response.getAttribute(Attribute.REALM);\n\n                if (realmAttribute == null)\n                    challenge = false;\n                else\n                {\n                    // The response MUST include a NONCE.\n                    NonceAttribute nonceAttribute\n                        = (NonceAttribute)\n                            response.getAttribute(Attribute.NONCE);\n\n                    if (nonceAttribute == null)\n                        challenge = false;\n                    else\n                    {\n                        retried\n                            = processChallenge(\n                                    realmAttribute.getRealm(),\n                                    nonceAttribute.getNonce(),\n                                    request,\n                                    transactionID);\n                    }\n                }\n            }\n        }\n        return retried;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java", "class_name": "StunCandidateHarvest", "class_uri": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nNotifies this <tt>StunCandidateHarvest</tt> that a specific STUN\n<tt>Response</tt> has been received and it challenges a specific STUN\n<tt>Request</tt> for a long-term credential (as the short-term credential\nmechanism does not utilize challenging).\n\n@param response the STUN <tt>Response</tt> which has been received\n@param request the STUN <tt>Request</tt> to which <tt>response</tt>\nresponds and which it challenges for a long-term credential\n@return <tt>true</tt> if the challenge has been processed and this\n<tt>StunCandidateHarvest</tt> is to continue processing STUN\n<tt>Response</tt>s; otherwise, <tt>false</tt>\n@param transactionID the <tt>TransactionID</tt> of <tt>response</tt> and\n<tt>request</tt> because <tt>response</tt> and <tt>request</tt> only have\nit as a <tt>byte</tt> array and <tt>TransactionID</tt> is required for\nthe <tt>applicationData</tt> property value\n@throws StunException if anything goes wrong while processing the\nchallenge\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest.[boolean]processErrorOrFailure(Response,Request,TransactionID)", "name": "processErrorOrFailure", "arg_nums": 3, "params": [{"name": "response", "type": "Response"}, {"name": "request", "type": "Request"}, {"name": "transactionID", "type": "TransactionID"}], "return_type": "boolean", "signature": "protected boolean processErrorOrFailure(\n            Response response,\n            Request request,\n            TransactionID transactionID)", "original_string": "    protected boolean processErrorOrFailure(\n            Response response,\n            Request request,\n            TransactionID transactionID)\n    {\n        return false;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java", "class_name": "StunCandidateHarvest", "class_uri": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nNotifies this <tt>StunCandidateHarvest</tt> that a specific\n<tt>Request</tt> has either received an error <tt>Response</tt> or has\nfailed to receive any <tt>Response</tt>. Allows extenders to override and\nprocess unhandled error <tt>Response</tt>s or failures. The default\nimplementation does no processing.\n\n@param response the error <tt>Response</tt> which has been received for\n<tt>request</tt>\n@param request the <tt>Request</tt> to which <tt>Response</tt> responds\n@param transactionID the <tt>TransactionID</tt> of <tt>response</tt> and\n<tt>request</tt> because <tt>response</tt> and <tt>request</tt> only have\nit as a <tt>byte</tt> array and <tt>TransactionID</tt> is required for\nthe <tt>applicationData</tt> property value\n@return <tt>true</tt> if the error or failure condition has been\nprocessed and this instance can continue its execution (e.g. the\nresolution of the candidate) as if it was expected; otherwise,\n<tt>false</tt>\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest.[void]processFailure(BaseStunMessageEvent)", "name": "processFailure", "arg_nums": 1, "params": [{"name": "event", "type": "BaseStunMessageEvent"}], "return_type": "void", "signature": "@Override\n    protected void processFailure(BaseStunMessageEvent event)", "original_string": "    @Override\n    protected void processFailure(BaseStunMessageEvent event)\n    {\n        TransactionID transactionID = event.getTransactionID();\n\n        logger.finest(\"A transaction expired: tranid=\" + transactionID);\n        logger.finest(\"localAddr=\" + hostCandidate);\n\n        /*\n         * Clean up for the purposes of the workaround which determines the STUN\n         * Request to which a STUN Response responds.\n         */\n        Request request;\n\n        synchronized (requests)\n        {\n            request = requests.remove(transactionID);\n        }\n        if (request == null)\n        {\n            Message message = event.getMessage();\n\n            if (message instanceof Request)\n                request = (Request) message;\n        }\n\n        boolean completedResolvingCandidate = true;\n        try\n        {\n            if (processErrorOrFailure(null, request, transactionID))\n                completedResolvingCandidate = false;\n        }\n        finally\n        {\n            if (completedResolvingCandidate)\n                completedResolvingCandidate(request, null);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java", "class_name": "StunCandidateHarvest", "class_uri": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest", "attributes": {"modifiers": "@Override\n    protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nNotifies this <tt>ResponseCollector</tt> that a transaction described by\nthe specified <tt>BaseStunMessageEvent</tt> has failed. The possible\nreasons for the failure include timeouts, unreachable destination, etc.\n\n@param event the <tt>BaseStunMessageEvent</tt> which describes the failed\ntransaction and the runtime type of which specifies the failure reason\n@see AbstractResponseCollector#processFailure(BaseStunMessageEvent)\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest.[void]processResponse(StunResponseEvent)", "name": "processResponse", "arg_nums": 1, "params": [{"name": "event", "type": "StunResponseEvent"}], "return_type": "void", "signature": "@Override\n    public void processResponse(StunResponseEvent event)", "original_string": "    @Override\n    public void processResponse(StunResponseEvent event)\n    {\n        TransactionID transactionID = event.getTransactionID();\n\n        logger.finest(\"Received a message: tranid= \" + transactionID);\n        logger.finest(\"localCand= \" + hostCandidate);\n\n        /*\n         * Clean up for the purposes of the workaround which determines the STUN\n         * Request to which a STUN Response responds.\n         */\n        synchronized (requests)\n        {\n            requests.remove(transactionID);\n        }\n\n        // At long last, do start handling the received STUN Response.\n        Response response = event.getResponse();\n        Request request = event.getRequest();\n        boolean completedResolvingCandidate = true;\n\n        try\n        {\n            if (response.isSuccessResponse())\n            {\n                // Authentication and Message-Integrity Mechanisms\n                if (request.containsAttribute(Attribute.MESSAGE_INTEGRITY))\n                {\n                    MessageIntegrityAttribute messageIntegrityAttribute\n                        = (MessageIntegrityAttribute)\n                            response.getAttribute(Attribute.MESSAGE_INTEGRITY);\n\n                    /*\n                     * RFC 5389: If MESSAGE-INTEGRITY was absent, the response\n                     * MUST be discarded, as if it was never received.\n                     */\n                    if (messageIntegrityAttribute == null)\n                        return;\n\n                    UsernameAttribute usernameAttribute\n                        = (UsernameAttribute)\n                            request.getAttribute(Attribute.USERNAME);\n\n                    /*\n                     * For a request or indication message, the agent MUST\n                     * include the USERNAME and MESSAGE-INTEGRITY attributes in\n                     * the message.\n                     */\n                    if (usernameAttribute == null)\n                        return;\n                    if (!harvester.getStunStack().validateMessageIntegrity(\n                            messageIntegrityAttribute,\n                            LongTermCredential.toString(\n                                    usernameAttribute.getUsername()),\n                            !request.containsAttribute(Attribute.REALM)\n                                && !request.containsAttribute(Attribute.NONCE),\n                            event.getRawMessage()))\n                        return;\n                }\n\n                processSuccess(response, request, transactionID);\n            }\n            else\n            {\n                ErrorCodeAttribute errorCodeAttr\n                    = (ErrorCodeAttribute)\n                        response.getAttribute(Attribute.ERROR_CODE);\n\n                if ((errorCodeAttr != null)\n                        && (errorCodeAttr.getErrorClass() == 4))\n                {\n                    try\n                    {\n                        switch (errorCodeAttr.getErrorNumber())\n                        {\n                        case 1: // 401 Unauthorized\n                            if (processUnauthorized(\n                                    response,\n                                    request,\n                                    transactionID))\n                                completedResolvingCandidate = false;\n                            break;\n                        case 38: // 438 Stale Nonce\n                            if (processStaleNonce(\n                                    response,\n                                    request,\n                                    transactionID))\n                                completedResolvingCandidate = false;\n                            break;\n                        }\n                    }\n                    catch (StunException sex)\n                    {\n                        completedResolvingCandidate = true;\n                    }\n                }\n                if (completedResolvingCandidate\n                        && processErrorOrFailure(\n                                response,\n                                request,\n                                transactionID))\n                    completedResolvingCandidate = false;\n            }\n        }\n        finally\n        {\n            if (completedResolvingCandidate)\n                completedResolvingCandidate(request, response);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java", "class_name": "StunCandidateHarvest", "class_uri": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nNotifies this <tt>ResponseCollector</tt> that a STUN response described\nby the specified <tt>StunResponseEvent</tt> has been received.\n\n@param event the <tt>StunResponseEvent</tt> which describes the received\nSTUN response\n@see ResponseCollector#processResponse(StunResponseEvent)\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest.[boolean]processStaleNonce(Response,Request,TransactionID)", "name": "processStaleNonce", "arg_nums": 3, "params": [{"name": "response", "type": "Response"}, {"name": "request", "type": "Request"}, {"name": "transactionID", "type": "TransactionID"}], "return_type": "boolean", "signature": "private boolean processStaleNonce(\n            Response response,\n            Request request,\n            TransactionID transactionID)", "original_string": "    private boolean processStaleNonce(\n            Response response,\n            Request request,\n            TransactionID transactionID)\n        throws StunException\n    {\n        /*\n         * The request MUST contain USERNAME, REALM, NONCE and MESSAGE-INTEGRITY\n         * attributes.\n         */\n        boolean challenge;\n\n        if (request.getAttributeCount() > 0)\n        {\n            char[] includedRequestAttributeTypes\n                = new char[]\n                        {\n                            Attribute.USERNAME,\n                            Attribute.REALM,\n                            Attribute.NONCE,\n                            Attribute.MESSAGE_INTEGRITY\n                        };\n            challenge = true;\n\n            for (char includedRequestAttributeType\n                    : includedRequestAttributeTypes)\n            {\n                if (!request.containsAttribute(includedRequestAttributeType))\n                {\n                    challenge = false;\n                    break;\n                }\n            }\n        }\n        else\n            challenge = false;\n\n        return\n            (challenge && processChallenge(response, request, transactionID));\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java", "class_name": "StunCandidateHarvest", "class_uri": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nHandles a specific STUN error <tt>Response</tt> with error code\n\"438 Stale Nonce\" to a specific STUN <tt>Request</tt>.\n\n@param response the received STUN error <tt>Response</tt> with error code\n\"438 Stale Nonce\" which is to be handled\n@param request the STUN <tt>Request</tt> to which <tt>response</tt>\nresponds\n@param transactionID the <tt>TransactionID</tt> of <tt>response</tt> and\n<tt>request</tt> because <tt>response</tt> and <tt>request</tt> only have\nit as a <tt>byte</tt> array and <tt>TransactionID</tt> is required for\nthe <tt>applicationData</tt> property value\n@return <tt>true</tt> if the specified STUN error <tt>response</tt> was\nsuccessfully handled; <tt>false</tt>, otherwise\n@throws StunException if anything goes wrong while handling the specified\n\"438 Stale Nonce\" error <tt>response</tt>\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest.[void]processSuccess(Response,Request,TransactionID)", "name": "processSuccess", "arg_nums": 3, "params": [{"name": "response", "type": "Response"}, {"name": "request", "type": "Request"}, {"name": "transactionID", "type": "TransactionID"}], "return_type": "void", "signature": "protected void processSuccess(\n            Response response,\n            Request request,\n            TransactionID transactionID)", "original_string": "    protected void processSuccess(\n            Response response,\n            Request request,\n            TransactionID transactionID)\n    {\n        if (!completedResolvingCandidate)\n            createCandidates(response);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java", "class_name": "StunCandidateHarvest", "class_uri": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nHandles a specific STUN success <tt>Response</tt> to a specific STUN\n<tt>Request</tt>.\n\n@param response the received STUN success <tt>Response</tt> which is to\nbe handled\n@param request the STUN <tt>Request</tt> to which <tt>response</tt>\nresponds\n@param transactionID the <tt>TransactionID</tt> of <tt>response</tt> and\n<tt>request</tt> because <tt>response</tt> and <tt>request</tt> only have\nit as a <tt>byte</tt> array and <tt>TransactionID</tt> is required for\nthe <tt>applicationData</tt> property value\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest.[boolean]processUnauthorized(Response,Request,TransactionID)", "name": "processUnauthorized", "arg_nums": 3, "params": [{"name": "response", "type": "Response"}, {"name": "request", "type": "Request"}, {"name": "transactionID", "type": "TransactionID"}], "return_type": "boolean", "signature": "private boolean processUnauthorized(\n            Response response,\n            Request request,\n            TransactionID transactionID)", "original_string": "    private boolean processUnauthorized(\n            Response response,\n            Request request,\n            TransactionID transactionID)\n        throws StunException\n    {\n        /*\n         * If the response is a challenge, retry the request with a new\n         * transaction.\n         */\n        boolean challenge = true;\n\n        /*\n         * The client SHOULD omit the USERNAME, MESSAGE-INTEGRITY, REALM, and\n         * NONCE attributes from the \"First Request\".\n         */\n        if (request.getAttributeCount() > 0)\n        {\n            char[] excludedRequestAttributeTypes\n                = new char[]\n                        {\n                            Attribute.USERNAME,\n                            Attribute.MESSAGE_INTEGRITY,\n                            Attribute.REALM,\n                            Attribute.NONCE\n                        };\n\n            for (char excludedRequestAttributeType\n                    : excludedRequestAttributeTypes)\n            {\n                if (request.containsAttribute(excludedRequestAttributeType))\n                {\n                    challenge = false;\n                    break;\n                }\n            }\n        }\n\n        return\n            (challenge && processChallenge(response, request, transactionID));\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java", "class_name": "StunCandidateHarvest", "class_uri": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nHandles a specific STUN error <tt>Response</tt> with error code\n\"401 Unauthorized\" to a specific STUN <tt>Request</tt>.\n\n@param response the received STUN error <tt>Response</tt> with error code\n\"401 Unauthorized\" which is to be handled\n@param request the STUN <tt>Request</tt> to which <tt>response</tt>\nresponds\n@param transactionID the <tt>TransactionID</tt> of <tt>response</tt> and\n<tt>request</tt> because <tt>response</tt> and <tt>request</tt> only have\nit as a <tt>byte</tt> array and <tt>TransactionID</tt> is required for\nthe <tt>applicationData</tt> property value\n@return <tt>true</tt> if the specified STUN error <tt>response</tt> was\nsuccessfully handled; <tt>false</tt>, otherwise\n@throws StunException if anything goes wrong while handling the specified\n\"401 Unauthorized\" error <tt>response</tt>\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest.[boolean]runInSendKeepAliveMessageThread()", "name": "runInSendKeepAliveMessageThread", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "private boolean runInSendKeepAliveMessageThread()", "original_string": "    private boolean runInSendKeepAliveMessageThread()\n    {\n        synchronized (sendKeepAliveMessageSyncRoot)\n        {\n            // Since we're going to #wait, make sure we're not canceled yet.\n            if (sendKeepAliveMessageThread != Thread.currentThread())\n                return false;\n            if (sendKeepAliveMessageInterval\n                    == SEND_KEEP_ALIVE_MESSAGE_INTERVAL_NOT_SPECIFIED)\n            {\n                return false;\n            }\n\n            // Determine the amount of milliseconds that we'll have to #wait.\n            long timeout;\n\n            if (sendKeepAliveMessageTime == -1)\n            {\n                /*\n                 * If we're just starting, don't just go and send a new STUN\n                 * keep-alive message but rather wait for the whole interval.\n                 */\n                timeout = sendKeepAliveMessageInterval;\n            }\n            else\n            {\n                timeout\n                    = sendKeepAliveMessageTime\n                        + sendKeepAliveMessageInterval\n                        - System.currentTimeMillis();\n            }\n            // At long last, #wait if necessary.\n            if (timeout > 0)\n            {\n                try\n                {\n                    sendKeepAliveMessageSyncRoot.wait(timeout);\n                }\n                catch (InterruptedException iex)\n                {\n                }\n                /*\n                 * Apart from being the time to send the STUN keep-alive\n                 * message, it could be that we've experienced a spurious\n                 * wake-up or that we've been canceled.\n                 */\n                return true;\n            }\n        }\n\n        sendKeepAliveMessageTime = System.currentTimeMillis();\n        try\n        {\n            sendKeepAliveMessage();\n        }\n        catch (StunException sex)\n        {\n            logger.log(\n                    Level.INFO,\n                    \"Failed to send STUN keep-alive message.\",\n                    sex);\n        }\n        return true;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java", "class_name": "StunCandidateHarvest", "class_uri": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nRuns in {@link #sendKeepAliveMessageThread} and sends STUN\nkeep-alive <tt>Message</tt>s to the STUN server associated with the\n<tt>StunCandidateHarvester</tt> of this instance.\n\n@return <tt>true</tt> if the method is to be invoked again; otherwise,\n<tt>false</tt>\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest.[void]sendKeepAliveMessage()", "name": "sendKeepAliveMessage", "arg_nums": 0, "params": [], "return_type": "void", "signature": "protected void sendKeepAliveMessage()", "original_string": "    protected void sendKeepAliveMessage()\n        throws StunException\n    {\n        for (LocalCandidate candidate : getCandidates())\n            if (sendKeepAliveMessage(candidate))\n                break;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java", "class_name": "StunCandidateHarvest", "class_uri": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSends a new STUN <tt>Message</tt> to the STUN server associated with the\n<tt>StunCandidateHarvester</tt> of this instance in order to keep a\n<tt>LocalCandidate</tt> harvested by this instance alive.\n\n@throws StunException if anything goes wrong while sending a new\nkeep-alive STUN <tt>Message</tt>\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest.[boolean]sendKeepAliveMessage(LocalCandidate)", "name": "sendKeepAliveMessage", "arg_nums": 1, "params": [{"name": "candidate", "type": "LocalCandidate"}], "return_type": "boolean", "signature": "protected boolean sendKeepAliveMessage(LocalCandidate candidate)", "original_string": "    protected boolean sendKeepAliveMessage(LocalCandidate candidate)\n        throws StunException\n    {\n        Message keepAliveMessage = createKeepAliveMessage(candidate);\n\n        /*\n         * The #createKeepAliveMessage method javadoc says it returns null when\n         * the STUN keep-alive functionality of this StunCandidateHarvest is to\n         * not be utilized.\n         */\n        if (keepAliveMessage == null)\n        {\n            return false;\n        }\n        else if (keepAliveMessage instanceof Request)\n        {\n            return\n                (sendRequest((Request) keepAliveMessage, false, null) != null);\n        }\n        else\n        {\n            throw new StunException(\n                    StunException.ILLEGAL_ARGUMENT,\n                    \"Failed to create keep-alive STUN message for candidate: \"\n                            + candidate);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java", "class_name": "StunCandidateHarvest", "class_uri": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nSends a new STUN <tt>Message</tt> to the STUN server associated with the\n<tt>StunCandidateHarvester</tt> of this instance in order to keep a\nspecific <tt>LocalCandidate</tt> alive.\n\n@param candidate the <tt>LocalCandidate</tt> to send a new keep-alive\nSTUN <tt>Message</tt> for\n@return <tt>true</tt> if a new STUN <tt>Message</tt> was sent to the\nSTUN server associated with the <tt>StunCandidateHarvester</tt> of this\ninstance or <tt>false</tt> if the STUN kee-alive functionality was not\nbeen used for the specified <tt>candidate</tt>\n@throws StunException if anything goes wrong while sending the new\nkeep-alive STUN <tt>Message</tt> for the specified <tt>candidate</tt>\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest.[TransactionID]sendRequest(Request,boolean,TransactionID)", "name": "sendRequest", "arg_nums": 3, "params": [{"name": "request", "type": "Request"}, {"name": "firstRequest", "type": "boolean"}, {"name": "transactionID", "type": "TransactionID"}], "return_type": "TransactionID", "signature": "protected TransactionID sendRequest(\n            Request request,\n            boolean firstRequest,\n            TransactionID transactionID)", "original_string": "    protected TransactionID sendRequest(\n            Request request,\n            boolean firstRequest,\n            TransactionID transactionID)\n        throws StunException\n    {\n        if (!firstRequest && (longTermCredentialSession != null))\n            longTermCredentialSession.addAttributes(request);\n\n        StunStack stunStack = harvester.getStunStack();\n        TransportAddress stunServer = harvester.stunServer;\n        TransportAddress hostCandidateTransportAddress\n            = hostCandidate.getTransportAddress();\n\n        if (transactionID == null)\n        {\n            byte[] transactionIDAsBytes = request.getTransactionID();\n\n            transactionID\n                = (transactionIDAsBytes == null)\n                    ? TransactionID.createNewTransactionID()\n                    : TransactionID.createTransactionID(\n                            harvester.getStunStack(),\n                            transactionIDAsBytes);\n        }\n        synchronized (requests)\n        {\n            try\n            {\n                transactionID\n                    = stunStack\n                        .sendRequest(\n                            request,\n                            stunServer,\n                            hostCandidateTransportAddress,\n                            this,\n                            transactionID);\n            }\n            catch (IllegalArgumentException iaex)\n            {\n                if (logger.isLoggable(Level.INFO))\n                {\n                    logger.log(\n                            Level.INFO,\n                            \"Failed to send \"\n                                + request\n                                + \" through \" + hostCandidateTransportAddress\n                                + \" to \" + stunServer,\n                            iaex);\n                }\n                throw new StunException(\n                        StunException.ILLEGAL_ARGUMENT,\n                        iaex.getMessage(),\n                        iaex);\n            }\n            catch (IOException ioex)\n            {\n                if (logger.isLoggable(Level.INFO))\n                {\n                    logger.log(\n                            Level.INFO,\n                            \"Failed to send \"\n                                + request\n                                + \" through \" + hostCandidateTransportAddress\n                                + \" to \" + stunServer,\n                            ioex);\n                }\n                throw new StunException(\n                        StunException.NETWORK_ERROR,\n                        ioex.getMessage(),\n                        ioex);\n            }\n\n            requests.put(transactionID, request);\n        }\n        return transactionID;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java", "class_name": "StunCandidateHarvest", "class_uri": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "TransactionID", "classes": []}, "docstring": "\nSends a specific <tt>Request</tt> to the STUN server associated with this\n<tt>StunCandidateHarvest</tt>.\n\n@param request the <tt>Request</tt> to send to the STUN server associated\nwith this <tt>StunCandidateHarvest</tt>\n@param firstRequest <tt>true</tt> if the specified <tt>request</tt>\nshould be sent as the first request in the terms of STUN; otherwise,\n<tt>false</tt>\n@return the <tt>TransactionID</tt> of the STUN client transaction through\nwhich the specified <tt>Request</tt> has been sent to the STUN server\nassociated with this <tt>StunCandidateHarvest</tt>\n@param transactionID the <tt>TransactionID</tt> of <tt>request</tt>\nbecause <tt>request</tt> only has it as a <tt>byte</tt> array and\n<tt>TransactionID</tt> is required for the <tt>applicationData</tt>\nproperty value\n@throws StunException if anything goes wrong while sending the specified\n<tt>Request</tt> to the STUN server associated with this\n<tt>StunCandidateHarvest</tt>\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest.[void]setSendKeepAliveMessageInterval(long)", "name": "setSendKeepAliveMessageInterval", "arg_nums": 1, "params": [{"name": "sendKeepAliveMessageInterval", "type": "long"}], "return_type": "void", "signature": "protected void setSendKeepAliveMessageInterval(\n            long sendKeepAliveMessageInterval)", "original_string": "    protected void setSendKeepAliveMessageInterval(\n            long sendKeepAliveMessageInterval)\n    {\n        if ((sendKeepAliveMessageInterval\n                    != SEND_KEEP_ALIVE_MESSAGE_INTERVAL_NOT_SPECIFIED)\n                && (sendKeepAliveMessageInterval < 1))\n            throw new IllegalArgumentException(\"sendKeepAliveMessageInterval\");\n\n        synchronized (sendKeepAliveMessageSyncRoot)\n        {\n            this.sendKeepAliveMessageInterval = sendKeepAliveMessageInterval;\n            if (sendKeepAliveMessageThread == null)\n            {\n                if (this.sendKeepAliveMessageInterval\n                        != SEND_KEEP_ALIVE_MESSAGE_INTERVAL_NOT_SPECIFIED)\n                    createSendKeepAliveMessageThread();\n            }\n            else\n                sendKeepAliveMessageSyncRoot.notify();\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java", "class_name": "StunCandidateHarvest", "class_uri": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets the interval in milliseconds at which a new STUN keep-alive message\nis to be sent to the STUN server associated with the\n<tt>StunCandidateHarvester</tt> of this instance in order to keep one of\nthe <tt>Candidate</tt>s harvested by this instance alive.\n\n@param sendKeepAliveMessageInterval the interval in milliseconds at which\na new STUN keep-alive message is to be sent to the STUN server associated\nwith the <tt>StunCandidateHarvester</tt> of this instance in order to\nkeep one of the <tt>Candidate</tt>s harvested by this instance alive or\n{@link #SEND_KEEP_ALIVE_MESSAGE_INTERVAL_NOT_SPECIFIED} if the keep-alive\nfunctionality is to not be utilized\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest.[boolean]startResolvingCandidate()", "name": "startResolvingCandidate", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "boolean startResolvingCandidate()", "original_string": "    boolean startResolvingCandidate()\n        throws Exception\n    {\n        Request requestToStartResolvingCandidate;\n\n        if (!completedResolvingCandidate\n                && ((requestToStartResolvingCandidate\n                            = createRequestToStartResolvingCandidate())\n                        != null))\n        {\n            // Short-Term Credential Mechanism\n            addShortTermCredentialAttributes(requestToStartResolvingCandidate);\n\n            sendRequest(requestToStartResolvingCandidate, true, null);\n            return true;\n        }\n        else\n            return false;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java", "class_name": "StunCandidateHarvest", "class_uri": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nStarts the harvesting of <tt>Candidate</tt>s to be performed for\n{@link #hostCandidate}.\n\n@return <tt>true</tt> if this <tt>StunCandidateHarvest</tt> has started\nthe harvesting of <tt>Candidate</tt>s for {@link #hostCandidate};\notherwise, <tt>false</tt>\n@throws Exception if anything goes wrong while starting the harvesting of\n<tt>Candidate</tt>s to be performed for {@link #hostCandidate}\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest.[void]close()", "name": "close", "arg_nums": 0, "params": [], "return_type": "void", "signature": "public void close()", "original_string": "    public void close()\n    {\n        // stop keep alive thread\n        setSendKeepAliveMessageInterval(\n            SEND_KEEP_ALIVE_MESSAGE_INTERVAL_NOT_SPECIFIED);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java", "class_name": "StunCandidateHarvest", "class_uri": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nClose the harvest.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/SinglePortUdpHarvester.java.SinglePortUdpHarvester.[List<SinglePortUdpHarvester>]createHarvesters(int)", "name": "createHarvesters", "arg_nums": 1, "params": [{"name": "port", "type": "int"}], "return_type": "List<SinglePortUdpHarvester>", "signature": "public static List<SinglePortUdpHarvester> createHarvesters(int port)", "original_string": "    public static List<SinglePortUdpHarvester> createHarvesters(int port)\n    {\n        List<SinglePortUdpHarvester> harvesters = new LinkedList<>();\n\n        for (TransportAddress address\n                : AbstractUdpListener.getAllowedAddresses(port))\n        {\n            try\n            {\n                harvesters.add(\n                    new SinglePortUdpHarvester(address));\n            }\n            catch (IOException ioe)\n            {\n                logger.info(\"Failed to create SinglePortUdpHarvester for \"\n                                + \"address \" + address + \": \" + ioe);\n            }\n        }\n\n        return harvesters;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/SinglePortUdpHarvester.java", "class_name": "SinglePortUdpHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/SinglePortUdpHarvester.java.SinglePortUdpHarvester", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "List<SinglePortUdpHarvester>", "classes": []}, "docstring": "\nCreates a new <tt>SinglePortUdpHarvester</tt> instance for each allowed\nIP address found on each allowed network interface, with the given port.\n\n@param port the UDP port number to use.\n@return the list of created <tt>SinglePortUdpHarvester</tt>s.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/SinglePortUdpHarvester.java.SinglePortUdpHarvester.[]SinglePortUdpHarvester(TransportAddress)", "name": "SinglePortUdpHarvester", "arg_nums": 1, "params": [{"name": "localAddress", "type": "TransportAddress"}], "return_type": "", "signature": "public SinglePortUdpHarvester(TransportAddress localAddress)", "original_string": "    public SinglePortUdpHarvester(TransportAddress localAddress)\n        throws IOException\n    {\n        super(localAddress);\n        logger.info(\"Initialized SinglePortUdpHarvester with address \"\n                            + this.localAddress);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/SinglePortUdpHarvester.java", "class_name": "SinglePortUdpHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/SinglePortUdpHarvester.java.SinglePortUdpHarvester", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>SinglePortUdpHarvester</tt> instance which is to\nbind on the specified local address.\n@param localAddress the address to bind to. If the port is 0 an ephemeral port is chosen by the OS and the\n                    SinglePortUdpHarvester.localAddress will reflect the allocated port number.\n@throws IOException if initialization fails.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/SinglePortUdpHarvester.java.SinglePortUdpHarvester.[HarvestStatistics]getHarvestStatistics()", "name": "getHarvestStatistics", "arg_nums": 0, "params": [], "return_type": "HarvestStatistics", "signature": "public HarvestStatistics getHarvestStatistics()", "original_string": "    public HarvestStatistics getHarvestStatistics()\n    {\n        return harvestStatistics;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/SinglePortUdpHarvester.java", "class_name": "SinglePortUdpHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/SinglePortUdpHarvester.java.SinglePortUdpHarvester", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "HarvestStatistics", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/SinglePortUdpHarvester.java.SinglePortUdpHarvester.[MySocket]maybeAcceptNewSession(Buffer,InetSocketAddress,String)", "name": "maybeAcceptNewSession", "arg_nums": 3, "params": [{"name": "buf", "type": "Buffer"}, {"name": "remoteAddress", "type": "InetSocketAddress"}, {"name": "ufrag", "type": "String"}], "return_type": "MySocket", "signature": "protected MySocket maybeAcceptNewSession(Buffer buf,\n                                         InetSocketAddress remoteAddress,\n                                         String ufrag)", "original_string": "    protected MySocket maybeAcceptNewSession(Buffer buf,\n                                         InetSocketAddress remoteAddress,\n                                         String ufrag)\n    {\n        MyCandidate candidate = candidates.get(ufrag);\n        if (candidate == null)\n        {\n            // A STUN Binding Request with an unknown USERNAME. Drop it.\n            return null;\n        }\n\n        // This is a STUN Binding Request destined for this\n        // specific Candidate/Component/Agent.\n        try\n        {\n            // 1. Create a socket for this remote address\n            // 2. Set-up de-multiplexing for future datagrams with this address to this socket.\n            MySocket newSocket = addSocket(\n                    remoteAddress,\n                    ufrag,\n                    candidate.getParentComponent());\n\n            // 3. Let the candidate and its STUN stack no about the\n            // new socket.\n            candidate.addSocket(newSocket, remoteAddress);\n\n            return newSocket;\n        }\n        catch (SocketException se)\n        {\n            logger.info(\"Could not create a socket: \" + se);\n            return null;\n        }\n        catch (IOException ioe)\n        {\n            logger.info(\"Failed to handle new socket: \" + ioe);\n            return null;\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/SinglePortUdpHarvester.java", "class_name": "SinglePortUdpHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/SinglePortUdpHarvester.java.SinglePortUdpHarvester", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "MySocket", "classes": []}, "docstring": "\n{@inheritDoc}\n\nLooks for an ICE candidate registered with this harvester, which has a\nlocal ufrag of {@code ufrag}, and if one is found it accepts the new\nsocket and adds it to the candidate.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/SinglePortUdpHarvester.java.SinglePortUdpHarvester.[Collection<LocalCandidate>]harvest(Component)", "name": "harvest", "arg_nums": 1, "params": [{"name": "component", "type": "Component"}], "return_type": "Collection<LocalCandidate>", "signature": "@Override\n    public Collection<LocalCandidate> harvest(Component component)", "original_string": "    @Override\n    public Collection<LocalCandidate> harvest(Component component)\n    {\n        IceMediaStream stream = component.getParentStream();\n        Agent agent = stream.getParentAgent();\n        String ufrag = agent.getLocalUfrag();\n\n        if (stream.getComponentCount() != 1 || agent.getStreamCount() != 1)\n        {\n            /*\n             * SinglePortUdpHarvester only works with streams with a\n             * single component, and agents with a single stream. This is\n             * because we use the local \"ufrag\" from an incoming STUN packet\n             * to setup de-multiplexing based on remote transport address.\n             */\n            logger.info(\n                    \"More than one Component for an Agent, cannot harvest.\");\n            return new LinkedList<>();\n        }\n\n        MyCandidate candidate = new MyCandidate(component, ufrag);\n\n        candidates.put(ufrag, candidate);\n        component.addLocalCandidate(candidate);\n\n        return new ArrayList<LocalCandidate>(Arrays.asList(candidate));\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/SinglePortUdpHarvester.java", "class_name": "SinglePortUdpHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/SinglePortUdpHarvester.java.SinglePortUdpHarvester", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Collection<LocalCandidate>", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/SinglePortUdpHarvester.java.SinglePortUdpHarvester.[boolean]isHostHarvester()", "name": "isHostHarvester", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "@Override\n    public boolean isHostHarvester()", "original_string": "    @Override\n    public boolean isHostHarvester()\n    {\n        return true;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/SinglePortUdpHarvester.java", "class_name": "SinglePortUdpHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/SinglePortUdpHarvester.java.SinglePortUdpHarvester", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/HostCandidateHarvester.java.HostCandidateHarvester.[List<InetAddress>]getAllAllowedAddresses()", "name": "getAllAllowedAddresses", "arg_nums": 0, "params": [], "return_type": "List<InetAddress>", "signature": "public static List<InetAddress> getAllAllowedAddresses()", "original_string": "    public static List<InetAddress> getAllAllowedAddresses()\n    {\n        List<InetAddress> addresses = new LinkedList<>();\n        for (NetworkInterface iface : getAllowedInterfaces())\n        {\n            Enumeration<InetAddress> ifaceAddresses = iface.getInetAddresses();\n            while (ifaceAddresses.hasMoreElements())\n            {\n                InetAddress address = ifaceAddresses.nextElement();\n                if (isAddressAllowed(address))\n                {\n                    addresses.add(address);\n                }\n            }\n        }\n\n        return addresses;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/HostCandidateHarvester.java", "class_name": "HostCandidateHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/HostCandidateHarvester.java.HostCandidateHarvester", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "List<InetAddress>", "classes": []}, "docstring": "\n@return the list of all local IP addresses from all allowed network\ninterfaces, which are allowed addresses.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/HostCandidateHarvester.java.HostCandidateHarvester.[void]harvest(Component,int,int,int,Transport)", "name": "harvest", "arg_nums": 5, "params": [{"name": "component", "type": "Component"}, {"name": "preferredPort", "type": "int"}, {"name": "minPort", "type": "int"}, {"name": "maxPort", "type": "int"}, {"name": "transport", "type": "Transport"}], "return_type": "void", "signature": "public void harvest(Component component,\n                        int       preferredPort,\n                        int       minPort,\n                        int       maxPort,\n                        Transport transport)", "original_string": "    public void harvest(Component component,\n                        int       preferredPort,\n                        int       minPort,\n                        int       maxPort,\n                        Transport transport)\n        throws IllegalArgumentException,\n               IOException\n    {\n        harvestStatistics.startHarvestTiming();\n\n        if (transport != Transport.UDP && transport != Transport.TCP)\n        {\n            throw new IllegalArgumentException(\"Transport protocol not supported: \" + transport);\n        }\n\n        boolean boundAtLeastOneSocket = false;\n        boolean foundAtLeastOneUsableInterface = false;\n        boolean foundAtLeastOneUsableAddress = false;\n        for (NetworkInterface iface: getAllowedInterfaces())\n        {\n            foundAtLeastOneUsableInterface = true;\n\n            Enumeration<InetAddress> addresses = iface.getInetAddresses();\n\n            while (addresses.hasMoreElements())\n            {\n                InetAddress addr = addresses.nextElement();\n\n                if (!isAddressAllowed(addr))\n                {\n                    continue;\n                }\n\n                foundAtLeastOneUsableAddress = true;\n\n                IceSocketWrapper sock = null;\n                try\n                {\n                    if (transport == Transport.UDP)\n                    {\n                        sock = createDatagramSocket(addr, preferredPort, minPort, maxPort);\n                        boundAtLeastOneSocket = true;\n                    }\n                    else if (transport == Transport.TCP)\n                    {\n                        if (addr instanceof Inet6Address)\n                        {\n                            continue;\n                        }\n                        sock = createServerSocket(\n                                addr,\n                                preferredPort,\n                                minPort,\n                                maxPort,\n                                component);\n                        boundAtLeastOneSocket = true;\n                    }\n                }\n                catch (IOException exc)\n                {\n                    // There seems to be a problem with this particular\n                    // address let's just move on for now and hope we will\n                    // find better\n                    if (logger.isLoggable(Level.WARNING))\n                    {\n                        logger.warning(\n                                \"Failed to create a socket for:\"\n                                        + \"\\naddr:\" + addr\n                                        + \"\\npreferredPort:\" + preferredPort\n                                        + \"\\nminPort:\" + minPort\n                                        + \"\\nmaxPort:\" + maxPort\n                                        + \"\\nprotocol:\" + transport\n                                        + \"\\nContinuing with next address\");\n                    }\n                    continue;\n                }\n\n                HostCandidate candidate = new HostCandidate(sock, component, transport);\n                candidate.setVirtual(iface.isVirtual());\n                component.addLocalCandidate(candidate);\n\n                if (transport == Transport.TCP)\n                {\n                    // have to wait a client connection to add a STUN socket\n                    // to the StunStack\n                    continue;\n                }\n\n                // We are most certainly going to use all local host\n                // candidates for sending and receiving STUN connectivity\n                // checks. In case we have enabled STUN, we are going to use\n                // them as well while harvesting reflexive candidates.\n                createAndRegisterStunSocket(candidate);\n\n                ComponentSocket componentSocket = component.getComponentSocket();\n                if (componentSocket != null)\n                {\n                    componentSocket.add(sock);\n                }\n            }\n        }\n\n        if (!boundAtLeastOneSocket)\n        {\n            throw new IOException(\n                \"Failed to bind even a single host candidate for component:\"\n                            + component\n                            + \" preferredPort=\" + preferredPort\n                            + \" minPort=\" + minPort\n                            + \" maxPort=\" + maxPort\n                            + \" foundAtLeastOneUsableInterface=\"\n                            + foundAtLeastOneUsableInterface\n                            + \" foundAtLeastOneUsableAddress=\"\n                            + foundAtLeastOneUsableAddress);\n        }\n\n        this.harvestStatistics.stopHarvestTiming(component.getLocalCandidateCount());\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/HostCandidateHarvester.java", "class_name": "HostCandidateHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/HostCandidateHarvester.java.HostCandidateHarvester", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nGathers all candidate addresses on the local machine, binds sockets on\nthem and creates {@link HostCandidate}s. The harvester would always\ntry to bind the sockets on the specified <tt>preferredPort</tt> first.\nIf that fails we will move through all ports between <tt>minPort</tt> and\n<tt>maxPort</tt> and give up if still can't find a free port.\n\nIf 0, 0, 0 are specified for preferred, min and max port, an ephemeral port will be used instead.\n\n@param component the {@link Component} that we'd like to gather candidate\naddresses for.\n@param preferredPort the port number that should be tried first when\nbinding local <tt>Candidate</tt> sockets for this <tt>Component</tt>.\n@param minPort the port number where we should first try to bind before\nmoving to the next one (i.e. <tt>minPort + 1</tt>)\n@param maxPort the maximum port number where we should try binding\nbefore giving up and throwing an exception.\n@param transport transport protocol used\n\n@throws IllegalArgumentException if either <tt>minPort</tt> or\n<tt>maxPort</tt> is not a valid port number, <tt>minPort &gt;\nmaxPort</tt> or if transport is not supported.\n@throws IOException if an error occurs while the underlying resolver lib\nis using sockets.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/HostCandidateHarvester.java.HostCandidateHarvester.[boolean]isInterfaceAllowed(NetworkInterface)", "name": "isInterfaceAllowed", "arg_nums": 1, "params": [{"name": "iface", "type": "NetworkInterface"}], "return_type": "boolean", "signature": "public static boolean isInterfaceAllowed(NetworkInterface iface)", "original_string": "    public static boolean isInterfaceAllowed(NetworkInterface iface)\n    {\n        Objects.requireNonNull(iface);\n        try\n        {\n            if (iface.isLoopback() || !iface.isUp())\n            {\n                return false;\n            }\n        }\n        catch (SocketException se)\n        {\n            logger.warning(\"Failed to check state of interface: \" + se);\n            return false;\n        }\n\n        // gp: use getDisplayName() on Windows and getName() on Linux. Also\n        // see NetworkAddressManagementServiceImpl in Jitsi.\n        String ifName = (System.getProperty(\"os.name\") == null\n                || System.getProperty(\"os.name\").startsWith(\"Windows\"))\n                ? iface.getDisplayName()\n                : iface.getName();\n\n        if (!config.getAllowedInterfaces().isEmpty())\n        {\n            // If an allowlist is configured, just check against it.\n            return config.getAllowedInterfaces().contains(ifName);\n        }\n        else\n        {\n            // Otherwise, check against the blocked list.\n            return !config.getBlockedInterfaces().contains(ifName);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/HostCandidateHarvester.java", "class_name": "HostCandidateHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/HostCandidateHarvester.java.HostCandidateHarvester", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nReturns a boolean value indicating whether ice4j should allocate a host candidate for the specified interface.\n<p/>\nReturns <code>false</code> if the interface is loopback, is not currently up, or is not allowed by the\nconfiguration.\n\n@param iface The {@link NetworkInterface}.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/HostCandidateHarvester.java.HostCandidateHarvester.[List<NetworkInterface>]getAllowedInterfaces()", "name": "getAllowedInterfaces", "arg_nums": 0, "params": [], "return_type": "List<NetworkInterface>", "signature": "public static List<NetworkInterface> getAllowedInterfaces()", "original_string": "    public static List<NetworkInterface> getAllowedInterfaces()\n    {\n        try\n        {\n            return NetworkInterface.networkInterfaces()\n                    .filter(HostCandidateHarvester::isInterfaceAllowed).collect(Collectors.toList());\n        }\n        catch (IOException ioe)\n        {\n            logger.warning(\"Failed to get network interfaces: \" + ioe.getMessage());\n            return Collections.emptyList();\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/HostCandidateHarvester.java", "class_name": "HostCandidateHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/HostCandidateHarvester.java.HostCandidateHarvester", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "List<NetworkInterface>", "classes": []}, "docstring": "\nGet the list of network interfaces suitable for host candidate harvesting, that is they are up, non-loopback\nand are allowed by configuration.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/HostCandidateHarvester.java.HostCandidateHarvester.[boolean]isAddressAllowed(InetAddress)", "name": "isAddressAllowed", "arg_nums": 1, "params": [{"name": "address", "type": "InetAddress"}], "return_type": "boolean", "signature": "static boolean isAddressAllowed(InetAddress address)", "original_string": "    static boolean isAddressAllowed(InetAddress address)\n    {\n        if (address.isLoopbackAddress())\n        {\n            return false;\n        }\n        if (!config.useLinkLocalAddresses() && address.isLinkLocalAddress())\n        {\n            return false;\n        }\n        if (!config.useIpv6() && address instanceof Inet6Address)\n        {\n            return false;\n        }\n\n        if (!config.getAllowedAddresses().isEmpty())\n        {\n            return config.getAllowedAddresses().contains(address);\n        }\n        return !config.getBlockedAddresses().contains(address);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/HostCandidateHarvester.java", "class_name": "HostCandidateHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/HostCandidateHarvester.java.HostCandidateHarvester", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nReturns <tt>true</tt> if <tt>address</tt> is allowed to be used for the purposes of candidate allocation, and\n<tt>false</tt> otherwise.\n<p/>\nAn address is considered allowed, if:\n1. It is not a loopback address.\n2. Link-local addresses are allowed or the address is not link-local.\n3. IPv6 addresses are allowed or the address is not IPv6\n4. It is allowed by configuration, that is, it either:\n     -- Is present in the allowlist\n     -- No allowlist is configured and it isn't present in the block list.\n\n@param address the address to check\n@return <tt>true</tt> if <tt>address</tt> is allowed to be used by this <tt>HostCandidateHarvester</tt>.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/HostCandidateHarvester.java.HostCandidateHarvester.[IceSocketWrapper]createServerSocket(InetAddress,int,int,int,Component)", "name": "createServerSocket", "arg_nums": 5, "params": [{"name": "laddr", "type": "InetAddress"}, {"name": "preferredPort", "type": "int"}, {"name": "minPort", "type": "int"}, {"name": "maxPort", "type": "int"}, {"name": "component", "type": "Component"}], "return_type": "IceSocketWrapper", "signature": "private IceSocketWrapper createServerSocket(InetAddress laddr,\n        int preferredPort, int minPort, int maxPort,\n        Component component)", "original_string": "    private IceSocketWrapper createServerSocket(InetAddress laddr,\n        int preferredPort, int minPort, int maxPort,\n        Component component)\n        throws IllegalArgumentException,\n               IOException,\n               BindException\n    {\n        // make sure port numbers are valid\n        boolean ephemeral = checkPorts(preferredPort, minPort, maxPort);\n        if (ephemeral)\n        {\n            ServerSocket socket = new ServerSocket();\n            socket.setReuseAddress(true);\n            socket.bind(new InetSocketAddress(laddr, 0));\n            if (logger.isLoggable(Level.FINEST))\n            {\n                logger.finest(\"Bound using an ephemeral port to \" + socket.getLocalSocketAddress());\n            }\n            return new IceTcpServerSocketWrapper(new DelegatingServerSocket(socket), component);\n        }\n\n        int bindRetries = StackProperties.getInt(\n                        StackProperties.BIND_RETRIES,\n                        StackProperties.BIND_RETRIES_DEFAULT_VALUE);\n\n        int port = preferredPort;\n        for (int i = 0; i < bindRetries; i++)\n        {\n            try\n            {\n                ServerSocket sock = new ServerSocket();\n                sock.setReuseAddress(true);\n                sock.bind(new InetSocketAddress(laddr, port));\n                IceSocketWrapper socket\n                    = new IceTcpServerSocketWrapper(\n                            new DelegatingServerSocket(sock),\n                            component);\n\n                if (logger.isLoggable(Level.FINEST))\n                {\n                    logger.log(\n                            Level.FINEST,\n                            \"just bound to: \" + sock.getLocalSocketAddress());\n                }\n                return socket;\n            }\n            catch (SocketException se)\n            {\n                logger.log(\n                        Level.INFO,\n                        \"Retrying a bind because of a failure to bind to\"\n                            + \" address \" + laddr\n                            + \" and port \" + port\n                            + \" (\" + se.getMessage() +\")\");\n                logger.log(Level.INFO, \"\", se);\n            }\n\n            port ++;\n\n            if (port > maxPort)\n                port = minPort;\n        }\n\n        throw new BindException(\"Could not bind to any port between \" + minPort + \" and \" + (port - 1));\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/HostCandidateHarvester.java", "class_name": "HostCandidateHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/HostCandidateHarvester.java.HostCandidateHarvester", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "IceSocketWrapper", "classes": []}, "docstring": "\nCreates a <tt>ServerSocket</tt> and binds it to the specified\n<tt>localAddress</tt> and a port in the range specified by the\n<tt>minPort</tt> and <tt>maxPort</tt> parameters.\n\nIf 0, 0, 0 are specified for preferred, min and max port, an ephemeral port will be used instead.\n\n@param laddr the address that we'd like to bind the socket on.\n@param preferredPort the port number that we should try to bind to first.\n@param minPort the port number where we should first try to bind before\nmoving to the next one (i.e. <tt>minPort + 1</tt>)\n@param maxPort the maximum port number where we should try binding\nbefore giving up and throwing an exception.\n\n@return the newly created <tt>DatagramSocket</tt>.\n\n@throws IllegalArgumentException if either <tt>minPort</tt> or\n<tt>maxPort</tt> is not a valid port number or if <tt>minPort &gt;\nmaxPort</tt>.\n@throws IOException if an error occurs while the underlying resolver lib\nis using sockets.\n@throws BindException if we couldn't find a free port between\n<tt>minPort</tt> and <tt>maxPort</tt> before reaching the maximum allowed\nnumber of retries.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/HostCandidateHarvester.java.HostCandidateHarvester.[IceSocketWrapper]createDatagramSocket(InetAddress,int,int,int)", "name": "createDatagramSocket", "arg_nums": 4, "params": [{"name": "laddr", "type": "InetAddress"}, {"name": "preferredPort", "type": "int"}, {"name": "minPort", "type": "int"}, {"name": "maxPort", "type": "int"}], "return_type": "IceSocketWrapper", "signature": "private IceSocketWrapper createDatagramSocket(InetAddress laddr,\n                                                int preferredPort,\n                                                int minPort,\n                                                int maxPort)", "original_string": "    private IceSocketWrapper createDatagramSocket(InetAddress laddr,\n                                                int preferredPort,\n                                                int minPort,\n                                                int maxPort)\n        throws IllegalArgumentException,\n               IOException,\n               BindException\n    {\n        // make sure port numbers are valid.\n        boolean ephemeral = checkPorts(preferredPort, minPort, maxPort);\n        if (ephemeral)\n        {\n            DatagramSocket socket = new MultiplexingDatagramSocket(0, laddr);\n            if (logger.isLoggable(Level.FINEST))\n            {\n                logger.finest(\"Bound using ephemeral port to \" + socket.getLocalSocketAddress());\n            }\n            return new IceUdpSocketWrapper(socket);\n        }\n\n        int bindRetries = StackProperties.getInt(\n                        StackProperties.BIND_RETRIES,\n                        StackProperties.BIND_RETRIES_DEFAULT_VALUE);\n\n        int port = preferredPort;\n        for (int i = 0; i < bindRetries; i++)\n        {\n            try\n            {\n                IceSocketWrapper sock\n                                = new IceUdpSocketWrapper(new\n                                    MultiplexingDatagramSocket(port, laddr));\n\n                if (logger.isLoggable(Level.FINEST))\n                {\n                    logger.log(\n                            Level.FINEST,\n                            \"just bound to: \" + sock.getLocalSocketAddress());\n                }\n                return sock;\n            }\n            catch (SocketException se)\n            {\n                logger.log(\n                        Level.INFO,\n                        \"Retrying a bind because of a failure to bind to\"\n                            + \" address \" + laddr\n                            + \" and port \" + port\n                            + \" (\" + se.getMessage() +\")\");\n                logger.log(Level.FINEST, \"\", se);\n            }\n\n            port ++;\n\n            if (port > maxPort)\n                port = minPort;\n        }\n\n        throw new BindException(\"Could not bind to any port between \"\n                        + minPort + \" and \" + (port - 1));\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/HostCandidateHarvester.java", "class_name": "HostCandidateHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/HostCandidateHarvester.java.HostCandidateHarvester", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "IceSocketWrapper", "classes": []}, "docstring": "\nCreates a <tt>DatagramSocket</tt> and binds it to the specified\n<tt>localAddress</tt> and a port in the range specified by the\n<tt>minPort</tt> and <tt>maxPort</tt> parameters. We first try to bind\nthe newly created socket on the <tt>preferredPort</tt> port number\n(unless it is outside the <tt>[minPort, maxPort]</tt> range in which case\nwe first try the <tt>minPort</tt>) and then proceed incrementally upwards\nuntil we succeed or reach the bind retries limit. If we reach the\n<tt>maxPort</tt> port number before the bind retries limit, we will then\nstart over again at <tt>minPort</tt> and keep going until we run out of\nretries.\n\nIf 0, 0, 0 are specified for preferred, min and max port, an ephemeral port will be used instead.\n\n@param laddr the address that we'd like to bind the socket on.\n@param preferredPort the port number that we should try to bind to first.\n@param minPort the port number where we should first try to bind before\nmoving to the next one (i.e. <tt>minPort + 1</tt>)\n@param maxPort the maximum port number where we should try binding\nbefore giving up and throwing an exception.\n\n@return the newly created <tt>DatagramSocket</tt>.\n\n@throws IllegalArgumentException if either <tt>minPort</tt> or\n<tt>maxPort</tt> is not a valid port number or if <tt>minPort &gt;\nmaxPort</tt>.\n@throws IOException if an error occurs while the underlying resolver lib\nis using sockets.\n@throws BindException if we couldn't find a free port between\n<tt>minPort</tt> and <tt>maxPort</tt> before reaching the maximum allowed\nnumber of retries.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/HostCandidateHarvester.java.HostCandidateHarvester.[void]createAndRegisterStunSocket(HostCandidate)", "name": "createAndRegisterStunSocket", "arg_nums": 1, "params": [{"name": "candidate", "type": "HostCandidate"}], "return_type": "void", "signature": "private void createAndRegisterStunSocket(HostCandidate candidate)", "original_string": "    private void createAndRegisterStunSocket(HostCandidate candidate)\n    {\n        IceSocketWrapper stunSocket = candidate.getStunSocket(null);\n\n        candidate.getStunStack().addSocket(stunSocket);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/HostCandidateHarvester.java", "class_name": "HostCandidateHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/HostCandidateHarvester.java.HostCandidateHarvester", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSince we are most certainly going to use all local host candidates for\nsending and receiving STUN connectivity checks, and possibly for STUN\nharvesting too, we might as well create their STUN sockets here and\nregister them with the StunStack. This allows us to avoid conflicts\nbetween the STUN harvester and the connectivity checks later on.\n\n@param candidate the candidate whose stun socket we'd like to initialize\nand register with the StunStack.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/HostCandidateHarvester.java.HostCandidateHarvester.[boolean]checkPorts(int,int,int)", "name": "checkPorts", "arg_nums": 3, "params": [{"name": "preferredPort", "type": "int"}, {"name": "minPort", "type": "int"}, {"name": "maxPort", "type": "int"}], "return_type": "boolean", "signature": "private static boolean checkPorts(int preferredPort, int minPort, int maxPort)", "original_string": "    private static boolean checkPorts(int preferredPort, int minPort, int maxPort)\n        throws IllegalArgumentException\n    {\n        if (preferredPort == 0 && minPort == 0 && maxPort == 0)\n        {\n            return true;\n        }\n\n        // make sure port numbers are valid\n        if (!NetworkUtils.isValidPortNumber(minPort)\n                        || !NetworkUtils.isValidPortNumber(maxPort))\n        {\n            throw new IllegalArgumentException(\"minPort (\" + minPort\n                            + \") and maxPort (\" + maxPort + \") \"\n                            + \"should be integers between 1024 and 65535.\");\n        }\n\n        // make sure minPort comes before maxPort.\n        if (minPort > maxPort)\n        {\n            throw new IllegalArgumentException(\"minPort (\" + minPort\n                            + \") should be less than or \"\n                            + \"equal to maxPort (\" + maxPort + \")\");\n        }\n\n        // if preferredPort is not  in the allowed range, place it at min.\n        if (minPort > preferredPort || preferredPort > maxPort)\n        {\n            throw new IllegalArgumentException(\"preferredPort (\"+preferredPort\n                            +\") must be between minPort (\" + minPort\n                            + \") and maxPort (\" + maxPort + \")\");\n        }\n\n        return false;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/HostCandidateHarvester.java", "class_name": "HostCandidateHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/HostCandidateHarvester.java.HostCandidateHarvester", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nChecks if the different ports are correctly set. If not, throws {@link IllegalArgumentException}. The\nspecial values 0, 0, 0 for the parameters are interpreted as \"use an ephemeral port\".\n\n@return {@code true} if the params specify that an ephemeral port should be used, and {@code false} otherwise.\n\n@param preferredPort the port number that we should try to bind to first.\n@param minPort the port number where we should first try to bind before\nmoving to the next one (i.e. <tt>minPort + 1</tt>)\n@param maxPort the maximum port number where we should try binding\nbefore giving up and throwing an exception.\n\n@throws IllegalArgumentException if either <tt>minPort</tt> or\n<tt>maxPort</tt> is not a valid port number or if <tt>minPort</tt> is\ngreater than <tt>maxPort</tt>.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/HostCandidateHarvester.java.HostCandidateHarvester.[HarvestStatistics]getHarvestStatistics()", "name": "getHarvestStatistics", "arg_nums": 0, "params": [], "return_type": "HarvestStatistics", "signature": "public HarvestStatistics getHarvestStatistics()", "original_string": "    public HarvestStatistics getHarvestStatistics()\n    {\n        return harvestStatistics;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/HostCandidateHarvester.java", "class_name": "HostCandidateHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/HostCandidateHarvester.java.HostCandidateHarvester", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "HarvestStatistics", "classes": []}, "docstring": "\nReturns the statistics describing how well the various harvests of this\nharvester went.\n\n@return The {@link HarvestStatistics} describing this harvester's\nharvests.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/TurnCandidateHarvest.java.TurnCandidateHarvest.[]TurnCandidateHarvest(TurnCandidateHarvester,HostCandidate)", "name": "TurnCandidateHarvest", "arg_nums": 2, "params": [{"name": "harvester", "type": "TurnCandidateHarvester"}, {"name": "hostCandidate", "type": "HostCandidate"}], "return_type": "", "signature": "public TurnCandidateHarvest(\n            TurnCandidateHarvester harvester,\n            HostCandidate hostCandidate)", "original_string": "    public TurnCandidateHarvest(\n            TurnCandidateHarvester harvester,\n            HostCandidate hostCandidate)\n    {\n        super(harvester, hostCandidate);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/TurnCandidateHarvest.java", "class_name": "TurnCandidateHarvest", "class_uri": "src/main/java/org/ice4j/ice/harvest/TurnCandidateHarvest.java.TurnCandidateHarvest", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>TurnCandidateHarvest</tt> which is to represent the\nharvesting of TURN <tt>Candidate</tt>s for a specific\n<tt>HostCandidate</tt> performed by a specific\n<tt>TurnCandidateHarvester</tt>.\n\n@param harvester the <tt>TurnCandidateHarvester</tt> which is performing\nthe TURN harvesting\n@param hostCandidate the <tt>HostCandidate</tt> for which TURN\n<tt>Candidate</tt>s are to be harvested\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/TurnCandidateHarvest.java.TurnCandidateHarvest.[void]close(RelayedCandidateDatagramSocket)", "name": "close", "arg_nums": 1, "params": [{"name": "relayedCandidateSocket", "type": "RelayedCandidateDatagramSocket"}], "return_type": "void", "signature": "public void close(RelayedCandidateDatagramSocket relayedCandidateSocket)", "original_string": "    public void close(RelayedCandidateDatagramSocket relayedCandidateSocket)\n    {\n        /*\n         * FIXME As far as logic goes, it seems that it is possible to send a\n         * TURN Refresh, cancel the STUN keep-alive functionality here and only\n         * then receive the response to the TURN Refresh which will enable the\n         * STUN keep-alive functionality again.\n         */\n        setSendKeepAliveMessageInterval(\n                SEND_KEEP_ALIVE_MESSAGE_INTERVAL_NOT_SPECIFIED);\n\n        /*\n         * TURN Refresh with a LIFETIME value equal to zero deletes the TURN\n         * Allocation.\n         */\n        try\n        {\n            sendRequest(MessageFactory.createRefreshRequest(0), false, null);\n        }\n        catch (StunException sex)\n        {\n            logger.log(\n                    Level.INFO,\n                    \"Failed to send TURN Refresh request to delete Allocation\",\n                    sex);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/TurnCandidateHarvest.java", "class_name": "TurnCandidateHarvest", "class_uri": "src/main/java/org/ice4j/ice/harvest/TurnCandidateHarvest.java.TurnCandidateHarvest", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nNotifies this <tt>TurnCandidateHarvest</tt> that a specific\n<tt>RelayedCandidateDatagramSocket</tt> is closing and that this instance\nis to delete the associated TURN Allocation.\n<p>\n<b>Note</b>: The method is part of the internal API of\n<tt>RelayedCandidateDatagramSocket</tt> and <tt>TurnCandidateHarvest</tt>\nand is not intended for public use.\n</p>\n\n@param relayedCandidateSocket the <tt>RelayedCandidateDatagramSocket</tt>\nwhich notifies this instance and which requests that the associated TURN\nAllocation be deleted\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/TurnCandidateHarvest.java.TurnCandidateHarvest.[boolean]completedResolvingCandidate(Request,Response)", "name": "completedResolvingCandidate", "arg_nums": 2, "params": [{"name": "request", "type": "Request"}, {"name": "response", "type": "Response"}], "return_type": "boolean", "signature": "@Override\n    protected boolean completedResolvingCandidate(\n            Request request,\n            Response response)", "original_string": "    @Override\n    protected boolean completedResolvingCandidate(\n            Request request,\n            Response response)\n    {\n        /*\n         * TODO If the Allocate request is rejected because the server lacks\n         * resources to fulfill it, the agent SHOULD instead send a Binding\n         * request to obtain a server reflexive candidate.\n         */\n        if ((response == null)\n                || (!response.isSuccessResponse()\n                        && (request.getMessageType()\n                                == Message.ALLOCATE_REQUEST)))\n        {\n            try\n            {\n                if (startResolvingCandidate())\n                    return false;\n            }\n            catch (Exception ex)\n            {\n                /*\n                 * Complete the harvesting of Candidates for hostCandidate\n                 * because the new attempt has just failed.\n                 */\n            }\n        }\n        return super.completedResolvingCandidate(request, response);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/TurnCandidateHarvest.java", "class_name": "TurnCandidateHarvest", "class_uri": "src/main/java/org/ice4j/ice/harvest/TurnCandidateHarvest.java.TurnCandidateHarvest", "attributes": {"modifiers": "@Override\n    protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nCompletes the harvesting of <tt>Candidate</tt>s for\n{@link #hostCandidate}. Notifies {@link #harvester} about the completion\nof the harvesting of <tt>Candidate</tt> for <tt>hostCandidate</tt>\nperformed by this <tt>StunCandidateHarvest</tt>.\n\n@param request the <tt>Request</tt> sent by this\n<tt>StunCandidateHarvest</tt> with which the harvesting of\n<tt>Candidate</tt>s for <tt>hostCandidate</tt> has completed\n@param response the <tt>Response</tt> received by this\n<tt>StunCandidateHarvest</tt>, if any, with which the harvesting of\n<tt>Candidate</tt>s for <tt>hostCandidate</tt> has completed\n@return <tt>true</tt> if the harvesting of <tt>Candidate</tt>s for\n<tt>hostCandidate</tt> performed by this <tt>StunCandidateHarvest</tt>\nhas completed; otherwise, <tt>false</tt>\n@see StunCandidateHarvest#completedResolvingCandidate(Request, Response)\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/TurnCandidateHarvest.java.TurnCandidateHarvest.[void]createCandidates(Response)", "name": "createCandidates", "arg_nums": 1, "params": [{"name": "response", "type": "Response"}], "return_type": "void", "signature": "@Override\n    protected void createCandidates(Response response)", "original_string": "    @Override\n    protected void createCandidates(Response response)\n    {\n        createRelayedCandidate(response);\n\n        // Let the super create the ServerReflexiveCandidate.\n        super.createCandidates(response);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/TurnCandidateHarvest.java", "class_name": "TurnCandidateHarvest", "class_uri": "src/main/java/org/ice4j/ice/harvest/TurnCandidateHarvest.java.TurnCandidateHarvest", "attributes": {"modifiers": "@Override\n    protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCreates new <tt>Candidate</tt>s determined by a specific STUN\n<tt>Response</tt>.\n\n@param response the received STUN <tt>Response</tt>\n@see StunCandidateHarvest#createCandidates(Response)\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/TurnCandidateHarvest.java.TurnCandidateHarvest.[Message]createKeepAliveMessage(LocalCandidate)", "name": "createKeepAliveMessage", "arg_nums": 1, "params": [{"name": "candidate", "type": "LocalCandidate"}], "return_type": "Message", "signature": "@Override\n    protected Message createKeepAliveMessage(LocalCandidate candidate)", "original_string": "    @Override\n    protected Message createKeepAliveMessage(LocalCandidate candidate)\n        throws StunException\n    {\n        switch (candidate.getType())\n        {\n        case RELAYED_CANDIDATE:\n            return MessageFactory.createRefreshRequest();\n        case SERVER_REFLEXIVE_CANDIDATE:\n            /*\n             * RFC 5245: The Refresh requests will also refresh the server\n             * reflexive candidate.\n             */\n            boolean existsRelayedCandidate = false;\n\n            for (Candidate<?> aCandidate : getCandidates())\n            {\n                if (CandidateType.RELAYED_CANDIDATE.equals(\n                        aCandidate.getType()))\n                {\n                    existsRelayedCandidate = true;\n                    break;\n                }\n            }\n            return\n                existsRelayedCandidate\n                    ? null\n                    : super.createKeepAliveMessage(candidate);\n        default:\n            return super.createKeepAliveMessage(candidate);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/TurnCandidateHarvest.java", "class_name": "TurnCandidateHarvest", "class_uri": "src/main/java/org/ice4j/ice/harvest/TurnCandidateHarvest.java.TurnCandidateHarvest", "attributes": {"modifiers": "@Override\n    protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Message", "classes": []}, "docstring": "\nCreates a new STUN <tt>Message</tt> to be sent to the STUN server\nassociated with the <tt>StunCandidateHarvester</tt> of this instance in\norder to keep a specific <tt>LocalCandidate</tt> (harvested by this\ninstance) alive.\n\n@param candidate the <tt>LocalCandidate</tt> (harvested by this instance)\nto create a new keep-alive STUN message for\n@return a new keep-alive STUN <tt>Message</tt> for the specified\n<tt>candidate</tt> or <tt>null</tt> if no keep-alive sending is to occur\n@throws StunException if anything goes wrong while creating the new\nkeep-alive STUN <tt>Message</tt> for the specified <tt>candidate</tt>\nor the candidate is of an unsupported <tt>CandidateType</tt>\n@see StunCandidateHarvest#createKeepAliveMessage(LocalCandidate)\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/TurnCandidateHarvest.java.TurnCandidateHarvest.[void]createRelayedCandidate(Response)", "name": "createRelayedCandidate", "arg_nums": 1, "params": [{"name": "response", "type": "Response"}], "return_type": "void", "signature": "private void createRelayedCandidate(Response response)", "original_string": "    private void createRelayedCandidate(Response response)\n    {\n        Attribute attribute\n            = response.getAttribute(Attribute.XOR_RELAYED_ADDRESS);\n\n        if (attribute instanceof XorRelayedAddressAttribute)\n        {\n            TransportAddress relayedAddress\n                = ((XorRelayedAddressAttribute) attribute).getAddress(\n                        response.getTransactionID());\n            RelayedCandidate relayedCandidate\n                = createRelayedCandidate(\n                        relayedAddress,\n                        getMappedAddress(response));\n\n            if (relayedCandidate != null)\n            {\n                /*\n                 * The ICE connectivity checks will utilize STUN on the\n                 * (application-purposed) socket of the RelayedCandidate and\n                 * will not add it to the StunStack so we have to do it.\n                 */\n                harvester.getStunStack().addSocket(\n                        relayedCandidate.getStunSocket(null));\n\n                ComponentSocket componentSocket\n                    = relayedCandidate.getParentComponent().getComponentSocket();\n                if (componentSocket != null)\n                {\n                    componentSocket.add(\n                        relayedCandidate.getCandidateIceSocketWrapper());\n                }\n                addCandidate(relayedCandidate);\n            }\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/TurnCandidateHarvest.java", "class_name": "TurnCandidateHarvest", "class_uri": "src/main/java/org/ice4j/ice/harvest/TurnCandidateHarvest.java.TurnCandidateHarvest", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCreates a <tt>RelayedCandidate</tt> using the\n<tt>XOR-RELAYED-ADDRESS</tt> attribute in a specific STUN\n<tt>Response</tt> for the actual <tt>TransportAddress</tt> of the new\ncandidate. If the message is malformed and/or does not contain the\ncorresponding attribute, this method simply has no effect.\n\n@param response the STUN <tt>Response</tt> which is supposed to contain\nthe address we should use for the new candidate\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/TurnCandidateHarvest.java.TurnCandidateHarvest.[RelayedCandidate]createRelayedCandidate(TransportAddress,TransportAddress)", "name": "createRelayedCandidate", "arg_nums": 2, "params": [{"name": "transportAddress", "type": "TransportAddress"}, {"name": "mappedAddress", "type": "TransportAddress"}], "return_type": "RelayedCandidate", "signature": "protected RelayedCandidate createRelayedCandidate(\n            TransportAddress transportAddress,\n            TransportAddress mappedAddress)", "original_string": "    protected RelayedCandidate createRelayedCandidate(\n            TransportAddress transportAddress,\n            TransportAddress mappedAddress)\n    {\n        return\n            new RelayedCandidate(\n                    transportAddress,\n                    this,\n                    mappedAddress);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/TurnCandidateHarvest.java", "class_name": "TurnCandidateHarvest", "class_uri": "src/main/java/org/ice4j/ice/harvest/TurnCandidateHarvest.java.TurnCandidateHarvest", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "RelayedCandidate", "classes": []}, "docstring": "\nCreates a new <tt>RelayedCandidate</tt> instance which is to represent a\nspecific <tt>TransportAddress</tt> harvested through\n{@link #hostCandidate} and the TURN server associated with\n{@link #harvester}.\n\n@param transportAddress the <tt>TransportAddress</tt> to be represented\nby the new <tt>RelayedCandidate</tt> instance\n@param mappedAddress the mapped <tt>TransportAddress</tt> reported by the\nTURN server with the delivery of the relayed <tt>transportAddress</tt> to\nbe represented by the new <tt>RelayedCandidate</tt> instance\n@return a new <tt>RelayedCandidate</tt> instance which represents the\nspecified <tt>TransportAddress</tt> harvested through\n{@link #hostCandidate} and the TURN server associated with\n{@link #harvester}\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/TurnCandidateHarvest.java.TurnCandidateHarvest.[Request]createRequestToRetry(Request)", "name": "createRequestToRetry", "arg_nums": 1, "params": [{"name": "request", "type": "Request"}], "return_type": "Request", "signature": "@Override\n    protected Request createRequestToRetry(Request request)", "original_string": "    @Override\n    protected Request createRequestToRetry(Request request)\n    {\n        switch (request.getMessageType())\n        {\n        case Message.ALLOCATE_REQUEST:\n        {\n            RequestedTransportAttribute requestedTransportAttribute\n                = (RequestedTransportAttribute)\n                    request.getAttribute(Attribute.REQUESTED_TRANSPORT);\n            int requestedTransport\n                = (requestedTransportAttribute == null)\n                    ? 17 /* User Datagram Protocol */\n                    : requestedTransportAttribute.getRequestedTransport();\n            EvenPortAttribute evenPortAttribute\n                = (EvenPortAttribute) request.getAttribute(Attribute.EVEN_PORT);\n            boolean rFlag\n                = (evenPortAttribute != null) && evenPortAttribute.isRFlag();\n\n            return\n                MessageFactory.createAllocateRequest(\n                        (byte) requestedTransport,\n                        rFlag);\n        }\n\n        case Message.CHANNELBIND_REQUEST:\n        {\n            ChannelNumberAttribute channelNumberAttribute\n                = (ChannelNumberAttribute)\n                    request.getAttribute(Attribute.CHANNEL_NUMBER);\n            char channelNumber = channelNumberAttribute.getChannelNumber();\n            XorPeerAddressAttribute peerAddressAttribute\n                = (XorPeerAddressAttribute)\n                    request.getAttribute(Attribute.XOR_PEER_ADDRESS);\n            TransportAddress peerAddress\n                = peerAddressAttribute.getAddress(request.getTransactionID());\n            byte[] retryTransactionID\n                = TransactionID.createNewTransactionID().getBytes();\n            Request retryChannelBindRequest\n                = MessageFactory.createChannelBindRequest(\n                        channelNumber,\n                        peerAddress,\n                        retryTransactionID);\n\n            try\n            {\n                retryChannelBindRequest.setTransactionID(retryTransactionID);\n            }\n            catch (StunException sex)\n            {\n                throw new UndeclaredThrowableException(sex);\n            }\n            return retryChannelBindRequest;\n        }\n\n        case Message.CREATEPERMISSION_REQUEST:\n        {\n            XorPeerAddressAttribute peerAddressAttribute\n                = (XorPeerAddressAttribute)\n                    request.getAttribute(Attribute.XOR_PEER_ADDRESS);\n            TransportAddress peerAddress\n                = peerAddressAttribute.getAddress(request.getTransactionID());\n            byte[] retryTransactionID\n                = TransactionID.createNewTransactionID().getBytes();\n            Request retryCreatePermissionRequest\n                = MessageFactory.createCreatePermissionRequest(\n                        peerAddress,\n                        retryTransactionID);\n\n            try\n            {\n                retryCreatePermissionRequest.setTransactionID(\n                        retryTransactionID);\n            }\n            catch (StunException sex)\n            {\n                throw new UndeclaredThrowableException(sex);\n            }\n            return retryCreatePermissionRequest;\n        }\n\n        case Message.REFRESH_REQUEST:\n        {\n            LifetimeAttribute lifetimeAttribute\n                = (LifetimeAttribute) request.getAttribute(Attribute.LIFETIME);\n\n            if (lifetimeAttribute == null)\n                return MessageFactory.createRefreshRequest();\n            else\n            {\n                return\n                    MessageFactory.createRefreshRequest(\n                            lifetimeAttribute.getLifetime());\n            }\n        }\n\n        default:\n            return super.createRequestToRetry(request);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/TurnCandidateHarvest.java", "class_name": "TurnCandidateHarvest", "class_uri": "src/main/java/org/ice4j/ice/harvest/TurnCandidateHarvest.java.TurnCandidateHarvest", "attributes": {"modifiers": "@Override\n    protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Request", "classes": []}, "docstring": "\nCreates a new <tt>Request</tt> instance which is to be sent by this\n<tt>StunCandidateHarvest</tt> in order to retry a specific\n<tt>Request</tt>. For example, the long-term credential mechanism\ndictates that a <tt>Request</tt> is first sent by the client without any\ncredential-related attributes, then it gets challenged by the server and\nthe client retries the original <tt>Request</tt> with the appropriate\ncredential-related attributes in response.\n\n@param request the <tt>Request</tt> which is to be retried by this\n<tt>StunCandidateHarvest</tt>\n@return the new <tt>Request</tt> instance which is to be sent by this\n<tt>StunCandidateHarvest</tt> in order to retry the specified\n<tt>request</tt>\n@see StunCandidateHarvest#createRequestToRetry(Request)\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/TurnCandidateHarvest.java.TurnCandidateHarvest.[Request]createRequestToStartResolvingCandidate()", "name": "createRequestToStartResolvingCandidate", "arg_nums": 0, "params": [], "return_type": "Request", "signature": "@Override\n    protected Request createRequestToStartResolvingCandidate()", "original_string": "    @Override\n    protected Request createRequestToStartResolvingCandidate()\n    {\n        if (requestToStartResolvingCandidate == null)\n        {\n            requestToStartResolvingCandidate\n                = MessageFactory.createAllocateRequest(\n                        (byte) 17 /* User Datagram Protocol */,\n                        false);\n            return requestToStartResolvingCandidate;\n        }\n        else if (requestToStartResolvingCandidate.getMessageType()\n                == Message.ALLOCATE_REQUEST)\n        {\n            requestToStartResolvingCandidate\n                = super.createRequestToStartResolvingCandidate();\n            return requestToStartResolvingCandidate;\n        }\n        else\n            return null;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/TurnCandidateHarvest.java", "class_name": "TurnCandidateHarvest", "class_uri": "src/main/java/org/ice4j/ice/harvest/TurnCandidateHarvest.java.TurnCandidateHarvest", "attributes": {"modifiers": "@Override\n    protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Request", "classes": []}, "docstring": "\nCreates a new <tt>Request</tt> which is to be sent to\n{@link TurnCandidateHarvester#stunServer} in order to start resolving\n{@link #hostCandidate}.\n\n@return a new <tt>Request</tt> which is to be sent to\n{@link TurnCandidateHarvester#stunServer} in order to start resolving\n{@link #hostCandidate}\n@see StunCandidateHarvest#createRequestToStartResolvingCandidate()\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/TurnCandidateHarvest.java.TurnCandidateHarvest.[boolean]processErrorOrFailure(Response,Request,TransactionID)", "name": "processErrorOrFailure", "arg_nums": 3, "params": [{"name": "response", "type": "Response"}, {"name": "request", "type": "Request"}, {"name": "transactionID", "type": "TransactionID"}], "return_type": "boolean", "signature": "@Override\n    protected boolean processErrorOrFailure(\n            Response response,\n            Request request,\n            TransactionID transactionID)", "original_string": "    @Override\n    protected boolean processErrorOrFailure(\n            Response response,\n            Request request,\n            TransactionID transactionID)\n    {\n\n        /*\n         * TurnCandidateHarvest uses the applicationData of TransactionID to\n         * deliver the results of Requests sent by\n         * RelayedCandidateDatagramSocket back to it.\n         */\n        Object applicationData = transactionID.getApplicationData();\n\n        if ((applicationData instanceof RelayedCandidateDatagramSocket)\n                && ((RelayedCandidateDatagramSocket) applicationData)\n                        .processErrorOrFailure(response, request))\n            return true;\n\n        return super.processErrorOrFailure(response, request, transactionID);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/TurnCandidateHarvest.java", "class_name": "TurnCandidateHarvest", "class_uri": "src/main/java/org/ice4j/ice/harvest/TurnCandidateHarvest.java.TurnCandidateHarvest", "attributes": {"modifiers": "@Override\n    protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nNotifies this <tt>StunCandidateHarvest</tt> that a specific\n<tt>Request</tt> has either received an error <tt>Response</tt> or has\nfailed to receive any <tt>Response</tt>.\n\n@param response the error <tt>Response</tt> which has been received for\n<tt>request</tt>\n@param request the <tt>Request</tt> to which <tt>Response</tt> responds\n@param transactionID the <tt>TransactionID</tt> of <tt>response</tt> and\n<tt>request</tt> because <tt>response</tt> and <tt>request</tt> only have\nit as a <tt>byte</tt> array and <tt>TransactionID</tt> is required for\nthe <tt>applicationData</tt> property value\n@return <tt>true</tt> if the error or failure condition has been\nprocessed and this instance can continue its execution (e.g. the\nresolution of the candidate) as if it was expected; otherwise,\n<tt>false</tt>\n@see StunCandidateHarvest#processErrorOrFailure(Response, Request,\nTransactionID)\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/TurnCandidateHarvest.java.TurnCandidateHarvest.[void]processSuccess(Response,Request,TransactionID)", "name": "processSuccess", "arg_nums": 3, "params": [{"name": "response", "type": "Response"}, {"name": "request", "type": "Request"}, {"name": "transactionID", "type": "TransactionID"}], "return_type": "void", "signature": "@Override\n    protected void processSuccess(\n            Response response,\n            Request request,\n            TransactionID transactionID)", "original_string": "    @Override\n    protected void processSuccess(\n            Response response,\n            Request request,\n            TransactionID transactionID)\n    {\n        super.processSuccess(response, request, transactionID);\n\n        LifetimeAttribute lifetimeAttribute;\n        int lifetime /* minutes */ = -1;\n\n        switch (response.getMessageType())\n        {\n        case Message.ALLOCATE_RESPONSE:\n            // The default lifetime of an allocation is 10 minutes.\n            lifetimeAttribute\n                = (LifetimeAttribute) response.getAttribute(Attribute.LIFETIME);\n            lifetime\n                = (lifetimeAttribute == null)\n                    ? (10 * 60)\n                    : lifetimeAttribute.getLifetime();\n            break;\n        case Message.REFRESH_RESPONSE:\n            lifetimeAttribute\n                = (LifetimeAttribute) response.getAttribute(Attribute.LIFETIME);\n            if (lifetimeAttribute != null)\n                lifetime = lifetimeAttribute.getLifetime();\n            break;\n        }\n        if (lifetime >= 0)\n        {\n            setSendKeepAliveMessageInterval(\n                    /* milliseconds */ 1000L * lifetime);\n        }\n\n        /*\n         * TurnCandidateHarvest uses the applicationData of TransactionID to\n         * deliver the results of Requests sent by\n         * RelayedCandidateDatagramSocket back to it.\n         */\n        Object applicationData = transactionID.getApplicationData();\n\n        if (applicationData instanceof RelayedCandidateDatagramSocket)\n        {\n            ((RelayedCandidateDatagramSocket) applicationData)\n                .processSuccess(response, request);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/TurnCandidateHarvest.java", "class_name": "TurnCandidateHarvest", "class_uri": "src/main/java/org/ice4j/ice/harvest/TurnCandidateHarvest.java.TurnCandidateHarvest", "attributes": {"modifiers": "@Override\n    protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nHandles a specific STUN success <tt>Response</tt> to a specific STUN\n<tt>Request</tt>.\n\n@param response the received STUN success <tt>Response</tt> which is to\nbe handled\n@param request the STUN <tt>Request</tt> to which <tt>response</tt>\nresponds\n@param transactionID the <tt>TransactionID</tt> of <tt>response</tt> and\n<tt>request</tt> because <tt>response</tt> and <tt>request</tt> only have\nit as a <tt>byte</tt> array and <tt>TransactionID</tt> is required for\nthe <tt>applicationData</tt> property value\n@see StunCandidateHarvest#processSuccess(Response, Request,\nTransactionID)\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/TurnCandidateHarvest.java.TurnCandidateHarvest.[byte[]]sendRequest(RelayedCandidateDatagramSocket,Request)", "name": "sendRequest", "arg_nums": 2, "params": [{"name": "relayedCandidateDatagramSocket", "type": "RelayedCandidateDatagramSocket"}, {"name": "request", "type": "Request"}], "return_type": "byte[]", "signature": "public byte[] sendRequest(\n            RelayedCandidateDatagramSocket relayedCandidateDatagramSocket,\n            Request request)", "original_string": "    public byte[] sendRequest(\n            RelayedCandidateDatagramSocket relayedCandidateDatagramSocket,\n            Request request)\n        throws StunException\n    {\n        TransactionID transactionID = TransactionID.createNewTransactionID();\n\n        transactionID.setApplicationData(relayedCandidateDatagramSocket);\n        transactionID = sendRequest(request, false, transactionID);\n        return (transactionID == null) ? null : transactionID.getBytes();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/TurnCandidateHarvest.java", "class_name": "TurnCandidateHarvest", "class_uri": "src/main/java/org/ice4j/ice/harvest/TurnCandidateHarvest.java.TurnCandidateHarvest", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "byte[]", "classes": []}, "docstring": "\nSends a specific <tt>Request</tt> on behalf of a specific\n<tt>RelayedCandidateDatagramSocket</tt> to the TURN server associated\nwith this <tt>TurnCandidateHarvest</tt>.\n\n@param relayedCandidateDatagramSocket the\n<tt>RelayedCandidateDatagramSocket</tt> which sends the specified\n<tt>Request</tt> and which is to be notified of the result\n@param request the <tt>Request</tt> to be sent to the TURN server\nassociated with this <tt>TurnCandidateHarvest</tt>\n@return an array of <tt>byte</tt>s which represents the ID of the\ntransaction with which the specified <tt>Request</tt> has been sent to\nthe TURN server\n@throws StunException if anything goes wrong while sending the specified\n<tt>Request</tt>\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/GoogleTurnSSLCandidateHarvester.java.GoogleTurnSSLCandidateHarvester.[]GoogleTurnSSLCandidateHarvester(TransportAddress)", "name": "GoogleTurnSSLCandidateHarvester", "arg_nums": 1, "params": [{"name": "turnServer", "type": "TransportAddress"}], "return_type": "", "signature": "public GoogleTurnSSLCandidateHarvester(TransportAddress turnServer)", "original_string": "    public GoogleTurnSSLCandidateHarvester(TransportAddress turnServer)\n    {\n        this(turnServer, null, null);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/GoogleTurnSSLCandidateHarvester.java", "class_name": "GoogleTurnSSLCandidateHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/GoogleTurnSSLCandidateHarvester.java.GoogleTurnSSLCandidateHarvester", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>GoogleTurnSSLCandidateHarvester</tt> instance which\nis to work with a specific Google TURN server.\n\n@param turnServer the <tt>TransportAddress</tt> of the TURN server the\nnew instance is to work with\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/GoogleTurnSSLCandidateHarvester.java.GoogleTurnSSLCandidateHarvester.[]GoogleTurnSSLCandidateHarvester(TransportAddress,String,String)", "name": "GoogleTurnSSLCandidateHarvester", "arg_nums": 3, "params": [{"name": "turnServer", "type": "TransportAddress"}, {"name": "shortTermCredentialUsername", "type": "String"}, {"name": "password", "type": "String"}], "return_type": "", "signature": "public GoogleTurnSSLCandidateHarvester(TransportAddress turnServer,\n            String shortTermCredentialUsername,\n            String password)", "original_string": "    public GoogleTurnSSLCandidateHarvester(TransportAddress turnServer,\n            String shortTermCredentialUsername,\n            String password)\n    {\n        super(turnServer, shortTermCredentialUsername, password);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/GoogleTurnSSLCandidateHarvester.java", "class_name": "GoogleTurnSSLCandidateHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/GoogleTurnSSLCandidateHarvester.java.GoogleTurnSSLCandidateHarvester", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>GoogleTurnSSLCandidateHarvester</tt> instance which is\nto work with a specific TURN server using a specific username for the\npurposes of the STUN short-term credential mechanism.\n\n@param turnServer the <tt>TransportAddress</tt> of the TURN server the\nnew instance is to work with\n@param shortTermCredentialUsername the username to be used by the new\ninstance for the purposes of the STUN short-term credential mechanism or\n<tt>null</tt> if the use of the STUN short-term credential mechanism is\nnot determined at the time of the construction of the new instance\n@param password The gingle candidates password necessary to use this TURN\nserver.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/GoogleTurnSSLCandidateHarvester.java.GoogleTurnSSLCandidateHarvester.[GoogleTurnCandidateHarvest]createHarvest(HostCandidate)", "name": "createHarvest", "arg_nums": 1, "params": [{"name": "hostCandidate", "type": "HostCandidate"}], "return_type": "GoogleTurnCandidateHarvest", "signature": "@Override\n    protected GoogleTurnCandidateHarvest createHarvest(\n            HostCandidate hostCandidate)", "original_string": "    @Override\n    protected GoogleTurnCandidateHarvest createHarvest(\n            HostCandidate hostCandidate)\n    {\n        return\n            new GoogleTurnCandidateHarvest(this, hostCandidate, getPassword());\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/GoogleTurnSSLCandidateHarvester.java", "class_name": "GoogleTurnSSLCandidateHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/GoogleTurnSSLCandidateHarvester.java.GoogleTurnSSLCandidateHarvester", "attributes": {"modifiers": "@Override\n    protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "GoogleTurnCandidateHarvest", "classes": []}, "docstring": "\nCreates a new <tt>GoogleTurnSSLCandidateHarvest</tt> instance which is to\nperform TURN harvesting of a specific <tt>HostCandidate</tt>.\n\n@param hostCandidate the <tt>HostCandidate</tt> for which harvesting is\nto be performed by the new <tt>TurnCandidateHarvest</tt> instance\n@return a new <tt>GoogleTurnSSLCandidateHarvest</tt> instance which is to\nperform TURN harvesting of the specified <tt>hostCandidate</tt>\n@see StunCandidateHarvester#createHarvest(HostCandidate)\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/GoogleTurnSSLCandidateHarvester.java.GoogleTurnSSLCandidateHarvester.[HostCandidate]getHostCandidate(HostCandidate)", "name": "getHostCandidate", "arg_nums": 1, "params": [{"name": "hostCand", "type": "HostCandidate"}], "return_type": "HostCandidate", "signature": "@Override\n    protected HostCandidate getHostCandidate(HostCandidate hostCand)", "original_string": "    @Override\n    protected HostCandidate getHostCandidate(HostCandidate hostCand)\n    {\n        HostCandidate cand = null;\n        Socket sock = null;\n\n        try\n        {\n            sock = new Socket(stunServer.getAddress(), stunServer.getPort());\n\n            OutputStream outputStream = sock.getOutputStream();\n            InputStream inputStream = sock.getInputStream();\n\n            if (sslHandshake(inputStream, outputStream))\n            {\n                Component parentComponent = hostCand.getParentComponent();\n                MultiplexingSocket multiplexing = new MultiplexingSocket(sock);\n\n                cand\n                    = new HostCandidate(\n                            new IceTcpSocketWrapper(multiplexing),\n                            parentComponent,\n                            Transport.TCP);\n                parentComponent\n                    .getParentStream()\n                        .getParentAgent()\n                            .getStunStack()\n                                .addSocket(cand.getStunSocket(null));\n                ComponentSocket componentSocket\n                    = parentComponent.getComponentSocket();\n                if (componentSocket != null)\n                {\n                    componentSocket.add(multiplexing);\n                }\n            }\n        }\n        catch (Exception e)\n        {\n            cand = null;\n        }\n        finally\n        {\n            if ((cand == null) && (sock != null))\n            {\n                try\n                {\n                    sock.close();\n                }\n                catch (IOException ioe)\n                {\n                    /*\n                     * We failed to close sock but that should not be much of a\n                     * problem because we were not closing it in earlier\n                     * revisions.\n                     */\n                }\n            }\n        }\n        return cand;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/GoogleTurnSSLCandidateHarvester.java", "class_name": "GoogleTurnSSLCandidateHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/GoogleTurnSSLCandidateHarvester.java.GoogleTurnSSLCandidateHarvester", "attributes": {"modifiers": "@Override\n    protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "HostCandidate", "classes": []}, "docstring": "\nReturns the host candidate.\nFor UDP it simply returns the candidate passed as parameter\n\nHowever for TCP, we cannot return the same hostCandidate because in Java\na  \"server\" socket cannot connect to a destination with the same local\naddress/port (i.e. a Java Socket cannot act as both server/client).\n\n@param hostCand HostCandidate\n@return HostCandidate\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/GoogleTurnSSLCandidateHarvester.java.GoogleTurnSSLCandidateHarvester.[boolean]sslHandshake(InputStream,OutputStream)", "name": "sslHandshake", "arg_nums": 2, "params": [{"name": "inputStream", "type": "InputStream"}, {"name": "outputStream", "type": "OutputStream"}], "return_type": "boolean", "signature": "public static boolean sslHandshake(InputStream inputStream, OutputStream\n        outputStream)", "original_string": "    public static boolean sslHandshake(InputStream inputStream, OutputStream\n        outputStream) throws IOException\n    {\n        byte data[] = new byte[SSL_SERVER_HANDSHAKE.length];\n\n        outputStream.write(SSL_CLIENT_HANDSHAKE);\n        inputStream.read(data);\n\n        outputStream = null;\n        inputStream = null;\n\n        if (Arrays.equals(data, SSL_SERVER_HANDSHAKE))\n        {\n            return true;\n        }\n\n        return false;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/GoogleTurnSSLCandidateHarvester.java", "class_name": "GoogleTurnSSLCandidateHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/GoogleTurnSSLCandidateHarvester.java.GoogleTurnSSLCandidateHarvester", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nDo the SSL handshake (send client certificate and wait for receive server\ncertificate). We explicitly need <tt>InputStream</tt> and\n<tt>OutputStream</tt> because some <tt>Socket</tt> may redefine\ngetInputStream()/getOutputStream() and we need the original stream.\n\n@param inputStream <tt>InputStream</tt> of the socket\n@param outputStream <tt>OutputStream</tt> of the socket\n@return true if the SSL handshake is done\n@throws IOException if something goes wrong\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/TcpHarvester.java.TcpHarvester.[]TcpHarvester(int)", "name": "TcpHarvester", "arg_nums": 1, "params": [{"name": "port", "type": "int"}], "return_type": "", "signature": "public TcpHarvester(int port)", "original_string": "    public TcpHarvester(int port)\n        throws IOException\n    {\n        super(port);\n        this.ssltcp = false;\n        addMappedAddresses();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/TcpHarvester.java", "class_name": "TcpHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/TcpHarvester.java.TcpHarvester", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>TcpHarvester</tt>, which is to\nlisten on port number <tt>port</tt> on all IP addresses on all available\ninterfaces.\n\n@param port the port to listen on.\n@throws IOException when {@link HarvestConfig#getAllowedAddresses()} or\n{@link HarvestConfig#getBlockedAddresses()} contains invalid values, or\nif an I/O error occurs.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/TcpHarvester.java.TcpHarvester.[]TcpHarvester(int,boolean)", "name": "TcpHarvester", "arg_nums": 2, "params": [{"name": "port", "type": "int"}, {"name": "ssltcp", "type": "boolean"}], "return_type": "", "signature": "public TcpHarvester(int port, boolean ssltcp)", "original_string": "    public TcpHarvester(int port, boolean ssltcp)\n            throws IOException\n    {\n        super(port, Collections.list(NetworkInterface.getNetworkInterfaces()));\n        this.ssltcp = ssltcp;\n        addMappedAddresses();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/TcpHarvester.java", "class_name": "TcpHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/TcpHarvester.java.TcpHarvester", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>TcpHarvester</tt>, which is to\nlisten on port number <tt>port</tt> on all IP addresses on all available\ninterfaces.\n\n@param port the port to listen on.\n@param ssltcp <tt>true</tt> to use ssltcp; otherwise, <tt>false</tt>\n@throws IOException when {@link HarvestConfig#getAllowedAddresses()} or\n{@link HarvestConfig#getBlockedAddresses()} contains invalid values, or\nif an I/O error occurs.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/TcpHarvester.java.TcpHarvester.[]TcpHarvester(int,List<NetworkInterface>,boolean)", "name": "TcpHarvester", "arg_nums": 3, "params": [{"name": "port", "type": "int"}, {"name": "interfaces", "type": "List<NetworkInterface>"}, {"name": "ssltcp", "type": "boolean"}], "return_type": "", "signature": "public TcpHarvester(\n            int port,\n            List<NetworkInterface> interfaces,\n            boolean ssltcp)", "original_string": "    public TcpHarvester(\n            int port,\n            List<NetworkInterface> interfaces,\n            boolean ssltcp)\n        throws IOException\n    {\n        super(port, interfaces);\n        this.ssltcp = ssltcp;\n        addMappedAddresses();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/TcpHarvester.java", "class_name": "TcpHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/TcpHarvester.java.TcpHarvester", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>TcpHarvester</tt>, which is to\nlisten on port number <tt>port</tt> on all the IP addresses on the\nspecified <tt>NetworkInterface</tt>s.\n\n@param port the port to listen on.\n@param interfaces the interfaces to listen on.\n@param ssltcp <tt>true</tt> to use ssltcp; otherwise, <tt>false</tt>\n@throws IOException when {@link HarvestConfig#getAllowedAddresses()} or\n{@link HarvestConfig#getBlockedAddresses()} contains invalid values, or\nif an I/O error occurs.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/TcpHarvester.java.TcpHarvester.[]TcpHarvester(List<TransportAddress>)", "name": "TcpHarvester", "arg_nums": 1, "params": [{"name": "transportAddresses", "type": "List<TransportAddress>"}], "return_type": "", "signature": "public TcpHarvester(List<TransportAddress> transportAddresses)", "original_string": "    public TcpHarvester(List<TransportAddress> transportAddresses)\n        throws IOException\n    {\n        super(transportAddresses);\n        this.ssltcp = false;\n        addMappedAddresses();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/TcpHarvester.java", "class_name": "TcpHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/TcpHarvester.java.TcpHarvester", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>TcpHarvester</tt>, which is to\nlisten on the specified list of <tt>TransportAddress</tt>es.\n\n@param transportAddresses the transport addresses to listen on.\n@throws IOException when {@link HarvestConfig#getAllowedAddresses()} or\n{@link HarvestConfig#getBlockedAddresses()} contains invalid values, or\nif an I/O error occurs.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/TcpHarvester.java.TcpHarvester.[]TcpHarvester(List<TransportAddress>,boolean)", "name": "TcpHarvester", "arg_nums": 2, "params": [{"name": "transportAddresses", "type": "List<TransportAddress>"}, {"name": "ssltcp", "type": "boolean"}], "return_type": "", "signature": "public TcpHarvester(\n            List<TransportAddress> transportAddresses,\n            boolean ssltcp)", "original_string": "    public TcpHarvester(\n            List<TransportAddress> transportAddresses,\n            boolean ssltcp)\n        throws IOException\n    {\n        super(transportAddresses);\n        this.ssltcp = ssltcp;\n        addMappedAddresses();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/TcpHarvester.java", "class_name": "TcpHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/TcpHarvester.java.TcpHarvester", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>TcpHarvester</tt>, which is to\nlisten on the specified list of <tt>TransportAddress</tt>es.\n\n@param transportAddresses the transport addresses to listen on.\n@param ssltcp <tt>true</tt> to use ssltcp; otherwise, <tt>false</tt>\n@throws IOException when {@link HarvestConfig#getAllowedAddresses()} or\n{@link HarvestConfig#getBlockedAddresses()} contains invalid values, or\nif an I/O error occurs.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/TcpHarvester.java.TcpHarvester.[void]addMappedAddresses()", "name": "addMappedAddresses", "arg_nums": 0, "params": [], "return_type": "void", "signature": "private void addMappedAddresses()", "original_string": "    private void addMappedAddresses()\n    {\n        for (MappingCandidateHarvester harvester\n                    : MappingCandidateHarvesters.getHarvesters())\n        {\n            addMappedAddress(\n                    harvester.getMask().getAddress(),\n                    harvester.getFace().getAddress());\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/TcpHarvester.java", "class_name": "TcpHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/TcpHarvester.java.TcpHarvester", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nAdds the mapped addresses known from {@link MappingCandidateHarvesters}.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/TcpHarvester.java.TcpHarvester.[void]addMappedAddress(InetAddress,InetAddress)", "name": "addMappedAddress", "arg_nums": 2, "params": [{"name": "publicAddress", "type": "InetAddress"}, {"name": "localAddress", "type": "InetAddress"}], "return_type": "void", "signature": "public void addMappedAddress(InetAddress publicAddress,\n                                 InetAddress localAddress)", "original_string": "    public void addMappedAddress(InetAddress publicAddress,\n                                 InetAddress localAddress)\n    {\n        if (logger.isLoggable(Level.FINE))\n        {\n            logger.fine(\"Adding a mapped address: \" + localAddress\n                            + \" => \" + publicAddress);\n        }\n        mappedAddresses.put(publicAddress, localAddress);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/TcpHarvester.java", "class_name": "TcpHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/TcpHarvester.java.TcpHarvester", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nAdds a mapping between <tt>publicAddress</tt> and <tt>localAddress</tt>.\nThis means that on harvest, along with any host candidates that have\n<tt>publicAddress</tt>, a server reflexive candidate will be added (with\nthe same port as the host candidate).\n\n@param publicAddress the public address.\n@param localAddress the local address.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/TcpHarvester.java.TcpHarvester.[void]addMappedPort(int)", "name": "addMappedPort", "arg_nums": 1, "params": [{"name": "port", "type": "int"}], "return_type": "void", "signature": "public void addMappedPort(int port)", "original_string": "    public void addMappedPort(int port)\n    {\n        mappedPorts.add(port);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/TcpHarvester.java", "class_name": "TcpHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/TcpHarvester.java.TcpHarvester", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nAdds port as an additional port. When harvesting, additional server\nreflexive candidates will be added with this port.\n\n@param port the port to add.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/TcpHarvester.java.TcpHarvester.[List<LocalCandidate>]createLocalCandidates(Component)", "name": "createLocalCandidates", "arg_nums": 1, "params": [{"name": "component", "type": "Component"}], "return_type": "List<LocalCandidate>", "signature": "private List<LocalCandidate> createLocalCandidates(Component component)", "original_string": "    private List<LocalCandidate> createLocalCandidates(Component component)\n    {\n        List<TcpHostCandidate> hostCandidates = new LinkedList<>();\n\n        // Add the host candidates for the addresses we really listen on\n        for (TransportAddress transportAddress : localAddresses)\n        {\n            TcpHostCandidate candidate\n                = new TcpHostCandidate(transportAddress, component);\n\n            candidate.setTcpType(CandidateTcpType.PASSIVE);\n            if (ssltcp)\n                candidate.setSSL(true);\n\n            hostCandidates.add(candidate);\n        }\n\n        // Add srflx candidates for any mapped addresses\n        List<LocalCandidate> mappedCandidates = new LinkedList<>();\n\n        for (Map.Entry<InetAddress, InetAddress> mapping\n                : mappedAddresses.entrySet())\n        {\n            InetAddress localAddress = mapping.getValue();\n\n            for (TcpHostCandidate base : hostCandidates)\n            {\n                TransportAddress baseTransportAddress\n                    = base.getTransportAddress();\n\n                if (localAddress.equals(baseTransportAddress.getAddress()))\n                {\n                    InetAddress publicAddress = mapping.getKey();\n                    ServerReflexiveCandidate mappedCandidate\n                        = new ServerReflexiveCandidate(\n                            new TransportAddress(publicAddress,\n                                                 baseTransportAddress.getPort(),\n                                                 Transport.TCP),\n                            base,\n                            base.getStunServerAddress(),\n                            CandidateExtendedType.STATICALLY_MAPPED_CANDIDATE);\n\n                    if (base.isSSL())\n                        mappedCandidate.setSSL(true);\n                    mappedCandidate.setTcpType(CandidateTcpType.PASSIVE);\n\n                    mappedCandidates.add(mappedCandidate);\n                }\n            }\n        }\n\n        // Add srflx candidates for mapped ports\n        List<LocalCandidate> portMappedCandidates = new LinkedList<>();\n\n        for (TcpHostCandidate base : hostCandidates)\n        {\n            for (Integer port : mappedPorts)\n            {\n                ServerReflexiveCandidate portMappedCandidate\n                    = new ServerReflexiveCandidate(\n                        new TransportAddress(\n                            base.getTransportAddress().getAddress(),\n                            port,\n                            Transport.TCP),\n                        base,\n                        base.getStunServerAddress(),\n                        CandidateExtendedType.STATICALLY_MAPPED_CANDIDATE);\n\n                if (base.isSSL())\n                    portMappedCandidate.setSSL(true);\n                portMappedCandidate.setTcpType(CandidateTcpType.PASSIVE);\n\n                portMappedCandidates.add(portMappedCandidate);\n            }\n        }\n        // Mapped ports for mapped addresses\n        for (LocalCandidate mappedCandidate : mappedCandidates)\n        {\n            TcpHostCandidate base\n                = (TcpHostCandidate) mappedCandidate.getBase();\n\n            for (Integer port : mappedPorts)\n            {\n                ServerReflexiveCandidate portMappedCandidate\n                    = new ServerReflexiveCandidate(\n                        new TransportAddress(\n                                mappedCandidate.getTransportAddress()\n                                        .getAddress(),\n                                port,\n                                Transport.TCP),\n                        base,\n                        base.getStunServerAddress(),\n                        CandidateExtendedType.STATICALLY_MAPPED_CANDIDATE);\n\n                if (base.isSSL())\n                    portMappedCandidate.setSSL(true);\n                portMappedCandidate.setTcpType(CandidateTcpType.PASSIVE);\n\n                portMappedCandidates.add(portMappedCandidate);\n            }\n        }\n\n        LinkedList<LocalCandidate> allCandidates = new LinkedList<>();\n\n        allCandidates.addAll(hostCandidates);\n        allCandidates.addAll(mappedCandidates);\n        allCandidates.addAll(portMappedCandidates);\n        return allCandidates;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/TcpHarvester.java", "class_name": "TcpHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/TcpHarvester.java.TcpHarvester", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "List<LocalCandidate>", "classes": []}, "docstring": "\nCreates and returns the list of <tt>LocalCandidate</tt>s which are to be\nadded by this <tt>TcpHarvester</tt> to a specific\n<tt>Component</tt>.\n\n@param component the <tt>Component</tt> for which to create candidates.\n@return the list of <tt>LocalCandidate</tt>s which are to be added by\nthis <tt>TcpHarvester</tt> to a specific\n<tt>Component</tt>.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/TcpHarvester.java.TcpHarvester.[Component]getComponent(String)", "name": "getComponent", "arg_nums": 1, "params": [{"name": "localUfrag", "type": "String"}], "return_type": "Component", "signature": "private Component getComponent(String localUfrag)", "original_string": "    private Component getComponent(String localUfrag)\n    {\n        synchronized (components)\n        {\n            WeakReference<Component> wr = components.get(localUfrag);\n\n            if (wr != null)\n            {\n                Component component = wr.get();\n\n                if (component == null)\n                {\n                    components.remove(localUfrag);\n                }\n\n                return component;\n            }\n            return null;\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/TcpHarvester.java", "class_name": "TcpHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/TcpHarvester.java.TcpHarvester", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Component", "classes": []}, "docstring": "\nReturns the <tt>Component</tt> instance, if any, for a given local\n&quot;ufrag&quot;.\n\n@param localUfrag the local &quot;ufrag&quot;\n@return the <tt>Component</tt> instance, if any, for a given local\n&quot;ufrag&quot;.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/TcpHarvester.java.TcpHarvester.[Collection<LocalCandidate>]harvest(Component)", "name": "harvest", "arg_nums": 1, "params": [{"name": "component", "type": "Component"}], "return_type": "Collection<LocalCandidate>", "signature": "@Override\n    public Collection<LocalCandidate> harvest(Component component)", "original_string": "    @Override\n    public Collection<LocalCandidate> harvest(Component component)\n    {\n        IceMediaStream stream = component.getParentStream();\n        Agent agent = stream.getParentAgent();\n\n        if (stream.getComponentCount() != 1 || agent.getStreamCount() != 1)\n        {\n            /*\n             * TcpHarvester only works with streams with a\n             * single component, and agents with a single stream. This is\n             * because we use the local \"ufrag\" to de-multiplex the accept()-ed\n             * sockets between the known components.\n             */\n            logger.info(\n                    \"More than one Component for an Agent, cannot harvest.\");\n            return new LinkedList<>();\n        }\n\n        List<LocalCandidate> candidates = createLocalCandidates(component);\n\n        for (LocalCandidate candidate : candidates)\n            component.addLocalCandidate(candidate);\n\n        synchronized (components)\n        {\n            components.put(\n                    agent.getLocalUfrag(),\n                    new WeakReference<>(component));\n            purgeComponents();\n        }\n\n        return candidates;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/TcpHarvester.java", "class_name": "TcpHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/TcpHarvester.java.TcpHarvester", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Collection<LocalCandidate>", "classes": []}, "docstring": "\n{@inheritDoc}\n\nSaves a (weak) reference to <tt>Component</tt>, so that it can be\nnotified if/when a socket for one of it <tt>LocalCandidate</tt>s is\naccepted.\n<p>\nThe method does not perform any network operations and should return\nquickly.\n</p>\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/TcpHarvester.java.TcpHarvester.[void]purgeComponents()", "name": "purgeComponents", "arg_nums": 0, "params": [], "return_type": "void", "signature": "private void purgeComponents()", "original_string": "    private void purgeComponents()\n    {\n        ++purgeCounter;\n        if (purgeCounter % PURGE_INTERVAL == 0)\n        {\n            synchronized (components)\n            {\n                for (Iterator<WeakReference<Component>> i\n                            = components.values().iterator();\n                        i.hasNext();)\n                {\n                    if (i.next().get() == null)\n                        i.remove();\n                }\n            }\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/TcpHarvester.java", "class_name": "TcpHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/TcpHarvester.java.TcpHarvester", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nRemoves entries from {@link #components} for which the\n<tt>WeakReference</tt> has been cleared.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/TcpHarvester.java.TcpHarvester.[void]acceptSession(Socket,String,DatagramPacket)", "name": "acceptSession", "arg_nums": 3, "params": [{"name": "socket", "type": "Socket"}, {"name": "ufrag", "type": "String"}, {"name": "pushback", "type": "DatagramPacket"}], "return_type": "void", "signature": "@Override\n    protected void acceptSession(Socket socket, String ufrag,\n                                 DatagramPacket pushback)", "original_string": "    @Override\n    protected void acceptSession(Socket socket, String ufrag,\n                                 DatagramPacket pushback)\n        throws IOException, IllegalStateException\n    {\n        Component component = getComponent(ufrag);\n        if (component == null)\n        {\n            throw new IllegalStateException(\n                    \"No component found for ufrag \" + ufrag);\n        }\n\n        addSocketToComponent(socket, component, pushback);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/TcpHarvester.java", "class_name": "TcpHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/TcpHarvester.java.TcpHarvester", "attributes": {"modifiers": "@Override\n    protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/TcpHarvester.java.TcpHarvester.[void]addSocketToComponent(Socket,Component,DatagramPacket)", "name": "addSocketToComponent", "arg_nums": 3, "params": [{"name": "socket", "type": "Socket"}, {"name": "component", "type": "Component"}, {"name": "datagramPacket", "type": "DatagramPacket"}], "return_type": "void", "signature": "private void addSocketToComponent(\n            Socket socket, Component component, DatagramPacket datagramPacket)", "original_string": "    private void addSocketToComponent(\n            Socket socket, Component component, DatagramPacket datagramPacket)\n        throws IOException, IllegalStateException\n    {\n        IceProcessingState state\n            = component.getParentStream().getParentAgent().getState();\n\n        if (!IceProcessingState.WAITING.equals(state)\n            && !IceProcessingState.RUNNING.equals(state))\n        {\n            // If we are using the merging socket, we can still make use of the\n            // new socket. Otherwise, we have no use for it, so we better close\n            // it (and log a warning) early.\n            if (component.getComponentSocket() == null)\n            {\n                throw new IllegalStateException(\n                    \"The associated Agent is in state \" + state +\n                        \" and we are not using a component socket\");\n            }\n            else if (logger.isLoggable(Level.FINE))\n            {\n                logger.fine(\"Adding a socket to an Agent in state \" + state);\n            }\n        }\n\n        // Socket to add to the candidate\n        IceSocketWrapper candidateSocket = null;\n        // STUN-only filtered socket to add to the StunStack\n        IceSocketWrapper stunSocket = null;\n\n        MultiplexingSocket multiplexing = new MultiplexingSocket(socket);\n        candidateSocket = new IceTcpSocketWrapper(multiplexing);\n\n        stunSocket\n            = new IceTcpSocketWrapper(\n                multiplexing.getSocket(new StunDatagramPacketFilter()));\n        stunSocket = new PushBackIceSocketWrapper(stunSocket, datagramPacket);\n\n        TcpHostCandidate candidate = findCandidate(component, socket);\n        if (candidate == null)\n        {\n            throw new IOException(\n                    \"Failed to find the local candidate for socket: \" + socket);\n        }\n\n        component.getParentStream().getParentAgent().getStunStack()\n                .addSocket(stunSocket);\n        candidate.addSocket(candidateSocket);\n\n        MergingDatagramSocket componentSocket = component.getComponentSocket();\n        if (componentSocket != null)\n        {\n            componentSocket.add(multiplexing);\n        }\n        // the socket is not our responsibility anymore. It is up to\n        // the candidate/component to close/free it.\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/TcpHarvester.java", "class_name": "TcpHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/TcpHarvester.java.TcpHarvester", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nMakes <tt>socket</tt> available to <tt>component</tt> and pushes back\n<tt>datagramPacket</tt> into the STUN socket.\n\n@param socket the <tt>Socket</tt>.\n@param component the <tt>Component</tt>.\n@param datagramPacket the <tt>DatagramPacket</tt> to push back.\n@throws IllegalStateException if the ICE state is incorrect, or an\nappropriate candidate could not be found.\n@throws IOException if creation of some of the required socket instances\nfailed.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/TcpHarvester.java.TcpHarvester.[TcpHostCandidate]findCandidate(Component,Socket)", "name": "findCandidate", "arg_nums": 2, "params": [{"name": "component", "type": "Component"}, {"name": "socket", "type": "Socket"}], "return_type": "TcpHostCandidate", "signature": "private TcpHostCandidate findCandidate(\n        Component component,\n        Socket socket)", "original_string": "    private TcpHostCandidate findCandidate(\n        Component component,\n        Socket socket)\n    {\n        InetAddress localAddress = socket.getLocalAddress();\n        int localPort = socket.getLocalPort();\n\n        for (LocalCandidate candidate : component.getLocalCandidates())\n        {\n            TransportAddress transportAddress\n                = candidate.getTransportAddress();\n\n            if (candidate instanceof TcpHostCandidate\n                && Transport.TCP.equals(transportAddress.getTransport())\n                && localPort == transportAddress.getPort()\n                && localAddress.equals(transportAddress.getAddress()))\n            {\n                return (TcpHostCandidate) candidate;\n            }\n        }\n        return null;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/TcpHarvester.java", "class_name": "TcpHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/TcpHarvester.java.TcpHarvester", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "TcpHostCandidate", "classes": []}, "docstring": "\nSearches among the local candidates of <tt>Component</tt> for a\n<tt>TcpHostCandidate</tt> with the same transport address as the\nlocal transport address of <tt>socket</tt>.\n\nWe expect to find such a candidate, which has been added by this\n<tt>TcpHarvester</tt> while harvesting.\n\n@param component the <tt>Component</tt> to search.\n@param socket the <tt>Socket</tt> to match the local transport\naddress of.\n@return a <tt>TcpHostCandidate</tt> among the local candidates of\n<tt>Component</tt> with the same transport address as the local\naddress of <tt>Socket</tt>, or <tt>null</tt> if no such candidate\nexists.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/TcpHarvester.java.TcpHarvester.[boolean]isHostHarvester()", "name": "isHostHarvester", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "@Override\n    public boolean isHostHarvester()", "original_string": "    @Override\n    public boolean isHostHarvester()\n    {\n        return true;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/TcpHarvester.java", "class_name": "TcpHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/TcpHarvester.java.TcpHarvester", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/TcpHarvester.java.TcpHarvester.[HarvestStatistics]getHarvestStatistics()", "name": "getHarvestStatistics", "arg_nums": 0, "params": [], "return_type": "HarvestStatistics", "signature": "public HarvestStatistics getHarvestStatistics()", "original_string": "    public HarvestStatistics getHarvestStatistics()\n    {\n        return harvestStatistics;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/TcpHarvester.java", "class_name": "TcpHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/TcpHarvester.java.TcpHarvester", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "HarvestStatistics", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/TurnCandidateHarvester.java.TurnCandidateHarvester.[]TurnCandidateHarvester(TransportAddress)", "name": "TurnCandidateHarvester", "arg_nums": 1, "params": [{"name": "turnServer", "type": "TransportAddress"}], "return_type": "", "signature": "public TurnCandidateHarvester(TransportAddress turnServer)", "original_string": "    public TurnCandidateHarvester(TransportAddress turnServer)\n    {\n        this(turnServer, (LongTermCredential) null);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/TurnCandidateHarvester.java", "class_name": "TurnCandidateHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/TurnCandidateHarvester.java.TurnCandidateHarvester", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>TurnCandidateHarvester</tt> instance which is to\nwork with a specific TURN server.\n\n@param turnServer the <tt>TransportAddress</tt> of the TURN server the\nnew instance is to work with\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/TurnCandidateHarvester.java.TurnCandidateHarvester.[]TurnCandidateHarvester(TransportAddress,LongTermCredential)", "name": "TurnCandidateHarvester", "arg_nums": 2, "params": [{"name": "turnServer", "type": "TransportAddress"}, {"name": "longTermCredential", "type": "LongTermCredential"}], "return_type": "", "signature": "public TurnCandidateHarvester(\n            TransportAddress turnServer,\n            LongTermCredential longTermCredential)", "original_string": "    public TurnCandidateHarvester(\n            TransportAddress turnServer,\n            LongTermCredential longTermCredential)\n    {\n        super(turnServer);\n\n        this.longTermCredential = longTermCredential;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/TurnCandidateHarvester.java", "class_name": "TurnCandidateHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/TurnCandidateHarvester.java.TurnCandidateHarvester", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>TurnCandidateHarvester</tt> instance which is to\nwork with a specific TURN server using a specific\n<tt>LongTermCredential</tt>.\n\n@param turnServer the <tt>TransportAddress</tt> of the TURN server the\nnew instance is to work with\n@param longTermCredential the <tt>LongTermCredential</tt> to use with the\nspecified <tt>turnServer</tt> or <tt>null</tt> if the use of the\nlong-term credential mechanism is not determined at the time of the\ninitialization of the new <tt>TurnCandidateHarvester</tt> instance\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/TurnCandidateHarvester.java.TurnCandidateHarvester.[]TurnCandidateHarvester(TransportAddress,String)", "name": "TurnCandidateHarvester", "arg_nums": 2, "params": [{"name": "turnServer", "type": "TransportAddress"}, {"name": "shortTermCredentialUsername", "type": "String"}], "return_type": "", "signature": "public TurnCandidateHarvester(\n            TransportAddress turnServer,\n            String shortTermCredentialUsername)", "original_string": "    public TurnCandidateHarvester(\n            TransportAddress turnServer,\n            String shortTermCredentialUsername)\n    {\n        super(turnServer, shortTermCredentialUsername);\n\n        this.longTermCredential = null;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/TurnCandidateHarvester.java", "class_name": "TurnCandidateHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/TurnCandidateHarvester.java.TurnCandidateHarvester", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>TurnCandidateHarvester</tt> instance which is to\nwork with a specific TURN server using a specific username for the\npurposes of the STUN short-term credential mechanism.\n\n@param turnServer the <tt>TransportAddress</tt> of the TURN server the\nnew instance is to work with\n@param shortTermCredentialUsername the username to be used by the new\ninstance for the purposes of the STUN short-term credential mechanism or\n<tt>null</tt> if the use of the STUN short-term credential mechanism is\nnot determined at the time of the construction of the new instance\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/TurnCandidateHarvester.java.TurnCandidateHarvester.[TurnCandidateHarvest]createHarvest(HostCandidate)", "name": "createHarvest", "arg_nums": 1, "params": [{"name": "hostCandidate", "type": "HostCandidate"}], "return_type": "TurnCandidateHarvest", "signature": "@Override\n    protected TurnCandidateHarvest createHarvest(HostCandidate hostCandidate)", "original_string": "    @Override\n    protected TurnCandidateHarvest createHarvest(HostCandidate hostCandidate)\n    {\n        return new TurnCandidateHarvest(this, hostCandidate);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/TurnCandidateHarvester.java", "class_name": "TurnCandidateHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/TurnCandidateHarvester.java.TurnCandidateHarvester", "attributes": {"modifiers": "@Override\n    protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "TurnCandidateHarvest", "classes": []}, "docstring": "\nCreates a new <tt>TurnCandidateHarvest</tt> instance which is to perform\nTURN harvesting of a specific <tt>HostCandidate</tt>.\n\n@param hostCandidate the <tt>HostCandidate</tt> for which harvesting is\nto be performed by the new <tt>TurnCandidateHarvest</tt> instance\n@return a new <tt>TurnCandidateHarvest</tt> instance which is to perform\nTURN harvesting of the specified <tt>hostCandidate</tt>\n@see StunCandidateHarvester#createHarvest(HostCandidate)\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/TurnCandidateHarvester.java.TurnCandidateHarvester.[LongTermCredential]createLongTermCredential(StunCandidateHarvest,byte[])", "name": "createLongTermCredential", "arg_nums": 2, "params": [{"name": "harvest", "type": "StunCandidateHarvest"}, {"name": "realm", "type": "byte[]"}], "return_type": "LongTermCredential", "signature": "@Override\n    protected LongTermCredential createLongTermCredential(\n            StunCandidateHarvest harvest,\n            byte[] realm)", "original_string": "    @Override\n    protected LongTermCredential createLongTermCredential(\n            StunCandidateHarvest harvest,\n            byte[] realm)\n    {\n        return longTermCredential;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/TurnCandidateHarvester.java", "class_name": "TurnCandidateHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/TurnCandidateHarvester.java.TurnCandidateHarvester", "attributes": {"modifiers": "@Override\n    protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "LongTermCredential", "classes": []}, "docstring": "\nCreates a <tt>LongTermCredential</tt> to be used by a specific\n<tt>StunCandidateHarvest</tt> for the purposes of the long-term\ncredential mechanism in a specific <tt>realm</tt> of the TURN server\nassociated with this <tt>TurnCandidateHarvester</tt>. The default\nimplementation returns <tt>null</tt> and allows extenders to override in\norder to support the long-term credential mechanism.\n\n@param harvest the <tt>StunCandidateHarvest</tt> which asks for the\n<tt>LongTermCredential</tt>\n@param realm the realm of the TURN server associated with this\n<tt>TurnCandidateHarvester</tt> in which <tt>harvest</tt> will use the\nreturned <tt>LongTermCredential</tt>\n@return a <tt>LongTermCredential</tt> to be used by <tt>harvest</tt> for\nthe purposes of the long-term credential mechanism in the specified\n<tt>realm</tt> of the TURN server associated with this\n<tt>TurnsCandidateHarvester</tt>\n@see StunCandidateHarvester#createLongTermCredential(\nStunCandidateHarvest,byte[])\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/StunMappingCandidateHarvester.java.StunMappingCandidateHarvester.[]StunMappingCandidateHarvester(TransportAddress,TransportAddress)", "name": "StunMappingCandidateHarvester", "arg_nums": 2, "params": [{"name": "localAddress", "type": "TransportAddress"}, {"name": "stunServerAddress", "type": "TransportAddress"}], "return_type": "", "signature": "public StunMappingCandidateHarvester(\n            @NotNull TransportAddress localAddress,\n            TransportAddress stunServerAddress)", "original_string": "    public StunMappingCandidateHarvester(\n            @NotNull TransportAddress localAddress,\n            TransportAddress stunServerAddress)\n    {\n        super(\"stun\");\n        this.localAddress = localAddress;\n        this.stunServerAddress = stunServerAddress;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/StunMappingCandidateHarvester.java", "class_name": "StunMappingCandidateHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/StunMappingCandidateHarvester.java.StunMappingCandidateHarvester", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new {@link StunMappingCandidateHarvester} instance with\na given local address and a STUN server address. Note that the actual\ndiscovery of the public address needs to be initiated to a separate call\nto {@link #discover()}.\n@param localAddress The local address.\n@param stunServerAddress The address of the STUN server.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/StunMappingCandidateHarvester.java.StunMappingCandidateHarvester.[void]discover()", "name": "discover", "arg_nums": 0, "params": [], "return_type": "void", "signature": "public void discover()", "original_string": "    public void discover()\n    {\n        try\n        {\n            SimpleAddressDetector sad\n                = new SimpleAddressDetector(stunServerAddress);\n            sad.start();\n\n            IceSocketWrapper localSocket = new IceUdpSocketWrapper(new DatagramSocket(localAddress));\n\n            publicAddress = sad.getMappingFor(localSocket);\n\n            /* Record bound address as face. */\n            SocketAddress boundAddr = localSocket.getLocalSocketAddress();\n            if (boundAddr instanceof InetSocketAddress)\n            {\n                localAddress = new TransportAddress((InetSocketAddress)boundAddr, localAddress.getTransport());\n            }\n\n            if (publicAddress != null)\n            {\n                logger.info(\"Discovered public address \" + publicAddress\n                                + \" from STUN server \" + stunServerAddress\n                                + \" using local address \" + localSocket);\n            }\n        }\n        catch (Exception exc)\n        {\n            //whatever happens, we just log\n            logger.log(Level.INFO, \"We failed to obtain addresses for the following reason: \", exc);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/StunMappingCandidateHarvester.java", "class_name": "StunMappingCandidateHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/StunMappingCandidateHarvester.java.StunMappingCandidateHarvester", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nAttempts to discover the the public address (mask) via the STUN server.\nNote that this will block until we either receive a response from the\nSTUN server, or a timeout occurs.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/StunMappingCandidateHarvester.java.StunMappingCandidateHarvester.[TransportAddress]getFace()", "name": "getFace", "arg_nums": 0, "params": [], "return_type": "TransportAddress", "signature": "@Nullable\n    @Override\n    public TransportAddress getFace()", "original_string": "    @Nullable\n    @Override\n    public TransportAddress getFace()\n    {\n        return localAddress;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/StunMappingCandidateHarvester.java", "class_name": "StunMappingCandidateHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/StunMappingCandidateHarvester.java.StunMappingCandidateHarvester", "attributes": {"modifiers": "@Nullable\n    @Override\n    public", "marker_annotations": ["@Nullable", "@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "TransportAddress", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/StunMappingCandidateHarvester.java.StunMappingCandidateHarvester.[TransportAddress]getMask()", "name": "getMask", "arg_nums": 0, "params": [], "return_type": "TransportAddress", "signature": "@Nullable\n    @Override\n    public TransportAddress getMask()", "original_string": "    @Nullable\n    @Override\n    public TransportAddress getMask()\n    {\n        return publicAddress;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/StunMappingCandidateHarvester.java", "class_name": "StunMappingCandidateHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/StunMappingCandidateHarvester.java.StunMappingCandidateHarvester", "attributes": {"modifiers": "@Nullable\n    @Override\n    public", "marker_annotations": ["@Nullable", "@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "TransportAddress", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSetElement.java.CandidateHarvesterSetElement.[]CandidateHarvesterSetElement(CandidateHarvester)", "name": "CandidateHarvesterSetElement", "arg_nums": 1, "params": [{"name": "harvester", "type": "CandidateHarvester"}], "return_type": "", "signature": "public CandidateHarvesterSetElement(CandidateHarvester harvester)", "original_string": "    public CandidateHarvesterSetElement(CandidateHarvester harvester)\n    {\n        this.harvester = harvester;\n        harvester.getHarvestStatistics().harvesterName = harvester.toString();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSetElement.java", "class_name": "CandidateHarvesterSetElement", "class_uri": "src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSetElement.java.CandidateHarvesterSetElement", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>CandidateHarvesterSetElement</tt> instance\nwhich is to represent a specific <tt>CandidateHarvester</tt> as an\nelement in a <tt>CandidateHarvesterSet</tt>.\n\n@param harvester the <tt>CandidateHarvester</tt> which is to be\nrepresented as an element in a <tt>CandidateHarvesterSet</tt> by the\nnew instance\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSetElement.java.CandidateHarvesterSetElement.[void]harvest(Component,TrickleCallback)", "name": "harvest", "arg_nums": 2, "params": [{"name": "component", "type": "Component"}, {"name": "trickleCallback", "type": "TrickleCallback"}], "return_type": "void", "signature": "public void harvest(Component       component,\n                        TrickleCallback trickleCallback)", "original_string": "    public void harvest(Component       component,\n                        TrickleCallback trickleCallback)\n    {\n        if (!isEnabled())\n            return;\n\n        startHarvestTiming();\n\n        Collection<LocalCandidate> candidates = harvester.harvest(component);\n\n        stopHarvestTiming(candidates);\n\n        /*\n         * If the CandidateHarvester has not gathered any candidates, it\n         * is considered failed and will not be used again in order to\n         * not risk it slowing down the overall harvesting.\n         */\n        if ((candidates == null) || candidates.isEmpty())\n        {\n            setEnabled(false);\n        }\n        else if (trickleCallback != null)\n        {\n            trickleCallback.onIceCandidates(candidates);\n        }\n\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSetElement.java", "class_name": "CandidateHarvesterSetElement", "class_uri": "src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSetElement.java.CandidateHarvesterSetElement", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCalls {@link CandidateHarvester#harvest(org.ice4j.ice.Component)} on the\nassociated <tt>CandidateHarvester</tt> if <tt>enabled</tt>.\n\n@param component the <tt>Component</tt> to gather candidates for\n@param trickleCallback the {@link TrickleCallback} that we will be\nfeeding candidates to, or <tt>null</tt> in case the application doesn't\nwant us trickling any candidates\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSetElement.java.CandidateHarvesterSetElement.[boolean]harvesterEquals(CandidateHarvester)", "name": "harvesterEquals", "arg_nums": 1, "params": [{"name": "harvester", "type": "CandidateHarvester"}], "return_type": "boolean", "signature": "public boolean harvesterEquals(CandidateHarvester harvester)", "original_string": "    public boolean harvesterEquals(CandidateHarvester harvester)\n    {\n        return this.harvester.equals(harvester);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSetElement.java", "class_name": "CandidateHarvesterSetElement", "class_uri": "src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSetElement.java.CandidateHarvesterSetElement", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nDetermines whether the associated <tt>CandidateHarvester</tt> is\nconsidered to be the same as a specific <tt>CandidateHarvester</tt>.\n\n@param harvester the <tt>CandidateHarvester</tt> to be compared to\nthe associated <tt>CandidateHarvester</tt>\n@return <tt>true</tt> if the associated <tt>CandidateHarvester</tt>\nis considered to be the same as the specified <tt>harvester</tt>;\notherwise, <tt>false</tt>\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSetElement.java.CandidateHarvesterSetElement.[boolean]isEnabled()", "name": "isEnabled", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "public boolean isEnabled()", "original_string": "    public boolean isEnabled()\n    {\n        return enabled;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSetElement.java", "class_name": "CandidateHarvesterSetElement", "class_uri": "src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSetElement.java.CandidateHarvesterSetElement", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nGets the indicator which determines whether\n{@link CandidateHarvester#harvest(Component)} is to be called on the\nassociated <tt>CandidateHarvester</tt>.\n\n@return <tt>true</tt> if\n<tt>CandidateHarvester#harvest(Component)</tt> is to be called on the\nassociated <tt>CandidateHarvester</tt>; otherwise, <tt>false</tt>\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSetElement.java.CandidateHarvesterSetElement.[void]setEnabled(boolean)", "name": "setEnabled", "arg_nums": 1, "params": [{"name": "enabled", "type": "boolean"}], "return_type": "void", "signature": "public void setEnabled(boolean enabled)", "original_string": "    public void setEnabled(boolean enabled)\n    {\n        logger.fine((enabled ? \"Enabling: \" : \"Disabling: \") + harvester);\n        this.enabled = enabled;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSetElement.java", "class_name": "CandidateHarvesterSetElement", "class_uri": "src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSetElement.java.CandidateHarvesterSetElement", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets the indicator which determines whether\n{@link CandidateHarvester#harvest(Component)} is to be called on the\nassociated <tt>CandidateHarvester</tt>.\n\n@param enabled <tt>true</tt> if\n<tt>CandidateHarvester#harvest(Component)</tt> is to be called on the\nassociated <tt>CandidateHarvester</tt>; otherwise, <tt>false</tt>\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSetElement.java.CandidateHarvesterSetElement.[CandidateHarvester]getHarvester()", "name": "getHarvester", "arg_nums": 0, "params": [], "return_type": "CandidateHarvester", "signature": "public CandidateHarvester getHarvester()", "original_string": "    public CandidateHarvester getHarvester()\n    {\n        return harvester;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSetElement.java", "class_name": "CandidateHarvesterSetElement", "class_uri": "src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSetElement.java.CandidateHarvesterSetElement", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "CandidateHarvester", "classes": []}, "docstring": "\nReturns the <tt>CandidateHarvester</tt> encapsulated by this element.\n\n@return the <tt>CandidateHarvester</tt> encapsulated by this element.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSetElement.java.CandidateHarvesterSetElement.[void]startHarvestTiming()", "name": "startHarvestTiming", "arg_nums": 0, "params": [], "return_type": "void", "signature": "private void startHarvestTiming()", "original_string": "    private void startHarvestTiming()\n    {\n        harvester.getHarvestStatistics().startHarvestTiming();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSetElement.java", "class_name": "CandidateHarvesterSetElement", "class_uri": "src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSetElement.java.CandidateHarvesterSetElement", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nStarts the harvesting timer. Called when the harvest begins.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSetElement.java.CandidateHarvesterSetElement.[void]stopHarvestTiming(Collection<LocalCandidate>)", "name": "stopHarvestTiming", "arg_nums": 1, "params": [{"name": "harvest", "type": "Collection<LocalCandidate>"}], "return_type": "void", "signature": "private void stopHarvestTiming(Collection<LocalCandidate> harvest)", "original_string": "    private void stopHarvestTiming(Collection<LocalCandidate> harvest)\n    {\n        harvester.getHarvestStatistics().stopHarvestTiming(harvest);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSetElement.java", "class_name": "CandidateHarvesterSetElement", "class_uri": "src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSetElement.java.CandidateHarvesterSetElement", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nStops the harvesting timer. Called when the harvest ends.\n\n@param harvest the harvest that we just concluded.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/MappingCandidateHarvesters.java.MappingCandidateHarvesters.[MappingCandidateHarvester[]]getHarvesters()", "name": "getHarvesters", "arg_nums": 0, "params": [], "return_type": "MappingCandidateHarvester[]", "signature": "public static MappingCandidateHarvester[] getHarvesters()", "original_string": "    public static MappingCandidateHarvester[] getHarvesters()\n    {\n        initialize();\n        return harvesters;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/MappingCandidateHarvesters.java", "class_name": "MappingCandidateHarvesters", "class_uri": "src/main/java/org/ice4j/ice/harvest/MappingCandidateHarvesters.java.MappingCandidateHarvesters", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "MappingCandidateHarvester[]", "classes": []}, "docstring": "\n@return the list of configured harvesters.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/MappingCandidateHarvesters.java.MappingCandidateHarvesters.[MappingCandidateHarvester]findHarvesterForAddress(TransportAddress)", "name": "findHarvesterForAddress", "arg_nums": 1, "params": [{"name": "publicAddress", "type": "TransportAddress"}], "return_type": "MappingCandidateHarvester", "signature": "public static MappingCandidateHarvester findHarvesterForAddress(TransportAddress publicAddress)", "original_string": "    public static MappingCandidateHarvester findHarvesterForAddress(TransportAddress publicAddress)\n    {\n        for (MappingCandidateHarvester harvester : harvesters)\n        {\n            if (harvester.publicAddressMatches(publicAddress))\n            {\n                return harvester;\n            }\n        }\n        return null;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/MappingCandidateHarvesters.java", "class_name": "MappingCandidateHarvesters", "class_uri": "src/main/java/org/ice4j/ice/harvest/MappingCandidateHarvesters.java.MappingCandidateHarvesters", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "MappingCandidateHarvester", "classes": []}, "docstring": "\n@return  the (first) mapping harvester which matches a given public address, or {@code null} if none match it.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/MappingCandidateHarvesters.java.MappingCandidateHarvesters.[void]initialize()", "name": "initialize", "arg_nums": 0, "params": [], "return_type": "void", "signature": "public static synchronized void initialize()", "original_string": "    public static synchronized void initialize()\n    {\n        if (initialized)\n            return;\n        initialized = true;\n\n        long start = System.currentTimeMillis();\n        List<MappingCandidateHarvester> harvesterList = new LinkedList<>();\n\n        for (HarvestConfig.StaticMapping staticMapping : config.getStaticMappings())\n        {\n            logger.info(\"Adding a static mapping: \" + staticMapping);\n            // If the configuration has no port, then the port value is not used in any way. We put 9 (for \"discard\")\n            // as a filler.\n            int localPort = staticMapping.getLocalPort() != null ? staticMapping.getLocalPort() : 9;\n            int publicPort = staticMapping.getPublicPort() != null ? staticMapping.getPublicPort() : 9;\n            TransportAddress localAddress\n                    = new TransportAddress(staticMapping.getLocalAddress(), localPort, Transport.UDP);\n            TransportAddress publicAddress\n                    = new TransportAddress(staticMapping.getPublicAddress(), publicPort, Transport.UDP);\n\n            harvesterList.add(new StaticMappingCandidateHarvester(\n                    publicAddress,\n                    localAddress,\n                    staticMapping.getName(),\n                    staticMapping.getLocalPort() != null));\n        }\n\n        // AWS harvester\n        boolean enableAwsHarvester = config.enableAwsHarvester();\n        if (enableAwsHarvester && (config.forceAwsHarvester() || AwsCandidateHarvester.smellsLikeAnEC2()))\n        {\n            logger.info(\"Using AwsCandidateHarvester.\");\n            harvesterList.add(new AwsCandidateHarvester());\n        }\n\n        // STUN harvesters\n        List<String> stunServers = config.stunMappingCandidateHarvesterAddresses();\n        if (!stunServers.isEmpty())\n        {\n            // Create STUN harvesters (and wait for all of their discovery to finish).\n            List<StunMappingCandidateHarvester> stunHarvesters = createStunHarvesters(stunServers);\n\n            // We have STUN servers configured, so flag failure if none of them were able to discover an address.\n            stunDiscoveryFailed = stunHarvesters.isEmpty();\n\n            harvesterList.addAll(stunHarvesters);\n        }\n\n        harvesterList = prune(harvesterList);\n        harvesters = harvesterList.toArray(new MappingCandidateHarvester[harvesterList.size()]);\n\n        for (MappingCandidateHarvester harvester : harvesters)\n        {\n            logger.info(\"Using \" + harvester);\n        }\n        logger.info(\"Initialized mapping harvesters (delay=\"\n                        + (System.currentTimeMillis() - start) + \"ms). \"\n                        + \" stunDiscoveryFailed=\" + stunDiscoveryFailed);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/MappingCandidateHarvesters.java", "class_name": "MappingCandidateHarvesters", "class_uri": "src/main/java/org/ice4j/ice/harvest/MappingCandidateHarvesters.java.MappingCandidateHarvesters", "attributes": {"modifiers": "public static synchronized", "marker_annotations": [], "non_marker_annotations": ["public", "static", "synchronized"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nInitializes {@link #harvesters}.\nFirst it reads the configuration and instantiates harvesters accordingly,\nwaiting for their initialization (which may include network communication\nand thus take a long time). Then it removes harvesters which failed to\ninitialize properly and remove any harvesters with duplicate addresses.\n\nThree types of mapping harvesters are supported: NAT (with\npre-configured addresses), AWS and STUN.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/MappingCandidateHarvesters.java.MappingCandidateHarvesters.[List<MappingCandidateHarvester>]prune(List<MappingCandidateHarvester>)", "name": "prune", "arg_nums": 1, "params": [{"name": "harvesters", "type": "List<MappingCandidateHarvester>"}], "return_type": "List<MappingCandidateHarvester>", "signature": "private static List<MappingCandidateHarvester> prune(\n        List<MappingCandidateHarvester> harvesters)", "original_string": "    private static List<MappingCandidateHarvester> prune(\n        List<MappingCandidateHarvester> harvesters)\n    {\n        List<MappingCandidateHarvester> pruned = new LinkedList<>();\n        for (MappingCandidateHarvester harvester : harvesters)\n        {\n            maybeAdd(harvester, pruned);\n        }\n        return pruned;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/MappingCandidateHarvesters.java", "class_name": "MappingCandidateHarvesters", "class_uri": "src/main/java/org/ice4j/ice/harvest/MappingCandidateHarvesters.java.MappingCandidateHarvesters", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "List<MappingCandidateHarvester>", "classes": []}, "docstring": "\nPrunes a list of mapping harvesters, removing the ones without valid\naddresses and those with duplicate addresses.\n@param harvesters the list of harvesters.\n@return the pruned list.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/MappingCandidateHarvesters.java.MappingCandidateHarvesters.[void]maybeAdd(MappingCandidateHarvester,List<MappingCandidateHarvester>)", "name": "maybeAdd", "arg_nums": 2, "params": [{"name": "harvester", "type": "MappingCandidateHarvester"}, {"name": "harvesters", "type": "List<MappingCandidateHarvester>"}], "return_type": "void", "signature": "private static void maybeAdd(\n        MappingCandidateHarvester harvester,\n        List<MappingCandidateHarvester> harvesters)", "original_string": "    private static void maybeAdd(\n        MappingCandidateHarvester harvester,\n        List<MappingCandidateHarvester> harvesters)\n    {\n        TransportAddress face = harvester.getFace();\n        TransportAddress mask = harvester.getMask();\n        if (face == null || mask == null || face.equals(mask))\n        {\n            logger.info(\"Discarding a mapping harvester: \" + harvester);\n            return;\n        }\n\n        for (MappingCandidateHarvester h : harvesters)\n        {\n            if (face.getAddress().equals(h.getFace().getAddress())\n                && mask.getAddress().equals(h.getMask().getAddress()))\n            {\n                logger.info(\"Discarding a mapping harvester with duplicate addresses: \" + harvester + \". Kept: \" + h);\n                return;\n            }\n        }\n\n        harvesters.add(harvester);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/MappingCandidateHarvesters.java", "class_name": "MappingCandidateHarvesters", "class_uri": "src/main/java/org/ice4j/ice/harvest/MappingCandidateHarvesters.java.MappingCandidateHarvesters", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nAdds {@code harvester} to {@code harvesters}, if it has valid addresses\nand {@code harvesters} doesn't already contain a harvester with the same\naddresses.\n@param harvester the harvester to add.\n@param harvesters the list to add to.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/MappingCandidateHarvesters.java.MappingCandidateHarvesters.[List<StunMappingCandidateHarvester>]createStunHarvesters(List<String>)", "name": "createStunHarvesters", "arg_nums": 1, "params": [{"name": "stunServers", "type": "List<String>"}], "return_type": "List<StunMappingCandidateHarvester>", "signature": "private static List<StunMappingCandidateHarvester> createStunHarvesters(@NotNull List<String> stunServers)", "original_string": "    private static List<StunMappingCandidateHarvester> createStunHarvesters(@NotNull List<String> stunServers)\n    {\n        List<StunMappingCandidateHarvester> stunHarvesters = new LinkedList<>();\n\n        List<Callable<StunMappingCandidateHarvester>> tasks = new LinkedList<>();\n\n        // Create a StunMappingCandidateHarvester for each local:remote address pair.\n        List<InetAddress> localAddresses = HostCandidateHarvester.getAllAllowedAddresses();\n        for (String stunServer : stunServers)\n        {\n            String[] addressAndPort = stunServer.split(\":\");\n            if (addressAndPort.length < 2)\n            {\n                logger.severe(\"Failed to parse STUN server address: \" + stunServer);\n                continue;\n            }\n            int port;\n            try\n            {\n                port = Integer.parseInt(addressAndPort[1]);\n            }\n            catch (NumberFormatException nfe)\n            {\n                logger.severe(\"Invalid STUN server port: \" + addressAndPort[1]);\n                continue;\n            }\n\n            TransportAddress remoteAddress\n                = new TransportAddress(\n                addressAndPort[0],\n                port,\n                Transport.UDP);\n\n            for (InetAddress localInetAddress : localAddresses)\n            {\n                if (localInetAddress instanceof Inet6Address)\n                {\n                    // This is disabled, because it is broken for an unknown\n                    // reason and it is not currently needed.\n                    continue;\n                }\n\n                TransportAddress localAddress = new TransportAddress(localInetAddress, 0, Transport.UDP);\n\n                logger.info(\"Using \" + remoteAddress + \" for StunMappingCandidateHarvester (localAddress=\"\n                        + localAddress + \").\");\n                final StunMappingCandidateHarvester stunHarvester\n                    = new StunMappingCandidateHarvester(localAddress, remoteAddress);\n\n                Callable<StunMappingCandidateHarvester> task = () ->\n                {\n                    stunHarvester.discover();\n                    return stunHarvester;\n                };\n                tasks.add(task);\n            }\n        }\n\n        if (tasks.isEmpty())\n        {\n            logger.warning(\"STUN mapping harvesters are configured, but no allowed local addresses were found.\" +\n                    \" Not using STUN.\");\n            return stunHarvesters;\n        }\n\n        // Now run discover() on all created harvesters in parallel and pick the ones which succeeded.\n        ExecutorService es = ExecutorFactory.createFixedThreadPool(tasks.size(), \"ice4j.Harvester-executor-\");\n\n        try\n        {\n            List<Future<StunMappingCandidateHarvester>> futures;\n            try\n            {\n                futures = es.invokeAll(tasks);\n            }\n            catch (InterruptedException ie)\n            {\n                Thread.currentThread().interrupt();\n                return stunHarvesters;\n            }\n\n            for (Future<StunMappingCandidateHarvester> future : futures)\n            {\n                try\n                {\n                    StunMappingCandidateHarvester harvester = future.get();\n\n                    // The STUN server replied successfully.\n                    if (harvester.getMask() != null)\n                    {\n                        stunHarvesters.add(harvester);\n                    }\n                }\n                catch (ExecutionException ee)\n                {\n                    // The harvester failed for some reason, discard it.\n                }\n                catch (InterruptedException ie)\n                {\n                    Thread.currentThread().interrupt();\n                    throw new RuntimeException(ie);\n                }\n            }\n        }\n        finally\n        {\n            es.shutdown();\n        }\n        return stunHarvesters;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/MappingCandidateHarvesters.java", "class_name": "MappingCandidateHarvesters", "class_uri": "src/main/java/org/ice4j/ice/harvest/MappingCandidateHarvesters.java.MappingCandidateHarvesters", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "List<StunMappingCandidateHarvester>", "classes": []}, "docstring": "\nCreates STUN mapping harvesters for each of the given STUN servers, and\nwaits for address discovery to finish for all of them.\n@param stunServers an array of STUN server addresses (ip_address:port\npairs).\n@return  the list of those who were successful in discovering an address.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/MappingCandidateHarvesters.java.MappingCandidateHarvesters.[]MappingCandidateHarvesters()", "name": "MappingCandidateHarvesters", "arg_nums": 0, "params": [], "return_type": "", "signature": "private MappingCandidateHarvesters()", "original_string": "    private MappingCandidateHarvesters()\n    {\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/MappingCandidateHarvesters.java", "class_name": "MappingCandidateHarvesters", "class_uri": "src/main/java/org/ice4j/ice/harvest/MappingCandidateHarvesters.java.MappingCandidateHarvesters", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nPrevent instance creation.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/TrickleCallback.java.TrickleCallback.[void]onIceCandidates(Collection<LocalCandidate>)", "name": "onIceCandidates", "arg_nums": 1, "params": [{"name": "iceCandidates", "type": "Collection<LocalCandidate>"}], "return_type": "void", "signature": "public void onIceCandidates(Collection<LocalCandidate> iceCandidates)", "original_string": "    public void onIceCandidates(Collection<LocalCandidate> iceCandidates);", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/TrickleCallback.java", "class_name": "TrickleCallback", "class_uri": "src/main/java/org/ice4j/ice/harvest/TrickleCallback.java.TrickleCallback", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nNotifies the callback that a new batch of <tt>LocalCandidate</tt>s has\nbeen discovered and should be advertised to the remove party.\n\n@param iceCandidates the newly discovered list of candidates or,\nsimilarly to WebRTC, <tt>null</tt> in case all candidate harvesting is\nnow completed.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/HarvestStatistics.java.HarvestStatistics.[void]startHarvestTiming()", "name": "startHarvestTiming", "arg_nums": 0, "params": [], "return_type": "void", "signature": "protected void startHarvestTiming()", "original_string": "    protected void startHarvestTiming()\n    {\n        harvestCount++;\n        // Remember the start date of this harvester.\n        this.lastStartHarvestingTime = System.currentTimeMillis();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/HarvestStatistics.java", "class_name": "HarvestStatistics", "class_uri": "src/main/java/org/ice4j/ice/harvest/HarvestStatistics.java.HarvestStatistics", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nStarts the harvesting timer. Called when the harvest begins.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/HarvestStatistics.java.HarvestStatistics.[void]stopHarvestTiming(Collection<LocalCandidate>)", "name": "stopHarvestTiming", "arg_nums": 1, "params": [{"name": "harvest", "type": "Collection<LocalCandidate>"}], "return_type": "void", "signature": "protected void stopHarvestTiming(Collection<LocalCandidate> harvest)", "original_string": "    protected void stopHarvestTiming(Collection<LocalCandidate> harvest)\n    {\n        //count total candidates\n        if (harvest != null)\n            stopHarvestTiming(harvest.size());\n        else\n            stopHarvestTiming(0);\n\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/HarvestStatistics.java", "class_name": "HarvestStatistics", "class_uri": "src/main/java/org/ice4j/ice/harvest/HarvestStatistics.java.HarvestStatistics", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nStops the harvesting timer. Called when the harvest ends.\n\n@param harvest the harvest that we just concluded.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/HarvestStatistics.java.HarvestStatistics.[void]stopHarvestTiming(int)", "name": "stopHarvestTiming", "arg_nums": 1, "params": [{"name": "candidateCount", "type": "int"}], "return_type": "void", "signature": "protected void stopHarvestTiming(int candidateCount)", "original_string": "    protected void stopHarvestTiming(int candidateCount)\n    {\n        // Remember the last harvesting time.\n        this.lastHarvestingTime = this.getHarvestDuration();\n        // Stops the current timer (must be done after setting the\n        // lastHarvestingTime).\n        this.lastStartHarvestingTime = -1;\n\n        //count total candidates\n        this.totalCandidateCount += candidateCount;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/HarvestStatistics.java", "class_name": "HarvestStatistics", "class_uri": "src/main/java/org/ice4j/ice/harvest/HarvestStatistics.java.HarvestStatistics", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nStops the harvesting timer. Called when the harvest ends.\n\n@param candidateCount the number of candidates we harvested.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/HarvestStatistics.java.HarvestStatistics.[long]getHarvestDuration()", "name": "getHarvestDuration", "arg_nums": 0, "params": [], "return_type": "long", "signature": "public long getHarvestDuration()", "original_string": "    public long getHarvestDuration()\n    {\n        if (this.lastStartHarvestingTime != -1)\n        {\n            long currentHarvestingTime\n                = System.currentTimeMillis() - lastStartHarvestingTime;\n            // Retest here, while the harvesting may be end while computing the\n            // harvesting time.\n            if (this.lastStartHarvestingTime != -1)\n            {\n                return this.lastHarvestingTime + currentHarvestingTime;\n            }\n        }\n        // If we are ont currently harvesting, then returns the value of the\n        // last harvesting time.\n        return this.lastHarvestingTime;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/HarvestStatistics.java", "class_name": "HarvestStatistics", "class_uri": "src/main/java/org/ice4j/ice/harvest/HarvestStatistics.java.HarvestStatistics", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "long", "classes": []}, "docstring": "\nReturns the current harvesting time in ms. If this harvester is not\ncurrently harvesting, then returns the value of the last harvesting time.\n0 if this harvester has never harvested.\n\n@return The current harvesting time in ms.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/HarvestStatistics.java.HarvestStatistics.[int]getTotalCandidateCount()", "name": "getTotalCandidateCount", "arg_nums": 0, "params": [], "return_type": "int", "signature": "public int getTotalCandidateCount()", "original_string": "    public int getTotalCandidateCount()\n    {\n        return totalCandidateCount;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/HarvestStatistics.java", "class_name": "HarvestStatistics", "class_uri": "src/main/java/org/ice4j/ice/harvest/HarvestStatistics.java.HarvestStatistics", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\nReturns the number of candidates gathered  by the associated harvester.\n\n@return the total number of candidates gatherer by this harvester.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/HarvestStatistics.java.HarvestStatistics.[int]getHarvestCount()", "name": "getHarvestCount", "arg_nums": 0, "params": [], "return_type": "int", "signature": "public int getHarvestCount()", "original_string": "    public int getHarvestCount()\n    {\n        return this.harvestCount;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/HarvestStatistics.java", "class_name": "HarvestStatistics", "class_uri": "src/main/java/org/ice4j/ice/harvest/HarvestStatistics.java.HarvestStatistics", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\nReturns the number of harvests that the harvester associated with these\nstatistics has completed so far.\n\n@return the number of harvests that the associated harvester has engaged\nin.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/HarvestStatistics.java.HarvestStatistics.[void]setName(String)", "name": "setName", "arg_nums": 1, "params": [{"name": "harvesterName", "type": "String"}], "return_type": "void", "signature": "protected void setName(String harvesterName)", "original_string": "    protected void setName(String harvesterName)\n    {\n        this.harvesterName = harvesterName;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/HarvestStatistics.java", "class_name": "HarvestStatistics", "class_uri": "src/main/java/org/ice4j/ice/harvest/HarvestStatistics.java.HarvestStatistics", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSpecifies the name of the associated harvester.\n\n@param harvesterName the name of the associated harvester.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/HarvestStatistics.java.HarvestStatistics.[String]getName()", "name": "getName", "arg_nums": 0, "params": [], "return_type": "String", "signature": "public String getName()", "original_string": "    public String getName()\n    {\n        return harvesterName;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/HarvestStatistics.java", "class_name": "HarvestStatistics", "class_uri": "src/main/java/org/ice4j/ice/harvest/HarvestStatistics.java.HarvestStatistics", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns the name of the associated harvester.\n\n@return the name of the associated harvester.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/HarvestStatistics.java.HarvestStatistics.[String]toString()", "name": "toString", "arg_nums": 0, "params": [], "return_type": "String", "signature": "@Override\n    public String toString()", "original_string": "    @Override\n    public String toString()\n    {\n        return harvesterName\n            + \": time=\"+getHarvestDuration()\n            + \"ms harvests=\"+getHarvestCount()\n            +\" candidates=\" + getTotalCandidateCount() ;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/HarvestStatistics.java", "class_name": "HarvestStatistics", "class_uri": "src/main/java/org/ice4j/ice/harvest/HarvestStatistics.java.HarvestStatistics", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns a string representation of these statistics in a concise format.\n\n@return a string representation of these stats.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/GoogleTurnCandidateHarvest.java.GoogleTurnCandidateHarvest.[]GoogleTurnCandidateHarvest(GoogleTurnCandidateHarvester,HostCandidate,String)", "name": "GoogleTurnCandidateHarvest", "arg_nums": 3, "params": [{"name": "harvester", "type": "GoogleTurnCandidateHarvester"}, {"name": "hostCandidate", "type": "HostCandidate"}, {"name": "password", "type": "String"}], "return_type": "", "signature": "public GoogleTurnCandidateHarvest(\n            GoogleTurnCandidateHarvester harvester,\n            HostCandidate hostCandidate,\n            String password)", "original_string": "    public GoogleTurnCandidateHarvest(\n            GoogleTurnCandidateHarvester harvester,\n            HostCandidate hostCandidate,\n            String password)\n    {\n        super(harvester, hostCandidate);\n        this.password = password;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/GoogleTurnCandidateHarvest.java", "class_name": "GoogleTurnCandidateHarvest", "class_uri": "src/main/java/org/ice4j/ice/harvest/GoogleTurnCandidateHarvest.java.GoogleTurnCandidateHarvest", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>TurnCandidateHarvest</tt> which is to represent the\nharvesting of TURN <tt>Candidate</tt>s for a specific\n<tt>HostCandidate</tt> performed by a specific\n<tt>TurnCandidateHarvester</tt>.\n\n@param harvester the <tt>TurnCandidateHarvester</tt> which is performing\nthe TURN harvesting\n@param hostCandidate the <tt>HostCandidate</tt> for which TURN\n<tt>Candidate</tt>s are to be harvested\n@param password The gingle candidates password necessary to use this TURN\nserver.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/GoogleTurnCandidateHarvest.java.GoogleTurnCandidateHarvest.[void]createCandidates(Response)", "name": "createCandidates", "arg_nums": 1, "params": [{"name": "response", "type": "Response"}], "return_type": "void", "signature": "@Override\n    protected void createCandidates(Response response)", "original_string": "    @Override\n    protected void createCandidates(Response response)\n    {\n        createRelayedCandidate(response);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/GoogleTurnCandidateHarvest.java", "class_name": "GoogleTurnCandidateHarvest", "class_uri": "src/main/java/org/ice4j/ice/harvest/GoogleTurnCandidateHarvest.java.GoogleTurnCandidateHarvest", "attributes": {"modifiers": "@Override\n    protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCreates new <tt>Candidate</tt>s determined by a specific STUN\n<tt>Response</tt>.\n\n@param response the received STUN <tt>Response</tt>\n@see StunCandidateHarvest#createCandidates(Response)\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/GoogleTurnCandidateHarvest.java.GoogleTurnCandidateHarvest.[void]createRelayedCandidate(Response)", "name": "createRelayedCandidate", "arg_nums": 1, "params": [{"name": "response", "type": "Response"}], "return_type": "void", "signature": "private void createRelayedCandidate(Response response)", "original_string": "    private void createRelayedCandidate(Response response)\n    {\n        Attribute attribute\n            = response.getAttribute(Attribute.MAPPED_ADDRESS);\n\n        if (attribute != null)\n        {\n            TransportAddress relayedAddress\n                = ((MappedAddressAttribute) attribute).getAddress();\n\n            if (harvester.stunServer.getTransport() == Transport.TCP)\n            {\n                relayedAddress = new TransportAddress(\n                    relayedAddress.getAddress(),\n                    harvester.stunServer.getPort(),\n                    //relayedAddress.getPort() - 1,\n                    Transport.TCP);\n            }\n            GoogleRelayedCandidate relayedCandidate\n                = createRelayedCandidate(\n                        relayedAddress,\n                        getMappedAddress(response));\n\n            if (relayedCandidate != null)\n            {\n                /*\n                 * The ICE connectivity checks will utilize STUN on the\n                 * (application-purposed) socket of the RelayedCandidate and\n                 * will not add it to the StunStack so we have to do it.\n                 */\n                harvester.getStunStack().addSocket(\n                        relayedCandidate.getStunSocket(null));\n\n                // Make the relayed candidate's socket available for reading\n                // by the component.\n                IceSocketWrapper candidateSocket\n                    = relayedCandidate.getCandidateIceSocketWrapper();\n\n                ComponentSocket componentSocket\n                    = relayedCandidate.getParentComponent().getComponentSocket();\n                if (componentSocket != null)\n                {\n                    componentSocket.add(candidateSocket);\n                }\n\n                addCandidate(relayedCandidate);\n            }\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/GoogleTurnCandidateHarvest.java", "class_name": "GoogleTurnCandidateHarvest", "class_uri": "src/main/java/org/ice4j/ice/harvest/GoogleTurnCandidateHarvest.java.GoogleTurnCandidateHarvest", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCreates a <tt>RelayedCandidate</tt> using the\n<tt>XOR-RELAYED-ADDRESS</tt> attribute in a specific STUN\n<tt>Response</tt> for the actual <tt>TransportAddress</tt> of the new\ncandidate. If the message is malformed and/or does not contain the\ncorresponding attribute, this method simply has no effect.\n\n@param response the STUN <tt>Response</tt> which is supposed to contain\nthe address we should use for the new candidate\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/GoogleTurnCandidateHarvest.java.GoogleTurnCandidateHarvest.[GoogleRelayedCandidate]createRelayedCandidate(TransportAddress,TransportAddress)", "name": "createRelayedCandidate", "arg_nums": 2, "params": [{"name": "transportAddress", "type": "TransportAddress"}, {"name": "mappedAddress", "type": "TransportAddress"}], "return_type": "GoogleRelayedCandidate", "signature": "protected GoogleRelayedCandidate createRelayedCandidate(\n            TransportAddress transportAddress,\n            TransportAddress mappedAddress)", "original_string": "    protected GoogleRelayedCandidate createRelayedCandidate(\n            TransportAddress transportAddress,\n            TransportAddress mappedAddress)\n    {\n        GoogleRelayedCandidate candidate =\n            new GoogleRelayedCandidate(\n                    transportAddress,\n                    this,\n                    mappedAddress,\n                    harvester.getShortTermCredentialUsername(),\n                    this.password);\n\n        candidate.setUfrag(harvester.getShortTermCredentialUsername());\n        return candidate;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/GoogleTurnCandidateHarvest.java", "class_name": "GoogleTurnCandidateHarvest", "class_uri": "src/main/java/org/ice4j/ice/harvest/GoogleTurnCandidateHarvest.java.GoogleTurnCandidateHarvest", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "GoogleRelayedCandidate", "classes": []}, "docstring": "\nCreates a new <tt>RelayedCandidate</tt> instance which is to represent a\nspecific <tt>TransportAddress</tt> harvested through\n{@link #hostCandidate} and the TURN server associated with\n{@link #harvester}.\n\n@param transportAddress the <tt>TransportAddress</tt> to be represented\nby the new <tt>RelayedCandidate</tt> instance\n@param mappedAddress the mapped <tt>TransportAddress</tt> reported by the\nTURN server with the delivery of the relayed <tt>transportAddress</tt> to\nbe represented by the new <tt>RelayedCandidate</tt> instance\n@return a new <tt>RelayedCandidate</tt> instance which represents the\nspecified <tt>TransportAddress</tt> harvested through\n{@link #hostCandidate} and the TURN server associated with\n{@link #harvester}\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/GoogleTurnCandidateHarvest.java.GoogleTurnCandidateHarvest.[Request]createRequestToStartResolvingCandidate()", "name": "createRequestToStartResolvingCandidate", "arg_nums": 0, "params": [], "return_type": "Request", "signature": "@Override\n    protected Request createRequestToStartResolvingCandidate()", "original_string": "    @Override\n    protected Request createRequestToStartResolvingCandidate()\n    {\n        if (requestToStartResolvingCandidate == null)\n        {\n            requestToStartResolvingCandidate\n                = MessageFactory.createGoogleAllocateRequest(\n                        harvester.getShortTermCredentialUsername());\n\n            return requestToStartResolvingCandidate;\n        }\n        else\n            return null;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/GoogleTurnCandidateHarvest.java", "class_name": "GoogleTurnCandidateHarvest", "class_uri": "src/main/java/org/ice4j/ice/harvest/GoogleTurnCandidateHarvest.java.GoogleTurnCandidateHarvest", "attributes": {"modifiers": "@Override\n    protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Request", "classes": []}, "docstring": "\nCreates a new <tt>Request</tt> which is to be sent to\n{@link TurnCandidateHarvester#stunServer} in order to start resolving\n{@link #hostCandidate}.\n\n@return a new <tt>Request</tt> which is to be sent to\n{@link TurnCandidateHarvester#stunServer} in order to start resolving\n{@link #hostCandidate}\n@see StunCandidateHarvest#createRequestToStartResolvingCandidate()\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/GoogleTurnCandidateHarvest.java.GoogleTurnCandidateHarvest.[boolean]addShortTermCredentialAttributes(Request)", "name": "addShortTermCredentialAttributes", "arg_nums": 1, "params": [{"name": "request", "type": "Request"}], "return_type": "boolean", "signature": "@Override\n    protected boolean addShortTermCredentialAttributes(Request request)", "original_string": "    @Override\n    protected boolean addShortTermCredentialAttributes(Request request)\n    {\n        return false;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/GoogleTurnCandidateHarvest.java", "class_name": "GoogleTurnCandidateHarvest", "class_uri": "src/main/java/org/ice4j/ice/harvest/GoogleTurnCandidateHarvest.java.GoogleTurnCandidateHarvest", "attributes": {"modifiers": "@Override\n    protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nAdds the <tt>Attribute</tt>s to a specific <tt>Request</tt> which support\nthe STUN short-term credential mechanism if the mechanism in question is\nutilized by this <tt>StunCandidateHarvest</tt> (i.e. by the associated\n<tt>StunCandidateHarvester</tt>).\n\n@param request the <tt>Request</tt> to which to add the\n<tt>Attribute</tt>s supporting the STUN short-term credential mechanism\nif the mechanism in question is utilized by this\n<tt>StunCandidateHarvest</tt>\n@return <tt>true</tt> if the STUN short-term credential mechanism is\nactually utilized by this <tt>StunCandidateHarvest</tt> for the specified\n<tt>request</tt>; otherwise, <tt>false</tt>\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/GoogleTurnCandidateHarvest.java.GoogleTurnCandidateHarvest.[boolean]completedResolvingCandidate(Request,Response)", "name": "completedResolvingCandidate", "arg_nums": 2, "params": [{"name": "request", "type": "Request"}, {"name": "response", "type": "Response"}], "return_type": "boolean", "signature": "@Override\n    protected boolean completedResolvingCandidate(\n            Request request,\n            Response response)", "original_string": "    @Override\n    protected boolean completedResolvingCandidate(\n            Request request,\n            Response response)\n    {\n        if ((response == null)\n                || (!response.isSuccessResponse()\n                        && (request.getMessageType()\n                                == Message.ALLOCATE_REQUEST)))\n        {\n            try\n            {\n                if (startResolvingCandidate())\n                    return false;\n            }\n            catch (Exception ex)\n            {\n                /*\n                 * Complete the harvesting of Candidates for hostCandidate\n                 * because the new attempt has just failed.\n                 */\n            }\n        }\n        return super.completedResolvingCandidate(request, response);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/GoogleTurnCandidateHarvest.java", "class_name": "GoogleTurnCandidateHarvest", "class_uri": "src/main/java/org/ice4j/ice/harvest/GoogleTurnCandidateHarvest.java.GoogleTurnCandidateHarvest", "attributes": {"modifiers": "@Override\n    protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nCompletes the harvesting of <tt>Candidate</tt>s for\n{@link #hostCandidate}. Notifies {@link #harvester} about the completion\nof the harvesting of <tt>Candidate</tt> for <tt>hostCandidate</tt>\nperformed by this <tt>StunCandidateHarvest</tt>.\n\n@param request the <tt>Request</tt> sent by this\n<tt>StunCandidateHarvest</tt> with which the harvesting of\n<tt>Candidate</tt>s for <tt>hostCandidate</tt> has completed\n@param response the <tt>Response</tt> received by this\n<tt>StunCandidateHarvest</tt>, if any, with which the harvesting of\n<tt>Candidate</tt>s for <tt>hostCandidate</tt> has completed\n@return <tt>true</tt> if the harvesting of <tt>Candidate</tt>s for\n<tt>hostCandidate</tt> performed by this <tt>StunCandidateHarvest</tt>\nhas completed; otherwise, <tt>false</tt>\n@see StunCandidateHarvest#completedResolvingCandidate(Request, Response)\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/GoogleTurnCandidateHarvest.java.GoogleTurnCandidateHarvest.[void]close(GoogleRelayedCandidateDatagramSocket)", "name": "close", "arg_nums": 1, "params": [{"name": "relayedCandidateSocket", "type": "GoogleRelayedCandidateDatagramSocket"}], "return_type": "void", "signature": "public void close(\n            GoogleRelayedCandidateDatagramSocket relayedCandidateSocket)", "original_string": "    public void close(\n            GoogleRelayedCandidateDatagramSocket relayedCandidateSocket)\n    {\n        /*\n         * FIXME As far as logic goes, it seems that it is possible to send a\n         * TURN Refresh, cancel the STUN keep-alive functionality here and only\n         * then receive the response to the TURN Refresh which will enable the\n         * STUN keep-alive functionality again.\n         */\n        setSendKeepAliveMessageInterval(\n                SEND_KEEP_ALIVE_MESSAGE_INTERVAL_NOT_SPECIFIED);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/GoogleTurnCandidateHarvest.java", "class_name": "GoogleTurnCandidateHarvest", "class_uri": "src/main/java/org/ice4j/ice/harvest/GoogleTurnCandidateHarvest.java.GoogleTurnCandidateHarvest", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nNotifies this <tt>TurnCandidateHarvest</tt> that a specific\n<tt>RelayedCandidateDatagramSocket</tt> is closing and that this instance\nis to delete the associated TURN Allocation.\n<p>\n<b>Note</b>: The method is part of the internal API of\n<tt>RelayedCandidateDatagramSocket</tt> and <tt>TurnCandidateHarvest</tt>\nand is not intended for public use.\n</p>\n\n@param relayedCandidateSocket the <tt>RelayedCandidateDatagramSocket</tt>\nwhich notifies this instance and which requests that the associated TURN\nAllocation be deleted\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/GoogleTurnCandidateHarvest.java.GoogleTurnCandidateHarvest.[boolean]processErrorOrFailure(Response,Request,TransactionID)", "name": "processErrorOrFailure", "arg_nums": 3, "params": [{"name": "response", "type": "Response"}, {"name": "request", "type": "Request"}, {"name": "transactionID", "type": "TransactionID"}], "return_type": "boolean", "signature": "@Override\n    protected boolean processErrorOrFailure(\n            Response response,\n            Request request,\n            TransactionID transactionID)", "original_string": "    @Override\n    protected boolean processErrorOrFailure(\n            Response response,\n            Request request,\n            TransactionID transactionID)\n    {\n        logger.info(\"Google TURN processErrorOrFailure\");\n        /*\n         * TurnCandidateHarvest uses the applicationData of TransactionID to\n         * deliver the results of Requests sent by\n         * RelayedCandidateDatagramSocket back to it.\n         */\n        Object applicationData = transactionID.getApplicationData();\n\n        if ((applicationData instanceof GoogleRelayedCandidateDatagramSocket)\n                && ((RelayedCandidateDatagramSocket) applicationData)\n                        .processErrorOrFailure(response, request))\n            return true;\n        else if ((applicationData instanceof\n            GoogleRelayedCandidateDatagramSocket)\n            && ((RelayedCandidateDatagramSocket) applicationData)\n                    .processErrorOrFailure(response, request))\n        return true;\n\n        return super.processErrorOrFailure(response, request, transactionID);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/GoogleTurnCandidateHarvest.java", "class_name": "GoogleTurnCandidateHarvest", "class_uri": "src/main/java/org/ice4j/ice/harvest/GoogleTurnCandidateHarvest.java.GoogleTurnCandidateHarvest", "attributes": {"modifiers": "@Override\n    protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nNotifies this <tt>StunCandidateHarvest</tt> that a specific\n<tt>Request</tt> has either received an error <tt>Response</tt> or has\nfailed to receive any <tt>Response</tt>.\n\n@param response the error <tt>Response</tt> which has been received for\n<tt>request</tt>\n@param request the <tt>Request</tt> to which <tt>Response</tt> responds\n@param transactionID the <tt>TransactionID</tt> of <tt>response</tt> and\n<tt>request</tt> because <tt>response</tt> and <tt>request</tt> only have\nit as a <tt>byte</tt> array and <tt>TransactionID</tt> is required for\nthe <tt>applicationData</tt> property value\n@return <tt>true</tt> if the error or failure condition has been\nprocessed and this instance can continue its execution (e.g. the\nresolution of the candidate) as if it was expected; otherwise,\n<tt>false</tt>\n@see StunCandidateHarvest#processErrorOrFailure(Response, Request,\nTransactionID)\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/GoogleTurnCandidateHarvest.java.GoogleTurnCandidateHarvest.[void]processSuccess(Response,Request,TransactionID)", "name": "processSuccess", "arg_nums": 3, "params": [{"name": "response", "type": "Response"}, {"name": "request", "type": "Request"}, {"name": "transactionID", "type": "TransactionID"}], "return_type": "void", "signature": "@Override\n    protected void processSuccess(\n            Response response,\n            Request request,\n            TransactionID transactionID)", "original_string": "    @Override\n    protected void processSuccess(\n            Response response,\n            Request request,\n            TransactionID transactionID)\n    {\n        super.processSuccess(response, request, transactionID);\n\n        LifetimeAttribute lifetimeAttribute;\n        int lifetime /* minutes */ = -1;\n\n        switch (response.getMessageType())\n        {\n        case Message.ALLOCATE_RESPONSE:\n            // The default lifetime of an allocation is 10 minutes.\n            // The default lifetime of an allocation is 10 minutes.\n            lifetimeAttribute\n                = (LifetimeAttribute) response.getAttribute(Attribute.LIFETIME);\n            lifetime\n                = (lifetimeAttribute == null)\n                    ? (10 * 60)\n                    : lifetimeAttribute.getLifetime();\n            logger.info(\"Successful Google TURN allocate\");\n            break;\n        default:\n            break;\n        }\n\n        if (lifetime >= 0)\n        {\n            setSendKeepAliveMessageInterval(\n                    /* milliseconds */ 1000L * lifetime);\n        }\n\n        /*\n         * TurnCandidateHarvest uses the applicationData of TransactionID to\n         * deliver the results of Requests sent by\n         * RelayedCandidateDatagramSocket back to it.\n         */\n        Object applicationData = transactionID.getApplicationData();\n\n        if (applicationData instanceof GoogleRelayedCandidateDatagramSocket)\n        {\n            ((GoogleRelayedCandidateDatagramSocket) applicationData)\n                .processSuccess(response, request);\n        }\n        else if (applicationData instanceof GoogleRelayedCandidateSocket)\n        {\n            ((GoogleRelayedCandidateSocket) applicationData)\n                .processSuccess(response, request);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/GoogleTurnCandidateHarvest.java", "class_name": "GoogleTurnCandidateHarvest", "class_uri": "src/main/java/org/ice4j/ice/harvest/GoogleTurnCandidateHarvest.java.GoogleTurnCandidateHarvest", "attributes": {"modifiers": "@Override\n    protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nHandles a specific STUN success <tt>Response</tt> to a specific STUN\n<tt>Request</tt>.\n\n@param response the received STUN success <tt>Response</tt> which is to\nbe handled\n@param request the STUN <tt>Request</tt> to which <tt>response</tt>\nresponds\n@param transactionID the <tt>TransactionID</tt> of <tt>response</tt> and\n<tt>request</tt> because <tt>response</tt> and <tt>request</tt> only have\nit as a <tt>byte</tt> array and <tt>TransactionID</tt> is required for\nthe <tt>applicationData</tt> property value\n@see StunCandidateHarvest#processSuccess(Response, Request,\nTransactionID)\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/AbstractUdpListener.java.AbstractUdpListener.[List<TransportAddress>]getAllowedAddresses(int)", "name": "getAllowedAddresses", "arg_nums": 1, "params": [{"name": "port", "type": "int"}], "return_type": "List<TransportAddress>", "signature": "public static List<TransportAddress> getAllowedAddresses(int port)", "original_string": "    public static List<TransportAddress> getAllowedAddresses(int port)\n    {\n        List<TransportAddress> addresses = new LinkedList<>();\n        for (InetAddress address : HostCandidateHarvester.getAllAllowedAddresses())\n        {\n            addresses.add(new TransportAddress(address, port, Transport.UDP));\n        }\n\n        return addresses;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/AbstractUdpListener.java", "class_name": "AbstractUdpListener", "class_uri": "src/main/java/org/ice4j/ice/harvest/AbstractUdpListener.java.AbstractUdpListener", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "List<TransportAddress>", "classes": []}, "docstring": "\nReturns the list of {@link TransportAddress}es, one for each allowed IP\naddress found on each allowed network interface, with the given port.\n\n@param port the UDP port number.\n@return the list of allowed transport addresses.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/AbstractUdpListener.java.AbstractUdpListener.[String]getUfrag(byte[],int,int)", "name": "getUfrag", "arg_nums": 3, "params": [{"name": "buf", "type": "byte[]"}, {"name": "off", "type": "int"}, {"name": "len", "type": "int"}], "return_type": "String", "signature": "static String getUfrag(byte[] buf, int off, int len)", "original_string": "    static String getUfrag(byte[] buf, int off, int len)\n    {\n        // RFC5389, Section 6:\n        // All STUN messages MUST start with a 20-byte header followed by zero\n        // or more Attributes.\n        if (buf == null || buf.length < off + len || len < 20)\n        {\n            return null;\n        }\n\n        // RFC5389, Section 6:\n        // The magic cookie field MUST contain the fixed value 0x2112A442 in\n        // network byte order.\n        if ( !( (buf[off + 4] & 0xFF) == 0x21 &&\n            (buf[off + 5] & 0xFF) == 0x12 &&\n            (buf[off + 6] & 0xFF) == 0xA4 &&\n            (buf[off + 7] & 0xFF) == 0x42))\n        {\n            if (logger.isLoggable(Level.FINE))\n            {\n                logger.fine(\"Not a STUN packet, magic cookie not found.\");\n            }\n            return null;\n        }\n\n        try\n        {\n            Message stunMessage = Message.decode(buf, off, len);\n\n            if (stunMessage.getMessageType()\n                != Message.BINDING_REQUEST)\n            {\n                return null;\n            }\n\n            UsernameAttribute usernameAttribute\n                = (UsernameAttribute)\n                stunMessage.getAttribute(Attribute.USERNAME);\n            if (usernameAttribute == null)\n                return null;\n\n            String usernameString\n                = new String(usernameAttribute.getUsername());\n            return usernameString.split(\":\")[0];\n        }\n        catch (Exception e)\n        {\n            // Catch everything. We are going to log, and then drop the packet\n            // anyway.\n            if (logger.isLoggable(Level.FINE))\n            {\n                logger.fine(\"Failed to extract local ufrag: \" + e);\n            }\n        }\n\n        return null;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/AbstractUdpListener.java", "class_name": "AbstractUdpListener", "class_uri": "src/main/java/org/ice4j/ice/harvest/AbstractUdpListener.java.AbstractUdpListener", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nTries to parse the bytes in <tt>buf</tt> at offset <tt>off</tt> (and\nlength <tt>len</tt>) as a STUN Binding Request message. If successful,\nlooks for a USERNAME attribute and returns the local username fragment\npart (see RFC5245 Section 7.1.2.3).\nIn case of any failure returns <tt>null</tt>.\n\n@param buf the bytes.\n@param off the offset.\n@param len the length.\n@return the local ufrag from the USERNAME attribute of the STUN message\ncontained in <tt>buf</tt>, or <tt>null</tt>.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/AbstractUdpListener.java.AbstractUdpListener.[]AbstractUdpListener(TransportAddress)", "name": "AbstractUdpListener", "arg_nums": 1, "params": [{"name": "localAddress", "type": "TransportAddress"}], "return_type": "", "signature": "protected AbstractUdpListener(TransportAddress localAddress)", "original_string": "    protected AbstractUdpListener(TransportAddress localAddress)\n        throws IOException\n    {\n        TransportAddress tempAddress = localAddress;\n\n        boolean bindWildcard = StackProperties.getBoolean(\n                StackProperties.BIND_WILDCARD,\n                false);\n\n        if (bindWildcard)\n        {\n            tempAddress = new TransportAddress(\n                                        (InetAddress) null,\n                                        localAddress.getPort(),\n                                        localAddress.getTransport()\n                                );\n        }\n\n        socket = new DatagramSocket( tempAddress );\n\n        Integer receiveBufferSize = config.udpReceiveBufferSize();\n        if (receiveBufferSize != null)\n        {\n            socket.setReceiveBufferSize(receiveBufferSize);\n        }\n\n        /* Update the port number if needed. */\n        if (localAddress.getPort() == 0)\n        {\n            tempAddress = new TransportAddress(\n                    tempAddress.getAddress(),\n                    socket.getLocalPort(),\n                    tempAddress.getTransport()\n            );\n        }\n        this.localAddress = tempAddress;\n\n        String logMessage\n            = \"Initialized AbstractUdpListener with address \" + this.localAddress;\n        logMessage += \". Receive buffer size \" + socket.getReceiveBufferSize();\n        if (receiveBufferSize != null)\n        {\n            logMessage += \" (asked for \" + receiveBufferSize + \")\";\n        }\n        logger.info(logMessage);\n\n        thread = new Thread(() ->\n        {\n            if (USE_PUSH_API)\n            {\n                AbstractUdpListener.this.runInHarvesterThreadPush();\n            }\n            else\n            {\n                AbstractUdpListener.this.runInHarvesterThread();\n            }\n        });\n\n        thread.setName(AbstractUdpListener.class.getName() + \" thread for \" + this.localAddress);\n        thread.setDaemon(true);\n        thread.start();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/AbstractUdpListener.java", "class_name": "AbstractUdpListener", "class_uri": "src/main/java/org/ice4j/ice/harvest/AbstractUdpListener.java.AbstractUdpListener", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>SinglePortUdpHarvester</tt> instance which is to\nbind on the specified local address.\n@param localAddress the address to bind to. If the port is 0 an ephemeral port will be chosen by the OS and the\n                    AbstractUdpListener.localAddress will reflect the allocated port.\n@throws IOException if initialization fails.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/AbstractUdpListener.java.AbstractUdpListener.[TransportAddress]getLocalAddress()", "name": "getLocalAddress", "arg_nums": 0, "params": [], "return_type": "TransportAddress", "signature": "public TransportAddress getLocalAddress()", "original_string": "    public TransportAddress getLocalAddress()\n    {\n        return localAddress;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/AbstractUdpListener.java", "class_name": "AbstractUdpListener", "class_uri": "src/main/java/org/ice4j/ice/harvest/AbstractUdpListener.java.AbstractUdpListener", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "TransportAddress", "classes": []}, "docstring": ""}, {"uris": "src/main/java/org/ice4j/ice/harvest/AbstractUdpListener.java.AbstractUdpListener.[void]close()", "name": "close", "arg_nums": 0, "params": [], "return_type": "void", "signature": "public void close()", "original_string": "    public void close()\n    {\n        close = true;\n        socket.close(); // causes socket#receive to stop blocking.\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/AbstractUdpListener.java", "class_name": "AbstractUdpListener", "class_uri": "src/main/java/org/ice4j/ice/harvest/AbstractUdpListener.java.AbstractUdpListener", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTriggers the termination of the threads of this instance.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/AbstractUdpListener.java.AbstractUdpListener.[void]runInHarvesterThread()", "name": "runInHarvesterThread", "arg_nums": 0, "params": [], "return_type": "void", "signature": "private void runInHarvesterThread()", "original_string": "    private void runInHarvesterThread()\n    {\n        Buffer buf;\n        DatagramPacket pkt = null;\n        MySocket destinationSocket;\n        InetSocketAddress remoteAddress;\n\n        do\n        {\n            if (close)\n            {\n                break;\n            }\n\n            buf = getFreeBuffer();\n\n            if (pkt == null)\n                pkt = new DatagramPacket(buf.getBuffer(), 0, buf.getBuffer().length);\n            else\n                pkt.setData(buf.getBuffer(), 0, buf.getBuffer().length);\n\n            try\n            {\n                socket.receive(pkt);\n            }\n            catch (IOException ioe)\n            {\n                if (!close)\n                {\n                    logger.severe(\"Failed to receive from socket: \" + ioe);\n                }\n                break;\n            }\n            buf.setOffset(pkt.getOffset());\n            buf.setLength(pkt.getLength());\n\n\n            remoteAddress = (InetSocketAddress) pkt.getSocketAddress();\n            destinationSocket = sockets.get(remoteAddress);\n            if (destinationSocket != null)\n            {\n                //make 'pkt' available for reading through destinationSocket\n                destinationSocket.addBuffer(buf);\n            }\n            else\n            {\n                // Packet from an unknown source. Is it a STUN Binding Request?\n                String ufrag = getUfrag(buf.getBuffer(), buf.getOffset(), buf.getLength());\n                if (ufrag == null)\n                {\n                    // Not a STUN Binding Request or doesn't have a valid\n                    // USERNAME attribute. Drop it.\n                    continue;\n                }\n\n                MySocket newSocket = maybeAcceptNewSession(buf, remoteAddress, ufrag);\n                if (newSocket == null)\n                {\n                    pool.offer(buf);\n                }\n                else\n                {\n                    newSocket.addBuffer(buf);\n                }\n            }\n        }\n        while (true);\n\n        // now clean up and exit\n        for (MySocket candidateSocket : new ArrayList<>(sockets.values()))\n        {\n            candidateSocket.close();\n        }\n        socket.close();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/AbstractUdpListener.java", "class_name": "AbstractUdpListener", "class_uri": "src/main/java/org/ice4j/ice/harvest/AbstractUdpListener.java.AbstractUdpListener", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nPerpetually reads datagrams from {@link #socket} and handles them\naccordingly.\n\nIt is important that this blocks are little as possible (except on\nsocket.receive(), of course),  because it could potentially delay the\nreception of both ICE and media packets for the whole application.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/AbstractUdpListener.java.AbstractUdpListener.[void]runInHarvesterThreadPush()", "name": "runInHarvesterThreadPush", "arg_nums": 0, "params": [], "return_type": "void", "signature": "private void runInHarvesterThreadPush()", "original_string": "    private void runInHarvesterThreadPush()\n    {\n        DatagramPacket pkt = new DatagramPacket(new byte[1500], 0, 1500);\n        MySocket destinationSocket;\n        InetSocketAddress remoteAddress;\n        Clock clock = Clock.systemUTC();\n        Instant receivedTime;\n\n        do\n        {\n            if (close)\n            {\n                break;\n            }\n\n            pkt.setData(pkt.getData(), 0, pkt.getData().length);\n\n            try\n            {\n                socket.receive(pkt);\n                receivedTime = clock.instant();\n            }\n            catch (IOException ioe)\n            {\n                if (!close)\n                {\n                    logger.severe(\"Failed to receive from socket: \" + ioe);\n                }\n                break;\n            }\n\n            remoteAddress = (InetSocketAddress) pkt.getSocketAddress();\n            destinationSocket = sockets.get(remoteAddress);\n            if (destinationSocket == null)\n            {\n                // Packet from an unknown source. Is it a STUN Binding Request?\n                String ufrag = getUfrag(pkt.getData(), pkt.getOffset(), pkt.getLength());\n                if (ufrag == null)\n                {\n                    // Not a STUN Binding Request or doesn't have a valid USERNAME attribute. Drop it.\n                    continue;\n                }\n\n                Buffer buffer = bufferFromPacket(pkt, receivedTime);\n                MySocket newSocket = maybeAcceptNewSession(buffer, remoteAddress, ufrag);\n                if (newSocket == null)\n                {\n                    BufferPool.returnBuffer.invoke(buffer);\n                }\n                else\n                {\n                    newSocket.addBuffer(buffer);\n                }\n            }\n            else\n            {\n                Buffer buf = bufferFromPacket(pkt, receivedTime);\n                if (StunDatagramPacketFilter.isStunPacket(pkt))\n                {\n                    // STUN packets are made available to the DatagramSocket-based API used by ice4j internally.\n                    destinationSocket.addBuffer(buf);\n                }\n                else\n                {\n                    // Payload goes through the push API.\n                    destinationSocket.bufferHandler.handleBuffer(buf);\n                }\n            }\n        }\n        while (true);\n\n        // now clean up and exit\n        for (MySocket candidateSocket : new ArrayList<>(sockets.values()))\n        {\n            candidateSocket.close();\n        }\n        socket.close();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/AbstractUdpListener.java", "class_name": "AbstractUdpListener", "class_uri": "src/main/java/org/ice4j/ice/harvest/AbstractUdpListener.java.AbstractUdpListener", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nRead packets from the socket and forward them via the push API. Note that the memory model here is different\nthan the other case. Specifically, we:\n1. Receive from {@link #socket} into a fixed buffer\n2. Obtain a buffer of the required size using {@link BufferPool#getBuffer}\n3. Copy the data into the buffer and either\n3.1 Call the associated {@link BufferHandler} if the packet is payload\n3.2 Make the packet available to the STUN socket if it's STUN\n\nThe only difference in the STUN case is that we take responsibility to return the buffer using\n{@link BufferPool#returnBuffer} afterwards.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/AbstractUdpListener.java.AbstractUdpListener.[Buffer]bufferFromPacket(DatagramPacket,Instant)", "name": "bufferFromPacket", "arg_nums": 2, "params": [{"name": "p", "type": "DatagramPacket"}, {"name": "receivedTime", "type": "Instant"}], "return_type": "Buffer", "signature": "private Buffer bufferFromPacket(DatagramPacket p, Instant receivedTime)", "original_string": "    private Buffer bufferFromPacket(DatagramPacket p, Instant receivedTime)\n    {\n        int off = BYTES_TO_LEAVE_AT_START_OF_PACKET;\n        Buffer buffer = BufferPool.getBuffer.invoke(off + p.getLength() + BYTES_TO_LEAVE_AT_END_OF_PACKET);\n\n        System.arraycopy(p.getData(), p.getOffset(), buffer.getBuffer(), off, p.getLength());\n        buffer.setOffset(off);\n        buffer.setLength(p.getLength());\n        buffer.setLocalAddress(socket.getLocalSocketAddress());\n        buffer.setRemoteAddress(p.getSocketAddress());\n        buffer.setReceivedTime(receivedTime);\n\n        return buffer;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/AbstractUdpListener.java", "class_name": "AbstractUdpListener", "class_uri": "src/main/java/org/ice4j/ice/harvest/AbstractUdpListener.java.AbstractUdpListener", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Buffer", "classes": []}, "docstring": ""}, {"uris": "src/main/java/org/ice4j/ice/harvest/AbstractUdpListener.java.AbstractUdpListener.[MySocket]maybeAcceptNewSession(Buffer,InetSocketAddress,String)", "name": "maybeAcceptNewSession", "arg_nums": 3, "params": [{"name": "buf", "type": "Buffer"}, {"name": "remoteAddress", "type": "InetSocketAddress"}, {"name": "ufrag", "type": "String"}], "return_type": "MySocket", "signature": "protected abstract MySocket maybeAcceptNewSession(\n            Buffer buf,\n            InetSocketAddress remoteAddress,\n            String ufrag)", "original_string": "    protected abstract MySocket maybeAcceptNewSession(\n            Buffer buf,\n            InetSocketAddress remoteAddress,\n            String ufrag);", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/AbstractUdpListener.java", "class_name": "AbstractUdpListener", "class_uri": "src/main/java/org/ice4j/ice/harvest/AbstractUdpListener.java.AbstractUdpListener", "attributes": {"modifiers": "protected abstract", "marker_annotations": [], "non_marker_annotations": ["protected", "abstract"], "comments": [], "return_type": "MySocket", "classes": []}, "docstring": "\nHandles the reception of a STUN Binding Request with a valid USERNAME\nattribute, from a \"new\" remote address (one which is not in\n{@link #sockets}).\nImplementations may choose to e.g. create a socket and pass it to their\nICE stack.\n\nNote that this is meant to only be executed by\n{@link AbstractUdpListener}'s read thread, and should not be called from\nimplementing classes.\n\n@param buf the UDP payload of the first datagram received on the newly\naccepted socket.\n@param remoteAddress the remote address from which the datagram was\nreceived.\n@param ufrag the local ICE username fragment of the received STUN Binding\nRequest.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/AbstractUdpListener.java.AbstractUdpListener.[Buffer]getFreeBuffer()", "name": "getFreeBuffer", "arg_nums": 0, "params": [], "return_type": "Buffer", "signature": "private Buffer getFreeBuffer()", "original_string": "    private Buffer getFreeBuffer()\n    {\n        Buffer buf = pool.poll();\n        if (buf == null)\n        {\n            buf = new Buffer(new byte[BUFFER_SIZE], 0, 0);\n        }\n\n        return buf;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/AbstractUdpListener.java", "class_name": "AbstractUdpListener", "class_uri": "src/main/java/org/ice4j/ice/harvest/AbstractUdpListener.java.AbstractUdpListener", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Buffer", "classes": []}, "docstring": "\nGets an unused <tt>Buffer</tt> instance, creating it if necessary.\n@return  an unused <tt>Buffer</tt> instance, creating it if necessary.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/AbstractUdpListener.java.AbstractUdpListener.[MySocket]addSocket(InetSocketAddress,String,BufferHandler)", "name": "addSocket", "arg_nums": 3, "params": [{"name": "remoteAddress", "type": "InetSocketAddress"}, {"name": "ufrag", "type": "String"}, {"name": "bufferHandler", "type": "BufferHandler"}], "return_type": "MySocket", "signature": "protected MySocket addSocket(InetSocketAddress remoteAddress, String ufrag, @NotNull BufferHandler bufferHandler)", "original_string": "    protected MySocket addSocket(InetSocketAddress remoteAddress, String ufrag, @NotNull BufferHandler bufferHandler)\n        throws SocketException\n    {\n        MySocket newSocket = new MySocket(remoteAddress, ufrag, bufferHandler);\n        sockets.put(remoteAddress, newSocket);\n        return newSocket;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/AbstractUdpListener.java", "class_name": "AbstractUdpListener", "class_uri": "src/main/java/org/ice4j/ice/harvest/AbstractUdpListener.java.AbstractUdpListener", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "MySocket", "classes": []}, "docstring": "\nCreates a new {@link MySocket} instance and associates it with the given\nremote address. Returns the created instance.\n\nNote that this is meant to only execute in {@link AbstractUdpListener}'s\nread thread.\n\n@param remoteAddress the remote address with which to associate the new\nsocket instance.\n@param ufrag The username fragment associated with the socket.\n@param bufferHandler The handler to call when the push API is used.\n@return the created socket instance.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/CandidateHarvester.java.CandidateHarvester.[Collection<LocalCandidate>]harvest(Component)", "name": "harvest", "arg_nums": 1, "params": [{"name": "component", "type": "Component"}], "return_type": "Collection<LocalCandidate>", "signature": "Collection<LocalCandidate> harvest(Component component)", "original_string": "    Collection<LocalCandidate> harvest(Component component);", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/CandidateHarvester.java", "class_name": "CandidateHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/CandidateHarvester.java.CandidateHarvester", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Collection<LocalCandidate>", "classes": []}, "docstring": "\nGathers all candidate addresses of the type that this\n<tt>CandidateHarvester</tt> supports. The gathered candidate addresses\nare to be added by this <tt>CandidateHarvester</tt> to the specified\n<tt>Component</tt> using\n{@link Component#addLocalCandidate(LocalCandidate)} as soon as they are\ndiscovered.\n\n@param component the {@link Component} that we'd like to gather candidate\naddresses for.\n@return  the <tt>LocalCandidate</tt>s gathered by this\n<tt>CandidateHarvester</tt>. Though they are to be added by this\n<tt>CandidateHarvester</tt> to the specified <tt>component</tt> as soon\nas they are discovered, they should also be returned in order to make\nsure that the gathering will be considered successful.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/CandidateHarvester.java.CandidateHarvester.[HarvestStatistics]getHarvestStatistics()", "name": "getHarvestStatistics", "arg_nums": 0, "params": [], "return_type": "HarvestStatistics", "signature": "HarvestStatistics getHarvestStatistics()", "original_string": "    HarvestStatistics getHarvestStatistics();", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/CandidateHarvester.java", "class_name": "CandidateHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/CandidateHarvester.java.CandidateHarvester", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "HarvestStatistics", "classes": []}, "docstring": "\nReturns the statistics describing how well the various harvests of this\nharvester went.\n\n@return The {@link HarvestStatistics} describing this harvester's\nharvests.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/CandidateHarvester.java.CandidateHarvester.[boolean]isHostHarvester()", "name": "isHostHarvester", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "boolean isHostHarvester()", "original_string": "    boolean isHostHarvester();", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/CandidateHarvester.java", "class_name": "CandidateHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/CandidateHarvester.java.CandidateHarvester", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nReturns <tt>true</tt> if this <tt>CandidateHarvester</tt> is to be\nconsidered a harvester for host candidates. Such a harvester should\n1. Create local candidates of type <tt>HOST_CANDIDATE</tt>.\n2. Not depend on other local candidates, already harvested for the\n     component for which it is called.\n3. Not perform blocking operations while harvesting.\n\n@return <tt>true</tt> if this <tt>CandidateHarvester</tt> is a harvester\nfor host candidates.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvester.java.StunCandidateHarvester.[]StunCandidateHarvester(TransportAddress)", "name": "StunCandidateHarvester", "arg_nums": 1, "params": [{"name": "stunServer", "type": "TransportAddress"}], "return_type": "", "signature": "public StunCandidateHarvester(TransportAddress stunServer)", "original_string": "    public StunCandidateHarvester(TransportAddress stunServer)\n    {\n        this(stunServer, null);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvester.java", "class_name": "StunCandidateHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvester.java.StunCandidateHarvester", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nCreates a new STUN harvester that will be running against the specified\n<tt>stunServer</tt> using a specific username for the purposes of the\nSTUN short-term credential mechanism.\n\n@param stunServer the address of the STUN server that we will be querying\nfor our public bindings\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvester.java.StunCandidateHarvester.[]StunCandidateHarvester(TransportAddress,String)", "name": "StunCandidateHarvester", "arg_nums": 2, "params": [{"name": "stunServer", "type": "TransportAddress"}, {"name": "shortTermCredentialUsername", "type": "String"}], "return_type": "", "signature": "public StunCandidateHarvester(\n            TransportAddress stunServer,\n            String shortTermCredentialUsername)", "original_string": "    public StunCandidateHarvester(\n            TransportAddress stunServer,\n            String shortTermCredentialUsername)\n    {\n        this.stunServer = stunServer;\n        this.shortTermCredentialUsername = shortTermCredentialUsername;\n\n        //these should be configurable.\n        if (System.getProperty(StackProperties.MAX_CTRAN_RETRANS_TIMER) == null)\n            System.setProperty(StackProperties.MAX_CTRAN_RETRANS_TIMER, \"400\");\n        if (System.getProperty(StackProperties.MAX_CTRAN_RETRANSMISSIONS) == null)\n            System.setProperty(StackProperties.MAX_CTRAN_RETRANSMISSIONS, \"3\");\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvester.java", "class_name": "StunCandidateHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvester.java.StunCandidateHarvester", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nCreates a new STUN harvester that will be running against the specified\n<tt>stunServer</tt> using a specific username for the purposes of the\nSTUN short-term credential mechanism.\n\n@param stunServer the address of the STUN server that we will be querying\nfor our public bindings\n@param shortTermCredentialUsername the username to be used by the new\ninstance for the purposes of the STUN short-term credential mechanism or\n<tt>null</tt> if the use of the STUN short-term credential mechanism is\nnot determined at the time of the construction of the new instance\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvester.java.StunCandidateHarvester.[void]completedResolvingCandidate(StunCandidateHarvest)", "name": "completedResolvingCandidate", "arg_nums": 1, "params": [{"name": "harvest", "type": "StunCandidateHarvest"}], "return_type": "void", "signature": "void completedResolvingCandidate(StunCandidateHarvest harvest)", "original_string": "    void completedResolvingCandidate(StunCandidateHarvest harvest)\n    {\n        boolean doNotify = false;\n\n        synchronized (startedHarvests)\n        {\n            startedHarvests.remove(harvest);\n\n            // If this was the last candidate, we are done with the STUN\n            // resolution and need to notify the waiters.\n            if (startedHarvests.isEmpty())\n                doNotify = true;\n        }\n\n        synchronized (completedHarvests)\n        {\n            if (harvest.getCandidateCount() < 1)\n                completedHarvests.remove(harvest);\n            else if (!completedHarvests.contains(harvest))\n                completedHarvests.add(harvest);\n        }\n\n        synchronized(startedHarvests)\n        {\n            if (doNotify)\n                startedHarvests.notify();\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvester.java", "class_name": "StunCandidateHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvester.java.StunCandidateHarvester", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nNotifies this <tt>StunCandidateHarvester</tt> that a specific\n<tt>StunCandidateHarvest</tt> has been completed. If the specified\nharvest has harvested <tt>Candidates</tt>, it is moved from\n{@link #startedHarvests} to {@link #completedHarvests}. Otherwise, it is\njust removed from {@link #startedHarvests}.\n\n@param harvest the <tt>StunCandidateHarvest</tt> which has been completed\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvester.java.StunCandidateHarvester.[StunCandidateHarvest]createHarvest(HostCandidate)", "name": "createHarvest", "arg_nums": 1, "params": [{"name": "hostCandidate", "type": "HostCandidate"}], "return_type": "StunCandidateHarvest", "signature": "protected StunCandidateHarvest createHarvest(HostCandidate hostCandidate)", "original_string": "    protected StunCandidateHarvest createHarvest(HostCandidate hostCandidate)\n    {\n        return new StunCandidateHarvest(this, hostCandidate);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvester.java", "class_name": "StunCandidateHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvester.java.StunCandidateHarvester", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "StunCandidateHarvest", "classes": []}, "docstring": "\nCreates a new <tt>StunCandidateHarvest</tt> instance which is to perform\nSTUN harvesting of a specific <tt>HostCandidate</tt>.\n\n@param hostCandidate the <tt>HostCandidate</tt> for which harvesting is\nto be performed by the new <tt>StunCandidateHarvest</tt> instance\n@return a new <tt>StunCandidateHarvest</tt> instance which is to perform\nSTUN harvesting of the specified <tt>hostCandidate</tt>\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvester.java.StunCandidateHarvester.[LongTermCredential]createLongTermCredential(StunCandidateHarvest,byte[])", "name": "createLongTermCredential", "arg_nums": 2, "params": [{"name": "harvest", "type": "StunCandidateHarvest"}, {"name": "realm", "type": "byte[]"}], "return_type": "LongTermCredential", "signature": "protected LongTermCredential createLongTermCredential(\n            StunCandidateHarvest harvest,\n            byte[] realm)", "original_string": "    protected LongTermCredential createLongTermCredential(\n            StunCandidateHarvest harvest,\n            byte[] realm)\n    {\n        // The long-term credential mechanism is not utilized by default.\n        return null;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvester.java", "class_name": "StunCandidateHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvester.java.StunCandidateHarvester", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "LongTermCredential", "classes": []}, "docstring": "\nCreates a <tt>LongTermCredential</tt> to be used by a specific\n<tt>StunCandidateHarvest</tt> for the purposes of the long-term\ncredential mechanism in a specific <tt>realm</tt> of the STUN server\nassociated with this <tt>StunCandidateHarvester</tt>. The default\nimplementation returns <tt>null</tt> and allows extenders to override in\norder to support the long-term credential mechanism.\n\n@param harvest the <tt>StunCandidateHarvest</tt> which asks for the\n<tt>LongTermCredential</tt>\n@param realm the realm of the STUN server associated with this\n<tt>StunCandidateHarvester</tt> in which <tt>harvest</tt> will use the\nreturned <tt>LongTermCredential</tt>\n@return a <tt>LongTermCredential</tt> to be used by <tt>harvest</tt> for\nthe purposes of the long-term credential mechanism in the specified\n<tt>realm</tt> of the STUN server associated with this\n<tt>StunCandidateHarvester</tt>\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvester.java.StunCandidateHarvester.[String]getShortTermCredentialUsername()", "name": "getShortTermCredentialUsername", "arg_nums": 0, "params": [], "return_type": "String", "signature": "protected String getShortTermCredentialUsername()", "original_string": "    protected String getShortTermCredentialUsername()\n    {\n        return shortTermCredentialUsername;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvester.java", "class_name": "StunCandidateHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvester.java.StunCandidateHarvester", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nGets the username to be used by this <tt>StunCandidateHarvester</tt> for\nthe purposes of the STUN short-term credential mechanism.\n\n@return the username to be used by this <tt>StunCandidateHarvester</tt>\nfor the purposes of the STUN short-term credential mechanism or\n<tt>null</tt> if the STUN short-term credential mechanism is not to be\nutilized\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvester.java.StunCandidateHarvester.[StunStack]getStunStack()", "name": "getStunStack", "arg_nums": 0, "params": [], "return_type": "StunStack", "signature": "public StunStack getStunStack()", "original_string": "    public StunStack getStunStack()\n    {\n        return stunStack;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvester.java", "class_name": "StunCandidateHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvester.java.StunCandidateHarvester", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "StunStack", "classes": []}, "docstring": "\nGets the <tt>StunStack</tt> used by this <tt>CandidateHarvester</tt> for\nthe purposes of STUN communication. It is guaranteed to be available only\nduring the execution of {@link CandidateHarvester#harvest(Component)}.\n\n@return the <tt>StunStack</tt> used by this <tt>CandidateHarvester</tt>\nfor the purposes of STUN communication\n@see CandidateHarvester#harvest(Component)\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvester.java.StunCandidateHarvester.[Collection<LocalCandidate>]harvest(Component)", "name": "harvest", "arg_nums": 1, "params": [{"name": "component", "type": "Component"}], "return_type": "Collection<LocalCandidate>", "signature": "@Override\n    public Collection<LocalCandidate> harvest(Component component)", "original_string": "    @Override\n    public Collection<LocalCandidate> harvest(Component component)\n    {\n        if (logger.isLoggable(Level.FINE))\n        {\n            logger.fine(\"starting \" + component.toShortString()\n                            + \" harvest for: \" + toString());\n        }\n        stunStack = component.getParentStream().getParentAgent().getStunStack();\n\n        for (Candidate<?> cand : component.getLocalCandidates())\n        {\n            if ((cand instanceof HostCandidate)\n                    && (cand.getTransport() == stunServer.getTransport()))\n            {\n                startResolvingCandidate((HostCandidate) cand);\n            }\n        }\n\n        waitForResolutionEnd();\n\n        /*\n         * Report the LocalCandidates gathered by this CandidateHarvester so\n         * that the harvest is sure to be considered successful.\n         */\n        Collection<LocalCandidate> candidates = new HashSet<>();\n\n        synchronized (completedHarvests)\n        {\n            for (StunCandidateHarvest completedHarvest : completedHarvests)\n            {\n                LocalCandidate[] completedHarvestCandidates\n                    = completedHarvest.getCandidates();\n\n                if ((completedHarvestCandidates != null)\n                        && (completedHarvestCandidates.length != 0))\n                {\n                    candidates.addAll(\n                            Arrays.asList(completedHarvestCandidates));\n                }\n            }\n\n            completedHarvests.clear();\n        }\n\n        logger.finest(\n                \"Completed \" + component.toShortString() + \" harvest: \"\n                    + toString() + \". Found \" + candidates.size()\n                    + \" candidates: \" + listCandidates(candidates));\n\n        return candidates;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvester.java", "class_name": "StunCandidateHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvester.java.StunCandidateHarvester", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Collection<LocalCandidate>", "classes": []}, "docstring": "\nGathers STUN candidates for all host <tt>Candidate</tt>s that are already\npresent in the specified <tt>component</tt>. This method relies on the\nspecified <tt>component</tt> to already contain all its host candidates\nso that it would resolve them.\n\n@param component the {@link Component} that we'd like to gather candidate\nSTUN <tt>Candidate</tt>s for\n@return  the <tt>LocalCandidate</tt>s gathered by this\n<tt>CandidateHarvester</tt>\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvester.java.StunCandidateHarvester.[String]listCandidates(Collection<? extends Candidate<?>>)", "name": "listCandidates", "arg_nums": 1, "params": [{"name": "candidates", "type": "Collection<? extends Candidate<?>>"}], "return_type": "String", "signature": "private String listCandidates(Collection<? extends Candidate<?>> candidates)", "original_string": "    private String listCandidates(Collection<? extends Candidate<?>> candidates)\n    {\n        StringBuilder retval = new StringBuilder();\n        for (Candidate<?> candidate : candidates)\n        {\n            retval.append(candidate.toShortString());\n        }\n        return retval.toString();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvester.java", "class_name": "StunCandidateHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvester.java.StunCandidateHarvester", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "String", "classes": []}, "docstring": ""}, {"uris": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvester.java.StunCandidateHarvester.[void]startResolvingCandidate(HostCandidate)", "name": "startResolvingCandidate", "arg_nums": 1, "params": [{"name": "hostCand", "type": "HostCandidate"}], "return_type": "void", "signature": "private void startResolvingCandidate(HostCandidate hostCand)", "original_string": "    private void startResolvingCandidate(HostCandidate hostCand)\n    {\n        //first of all, make sure that the STUN server and the Candidate\n        //address are of the same type and that they can communicate.\n        if (!hostCand.getTransportAddress().canReach(stunServer))\n            return;\n\n        HostCandidate cand = getHostCandidate(hostCand);\n\n        if (cand == null)\n        {\n            logger.info(\n                    \"server/candidate address type mismatch,\"\n                        + \" skipping candidate in this harvester\");\n            return;\n        }\n\n        StunCandidateHarvest harvest = createHarvest(cand);\n\n        if (harvest == null)\n        {\n            logger.warning(\"failed to create harvest\");\n            return;\n        }\n\n        synchronized (startedHarvests)\n        {\n            startedHarvests.add(harvest);\n\n            boolean started = false;\n\n            try\n            {\n                started = harvest.startResolvingCandidate();\n            }\n            catch (Exception ex)\n            {\n                started = false;\n                if (logger.isLoggable(Level.INFO))\n                {\n                    logger.log(\n                            Level.INFO,\n                            \"Failed to start resolving host candidate \"\n                                + hostCand,\n                            ex);\n                }\n            }\n            finally\n            {\n                if (!started)\n                {\n                    try\n                    {\n                        startedHarvests.remove(harvest);\n                        logger.warning(\n                                \"harvest did not start, removed: \" + harvest);\n                    }\n                    finally\n                    {\n                        /*\n                         * For the sake of completeness, explicitly close the\n                         * harvest.\n                         */\n                        try\n                        {\n                            harvest.close();\n                        }\n                        catch (Exception ex)\n                        {\n                        }\n                    }\n                }\n            }\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvester.java", "class_name": "StunCandidateHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvester.java.StunCandidateHarvester", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSends a binding request to our stun server through the specified\n<tt>hostCand</tt> candidate and adds it to the list of addresses still\nwaiting for resolution.\n\n@param hostCand the <tt>HostCandidate</tt> that we'd like to resolve.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvester.java.StunCandidateHarvester.[void]waitForResolutionEnd()", "name": "waitForResolutionEnd", "arg_nums": 0, "params": [], "return_type": "void", "signature": "private void waitForResolutionEnd()", "original_string": "    private void waitForResolutionEnd()\n    {\n        synchronized(startedHarvests)\n        {\n            boolean interrupted = false;\n\n            // Handle spurious wakeups.\n            while (!startedHarvests.isEmpty())\n            {\n                try\n                {\n                    startedHarvests.wait();\n                }\n                catch (InterruptedException iex)\n                {\n                    logger.info(\n                            \"interrupted waiting for harvests to complete,\"\n                                + \" no. startedHarvests = \"\n                                + startedHarvests.size());\n                    interrupted = true;\n                }\n            }\n            // Restore the interrupted status.\n            if (interrupted)\n                Thread.currentThread().interrupt();\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvester.java", "class_name": "StunCandidateHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvester.java.StunCandidateHarvester", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nBlocks the current thread until all resolutions in this harvester\nhave terminated one way or another.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvester.java.StunCandidateHarvester.[String]toString()", "name": "toString", "arg_nums": 0, "params": [], "return_type": "String", "signature": "@Override\n    public String toString()", "original_string": "    @Override\n    public String toString()\n    {\n        String proto = (this instanceof TurnCandidateHarvester)\n                                ? \"TURN\"\n                                : \"STUN\";\n        return proto + \" harvester(srvr: \" + this.stunServer + \")\";\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvester.java", "class_name": "StunCandidateHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvester.java.StunCandidateHarvester", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns a <tt>String</tt> representation of this harvester containing its\ntype and server address.\n\n@return a <tt>String</tt> representation of this harvester containing its\ntype and server address.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvester.java.StunCandidateHarvester.[HostCandidate]getHostCandidate(HostCandidate)", "name": "getHostCandidate", "arg_nums": 1, "params": [{"name": "hostCand", "type": "HostCandidate"}], "return_type": "HostCandidate", "signature": "protected HostCandidate getHostCandidate(HostCandidate hostCand)", "original_string": "    protected HostCandidate getHostCandidate(HostCandidate hostCand)\n    {\n        HostCandidate cand;\n\n        // create a new TCP HostCandidate\n        if (hostCand.getTransport() == Transport.TCP)\n        {\n            try\n            {\n                Socket sock = new Socket(stunServer.getAddress(),\n                    stunServer.getPort());\n                MultiplexingSocket multiplexing = new MultiplexingSocket(sock);\n                Component component = hostCand.getParentComponent();\n                cand\n                    = new HostCandidate(\n                            new IceTcpSocketWrapper(multiplexing),\n                            component,\n                            Transport.TCP);\n                component.getParentStream().\n                    getParentAgent().getStunStack().addSocket(\n                        cand.getStunSocket(null));\n\n                ComponentSocket componentSocket\n                    = component.getComponentSocket();\n                if (componentSocket != null)\n                {\n                    componentSocket.add(multiplexing);\n                }\n            }\n            catch(Exception io)\n            {\n                logger.info(\"Exception TCP client connect: \" + io);\n                return null;\n            }\n        }\n        else\n        {\n            cand = hostCand;\n        }\n\n        return cand;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvester.java", "class_name": "StunCandidateHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvester.java.StunCandidateHarvester", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "HostCandidate", "classes": []}, "docstring": "\nReturns the host candidate.\nFor UDP it simply returns the candidate passed as a parameter.\n\nHowever for TCP, we cannot return the same hostCandidate because in Java\na  \"server\" socket cannot connect to a destination with the same local\naddress/port (i.e. a Java Socket cannot act as both server/client).\n\n@param hostCand HostCandidate\n@return HostCandidate\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/AbstractTcpListener.java.AbstractTcpListener.[void]closeNoExceptions(Channel)", "name": "closeNoExceptions", "arg_nums": 1, "params": [{"name": "channel", "type": "Channel"}], "return_type": "void", "signature": "static void closeNoExceptions(Channel channel)", "original_string": "    static void closeNoExceptions(Channel channel)\n    {\n        try\n        {\n            channel.close();\n        }\n        catch (IOException ioe)\n        {\n            // The whole idea of the method is to close a specific Channel\n            // without caring about any possible IOException.\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/AbstractTcpListener.java", "class_name": "AbstractTcpListener", "class_uri": "src/main/java/org/ice4j/ice/harvest/AbstractTcpListener.java.AbstractTcpListener", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCloses a {@code Channel} and swallows any {@link IOException}.\n\n@param channel the {@code Channel} to close\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/AbstractTcpListener.java.AbstractTcpListener.[List<TransportAddress>]getLocalAddresses(int,List<NetworkInterface>)", "name": "getLocalAddresses", "arg_nums": 2, "params": [{"name": "port", "type": "int"}, {"name": "interfaces", "type": "List<NetworkInterface>"}], "return_type": "List<TransportAddress>", "signature": "private static List<TransportAddress> getLocalAddresses(\n            int port,\n            List<NetworkInterface> interfaces)", "original_string": "    private static List<TransportAddress> getLocalAddresses(\n            int port,\n            List<NetworkInterface> interfaces)\n    {\n        List<TransportAddress> addresses = new LinkedList<>();\n\n        for (NetworkInterface iface : interfaces)\n        {\n            if (!HostCandidateHarvester.isInterfaceAllowed(iface))\n            {\n                continue;\n            }\n\n            Enumeration<InetAddress> ifaceAddresses = iface.getInetAddresses();\n\n            while (ifaceAddresses.hasMoreElements())\n            {\n                InetAddress addr = ifaceAddresses.nextElement();\n\n                addresses.add(new TransportAddress(addr, port, Transport.TCP));\n            }\n        }\n        return addresses;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/AbstractTcpListener.java", "class_name": "AbstractTcpListener", "class_uri": "src/main/java/org/ice4j/ice/harvest/AbstractTcpListener.java.AbstractTcpListener", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "List<TransportAddress>", "classes": []}, "docstring": "\nReturns a list of all addresses on the interfaces in <tt>interfaces</tt>\nwhich are found suitable for candidate allocations (are not loopback, are\nup, and are allowed by the configuration).\n\n@param port the port to use.\n@param interfaces the list of interfaces to use.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/AbstractTcpListener.java.AbstractTcpListener.[]AbstractTcpListener(int)", "name": "AbstractTcpListener", "arg_nums": 1, "params": [{"name": "port", "type": "int"}], "return_type": "", "signature": "public AbstractTcpListener(int port)", "original_string": "    public AbstractTcpListener(int port)\n            throws IOException\n    {\n        this(port, Collections.list(NetworkInterface.getNetworkInterfaces()));\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/AbstractTcpListener.java", "class_name": "AbstractTcpListener", "class_uri": "src/main/java/org/ice4j/ice/harvest/AbstractTcpListener.java.AbstractTcpListener", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>TcpHarvester</tt>, which is to\nlisten on port number <tt>port</tt> on all IP addresses on all available\ninterfaces.\n\n@param port the port to listen on.\n@throws IOException when {@link HarvestConfig#getAllowedAddresses()} or\n{@link HarvestConfig#getBlockedAddresses()} contains invalid values, or\nif an I/O error occurs.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/AbstractTcpListener.java.AbstractTcpListener.[]AbstractTcpListener(int,List<NetworkInterface>)", "name": "AbstractTcpListener", "arg_nums": 2, "params": [{"name": "port", "type": "int"}, {"name": "interfaces", "type": "List<NetworkInterface>"}], "return_type": "", "signature": "public AbstractTcpListener(int port, List<NetworkInterface> interfaces)", "original_string": "    public AbstractTcpListener(int port, List<NetworkInterface> interfaces)\n        throws IOException\n    {\n        this(getLocalAddresses(port, interfaces));\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/AbstractTcpListener.java", "class_name": "AbstractTcpListener", "class_uri": "src/main/java/org/ice4j/ice/harvest/AbstractTcpListener.java.AbstractTcpListener", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>TcpHarvester</tt>, which is to listen on port\nnumber <tt>port</tt> on all the IP addresses on the specified\n<tt>NetworkInterface</tt>s.\n\n@param port the port to listen on.\n@param interfaces the interfaces to listen on.\n@throws IOException when {@link HarvestConfig#getAllowedAddresses()} or\n{@link HarvestConfig#getBlockedAddresses()} contains invalid values, or\nif an I/O error occurs.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/AbstractTcpListener.java.AbstractTcpListener.[]AbstractTcpListener(List<TransportAddress>)", "name": "AbstractTcpListener", "arg_nums": 1, "params": [{"name": "transportAddresses", "type": "List<TransportAddress>"}], "return_type": "", "signature": "public AbstractTcpListener(List<TransportAddress> transportAddresses)", "original_string": "    public AbstractTcpListener(List<TransportAddress> transportAddresses)\n        throws IOException\n    {\n        addLocalAddresses(transportAddresses);\n        init();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/AbstractTcpListener.java", "class_name": "AbstractTcpListener", "class_uri": "src/main/java/org/ice4j/ice/harvest/AbstractTcpListener.java.AbstractTcpListener", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>TcpHarvester</tt>, which is to listen on the\nspecified list of <tt>TransportAddress</tt>es.\n\n@param transportAddresses the transport addresses to listen on.\n@throws IOException when {@link HarvestConfig#getAllowedAddresses()} or\n{@link HarvestConfig#getBlockedAddresses()} contains invalid values, or\nif an I/O error occurs.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/AbstractTcpListener.java.AbstractTcpListener.[void]addLocalAddresses(List<TransportAddress>)", "name": "addLocalAddresses", "arg_nums": 1, "params": [{"name": "transportAddresses", "type": "List<TransportAddress>"}], "return_type": "void", "signature": "protected void addLocalAddresses(List<TransportAddress> transportAddresses)", "original_string": "    protected void addLocalAddresses(List<TransportAddress> transportAddresses)\n        throws IOException\n    {\n        for (TransportAddress transportAddress : transportAddresses)\n        {\n            if (HostCandidateHarvester.isAddressAllowed(transportAddress.getAddress()))\n            {\n                localAddresses.add(transportAddress);\n            }\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/AbstractTcpListener.java", "class_name": "AbstractTcpListener", "class_uri": "src/main/java/org/ice4j/ice/harvest/AbstractTcpListener.java.AbstractTcpListener", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nAdds to {@link #localAddresses} those addresses from\n<tt>transportAddresses</tt> which are found suitable for candidate\nallocation.\n\n@param transportAddresses the list of addresses to add.\n@throws IOException when {@link HarvestConfig#getAllowedAddresses()} or\n{@link HarvestConfig#getBlockedAddresses()} contains invalid values.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/AbstractTcpListener.java.AbstractTcpListener.[void]close()", "name": "close", "arg_nums": 0, "params": [], "return_type": "void", "signature": "public void close()", "original_string": "    public void close()\n    {\n        close = true;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/AbstractTcpListener.java", "class_name": "AbstractTcpListener", "class_uri": "src/main/java/org/ice4j/ice/harvest/AbstractTcpListener.java.AbstractTcpListener", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nTriggers the termination of the threads of this\n<tt>MultiplexingTcpHarvester</tt>.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/AbstractTcpListener.java.AbstractTcpListener.[void]init()", "name": "init", "arg_nums": 0, "params": [], "return_type": "void", "signature": "protected void init()", "original_string": "    protected void init()\n        throws IOException\n    {\n        boolean bindWildcard = StackProperties.getBoolean(\n                StackProperties.BIND_WILDCARD,\n                false);\n\n        // Use a set to filter out any duplicates.\n        Set<InetSocketAddress> addressesToBind = new HashSet<>();\n\n        for (TransportAddress transportAddress : localAddresses)\n        {\n            addressesToBind.add( new InetSocketAddress(\n                bindWildcard ? null : transportAddress.getAddress(),\n                transportAddress.getPort()\n            ) );\n        }\n\n        for (InetSocketAddress addressToBind : addressesToBind )\n        {\n            addSocketChannel( addressToBind );\n        }\n\n        acceptThread = new AcceptThread();\n        acceptThread.start();\n\n        readThread = new ReadThread();\n        readThread.start();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/AbstractTcpListener.java", "class_name": "AbstractTcpListener", "class_uri": "src/main/java/org/ice4j/ice/harvest/AbstractTcpListener.java.AbstractTcpListener", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nInitializes {@link #serverSocketChannels}, creates and starts the threads\nused by this instance.\n@throws IOException if an I/O error occurs\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/AbstractTcpListener.java.AbstractTcpListener.[void]addSocketChannel(InetSocketAddress)", "name": "addSocketChannel", "arg_nums": 1, "params": [{"name": "address", "type": "InetSocketAddress"}], "return_type": "void", "signature": "private void addSocketChannel(InetSocketAddress address)", "original_string": "    private void addSocketChannel(InetSocketAddress address)\n        throws IOException\n    {\n        ServerSocketChannel channel = MuxServerSocketChannelFactory\n            .openAndBindServerSocketChannel(null, address, 0);\n\n        serverSocketChannels.add(channel);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/AbstractTcpListener.java", "class_name": "AbstractTcpListener", "class_uri": "src/main/java/org/ice4j/ice/harvest/AbstractTcpListener.java.AbstractTcpListener", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nInitializes one of the channels in {@link #serverSocketChannels},\n@throws IOException if an I/O error occurs\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/AbstractTcpListener.java.AbstractTcpListener.[void]acceptSession(Socket,String,DatagramPacket)", "name": "acceptSession", "arg_nums": 3, "params": [{"name": "socket", "type": "Socket"}, {"name": "ufrag", "type": "String"}, {"name": "pushback", "type": "DatagramPacket"}], "return_type": "void", "signature": "protected abstract void acceptSession(\n            Socket socket, String ufrag, DatagramPacket pushback)", "original_string": "    protected abstract void acceptSession(\n            Socket socket, String ufrag, DatagramPacket pushback)\n        throws IOException, IllegalStateException;", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/AbstractTcpListener.java", "class_name": "AbstractTcpListener", "class_uri": "src/main/java/org/ice4j/ice/harvest/AbstractTcpListener.java.AbstractTcpListener", "attributes": {"modifiers": "protected abstract", "marker_annotations": [], "non_marker_annotations": ["protected", "abstract"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nAccepts a session.\n@param socket the {@link Socket} for the session.\n@param ufrag the local username fragment for the session.\n@param pushback the first \"datagram\" (RFC4571-framed), already read from\nthe socket's stream.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSet.java.CandidateHarvesterSet.[]CandidateHarvesterSet()", "name": "CandidateHarvesterSet", "arg_nums": 0, "params": [], "return_type": "", "signature": "public CandidateHarvesterSet()", "original_string": "    public CandidateHarvesterSet()\n    {\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSet.java", "class_name": "CandidateHarvesterSet", "class_uri": "src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSet.java.CandidateHarvesterSet", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>CandidateHarvesterSet</tt> instance.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSet.java.CandidateHarvesterSet.[boolean]add(CandidateHarvester)", "name": "add", "arg_nums": 1, "params": [{"name": "harvester", "type": "CandidateHarvester"}], "return_type": "boolean", "signature": "@Override\n    public boolean add(CandidateHarvester harvester)", "original_string": "    @Override\n    public boolean add(CandidateHarvester harvester)\n    {\n        synchronized (elements)\n        {\n            for (CandidateHarvesterSetElement element : elements)\n                if (element.harvesterEquals(harvester))\n                    return false;\n\n            elements.add(new CandidateHarvesterSetElement(harvester));\n            return true;\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSet.java", "class_name": "CandidateHarvesterSet", "class_uri": "src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSet.java.CandidateHarvesterSet", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nAdds a specific <tt>CandidateHarvester</tt> to this\n<tt>CandidateHarvesterSet</tt> and returns <tt>true</tt> if it is not\nalready present. Otherwise, leaves this set unchanged and returns\n<tt>false</tt>.\n\n@param harvester the <tt>CandidateHarvester</tt> to be added to this\n<tt>CandidateHarvesterSet</tt>\n@return <tt>true</tt> if this <tt>CandidateHarvesterSet</tt> did not\nalready contain the specified <tt>harvester</tt>; otherwise,\n<tt>false</tt>\n@see Set#add(Object)\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSet.java.CandidateHarvesterSet.[void]harvest(Component)", "name": "harvest", "arg_nums": 1, "params": [{"name": "component", "type": "Component"}], "return_type": "void", "signature": "public void harvest(Component component)", "original_string": "    public void harvest(Component component)\n    {\n        harvest(Arrays.asList(component), null);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSet.java", "class_name": "CandidateHarvesterSet", "class_uri": "src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSet.java.CandidateHarvesterSet", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nGathers candidate addresses for a specific <tt>Component</tt>.\n<tt>CandidateHarvesterSet</tt> delegates to the\n<tt>CandidateHarvester</tt>s which are its <tt>Set</tt> elements.\n\n@param component the <tt>Component</tt> to gather candidate addresses for\n@see CandidateHarvester#harvest(Component)\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSet.java.CandidateHarvesterSet.[void]harvest(List<Component>,TrickleCallback)", "name": "harvest", "arg_nums": 2, "params": [{"name": "components", "type": "List<Component>"}, {"name": "trickleCallback", "type": "TrickleCallback"}], "return_type": "void", "signature": "public void harvest(final List<Component> components,\n                              TrickleCallback trickleCallback)", "original_string": "    public void harvest(final List<Component> components,\n                              TrickleCallback trickleCallback)\n    {\n        synchronized (elements)\n        {\n            harvest(\n                elements.iterator(), components, threadPool, trickleCallback);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSet.java", "class_name": "CandidateHarvesterSet", "class_uri": "src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSet.java.CandidateHarvesterSet", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nGathers candidate addresses for a specific <tt>Component</tt>.\n<tt>CandidateHarvesterSet</tt> delegates to the\n<tt>CandidateHarvester</tt>s which are its <tt>Set</tt> elements.\n\n@param components the <tt>Component</tt> to gather candidate addresses for\n@see CandidateHarvester#harvest(Component)\n@param trickleCallback the {@link TrickleCallback} that we will be\nfeeding candidates to, or <tt>null</tt> in case the application doesn't\nwant us trickling any candidates\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSet.java.CandidateHarvesterSet.[void]harvest(Iterator<CandidateHarvesterSetElement>,List<Component>,ExecutorService,TrickleCallback)", "name": "harvest", "arg_nums": 4, "params": [{"name": "harvesters", "type": "Iterator<CandidateHarvesterSetElement>"}, {"name": "components", "type": "List<Component>"}, {"name": "executorService", "type": "ExecutorService"}, {"name": "trickleCallback", "type": "TrickleCallback"}], "return_type": "void", "signature": "private void harvest(\n            final Iterator<CandidateHarvesterSetElement> harvesters,\n            final List<Component>                        components,\n                  ExecutorService                        executorService,\n            final TrickleCallback                        trickleCallback)", "original_string": "    private void harvest(\n            final Iterator<CandidateHarvesterSetElement> harvesters,\n            final List<Component>                        components,\n                  ExecutorService                        executorService,\n            final TrickleCallback                        trickleCallback)\n    {\n        /*\n         * Start asynchronously executing the\n         * CandidateHarvester#harvest(Component) method of the harvesters.\n         */\n        Map<CandidateHarvesterSetTask, Future<?>> tasks = new HashMap<>();\n\n        while (true)\n        {\n            /*\n             * Find the next CandidateHarvester which is to start gathering\n             * candidates.\n             */\n            CandidateHarvesterSetElement harvester;\n\n            synchronized (harvesters)\n            {\n                if (harvesters.hasNext())\n                    harvester = harvesters.next();\n                else\n                    break;\n            }\n\n            if (!harvester.isEnabled())\n                continue;\n\n            List<Component> componentsCopy;\n\n            synchronized (components)\n            {\n                componentsCopy = new ArrayList<>(components);\n            }\n\n            // Asynchronously start gathering candidates using the harvester.\n            CandidateHarvesterSetTask task = new CandidateHarvesterSetTask(\n                harvester, componentsCopy, trickleCallback);\n\n            tasks.put(task, executorService.submit(task));\n        }\n\n        /*\n         * Wait for all harvesters to be given a chance to execute their\n         * CandidateHarvester#harvest(Component) method.\n         */\n        Iterator<Map.Entry<CandidateHarvesterSetTask, Future<?>>> taskIter\n            = tasks.entrySet().iterator();\n\n        while (taskIter.hasNext())\n        {\n            Map.Entry<CandidateHarvesterSetTask, Future<?>> task\n                = taskIter.next();\n            Future<?> future = task.getValue();\n\n            do\n            {\n                try\n                {\n                    future.get(HarvestConfig.config.timeout().toMillis(), TimeUnit.MILLISECONDS);\n                    break;\n                }\n                catch (TimeoutException te)\n                {\n                    CandidateHarvesterSetElement harvester = task.getKey().getHarvester();\n                    if (harvester != null)\n                    {\n                        harvester.setEnabled(false);\n                    }\n                    logger.warning(\"timed out while harvesting from \" + harvester);\n                    break;\n                }\n                catch (CancellationException ce)\n                {\n                    logger.info(\"harvester cancelled\");\n                    /*\n                     * It got cancelled so we cannot say that the fault is with\n                     * its current harvester.\n                     */\n                    break;\n                }\n                catch (ExecutionException ee)\n                {\n                    CandidateHarvesterSetElement harvester\n                        = task.getKey().getHarvester();\n\n                    /*\n                     * A problem appeared during the execution of the task.\n                     * CandidateHarvesterSetTask clears its harvester property\n                     * for the purpose of determining whether the problem has\n                     * appeared while working with a harvester.\n                     */\n                    logger.info(\n                        \"disabling harvester \"+ harvester.getHarvester()\n                            + \" due to ExecutionException: \" +\n                            ee.getLocalizedMessage());\n\n                    if (harvester != null)\n                        harvester.setEnabled(false);\n                    break;\n                }\n                catch (InterruptedException ie)\n                {\n                }\n            }\n            while (true);\n            taskIter.remove();\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSet.java", "class_name": "CandidateHarvesterSet", "class_uri": "src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSet.java.CandidateHarvesterSet", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nGathers candidate addresses for a specific <tt>Component</tt> using\nspecific <tt>CandidateHarvester</tt>s.\n\n@param harvesters the <tt>CandidateHarvester</tt>s to gather candidate\naddresses for the specified <tt>Component</tt>\n@param components the <tt>Component</tt>s to gather candidate addresses\nfor.\n@param executorService the <tt>ExecutorService</tt> to schedule the\nexecution of the gathering of candidate addresses performed by the\nspecified <tt>harvesters</tt>\n@param trickleCallback the {@link TrickleCallback} that we will be\nfeeding candidates to, or <tt>null</tt> in case the application doesn't\nwant us trickling any candidates\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSet.java.CandidateHarvesterSet.[Iterator<CandidateHarvester>]iterator()", "name": "iterator", "arg_nums": 0, "params": [], "return_type": "Iterator<CandidateHarvester>", "signature": "public Iterator<CandidateHarvester> iterator()", "original_string": "    public Iterator<CandidateHarvester> iterator()\n    {\n        final Iterator<CandidateHarvesterSetElement> elementIter\n            = elements.iterator();\n\n        return\n            new Iterator<CandidateHarvester>()\n            {\n                /**\n                 * Determines whether this iteration has more elements.\n                 *\n                 * @return <tt>true</tt> if this iteration has more elements;\n                 * otherwise, <tt>false</tt>\n                 * @see Iterator#hasNext()\n                 */\n                public boolean hasNext()\n                {\n                    return elementIter.hasNext();\n                }\n\n                /**\n                 * Returns the next element in this iteration.\n                 *\n                 * @return the next element in this iteration\n                 * @throws NoSuchElementException if this iteration has no more\n                 * elements\n                 * @see Iterator#next()\n                 */\n                public CandidateHarvester next()\n                    throws NoSuchElementException\n                {\n                    return elementIter.next().getHarvester();\n                }\n\n                /**\n                 * Removes from the underlying <tt>CandidateHarvesterSet</tt>\n                 * the last <tt>CandidateHarvester</tt> (element) returned by\n                 * this <tt>Iterator</tt>. <tt>CandidateHarvestSet</tt> does not\n                 * implement the <tt>remove</tt> operation at the time of this\n                 * writing i.e. it always throws\n                 * <tt>UnsupportedOperationException</tt>.\n                 *\n                 * @throws IllegalStateException if the <tt>next</tt> method has\n                 * not yet been called, or the <tt>remove</tt> method has\n                 * already been called after the last call to the <tt>next</tt>\n                 * method\n                 * @throws UnsupportedOperationException if the <tt>remove</tt>\n                 * operation is not supported by this <tt>Iterator</tt>\n                 * @see Iterator#remove()\n                 */\n                public void remove()\n                    throws IllegalStateException,\n                           UnsupportedOperationException\n                {\n                    throw new UnsupportedOperationException(\"remove\");\n                }\n            };\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSet.java", "class_name": "CandidateHarvesterSet", "class_uri": "src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSet.java.CandidateHarvesterSet", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Iterator<CandidateHarvester>", "classes": []}, "docstring": "\nReturns an <tt>Iterator</tt> over the <tt>CandidateHarvester</tt>s which\nare elements in this <tt>CandidateHarvesterSet</tt>. The elements are\nreturned in no particular order.\n\n@return an <tt>Iterator</tt> over the <tt>CandidateHarvester</tt>s which\nare elements in this <tt>CandidateHarvesterSet</tt>\n@see Set#iterator()\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSet.java.CandidateHarvesterSet.[int]size()", "name": "size", "arg_nums": 0, "params": [], "return_type": "int", "signature": "public int size()", "original_string": "    public int size()\n    {\n        synchronized (elements)\n        {\n            return elements.size();\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSet.java", "class_name": "CandidateHarvesterSet", "class_uri": "src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSet.java.CandidateHarvesterSet", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\nReturns the number of <tt>CandidateHarvester</tt>s which are elements in\nthis <tt>CandidateHarvesterSet</tt>.\n\n@return the number of <tt>CandidateHarvester</tt>s which are elements in\nthis <tt>CandidateHarvesterSet</tt>\n@see Set#size()\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/AwsCandidateHarvester.java.AwsCandidateHarvester.[]AwsCandidateHarvester()", "name": "AwsCandidateHarvester", "arg_nums": 0, "params": [], "return_type": "", "signature": "public AwsCandidateHarvester()", "original_string": "    public AwsCandidateHarvester()\n    {\n        super(\"aws\");\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/AwsCandidateHarvester.java", "class_name": "AwsCandidateHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/AwsCandidateHarvester.java.AwsCandidateHarvester", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nCreates an AWS harvester. The actual addresses wil be retrieved later,\nduring the first harvest.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/AwsCandidateHarvester.java.AwsCandidateHarvester.[void]obtainEC2Addresses()", "name": "obtainEC2Addresses", "arg_nums": 0, "params": [], "return_type": "void", "signature": "private static synchronized void obtainEC2Addresses()", "original_string": "    private static synchronized void obtainEC2Addresses()\n    {\n        if (addressChecked)\n            return;\n        addressChecked = true;\n\n        String localIPStr = null;\n        String publicIPStr = null;\n\n        try\n        {\n            localIPStr = fetch(LOCAL_IP_URL);\n            publicIPStr = fetch(PUBLIC_IP_URL);\n\n            //now let's cross our fingers and hope that what we got above are\n            //real IP addresses\n            face = new TransportAddress(localIPStr, 9, Transport.UDP);\n            mask = new TransportAddress(publicIPStr, 9, Transport.UDP);\n\n            logger.info(\"Detected AWS local IP: \" + face);\n            logger.info(\"Detected AWS public IP: \" + mask);\n\n\n        }\n        catch (Exception exc)\n        {\n            //whatever happens, we just log and fail\n            logger.log(Level.INFO, \"We failed to obtain EC2 instance addresses \"\n                + \"for the following reason: \", exc);\n            logger.info(\"String for local IP: \" + localIPStr);\n            logger.info(\"String for public IP: \" + publicIPStr);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/AwsCandidateHarvester.java", "class_name": "AwsCandidateHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/AwsCandidateHarvester.java.AwsCandidateHarvester", "attributes": {"modifiers": "private static synchronized", "marker_annotations": [], "non_marker_annotations": ["private", "static", "synchronized"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSends HTTP GET queries to\n<tt>http://169.254.169.254/latest/meta-data/local-ipv4</tt> and\n<tt>http://169.254.169.254/latest/meta-data/public-ipv4</tt> to learn the\nprivate (face) and public (mask) addresses of this EC2 instance.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/AwsCandidateHarvester.java.AwsCandidateHarvester.[TransportAddress]getMask()", "name": "getMask", "arg_nums": 0, "params": [], "return_type": "TransportAddress", "signature": "@Override\n    public TransportAddress getMask()", "original_string": "    @Override\n    public TransportAddress getMask()\n    {\n        if (smellsLikeAnEC2())\n        {\n            obtainEC2Addresses();\n            return mask;\n        }\n        return null;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/AwsCandidateHarvester.java", "class_name": "AwsCandidateHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/AwsCandidateHarvester.java.AwsCandidateHarvester", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "TransportAddress", "classes": []}, "docstring": "\nReturns the public (mask) address, or null.\n@return the public (mask) address, or null.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/AwsCandidateHarvester.java.AwsCandidateHarvester.[TransportAddress]getFace()", "name": "getFace", "arg_nums": 0, "params": [], "return_type": "TransportAddress", "signature": "@Override\n    public TransportAddress getFace()", "original_string": "    @Override\n    public TransportAddress getFace()\n    {\n        if (smellsLikeAnEC2())\n        {\n            obtainEC2Addresses();\n            return face;\n        }\n        return null;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/AwsCandidateHarvester.java", "class_name": "AwsCandidateHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/AwsCandidateHarvester.java.AwsCandidateHarvester", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "TransportAddress", "classes": []}, "docstring": "\nReturns the local (face) address, or null.\n@return the local (face) address, or null.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/AwsCandidateHarvester.java.AwsCandidateHarvester.[boolean]smellsLikeAnEC2()", "name": "smellsLikeAnEC2", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "public synchronized static boolean smellsLikeAnEC2()", "original_string": "    public synchronized static boolean smellsLikeAnEC2()\n    {\n        if (RUNNING_ON_EC2 == null)\n        {\n            RUNNING_ON_EC2 = doTestEc2();\n        }\n        return RUNNING_ON_EC2;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/AwsCandidateHarvester.java", "class_name": "AwsCandidateHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/AwsCandidateHarvester.java.AwsCandidateHarvester", "attributes": {"modifiers": "public synchronized static", "marker_annotations": [], "non_marker_annotations": ["public", "synchronized", "static"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nDetermines if there is a decent chance for the box executing this\napplication to be an AWS EC2 instance and returns <tt>true</tt> if so.\n\n@return <tt>true</tt> if there appear to be decent chances for this\nmachine to be an AWS EC2 and <tt>false</tt> otherwise.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/AwsCandidateHarvester.java.AwsCandidateHarvester.[boolean]doTestEc2()", "name": "doTestEc2", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "private static boolean doTestEc2()", "original_string": "    private static boolean doTestEc2()\n    {\n        try\n        {\n            URLConnection conn = new URL(EC2_TEST_URL).openConnection();\n            conn.setConnectTimeout(500); //don't hang for too long\n            conn.getContent();\n\n            return true;\n        }\n        catch(Exception exc)\n        {\n            //ah! I knew you weren't one of those ...\n            return false;\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/AwsCandidateHarvester.java", "class_name": "AwsCandidateHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/AwsCandidateHarvester.java.AwsCandidateHarvester", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nTries to connect to an Amazon EC2-specific URL in order to determine\nwhether we are running on EC2.\n\n@return <tt>true</tt> if the connection succeeded, <tt>false</tt>\notherwise.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/AwsCandidateHarvester.java.AwsCandidateHarvester.[String]fetch(String)", "name": "fetch", "arg_nums": 1, "params": [{"name": "url", "type": "String"}], "return_type": "String", "signature": "private static String fetch(String url)", "original_string": "    private static String fetch(String url)\n        throws Exception\n    {\n        URLConnection conn = new URL(url).openConnection();\n        BufferedReader in = new BufferedReader(new InputStreamReader(\n                    conn.getInputStream(), \"UTF-8\"));\n\n        String retString = in.readLine();\n\n        in.close();\n\n        return retString;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/AwsCandidateHarvester.java", "class_name": "AwsCandidateHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/AwsCandidateHarvester.java.AwsCandidateHarvester", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nRetrieves the content at the specified <tt>url</tt>. No more, no less.\n\n@param url the URL we'd like to open and query.\n\n@return the String we retrieved from the URL.\n\n@throws Exception if anything goes wrong.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/GoogleTurnCandidateHarvester.java.GoogleTurnCandidateHarvester.[]GoogleTurnCandidateHarvester(TransportAddress)", "name": "GoogleTurnCandidateHarvester", "arg_nums": 1, "params": [{"name": "turnServer", "type": "TransportAddress"}], "return_type": "", "signature": "public GoogleTurnCandidateHarvester(TransportAddress turnServer)", "original_string": "    public GoogleTurnCandidateHarvester(TransportAddress turnServer)\n    {\n        this(turnServer, null, null);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/GoogleTurnCandidateHarvester.java", "class_name": "GoogleTurnCandidateHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/GoogleTurnCandidateHarvester.java.GoogleTurnCandidateHarvester", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>GoogleTurnCandidateHarvester</tt> instance which\nis to work with a specific Google TURN server.\n\n@param turnServer the <tt>TransportAddress</tt> of the TURN server the\nnew instance is to work with\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/GoogleTurnCandidateHarvester.java.GoogleTurnCandidateHarvester.[]GoogleTurnCandidateHarvester(TransportAddress,String,String)", "name": "GoogleTurnCandidateHarvester", "arg_nums": 3, "params": [{"name": "turnServer", "type": "TransportAddress"}, {"name": "shortTermCredentialUsername", "type": "String"}, {"name": "password", "type": "String"}], "return_type": "", "signature": "public GoogleTurnCandidateHarvester(TransportAddress turnServer,\n            String shortTermCredentialUsername,\n            String password)", "original_string": "    public GoogleTurnCandidateHarvester(TransportAddress turnServer,\n            String shortTermCredentialUsername,\n            String password)\n    {\n        super(turnServer, shortTermCredentialUsername);\n        this.password = password;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/GoogleTurnCandidateHarvester.java", "class_name": "GoogleTurnCandidateHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/GoogleTurnCandidateHarvester.java.GoogleTurnCandidateHarvester", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>GoogleTurnCandidateHarvester</tt> instance which is\nto work with a specific TURN server using a specific username for the\npurposes of the STUN short-term credential mechanism.\n\n@param turnServer the <tt>TransportAddress</tt> of the TURN server the\nnew instance is to work with\n@param shortTermCredentialUsername the username to be used by the new\ninstance for the purposes of the STUN short-term credential mechanism or\n<tt>null</tt> if the use of the STUN short-term credential mechanism is\nnot determined at the time of the construction of the new instance\n@param password The gingle candidates password necessary to use this TURN\nserver.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/GoogleTurnCandidateHarvester.java.GoogleTurnCandidateHarvester.[GoogleTurnCandidateHarvest]createHarvest(HostCandidate)", "name": "createHarvest", "arg_nums": 1, "params": [{"name": "hostCandidate", "type": "HostCandidate"}], "return_type": "GoogleTurnCandidateHarvest", "signature": "@Override\n    protected GoogleTurnCandidateHarvest createHarvest(\n            HostCandidate hostCandidate)", "original_string": "    @Override\n    protected GoogleTurnCandidateHarvest createHarvest(\n            HostCandidate hostCandidate)\n    {\n        return\n            new GoogleTurnCandidateHarvest(this, hostCandidate, getPassword());\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/GoogleTurnCandidateHarvester.java", "class_name": "GoogleTurnCandidateHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/GoogleTurnCandidateHarvester.java.GoogleTurnCandidateHarvester", "attributes": {"modifiers": "@Override\n    protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "GoogleTurnCandidateHarvest", "classes": []}, "docstring": "\nCreates a new <tt>GoogleTurnCandidateHarvest</tt> instance which is to\nperform TURN harvesting of a specific <tt>HostCandidate</tt>.\n\n@param hostCandidate the <tt>HostCandidate</tt> for which harvesting is\nto be performed by the new <tt>TurnCandidateHarvest</tt> instance\n@return a new <tt>GoogleTurnCandidateHarvest</tt> instance which is to\nperform TURN harvesting of the specified <tt>hostCandidate</tt>\n@see StunCandidateHarvester#createHarvest(HostCandidate)\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/GoogleTurnCandidateHarvester.java.GoogleTurnCandidateHarvester.[String]getPassword()", "name": "getPassword", "arg_nums": 0, "params": [], "return_type": "String", "signature": "public String getPassword()", "original_string": "    public String getPassword()\n    {\n        return this.password;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/GoogleTurnCandidateHarvester.java", "class_name": "GoogleTurnCandidateHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/GoogleTurnCandidateHarvester.java.GoogleTurnCandidateHarvester", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns the password for this candidate.\n@return the password for this candidate.\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/UPNPHarvester.java.UPNPHarvester.[Collection<LocalCandidate>]harvest(Component)", "name": "harvest", "arg_nums": 1, "params": [{"name": "component", "type": "Component"}], "return_type": "Collection<LocalCandidate>", "signature": "public synchronized Collection<LocalCandidate> harvest(Component component)", "original_string": "    public synchronized Collection<LocalCandidate> harvest(Component component)\n    {\n        Collection<LocalCandidate> candidates = new HashSet<>();\n        int retries = 0;\n\n        logger.fine(\"Begin UPnP harvesting\");\n        try\n        {\n            if (device == null)\n            {\n                // do it only once\n                if (finishThreads == 0)\n                {\n                    try\n                    {\n                        UPNPThread wanIPThread = new UPNPThread(stIP);\n                        UPNPThread wanPPPThread = new UPNPThread(stPPP);\n\n                        wanIPThread.start();\n                        wanPPPThread.start();\n\n                        synchronized(rootSync)\n                        {\n                            while (finishThreads != 2)\n                            {\n                                rootSync.wait();\n                            }\n                        }\n\n                        if (wanIPThread.getDevice() != null)\n                        {\n                            device = wanIPThread.getDevice();\n                        }\n                        else if (wanPPPThread.getDevice() != null)\n                        {\n                            device = wanPPPThread.getDevice();\n                        }\n\n                    }\n                    catch(Throwable e)\n                    {\n                        logger.info(\"UPnP discovery failed: \" + e);\n                    }\n                }\n\n                if (device == null)\n                    return candidates;\n            }\n\n            InetAddress localAddress = device.getLocalAddress();\n            String externalIPAddress = device.getExternalIPAddress();\n            PortMappingEntry portMapping = new PortMappingEntry();\n\n            IceSocketWrapper socket = new IceUdpSocketWrapper(\n                new MultiplexingDatagramSocket(0, localAddress));\n            int port = socket.getLocalPort();\n            int externalPort = socket.getLocalPort();\n\n            while (retries < MAX_RETRIES)\n            {\n                if (!device.getSpecificPortMappingEntry(port, \"UDP\",\n                        portMapping))\n                {\n                    if (device.addPortMapping(\n                            externalPort,\n                            port,\n                            localAddress.getHostAddress(),\n                            \"UDP\",\n                            \"ice4j.org: \" + port))\n                    {\n                        List<LocalCandidate> cands = createUPNPCandidate(socket,\n                            externalIPAddress, externalPort, component, device);\n\n                        logger.info(\"Add UPnP port mapping: \" +\n                                externalIPAddress + \" \" + externalPort);\n\n                        // we have to add the UPNPCandidate and also the base.\n                        // if we don't add the base, we won't be able to add\n                        // peer reflexive candidate if someone contact us on the\n                        // UPNPCandidate\n                        for (LocalCandidate cand : cands)\n                        {\n                            //try to add the candidate to the component and then\n                            //only add it to the harvest not redundant\n                            if (component.addLocalCandidate(cand))\n                            {\n                                candidates.add(cand);\n                            }\n                        }\n\n                        break;\n                    }\n                    else\n                    {\n                        port++;\n                    }\n                }\n                else\n                {\n                    port++;\n                }\n                retries++;\n            }\n        }\n        catch(Throwable e)\n        {\n            logger.info(\"Exception while gathering UPnP candidates: \" + e);\n        }\n\n        return candidates;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/UPNPHarvester.java", "class_name": "UPNPHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/UPNPHarvester.java.UPNPHarvester", "attributes": {"modifiers": "public synchronized", "marker_annotations": [], "non_marker_annotations": ["public", "synchronized"], "comments": [], "return_type": "Collection<LocalCandidate>", "classes": []}, "docstring": "\nGathers UPnP candidates for all host <tt>Candidate</tt>s that are\nalready present in the specified <tt>component</tt>. This method relies\non the specified <tt>component</tt> to already contain all its host\ncandidates so that it would resolve them.\n\n@param component the {@link Component} that we'd like to gather candidate\nUPnP <tt>Candidate</tt>s for\n@return  the <tt>LocalCandidate</tt>s gathered by this\n<tt>CandidateHarvester</tt>\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/UPNPHarvester.java.UPNPHarvester.[List<LocalCandidate>]createUPNPCandidate(IceSocketWrapper,String,int,Component,GatewayDevice)", "name": "createUPNPCandidate", "arg_nums": 5, "params": [{"name": "socket", "type": "IceSocketWrapper"}, {"name": "externalIP", "type": "String"}, {"name": "port", "type": "int"}, {"name": "component", "type": "Component"}, {"name": "device", "type": "GatewayDevice"}], "return_type": "List<LocalCandidate>", "signature": "private List<LocalCandidate> createUPNPCandidate(IceSocketWrapper socket,\n            String externalIP, int port, Component component, GatewayDevice device)", "original_string": "    private List<LocalCandidate> createUPNPCandidate(IceSocketWrapper socket,\n            String externalIP, int port, Component component, GatewayDevice device)\n    {\n        List<LocalCandidate> ret = new ArrayList<>();\n        TransportAddress addr\n            = new TransportAddress(externalIP, port, Transport.UDP);\n\n        HostCandidate base = new HostCandidate(socket, component);\n\n        UPNPCandidate candidate\n            = new UPNPCandidate(addr, base, component, device);\n        IceSocketWrapper stunSocket = candidate.getStunSocket(null);\n        candidate.getStunStack().addSocket(stunSocket);\n        ComponentSocket componentSocket = component.getComponentSocket();\n        if (componentSocket != null)\n        {\n            componentSocket.add(candidate.getCandidateIceSocketWrapper());\n        }\n\n        ret.add(candidate);\n        ret.add(base);\n\n        return ret;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/UPNPHarvester.java", "class_name": "UPNPHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/UPNPHarvester.java.UPNPHarvester", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "List<LocalCandidate>", "classes": []}, "docstring": "\nCreate a UPnP candidate.\n\n@param socket local socket\n@param externalIP external IP address\n@param port local port\n@param component parent component\n@param device the UPnP gateway device\n@return a new <tt>UPNPCandidate</tt> instance which\nrepresents the specified <tt>TransportAddress</tt>\n"}, {"uris": "src/main/java/org/ice4j/ice/harvest/UPNPHarvester.java.UPNPHarvester.[String]toString()", "name": "toString", "arg_nums": 0, "params": [], "return_type": "String", "signature": "@Override\n    public String toString()", "original_string": "    @Override\n    public String toString()\n    {\n        return getClass().getSimpleName();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/harvest/UPNPHarvester.java", "class_name": "UPNPHarvester", "class_uri": "src/main/java/org/ice4j/ice/harvest/UPNPHarvester.java.UPNPHarvester", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns a <tt>String</tt> representation of this harvester containing its\nname.\n\n@return a <tt>String</tt> representation of this harvester containing its\nname.\n"}, {"uris": "src/main/java/org/ice4j/ice/sdp/IceSdpUtils.java.IceSdpUtils.[void]setIceCredentials(SessionDescription,String,String)", "name": "setIceCredentials", "arg_nums": 3, "params": [{"name": "sDes", "type": "SessionDescription"}, {"name": "uFrag", "type": "String"}, {"name": "pwd", "type": "String"}], "return_type": "void", "signature": "@SuppressWarnings(\"unchecked\") // SDP legacy\n    public static void setIceCredentials(SessionDescription sDes,\n                                         String             uFrag,\n                                         String             pwd)", "original_string": "    @SuppressWarnings(\"unchecked\") // SDP legacy\n    public static void setIceCredentials(SessionDescription sDes,\n                                         String             uFrag,\n                                         String             pwd)\n        throws NullPointerException\n    {\n        if (sDes == null || uFrag == null || pwd == null)\n        {\n            throw new NullPointerException(\n                \"sDes, uFrag and pwd, cannot be null\");\n        }\n\n        try\n        {\n            Vector<Attribute> sessionAttributes = sDes.getAttributes(true);\n\n            //ice u-frag and password\n            sessionAttributes.add(sdpFactory.createAttribute(ICE_UFRAG, uFrag));\n            sessionAttributes.add(sdpFactory.createAttribute(ICE_PWD, pwd));\n\n            sDes.setAttributes(sessionAttributes);\n        }\n        catch (Exception cause)\n        {\n           // this is very unlikely to happen but we should still log.\n           // Just in case.\n           logger.log(Level.INFO,\n               \"Failed to set ICE credentials for some weird reason\",\n               cause);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/sdp/IceSdpUtils.java", "class_name": "IceSdpUtils", "class_uri": "src/main/java/org/ice4j/ice/sdp/IceSdpUtils.java.IceSdpUtils", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\") // SDP legacy\n    public static", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public", "static"], "comments": ["// SDP legacy"], "return_type": "void", "classes": []}, "docstring": "\nSets the specified ICE user fragment and password as attributes of the\nspecified session description.\n\n@param sDes the session description where we'd like to set a user\nfragment and a password.\n@param uFrag the ICE user name fragment that we'd like to set on the\nsession description\n@param pwd the ICE password that we'd like to set on the session\ndescription\n\n@throws NullPointerException if the either of the parameters is null\n"}, {"uris": "src/main/java/org/ice4j/ice/sdp/IceSdpUtils.java.IceSdpUtils.[void]initMediaDescription(MediaDescription,IceMediaStream)", "name": "initMediaDescription", "arg_nums": 2, "params": [{"name": "mediaDescription", "type": "MediaDescription"}, {"name": "iceMediaStream", "type": "IceMediaStream"}], "return_type": "void", "signature": "@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n    public static void initMediaDescription(MediaDescription mediaDescription,\n                                            IceMediaStream   iceMediaStream)", "original_string": "    @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n    public static void initMediaDescription(MediaDescription mediaDescription,\n                                            IceMediaStream   iceMediaStream)\n    {\n        try\n        {\n            //set mid-s\n            mediaDescription.setAttribute(MID, iceMediaStream.getName());\n\n            Component firstComponent = null;\n\n            //add candidates\n            for (Component component : iceMediaStream.getComponents())\n            {\n                //if this is the first component, remember it so that we can\n                //later use it for default candidates.\n                if (firstComponent == null)\n                    firstComponent = component;\n\n                Vector attributes = mediaDescription.getAttributes(true);\n                for (Candidate<?> candidate : component.getLocalCandidates())\n                {\n                    attributes.add(new CandidateAttribute(candidate));\n                }\n            }\n\n            //set the default candidate\n            TransportAddress defaultAddress = firstComponent\n                .getDefaultCandidate().getTransportAddress();\n\n            mediaDescription.getMedia().setMediaPort(\n                defaultAddress.getPort());\n\n            String addressFamily = defaultAddress.isIPv6()\n                                ? Connection.IP6\n                                : Connection.IP4;\n\n            mediaDescription.setConnection(sdpFactory.createConnection(\n                \"IN\", addressFamily, defaultAddress.getHostAddress()));\n\n            //now check if the RTCP port for the default candidate is different\n            //than RTP.port +1, in which case we need to mention it.\n            Component rtcpComponent\n                = iceMediaStream.getComponent(Component.RTCP);\n\n            if ( rtcpComponent != null )\n            {\n                TransportAddress defaultRtcpCandidate = rtcpComponent\n                    .getDefaultCandidate().getTransportAddress();\n\n                if (defaultRtcpCandidate.getPort() != defaultAddress.getPort()+1)\n                {\n                    mediaDescription.setAttribute(\n                        RTCP, Integer.toString(defaultRtcpCandidate.getPort()));\n                }\n            }\n        }\n        catch (SdpException exc)\n        {\n            //this shouldn't happen but let's rethrow an SDP exception just\n            //in case.\n            throw new IllegalArgumentException(\n                \"Something went wrong when setting default candidates\",\n                exc);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/sdp/IceSdpUtils.java", "class_name": "IceSdpUtils", "class_uri": "src/main/java/org/ice4j/ice/sdp/IceSdpUtils.java.IceSdpUtils", "attributes": {"modifiers": "@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n    public static", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings({ \"rawtypes\", \"unchecked\" })", "public", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nReflects the candidates from the various components in\n<tt>iceMediaStream</tt> into the specified m-line. Also sets default\ncandidates into m= lines and c= lines. This method uses media level\nc= lines. They override session level making them pointless. This\nshouldn't be causing problems, but for good taste, make sure you don't\ninclude session level ones and avoid duplication.\n\n@param mediaDescription the media descriptions that we'd like to add\ncandidates to.\n@param iceMediaStream the media stream where we should extract candidates\nfrom.\n"}, {"uris": "src/main/java/org/ice4j/ice/sdp/IceSdpUtils.java.IceSdpUtils.[void]initSessionDescription(SessionDescription,Agent)", "name": "initSessionDescription", "arg_nums": 2, "params": [{"name": "sDes", "type": "SessionDescription"}, {"name": "agent", "type": "Agent"}], "return_type": "void", "signature": "@SuppressWarnings(\"unchecked\") // jain-sdp legacy\n    public static void initSessionDescription(SessionDescription sDes,\n                                              Agent              agent)", "original_string": "    @SuppressWarnings(\"unchecked\") // jain-sdp legacy\n    public static void initSessionDescription(SessionDescription sDes,\n                                              Agent              agent)\n        throws IllegalArgumentException\n    {\n        //now add ICE options\n        StringBuilder allOptionsBuilder = new StringBuilder();\n\n        //if(agent.supportsTrickle())\n            allOptionsBuilder.append(ICE_OPTION_TRICKLE).append(\" \");\n\n        String allOptions = allOptionsBuilder.toString().trim();\n\n        try\n        {\n            if (allOptions.length() > 0)\n            {\n                //get the attributes so that we could easily modify them\n                Vector<Attribute> sessionAttributes = sDes.getAttributes(true);\n\n                sessionAttributes.add(\n                    sdpFactory.createAttribute(ICE_OPTIONS, allOptions));\n            }\n\n            //take care of the origin: first extract one of the default\n            // addresses so that we could set the origin.\n            TransportAddress defaultAddress = agent.getStreams().get(0)\n                .getComponent(Component.RTP).getDefaultCandidate()\n                    .getTransportAddress();\n\n            String addressFamily = defaultAddress.isIPv6()\n                                        ? Connection.IP6\n                                        : Connection.IP4;\n\n            //origin\n            Origin o = sDes.getOrigin();\n\n            if ( o == null || \"user\".equals(o.getUsername()))\n            {\n                //looks like there wasn't any origin set: jain-sdp creates a\n                //default origin that has \"user\" as the user name so we use this\n                //to detect it. it's quite hacky but couldn't fine another way.\n                o = sdpFactory.createOrigin(\"ice4j.org\", 0, 0, \"IN\",\n                        addressFamily, defaultAddress.getHostAddress());\n            }\n            else\n            {\n                //if an origin existed, we just make sure it has the right\n                // address now and are care ful not to touch anything else.\n                o.setAddress(defaultAddress.getHostAddress());\n                o.setAddressType(addressFamily);\n            }\n\n            sDes.setOrigin(o);\n\n            //m lines\n            List<IceMediaStream> streams = agent.getStreams();\n            Vector<MediaDescription> mDescs\n                = new Vector<>(agent.getStreamCount());\n            for (IceMediaStream stream : streams)\n            {\n               MediaDescription mLine = sdpFactory.createMediaDescription(\n                               stream.getName(), 0, //default port comes later\n                               1, SdpConstants.RTP_AVP, new int[]{0});\n\n               IceSdpUtils.initMediaDescription(mLine, stream);\n\n               mDescs.add(mLine);\n            }\n\n            sDes.setMediaDescriptions(mDescs);\n        }\n        catch (SdpException exc)\n        {\n            //this shouldn't happen but let's rethrow an SDP exception just\n            //in case.\n            throw new IllegalArgumentException(\n                \"Something went wrong when setting ICE options\",\n                exc);\n        }\n\n        //first set credentials\n        setIceCredentials(\n            sDes, agent.getLocalUfrag(), agent.getLocalPassword());\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/sdp/IceSdpUtils.java", "class_name": "IceSdpUtils", "class_uri": "src/main/java/org/ice4j/ice/sdp/IceSdpUtils.java.IceSdpUtils", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\") // jain-sdp legacy\n    public static", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public", "static"], "comments": ["// jain-sdp legacy"], "return_type": "void", "classes": []}, "docstring": "\nSets ice credentials, ICE options, media lines and candidates from agent,\non the specified session description.\n\n@param sDes the {@link SessionDescription} that we'd like to setup as per\nthe specified agent.\n@param agent the {@link Agent} that we need to use when initializing\nthe session description.\n\n@throws  IllegalArgumentException Obviously, if there's a problem with\nthe arguments ... duh!\n"}, {"uris": "src/main/java/org/ice4j/ice/sdp/IceSdpUtils.java.IceSdpUtils.[Collection<Attribute>]createTrickleUpdate(Collection<LocalCandidate>)", "name": "createTrickleUpdate", "arg_nums": 1, "params": [{"name": "localCandidates", "type": "Collection<LocalCandidate>"}], "return_type": "Collection<Attribute>", "signature": "public static Collection<Attribute> createTrickleUpdate(\n                                Collection<LocalCandidate> localCandidates)", "original_string": "    public static Collection<Attribute> createTrickleUpdate(\n                                Collection<LocalCandidate> localCandidates)\n    {\n        List<Attribute> trickleUpdate = null;\n\n        if (localCandidates == null || localCandidates.size() == 0)\n        {\n            trickleUpdate = new ArrayList<>(1);\n            trickleUpdate.add(\n                sdpFactory.createAttribute(END_OF_CANDIDATES, null));\n\n            return trickleUpdate;\n        }\n\n        trickleUpdate = new ArrayList<>(localCandidates.size() + 1);\n\n        String streamName = null;\n\n        for (LocalCandidate candidate : localCandidates)\n        {\n           streamName = candidate.getParentComponent()\n               .getParentStream().getName();\n\n            trickleUpdate.add(new CandidateAttribute(candidate));\n        }\n\n        trickleUpdate.add(0, sdpFactory.createAttribute(MID, streamName));\n\n        return trickleUpdate;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/sdp/IceSdpUtils.java", "class_name": "IceSdpUtils", "class_uri": "src/main/java/org/ice4j/ice/sdp/IceSdpUtils.java.IceSdpUtils", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Collection<Attribute>", "classes": []}, "docstring": "\nGenerates and returns a set of attributes that can be used for a trickle\nupdate, such as a SIP INFO, with the specified <tt>localCandidates</tt>.\n\n@param localCandidates the list of {@link LocalCandidate}s that we'd like\nto generate the update for.\n\n@return a collection of {@link CandidateAttribute}s and an MID attribute\nthat we can use in a SIP INFO trickle update.\n"}, {"uris": "src/main/java/org/ice4j/ice/sdp/CandidateAttribute.java.CandidateAttribute.[]CandidateAttribute()", "name": "CandidateAttribute", "arg_nums": 0, "params": [], "return_type": "", "signature": "protected CandidateAttribute()", "original_string": "    protected CandidateAttribute()\n    {\n        this(null);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/sdp/CandidateAttribute.java", "class_name": "CandidateAttribute", "class_uri": "src/main/java/org/ice4j/ice/sdp/CandidateAttribute.java.CandidateAttribute", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "docstring": ""}, {"uris": "src/main/java/org/ice4j/ice/sdp/CandidateAttribute.java.CandidateAttribute.[]CandidateAttribute(Candidate<?>)", "name": "CandidateAttribute", "arg_nums": 1, "params": [{"name": "candidate", "type": "Candidate<?>"}], "return_type": "", "signature": "public CandidateAttribute(Candidate<?> candidate)", "original_string": "    public CandidateAttribute(Candidate<?> candidate)\n    {\n        this.candidate = candidate;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/sdp/CandidateAttribute.java", "class_name": "CandidateAttribute", "class_uri": "src/main/java/org/ice4j/ice/sdp/CandidateAttribute.java.CandidateAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nCreates an attribute instance\n\n@param candidate the Candidate\n"}, {"uris": "src/main/java/org/ice4j/ice/sdp/CandidateAttribute.java.CandidateAttribute.[NameValue]getAttribute()", "name": "getAttribute", "arg_nums": 0, "params": [], "return_type": "NameValue", "signature": "public NameValue getAttribute()", "original_string": "    public NameValue getAttribute()\n    {\n        // We've overridden the method getValue() of AttributeField. The\n        // NameValue pair of the method getAttribute() should return the value of\n        // the method getValue() of AttributeField then. Unfortunately, NameValue\n        // accesses its field value in multiple places so it is not a question of\n        // simply overriding a method or two. As a compromise, initialize a new\n        // NameValue with the current name and value upon each invocation.\n        NameValue attribute = super.getAttribute();\n        String name = getName();\n\n        if ((attribute == null)\n                || (name.equals(attribute.getName())\n                        && (attribute.getValue() == null)))\n        {\n            attribute = new NameValue(name, getValue());\n        }\n        return attribute;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/sdp/CandidateAttribute.java", "class_name": "CandidateAttribute", "class_uri": "src/main/java/org/ice4j/ice/sdp/CandidateAttribute.java.CandidateAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "NameValue", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/ice/sdp/CandidateAttribute.java.CandidateAttribute.[String]getName()", "name": "getName", "arg_nums": 0, "params": [], "return_type": "String", "signature": "public String getName()", "original_string": "    public String getName()\n    {\n        return NAME;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/sdp/CandidateAttribute.java", "class_name": "CandidateAttribute", "class_uri": "src/main/java/org/ice4j/ice/sdp/CandidateAttribute.java.CandidateAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns the name of this attribute\n\n@return a String identity.\n"}, {"uris": "src/main/java/org/ice4j/ice/sdp/CandidateAttribute.java.CandidateAttribute.[void]setName(String)", "name": "setName", "arg_nums": 1, "params": [{"name": "name", "type": "String"}], "return_type": "void", "signature": "public void setName(String name)", "original_string": "    public void setName(String name)\n    {\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/sdp/CandidateAttribute.java", "class_name": "CandidateAttribute", "class_uri": "src/main/java/org/ice4j/ice/sdp/CandidateAttribute.java.CandidateAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nDoes nothing .\n\n@param name ignored.\n"}, {"uris": "src/main/java/org/ice4j/ice/sdp/CandidateAttribute.java.CandidateAttribute.[boolean]hasValue()", "name": "hasValue", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "public boolean hasValue()", "original_string": "    public boolean hasValue()\n    {\n        return true;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/sdp/CandidateAttribute.java", "class_name": "CandidateAttribute", "class_uri": "src/main/java/org/ice4j/ice/sdp/CandidateAttribute.java.CandidateAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nAlways returns <tt>true</tt> as this attribute always has a value.\n\n@return true if the attribute has a value.\n"}, {"uris": "src/main/java/org/ice4j/ice/sdp/CandidateAttribute.java.CandidateAttribute.[String]getValue()", "name": "getValue", "arg_nums": 0, "params": [], "return_type": "String", "signature": "public String getValue()", "original_string": "    public String getValue()\n    {\n        StringBuffer buff = new StringBuffer();\n\n        buff.append(candidate.getFoundation());\n        buff.append(\" \").append(\n            candidate.getParentComponent().getComponentID());\n        buff.append(\" \").append(candidate.getTransport());\n        buff.append(\" \").append(candidate.getPriority());\n        buff.append(\" \").append(\n            candidate.getTransportAddress().getHostAddress());\n        buff.append(\" \").append(\n            candidate.getTransportAddress().getPort());\n        buff.append(\" typ \").append(\n            candidate.getType());\n\n        TransportAddress relAddr = candidate.getRelatedAddress();\n\n        if (relAddr != null)\n        {\n            buff.append(\" raddr \").append(relAddr.getHostAddress());\n            buff.append(\" rport \").append(relAddr.getPort());\n        }\n\n        return buff.toString();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/sdp/CandidateAttribute.java", "class_name": "CandidateAttribute", "class_uri": "src/main/java/org/ice4j/ice/sdp/CandidateAttribute.java.CandidateAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns the value of this attribute.\n\n@return the value\n"}, {"uris": "src/main/java/org/ice4j/ice/sdp/CandidateAttribute.java.CandidateAttribute.[void]setValue(String)", "name": "setValue", "arg_nums": 1, "params": [{"name": "value", "type": "String"}], "return_type": "void", "signature": "public void setValue(String value)", "original_string": "    public void setValue(String value)\n        throws SdpException\n    {\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/sdp/CandidateAttribute.java", "class_name": "CandidateAttribute", "class_uri": "src/main/java/org/ice4j/ice/sdp/CandidateAttribute.java.CandidateAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nParses the value of this attribute.\n\n@param value the - attribute value\n\n@throws javax.sdp.SdpException if there's a problem with the <tt>value\nString</tt>.\n"}, {"uris": "src/main/java/org/ice4j/ice/sdp/CandidateAttribute.java.CandidateAttribute.[char]getTypeChar()", "name": "getTypeChar", "arg_nums": 0, "params": [], "return_type": "char", "signature": "public char getTypeChar()", "original_string": "    public char getTypeChar()\n    {\n        return 'a';\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/sdp/CandidateAttribute.java", "class_name": "CandidateAttribute", "class_uri": "src/main/java/org/ice4j/ice/sdp/CandidateAttribute.java.CandidateAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "char", "classes": []}, "docstring": "\nReturns the type character for the field.\n\n@return the type character for the field.\n"}, {"uris": "src/main/java/org/ice4j/ice/sdp/CandidateAttribute.java.CandidateAttribute.[CandidateAttribute]clone()", "name": "clone", "arg_nums": 0, "params": [], "return_type": "CandidateAttribute", "signature": "public CandidateAttribute clone()", "original_string": "    public CandidateAttribute clone()\n    {\n        CandidateAttribute clone = (CandidateAttribute) super.clone();\n\n        clone.candidate = candidate;\n        return clone;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/sdp/CandidateAttribute.java", "class_name": "CandidateAttribute", "class_uri": "src/main/java/org/ice4j/ice/sdp/CandidateAttribute.java.CandidateAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "CandidateAttribute", "classes": []}, "docstring": "\nReturns a reference to this attribute.\n\n@return a reference to this attribute.\n"}, {"uris": "src/main/java/org/ice4j/ice/sdp/CandidateAttribute.java.CandidateAttribute.[String]encode()", "name": "encode", "arg_nums": 0, "params": [], "return_type": "String", "signature": "public String encode()", "original_string": "     public String encode()\n     {\n         StringBuffer sbuff = new StringBuffer(ATTRIBUTE_FIELD);\n         sbuff.append(getName()).append(Separators.COLON);\n         sbuff.append(getValue());\n         return sbuff.append(Separators.NEWLINE).toString();\n     }", "default_arguments": null, "file": "src/main/java/org/ice4j/ice/sdp/CandidateAttribute.java", "class_name": "CandidateAttribute", "class_uri": "src/main/java/org/ice4j/ice/sdp/CandidateAttribute.java.CandidateAttribute", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\nReturns the string encoded version of this object\n\n@return the string encoded version of this object\n"}, {"uris": "src/main/java/org/ice4j/socket/MultiplexingSocket.java.MultiplexingSocket.[]MultiplexingSocket()", "name": "MultiplexingSocket", "arg_nums": 0, "params": [], "return_type": "", "signature": "public MultiplexingSocket()", "original_string": "    public MultiplexingSocket()\n    {\n        this((Socket) null);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MultiplexingSocket.java", "class_name": "MultiplexingSocket", "class_uri": "src/main/java/org/ice4j/socket/MultiplexingSocket.java.MultiplexingSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>MultiplexingSocket</tt> instance.\n\n@see Socket#Socket()\n"}, {"uris": "src/main/java/org/ice4j/socket/MultiplexingSocket.java.MultiplexingSocket.[]MultiplexingSocket(InetAddress,int)", "name": "MultiplexingSocket", "arg_nums": 2, "params": [{"name": "address", "type": "InetAddress"}, {"name": "port", "type": "int"}], "return_type": "", "signature": "public MultiplexingSocket(InetAddress address, int port)", "original_string": "    public MultiplexingSocket(InetAddress address, int port)\n    {\n        this((Socket) null);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MultiplexingSocket.java", "class_name": "MultiplexingSocket", "class_uri": "src/main/java/org/ice4j/socket/MultiplexingSocket.java.MultiplexingSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>MultiplexingSocket</tt> instance.\n\n@param address not used\n@param port not used\n@see Socket#Socket(InetAddress, int)\n"}, {"uris": "src/main/java/org/ice4j/socket/MultiplexingSocket.java.MultiplexingSocket.[]MultiplexingSocket(InetAddress,int,InetAddress,int)", "name": "MultiplexingSocket", "arg_nums": 4, "params": [{"name": "address", "type": "InetAddress"}, {"name": "port", "type": "int"}, {"name": "localAddr", "type": "InetAddress"}, {"name": "localPort", "type": "int"}], "return_type": "", "signature": "public MultiplexingSocket(\n            InetAddress address, int port,\n            InetAddress localAddr, int localPort)", "original_string": "    public MultiplexingSocket(\n            InetAddress address, int port,\n            InetAddress localAddr, int localPort)\n    {\n        this((Socket) null);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MultiplexingSocket.java", "class_name": "MultiplexingSocket", "class_uri": "src/main/java/org/ice4j/socket/MultiplexingSocket.java.MultiplexingSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>MultiplexingSocket</tt> instance.\n\n@param address not used\n@param port not used\n@param localAddr not used\n@param localPort not used\n@see Socket#Socket(InetAddress, int, InetAddress, int)\n"}, {"uris": "src/main/java/org/ice4j/socket/MultiplexingSocket.java.MultiplexingSocket.[]MultiplexingSocket(Proxy)", "name": "MultiplexingSocket", "arg_nums": 1, "params": [{"name": "proxy", "type": "Proxy"}], "return_type": "", "signature": "public MultiplexingSocket(Proxy proxy)", "original_string": "    public MultiplexingSocket(Proxy proxy)\n    {\n        this((Socket) null);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MultiplexingSocket.java", "class_name": "MultiplexingSocket", "class_uri": "src/main/java/org/ice4j/socket/MultiplexingSocket.java.MultiplexingSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>MultiplexingSocket</tt> instance.\n\n@param proxy not used\n@see Socket#Socket(Proxy)\n"}, {"uris": "src/main/java/org/ice4j/socket/MultiplexingSocket.java.MultiplexingSocket.[]MultiplexingSocket(Socket)", "name": "MultiplexingSocket", "arg_nums": 1, "params": [{"name": "socket", "type": "Socket"}], "return_type": "", "signature": "public MultiplexingSocket(Socket socket)", "original_string": "    public MultiplexingSocket(Socket socket)\n    {\n        super(socket);\n\n        try\n        {\n            setTcpNoDelay(true);\n        }\n        catch (SocketException ex)\n        {\n            logger.info(\"Cannot SO_TCPNODELAY\");\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MultiplexingSocket.java", "class_name": "MultiplexingSocket", "class_uri": "src/main/java/org/ice4j/socket/MultiplexingSocket.java.MultiplexingSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>MultiplexingSocket</tt> instance.\n\n@param socket delegate socket\n"}, {"uris": "src/main/java/org/ice4j/socket/MultiplexingSocket.java.MultiplexingSocket.[]MultiplexingSocket(SocketImpl)", "name": "MultiplexingSocket", "arg_nums": 1, "params": [{"name": "impl", "type": "SocketImpl"}], "return_type": "", "signature": "protected MultiplexingSocket(SocketImpl impl)", "original_string": "    protected MultiplexingSocket(SocketImpl impl)\n    {\n        this((Socket) null);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MultiplexingSocket.java", "class_name": "MultiplexingSocket", "class_uri": "src/main/java/org/ice4j/socket/MultiplexingSocket.java.MultiplexingSocket", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>MultiplexingSocket</tt> instance.\n\n@param impl not used\n@see Socket#Socket(SocketImpl)\n"}, {"uris": "src/main/java/org/ice4j/socket/MultiplexingSocket.java.MultiplexingSocket.[]MultiplexingSocket(String,int)", "name": "MultiplexingSocket", "arg_nums": 2, "params": [{"name": "host", "type": "String"}, {"name": "port", "type": "int"}], "return_type": "", "signature": "public MultiplexingSocket(String host, int port)", "original_string": "    public MultiplexingSocket(String host, int port)\n    {\n        this((Socket) null);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MultiplexingSocket.java", "class_name": "MultiplexingSocket", "class_uri": "src/main/java/org/ice4j/socket/MultiplexingSocket.java.MultiplexingSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>MultiplexingSocket</tt> instance.\n\n@param host not used\n@param port not used\n@see Socket#Socket(String, int)\n"}, {"uris": "src/main/java/org/ice4j/socket/MultiplexingSocket.java.MultiplexingSocket.[]MultiplexingSocket(String,int,InetAddress,int)", "name": "MultiplexingSocket", "arg_nums": 4, "params": [{"name": "host", "type": "String"}, {"name": "port", "type": "int"}, {"name": "localAddr", "type": "InetAddress"}, {"name": "localPort", "type": "int"}], "return_type": "", "signature": "public MultiplexingSocket(\n            String host, int port,\n            InetAddress localAddr, int localPort)", "original_string": "    public MultiplexingSocket(\n            String host, int port,\n            InetAddress localAddr, int localPort)\n    {\n        this((Socket) null);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MultiplexingSocket.java", "class_name": "MultiplexingSocket", "class_uri": "src/main/java/org/ice4j/socket/MultiplexingSocket.java.MultiplexingSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>MultiplexingSocket</tt> instance.\n\n@param host not used\n@param port not used\n@param localAddr not used\n@param localPort not used\n@see Socket#Socket(String, int, InetAddress, int)\n"}, {"uris": "src/main/java/org/ice4j/socket/MultiplexingSocket.java.MultiplexingSocket.[void]close(MultiplexedSocket)", "name": "close", "arg_nums": 1, "params": [{"name": "multiplexed", "type": "MultiplexedSocket"}], "return_type": "void", "signature": "void close(MultiplexedSocket multiplexed)", "original_string": "    void close(MultiplexedSocket multiplexed)\n    {\n        multiplexingXXXSocketSupport.close(multiplexed);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MultiplexingSocket.java", "class_name": "MultiplexingSocket", "class_uri": "src/main/java/org/ice4j/socket/MultiplexingSocket.java.MultiplexingSocket", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCloses a specific <tt>MultiplexedSocket</tt> which filters\n<tt>DatagramPacket</tt>s away from this <tt>Socket</tt>.\n\n@param multiplexed the <tt>MultiplexedSocket</tt> to close\n"}, {"uris": "src/main/java/org/ice4j/socket/MultiplexingSocket.java.MultiplexingSocket.[InputStream]getInputStream()", "name": "getInputStream", "arg_nums": 0, "params": [], "return_type": "InputStream", "signature": "@Override\n    public InputStream getInputStream()", "original_string": "    @Override\n    public InputStream getInputStream()\n        throws IOException\n    {\n        return inputStream;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MultiplexingSocket.java", "class_name": "MultiplexingSocket", "class_uri": "src/main/java/org/ice4j/socket/MultiplexingSocket.java.MultiplexingSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "InputStream", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/MultiplexingSocket.java.MultiplexingSocket.[InputStream]getOriginalInputStream()", "name": "getOriginalInputStream", "arg_nums": 0, "params": [], "return_type": "InputStream", "signature": "public InputStream getOriginalInputStream()", "original_string": "    public InputStream getOriginalInputStream()\n        throws IOException\n    {\n        return super.getInputStream();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MultiplexingSocket.java", "class_name": "MultiplexingSocket", "class_uri": "src/main/java/org/ice4j/socket/MultiplexingSocket.java.MultiplexingSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "InputStream", "classes": []}, "docstring": "\nGet original <tt>InputStream</tt>.\n\n@return original <tt>InputStream</tt>\n@throws IOException if something goes wrong\n"}, {"uris": "src/main/java/org/ice4j/socket/MultiplexingSocket.java.MultiplexingSocket.[OutputStream]getOriginalOutputStream()", "name": "getOriginalOutputStream", "arg_nums": 0, "params": [], "return_type": "OutputStream", "signature": "public OutputStream getOriginalOutputStream()", "original_string": "    public OutputStream getOriginalOutputStream()\n        throws IOException\n    {\n        return super.getOutputStream();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MultiplexingSocket.java", "class_name": "MultiplexingSocket", "class_uri": "src/main/java/org/ice4j/socket/MultiplexingSocket.java.MultiplexingSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "OutputStream", "classes": []}, "docstring": "\nGet original <tt>OutputStream</tt>.\n\n@return original <tt>OutputStream</tt>\n@throws IOException if something goes wrong\n"}, {"uris": "src/main/java/org/ice4j/socket/MultiplexingSocket.java.MultiplexingSocket.[OutputStream]getOutputStream()", "name": "getOutputStream", "arg_nums": 0, "params": [], "return_type": "OutputStream", "signature": "@Override\n    public OutputStream getOutputStream()", "original_string": "    @Override\n    public OutputStream getOutputStream()\n        throws IOException\n    {\n        if (outputStream == null)\n            outputStream = new TCPOutputStream(super.getOutputStream());\n        return outputStream;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MultiplexingSocket.java", "class_name": "MultiplexingSocket", "class_uri": "src/main/java/org/ice4j/socket/MultiplexingSocket.java.MultiplexingSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "OutputStream", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/MultiplexingSocket.java.MultiplexingSocket.[MultiplexedSocket]getSocket(DatagramPacketFilter)", "name": "getSocket", "arg_nums": 1, "params": [{"name": "filter", "type": "DatagramPacketFilter"}], "return_type": "MultiplexedSocket", "signature": "public MultiplexedSocket getSocket(DatagramPacketFilter filter)", "original_string": "    public MultiplexedSocket getSocket(DatagramPacketFilter filter)\n        throws SocketException\n    {\n        return multiplexingXXXSocketSupport.getSocket(filter);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MultiplexingSocket.java", "class_name": "MultiplexingSocket", "class_uri": "src/main/java/org/ice4j/socket/MultiplexingSocket.java.MultiplexingSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "MultiplexedSocket", "classes": []}, "docstring": "\nGets a <tt>MultiplexedDatagramSocket</tt> which filters\n<tt>DatagramPacket</tt>s away from this <tt>DatagramSocket</tt> using a\nspecific <tt>DatagramPacketFilter</tt>. If such a\n<tt>MultiplexedDatagramSocket</tt> does not exist in this instance, it is\ncreated.\n\n@param filter the <tt>DatagramPacketFilter</tt> to get a\n<tt>MultiplexedDatagramSocket</tt> for\n@return a <tt>MultiplexedDatagramSocket</tt> which filters\n<tt>DatagramPacket</tt>s away from this <tt>DatagramSocket</tt> using the\nspecified <tt>filter</tt>\n@throws SocketException if creating the\n<tt>MultiplexedDatagramSocket</tt> for the specified <tt>filter</tt>\nfails\n"}, {"uris": "src/main/java/org/ice4j/socket/MultiplexingSocket.java.MultiplexingSocket.[int]getSoTimeout()", "name": "getSoTimeout", "arg_nums": 0, "params": [], "return_type": "int", "signature": "@Override\n    public int getSoTimeout()", "original_string": "    @Override\n    public int getSoTimeout()\n    {\n        return soTimeout;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MultiplexingSocket.java", "class_name": "MultiplexingSocket", "class_uri": "src/main/java/org/ice4j/socket/MultiplexingSocket.java.MultiplexingSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/MultiplexingSocket.java.MultiplexingSocket.[void]multiplexingXXXSocketSupportDoReceive(DatagramPacket)", "name": "multiplexingXXXSocketSupportDoReceive", "arg_nums": 1, "params": [{"name": "p", "type": "DatagramPacket"}], "return_type": "void", "signature": "private void multiplexingXXXSocketSupportDoReceive(DatagramPacket p)", "original_string": "    private void multiplexingXXXSocketSupportDoReceive(DatagramPacket p)\n        throws IOException\n    {\n        super.receive(p);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MultiplexingSocket.java", "class_name": "MultiplexingSocket", "class_uri": "src/main/java/org/ice4j/socket/MultiplexingSocket.java.MultiplexingSocket", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nImplements {@link MultiplexingXXXSocketSupport#doReceive(DatagramPacket)}\non behalf of {@link #multiplexingXXXSocketSupport}. Receives a\n{@code DatagramPacket} from this socket.\n\n@param p the {@code DatagramPacket} into which to place the incoming data\n@throws IOException if an I/O error occurs\n"}, {"uris": "src/main/java/org/ice4j/socket/MultiplexingSocket.java.MultiplexingSocket.[void]multiplexingXXXSocketSupportDoSetReceiveBufferSize(int)", "name": "multiplexingXXXSocketSupportDoSetReceiveBufferSize", "arg_nums": 1, "params": [{"name": "receiveBufferSize", "type": "int"}], "return_type": "void", "signature": "private void multiplexingXXXSocketSupportDoSetReceiveBufferSize(\n            int receiveBufferSize)", "original_string": "    private void multiplexingXXXSocketSupportDoSetReceiveBufferSize(\n            int receiveBufferSize)\n        throws SocketException\n    {\n        super.setReceiveBufferSize(receiveBufferSize);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MultiplexingSocket.java", "class_name": "MultiplexingSocket", "class_uri": "src/main/java/org/ice4j/socket/MultiplexingSocket.java.MultiplexingSocket", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nImplements\n{@link MultiplexingXXXSocketSupport#doSetReceiveBufferSize(int)} on\nbehalf of {@link #multiplexingXXXSocketSupport}. Sets the\n{@code SO_RCVBUF} option to the specified value for this\n{@code DatagramSocket}. The {@code SO_RCVBUF} option is used by the\nnetwork implementation as a hint to size the underlying network I/O\nbuffers. The {@code SO_RCVBUF} setting may also be used by the network\nimplementation to determine the maximum size of the packet that can be\nreceived on this socket.\n\n@param receiveBufferSize the size to which to set the receive buffer size\n@throws SocketException if there is an error in the underlying protocol,\nsuch as a TCP error\n"}, {"uris": "src/main/java/org/ice4j/socket/MultiplexingSocket.java.MultiplexingSocket.[void]receive(DatagramPacket)", "name": "receive", "arg_nums": 1, "params": [{"name": "p", "type": "DatagramPacket"}], "return_type": "void", "signature": "@Override\n    public void receive(DatagramPacket p)", "original_string": "    @Override\n    public void receive(DatagramPacket p)\n        throws IOException\n    {\n        try\n        {\n            setOriginalInputStream(super.getInputStream());\n        }\n        catch(Exception e)\n        {\n        }\n\n        multiplexingXXXSocketSupport.receive(received, p, soTimeout);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MultiplexingSocket.java", "class_name": "MultiplexingSocket", "class_uri": "src/main/java/org/ice4j/socket/MultiplexingSocket.java.MultiplexingSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nReceives a datagram packet from this socket. The <tt>DatagramPacket</tt>s\nreturned by this method do not match any of the\n<tt>DatagramPacketFilter</tt>s of the <tt>MultiplexedDatagramSocket</tt>s\nassociated with this instance at the time of their receipt. When this\nmethod returns, the <tt>DatagramPacket</tt>'s buffer is filled with the\ndata received. The datagram packet also contains the sender's IP address,\nand the port number on the sender's machine.\n<p>\nThis method blocks until a datagram is received. The <tt>length</tt>\nfield of the datagram packet object contains the length of the received\nmessage. If the message is longer than the packet's length, the message\nis truncated.\n</p>\n\n@param p the <tt>DatagramPacket</tt> into which to place the incoming\ndata\n@throws IOException if an I/O error occurs\n@see DelegatingSocket#receive(DatagramPacket)\n"}, {"uris": "src/main/java/org/ice4j/socket/MultiplexingSocket.java.MultiplexingSocket.[void]receive(MultiplexedSocket,DatagramPacket)", "name": "receive", "arg_nums": 2, "params": [{"name": "multiplexed", "type": "MultiplexedSocket"}, {"name": "p", "type": "DatagramPacket"}], "return_type": "void", "signature": "void receive(MultiplexedSocket multiplexed, DatagramPacket p)", "original_string": "    void receive(MultiplexedSocket multiplexed, DatagramPacket p)\n        throws IOException\n    {\n        try\n        {\n            setOriginalInputStream(super.getInputStream());\n        }\n        catch(Exception e)\n        {\n        }\n\n        multiplexingXXXSocketSupport.receive(\n                multiplexed.received,\n                p,\n                multiplexed.getSoTimeout());\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MultiplexingSocket.java", "class_name": "MultiplexingSocket", "class_uri": "src/main/java/org/ice4j/socket/MultiplexingSocket.java.MultiplexingSocket", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nReceives a <tt>DatagramPacket</tt> from this <tt>Socket</tt> upon\nrequest from a specific <tt>MultiplexedSocket</tt>.\n\n@param multiplexed the <tt>MultiplexedSocket</tt> which requests\nthe receipt of a <tt>DatagramPacket</tt> from the network\n@param p the <tt>DatagramPacket</tt> to receive the data from the network\n@throws IOException if an I/O error occurs\n"}, {"uris": "src/main/java/org/ice4j/socket/MultiplexingSocket.java.MultiplexingSocket.[void]setSoTimeout(int)", "name": "setSoTimeout", "arg_nums": 1, "params": [{"name": "timeout", "type": "int"}], "return_type": "void", "signature": "@Override\n    public void setSoTimeout(int timeout)", "original_string": "    @Override\n    public void setSoTimeout(int timeout)\n        throws SocketException\n    {\n        super.setSoTimeout(timeout);\n\n        soTimeout = timeout;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MultiplexingSocket.java", "class_name": "MultiplexingSocket", "class_uri": "src/main/java/org/ice4j/socket/MultiplexingSocket.java.MultiplexingSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/IceTcpSocketWrapper.java.IceTcpSocketWrapper.[]IceTcpSocketWrapper(Socket)", "name": "IceTcpSocketWrapper", "arg_nums": 1, "params": [{"name": "delegate", "type": "Socket"}], "return_type": "", "signature": "public IceTcpSocketWrapper(Socket delegate)", "original_string": "    public IceTcpSocketWrapper(Socket delegate)\n        throws IOException\n    {\n        socket = delegate;\n\n        if (delegate instanceof DelegatingSocket)\n        {\n            inputStream = null;\n            outputStream = null;\n            socketAsDelegatingSocket = (DelegatingSocket) delegate;\n        }\n        else\n        {\n            inputStream = delegate.getInputStream();\n            outputStream = delegate.getOutputStream();\n            socketAsDelegatingSocket = null;\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/IceTcpSocketWrapper.java", "class_name": "IceTcpSocketWrapper", "class_uri": "src/main/java/org/ice4j/socket/IceTcpSocketWrapper.java.IceTcpSocketWrapper", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nConstructor.\n\n@param delegate delegate <tt>Socket</tt>\n\n@throws IOException if something goes wrong during initialization\n"}, {"uris": "src/main/java/org/ice4j/socket/IceTcpSocketWrapper.java.IceTcpSocketWrapper.[void]close()", "name": "close", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Override\n    public void close()", "original_string": "    @Override\n    public void close()\n    {\n        try\n        {\n            socket.close();\n        }\n        catch(IOException e)\n        {\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/IceTcpSocketWrapper.java", "class_name": "IceTcpSocketWrapper", "class_uri": "src/main/java/org/ice4j/socket/IceTcpSocketWrapper.java.IceTcpSocketWrapper", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/IceTcpSocketWrapper.java.IceTcpSocketWrapper.[InetAddress]getLocalAddress()", "name": "getLocalAddress", "arg_nums": 0, "params": [], "return_type": "InetAddress", "signature": "@Override\n    public InetAddress getLocalAddress()", "original_string": "    @Override\n    public InetAddress getLocalAddress()\n    {\n        return socket.getLocalAddress();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/IceTcpSocketWrapper.java", "class_name": "IceTcpSocketWrapper", "class_uri": "src/main/java/org/ice4j/socket/IceTcpSocketWrapper.java.IceTcpSocketWrapper", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "InetAddress", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/IceTcpSocketWrapper.java.IceTcpSocketWrapper.[int]getLocalPort()", "name": "getLocalPort", "arg_nums": 0, "params": [], "return_type": "int", "signature": "@Override\n    public int getLocalPort()", "original_string": "    @Override\n    public int getLocalPort()\n    {\n        return socket.getLocalPort();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/IceTcpSocketWrapper.java", "class_name": "IceTcpSocketWrapper", "class_uri": "src/main/java/org/ice4j/socket/IceTcpSocketWrapper.java.IceTcpSocketWrapper", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/IceTcpSocketWrapper.java.IceTcpSocketWrapper.[SocketAddress]getLocalSocketAddress()", "name": "getLocalSocketAddress", "arg_nums": 0, "params": [], "return_type": "SocketAddress", "signature": "@Override\n    public SocketAddress getLocalSocketAddress()", "original_string": "    @Override\n    public SocketAddress getLocalSocketAddress()\n    {\n        return socket.getLocalSocketAddress();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/IceTcpSocketWrapper.java", "class_name": "IceTcpSocketWrapper", "class_uri": "src/main/java/org/ice4j/socket/IceTcpSocketWrapper.java.IceTcpSocketWrapper", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "SocketAddress", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/IceTcpSocketWrapper.java.IceTcpSocketWrapper.[Socket]getTCPSocket()", "name": "getTCPSocket", "arg_nums": 0, "params": [], "return_type": "Socket", "signature": "@Override\n    public Socket getTCPSocket()", "original_string": "    @Override\n    public Socket getTCPSocket()\n    {\n        return socket;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/IceTcpSocketWrapper.java", "class_name": "IceTcpSocketWrapper", "class_uri": "src/main/java/org/ice4j/socket/IceTcpSocketWrapper.java.IceTcpSocketWrapper", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Socket", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/IceTcpSocketWrapper.java.IceTcpSocketWrapper.[DatagramSocket]getUDPSocket()", "name": "getUDPSocket", "arg_nums": 0, "params": [], "return_type": "DatagramSocket", "signature": "@Override\n    public DatagramSocket getUDPSocket()", "original_string": "    @Override\n    public DatagramSocket getUDPSocket()\n    {\n        return null;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/IceTcpSocketWrapper.java", "class_name": "IceTcpSocketWrapper", "class_uri": "src/main/java/org/ice4j/socket/IceTcpSocketWrapper.java.IceTcpSocketWrapper", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "DatagramSocket", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/IceTcpSocketWrapper.java.IceTcpSocketWrapper.[void]receive(DatagramPacket)", "name": "receive", "arg_nums": 1, "params": [{"name": "p", "type": "DatagramPacket"}], "return_type": "void", "signature": "@Override\n    public void receive(DatagramPacket p)", "original_string": "    @Override\n    public void receive(DatagramPacket p) throws IOException\n    {\n        if (socketAsDelegatingSocket != null)\n        {\n            socketAsDelegatingSocket.receive(p);\n        }\n        else\n        {\n            DelegatingSocket.receiveFromInputStream(\n                    p,\n                    inputStream,\n                    getLocalAddress(), getLocalPort());\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/IceTcpSocketWrapper.java", "class_name": "IceTcpSocketWrapper", "class_uri": "src/main/java/org/ice4j/socket/IceTcpSocketWrapper.java.IceTcpSocketWrapper", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/IceTcpSocketWrapper.java.IceTcpSocketWrapper.[void]send(DatagramPacket)", "name": "send", "arg_nums": 1, "params": [{"name": "p", "type": "DatagramPacket"}], "return_type": "void", "signature": "@Override\n    public void send(DatagramPacket p)", "original_string": "    @Override\n    public void send(DatagramPacket p)\n        throws IOException\n    {\n        if (socketAsDelegatingSocket != null)\n        {\n            socketAsDelegatingSocket.send(p);\n        }\n        else\n        {\n            int len = p.getLength();\n            int off = p.getOffset();\n            byte data[] = new byte[len + 2];\n\n            data[0] = (byte)((len >> 8) & 0xff);\n            data[1] = (byte)(len & 0xff);\n            System.arraycopy(p.getData(), off, data, 2, len);\n            outputStream.write(data, 0, len + 2);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/IceTcpSocketWrapper.java", "class_name": "IceTcpSocketWrapper", "class_uri": "src/main/java/org/ice4j/socket/IceTcpSocketWrapper.java.IceTcpSocketWrapper", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/TurnDatagramPacketFilter.java.TurnDatagramPacketFilter.[]TurnDatagramPacketFilter(TransportAddress)", "name": "TurnDatagramPacketFilter", "arg_nums": 1, "params": [{"name": "turnServer", "type": "TransportAddress"}], "return_type": "", "signature": "public TurnDatagramPacketFilter(TransportAddress turnServer)", "original_string": "    public TurnDatagramPacketFilter(TransportAddress turnServer)\n    {\n        super(turnServer);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/TurnDatagramPacketFilter.java", "class_name": "TurnDatagramPacketFilter", "class_uri": "src/main/java/org/ice4j/socket/TurnDatagramPacketFilter.java.TurnDatagramPacketFilter", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>TurnDatagramPacketFilter</tt> which will accept\n<tt>DatagramPacket</tt>s which represent TURN messages and which are part\nof the communication with a specific TURN server.\n\n@param turnServer the <tt>TransportAddress</tt> of the TURN server\n<tt>DatagramPacket</tt>s representing TURN messages from and to which\nwill be accepted by the new instance\n"}, {"uris": "src/main/java/org/ice4j/socket/TurnDatagramPacketFilter.java.TurnDatagramPacketFilter.[boolean]accept(DatagramPacket)", "name": "accept", "arg_nums": 1, "params": [{"name": "p", "type": "DatagramPacket"}], "return_type": "boolean", "signature": "@Override\n    public boolean accept(DatagramPacket p)", "original_string": "    @Override\n    public boolean accept(DatagramPacket p)\n    {\n        if (super.accept(p))\n        {\n            /*\n             * The specified DatagramPacket represents a STUN message with a\n             * TURN method.\n             */\n            return true;\n        }\n        else\n        {\n\n            /*\n             * The specified DatagramPacket does not come from or is not being\n             * sent to the TURN server associated with this instance or is a\n             * ChannelData message which is not supported by\n             * TurnDatagramPacketFilter.\n             */\n            return false;\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/TurnDatagramPacketFilter.java", "class_name": "TurnDatagramPacketFilter", "class_uri": "src/main/java/org/ice4j/socket/TurnDatagramPacketFilter.java.TurnDatagramPacketFilter", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nDetermines whether a specific <tt>DatagramPacket</tt> represents a TURN\nmessage which is part of the communication with the TURN server\nassociated with this instance.\n\n@param p the <tt>DatagramPacket</tt> to be checked whether it represents\na TURN message which is part of the communicator with the TURN server\nassociated with this instance\n@return <tt>true</tt> if the specified <tt>DatagramPacket</tt> represents\na TURN message which is part of the communication with the TURN server\nassociated with this instance; otherwise, <tt>false</tt>\n"}, {"uris": "src/main/java/org/ice4j/socket/TurnDatagramPacketFilter.java.TurnDatagramPacketFilter.[boolean]acceptMethod(char)", "name": "acceptMethod", "arg_nums": 1, "params": [{"name": "method", "type": "char"}], "return_type": "boolean", "signature": "@Override\n    protected boolean acceptMethod(char method)", "original_string": "    @Override\n    protected boolean acceptMethod(char method)\n    {\n        if (super.acceptMethod(method))\n            return true;\n        else\n        {\n            switch (method)\n            {\n            case Message.TURN_METHOD_ALLOCATE:\n            case Message.TURN_METHOD_CHANNELBIND:\n            case Message.TURN_METHOD_CREATEPERMISSION:\n            case Message.TURN_METHOD_DATA:\n            case Message.TURN_METHOD_REFRESH:\n            case Message.TURN_METHOD_SEND:\n            case 0x0005: /* old TURN DATA indication */\n                return true;\n            default:\n                return false;\n            }\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/TurnDatagramPacketFilter.java", "class_name": "TurnDatagramPacketFilter", "class_uri": "src/main/java/org/ice4j/socket/TurnDatagramPacketFilter.java.TurnDatagramPacketFilter", "attributes": {"modifiers": "@Override\n    protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nDetermines whether this <tt>DatagramPacketFilter</tt> accepts a\n<tt>DatagramPacket</tt> which represents a STUN message with a specific\nSTUN method. <tt>TurnDatagramPacketFilter</tt> accepts TURN methods.\n\n@param method the STUN method of a STUN message represented by a\n<tt>DatagramPacket</tt> to be checked whether it is accepted by this\n<tt>DatagramPacketFilter</tt>\n@return <tt>true</tt> if this <tt>DatagramPacketFilter</tt> accepts the\n<tt>DatagramPacket</tt> which represents a STUN message with the\nspecified STUN method; otherwise, <tt>false</tt>\n@see StunDatagramPacketFilter#acceptMethod(char)\n"}, {"uris": "src/main/java/org/ice4j/socket/IceUdpSocketWrapper.java.IceUdpSocketWrapper.[]IceUdpSocketWrapper(DatagramSocket)", "name": "IceUdpSocketWrapper", "arg_nums": 1, "params": [{"name": "delegate", "type": "DatagramSocket"}], "return_type": "", "signature": "public IceUdpSocketWrapper(DatagramSocket delegate)", "original_string": "    public IceUdpSocketWrapper(DatagramSocket delegate)\n    {\n        this.socket = delegate;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/IceUdpSocketWrapper.java", "class_name": "IceUdpSocketWrapper", "class_uri": "src/main/java/org/ice4j/socket/IceUdpSocketWrapper.java.IceUdpSocketWrapper", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nConstructor.\n\n@param delegate delegate <tt>DatagramSocket</tt>\n"}, {"uris": "src/main/java/org/ice4j/socket/IceUdpSocketWrapper.java.IceUdpSocketWrapper.[void]send(DatagramPacket)", "name": "send", "arg_nums": 1, "params": [{"name": "p", "type": "DatagramPacket"}], "return_type": "void", "signature": "@Override\n    public void send(DatagramPacket p)", "original_string": "    @Override\n    public void send(DatagramPacket p)\n        throws IOException\n    {\n        socket.send(p);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/IceUdpSocketWrapper.java", "class_name": "IceUdpSocketWrapper", "class_uri": "src/main/java/org/ice4j/socket/IceUdpSocketWrapper.java.IceUdpSocketWrapper", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/IceUdpSocketWrapper.java.IceUdpSocketWrapper.[void]receive(DatagramPacket)", "name": "receive", "arg_nums": 1, "params": [{"name": "p", "type": "DatagramPacket"}], "return_type": "void", "signature": "@Override\n    public void receive(DatagramPacket p)", "original_string": "    @Override\n    public void receive(DatagramPacket p) throws IOException\n    {\n        socket.receive(p);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/IceUdpSocketWrapper.java", "class_name": "IceUdpSocketWrapper", "class_uri": "src/main/java/org/ice4j/socket/IceUdpSocketWrapper.java.IceUdpSocketWrapper", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/IceUdpSocketWrapper.java.IceUdpSocketWrapper.[void]close()", "name": "close", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Override\n    public void close()", "original_string": "    @Override\n    public void close()\n    {\n        socket.close();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/IceUdpSocketWrapper.java", "class_name": "IceUdpSocketWrapper", "class_uri": "src/main/java/org/ice4j/socket/IceUdpSocketWrapper.java.IceUdpSocketWrapper", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/IceUdpSocketWrapper.java.IceUdpSocketWrapper.[InetAddress]getLocalAddress()", "name": "getLocalAddress", "arg_nums": 0, "params": [], "return_type": "InetAddress", "signature": "@Override\n    public InetAddress getLocalAddress()", "original_string": "    @Override\n    public InetAddress getLocalAddress()\n    {\n        return socket.getLocalAddress();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/IceUdpSocketWrapper.java", "class_name": "IceUdpSocketWrapper", "class_uri": "src/main/java/org/ice4j/socket/IceUdpSocketWrapper.java.IceUdpSocketWrapper", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "InetAddress", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/IceUdpSocketWrapper.java.IceUdpSocketWrapper.[int]getLocalPort()", "name": "getLocalPort", "arg_nums": 0, "params": [], "return_type": "int", "signature": "@Override\n    public int getLocalPort()", "original_string": "    @Override\n    public int getLocalPort()\n    {\n        return socket.getLocalPort();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/IceUdpSocketWrapper.java", "class_name": "IceUdpSocketWrapper", "class_uri": "src/main/java/org/ice4j/socket/IceUdpSocketWrapper.java.IceUdpSocketWrapper", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/IceUdpSocketWrapper.java.IceUdpSocketWrapper.[SocketAddress]getLocalSocketAddress()", "name": "getLocalSocketAddress", "arg_nums": 0, "params": [], "return_type": "SocketAddress", "signature": "@Override\n    public SocketAddress getLocalSocketAddress()", "original_string": "    @Override\n    public SocketAddress getLocalSocketAddress()\n    {\n        return socket.getLocalSocketAddress();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/IceUdpSocketWrapper.java", "class_name": "IceUdpSocketWrapper", "class_uri": "src/main/java/org/ice4j/socket/IceUdpSocketWrapper.java.IceUdpSocketWrapper", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "SocketAddress", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/IceUdpSocketWrapper.java.IceUdpSocketWrapper.[Socket]getTCPSocket()", "name": "getTCPSocket", "arg_nums": 0, "params": [], "return_type": "Socket", "signature": "@Override\n    public Socket getTCPSocket()", "original_string": "    @Override\n    public Socket getTCPSocket()\n    {\n        return null;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/IceUdpSocketWrapper.java", "class_name": "IceUdpSocketWrapper", "class_uri": "src/main/java/org/ice4j/socket/IceUdpSocketWrapper.java.IceUdpSocketWrapper", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Socket", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/IceUdpSocketWrapper.java.IceUdpSocketWrapper.[DatagramSocket]getUDPSocket()", "name": "getUDPSocket", "arg_nums": 0, "params": [], "return_type": "DatagramSocket", "signature": "@Override\n    public DatagramSocket getUDPSocket()", "original_string": "    @Override\n    public DatagramSocket getUDPSocket()\n    {\n        return socket;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/IceUdpSocketWrapper.java", "class_name": "IceUdpSocketWrapper", "class_uri": "src/main/java/org/ice4j/socket/IceUdpSocketWrapper.java.IceUdpSocketWrapper", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "DatagramSocket", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/BaseDelegatingServerSocketChannel.java.BaseDelegatingServerSocketChannel.[]BaseDelegatingServerSocketChannel(T)", "name": "BaseDelegatingServerSocketChannel", "arg_nums": 1, "params": [{"name": "delegate", "type": "T"}], "return_type": "", "signature": "public BaseDelegatingServerSocketChannel(T delegate)", "original_string": "    public BaseDelegatingServerSocketChannel(T delegate)\n    {\n        super(delegate.provider());\n\n        this.delegate = delegate;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/BaseDelegatingServerSocketChannel.java", "class_name": "BaseDelegatingServerSocketChannel", "class_uri": "src/main/java/org/ice4j/socket/BaseDelegatingServerSocketChannel.java.BaseDelegatingServerSocketChannel", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new {@code BaseDelegatingServerSocketChannel} instance\nwhich is to delegate (its method calls) to a specific\n{@code ServerSocketChannel}.\n\n@param delegate the {@code ServerSocketChannel} the new instance is to\ndelegate (its method calls) to\n"}, {"uris": "src/main/java/org/ice4j/socket/BaseDelegatingServerSocketChannel.java.BaseDelegatingServerSocketChannel.[SocketChannel]accept()", "name": "accept", "arg_nums": 0, "params": [], "return_type": "SocketChannel", "signature": "@Override\n    public SocketChannel accept()", "original_string": "    @Override\n    public SocketChannel accept()\n        throws IOException\n    {\n        SocketChannel channel = delegate.accept();\n\n        return (channel == null) ? null : implAccept(channel);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/BaseDelegatingServerSocketChannel.java", "class_name": "BaseDelegatingServerSocketChannel", "class_uri": "src/main/java/org/ice4j/socket/BaseDelegatingServerSocketChannel.java.BaseDelegatingServerSocketChannel", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "SocketChannel", "classes": []}, "docstring": "\n{@inheritDoc}\n\nForwards to {@link #delegate}.\n"}, {"uris": "src/main/java/org/ice4j/socket/BaseDelegatingServerSocketChannel.java.BaseDelegatingServerSocketChannel.[ServerSocketChannel]bind(SocketAddress,int)", "name": "bind", "arg_nums": 2, "params": [{"name": "local", "type": "SocketAddress"}, {"name": "backlog", "type": "int"}], "return_type": "ServerSocketChannel", "signature": "@Override\n    public ServerSocketChannel bind(SocketAddress local, int backlog)", "original_string": "    @Override\n    public ServerSocketChannel bind(SocketAddress local, int backlog)\n        throws IOException\n    {\n        delegate.bind(local, backlog);\n        return this;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/BaseDelegatingServerSocketChannel.java", "class_name": "BaseDelegatingServerSocketChannel", "class_uri": "src/main/java/org/ice4j/socket/BaseDelegatingServerSocketChannel.java.BaseDelegatingServerSocketChannel", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "ServerSocketChannel", "classes": []}, "docstring": "\n{@inheritDoc}\n\nForwards to {@link #delegate} and returns {@code this}.\n"}, {"uris": "src/main/java/org/ice4j/socket/BaseDelegatingServerSocketChannel.java.BaseDelegatingServerSocketChannel.[SocketAddress]getLocalAddress()", "name": "getLocalAddress", "arg_nums": 0, "params": [], "return_type": "SocketAddress", "signature": "@Override\n    public SocketAddress getLocalAddress()", "original_string": "    @Override\n    public SocketAddress getLocalAddress()\n        throws IOException\n    {\n        return delegate.getLocalAddress();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/BaseDelegatingServerSocketChannel.java", "class_name": "BaseDelegatingServerSocketChannel", "class_uri": "src/main/java/org/ice4j/socket/BaseDelegatingServerSocketChannel.java.BaseDelegatingServerSocketChannel", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "SocketAddress", "classes": []}, "docstring": "\n{@inheritDoc}\n\nForwards to {@link #delegate}.\n"}, {"uris": "src/main/java/org/ice4j/socket/BaseDelegatingServerSocketChannel.java.BaseDelegatingServerSocketChannel.[U]getOption(SocketOption<U>)", "name": "getOption", "arg_nums": 1, "params": [{"name": "name", "type": "SocketOption<U>"}], "return_type": "U", "signature": "@Override\n    public <U> U getOption(SocketOption<U> name)", "original_string": "    @Override\n    public <U> U getOption(SocketOption<U> name)\n        throws IOException\n    {\n        return delegate.getOption(name);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/BaseDelegatingServerSocketChannel.java", "class_name": "BaseDelegatingServerSocketChannel", "class_uri": "src/main/java/org/ice4j/socket/BaseDelegatingServerSocketChannel.java.BaseDelegatingServerSocketChannel", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "U", "classes": []}, "docstring": "\n{@inheritDoc}\n\nForwards to {@link #delegate}.\n"}, {"uris": "src/main/java/org/ice4j/socket/BaseDelegatingServerSocketChannel.java.BaseDelegatingServerSocketChannel.[SocketChannel]implAccept(SocketChannel)", "name": "implAccept", "arg_nums": 1, "params": [{"name": "accepted", "type": "SocketChannel"}], "return_type": "SocketChannel", "signature": "protected SocketChannel implAccept(SocketChannel accepted)", "original_string": "    protected SocketChannel implAccept(SocketChannel accepted)\n        throws IOException\n    {\n        return accepted;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/BaseDelegatingServerSocketChannel.java", "class_name": "BaseDelegatingServerSocketChannel", "class_uri": "src/main/java/org/ice4j/socket/BaseDelegatingServerSocketChannel.java.BaseDelegatingServerSocketChannel", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "SocketChannel", "classes": []}, "docstring": "\nAllows extenders to optionally configure (e.g. wrap) a\n<tt>SocketChannel</tt> which has been accepted by {@link #delegate} and\nbefore it is returned by {@link #accept()}.\n\n@param accepted the <tt>SocketChannel</tt> accepted by <tt>delegate</tt>\n@return the <tt>SocketChannel</tt> to be returned by {@link #accept()}\n(in place of <tt>accepted</tt>)\n@throws IOException if an I/O error occurs\n"}, {"uris": "src/main/java/org/ice4j/socket/BaseDelegatingServerSocketChannel.java.BaseDelegatingServerSocketChannel.[void]implCloseSelectableChannel()", "name": "implCloseSelectableChannel", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Override\n    protected void implCloseSelectableChannel()", "original_string": "    @Override\n    protected void implCloseSelectableChannel()\n        throws IOException\n    {\n        delegate.close();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/BaseDelegatingServerSocketChannel.java", "class_name": "BaseDelegatingServerSocketChannel", "class_uri": "src/main/java/org/ice4j/socket/BaseDelegatingServerSocketChannel.java.BaseDelegatingServerSocketChannel", "attributes": {"modifiers": "@Override\n    protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\n{@inheritDoc}\n\nForwards to {@link #delegate}.\n"}, {"uris": "src/main/java/org/ice4j/socket/BaseDelegatingServerSocketChannel.java.BaseDelegatingServerSocketChannel.[void]implConfigureBlocking(boolean)", "name": "implConfigureBlocking", "arg_nums": 1, "params": [{"name": "block", "type": "boolean"}], "return_type": "void", "signature": "@Override\n    protected void implConfigureBlocking(boolean block)", "original_string": "    @Override\n    protected void implConfigureBlocking(boolean block)\n        throws IOException\n    {\n        delegate.configureBlocking(block);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/BaseDelegatingServerSocketChannel.java", "class_name": "BaseDelegatingServerSocketChannel", "class_uri": "src/main/java/org/ice4j/socket/BaseDelegatingServerSocketChannel.java.BaseDelegatingServerSocketChannel", "attributes": {"modifiers": "@Override\n    protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\n{@inheritDoc}\n\nForwards to {@link #delegate}.\n"}, {"uris": "src/main/java/org/ice4j/socket/BaseDelegatingServerSocketChannel.java.BaseDelegatingServerSocketChannel.[ServerSocket]implSocket(ServerSocket)", "name": "implSocket", "arg_nums": 1, "params": [{"name": "socket", "type": "ServerSocket"}], "return_type": "ServerSocket", "signature": "protected ServerSocket implSocket(ServerSocket socket)", "original_string": "    protected ServerSocket implSocket(ServerSocket socket)\n        throws IOException\n    {\n        return new DelegatingServerSocket(socket, this);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/BaseDelegatingServerSocketChannel.java", "class_name": "BaseDelegatingServerSocketChannel", "class_uri": "src/main/java/org/ice4j/socket/BaseDelegatingServerSocketChannel.java.BaseDelegatingServerSocketChannel", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "ServerSocket", "classes": []}, "docstring": "\nAllows extenders to optionally configure (e.g. wrap) the\n{@code ServerSocket} of {@link #delegate} and before it is returned by\n{@link #socket()}.\n\n@param socket the {@code ServerSocket} of {@code delegate}\n@return the {@code ServerSocket} to be returned by {@link #socket()} (in\nplace of {@code socket})\n@throws IOException if an I/O error occurs\n"}, {"uris": "src/main/java/org/ice4j/socket/BaseDelegatingServerSocketChannel.java.BaseDelegatingServerSocketChannel.[boolean]isBound()", "name": "isBound", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "public boolean isBound()", "original_string": "    public boolean isBound()\n    {\n        try\n        {\n            return getLocalAddress() != null;\n        }\n        catch (IOException ioe)\n        {\n            return false;\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/BaseDelegatingServerSocketChannel.java", "class_name": "BaseDelegatingServerSocketChannel", "class_uri": "src/main/java/org/ice4j/socket/BaseDelegatingServerSocketChannel.java.BaseDelegatingServerSocketChannel", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nDetermines whether this {@code BaseDelegatingServerSocketChannel} is\nbound.\n\n@return {@code true} if this instancei bound; otherwise, {@code false}\n"}, {"uris": "src/main/java/org/ice4j/socket/BaseDelegatingServerSocketChannel.java.BaseDelegatingServerSocketChannel.[ServerSocketChannel]setOption(SocketOption<U>,U)", "name": "setOption", "arg_nums": 2, "params": [{"name": "name", "type": "SocketOption<U>"}, {"name": "value", "type": "U"}], "return_type": "ServerSocketChannel", "signature": "@Override\n    public <U> ServerSocketChannel setOption(SocketOption<U> name, U value)", "original_string": "    @Override\n    public <U> ServerSocketChannel setOption(SocketOption<U> name, U value)\n        throws IOException\n    {\n        delegate.setOption(name, value);\n        return this;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/BaseDelegatingServerSocketChannel.java", "class_name": "BaseDelegatingServerSocketChannel", "class_uri": "src/main/java/org/ice4j/socket/BaseDelegatingServerSocketChannel.java.BaseDelegatingServerSocketChannel", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "ServerSocketChannel", "classes": []}, "docstring": "\n{@inheritDoc}\n\nForwards to {@link #delegate} and returns {@code this}.\n"}, {"uris": "src/main/java/org/ice4j/socket/BaseDelegatingServerSocketChannel.java.BaseDelegatingServerSocketChannel.[ServerSocket]socket()", "name": "socket", "arg_nums": 0, "params": [], "return_type": "ServerSocket", "signature": "@Override\n    public ServerSocket socket()", "original_string": "    @Override\n    public ServerSocket socket()\n    {\n        ServerSocket socket = delegate.socket();\n\n        synchronized (socketSyncRoot)\n        {\n            if (this.socket == null)\n            {\n                if (socket != null)\n                {\n                    try\n                    {\n                        this.socket = implSocket(socket);\n                    }\n                    catch (IOException ioe)\n                    {\n                        throw new RuntimeException(ioe);\n                    }\n                }\n            }\n            else if (socket == null)\n            {\n                this.socket = null;\n            }\n            else\n            {\n                // TODO For the sake of completeness, maybe check that the\n                // value of this.socket still delegates to the latest value of\n                // socket. However, the value of socket is very likely final so\n                // do not bother with it at the time of this writing.\n            }\n            return this.socket;\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/BaseDelegatingServerSocketChannel.java", "class_name": "BaseDelegatingServerSocketChannel", "class_uri": "src/main/java/org/ice4j/socket/BaseDelegatingServerSocketChannel.java.BaseDelegatingServerSocketChannel", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "ServerSocket", "classes": []}, "docstring": "\n{@inheritDoc}\n\nAllows wrapping the {@code socket} of {@link #delegate}.\n"}, {"uris": "src/main/java/org/ice4j/socket/BaseDelegatingServerSocketChannel.java.BaseDelegatingServerSocketChannel.[Set<SocketOption<?>>]supportedOptions()", "name": "supportedOptions", "arg_nums": 0, "params": [], "return_type": "Set<SocketOption<?>>", "signature": "@Override\n    public Set<SocketOption<?>> supportedOptions()", "original_string": "    @Override\n    public Set<SocketOption<?>> supportedOptions()\n    {\n        return delegate.supportedOptions();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/BaseDelegatingServerSocketChannel.java", "class_name": "BaseDelegatingServerSocketChannel", "class_uri": "src/main/java/org/ice4j/socket/BaseDelegatingServerSocketChannel.java.BaseDelegatingServerSocketChannel", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Set<SocketOption<?>>", "classes": []}, "docstring": "\n{@inheritDoc}\n\nForwards to {@link #delegate}.\n"}, {"uris": "src/main/java/org/ice4j/socket/SafeCloseDatagramSocket.java.SafeCloseDatagramSocket.[]SafeCloseDatagramSocket()", "name": "SafeCloseDatagramSocket", "arg_nums": 0, "params": [], "return_type": "", "signature": "public SafeCloseDatagramSocket()", "original_string": "    public SafeCloseDatagramSocket()\n        throws SocketException\n    {\n        super();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/SafeCloseDatagramSocket.java", "class_name": "SafeCloseDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/SafeCloseDatagramSocket.java.SafeCloseDatagramSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>SafeCloseDatagramSocket</tt> instance and binds it\nto any available port on the local host machine.  The socket will be\nbound to the wildcard address, an IP address chosen by the kernel.\n\n@throws SocketException if the socket could not be opened, or the socket\ncould not bind to the specified local port\n@see DatagramSocket#DatagramSocket()\n"}, {"uris": "src/main/java/org/ice4j/socket/SafeCloseDatagramSocket.java.SafeCloseDatagramSocket.[]SafeCloseDatagramSocket(DatagramSocket)", "name": "SafeCloseDatagramSocket", "arg_nums": 1, "params": [{"name": "delegate", "type": "DatagramSocket"}], "return_type": "", "signature": "public SafeCloseDatagramSocket(DatagramSocket delegate)", "original_string": "    public SafeCloseDatagramSocket(DatagramSocket delegate)\n        throws SocketException\n    {\n        super(delegate);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/SafeCloseDatagramSocket.java", "class_name": "SafeCloseDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/SafeCloseDatagramSocket.java.SafeCloseDatagramSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>SafeCloseDatagramSocket</tt> instance which to\nimplement the <tt>DatagramSocket</tt> functionality by delegating to a\nspecific <tt>DatagramSocket</tt>.\n\n@param delegate the <tt>DatagramSocket</tt> to which the new instance is\nto delegate\n@throws SocketException if anything goes wrong while initializing the new\n<tt>SafeCloseDatagramSocket</tt> instance\n"}, {"uris": "src/main/java/org/ice4j/socket/SafeCloseDatagramSocket.java.SafeCloseDatagramSocket.[]SafeCloseDatagramSocket(int)", "name": "SafeCloseDatagramSocket", "arg_nums": 1, "params": [{"name": "port", "type": "int"}], "return_type": "", "signature": "public SafeCloseDatagramSocket(int port)", "original_string": "    public SafeCloseDatagramSocket(int port)\n        throws SocketException\n    {\n        super(port);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/SafeCloseDatagramSocket.java", "class_name": "SafeCloseDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/SafeCloseDatagramSocket.java.SafeCloseDatagramSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>SafeCloseDatagramSocket</tt> instance  and binds it\nto the specified port on the local host machine.  The socket will be\nbound to the wildcard address, an IP address chosen by the kernel.\n\n@param port the port to bind the new socket to\n@throws SocketException if the socket could not be opened, or the socket\ncould not bind to the specified local port\n@see DatagramSocket#DatagramSocket(int)\n"}, {"uris": "src/main/java/org/ice4j/socket/SafeCloseDatagramSocket.java.SafeCloseDatagramSocket.[]SafeCloseDatagramSocket(int,InetAddress)", "name": "SafeCloseDatagramSocket", "arg_nums": 2, "params": [{"name": "port", "type": "int"}, {"name": "laddr", "type": "InetAddress"}], "return_type": "", "signature": "public SafeCloseDatagramSocket(int port, InetAddress laddr)", "original_string": "    public SafeCloseDatagramSocket(int port, InetAddress laddr)\n        throws SocketException\n    {\n        super(port, laddr);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/SafeCloseDatagramSocket.java", "class_name": "SafeCloseDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/SafeCloseDatagramSocket.java.SafeCloseDatagramSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>SafeCloseDatagramSocket</tt> instance bound to the\nspecified local address.  The local port must be between 0 and 65535\ninclusive. If the IP address is 0.0.0.0, the socket will be bound to the\nwildcard address, an IP address chosen by the kernel.\n\n@param port the local port to bind the new socket to\n@param laddr the local address to bind the new socket to\n@throws SocketException if the socket could not be opened, or the socket\ncould not bind to the specified local port\n@see DatagramSocket#DatagramSocket(int, InetAddress)\n"}, {"uris": "src/main/java/org/ice4j/socket/SafeCloseDatagramSocket.java.SafeCloseDatagramSocket.[]SafeCloseDatagramSocket(SocketAddress)", "name": "SafeCloseDatagramSocket", "arg_nums": 1, "params": [{"name": "bindaddr", "type": "SocketAddress"}], "return_type": "", "signature": "public SafeCloseDatagramSocket(SocketAddress bindaddr)", "original_string": "    public SafeCloseDatagramSocket(SocketAddress bindaddr)\n        throws SocketException\n    {\n        super(bindaddr);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/SafeCloseDatagramSocket.java", "class_name": "SafeCloseDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/SafeCloseDatagramSocket.java.SafeCloseDatagramSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nCreates a datagram socket, bound to the specified local socket address.\n<p>\nIf, if the address is <tt>null</tt>, creates an unbound socket.\n</p>\n\n@param bindaddr local socket address to bind, or <tt>null</tt> for an\nunbound socket\n@throws SocketException if the socket could not be opened, or the socket\ncould not bind to the specified local port\n"}, {"uris": "src/main/java/org/ice4j/socket/SafeCloseDatagramSocket.java.SafeCloseDatagramSocket.[void]close()", "name": "close", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Override\n    public void close()", "original_string": "    @Override\n    public void close()\n    {\n        super.close();\n\n        final Lock closeLock = receiveCloseLock.writeLock();\n        closeLock.lock();\n        // we now know all read threads have finished\n        closeLock.unlock();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/SafeCloseDatagramSocket.java", "class_name": "SafeCloseDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/SafeCloseDatagramSocket.java.SafeCloseDatagramSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCloses this datagram socket.\n<p>\nAny thread currently blocked in {@link #receive} upon this socket will\nthrow a {@link SocketException} and this datagram socket will wait for it\nto return.\n</p>\n\n@see DatagramSocket#close()\n"}, {"uris": "src/main/java/org/ice4j/socket/SafeCloseDatagramSocket.java.SafeCloseDatagramSocket.[void]receive(DatagramPacket)", "name": "receive", "arg_nums": 1, "params": [{"name": "p", "type": "DatagramPacket"}], "return_type": "void", "signature": "@Override\n    public void receive(DatagramPacket p)", "original_string": "    @Override\n    public void receive(DatagramPacket p)\n        throws IOException\n    {\n        final Lock receiveLock = receiveCloseLock.readLock();\n        receiveLock.lock();\n        try\n        {\n            super.receive(p);\n        }\n        finally\n        {\n            receiveLock.unlock();\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/SafeCloseDatagramSocket.java", "class_name": "SafeCloseDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/SafeCloseDatagramSocket.java.SafeCloseDatagramSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nReceives a datagram packet from this socket. When this method returns,\nthe <tt>DatagramPacket</tt>'s buffer is filled with the data received.\nThe datagram packet also contains the sender's IP address, and the port\nnumber on the sender's machine.\n<p>\nThis method blocks until a datagram is received. The <tt>length</tt>\nfield of the datagram packet object contains the length of the received\nmessage. If the message is longer than the packet's length, the message\nis truncated.\n</p>\n\n@param p the <tt>DatagramPacket</tt> into which to place the incoming\ndata\n@throws  IOException if an I/O error occurs\n@see DatagramSocket#receive(DatagramPacket)\n"}, {"uris": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateSocket.java.GoogleRelayedCandidateSocket.[]GoogleRelayedCandidateSocket(GoogleRelayedCandidate,GoogleTurnCandidateHarvest,String)", "name": "GoogleRelayedCandidateSocket", "arg_nums": 3, "params": [{"name": "relayedCandidate", "type": "GoogleRelayedCandidate"}, {"name": "turnCandidateHarvest", "type": "GoogleTurnCandidateHarvest"}, {"name": "username", "type": "String"}], "return_type": "", "signature": "public GoogleRelayedCandidateSocket(\n            GoogleRelayedCandidate relayedCandidate,\n            GoogleTurnCandidateHarvest turnCandidateHarvest,\n            String username)", "original_string": "    public GoogleRelayedCandidateSocket(\n            GoogleRelayedCandidate relayedCandidate,\n            GoogleTurnCandidateHarvest turnCandidateHarvest,\n            String username)\n        throws SocketException\n    {\n        super();\n\n        this.relayedCandidate = relayedCandidate;\n        socketDelegate = new GoogleRelayedCandidateDelegate(\n            turnCandidateHarvest, username);\n\n        logger.finest(\"Create new GoogleRelayedCandidateSocket\");\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateSocket.java", "class_name": "GoogleRelayedCandidateSocket", "class_uri": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateSocket.java.GoogleRelayedCandidateSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>GoogleRelayedCandidateSocket</tt> instance\nwhich is to be the <tt>socket</tt> of a specific\n<tt>RelayedCandidate</tt> harvested by a specific\n<tt>TurnCandidateHarvest</tt>.\n\n@param relayedCandidate the <tt>RelayedCandidate</tt> which is to use the\nnew instance as the value of its <tt>socket</tt> property\n@param turnCandidateHarvest the <tt>TurnCandidateHarvest</tt> which has\nharvested <tt>relayedCandidate</tt>\n@param username username\n@throws SocketException if anything goes wrong while initializing the new\n<tt>GoogleRelayedCandidateSocket</tt> instance\n"}, {"uris": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateSocket.java.GoogleRelayedCandidateSocket.[void]close()", "name": "close", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Override\n    public void close()", "original_string": "    @Override\n    public void close()\n    {\n        synchronized (this)\n        {\n            if (this.closed)\n                return;\n            else\n                this.closed = true;\n        }\n        socketDelegate.close();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateSocket.java", "class_name": "GoogleRelayedCandidateSocket", "class_uri": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateSocket.java.GoogleRelayedCandidateSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCloses this datagram socket.\n\n@see Socket#close()\n"}, {"uris": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateSocket.java.GoogleRelayedCandidateSocket.[InetAddress]getLocalAddress()", "name": "getLocalAddress", "arg_nums": 0, "params": [], "return_type": "InetAddress", "signature": "@Override\n    public InetAddress getLocalAddress()", "original_string": "    @Override\n    public InetAddress getLocalAddress()\n    {\n        return getLocalSocketAddress().getAddress();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateSocket.java", "class_name": "GoogleRelayedCandidateSocket", "class_uri": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateSocket.java.GoogleRelayedCandidateSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "InetAddress", "classes": []}, "docstring": "\nGets the local address to which the socket is bound.\n<tt>GoogleRelayedCandidateSocket</tt> returns the\n<tt>address</tt> of its <tt>localSocketAddress</tt>.\n<p>\nIf there is a security manager, its <tt>checkConnect</tt> method is first\ncalled with the host address and <tt>-1</tt> as its arguments to see if\nthe operation is allowed.\n</p>\n\n@return the local address to which the socket is bound, or an\n<tt>InetAddress</tt> representing any local address if either the socket\nis not bound, or the security manager <tt>checkConnect</tt> method does\nnot allow the operation\n@see #getLocalSocketAddress()\n@see Socket#getLocalAddress()\n"}, {"uris": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateSocket.java.GoogleRelayedCandidateSocket.[int]getLocalPort()", "name": "getLocalPort", "arg_nums": 0, "params": [], "return_type": "int", "signature": "@Override\n    public int getLocalPort()", "original_string": "    @Override\n    public int getLocalPort()\n    {\n        return getLocalSocketAddress().getPort();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateSocket.java", "class_name": "GoogleRelayedCandidateSocket", "class_uri": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateSocket.java.GoogleRelayedCandidateSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\nReturns the port number on the local host to which this socket is bound.\n<tt>GoogleRelayedCandidateSocket</tt> returns the <tt>port</tt>\nof its <tt>localSocketAddress</tt>.\n\n@return the port number on the local host to which this socket is bound\n@see #getLocalSocketAddress()\n@see Socket#getLocalPort()\n"}, {"uris": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateSocket.java.GoogleRelayedCandidateSocket.[InetSocketAddress]getLocalSocketAddress()", "name": "getLocalSocketAddress", "arg_nums": 0, "params": [], "return_type": "InetSocketAddress", "signature": "@Override\n    public InetSocketAddress getLocalSocketAddress()", "original_string": "    @Override\n    public InetSocketAddress getLocalSocketAddress()\n    {\n        return getRelayedCandidate().getTransportAddress();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateSocket.java", "class_name": "GoogleRelayedCandidateSocket", "class_uri": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateSocket.java.GoogleRelayedCandidateSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "InetSocketAddress", "classes": []}, "docstring": "\nReturns the address of the endpoint this socket is bound to, or\n<tt>null</tt> if it is not bound yet. Since\n<tt>GoogleRelayedCandidateSocket</tt> represents an\napplication-purposed <tt>Socket</tt> relaying data to and from a\nTURN server, the <tt>localSocketAddress</tt> is the\n<tt>transportAddress</tt> of the respective <tt>RelayedCandidate</tt>.\n\n@return a <tt>SocketAddress</tt> representing the local endpoint of this\nsocket, or <tt>null</tt> if it is not bound yet\n@see Socket#getLocalSocketAddress()\n"}, {"uris": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateSocket.java.GoogleRelayedCandidateSocket.[GoogleRelayedCandidate]getRelayedCandidate()", "name": "getRelayedCandidate", "arg_nums": 0, "params": [], "return_type": "GoogleRelayedCandidate", "signature": "public final GoogleRelayedCandidate getRelayedCandidate()", "original_string": "    public final GoogleRelayedCandidate getRelayedCandidate()\n    {\n        return relayedCandidate;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateSocket.java", "class_name": "GoogleRelayedCandidateSocket", "class_uri": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateSocket.java.GoogleRelayedCandidateSocket", "attributes": {"modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "return_type": "GoogleRelayedCandidate", "classes": []}, "docstring": "\nGets the <tt>RelayedCandidate</tt> which uses this instance as the value\nof its <tt>socket</tt> property.\n\n@return the <tt>RelayedCandidate</tt> which uses this instance as the\nvalue of its <tt>socket</tt> property\n"}, {"uris": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateSocket.java.GoogleRelayedCandidateSocket.[void]processSuccess(Response,Request)", "name": "processSuccess", "arg_nums": 2, "params": [{"name": "response", "type": "Response"}, {"name": "request", "type": "Request"}], "return_type": "void", "signature": "public void processSuccess(Response response, Request request)", "original_string": "    public void processSuccess(Response response, Request request)\n    {\n        socketDelegate.processSuccess(response, request);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateSocket.java", "class_name": "GoogleRelayedCandidateSocket", "class_uri": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateSocket.java.GoogleRelayedCandidateSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nNotifies this <tt>GoogleRelayedCandidateSocket</tt> that a\nspecific <tt>Request</tt> it has sent has received a STUN success\n<tt>Response</tt>.\n\n@param response the <tt>Response</tt> which responds to <tt>request</tt>\n@param request the <tt>Request</tt> sent by this instance to which\n<tt>response</tt> responds\n"}, {"uris": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateSocket.java.GoogleRelayedCandidateSocket.[void]processResponse(StunResponseEvent)", "name": "processResponse", "arg_nums": 1, "params": [{"name": "response", "type": "StunResponseEvent"}], "return_type": "void", "signature": "public void processResponse(StunResponseEvent response)", "original_string": "    public void processResponse(StunResponseEvent response)\n    {\n        socketDelegate.processResponse(response);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateSocket.java", "class_name": "GoogleRelayedCandidateSocket", "class_uri": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateSocket.java.GoogleRelayedCandidateSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nDispatch the specified response.\n\n@param response the response to dispatch.\n"}, {"uris": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateSocket.java.GoogleRelayedCandidateSocket.[void]receive(DatagramPacket)", "name": "receive", "arg_nums": 1, "params": [{"name": "p", "type": "DatagramPacket"}], "return_type": "void", "signature": "@Override\n    public void receive(DatagramPacket p)", "original_string": "    @Override\n    public void receive(DatagramPacket p)\n        throws IOException\n    {\n        socketDelegate.receive(p);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateSocket.java", "class_name": "GoogleRelayedCandidateSocket", "class_uri": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateSocket.java.GoogleRelayedCandidateSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nReceives a datagram packet from this socket. When this method returns,\nthe <tt>DatagramPacket</tt>'s buffer is filled with the data received.\nThe datagram packet also contains the sender's IP address, and the port\nnumber on the sender's machine.\n\n@param p the <tt>DatagramPacket</tt> into which to place the incoming\ndata\n@throws IOException if an I/O error occurs\n"}, {"uris": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateSocket.java.GoogleRelayedCandidateSocket.[void]send(DatagramPacket)", "name": "send", "arg_nums": 1, "params": [{"name": "p", "type": "DatagramPacket"}], "return_type": "void", "signature": "public void send(DatagramPacket p)", "original_string": "    public void send(DatagramPacket p)\n        throws IOException\n    {\n        socketDelegate.send(p);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateSocket.java", "class_name": "GoogleRelayedCandidateSocket", "class_uri": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateSocket.java.GoogleRelayedCandidateSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSends a datagram packet from this socket. The <tt>DatagramPacket</tt>\nincludes information indicating the data to be sent, its length, the IP\naddress of the remote host, and the port number on the remote host.\n\n@param p the <tt>DatagramPacket</tt> to be sent\n@throws IOException if an I/O error occurs\n"}, {"uris": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateSocket.java.GoogleRelayedCandidateSocket.[OutputStream]getOutputStream()", "name": "getOutputStream", "arg_nums": 0, "params": [], "return_type": "OutputStream", "signature": "@Override\n    public OutputStream getOutputStream()", "original_string": "    @Override\n    public OutputStream getOutputStream()\n        throws IOException\n    {\n        if (outputStream == null)\n        {\n            CandidatePair pair =\n                relayedCandidate.getParentComponent().getSelectedPair();\n\n            if (pair.getLocalCandidate() == relayedCandidate)\n            {\n                TransportAddress target = pair.getRemoteCandidate().\n                    getTransportAddress();\n                outputStream = new TCPOutputStream(target);\n            }\n            else\n                throw new IOException(\"TURN-TCP socket is not selected\");\n        }\n\n        return outputStream;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateSocket.java", "class_name": "GoogleRelayedCandidateSocket", "class_uri": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateSocket.java.GoogleRelayedCandidateSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "OutputStream", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/RtcpDemuxPacketFilter.java.RtcpDemuxPacketFilter.[boolean]isRtcpPacket(DatagramPacket)", "name": "isRtcpPacket", "arg_nums": 1, "params": [{"name": "p", "type": "DatagramPacket"}], "return_type": "boolean", "signature": "public static boolean isRtcpPacket(DatagramPacket p)", "original_string": "    public static boolean isRtcpPacket(DatagramPacket p)\n    {\n        int len = p.getLength();\n\n        if (len >= 4) //minimum RTCP message length\n        {\n            byte[] data = p.getData();\n            int off = p.getOffset();\n\n            if (((data[off] & 0xc0) >> 6) == 2) //RTP/RTCP version field\n            {\n                int pt = data[off + 1] & 0xff;\n\n                return (200 <= pt && pt <= 211);\n            }\n        }\n        return false;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/RtcpDemuxPacketFilter.java", "class_name": "RtcpDemuxPacketFilter", "class_uri": "src/main/java/org/ice4j/socket/RtcpDemuxPacketFilter.java.RtcpDemuxPacketFilter", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nDetermines whether a specific <tt>DatagramPacket</tt> is an RTCP.\n<tt>DatagramPacket</tt> in a selection based on this filter.\n\nRTP/RTCP packets are distinguished from other packets (such as STUN,\nDTLS or ZRTP) by the value of their first byte. See\n<a href=\"http://tools.ietf.org/html/rfc5764#section-5.1.2\">\nRFC5764, Section 5.1.2</a> and\n<a href=\"http://tools.ietf.org/html/rfc6189#section-5\">RFC6189,\nSection 5</a>.\n\nRTCP packets are distinguished from RTP packet based on the second byte\n(either Packet Type (RTCP) or M-bit and Payload Type (RTP). See\n<a href=\"http://tools.ietf.org/html/rfc5761#section-4\">RFC5761, Section\n4</a>\n\nWe assume that RTCP packets have a packet type in [200, 211]. This means\nthat RTP packets with Payload Types in [72, 83] (which should not\nappear, because these PTs are reserved or unassigned by IANA, see\n<a href=\"http://www.iana.org/assignments/rtp-parameters/rtp-parameters.xhtml\">\nIANA RTP Parameters</a>) with the M-bit set will be misidentified as\nRTCP packets.\n\nAlso, any RTCP packets with Packet Types not in [200, 211] will be\nmisidentified as RTP packets.\n\n@param p the <tt>DatagramPacket</tt> whose protocol we'd like to\ndetermine.\n@return <tt>true</tt> if <tt>p</tt> is an RTCP and this filter accepts it\nand <tt>false</tt> otherwise.\n"}, {"uris": "src/main/java/org/ice4j/socket/RtcpDemuxPacketFilter.java.RtcpDemuxPacketFilter.[boolean]accept(DatagramPacket)", "name": "accept", "arg_nums": 1, "params": [{"name": "p", "type": "DatagramPacket"}], "return_type": "boolean", "signature": "public boolean accept(DatagramPacket p)", "original_string": "    public boolean accept(DatagramPacket p)\n    {\n        return isRtcpPacket(p);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/RtcpDemuxPacketFilter.java", "class_name": "RtcpDemuxPacketFilter", "class_uri": "src/main/java/org/ice4j/socket/RtcpDemuxPacketFilter.java.RtcpDemuxPacketFilter", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nReturns <tt>true</tt> if this <tt>RtcpDemuxPacketFilter</tt> should\naccept <tt>p</tt>, that is, if <tt>p</tt> looks like an RTCP packet.\nSee {@link #isRtcpPacket(java.net.DatagramPacket)}\n@return <tt>true</tt> if <tt>p</tt> looks like an RTCP packet.\n"}, {"uris": "src/main/java/org/ice4j/socket/HttpDemuxFilter.java.HttpDemuxFilter.[boolean]accept(DatagramPacket)", "name": "accept", "arg_nums": 1, "params": [{"name": "p", "type": "DatagramPacket"}], "return_type": "boolean", "signature": "@Override\n    public boolean accept(DatagramPacket p)", "original_string": "    @Override\n    public boolean accept(DatagramPacket p)\n    {\n        int len = p.getLength();\n        boolean accept = false;\n\n        if (len > 0)\n        {\n            byte[] buf = p.getData();\n            int off = p.getOffset();\n            // The first bytes of HTTP, SSL v2, and TLS are different so quickly\n            // determine which one of the three is possible and, respectively,\n            // which two of the three are impossible.\n            int b0 = 0xFF & buf[off];\n            boolean http, sslv2, tls;\n\n            if (b0 == 22 /* TLS handshake */)\n            {\n                http = false;\n                sslv2 = false;\n                tls = true;\n            }\n            else if (b0 > 0x80 /* SSL v2 client hello */)\n            {\n                http = false;\n                sslv2 = true;\n                tls = false;\n            }\n            else\n            {\n                http = true;\n                sslv2 = false;\n                tls = false;\n            }\n\n            // HTTP\n            if (http)\n            {\n                // Request-Line = Method SP Request-URI SP HTTP-Version CRLF\n                // HTTP-Version = \"HTTP\" \"/\" 1*DIGIT \".\" 1*DIGIT\n                if (b0 >= REQUEST_METHOD_MIN_CHAR\n                        && b0 <= REQUEST_METHOD_MAX_CHAR\n                        && len >= REQUEST_METHOD_MAX_LENGTH + 1 /* SP */)\n                {\n                    // Match a supported HTTP request method.\n                    for (byte[] bytes : REQUEST_METHOD_BYTES)\n                    {\n                        int length = bytes.length;\n\n                        if (buf[off + length] == ' ' /* SP */)\n                        {\n                            boolean equals = true;\n\n                            for (int i = 1, j = off + 1; i < length; i++, j++)\n                            {\n                                if (bytes[i] != buf[j])\n                                {\n                                    equals = false;\n                                    break;\n                                }\n                            }\n                            if (equals)\n                            {\n                                accept = true;\n                                break;\n                            }\n                        }\n                    }\n                }\n                // Only one of HTTP, SSL v2, and TLS was deemed possible by\n                // looking at the first byte. If p didn't look like HTTP here,\n                // then it will not look like SSL v2 or TLS.\n                return accept;\n            }\n\n            // HTTPS\n            if (tls)\n            {\n                // 1 byte   ContentType type = handshake(22)\n                // 2 bytes  ProtocolVersion version = { major(3) , minor<1..3> }\n                // 2 bytes  uint16 length\n                // 1 byte   HandshakeType msg_type = client_hello(1)\n                // 3 bytes  uint24 length\n                // 2 bytes  ProtocolVersion client_version\n                if (len >= TLS_MIN_LENGTH\n                        && /* major */ (0xFF & buf[off + 1]) == 3)\n                {\n                    int minor = 0xFF & buf[off + 2];\n\n                    if (1 <= minor\n                            && minor <= 3\n                            && /* msg_type */ (0xFF & buf[off + 5])\n                                == /* client_hello */ 1\n                            && /* major */ (0xFF & buf[off + 9]) == 3)\n                    {\n                        minor = 0xFF & buf[off + 10];\n                        if (1 <= minor && minor <= 3)\n                            accept = true;\n                    }\n                }\n                // Only one of HTTP, SSL v2, and TLS was deemed possible by\n                // looking at the first byte. If p didn't look like TLS here,\n                // then it will not look like HTTP or SSL v2.\n                return accept;\n            }\n            if (sslv2)\n            {\n                final byte[] googleTurnSslTcp\n                    = GoogleTurnSSLCandidateHarvester.SSL_CLIENT_HANDSHAKE;\n\n                // 2 bytes  uint15 length\n                // 1 byte   uint8 msg_type = 1\n                // 2 bytes  Version version\n                if (len > 5\n                        && len >= googleTurnSslTcp.length\n                        && /* msg_type */ (0xFF & buf[off + 2]) == 1\n                        && /* major */ (0xFF & buf[off + 3]) == 3)\n                {\n                    int minor = 0xFF & buf[off + 4];\n\n                    if (1 <= minor && minor <= 3)\n                    {\n                        // Reject Google TURN SSLTCP.\n                        boolean equals = true;\n\n                        for (int i = 0, iEnd = googleTurnSslTcp.length, j = off;\n                                i < iEnd;\n                                i++, j++)\n                        {\n                            if (googleTurnSslTcp[i] != buf[j])\n                            {\n                                equals = false;\n                                break;\n                            }\n                        }\n                        accept = !equals;\n                    }\n                }\n                // Only one of HTTP, SSL v2, and TLS was deemed possible by\n                // looking at the first byte. If p didn't look like SSL v2 here,\n                // then it will not look like HTTP or TLS.\n                return accept;\n            }\n        }\n        return accept;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/HttpDemuxFilter.java", "class_name": "HttpDemuxFilter", "class_uri": "src/main/java/org/ice4j/socket/HttpDemuxFilter.java.HttpDemuxFilter", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nDetermines whether a specific {@link DatagramPacket} looks like the\nbeginning of HTTP(S) client communication. Accepts HTTP, SSL v2, and\nTLS. Rejects Google TURN SSLTCP.\n\n@param p the {@code DatagramPacket} to analyze\n@return {@code true} if {@code p} looks like the beginning of HTTP(S)\nclient communication; otherwise, {@code false}\n"}, {"uris": "src/main/java/org/ice4j/socket/SocketClosedException.java.SocketClosedException.[]SocketClosedException()", "name": "SocketClosedException", "arg_nums": 0, "params": [], "return_type": "", "signature": "public SocketClosedException()", "original_string": "    public SocketClosedException()\n    {\n        // Keep the same message as the one used by jdk, since existing code\n        // might be matching against the string.\n        super(\"Socket closed\");\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/SocketClosedException.java", "class_name": "SocketClosedException", "class_uri": "src/main/java/org/ice4j/socket/SocketClosedException.java.SocketClosedException", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new {@link SocketClosedException}.\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[void]receiveFromInputStream(DatagramPacket,InputStream,InetAddress,int)", "name": "receiveFromInputStream", "arg_nums": 4, "params": [{"name": "p", "type": "DatagramPacket"}, {"name": "inputStream", "type": "InputStream"}, {"name": "inetAddress", "type": "InetAddress"}, {"name": "port", "type": "int"}], "return_type": "void", "signature": "public static void receiveFromInputStream(\n            DatagramPacket p,\n            InputStream inputStream,\n            InetAddress inetAddress, int port)", "original_string": "    public static void receiveFromInputStream(\n            DatagramPacket p,\n            InputStream inputStream,\n            InetAddress inetAddress, int port)\n        throws IOException\n    {\n        int b0 = inputStream.read();\n        int b1 = inputStream.read();\n\n        // If we do not achieve to read the first bytes, then it was just a hole\n        // punch packet.\n        if (b0 == -1 || b1 == -1)\n        {\n            p.setLength(0);\n            throw new SocketException(\"read failed\");\n        }\n\n        int frameLen = ((b0 & 0xFF) << 8) | (b1 & 0xFF);\n        int readLen = 0;\n        byte[] data = p.getData();\n        int off = 0;\n\n        while (readLen < frameLen)\n        {\n            int len = inputStream.read(data, off, frameLen - off);\n\n            if (len == -1)\n            {\n                throw new SocketException(\"read failed\");\n            }\n            else\n            {\n                off += len;\n                readLen += len;\n            }\n        }\n\n        if (readLen == frameLen)\n        {\n            p.setAddress(inetAddress);\n            p.setData(data, 0, frameLen);\n            p.setPort(port);\n        }\n        else\n        {\n            throw new SocketException(\"Failed to receive data from socket\");\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingSocket.java", "class_name": "DelegatingSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nReceives an RFC4571-formatted frame from <tt>inputStream</tt> into\n<tt>p</tt>, and sets <tt>p</tt>'s port and address to <tt>port</tt> and\n<tt>inetAddress</tt>.\n\n@param p the <tt>DatagramPacket</tt> into which to place the incoming\ndata.\n@param inputStream The TCP stream to be read.\n@param inetAddress The receiver address (local address) to set to the\ndatagram packet.\n@param port The receiver port (local port) to set to the datagram packet.\n\n@throws IOException if an I/O error occurs\n@see #receive(DatagramPacket)\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[]DelegatingSocket()", "name": "DelegatingSocket", "arg_nums": 0, "params": [], "return_type": "", "signature": "public DelegatingSocket()", "original_string": "    public DelegatingSocket()\n    {\n        this((Socket) null);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingSocket.java", "class_name": "DelegatingSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>DelegatingSocket</tt>.\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[]DelegatingSocket(InetAddress,int)", "name": "DelegatingSocket", "arg_nums": 2, "params": [{"name": "address", "type": "InetAddress"}, {"name": "port", "type": "int"}], "return_type": "", "signature": "public DelegatingSocket(InetAddress address, int port)", "original_string": "    public DelegatingSocket(InetAddress address, int port)\n        throws IOException\n    {\n        this((Socket) null);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingSocket.java", "class_name": "DelegatingSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>DelegatingSocket</tt>.\n\n@param address ignored\n@param port ignored\n@throws IOException never thrown\n@see Socket#Socket(InetAddress, int)\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[]DelegatingSocket(InetAddress,int,InetAddress,int)", "name": "DelegatingSocket", "arg_nums": 4, "params": [{"name": "address", "type": "InetAddress"}, {"name": "port", "type": "int"}, {"name": "localAddr", "type": "InetAddress"}, {"name": "localPort", "type": "int"}], "return_type": "", "signature": "public DelegatingSocket(\n            InetAddress address, int port,\n            InetAddress localAddr, int localPort)", "original_string": "    public DelegatingSocket(\n            InetAddress address, int port,\n            InetAddress localAddr, int localPort)\n        throws IOException\n    {\n        this((Socket) null);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingSocket.java", "class_name": "DelegatingSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>DelegatingSocket</tt>.\n\n@param address ignored\n@param port ignored\n@param localAddr ignored\n@param localPort ignored\n@see Socket#Socket(InetAddress, int, InetAddress, int)\n@throws IOException never thrown\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[]DelegatingSocket(Proxy)", "name": "DelegatingSocket", "arg_nums": 1, "params": [{"name": "proxy", "type": "Proxy"}], "return_type": "", "signature": "public DelegatingSocket(Proxy proxy)", "original_string": "    public DelegatingSocket(Proxy proxy)\n    {\n        this((Socket) null);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingSocket.java", "class_name": "DelegatingSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>DelegatingSocket</tt>.\n\n@param proxy ignored\n@see Socket#Socket(Proxy)\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[]DelegatingSocket(Socket)", "name": "DelegatingSocket", "arg_nums": 1, "params": [{"name": "delegate", "type": "Socket"}], "return_type": "", "signature": "public DelegatingSocket(Socket delegate)", "original_string": "    public DelegatingSocket(Socket delegate)\n    {\n        this(delegate, (delegate == null) ? null : delegate.getChannel());\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingSocket.java", "class_name": "DelegatingSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>DelegatingSocket</tt> instance which is to delegate\n(i.e. forwards) method calls to a specific <tt>Socket</tt>.\n\n@param delegate the <tt>Socket</tt> the new instance is to delegate to\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[]DelegatingSocket(Socket,SocketChannel)", "name": "DelegatingSocket", "arg_nums": 2, "params": [{"name": "delegate", "type": "Socket"}, {"name": "channel", "type": "SocketChannel"}], "return_type": "", "signature": "public DelegatingSocket(Socket delegate, SocketChannel channel)", "original_string": "    public DelegatingSocket(Socket delegate, SocketChannel channel)\n    {\n        this.delegate = delegate;\n        this.channel = channel;\n\n        if (delegate instanceof DelegatingSocket)\n        {\n            // FIXME BaseDelegatingSocketChannel was in need of a Socket which\n            // wraps another Socket and reports a specific SocketChannel. Since\n            // DelegatingSocket does that, BaseDelegatingSocketChannel used it.\n            // Unfortunately, it turned out after much debugging that\n            // DelegatingSocket has the additional function of flagging where\n            // UDP packets sent over TCP are to be framed. As a temporary fix,\n            // do not treat the sockets of DelegatingSocketChannel as\n            // DelegatingSockets.\n            if (channel instanceof BaseDelegatingSocketChannel)\n                delegateAsDelegatingSocket = null;\n            else\n                delegateAsDelegatingSocket = (DelegatingSocket) delegate;\n        }\n        else\n        {\n            delegateAsDelegatingSocket = null;\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingSocket.java", "class_name": "DelegatingSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>DelegatingSocket</tt> instance which is to delegate\n(i.e. forward) method calls to a specific <tt>Socket</tt> and to report\n(i.e. return) an association with a specific <tt>SocketChannel</tt>.\n\n@param delegate the <tt>Socket</tt> the new instance is to delegate to\n@param channel the <tt>SocketChannel</tt> to be returned by\n{@link #getChannel()}. If <tt>null</tt>, <tt>getChannel()</tt> forwards\nto <tt>delegate</tt>.\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[]DelegatingSocket(SocketImpl)", "name": "DelegatingSocket", "arg_nums": 1, "params": [{"name": "impl", "type": "SocketImpl"}], "return_type": "", "signature": "protected DelegatingSocket(SocketImpl impl)", "original_string": "    protected DelegatingSocket(SocketImpl impl)\n        throws SocketException\n    {\n        this((Socket) null);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingSocket.java", "class_name": "DelegatingSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>DelegatingSocket</tt>.\n\n@param impl  ignored\n@throws SocketException never thrown\n@see Socket#Socket(SocketImpl)\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[]DelegatingSocket(String,int)", "name": "DelegatingSocket", "arg_nums": 2, "params": [{"name": "host", "type": "String"}, {"name": "port", "type": "int"}], "return_type": "", "signature": "public DelegatingSocket(String host, int port)", "original_string": "    public DelegatingSocket(String host, int port)\n        throws UnknownHostException, IOException\n    {\n        this((Socket) null);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingSocket.java", "class_name": "DelegatingSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>DelegatingSocket</tt>.\n\n@param host ignored\n@param port ignored\n@throws UnknownHostException never thrown\n@throws IOException never thrown\n@see Socket#Socket(String, int)\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[]DelegatingSocket(String,int,InetAddress,int)", "name": "DelegatingSocket", "arg_nums": 4, "params": [{"name": "host", "type": "String"}, {"name": "port", "type": "int"}, {"name": "localAddr", "type": "InetAddress"}, {"name": "localPort", "type": "int"}], "return_type": "", "signature": "public DelegatingSocket(\n            String host, int port,\n            InetAddress localAddr, int localPort)", "original_string": "    public DelegatingSocket(\n            String host, int port,\n            InetAddress localAddr, int localPort)\n    {\n        this((Socket) null);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingSocket.java", "class_name": "DelegatingSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>DelegatingSocket</tt>.\n\n@param host ignored\n@param port ignored\n@param localAddr ignored\n@param localPort ignored\n@see Socket#Socket(String, int, InetAddress, int)\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[void]bind(SocketAddress)", "name": "bind", "arg_nums": 1, "params": [{"name": "bindpoint", "type": "SocketAddress"}], "return_type": "void", "signature": "@Override\n    public void bind(SocketAddress bindpoint)", "original_string": "    @Override\n    public void bind(SocketAddress bindpoint) throws IOException\n    {\n        if (delegate == null)\n            super.bind(bindpoint);\n        else\n            delegate.bind(bindpoint);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingSocket.java", "class_name": "DelegatingSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[void]close()", "name": "close", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Override\n    public void close()", "original_string": "    @Override\n    public void close() throws IOException\n    {\n        if (delegate == null)\n            super.close();\n        else\n            delegate.close();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingSocket.java", "class_name": "DelegatingSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[void]connect(SocketAddress)", "name": "connect", "arg_nums": 1, "params": [{"name": "endpoint", "type": "SocketAddress"}], "return_type": "void", "signature": "@Override\n    public void connect(SocketAddress endpoint)", "original_string": "    @Override\n    public void connect(SocketAddress endpoint) throws IOException\n    {\n        if (delegate == null)\n            super.connect(endpoint);\n        else\n            delegate.connect(endpoint);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingSocket.java", "class_name": "DelegatingSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[void]connect(SocketAddress,int)", "name": "connect", "arg_nums": 2, "params": [{"name": "endpoint", "type": "SocketAddress"}, {"name": "timeout", "type": "int"}], "return_type": "void", "signature": "@Override\n    public void connect(SocketAddress endpoint, int timeout)", "original_string": "    @Override\n    public void connect(SocketAddress endpoint, int timeout) throws IOException\n    {\n        if (delegate == null)\n            super.connect(endpoint, timeout);\n        else\n            delegate.connect(endpoint, timeout);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingSocket.java", "class_name": "DelegatingSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[SocketChannel]getChannel()", "name": "getChannel", "arg_nums": 0, "params": [], "return_type": "SocketChannel", "signature": "@Override\n    public SocketChannel getChannel()", "original_string": "    @Override\n    public SocketChannel getChannel()\n    {\n        SocketChannel channel = this.channel;\n\n        if (channel == null)\n        {\n            Socket delegate = this.delegate;\n\n            channel\n                = (delegate == null)\n                    ? super.getChannel()\n                    : delegate.getChannel();\n        }\n        return channel;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingSocket.java", "class_name": "DelegatingSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "SocketChannel", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[InetAddress]getInetAddress()", "name": "getInetAddress", "arg_nums": 0, "params": [], "return_type": "InetAddress", "signature": "@Override\n    public InetAddress getInetAddress()", "original_string": "    @Override\n    public InetAddress getInetAddress()\n    {\n        return\n            (delegate == null)\n                ? super.getInetAddress()\n                : delegate.getInetAddress();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingSocket.java", "class_name": "DelegatingSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "InetAddress", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[InputStream]getInputStream()", "name": "getInputStream", "arg_nums": 0, "params": [], "return_type": "InputStream", "signature": "@Override\n    public InputStream getInputStream()", "original_string": "    @Override\n    public InputStream getInputStream() throws IOException\n    {\n        return\n            (delegate == null)\n                ? super.getInputStream()\n                : delegate.getInputStream();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingSocket.java", "class_name": "DelegatingSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "InputStream", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[boolean]getKeepAlive()", "name": "getKeepAlive", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "@Override\n    public boolean getKeepAlive()", "original_string": "    @Override\n    public boolean getKeepAlive() throws SocketException\n    {\n        return\n            (delegate == null) ? super.getKeepAlive() : delegate.getKeepAlive();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingSocket.java", "class_name": "DelegatingSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[InetAddress]getLocalAddress()", "name": "getLocalAddress", "arg_nums": 0, "params": [], "return_type": "InetAddress", "signature": "@Override\n    public InetAddress getLocalAddress()", "original_string": "    @Override\n    public InetAddress getLocalAddress()\n    {\n        return\n            (delegate == null)\n                ? super.getLocalAddress()\n                : delegate.getLocalAddress();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingSocket.java", "class_name": "DelegatingSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "InetAddress", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[int]getLocalPort()", "name": "getLocalPort", "arg_nums": 0, "params": [], "return_type": "int", "signature": "@Override\n    public int getLocalPort()", "original_string": "    @Override\n    public int getLocalPort()\n    {\n        return\n            (delegate == null) ? super.getLocalPort() : delegate.getLocalPort();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingSocket.java", "class_name": "DelegatingSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[SocketAddress]getLocalSocketAddress()", "name": "getLocalSocketAddress", "arg_nums": 0, "params": [], "return_type": "SocketAddress", "signature": "@Override\n    public SocketAddress getLocalSocketAddress()", "original_string": "    @Override\n    public SocketAddress getLocalSocketAddress()\n    {\n        return\n            (delegate == null)\n                ? super.getLocalSocketAddress()\n                : delegate.getLocalSocketAddress();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingSocket.java", "class_name": "DelegatingSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "SocketAddress", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[boolean]getOOBInline()", "name": "getOOBInline", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "@Override\n    public boolean getOOBInline()", "original_string": "    @Override\n    public boolean getOOBInline() throws SocketException\n    {\n        return\n            (delegate == null) ? super.getOOBInline() : delegate.getOOBInline();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingSocket.java", "class_name": "DelegatingSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[OutputStream]getOutputStream()", "name": "getOutputStream", "arg_nums": 0, "params": [], "return_type": "OutputStream", "signature": "@Override\n    public OutputStream getOutputStream()", "original_string": "    @Override\n    public OutputStream getOutputStream() throws IOException\n    {\n        return\n            (delegate == null)\n                ? super.getOutputStream()\n                : delegate.getOutputStream();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingSocket.java", "class_name": "DelegatingSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "OutputStream", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[int]getPort()", "name": "getPort", "arg_nums": 0, "params": [], "return_type": "int", "signature": "@Override\n    public int getPort()", "original_string": "    @Override\n    public int getPort()\n    {\n        return (delegate == null) ? super.getPort() : delegate.getPort();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingSocket.java", "class_name": "DelegatingSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[int]getReceiveBufferSize()", "name": "getReceiveBufferSize", "arg_nums": 0, "params": [], "return_type": "int", "signature": "@Override\n    public int getReceiveBufferSize()", "original_string": "    @Override\n    public int getReceiveBufferSize() throws SocketException\n    {\n        return\n            (delegate == null)\n                ? super.getReceiveBufferSize()\n                : delegate.getReceiveBufferSize();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingSocket.java", "class_name": "DelegatingSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[SocketAddress]getRemoteSocketAddress()", "name": "getRemoteSocketAddress", "arg_nums": 0, "params": [], "return_type": "SocketAddress", "signature": "@Override\n    public SocketAddress getRemoteSocketAddress()", "original_string": "    @Override\n    public SocketAddress getRemoteSocketAddress()\n    {\n        return\n            (delegate == null)\n                ? super.getRemoteSocketAddress()\n                : delegate.getRemoteSocketAddress();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingSocket.java", "class_name": "DelegatingSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "SocketAddress", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[boolean]getReuseAddress()", "name": "getReuseAddress", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "@Override\n    public boolean getReuseAddress()", "original_string": "    @Override\n    public boolean getReuseAddress() throws SocketException\n    {\n        return\n            (delegate == null)\n                ? super.getReuseAddress()\n                : delegate.getReuseAddress();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingSocket.java", "class_name": "DelegatingSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[int]getSendBufferSize()", "name": "getSendBufferSize", "arg_nums": 0, "params": [], "return_type": "int", "signature": "@Override\n    public int getSendBufferSize()", "original_string": "    @Override\n    public int getSendBufferSize() throws SocketException\n    {\n        return\n            (delegate == null)\n                ? super.getSendBufferSize()\n                : delegate.getSendBufferSize();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingSocket.java", "class_name": "DelegatingSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[int]getSoLinger()", "name": "getSoLinger", "arg_nums": 0, "params": [], "return_type": "int", "signature": "@Override\n    public int getSoLinger()", "original_string": "    @Override\n    public int getSoLinger() throws SocketException\n    {\n        return\n            (delegate == null) ? super.getSoLinger() : delegate.getSoLinger();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingSocket.java", "class_name": "DelegatingSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[int]getSoTimeout()", "name": "getSoTimeout", "arg_nums": 0, "params": [], "return_type": "int", "signature": "@Override\n    public int getSoTimeout()", "original_string": "    @Override\n    public int getSoTimeout() throws SocketException\n    {\n        return\n            (delegate == null) ? super.getSoTimeout() : delegate.getSoTimeout();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingSocket.java", "class_name": "DelegatingSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[boolean]getTcpNoDelay()", "name": "getTcpNoDelay", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "@Override\n    public boolean getTcpNoDelay()", "original_string": "    @Override\n    public boolean getTcpNoDelay() throws SocketException\n    {\n        return\n            (delegate == null)\n                ? super.getTcpNoDelay()\n                : delegate.getTcpNoDelay();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingSocket.java", "class_name": "DelegatingSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[int]getTrafficClass()", "name": "getTrafficClass", "arg_nums": 0, "params": [], "return_type": "int", "signature": "@Override\n    public int getTrafficClass()", "original_string": "    @Override\n    public int getTrafficClass() throws SocketException\n    {\n        return\n            (delegate == null)\n                ? super.getTrafficClass()\n                : delegate.getTrafficClass();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingSocket.java", "class_name": "DelegatingSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[boolean]isBound()", "name": "isBound", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "@Override\n    public boolean isBound()", "original_string": "    @Override\n    public boolean isBound()\n    {\n        return (delegate == null) ? super.isBound() : delegate.isBound();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingSocket.java", "class_name": "DelegatingSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[boolean]isClosed()", "name": "isClosed", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "@Override\n    public boolean isClosed()", "original_string": "    @Override\n    public boolean isClosed()\n    {\n        return (delegate == null) ? super.isClosed() : delegate.isClosed();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingSocket.java", "class_name": "DelegatingSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[boolean]isConnected()", "name": "isConnected", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "@Override\n    public boolean isConnected()", "original_string": "    @Override\n    public boolean isConnected()\n    {\n        return\n            (delegate == null) ? super.isConnected() : delegate.isConnected();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingSocket.java", "class_name": "DelegatingSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[boolean]isInputShutdown()", "name": "isInputShutdown", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "@Override\n    public boolean isInputShutdown()", "original_string": "    @Override\n    public boolean isInputShutdown()\n    {\n        return\n            (delegate == null)\n                ? super.isInputShutdown()\n                : delegate.isInputShutdown();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingSocket.java", "class_name": "DelegatingSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[boolean]isOutputShutdown()", "name": "isOutputShutdown", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "@Override\n    public boolean isOutputShutdown()", "original_string": "    @Override\n    public boolean isOutputShutdown()\n    {\n        return\n            (delegate == null)\n                ? super.isOutputShutdown()\n                : delegate.isOutputShutdown();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingSocket.java", "class_name": "DelegatingSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[void]receive(DatagramPacket)", "name": "receive", "arg_nums": 1, "params": [{"name": "p", "type": "DatagramPacket"}], "return_type": "void", "signature": "public void receive(DatagramPacket p)", "original_string": "    public void receive(DatagramPacket p)\n        throws IOException\n    {\n        if (delegateAsDelegatingSocket != null)\n        {\n            delegateAsDelegatingSocket.receive(p);\n        }\n        else\n        {\n            SocketChannel channel = getChannel();\n\n            if (channel == null)\n            {\n                // Read from our InputStream\n                if (inputStream == null)\n                    inputStream = getInputStream();\n\n                DelegatingSocket.receiveFromInputStream(\n                        p,\n                        inputStream,\n                        getInetAddress(), getPort());\n            }\n            else\n            {\n                // For nio SocketChannel-s, the read() from the InputStream and\n                // the write() to the OutputStream both lock on the same object.\n                // So, read from the Channel directly in order to avoid\n                // preventing any writing threads from proceeding.\n                receiveFromChannel(channel, p);\n            }\n\n            InetSocketAddress localAddress\n                = (InetSocketAddress) super.getLocalSocketAddress();\n\n            if (StunDatagramPacketFilter.isStunPacket(p)\n                || DelegatingDatagramSocket.logNonStun(++nbReceivedPackets))\n            {\n                StunStack.logPacketToPcap(\n                        p,\n                        false,\n                        localAddress.getAddress(),\n                        localAddress.getPort());\n            }\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingSocket.java", "class_name": "DelegatingSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nReceives a datagram packet from this socket. The <tt>DatagramPacket</tt>s\nreturned by this method do not match any of the\n<tt>DatagramPacketFilter</tt>s of the <tt>MultiplexedSocket</tt>s\nassociated with this instance at the time of their receipt. When this\nmethod returns, the <tt>DatagramPacket</tt>'s buffer is filled with the\ndata received. The datagram packet also contains the sender's IP address,\nand the port number on the sender's machine.\n<p>\nThis method blocks until a datagram is received. The <tt>length</tt>\nfield of the datagram packet object contains the length of the received\nmessage. If the message is longer than the packet's length, the message\nis truncated.\n</p>\n\n@param p the <tt>DatagramPacket</tt> into which to place the incoming\n           data\n@throws IOException if an I/O error occurs\n@see #receive(DatagramPacket)\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[void]receiveFromChannel(SocketChannel,DatagramPacket)", "name": "receiveFromChannel", "arg_nums": 2, "params": [{"name": "channel", "type": "SocketChannel"}, {"name": "p", "type": "DatagramPacket"}], "return_type": "void", "signature": "private synchronized void receiveFromChannel(\n            SocketChannel channel,\n            DatagramPacket p)", "original_string": "    private synchronized void receiveFromChannel(\n            SocketChannel channel,\n            DatagramPacket p)\n        throws IOException\n    {\n        while (frameLengthByteBuffer.hasRemaining())\n        {\n            int read = channel.read(frameLengthByteBuffer);\n\n            if (read == -1)\n            {\n                throw new SocketException(\n                        \"Failed to receive data from socket.\");\n            }\n        }\n        frameLengthByteBuffer.flip();\n\n        int b0 = frameLengthByteBuffer.get();\n        int b1 = frameLengthByteBuffer.get();\n        int frameLength = ((b0 & 0xFF) << 8) | (b1 & 0xFF);\n\n        frameLengthByteBuffer.flip();\n\n        byte[] data = p.getData();\n\n        if (data == null || data.length < frameLength)\n            data = new byte[frameLength];\n\n        ByteBuffer byteBuffer = ByteBuffer.wrap(data, 0, frameLength);\n\n        while (byteBuffer.hasRemaining())\n        {\n            int read = channel.read(byteBuffer);\n\n            if (read == -1)\n            {\n                throw new SocketException(\n                        \"Failed to receive data from socket.\");\n            }\n        }\n\n        p.setAddress(getInetAddress());\n        p.setData(data, 0, frameLength);\n        p.setPort(getPort());\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingSocket.java", "class_name": "DelegatingSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket", "attributes": {"modifiers": "private synchronized", "marker_annotations": [], "non_marker_annotations": ["private", "synchronized"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nReceives an RFC4571-formatted frame from <tt>channel</tt> into\n<tt>p</tt>, and sets <tt>p</tt>'s port and address to the remote port\nand address of this <tt>Socket</tt>.\n\n@param channel\n@param p\n@throws IOException\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[void]send(DatagramPacket)", "name": "send", "arg_nums": 1, "params": [{"name": "p", "type": "DatagramPacket"}], "return_type": "void", "signature": "public void send(DatagramPacket p)", "original_string": "    public void send(DatagramPacket p) throws IOException\n    {\n        // The delegate socket will encapsulate the packet.\n        if (delegateAsDelegatingSocket != null)\n        {\n            delegateAsDelegatingSocket.send(p);\n        }\n        else\n        {\n            if (outputStream == null)\n                outputStream = getOutputStream();\n\n            // Else, sends the packet to the final socket (outputStream).\n            outputStream.write(p.getData(), p.getOffset(), p.getLength());\n\n            if (DelegatingDatagramSocket.logNonStun(++nbSentPackets))\n            {\n                InetSocketAddress localAddress\n                    = (InetSocketAddress) super.getLocalSocketAddress();\n\n                StunStack.logPacketToPcap(\n                        p,\n                        true,\n                        localAddress.getAddress(),\n                        localAddress.getPort());\n            }\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingSocket.java", "class_name": "DelegatingSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSend a datagram packet from this socket.\n\n@param p <tt>DatagramPacket</tt> to sent\n@throws IOException if something goes wrong during send\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[void]sendUrgentData(int)", "name": "sendUrgentData", "arg_nums": 1, "params": [{"name": "data", "type": "int"}], "return_type": "void", "signature": "@Override\n    public void sendUrgentData(int data)", "original_string": "    @Override\n    public void sendUrgentData(int data) throws IOException\n    {\n        if (delegate == null)\n            super.sendUrgentData(data);\n        else\n            delegate.sendUrgentData(data);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingSocket.java", "class_name": "DelegatingSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[void]setKeepAlive(boolean)", "name": "setKeepAlive", "arg_nums": 1, "params": [{"name": "on", "type": "boolean"}], "return_type": "void", "signature": "@Override\n    public void setKeepAlive(boolean on)", "original_string": "    @Override\n    public void setKeepAlive(boolean on) throws SocketException\n    {\n        if (delegate == null)\n            super.setKeepAlive(on);\n        else\n            delegate.setKeepAlive(on);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingSocket.java", "class_name": "DelegatingSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[void]setOOBInline(boolean)", "name": "setOOBInline", "arg_nums": 1, "params": [{"name": "on", "type": "boolean"}], "return_type": "void", "signature": "@Override\n    public void setOOBInline(boolean on)", "original_string": "    @Override\n    public void setOOBInline(boolean on) throws SocketException\n    {\n        if (delegate == null)\n            super.setOOBInline(on);\n        else\n            delegate.setOOBInline(on);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingSocket.java", "class_name": "DelegatingSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[void]setOriginalInputStream(InputStream)", "name": "setOriginalInputStream", "arg_nums": 1, "params": [{"name": "inputStream", "type": "InputStream"}], "return_type": "void", "signature": "public void setOriginalInputStream(InputStream inputStream)", "original_string": "    public void setOriginalInputStream(InputStream inputStream)\n    {\n        if (this.inputStream == null && inputStream != null)\n            this.inputStream = inputStream;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingSocket.java", "class_name": "DelegatingSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSet original <tt>InputStream</tt>.\n\n@param inputStream <tt>InputStream</tt>\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[void]setPerformancePreferences(int,int,int)", "name": "setPerformancePreferences", "arg_nums": 3, "params": [{"name": "connectionTime", "type": "int"}, {"name": "latency", "type": "int"}, {"name": "bandwidth", "type": "int"}], "return_type": "void", "signature": "@Override\n    public void setPerformancePreferences(\n            int connectionTime,\n            int latency,\n            int bandwidth)", "original_string": "    @Override\n    public void setPerformancePreferences(\n            int connectionTime,\n            int latency,\n            int bandwidth)\n    {\n        if (delegate == null)\n        {\n            super.setPerformancePreferences(connectionTime, latency, bandwidth);\n        }\n        else\n        {\n            delegate.setPerformancePreferences(\n                    connectionTime,\n                    latency,\n                    bandwidth);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingSocket.java", "class_name": "DelegatingSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[void]setReceiveBufferSize(int)", "name": "setReceiveBufferSize", "arg_nums": 1, "params": [{"name": "size", "type": "int"}], "return_type": "void", "signature": "@Override\n    public void setReceiveBufferSize(int size)", "original_string": "    @Override\n    public void setReceiveBufferSize(int size) throws SocketException\n    {\n        if (delegate == null)\n            super.setReceiveBufferSize(size);\n        else\n            delegate.setReceiveBufferSize(size);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingSocket.java", "class_name": "DelegatingSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[void]setReuseAddress(boolean)", "name": "setReuseAddress", "arg_nums": 1, "params": [{"name": "on", "type": "boolean"}], "return_type": "void", "signature": "@Override\n    public void setReuseAddress(boolean on)", "original_string": "    @Override\n    public void setReuseAddress(boolean on) throws SocketException\n    {\n        if (delegate == null)\n            super.setReuseAddress(on);\n        else\n            delegate.setReuseAddress(on);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingSocket.java", "class_name": "DelegatingSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[void]setSendBufferSize(int)", "name": "setSendBufferSize", "arg_nums": 1, "params": [{"name": "size", "type": "int"}], "return_type": "void", "signature": "@Override\n    public void setSendBufferSize(int size)", "original_string": "    @Override\n    public void setSendBufferSize(int size) throws SocketException\n    {\n        if (delegate == null)\n            super.setSendBufferSize(size);\n        else\n            delegate.setSendBufferSize(size);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingSocket.java", "class_name": "DelegatingSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[void]setSoLinger(boolean,int)", "name": "setSoLinger", "arg_nums": 2, "params": [{"name": "on", "type": "boolean"}, {"name": "linger", "type": "int"}], "return_type": "void", "signature": "@Override\n    public void setSoLinger(boolean on, int linger)", "original_string": "    @Override\n    public void setSoLinger(boolean on, int linger) throws SocketException\n    {\n        if (delegate == null)\n            super.setSoLinger(on, linger);\n        else\n            delegate.setSoLinger(on, linger);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingSocket.java", "class_name": "DelegatingSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[void]setSoTimeout(int)", "name": "setSoTimeout", "arg_nums": 1, "params": [{"name": "timeout", "type": "int"}], "return_type": "void", "signature": "@Override\n    public void setSoTimeout(int timeout)", "original_string": "    @Override\n    public void setSoTimeout(int timeout) throws SocketException\n    {\n        if (delegate == null)\n            super.setSoTimeout(timeout);\n        else\n            delegate.setSoTimeout(timeout);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingSocket.java", "class_name": "DelegatingSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[void]setTcpNoDelay(boolean)", "name": "setTcpNoDelay", "arg_nums": 1, "params": [{"name": "on", "type": "boolean"}], "return_type": "void", "signature": "@Override\n    public void setTcpNoDelay(boolean on)", "original_string": "    @Override\n    public void setTcpNoDelay(boolean on) throws SocketException\n    {\n        if (delegate == null)\n            super.setTcpNoDelay(on);\n        else\n            delegate.setTcpNoDelay(on);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingSocket.java", "class_name": "DelegatingSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[void]setTrafficClass(int)", "name": "setTrafficClass", "arg_nums": 1, "params": [{"name": "tc", "type": "int"}], "return_type": "void", "signature": "@Override\n    public void setTrafficClass(int tc)", "original_string": "    @Override\n    public void setTrafficClass(int tc) throws SocketException\n    {\n        if (delegate == null)\n            super.setTrafficClass(tc);\n        else\n            delegate.setTrafficClass(tc);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingSocket.java", "class_name": "DelegatingSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[void]shutdownInput()", "name": "shutdownInput", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Override\n    public void shutdownInput()", "original_string": "    @Override\n    public void shutdownInput() throws IOException\n    {\n        if (delegate == null)\n            super.shutdownInput();\n        else\n            delegate.shutdownInput();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingSocket.java", "class_name": "DelegatingSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[void]shutdownOutput()", "name": "shutdownOutput", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Override\n    public void shutdownOutput()", "original_string": "    @Override\n    public void shutdownOutput() throws IOException\n    {\n        if (delegate == null)\n            super.shutdownOutput();\n        else\n            delegate.shutdownOutput();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingSocket.java", "class_name": "DelegatingSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[String]toString()", "name": "toString", "arg_nums": 0, "params": [], "return_type": "String", "signature": "@Override\n    public String toString()", "original_string": "    @Override\n    public String toString()\n    {\n        return (delegate == null) ? super.toString() : delegate.toString();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingSocket.java", "class_name": "DelegatingSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDelegate.java.GoogleRelayedCandidateDelegate.[]GoogleRelayedCandidateDelegate(GoogleTurnCandidateHarvest,String)", "name": "GoogleRelayedCandidateDelegate", "arg_nums": 2, "params": [{"name": "turnCandidateHarvest", "type": "GoogleTurnCandidateHarvest"}, {"name": "username", "type": "String"}], "return_type": "", "signature": "public GoogleRelayedCandidateDelegate(\n        GoogleTurnCandidateHarvest turnCandidateHarvest, String username)", "original_string": "    public GoogleRelayedCandidateDelegate(\n        GoogleTurnCandidateHarvest turnCandidateHarvest, String username)\n        throws SocketException\n    {\n        this.turnCandidateHarvest = turnCandidateHarvest;\n        this.username = username;\n\n        this.turnCandidateHarvest.harvester.getStunStack()\n            .addOldIndicationListener(\n                this.turnCandidateHarvest.hostCandidate.getTransportAddress(),\n                this);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDelegate.java", "class_name": "GoogleRelayedCandidateDelegate", "class_uri": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDelegate.java.GoogleRelayedCandidateDelegate", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>GoogleRelayedCandidateDatagramSocket</tt> instance\nwhich is to be the <tt>socket</tt> of a specific\n<tt>RelayedCandidate</tt> harvested by a specific\n<tt>TurnCandidateHarvest</tt>.\n\n@param turnCandidateHarvest the <tt>TurnCandidateHarvest</tt> which has\nharvested <tt>relayedCandidate</tt>\n@param username username\n@throws SocketException if anything goes wrong while initializing the new\n<tt>GoogleRelayedCandidateDatagramSocket</tt> instance\n"}, {"uris": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDelegate.java.GoogleRelayedCandidateDelegate.[void]close()", "name": "close", "arg_nums": 0, "params": [], "return_type": "void", "signature": "public void close()", "original_string": "    public void close()\n    {\n        synchronized (this)\n        {\n            if (this.closed)\n                return;\n            else\n                this.closed = true;\n        }\n        synchronized (packetsToReceive)\n        {\n            packetsToReceive.notifyAll();\n        }\n        synchronized (packetsToSend)\n        {\n            packetsToSend.notifyAll();\n        }\n\n        turnCandidateHarvest.harvester.getStunStack().removeIndicationListener(\n            turnCandidateHarvest.hostCandidate.getTransportAddress(), this);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDelegate.java", "class_name": "GoogleRelayedCandidateDelegate", "class_uri": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDelegate.java.GoogleRelayedCandidateDelegate", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCloses this datagram socket.\n\n@see DatagramSocket#close()\n"}, {"uris": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDelegate.java.GoogleRelayedCandidateDelegate.[void]handleMessageEvent(StunMessageEvent)", "name": "handleMessageEvent", "arg_nums": 1, "params": [{"name": "e", "type": "StunMessageEvent"}], "return_type": "void", "signature": "public void handleMessageEvent(StunMessageEvent e)", "original_string": "    public void handleMessageEvent(StunMessageEvent e)\n    {\n        Message message = e.getMessage();\n        char messageType = message.getMessageType();\n\n        if (messageType != Message.OLD_DATA_INDICATION)\n            return;\n\n        if (!turnCandidateHarvest.hostCandidate.getTransportAddress().equals(\n            e.getLocalAddress()))\n            return;\n\n        // Is it from our TURN server?\n        if (!turnCandidateHarvest.harvester.stunServer.equals(e\n            .getRemoteAddress()))\n            return;\n\n        logger.finest(\"handle old DATA Indication\");\n\n        /*\n         * as REMOTE-ADDRESS and XOR-PEER-ADDRESS has the same attribute type we\n         * cast it to XorPeerAddressAttribute but we do not apply XOR to get the\n         * address\n         */\n        XorPeerAddressAttribute peerAddressAttribute =\n            (XorPeerAddressAttribute) message\n                .getAttribute(Attribute.REMOTE_ADDRESS);\n\n        if (peerAddressAttribute == null)\n        {\n            logger.info(\"peerAddressAttribute is null\");\n            return;\n        }\n\n        DataAttribute dataAttribute =\n            (DataAttribute) message.getAttribute(Attribute.DATA);\n\n        if (dataAttribute == null)\n        {\n            logger.info(\"data is null\");\n            return;\n        }\n\n        TransportAddress peerAddress = peerAddressAttribute.getAddress();\n        if (peerAddress == null)\n            return;\n\n        byte[] data = dataAttribute.getData();\n\n        if (data == null)\n            return;\n\n        DatagramPacket packetToReceive;\n\n        try\n        {\n            packetToReceive\n                = new DatagramPacket(data, 0, data.length, peerAddress);\n        }\n        catch (Throwable t)\n        {\n            /*\n             * The signature of the DatagramPacket constructor was changed\n             * in JDK 8 to not declare that it may throw a SocketException.\n             */\n            if (t instanceof SocketException)\n            {\n                packetToReceive = null;\n            }\n            else if (t instanceof Error)\n            {\n                throw (Error) t;\n            }\n            else if (t instanceof RuntimeException)\n            {\n                throw (RuntimeException) t;\n            }\n            else\n            {\n                /*\n                 * Unfortunately, we cannot re-throw it. Anyway, it was\n                 * unlikely to occur on JDK 7.\n                 */\n                if (t instanceof InterruptedException)\n                {\n                    Thread.currentThread().interrupt();\n                }\n                packetToReceive = null;\n            }\n        }\n        if (packetToReceive != null)\n        {\n            synchronized (packetsToReceive)\n            {\n                packetsToReceive.add(packetToReceive);\n                packetsToReceive.notifyAll();\n            }\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDelegate.java", "class_name": "GoogleRelayedCandidateDelegate", "class_uri": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDelegate.java.GoogleRelayedCandidateDelegate", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nNotifies this <tt>MessageEventHandler</tt> that a specific STUN message\nhas been received, parsed and is ready for delivery.\n<tt>GoogleRelayedCandidateDatagramSocket</tt> handles STUN indications\nsent from the associated TURN server and received at the associated local\n<tt>TransportAddress</tt>.\n\n@param e a <tt>StunMessageEvent</tt> which encapsulates the received STUN\n           message\n"}, {"uris": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDelegate.java.GoogleRelayedCandidateDelegate.[boolean]processErrorOrFailure(Response,Request)", "name": "processErrorOrFailure", "arg_nums": 2, "params": [{"name": "response", "type": "Response"}, {"name": "request", "type": "Request"}], "return_type": "boolean", "signature": "public boolean processErrorOrFailure(Response response, Request request)", "original_string": "    public boolean processErrorOrFailure(Response response, Request request)\n    {\n        return false;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDelegate.java", "class_name": "GoogleRelayedCandidateDelegate", "class_uri": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDelegate.java.GoogleRelayedCandidateDelegate", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nNotifies this <tt>GoogleRelayedCandidateDatagramSocket</tt> that a\nspecific <tt>Request</tt> it has sent has either failed or received a\nSTUN error <tt>Response</tt>.\n\n@param response the <tt>Response</tt> which responds to <tt>request</tt>\n@param request the <tt>Request</tt> sent by this instance to which\n           <tt>response</tt> responds\n@return <tt>true</tt> if the failure or error condition has been handled\n        and the caller should assume this instance has recovered from it;\n        otherwise, <tt>false</tt>\n"}, {"uris": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDelegate.java.GoogleRelayedCandidateDelegate.[void]processSuccess(Response,Request)", "name": "processSuccess", "arg_nums": 2, "params": [{"name": "response", "type": "Response"}, {"name": "request", "type": "Request"}], "return_type": "void", "signature": "public void processSuccess(Response response, Request request)", "original_string": "    public void processSuccess(Response response, Request request)\n    {\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDelegate.java", "class_name": "GoogleRelayedCandidateDelegate", "class_uri": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDelegate.java.GoogleRelayedCandidateDelegate", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nNotifies this <tt>GoogleRelayedCandidateDatagramSocket</tt> that a\nspecific <tt>Request</tt> it has sent has received a STUN success\n<tt>Response</tt>.\n\n@param response the <tt>Response</tt> which responds to <tt>request</tt>\n@param request the <tt>Request</tt> sent by this instance to which\n           <tt>response</tt> responds\n"}, {"uris": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDelegate.java.GoogleRelayedCandidateDelegate.[void]processResponse(StunResponseEvent)", "name": "processResponse", "arg_nums": 1, "params": [{"name": "response", "type": "StunResponseEvent"}], "return_type": "void", "signature": "public void processResponse(StunResponseEvent response)", "original_string": "    public void processResponse(StunResponseEvent response)\n    {\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDelegate.java", "class_name": "GoogleRelayedCandidateDelegate", "class_uri": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDelegate.java.GoogleRelayedCandidateDelegate", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nDispatch the specified response.\n\n@param response the response to dispatch.\n"}, {"uris": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDelegate.java.GoogleRelayedCandidateDelegate.[void]processTimeout(StunTimeoutEvent)", "name": "processTimeout", "arg_nums": 1, "params": [{"name": "event", "type": "StunTimeoutEvent"}], "return_type": "void", "signature": "public void processTimeout(StunTimeoutEvent event)", "original_string": "    public void processTimeout(StunTimeoutEvent event)\n    {\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDelegate.java", "class_name": "GoogleRelayedCandidateDelegate", "class_uri": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDelegate.java.GoogleRelayedCandidateDelegate", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nNotifies this collector that no response had been received after repeated\nretransmissions of the original request (as described by rfc3489) and\nthat the request should be considered unanswered.\n\n@param event the <tt>StunTimeoutEvent</tt> containing a reference to the\n           transaction that has just failed.\n"}, {"uris": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDelegate.java.GoogleRelayedCandidateDelegate.[void]receive(DatagramPacket)", "name": "receive", "arg_nums": 1, "params": [{"name": "p", "type": "DatagramPacket"}], "return_type": "void", "signature": "public void receive(DatagramPacket p)", "original_string": "    public void receive(DatagramPacket p) throws IOException\n    {\n        synchronized (packetsToReceive)\n        {\n            do\n            {\n                /*\n                 * According to the javadoc of DatagramSocket#close(), any\n                 * thread currently blocked in #receive(DatagramPacket) upon\n                 * this socket will throw a SocketException.\n                 */\n                if (closed)\n                {\n                    throw new SocketException(\n                        GoogleRelayedCandidateDatagramSocket.class\n                            .getSimpleName() + \" has been closed.\");\n                }\n                else if (packetsToReceive.isEmpty())\n                {\n                    try\n                    {\n                        packetsToReceive.wait();\n                    }\n                    catch (InterruptedException iex)\n                    {\n                    }\n                }\n                else\n                {\n                    DatagramPacket packetToReceive = packetsToReceive.remove(0);\n\n                    MultiplexingXXXSocketSupport.copy(packetToReceive, p);\n                    packetsToReceive.notifyAll();\n                    break;\n                }\n            }\n            while (true);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDelegate.java", "class_name": "GoogleRelayedCandidateDelegate", "class_uri": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDelegate.java.GoogleRelayedCandidateDelegate", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nReceives a datagram packet from this socket. When this method returns,\nthe <tt>DatagramPacket</tt>'s buffer is filled with the data received.\nThe datagram packet also contains the sender's IP address, and the port\nnumber on the sender's machine.\n\n@param p the <tt>DatagramPacket</tt> into which to place the incoming\n           data\n@throws IOException if an I/O error occurs\n@see DatagramSocket#receive(DatagramPacket)\n"}, {"uris": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDelegate.java.GoogleRelayedCandidateDelegate.[void]send(DatagramPacket)", "name": "send", "arg_nums": 1, "params": [{"name": "p", "type": "DatagramPacket"}], "return_type": "void", "signature": "public void send(DatagramPacket p)", "original_string": "    public void send(DatagramPacket p) throws IOException\n    {\n        synchronized (packetsToSend)\n        {\n            if (closed)\n            {\n                throw new IOException(\n                    GoogleRelayedCandidateDatagramSocket.class.getSimpleName()\n                        + \" has been closed.\");\n            }\n            else\n            {\n                packetsToSend.add(MultiplexingXXXSocketSupport.clone(p));\n                if (sendThread == null)\n                    createSendThread();\n                else\n                    packetsToSend.notifyAll();\n            }\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDelegate.java", "class_name": "GoogleRelayedCandidateDelegate", "class_uri": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDelegate.java.GoogleRelayedCandidateDelegate", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSends a datagram packet from this socket. The <tt>DatagramPacket</tt>\nincludes information indicating the data to be sent, its length, the IP\naddress of the remote host, and the port number on the remote host.\n\n@param p the <tt>DatagramPacket</tt> to be sent\n@throws IOException if an I/O error occurs\n@see DatagramSocket#send(DatagramPacket)\n"}, {"uris": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDelegate.java.GoogleRelayedCandidateDelegate.[void]createSendThread()", "name": "createSendThread", "arg_nums": 0, "params": [], "return_type": "void", "signature": "private void createSendThread()", "original_string": "    private void createSendThread()\n    {\n        sendThread = new Thread()\n        {\n            @Override\n            public void run()\n            {\n                try\n                {\n                    runInSendThread();\n                }\n                finally\n                {\n                    /*\n                     * If sendThread is dying and there are packetsToSend, then\n                     * spawn a new sendThread.\n                     */\n                    synchronized (packetsToSend)\n                    {\n                        if (sendThread == Thread.currentThread())\n                            sendThread = null;\n                        if ((sendThread == null) && !closed\n                            && !packetsToSend.isEmpty())\n                            createSendThread();\n                    }\n                }\n            }\n        };\n        sendThread.start();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDelegate.java", "class_name": "GoogleRelayedCandidateDelegate", "class_uri": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDelegate.java.GoogleRelayedCandidateDelegate", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCreates {@link #sendThread} which is to send {@link #packetsToSend} to\nthe associated TURN server.\n"}, {"uris": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDelegate.java.GoogleRelayedCandidateDelegate.[void]runInSendThread()", "name": "runInSendThread", "arg_nums": 0, "params": [], "return_type": "void", "signature": "private void runInSendThread()", "original_string": "    private void runInSendThread()\n    {\n        synchronized (packetsToSend)\n        {\n            while (!closed)\n            {\n                if (packetsToSend.isEmpty())\n                {\n                    try\n                    {\n                        packetsToSend.wait();\n                    }\n                    catch (InterruptedException iex)\n                    {\n                    }\n                    continue;\n                }\n\n                int packetToSendCount = packetsToSend.size();\n\n                for (int packetToSendIndex = 0; packetToSendIndex < packetToSendCount; packetToSendIndex++)\n                {\n                    DatagramPacket packetToSend = packetsToSend.remove(0);\n                    TransportAddress peerAddress =\n                        new TransportAddress(packetToSend.getAddress(),\n                            packetToSend.getPort(), Transport.UDP);\n                    byte[] pData = packetToSend.getData();\n                    int pOffset = packetToSend.getOffset();\n                    int pLength = packetToSend.getLength();\n                    byte[] data;\n\n                    if ((pOffset == 0) && (pLength == pData.length))\n                        data = pData;\n                    else\n                    {\n                        data = new byte[pLength];\n                        System.arraycopy(pData, pOffset, data, 0, pLength);\n                    }\n\n                    byte[] transactionID =\n                        TransactionID.createNewTransactionID().getBytes();\n                    Request sendRequest =\n                        MessageFactory.createSendRequest(username, peerAddress,\n                            data);\n\n                    try\n                    {\n                        sendRequest.setTransactionID(transactionID);\n                        turnCandidateHarvest.harvester.getStunStack()\n                            .sendRequest(\n                                sendRequest,\n                                turnCandidateHarvest.harvester.stunServer,\n                                turnCandidateHarvest.hostCandidate\n                                    .getTransportAddress(), this);\n                    }\n                    catch (Exception e)\n                    {\n                        logger.fine(\"Failed to send TURN Send request: \" + e);\n                    }\n                }\n\n                /*\n                 * If no packetToSend has been sent by the current iteration,\n                 * then we must be waiting for some condition to change in order\n                 * to be able to send.\n                 */\n                if (packetsToSend.size() == packetToSendCount)\n                {\n                    try\n                    {\n                        packetsToSend.wait();\n                    }\n                    catch (InterruptedException iex)\n                    {\n                    }\n                }\n            }\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDelegate.java", "class_name": "GoogleRelayedCandidateDelegate", "class_uri": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDelegate.java.GoogleRelayedCandidateDelegate", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nRuns in {@link #sendThread} to send {@link #packetsToSend} to the\nassociated TURN server.\n"}, {"uris": "src/main/java/org/ice4j/socket/IceSocketWrapper.java.IceSocketWrapper.[void]send(DatagramPacket)", "name": "send", "arg_nums": 1, "params": [{"name": "p", "type": "DatagramPacket"}], "return_type": "void", "signature": "public abstract void send(DatagramPacket p)", "original_string": "    public abstract void send(DatagramPacket p)\n        throws IOException;", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/IceSocketWrapper.java", "class_name": "IceSocketWrapper", "class_uri": "src/main/java/org/ice4j/socket/IceSocketWrapper.java.IceSocketWrapper", "attributes": {"modifiers": "public abstract", "marker_annotations": [], "non_marker_annotations": ["public", "abstract"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSends a <tt>DatagramPacket</tt> from this socket\nIt is a utility method to provide a common way to send for both\nUDP and TCP socket. If the underlying socket is a TCP one, it is still\npossible to get the <tt>OutputStream</tt> and do stuff with it.\n\n\n@param p <tt>DatagramPacket</tt> to send\n@throws IOException if something goes wrong\n"}, {"uris": "src/main/java/org/ice4j/socket/IceSocketWrapper.java.IceSocketWrapper.[void]receive(DatagramPacket)", "name": "receive", "arg_nums": 1, "params": [{"name": "p", "type": "DatagramPacket"}], "return_type": "void", "signature": "public abstract void receive(DatagramPacket p)", "original_string": "    public abstract void receive(DatagramPacket p)\n        throws IOException;", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/IceSocketWrapper.java", "class_name": "IceSocketWrapper", "class_uri": "src/main/java/org/ice4j/socket/IceSocketWrapper.java.IceSocketWrapper", "attributes": {"modifiers": "public abstract", "marker_annotations": [], "non_marker_annotations": ["public", "abstract"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nReceives a <tt>DatagramPacket</tt> from this socket.\nIt is a utility method to provide a common way to receive for both\nUDP and TCP socket. If the underlying socket is a TCP one, it is still\npossible to get the <tt>InputStream</tt> and do stuff with it.\n\n@param p <tt>DatagramPacket</tt>\n@throws IOException if something goes wrong\n"}, {"uris": "src/main/java/org/ice4j/socket/IceSocketWrapper.java.IceSocketWrapper.[void]close()", "name": "close", "arg_nums": 0, "params": [], "return_type": "void", "signature": "public abstract void close()", "original_string": "    public abstract void close();", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/IceSocketWrapper.java", "class_name": "IceSocketWrapper", "class_uri": "src/main/java/org/ice4j/socket/IceSocketWrapper.java.IceSocketWrapper", "attributes": {"modifiers": "public abstract", "marker_annotations": [], "non_marker_annotations": ["public", "abstract"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCloses this socket.\n"}, {"uris": "src/main/java/org/ice4j/socket/IceSocketWrapper.java.IceSocketWrapper.[InetAddress]getLocalAddress()", "name": "getLocalAddress", "arg_nums": 0, "params": [], "return_type": "InetAddress", "signature": "public abstract InetAddress getLocalAddress()", "original_string": "    public abstract InetAddress getLocalAddress();", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/IceSocketWrapper.java", "class_name": "IceSocketWrapper", "class_uri": "src/main/java/org/ice4j/socket/IceSocketWrapper.java.IceSocketWrapper", "attributes": {"modifiers": "public abstract", "marker_annotations": [], "non_marker_annotations": ["public", "abstract"], "comments": [], "return_type": "InetAddress", "classes": []}, "docstring": "\nGet local address.\n\n@return local address\n"}, {"uris": "src/main/java/org/ice4j/socket/IceSocketWrapper.java.IceSocketWrapper.[int]getLocalPort()", "name": "getLocalPort", "arg_nums": 0, "params": [], "return_type": "int", "signature": "public abstract int getLocalPort()", "original_string": "    public abstract int getLocalPort();", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/IceSocketWrapper.java", "class_name": "IceSocketWrapper", "class_uri": "src/main/java/org/ice4j/socket/IceSocketWrapper.java.IceSocketWrapper", "attributes": {"modifiers": "public abstract", "marker_annotations": [], "non_marker_annotations": ["public", "abstract"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\nGet local port.\n\n@return local port\n"}, {"uris": "src/main/java/org/ice4j/socket/IceSocketWrapper.java.IceSocketWrapper.[SocketAddress]getLocalSocketAddress()", "name": "getLocalSocketAddress", "arg_nums": 0, "params": [], "return_type": "SocketAddress", "signature": "public abstract SocketAddress getLocalSocketAddress()", "original_string": "    public abstract SocketAddress getLocalSocketAddress();", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/IceSocketWrapper.java", "class_name": "IceSocketWrapper", "class_uri": "src/main/java/org/ice4j/socket/IceSocketWrapper.java.IceSocketWrapper", "attributes": {"modifiers": "public abstract", "marker_annotations": [], "non_marker_annotations": ["public", "abstract"], "comments": [], "return_type": "SocketAddress", "classes": []}, "docstring": "\nGet socket address.\n\n@return socket address\n"}, {"uris": "src/main/java/org/ice4j/socket/IceSocketWrapper.java.IceSocketWrapper.[Socket]getTCPSocket()", "name": "getTCPSocket", "arg_nums": 0, "params": [], "return_type": "Socket", "signature": "public abstract Socket getTCPSocket()", "original_string": "    public abstract Socket getTCPSocket();", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/IceSocketWrapper.java", "class_name": "IceSocketWrapper", "class_uri": "src/main/java/org/ice4j/socket/IceSocketWrapper.java.IceSocketWrapper", "attributes": {"modifiers": "public abstract", "marker_annotations": [], "non_marker_annotations": ["public", "abstract"], "comments": [], "return_type": "Socket", "classes": []}, "docstring": "\nReturns Socket object if the delegate socket is a TCP one, null\notherwise.\n\n@return Socket object if the delegate socket is a TCP one, null\notherwise.\n"}, {"uris": "src/main/java/org/ice4j/socket/IceSocketWrapper.java.IceSocketWrapper.[DatagramSocket]getUDPSocket()", "name": "getUDPSocket", "arg_nums": 0, "params": [], "return_type": "DatagramSocket", "signature": "public abstract DatagramSocket getUDPSocket()", "original_string": "    public abstract DatagramSocket getUDPSocket();", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/IceSocketWrapper.java", "class_name": "IceSocketWrapper", "class_uri": "src/main/java/org/ice4j/socket/IceSocketWrapper.java.IceSocketWrapper", "attributes": {"modifiers": "public abstract", "marker_annotations": [], "non_marker_annotations": ["public", "abstract"], "comments": [], "return_type": "DatagramSocket", "classes": []}, "docstring": "\nReturns DatagramSocket object if the delegate socket is a UDP one, null\notherwise.\n\n@return DatagramSocket object if the delegate socket is a UDP one, null\notherwise.\n"}, {"uris": "src/main/java/org/ice4j/socket/SocketReceiveBuffer.java.SocketReceiveBuffer.[]SocketReceiveBuffer(Callable<Integer>)", "name": "SocketReceiveBuffer", "arg_nums": 1, "params": [{"name": "receiveBufferSizeSupplier", "type": "Callable<Integer>"}], "return_type": "", "signature": "public SocketReceiveBuffer(Callable<Integer> receiveBufferSizeSupplier)", "original_string": "    public SocketReceiveBuffer(Callable<Integer> receiveBufferSizeSupplier)\n    {\n        this.tracker = new DatagramSizeTracker(receiveBufferSizeSupplier);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/SocketReceiveBuffer.java", "class_name": "SocketReceiveBuffer", "class_uri": "src/main/java/org/ice4j/socket/SocketReceiveBuffer.java.SocketReceiveBuffer", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nConstructs {@link SocketReceiveBuffer} with user-provided\n@param receiveBufferSizeSupplier a function to obtain receive buffer\nsize from associated socket.\n"}, {"uris": "src/main/java/org/ice4j/socket/SocketReceiveBuffer.java.SocketReceiveBuffer.[boolean]isEmpty()", "name": "isEmpty", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "public boolean isEmpty()", "original_string": "    public boolean isEmpty()\n    {\n        return buffer.isEmpty();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/SocketReceiveBuffer.java", "class_name": "SocketReceiveBuffer", "class_uri": "src/main/java/org/ice4j/socket/SocketReceiveBuffer.java.SocketReceiveBuffer", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nCheck if receive buffer is empty\n@return true if buffer is empty, false - otherwise.\n"}, {"uris": "src/main/java/org/ice4j/socket/SocketReceiveBuffer.java.SocketReceiveBuffer.[void]add(DatagramPacket)", "name": "add", "arg_nums": 1, "params": [{"name": "p", "type": "DatagramPacket"}], "return_type": "void", "signature": "public void add(DatagramPacket p)", "original_string": "    public void add(DatagramPacket p)\n    {\n        while (!buffer.offer(p))\n        {\n            // ensure buffer capacity restriction enforced\n            poll();\n        }\n\n        tracker.trackDatagramAdded(p);\n\n        while (tracker.isExceedReceiveBufferSize() && buffer.size() > 1)\n        {\n            // enforce SO_RCVBUF restriction\n            poll();\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/SocketReceiveBuffer.java", "class_name": "SocketReceiveBuffer", "class_uri": "src/main/java/org/ice4j/socket/SocketReceiveBuffer.java.SocketReceiveBuffer", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nAdds {@link DatagramPacket} at the end of the socket receive buffer.\n@param p datagram to add into receive buffer\n"}, {"uris": "src/main/java/org/ice4j/socket/SocketReceiveBuffer.java.SocketReceiveBuffer.[DatagramPacket]poll()", "name": "poll", "arg_nums": 0, "params": [], "return_type": "DatagramPacket", "signature": "public DatagramPacket poll()", "original_string": "    public DatagramPacket poll()\n    {\n        DatagramPacket p = buffer.poll();\n\n        // Keep track of the (total) size in bytes of this receive buffer in\n        // order to be able to enforce SO_RCVBUF restriction.\n        if (p != null)\n        {\n            tracker.trackDatagramRemoved(p);\n        }\n\n        return p;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/SocketReceiveBuffer.java", "class_name": "SocketReceiveBuffer", "class_uri": "src/main/java/org/ice4j/socket/SocketReceiveBuffer.java.SocketReceiveBuffer", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "DatagramPacket", "classes": []}, "docstring": "\nPolls socket receive buffer for already stored {@link DatagramPacket}\n@return the first datagram in the buffer, or {@code null} if buffer\nis empty.\n"}, {"uris": "src/main/java/org/ice4j/socket/SocketReceiveBuffer.java.SocketReceiveBuffer.[List<DatagramPacket>]scan(DatagramPacketFilter)", "name": "scan", "arg_nums": 1, "params": [{"name": "filter", "type": "DatagramPacketFilter"}], "return_type": "List<DatagramPacket>", "signature": "public List<DatagramPacket> scan(DatagramPacketFilter filter)", "original_string": "    public List<DatagramPacket> scan(DatagramPacketFilter filter)\n    {\n        List<DatagramPacket> matchedDatagrams = null;\n        final Iterator<DatagramPacket> it = buffer.iterator();\n\n        while (it.hasNext())\n        {\n            final DatagramPacket p = it.next();\n\n            if (filter.accept(p))\n            {\n                if (matchedDatagrams == null)\n                {\n                    matchedDatagrams = new ArrayList<>();\n                }\n                matchedDatagrams.add(p);\n\n                it.remove();\n\n                tracker.trackDatagramRemoved(p);\n            }\n        }\n\n        if (matchedDatagrams != null)\n        {\n            return matchedDatagrams;\n        }\n        return Collections.emptyList();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/SocketReceiveBuffer.java", "class_name": "SocketReceiveBuffer", "class_uri": "src/main/java/org/ice4j/socket/SocketReceiveBuffer.java.SocketReceiveBuffer", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<DatagramPacket>", "classes": []}, "docstring": "\nScans buffer of received {@link DatagramPacket}s and move\ndatagrams which matches the {@code filter} into returned list.\n@param filter a predicate to filter {@link DatagramPacket} stored\nin receive buffer.\n@return list of datagrams matched to {@code filter}.\n"}, {"uris": "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java.RelayedCandidateDatagramSocket.[]RelayedCandidateDatagramSocket(RelayedCandidate,TurnCandidateHarvest)", "name": "RelayedCandidateDatagramSocket", "arg_nums": 2, "params": [{"name": "relayedCandidate", "type": "RelayedCandidate"}, {"name": "turnCandidateHarvest", "type": "TurnCandidateHarvest"}], "return_type": "", "signature": "public RelayedCandidateDatagramSocket(\n            RelayedCandidate relayedCandidate,\n            TurnCandidateHarvest turnCandidateHarvest)", "original_string": "    public RelayedCandidateDatagramSocket(\n            RelayedCandidate relayedCandidate,\n            TurnCandidateHarvest turnCandidateHarvest)\n        throws SocketException\n    {\n        super(/* bindaddr */ (SocketAddress) null);\n\n        this.relayedCandidate = relayedCandidate;\n        this.turnCandidateHarvest = turnCandidateHarvest;\n\n        this.turnCandidateHarvest\n                .harvester\n                    .getStunStack()\n                        .addIndicationListener(\n                                this.turnCandidateHarvest.hostCandidate\n                                        .getTransportAddress(),\n                                this);\n\n        DatagramSocket hostSocket\n            = this.turnCandidateHarvest.hostCandidate\n                    .getCandidateIceSocketWrapper().getUDPSocket();\n\n        if (hostSocket instanceof MultiplexingDatagramSocket)\n        {\n            channelDataSocket\n                = ((MultiplexingDatagramSocket) hostSocket).getSocket(\n                        new TurnDatagramPacketFilter(\n                                this.turnCandidateHarvest.harvester.stunServer)\n                        {\n                            @Override\n                            public boolean accept(DatagramPacket p)\n                            {\n                                return channelDataSocketAccept(p);\n                            }\n\n                            @Override\n                            protected boolean acceptMethod(char method)\n                            {\n                                return channelDataSocketAcceptMethod(method);\n                            }\n                        });\n        }\n        else\n            channelDataSocket = null;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java", "class_name": "RelayedCandidateDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java.RelayedCandidateDatagramSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>RelayedCandidateDatagramSocket</tt> instance which\nis to be the <tt>socket</tt> of a specific <tt>RelayedCandidate</tt>\nharvested by a specific <tt>TurnCandidateHarvest</tt>.\n\n@param relayedCandidate the <tt>RelayedCandidate</tt> which is to use the\nnew instance as the value of its <tt>socket</tt> property\n@param turnCandidateHarvest the <tt>TurnCandidateHarvest</tt> which has\nharvested <tt>relayedCandidate</tt>\n@throws SocketException if anything goes wrong while initializing the new\n<tt>RelayedCandidateDatagramSocket</tt> instance\n"}, {"uris": "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java.RelayedCandidateDatagramSocket.[boolean]channelDataSocketAccept(DatagramPacket)", "name": "channelDataSocketAccept", "arg_nums": 1, "params": [{"name": "p", "type": "DatagramPacket"}], "return_type": "boolean", "signature": "private boolean channelDataSocketAccept(DatagramPacket p)", "original_string": "    private boolean channelDataSocketAccept(DatagramPacket p)\n    {\n        // Is it from our TURN server?\n        if (turnCandidateHarvest.harvester.stunServer.equals(\n                p.getSocketAddress()))\n        {\n            int pLength = p.getLength();\n\n            if (pLength\n                    >= (CHANNELDATA_CHANNELNUMBER_LENGTH\n                            + CHANNELDATA_LENGTH_LENGTH))\n            {\n                byte[] pData = p.getData();\n                int pOffset = p.getOffset();\n\n                /*\n                 * The first two bits should be 0b01 because of the current\n                 * channel number range 0x4000 - 0x7FFE. But 0b10 and 0b11 which\n                 * are currently reserved and may be used in the future to\n                 * extend the range of channel numbers.\n                 */\n                if ((pData[pOffset] & 0xC0) != 0)\n                {\n                    /*\n                     * Technically, we cannot create a DatagramPacket from a\n                     * ChannelData message with a Channel Number we do not know\n                     * about. But determining that we know the value of the\n                     * Channel Number field may be too much of an unnecessary\n                     * performance penalty and it may be unnecessary because the\n                     * message comes from our TURN server and it looks like a\n                     * ChannelData message already.\n                     */\n                    pOffset += CHANNELDATA_CHANNELNUMBER_LENGTH;\n                    pLength -= CHANNELDATA_CHANNELNUMBER_LENGTH;\n\n                    int length\n                        = ((pData[pOffset++] << 8)\n                              | (pData[pOffset++] & 0xFF));\n\n                    int padding = ((length % 4) > 0) ? 4 - (length % 4) : 0;\n\n                    /*\n                     * The Length field specifies the length in bytes of the\n                     * Application Data field. The Length field does not include\n                     * the padding that is sometimes present in the data of the\n                     * DatagramPacket.\n                     */\n                    return length == pLength - padding - CHANNELDATA_LENGTH_LENGTH \n                        || length == pLength - CHANNELDATA_LENGTH_LENGTH;\n                }\n            }\n        }\n        return false;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java", "class_name": "RelayedCandidateDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java.RelayedCandidateDatagramSocket", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nDetermines whether a specific <tt>DatagramPacket</tt> is accepted by\n{@link #channelDataSocket} (i.e. whether <tt>channelDataSocket</tt>\nunderstands <tt>p</tt> and <tt>p</tt> is meant to be received by\n<tt>channelDataSocket</tt>).\n\n@param p the <tt>DatagramPacket</tt> which is to be checked whether it is\naccepted by <tt>channelDataSocket</tt>\n@return <tt>true</tt> if <tt>channelDataSocket</tt> accepts <tt>p</tt>\n(i.e. <tt>channelDataSocket</tt> understands <tt>p</tt> and <tt>p</tt> is\nmeant to be received by <tt>channelDataSocket</tt>); otherwise,\n<tt>false</tt>\n"}, {"uris": "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java.RelayedCandidateDatagramSocket.[boolean]channelDataSocketAcceptMethod(char)", "name": "channelDataSocketAcceptMethod", "arg_nums": 1, "params": [{"name": "method", "type": "char"}], "return_type": "boolean", "signature": "private boolean channelDataSocketAcceptMethod(char method)", "original_string": "    private boolean channelDataSocketAcceptMethod(char method)\n    {\n        /*\n         * Accept only ChannelData messages for now. ChannelData messages are\n         * not STUN messages so they do not have a method associated with them.\n         */\n        return false;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java", "class_name": "RelayedCandidateDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java.RelayedCandidateDatagramSocket", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nDetermines whether {@link #channelDataSocket} accepts\n<tt>DatagramPacket</tt>s which represent STUN messages with a specific\nmethod.\n\n@param method the method of the STUN messages represented in\n<tt>DatagramPacket</tt>s which is accepted by <tt>channelDataSocket</tt>\n@return <tt>true</tt> if <tt>channelDataSocket</tt> accepts\n<tt>DatagramPacket</tt>s which represent STUN messages with the specified\n<tt>method</tt>; otherwise, <tt>false</tt>\n"}, {"uris": "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java.RelayedCandidateDatagramSocket.[void]close()", "name": "close", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Override\n    public void close()", "original_string": "    @Override\n    public void close()\n    {\n        synchronized (this)\n        {\n            if (this.closed)\n                return;\n            else\n                this.closed = true;\n        }\n        synchronized (packetsToReceive)\n        {\n            packetsToReceive.notifyAll();\n        }\n        synchronized (packetsToSend)\n        {\n            packetsToSend.notifyAll();\n        }\n        turnCandidateHarvest.harvester.getStunStack().removeIndicationListener(\n                turnCandidateHarvest.hostCandidate.getTransportAddress(),\n                this);\n        turnCandidateHarvest.close(this);\n\n        super.close();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java", "class_name": "RelayedCandidateDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java.RelayedCandidateDatagramSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCloses this datagram socket.\n\n@see DatagramSocket#close()\n"}, {"uris": "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java.RelayedCandidateDatagramSocket.[void]createReceiveChannelDataThread()", "name": "createReceiveChannelDataThread", "arg_nums": 0, "params": [], "return_type": "void", "signature": "private void createReceiveChannelDataThread()", "original_string": "    private void createReceiveChannelDataThread()\n    {\n        receiveChannelDataThread\n            = new Thread()\n            {\n                @Override\n                public void run()\n                {\n                    boolean done = false;\n\n                    try\n                    {\n                        runInReceiveChannelDataThread();\n                        done = true;\n                    }\n                    catch (SocketException sex)\n                    {\n                        done = true;\n                    }\n                    finally\n                    {\n                        /*\n                         * If receiveChannelDataThread is dying and this\n                         * RelayedCandidateDatagramSocket is not closed, then\n                         * spawn a new receiveChannelDataThread.\n                         */\n                        synchronized (packetsToReceive)\n                        {\n                            if (receiveChannelDataThread\n                                    == Thread.currentThread())\n                                receiveChannelDataThread = null;\n                            if ((receiveChannelDataThread == null)\n                                    && !closed\n                                    && !done)\n                                createReceiveChannelDataThread();\n                        }\n                    }\n                }\n            };\n        receiveChannelDataThread.start();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java", "class_name": "RelayedCandidateDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java.RelayedCandidateDatagramSocket", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCreates {@link #receiveChannelDataThread} which is to receive\n<tt>DatagramPacket</tt>s from {@link #channelDataSocket} and queue them\nin {@link #packetsToReceive}.\n"}, {"uris": "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java.RelayedCandidateDatagramSocket.[void]createSendThread()", "name": "createSendThread", "arg_nums": 0, "params": [], "return_type": "void", "signature": "private void createSendThread()", "original_string": "    private void createSendThread()\n    {\n        sendThread\n            = new Thread()\n            {\n                @Override\n                public void run()\n                {\n                    try\n                    {\n                        runInSendThread();\n                    }\n                    finally\n                    {\n                        /*\n                         * If sendThread is dying and there are packetsToSend,\n                         * then spawn a new sendThread.\n                         */\n                        synchronized (packetsToSend)\n                        {\n                            if (sendThread == Thread.currentThread())\n                                sendThread = null;\n                            if ((sendThread == null)\n                                    && !closed\n                                    && !packetsToSend.isEmpty())\n                                createSendThread();\n                        }\n                    }\n                }\n            };\n        sendThread.start();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java", "class_name": "RelayedCandidateDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java.RelayedCandidateDatagramSocket", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCreates {@link #sendThread} which is to send {@link #packetsToSend} to\nthe associated TURN server.\n"}, {"uris": "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java.RelayedCandidateDatagramSocket.[InetAddress]getLocalAddress()", "name": "getLocalAddress", "arg_nums": 0, "params": [], "return_type": "InetAddress", "signature": "@Override\n    public InetAddress getLocalAddress()", "original_string": "    @Override\n    public InetAddress getLocalAddress()\n    {\n        return getLocalSocketAddress().getAddress();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java", "class_name": "RelayedCandidateDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java.RelayedCandidateDatagramSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "InetAddress", "classes": []}, "docstring": "\nGets the local address to which the socket is bound.\n<tt>RelayedCandidateDatagramSocket</tt> returns the <tt>address</tt> of\nits <tt>localSocketAddress</tt>.\n<p>\nIf there is a security manager, its <tt>checkConnect</tt> method is first\ncalled with the host address and <tt>-1</tt> as its arguments to see if\nthe operation is allowed.\n</p>\n\n@return the local address to which the socket is bound, or an\n<tt>InetAddress</tt> representing any local address if either the socket\nis not bound, or the security manager <tt>checkConnect</tt> method does\nnot allow the operation\n@see #getLocalSocketAddress()\n@see DatagramSocket#getLocalAddress()\n"}, {"uris": "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java.RelayedCandidateDatagramSocket.[int]getLocalPort()", "name": "getLocalPort", "arg_nums": 0, "params": [], "return_type": "int", "signature": "@Override\n    public int getLocalPort()", "original_string": "    @Override\n    public int getLocalPort()\n    {\n        return getLocalSocketAddress().getPort();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java", "class_name": "RelayedCandidateDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java.RelayedCandidateDatagramSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\nReturns the port number on the local host to which this socket is bound.\n<tt>RelayedCandidateDatagramSocket</tt> returns the <tt>port</tt> of its\n<tt>localSocketAddress</tt>.\n\n@return the port number on the local host to which this socket is bound\n@see #getLocalSocketAddress()\n@see DatagramSocket#getLocalPort()\n"}, {"uris": "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java.RelayedCandidateDatagramSocket.[InetSocketAddress]getLocalSocketAddress()", "name": "getLocalSocketAddress", "arg_nums": 0, "params": [], "return_type": "InetSocketAddress", "signature": "@Override\n    public InetSocketAddress getLocalSocketAddress()", "original_string": "    @Override\n    public InetSocketAddress getLocalSocketAddress()\n    {\n        return getRelayedCandidate().getTransportAddress();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java", "class_name": "RelayedCandidateDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java.RelayedCandidateDatagramSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "InetSocketAddress", "classes": []}, "docstring": "\nReturns the address of the endpoint this socket is bound to, or\n<tt>null</tt> if it is not bound yet. Since\n<tt>RelayedCandidateDatagramSocket</tt> represents an\napplication-purposed <tt>DatagramSocket</tt> relaying data to and from a\nTURN server, the <tt>localSocketAddress</tt> is the\n<tt>transportAddress</tt> of the respective <tt>RelayedCandidate</tt>.\n\n@return a <tt>SocketAddress</tt> representing the local endpoint of this\nsocket, or <tt>null</tt> if it is not bound yet\n@see DatagramSocket#getLocalSocketAddress()\n"}, {"uris": "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java.RelayedCandidateDatagramSocket.[char]getNextChannelNumber()", "name": "getNextChannelNumber", "arg_nums": 0, "params": [], "return_type": "char", "signature": "private char getNextChannelNumber()", "original_string": "    private char getNextChannelNumber()\n    {\n        char nextChannelNumber;\n\n        if (this.nextChannelNumber > MAX_CHANNEL_NUMBER)\n            nextChannelNumber = CHANNEL_NUMBER_NOT_SPECIFIED;\n        else\n        {\n            nextChannelNumber = this.nextChannelNumber;\n            this.nextChannelNumber++;\n        }\n        return nextChannelNumber;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java", "class_name": "RelayedCandidateDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java.RelayedCandidateDatagramSocket", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "char", "classes": []}, "docstring": "\nGets the next free channel number to be allocated to a <tt>Channel</tt>\nand marked as non-free.\n\n@return the next free channel number to be allocated to a\n<tt>Channel</tt> and marked as non-free.\n"}, {"uris": "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java.RelayedCandidateDatagramSocket.[RelayedCandidate]getRelayedCandidate()", "name": "getRelayedCandidate", "arg_nums": 0, "params": [], "return_type": "RelayedCandidate", "signature": "public final RelayedCandidate getRelayedCandidate()", "original_string": "    public final RelayedCandidate getRelayedCandidate()\n    {\n        return relayedCandidate;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java", "class_name": "RelayedCandidateDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java.RelayedCandidateDatagramSocket", "attributes": {"modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "return_type": "RelayedCandidate", "classes": []}, "docstring": "\nGets the <tt>RelayedCandidate</tt> which uses this instance as the value\nof its <tt>socket</tt> property.\n\n@return the <tt>RelayedCandidate</tt> which uses this instance as the\nvalue of its <tt>socket</tt> property\n"}, {"uris": "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java.RelayedCandidateDatagramSocket.[void]handleMessageEvent(StunMessageEvent)", "name": "handleMessageEvent", "arg_nums": 1, "params": [{"name": "e", "type": "StunMessageEvent"}], "return_type": "void", "signature": "public void handleMessageEvent(StunMessageEvent e)", "original_string": "    public void handleMessageEvent(StunMessageEvent e)\n    {\n        /*\n         * Is it meant for us? (It should be because\n         * RelayedCandidateDatagramSocket registers for STUN indications\n         * received at the associated local TransportAddress only.)\n         */\n        if (!turnCandidateHarvest.hostCandidate.getTransportAddress().equals(\n                e.getLocalAddress()))\n            return;\n        // Is it from our TURN server?\n        if (!turnCandidateHarvest.harvester.stunServer.equals(\n                e.getRemoteAddress()))\n            return;\n\n        Message message = e.getMessage();\n        char messageType = message.getMessageType();\n\n        if (messageType != Message.DATA_INDICATION)\n            return;\n\n        /*\n         * RFC 5766: When the client receives a Data indication, it checks that\n         * the Data indication contains both an XOR-PEER-ADDRESS and a DATA\n         * attribute, and discards the indication if it does not.\n         */\n        XorPeerAddressAttribute peerAddressAttribute\n            = (XorPeerAddressAttribute)\n                message.getAttribute(Attribute.XOR_PEER_ADDRESS);\n\n        if (peerAddressAttribute == null)\n            return;\n\n        DataAttribute dataAttribute\n            = (DataAttribute) message.getAttribute(Attribute.DATA);\n\n        if (dataAttribute == null)\n            return;\n\n        TransportAddress peerAddress\n            = peerAddressAttribute.getAddress(message.getTransactionID());\n\n        if (peerAddress == null)\n            return;\n\n        byte[] data = dataAttribute.getData();\n\n        if (data == null)\n            return;\n\n        DatagramPacket packetToReceive;\n\n        try\n        {\n            packetToReceive\n                = new DatagramPacket(data, 0, data.length, peerAddress);\n        }\n        catch (Throwable t)\n        {\n            /*\n             * The signature of the DatagramPacket constructor was changed\n             * in JDK 8 to not declare that it may throw a SocketException.\n             */\n            if (t instanceof SocketException)\n            {\n                packetToReceive = null;\n            }\n            else if (t instanceof Error)\n            {\n                throw (Error) t;\n            }\n            else if (t instanceof RuntimeException)\n            {\n                throw (RuntimeException) t;\n            }\n            else\n            {\n                /*\n                 * Unfortunately, we cannot re-throw it. Anyway, it was\n                 * unlikely to occur on JDK 7.\n                 */\n                if (t instanceof InterruptedException)\n                {\n                    Thread.currentThread().interrupt();\n                }\n                packetToReceive = null;\n            }\n        }\n        if (packetToReceive != null)\n        {\n            synchronized (packetsToReceive)\n            {\n                packetsToReceive.add(packetToReceive);\n                packetsToReceive.notifyAll();\n            }\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java", "class_name": "RelayedCandidateDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java.RelayedCandidateDatagramSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nNotifies this <tt>MessageEventHandler</tt> that a specific STUN message\nhas been received, parsed and is ready for delivery.\n<tt>RelayedCandidateDatagramSocket</tt> handles STUN indications sent\nfrom the associated TURN server and received at the associated local\n<tt>TransportAddress</tt>.\n\n@param e a <tt>StunMessageEvent</tt> which encapsulates the received STUN\nmessage\n"}, {"uris": "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java.RelayedCandidateDatagramSocket.[boolean]processErrorOrFailure(Response,Request)", "name": "processErrorOrFailure", "arg_nums": 2, "params": [{"name": "response", "type": "Response"}, {"name": "request", "type": "Request"}], "return_type": "boolean", "signature": "public boolean processErrorOrFailure(Response response, Request request)", "original_string": "    public boolean processErrorOrFailure(Response response, Request request)\n    {\n        switch (request.getMessageType())\n        {\n        case Message.CHANNELBIND_REQUEST:\n            setChannelNumberIsConfirmed(request, false);\n            break;\n        case Message.CREATEPERMISSION_REQUEST:\n            setChannelBound(request, false);\n            break;\n        default:\n            break;\n        }\n        return false;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java", "class_name": "RelayedCandidateDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java.RelayedCandidateDatagramSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nNotifies this <tt>RelayedCandidateDatagramSocket</tt> that a specific\n<tt>Request</tt> it has sent has either failed or received a STUN error\n<tt>Response</tt>.\n\n@param response the <tt>Response</tt> which responds to <tt>request</tt>\n@param request the <tt>Request</tt> sent by this instance to which\n<tt>response</tt> responds\n@return <tt>true</tt> if the failure or error condition has been handled\nand the caller should assume this instance has recovered from it;\notherwise, <tt>false</tt>\n"}, {"uris": "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java.RelayedCandidateDatagramSocket.[void]processSuccess(Response,Request)", "name": "processSuccess", "arg_nums": 2, "params": [{"name": "response", "type": "Response"}, {"name": "request", "type": "Request"}], "return_type": "void", "signature": "public void processSuccess(Response response, Request request)", "original_string": "    public void processSuccess(Response response, Request request)\n    {\n        switch (request.getMessageType())\n        {\n        case Message.CHANNELBIND_REQUEST:\n            setChannelNumberIsConfirmed(request, true);\n            break;\n        case Message.CREATEPERMISSION_REQUEST:\n            setChannelBound(request, true);\n            break;\n        default:\n            break;\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java", "class_name": "RelayedCandidateDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java.RelayedCandidateDatagramSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nNotifies this <tt>RelayedCandidateDatagramSocket</tt> that a specific\n<tt>Request</tt> it has sent has received a STUN success\n<tt>Response</tt>.\n\n@param response the <tt>Response</tt> which responds to <tt>request</tt>\n@param request the <tt>Request</tt> sent by this instance to which\n<tt>response</tt> responds\n"}, {"uris": "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java.RelayedCandidateDatagramSocket.[void]receive(DatagramPacket)", "name": "receive", "arg_nums": 1, "params": [{"name": "p", "type": "DatagramPacket"}], "return_type": "void", "signature": "@Override\n    public void receive(DatagramPacket p)", "original_string": "    @Override\n    public void receive(DatagramPacket p)\n        throws IOException\n    {\n        synchronized (packetsToReceive)\n        {\n            do\n            {\n                /*\n                 * According to the javadoc of DatagramSocket#close(), any\n                 * thread currently blocked in #receive(DatagramPacket) upon\n                 * this socket will throw a SocketException.\n                 */\n                if (closed)\n                {\n                    throw\n                        new SocketException(\n                                RelayedCandidateDatagramSocket.class\n                                        .getSimpleName()\n                                    + \" has been closed.\");\n                }\n                else if (packetsToReceive.isEmpty())\n                {\n                    try\n                    {\n                        packetsToReceive.wait();\n                    }\n                    catch (InterruptedException iex)\n                    {\n                    }\n                }\n                else\n                {\n                    DatagramPacket packetToReceive = packetsToReceive.remove(0);\n\n                    MultiplexingXXXSocketSupport.copy(packetToReceive, p);\n                    packetsToReceive.notifyAll();\n                    break;\n                }\n            }\n            while (true);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java", "class_name": "RelayedCandidateDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java.RelayedCandidateDatagramSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nReceives a datagram packet from this socket. When this method returns,\nthe <tt>DatagramPacket</tt>'s buffer is filled with the data received.\nThe datagram packet also contains the sender's IP address, and the port\nnumber on the sender's machine.\n\n@param p the <tt>DatagramPacket</tt> into which to place the incoming\ndata\n@throws IOException if an I/O error occurs\n@see DatagramSocket#receive(DatagramPacket)\n"}, {"uris": "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java.RelayedCandidateDatagramSocket.[void]runInReceiveChannelDataThread()", "name": "runInReceiveChannelDataThread", "arg_nums": 0, "params": [], "return_type": "void", "signature": "private void runInReceiveChannelDataThread()", "original_string": "    private void runInReceiveChannelDataThread()\n        throws SocketException\n    {\n        DatagramPacket p = null;\n\n        while (!closed)\n        {\n            // read one datagram a time\n            int receiveBufferSize = 1500;\n\n            if (p == null)\n            {\n                p\n                    = new DatagramPacket(\n                            new byte[receiveBufferSize],\n                            receiveBufferSize);\n            }\n            else\n            {\n                byte[] pData = p.getData();\n\n                if ((pData == null) || (pData.length < receiveBufferSize))\n                    p.setData(new byte[receiveBufferSize]);\n                else\n                    p.setLength(receiveBufferSize);\n            }\n\n            try\n            {\n                channelDataSocket.receive(p);\n            }\n            catch (Throwable t)\n            {\n                if (t instanceof ThreadDeath)\n                {\n                    // Death is the end of life no matter what.\n                    throw (ThreadDeath) t;\n                }\n                else if (t instanceof SocketException)\n                {\n                    /*\n                     * If the channelDataSocket has gone unusable, put an end to\n                     * receiving from it.\n                     */\n                    throw (SocketException) t;\n                }\n                else\n                {\n                    if (logger.isLoggable(Level.WARNING))\n                    {\n                        logger.log(\n                                Level.WARNING,\n                                \"Ignoring error while receiving from\"\n                                    + \" ChannelData socket\",\n                                t);\n                    }\n                    continue;\n                }\n            }\n\n            /*\n             * We've been waiting in #receive so make sure we're still to\n             * continue just in case.\n             */\n            if (closed)\n                break;\n\n            int channelDataLength = p.getLength();\n\n            if (channelDataLength\n                    < (CHANNELDATA_CHANNELNUMBER_LENGTH\n                            + CHANNELDATA_LENGTH_LENGTH))\n                continue;\n\n            byte[] channelData = p.getData();\n            int channelDataOffset = p.getOffset();\n            char channelNumber\n                = (char)\n                    ((channelData[channelDataOffset++] << 8)\n                            | (channelData[channelDataOffset++] & 0xFF));\n\n            channelDataLength -= CHANNELDATA_CHANNELNUMBER_LENGTH;\n\n            char length\n                = (char)\n                    ((channelData[channelDataOffset++] << 8)\n                            | (channelData[channelDataOffset++] & 0xFF));\n\n            channelDataLength -= CHANNELDATA_LENGTH_LENGTH;\n            if (length > channelDataLength)\n                continue;\n\n            TransportAddress peerAddress = null;\n\n            synchronized (packetsToSend)\n            {\n                int channelCount = channels.size();\n\n                for (int channelIndex = 0;\n                        channelIndex < channelCount;\n                        channelIndex++)\n                {\n                    Channel channel = channels.get(channelIndex);\n\n                    if (channel.channelNumberEquals(channelNumber))\n                    {\n                        peerAddress = channel.peerAddress;\n                        break;\n                    }\n                }\n            }\n            if (peerAddress == null)\n                continue;\n\n            byte[] data = new byte[length];\n\n            System.arraycopy(channelData, channelDataOffset, data, 0, length);\n\n            DatagramPacket packetToReceive\n                = new DatagramPacket(data, 0, length, peerAddress);\n\n            synchronized (packetsToReceive)\n            {\n                packetsToReceive.add(packetToReceive);\n                packetsToReceive.notifyAll();\n            }\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java", "class_name": "RelayedCandidateDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java.RelayedCandidateDatagramSocket", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nRuns in {@link #receiveChannelDataThread} to receive\n<tt>DatagramPacket</tt>s from {@link #channelDataSocket} and queue them\nin {@link #packetsToReceive}.\n\n@throws SocketException if anything goes wrong while receiving\n<tt>DatagramPacket</tt>s from {@link #channelDataSocket} and\n{@link #receiveChannelDataThread} is to no longer exist\n"}, {"uris": "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java.RelayedCandidateDatagramSocket.[void]runInSendThread()", "name": "runInSendThread", "arg_nums": 0, "params": [], "return_type": "void", "signature": "private void runInSendThread()", "original_string": "    private void runInSendThread()\n    {\n        synchronized (packetsToSend)\n        {\n            while (!closed)\n            {\n                if (packetsToSend.isEmpty())\n                {\n                    try\n                    {\n                        packetsToSend.wait();\n                    }\n                    catch (InterruptedException iex)\n                    {\n                    }\n                    continue;\n                }\n\n                int packetToSendCount = packetsToSend.size();\n\n                for (int packetToSendIndex = 0;\n                        packetToSendIndex < packetToSendCount;\n                        packetToSendIndex++)\n                {\n                    DatagramPacket packetToSend\n                        = packetsToSend.get(packetToSendIndex);\n\n                    /*\n                     * Get a channel to the peer which is to receive the\n                     * packetToSend.\n                     */\n                    int channelCount = channels.size();\n                    TransportAddress peerAddress\n                        = new TransportAddress(\n                                packetToSend.getAddress(),\n                                packetToSend.getPort(),\n                                Transport.UDP);\n                    Channel channel = null;\n\n                    for (int channelIndex = 0;\n                            channelIndex < channelCount;\n                            channelIndex++)\n                    {\n                        Channel aChannel = channels.get(channelIndex);\n\n                        if (aChannel.peerAddressEquals(peerAddress))\n                        {\n                            channel = aChannel;\n                            break;\n                        }\n                    }\n                    if (channel == null)\n                    {\n                        channel = new Channel(peerAddress);\n                        channels.add(channel);\n                    }\n\n                    /*\n                     * RFC 5245 says that \"it is RECOMMENDED that the agent\n                     * defer creation of a TURN channel until ICE completes.\"\n                     * RelayedCandidateDatagramSocket is not explicitly told\n                     * from the outside that ICE has completed so it tries to\n                     * determine it by assuming that connectivity checks send\n                     * only STUN messages and ICE has completed by the time a\n                     * non-STUN message is to be sent.\n                     */\n                    boolean forceBind = false;\n\n                    if ((channelDataSocket != null)\n                            && !channel.getChannelDataIsPreferred()\n                            && !connectivityCheckRecognizer.accept(\n                                    packetToSend))\n                    {\n                        channel.setChannelDataIsPreferred(true);\n                        forceBind = true;\n                    }\n\n                    /*\n                     * Either bind the channel or send the packetToSend through\n                     * it.\n                     */\n                    if (!forceBind && channel.isBound())\n                    {\n                        packetsToSend.remove(packetToSendIndex);\n                        try\n                        {\n                            channel.send(packetToSend, peerAddress);\n                        }\n                        catch (StunException sex)\n                        {\n                            if (logger.isLoggable(Level.INFO))\n                            {\n                                logger.log(\n                                        Level.INFO,\n                                        \"Failed to send through \"\n                                            + RelayedCandidateDatagramSocket\n                                                    .class.getSimpleName()\n                                            + \" channel.\" ,\n                                        sex);\n                            }\n                        }\n                        break;\n                    }\n                    else if (forceBind || !channel.isBinding())\n                    {\n                        try\n                        {\n                            channel.bind();\n                        }\n                        catch (StunException sex)\n                        {\n                            if (logger.isLoggable(Level.INFO))\n                            {\n                                logger.log(\n                                        Level.INFO,\n                                        \"Failed to bind \"\n                                            + RelayedCandidateDatagramSocket\n                                                    .class.getSimpleName()\n                                            + \" channel.\" ,\n                                        sex);\n                            }\n                            /*\n                             * Well, it may not be the fault of the packetToSend\n                             * but it happened while we were trying to send it\n                             * and we don't have a way to report an error so\n                             * just drop packetToSend in order to change\n                             * something and not just go again trying the same\n                             * thing.\n                             */\n                            packetsToSend.remove(packetToSendIndex);\n                            break;\n                        }\n                        /*\n                         * If the Channel was bound but #bind() was forced on\n                         * it, we cannot continue with the next packetToSend\n                         * because it may be for the same Channel and then\n                         * #bind() will not be forced and the Channel will be\n                         * bound already so the send order of the packetsToSend\n                         * will be disrupted.\n                         */\n                        if (forceBind)\n                            break;\n                    }\n                }\n\n                /*\n                 * If no packetToSend has been sent by the current iteration,\n                 * then we must be waiting for some condition to change in order\n                 * to be able to send.\n                 */\n                if (packetsToSend.size() == packetToSendCount)\n                {\n                    try\n                    {\n                        packetsToSend.wait();\n                    }\n                    catch (InterruptedException iex)\n                    {\n                    }\n                }\n            }\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java", "class_name": "RelayedCandidateDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java.RelayedCandidateDatagramSocket", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nRuns in {@link #sendThread} to send {@link #packetsToSend} to the\nassociated TURN server.\n"}, {"uris": "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java.RelayedCandidateDatagramSocket.[void]send(DatagramPacket)", "name": "send", "arg_nums": 1, "params": [{"name": "p", "type": "DatagramPacket"}], "return_type": "void", "signature": "@Override\n    public void send(DatagramPacket p)", "original_string": "    @Override\n    public void send(DatagramPacket p)\n        throws IOException\n    {\n        synchronized (packetsToSend)\n        {\n            if (closed)\n            {\n                throw\n                    new IOException(\n                            RelayedCandidateDatagramSocket.class.getSimpleName()\n                                + \" has been closed.\");\n            }\n            else\n            {\n                packetsToSend.add(MultiplexingXXXSocketSupport.clone(p));\n                if (sendThread == null)\n                    createSendThread();\n                else\n                    packetsToSend.notifyAll();\n            }\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java", "class_name": "RelayedCandidateDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java.RelayedCandidateDatagramSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSends a datagram packet from this socket. The <tt>DatagramPacket</tt>\nincludes information indicating the data to be sent, its length, the IP\naddress of the remote host, and the port number on the remote host.\n\n@param p the <tt>DatagramPacket</tt> to be sent\n@throws IOException if an I/O error occurs\n@see DatagramSocket#send(DatagramPacket)\n"}, {"uris": "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java.RelayedCandidateDatagramSocket.[void]setChannelBound(Request,boolean)", "name": "setChannelBound", "arg_nums": 2, "params": [{"name": "request", "type": "Request"}, {"name": "bound", "type": "boolean"}], "return_type": "void", "signature": "private void setChannelBound(Request request, boolean bound)", "original_string": "    private void setChannelBound(Request request, boolean bound)\n    {\n        XorPeerAddressAttribute peerAddressAttribute\n            = (XorPeerAddressAttribute)\n                request.getAttribute(Attribute.XOR_PEER_ADDRESS);\n        byte[] transactionID = request.getTransactionID();\n        TransportAddress peerAddress\n            = peerAddressAttribute.getAddress(transactionID);\n\n        synchronized (packetsToSend)\n        {\n            int channelCount = channels.size();\n\n            for (int channelIndex = 0;\n                    channelIndex < channelCount;\n                    channelIndex++)\n            {\n                Channel channel = channels.get(channelIndex);\n\n                if (channel.peerAddressEquals(peerAddress))\n                {\n                    channel.setBound(bound, transactionID);\n                    packetsToSend.notifyAll();\n                    break;\n                }\n            }\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java", "class_name": "RelayedCandidateDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java.RelayedCandidateDatagramSocket", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets the <tt>bound</tt> property of a <tt>Channel</tt> the installation\nof which has been attempted by sending a specific <tt>Request</tt>.\n\n@param request the <tt>Request</tt> which has been attempted in order to\ninstall a <tt>Channel</tt>\n@param bound <tt>true</tt> if the <tt>bound</tt> property of the\n<tt>Channel</tt> is to be set to <tt>true</tt>; otherwise, <tt>false</tt>\n"}, {"uris": "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java.RelayedCandidateDatagramSocket.[void]setChannelNumberIsConfirmed(Request,boolean)", "name": "setChannelNumberIsConfirmed", "arg_nums": 2, "params": [{"name": "request", "type": "Request"}, {"name": "channelNumberIsConfirmed", "type": "boolean"}], "return_type": "void", "signature": "private void setChannelNumberIsConfirmed(\n            Request request,\n            boolean channelNumberIsConfirmed)", "original_string": "    private void setChannelNumberIsConfirmed(\n            Request request,\n            boolean channelNumberIsConfirmed)\n    {\n        XorPeerAddressAttribute peerAddressAttribute\n            = (XorPeerAddressAttribute)\n                request.getAttribute(Attribute.XOR_PEER_ADDRESS);\n        byte[] transactionID = request.getTransactionID();\n        TransportAddress peerAddress\n            = peerAddressAttribute.getAddress(transactionID);\n\n        synchronized (packetsToSend)\n        {\n            int channelCount = channels.size();\n\n            for (int channelIndex = 0;\n                    channelIndex < channelCount;\n                    channelIndex++)\n            {\n                Channel channel = channels.get(channelIndex);\n\n                if (channel.peerAddressEquals(peerAddress))\n                {\n                    channel.setChannelNumberIsConfirmed(\n                            channelNumberIsConfirmed,\n                            transactionID);\n                    packetsToSend.notifyAll();\n                    break;\n                }\n            }\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java", "class_name": "RelayedCandidateDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java.RelayedCandidateDatagramSocket", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets the <tt>channelNumberIsConfirmed</tt> property of a <tt>Channel</tt>\nwhich has attempted to allocate a specific channel number by sending a\nspecific ChannelBind <tt>Request</tt>.\n\n@param request the <tt>Request</tt> which has been sent to allocate a\nspecific channel number for a <tt>Channel</tt>\n@param channelNumberIsConfirmed <tt>true</tt> if the channel number has\nbeen successfully allocated; otherwise, <tt>false</tt>\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingServerSocket.java.DelegatingServerSocket.[]DelegatingServerSocket(ServerSocket)", "name": "DelegatingServerSocket", "arg_nums": 1, "params": [{"name": "delegate", "type": "ServerSocket"}], "return_type": "", "signature": "public DelegatingServerSocket(ServerSocket delegate)", "original_string": "    public DelegatingServerSocket(ServerSocket delegate)\n        throws IOException\n    {\n        this(delegate, delegate.getChannel());\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingServerSocket.java", "class_name": "DelegatingServerSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingServerSocket.java.DelegatingServerSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new {@code DelegatingServerSocket} instance which is to\ndelegate (its method calls) to a specific {@link ServerSocket}.\n\n@param delegate the {@code ServerSocket} the new instance is to delegate\n(it method calls) to\n@throws IOException never thrown\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingServerSocket.java.DelegatingServerSocket.[]DelegatingServerSocket(ServerSocket,ServerSocketChannel)", "name": "DelegatingServerSocket", "arg_nums": 2, "params": [{"name": "delegate", "type": "ServerSocket"}, {"name": "channel", "type": "ServerSocketChannel"}], "return_type": "", "signature": "public DelegatingServerSocket(\n            ServerSocket delegate,\n            ServerSocketChannel channel)", "original_string": "    public DelegatingServerSocket(\n            ServerSocket delegate,\n            ServerSocketChannel channel)\n        throws IOException\n    {\n        this.delegate = delegate;\n        this.channel = channel;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingServerSocket.java", "class_name": "DelegatingServerSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingServerSocket.java.DelegatingServerSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new {@code DelegatingServerSocket} instance which is to\ndelegate (its method calls) to a specific {@link ServerSocket} and is to\nreport a specific {@link ServerSocketChannel}.\n\n@param delegate the {@code ServerSocket} the new instance is to delegate\n(it method calls) to\n@param channel the {@code ServerSocketChannel} to be reported by the new\ninstance or {@code null} to report the one of {@code delegate}\n@throws IOException never thrown\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingServerSocket.java.DelegatingServerSocket.[Socket]accept()", "name": "accept", "arg_nums": 0, "params": [], "return_type": "Socket", "signature": "@Override\n    public Socket accept()", "original_string": "    @Override\n    public Socket accept()\n        throws IOException\n    {\n        return delegate.accept();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingServerSocket.java", "class_name": "DelegatingServerSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingServerSocket.java.DelegatingServerSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Socket", "classes": []}, "docstring": "\n{@inheritDoc}\n\nForwards to {@link #delegate}.\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingServerSocket.java.DelegatingServerSocket.[void]bind(SocketAddress)", "name": "bind", "arg_nums": 1, "params": [{"name": "endpoint", "type": "SocketAddress"}], "return_type": "void", "signature": "@Override\n    public void bind(SocketAddress endpoint)", "original_string": "    @Override\n    public void bind(SocketAddress endpoint)\n        throws IOException\n    {\n        delegate.bind(endpoint);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingServerSocket.java", "class_name": "DelegatingServerSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingServerSocket.java.DelegatingServerSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\n{@inheritDoc}\n\nForwards to {@link #delegate}.\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingServerSocket.java.DelegatingServerSocket.[void]bind(SocketAddress,int)", "name": "bind", "arg_nums": 2, "params": [{"name": "endpoint", "type": "SocketAddress"}, {"name": "backlog", "type": "int"}], "return_type": "void", "signature": "@Override\n    public void bind(SocketAddress endpoint, int backlog)", "original_string": "    @Override\n    public void bind(SocketAddress endpoint, int backlog)\n        throws IOException\n    {\n        delegate.bind(endpoint, backlog);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingServerSocket.java", "class_name": "DelegatingServerSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingServerSocket.java.DelegatingServerSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\n{@inheritDoc}\n\nForwards to {@link #delegate}.\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingServerSocket.java.DelegatingServerSocket.[void]close()", "name": "close", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Override\n    public void close()", "original_string": "    @Override\n    public void close()\n        throws IOException\n    {\n        delegate.close();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingServerSocket.java", "class_name": "DelegatingServerSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingServerSocket.java.DelegatingServerSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\n{@inheritDoc}\n\nForwards to {@link #delegate}.\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingServerSocket.java.DelegatingServerSocket.[ServerSocketChannel]getChannel()", "name": "getChannel", "arg_nums": 0, "params": [], "return_type": "ServerSocketChannel", "signature": "@Override\n    public ServerSocketChannel getChannel()", "original_string": "    @Override\n    public ServerSocketChannel getChannel()\n    {\n        ServerSocketChannel channel = this.channel;\n\n        return (channel == null) ? delegate.getChannel() : channel;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingServerSocket.java", "class_name": "DelegatingServerSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingServerSocket.java.DelegatingServerSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "ServerSocketChannel", "classes": []}, "docstring": "\n{@inheritDoc}\n\nIf {@link #channel} is not {@code null}, returns it. Otherwise, forwards\nto {@link #delegate}.\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingServerSocket.java.DelegatingServerSocket.[InetAddress]getInetAddress()", "name": "getInetAddress", "arg_nums": 0, "params": [], "return_type": "InetAddress", "signature": "@Override\n    public InetAddress getInetAddress()", "original_string": "    @Override\n    public InetAddress getInetAddress()\n    {\n        return delegate.getInetAddress();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingServerSocket.java", "class_name": "DelegatingServerSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingServerSocket.java.DelegatingServerSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "InetAddress", "classes": []}, "docstring": "\n{@inheritDoc}\n\nForwards to {@link #delegate}.\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingServerSocket.java.DelegatingServerSocket.[int]getLocalPort()", "name": "getLocalPort", "arg_nums": 0, "params": [], "return_type": "int", "signature": "@Override\n    public int getLocalPort()", "original_string": "    @Override\n    public int getLocalPort()\n    {\n        return delegate.getLocalPort();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingServerSocket.java", "class_name": "DelegatingServerSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingServerSocket.java.DelegatingServerSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\n{@inheritDoc}\n\nForwards to {@link #delegate}.\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingServerSocket.java.DelegatingServerSocket.[SocketAddress]getLocalSocketAddress()", "name": "getLocalSocketAddress", "arg_nums": 0, "params": [], "return_type": "SocketAddress", "signature": "@Override\n    public SocketAddress getLocalSocketAddress()", "original_string": "    @Override\n    public SocketAddress getLocalSocketAddress()\n    {\n        return delegate.getLocalSocketAddress();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingServerSocket.java", "class_name": "DelegatingServerSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingServerSocket.java.DelegatingServerSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "SocketAddress", "classes": []}, "docstring": "\n{@inheritDoc}\n\nForwards to {@link #delegate}.\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingServerSocket.java.DelegatingServerSocket.[int]getReceiveBufferSize()", "name": "getReceiveBufferSize", "arg_nums": 0, "params": [], "return_type": "int", "signature": "@Override\n    public int getReceiveBufferSize()", "original_string": "    @Override\n    public int getReceiveBufferSize()\n        throws SocketException\n    {\n        return delegate.getReceiveBufferSize();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingServerSocket.java", "class_name": "DelegatingServerSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingServerSocket.java.DelegatingServerSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\n{@inheritDoc}\n\nForwards to {@link #delegate}.\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingServerSocket.java.DelegatingServerSocket.[boolean]getReuseAddress()", "name": "getReuseAddress", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "@Override\n    public boolean getReuseAddress()", "original_string": "    @Override\n    public boolean getReuseAddress()\n        throws SocketException\n    {\n        return delegate.getReuseAddress();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingServerSocket.java", "class_name": "DelegatingServerSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingServerSocket.java.DelegatingServerSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\n{@inheritDoc}\n\nForwards to {@link #delegate}.\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingServerSocket.java.DelegatingServerSocket.[int]getSoTimeout()", "name": "getSoTimeout", "arg_nums": 0, "params": [], "return_type": "int", "signature": "@Override\n    public int getSoTimeout()", "original_string": "    @Override\n    public int getSoTimeout()\n        throws IOException\n    {\n        return delegate.getSoTimeout();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingServerSocket.java", "class_name": "DelegatingServerSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingServerSocket.java.DelegatingServerSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\n{@inheritDoc}\n\nForwards to {@link #delegate}.\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingServerSocket.java.DelegatingServerSocket.[boolean]isBound()", "name": "isBound", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "@Override\n    public boolean isBound()", "original_string": "    @Override\n    public boolean isBound()\n    {\n        return delegate.isBound();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingServerSocket.java", "class_name": "DelegatingServerSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingServerSocket.java.DelegatingServerSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\n{@inheritDoc}\n\nForwards to {@link #delegate}.\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingServerSocket.java.DelegatingServerSocket.[boolean]isClosed()", "name": "isClosed", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "@Override\n    public boolean isClosed()", "original_string": "    @Override\n    public boolean isClosed()\n    {\n        return delegate.isClosed();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingServerSocket.java", "class_name": "DelegatingServerSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingServerSocket.java.DelegatingServerSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\n{@inheritDoc}\n\nForwards to {@link #delegate}.\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingServerSocket.java.DelegatingServerSocket.[void]setPerformancePreferences(int,int,int)", "name": "setPerformancePreferences", "arg_nums": 3, "params": [{"name": "connectionTime", "type": "int"}, {"name": "latency", "type": "int"}, {"name": "bandwidth", "type": "int"}], "return_type": "void", "signature": "@Override\n    public void setPerformancePreferences(int connectionTime,\n                                          int latency,\n                                          int bandwidth)", "original_string": "    @Override\n    public void setPerformancePreferences(int connectionTime,\n                                          int latency,\n                                          int bandwidth)\n    {\n        delegate.setPerformancePreferences(connectionTime, latency, bandwidth);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingServerSocket.java", "class_name": "DelegatingServerSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingServerSocket.java.DelegatingServerSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\n{@inheritDoc}\n\nForwards to {@link #delegate}.\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingServerSocket.java.DelegatingServerSocket.[void]setReceiveBufferSize(int)", "name": "setReceiveBufferSize", "arg_nums": 1, "params": [{"name": "size", "type": "int"}], "return_type": "void", "signature": "@Override\n    public void setReceiveBufferSize(int size)", "original_string": "    @Override\n    public void setReceiveBufferSize(int size)\n        throws SocketException\n    {\n        delegate.setReceiveBufferSize(size);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingServerSocket.java", "class_name": "DelegatingServerSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingServerSocket.java.DelegatingServerSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\n{@inheritDoc}\n\nForwards to {@link #delegate}.\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingServerSocket.java.DelegatingServerSocket.[void]setReuseAddress(boolean)", "name": "setReuseAddress", "arg_nums": 1, "params": [{"name": "on", "type": "boolean"}], "return_type": "void", "signature": "@Override\n    public void setReuseAddress(boolean on)", "original_string": "    @Override\n    public void setReuseAddress(boolean on)\n        throws SocketException\n    {\n        delegate.setReuseAddress(on);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingServerSocket.java", "class_name": "DelegatingServerSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingServerSocket.java.DelegatingServerSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\n{@inheritDoc}\n\nForwards to {@link #delegate}.\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingServerSocket.java.DelegatingServerSocket.[void]setSoTimeout(int)", "name": "setSoTimeout", "arg_nums": 1, "params": [{"name": "timeout", "type": "int"}], "return_type": "void", "signature": "@Override\n    public void setSoTimeout(int timeout)", "original_string": "    @Override\n    public void setSoTimeout(int timeout)\n        throws SocketException\n    {\n        delegate.setSoTimeout(timeout);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingServerSocket.java", "class_name": "DelegatingServerSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingServerSocket.java.DelegatingServerSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\n{@inheritDoc}\n\nForwards to {@link #delegate}.\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingServerSocket.java.DelegatingServerSocket.[String]toString()", "name": "toString", "arg_nums": 0, "params": [], "return_type": "String", "signature": "@Override\n    public String toString()", "original_string": "    @Override\n    public String toString()\n    {\n        return delegate.toString();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingServerSocket.java", "class_name": "DelegatingServerSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingServerSocket.java.DelegatingServerSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "docstring": "\n{@inheritDoc}\n\nForwards to {@link #delegate}.\n"}, {"uris": "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java.MultiplexingDatagramSocket.[]MultiplexingDatagramSocket()", "name": "MultiplexingDatagramSocket", "arg_nums": 0, "params": [], "return_type": "", "signature": "public MultiplexingDatagramSocket()", "original_string": "    public MultiplexingDatagramSocket()\n        throws SocketException\n    {\n        this(false);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java", "class_name": "MultiplexingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java.MultiplexingDatagramSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>MultiplexingDatagramSocket</tt> instance which is\nto enable <tt>DatagramPacket</tt> filtering and binds it to any available\nport on the local host machine. The socket will be bound to the wildcard\naddress, an IP address chosen by the kernel.\n\n@throws SocketException if the socket could not be opened, or the socket\ncould not bind to the specified local port\n@see DatagramSocket#DatagramSocket()\n"}, {"uris": "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java.MultiplexingDatagramSocket.[]MultiplexingDatagramSocket(boolean)", "name": "MultiplexingDatagramSocket", "arg_nums": 1, "params": [{"name": "persistent", "type": "boolean"}], "return_type": "", "signature": "public MultiplexingDatagramSocket(boolean persistent)", "original_string": "    public MultiplexingDatagramSocket(boolean persistent)\n        throws SocketException\n    {\n        this.persistent = persistent;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java", "class_name": "MultiplexingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java.MultiplexingDatagramSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>MultiplexingDatagramSocket</tt> instance which is\nto enable <tt>DatagramPacket</tt> filtering and binds it to any available\nport on the local host machine. The socket will be bound to the wildcard\naddress, an IP address chosen by the kernel.\n\n@throws SocketException if the socket could not be opened, or the socket\ncould not bind to the specified local port\n@param persistent whether this socket should be kept open after all of\nits {@link MultiplexedDatagramSocket}s are closed.\n@see DatagramSocket#DatagramSocket()\n"}, {"uris": "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java.MultiplexingDatagramSocket.[]MultiplexingDatagramSocket(DatagramSocket)", "name": "MultiplexingDatagramSocket", "arg_nums": 1, "params": [{"name": "delegate", "type": "DatagramSocket"}], "return_type": "", "signature": "public MultiplexingDatagramSocket(DatagramSocket delegate)", "original_string": "    public MultiplexingDatagramSocket(DatagramSocket delegate)\n        throws SocketException\n    {\n        this(delegate, false);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java", "class_name": "MultiplexingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java.MultiplexingDatagramSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>MultiplexingDatagramSocket</tt> instance which is\nto enable <tt>DatagramPacket</tt> filtering on a specific\n<tt>DatagramSocket</tt>.\n\n@param delegate the <tt>DatagramSocket</tt> on which\n<tt>DatagramPacket</tt> filtering is to be enabled by the new instance\n@throws SocketException if anything goes wrong while initializing the new\ninstance\n"}, {"uris": "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java.MultiplexingDatagramSocket.[]MultiplexingDatagramSocket(DatagramSocket,boolean)", "name": "MultiplexingDatagramSocket", "arg_nums": 2, "params": [{"name": "delegate", "type": "DatagramSocket"}, {"name": "persistent", "type": "boolean"}], "return_type": "", "signature": "public MultiplexingDatagramSocket(\n            DatagramSocket delegate,\n            boolean persistent)", "original_string": "    public MultiplexingDatagramSocket(\n            DatagramSocket delegate,\n            boolean persistent)\n        throws SocketException\n    {\n        super(delegate);\n\n        this.persistent = persistent;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java", "class_name": "MultiplexingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java.MultiplexingDatagramSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>MultiplexingDatagramSocket</tt> instance which is\nto enable <tt>DatagramPacket</tt> filtering on a specific\n<tt>DatagramSocket</tt>.\n\n@param delegate the <tt>DatagramSocket</tt> on which\n<tt>DatagramPacket</tt> filtering is to be enabled by the new instance\n@param persistent whether this socket should be kept open after all of\nits {@link MultiplexedDatagramSocket}s are closed.\n@throws SocketException if anything goes wrong while initializing the new\ninstance\n"}, {"uris": "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java.MultiplexingDatagramSocket.[]MultiplexingDatagramSocket(int)", "name": "MultiplexingDatagramSocket", "arg_nums": 1, "params": [{"name": "port", "type": "int"}], "return_type": "", "signature": "public MultiplexingDatagramSocket(int port)", "original_string": "    public MultiplexingDatagramSocket(int port)\n        throws SocketException\n    {\n        this(port, false);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java", "class_name": "MultiplexingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java.MultiplexingDatagramSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>MultiplexingDatagramSocket</tt> instance which is\nto enable <tt>DatagramPacket</tt> filtering and binds it to the specified\nport on the local host machine. The socket will be bound to the wildcard\naddress, an IP address chosen by the kernel.\n\n@param port the port to bind the new socket to\n@throws SocketException if the socket could not be opened, or the socket\ncould not bind to the specified local port\n@see DatagramSocket#DatagramSocket(int)\n"}, {"uris": "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java.MultiplexingDatagramSocket.[]MultiplexingDatagramSocket(int,boolean)", "name": "MultiplexingDatagramSocket", "arg_nums": 2, "params": [{"name": "port", "type": "int"}, {"name": "persistent", "type": "boolean"}], "return_type": "", "signature": "public MultiplexingDatagramSocket(int port, boolean persistent)", "original_string": "    public MultiplexingDatagramSocket(int port, boolean persistent)\n        throws SocketException\n    {\n        super(port);\n\n        this.persistent = persistent;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java", "class_name": "MultiplexingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java.MultiplexingDatagramSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>MultiplexingDatagramSocket</tt> instance which is\nto enable <tt>DatagramPacket</tt> filtering and binds it to the specified\nport on the local host machine. The socket will be bound to the wildcard\naddress, an IP address chosen by the kernel.\n\n@param port the port to bind the new socket to\n@param persistent whether this socket should be kept open after all of\nits {@link MultiplexedDatagramSocket}s are closed.\n@throws SocketException if the socket could not be opened, or the socket\ncould not bind to the specified local port\n@see DatagramSocket#DatagramSocket(int)\n"}, {"uris": "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java.MultiplexingDatagramSocket.[]MultiplexingDatagramSocket(int,InetAddress)", "name": "MultiplexingDatagramSocket", "arg_nums": 2, "params": [{"name": "port", "type": "int"}, {"name": "laddr", "type": "InetAddress"}], "return_type": "", "signature": "public MultiplexingDatagramSocket(int port, InetAddress laddr)", "original_string": "    public MultiplexingDatagramSocket(int port, InetAddress laddr)\n        throws SocketException\n    {\n        this(port, laddr, false);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java", "class_name": "MultiplexingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java.MultiplexingDatagramSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>MultiplexingDatagramSocket</tt> instance which is\nto enable <tt>DatagramPacket</tt> filtering, bound to the specified local\naddress. The local port must be between 0 and 65535 inclusive. If the IP\naddress is 0.0.0.0, the socket will be bound to the wildcard address, an\nIP address chosen by the kernel.\n\n@param port the local port to bind the new socket to\n@param laddr the local address to bind the new socket to\n@throws SocketException if the socket could not be opened, or the socket\ncould not bind to the specified local port\n@see DatagramSocket#DatagramSocket(int, InetAddress)\n"}, {"uris": "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java.MultiplexingDatagramSocket.[]MultiplexingDatagramSocket(int,InetAddress,boolean)", "name": "MultiplexingDatagramSocket", "arg_nums": 3, "params": [{"name": "port", "type": "int"}, {"name": "laddr", "type": "InetAddress"}, {"name": "persistent", "type": "boolean"}], "return_type": "", "signature": "public MultiplexingDatagramSocket(\n            int port,\n            InetAddress laddr,\n            boolean persistent)", "original_string": "    public MultiplexingDatagramSocket(\n            int port,\n            InetAddress laddr,\n            boolean persistent)\n        throws SocketException\n    {\n        super(port, laddr);\n\n        this.persistent = persistent;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java", "class_name": "MultiplexingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java.MultiplexingDatagramSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>MultiplexingDatagramSocket</tt> instance which is\nto enable <tt>DatagramPacket</tt> filtering, bound to the specified local\naddress. The local port must be between 0 and 65535 inclusive. If the IP\naddress is 0.0.0.0, the socket will be bound to the wildcard address, an\nIP address chosen by the kernel.\n\n@param port the local port to bind the new socket to\n@param laddr the local address to bind the new socket to\n@param persistent whether this socket should be kept open after all of\nits {@link MultiplexedDatagramSocket}s are closed.\n@throws SocketException if the socket could not be opened, or the socket\ncould not bind to the specified local port\n@see DatagramSocket#DatagramSocket(int, InetAddress)\n"}, {"uris": "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java.MultiplexingDatagramSocket.[]MultiplexingDatagramSocket(SocketAddress)", "name": "MultiplexingDatagramSocket", "arg_nums": 1, "params": [{"name": "bindaddr", "type": "SocketAddress"}], "return_type": "", "signature": "public MultiplexingDatagramSocket(SocketAddress bindaddr)", "original_string": "    public MultiplexingDatagramSocket(SocketAddress bindaddr)\n        throws SocketException\n    {\n        this(bindaddr, false);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java", "class_name": "MultiplexingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java.MultiplexingDatagramSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>MultiplexingDatagramSocket</tt> instance which is\nto enable <tt>DatagramPacket</tt> filtering, bound to the specified local\nsocket address.\n<p>\nIf the specified local socket address is <tt>null</tt>, creates an\nunbound socket.\n</p>\n\n@param bindaddr local socket address to bind, or <tt>null</tt> for an\nunbound socket\n@throws SocketException if the socket could not be opened, or the socket\ncould not bind to the specified local port\n@see DatagramSocket#DatagramSocket(SocketAddress)\n"}, {"uris": "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java.MultiplexingDatagramSocket.[]MultiplexingDatagramSocket(SocketAddress,boolean)", "name": "MultiplexingDatagramSocket", "arg_nums": 2, "params": [{"name": "bindaddr", "type": "SocketAddress"}, {"name": "persistent", "type": "boolean"}], "return_type": "", "signature": "public MultiplexingDatagramSocket(\n                SocketAddress bindaddr,\n                boolean persistent)", "original_string": "    public MultiplexingDatagramSocket(\n                SocketAddress bindaddr,\n                boolean persistent)\n        throws SocketException\n    {\n        super(bindaddr);\n\n        this.persistent = persistent;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java", "class_name": "MultiplexingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java.MultiplexingDatagramSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>MultiplexingDatagramSocket</tt> instance which is\nto enable <tt>DatagramPacket</tt> filtering, bound to the specified local\nsocket address.\n<p>\nIf the specified local socket address is <tt>null</tt>, creates an\nunbound socket.\n</p>\n\n@param bindaddr local socket address to bind, or <tt>null</tt> for an\nunbound socket\n@param persistent whether this socket should be kept open after all of\nits {@link MultiplexedDatagramSocket}s are closed.\n@throws SocketException if the socket could not be opened, or the socket\ncould not bind to the specified local port\n@see DatagramSocket#DatagramSocket(SocketAddress)\n"}, {"uris": "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java.MultiplexingDatagramSocket.[void]close(MultiplexedDatagramSocket)", "name": "close", "arg_nums": 1, "params": [{"name": "multiplexed", "type": "MultiplexedDatagramSocket"}], "return_type": "void", "signature": "void close(MultiplexedDatagramSocket multiplexed)", "original_string": "    void close(MultiplexedDatagramSocket multiplexed)\n    {\n        if (!multiplexingXXXSocketSupport.close(multiplexed)\n            && !persistent)\n        {\n            close();\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java", "class_name": "MultiplexingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java.MultiplexingDatagramSocket", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCloses a specific <tt>MultiplexedDatagramSocket</tt> which filters\n<tt>DatagramPacket</tt>s away from this <tt>DatagramSocket</tt>.\n\n@param multiplexed the <tt>MultiplexedDatagramSocket</tt> to close\n"}, {"uris": "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java.MultiplexingDatagramSocket.[MultiplexedDatagramSocket]getSocket(DatagramPacketFilter)", "name": "getSocket", "arg_nums": 1, "params": [{"name": "filter", "type": "DatagramPacketFilter"}], "return_type": "MultiplexedDatagramSocket", "signature": "public MultiplexedDatagramSocket getSocket(DatagramPacketFilter filter)", "original_string": "    public MultiplexedDatagramSocket getSocket(DatagramPacketFilter filter)\n        throws SocketException\n    {\n        return getSocket(filter, /* create */ true);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java", "class_name": "MultiplexingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java.MultiplexingDatagramSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "MultiplexedDatagramSocket", "classes": []}, "docstring": "\nGets a <tt>MultiplexedDatagramSocket</tt> which filters\n<tt>DatagramPacket</tt>s away from this <tt>DatagramSocket</tt> using a\nspecific <tt>DatagramPacketFilter</tt>. If such a\n<tt>MultiplexedDatagramSocket</tt> does not exist in this instance, it is\ncreated.\n\n@param filter the <tt>DatagramPacketFilter</tt> to get a\n<tt>MultiplexedDatagramSocket</tt> for\n@return a <tt>MultiplexedDatagramSocket</tt> which filters\n<tt>DatagramPacket</tt>s away from this <tt>DatagramSocket</tt> using the\nspecified <tt>filter</tt>\n@throws SocketException if creating the\n<tt>MultiplexedDatagramSocket</tt> for the specified <tt>filter</tt>\nfails\n"}, {"uris": "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java.MultiplexingDatagramSocket.[MultiplexedDatagramSocket]getSocket(DatagramPacketFilter,boolean)", "name": "getSocket", "arg_nums": 2, "params": [{"name": "filter", "type": "DatagramPacketFilter"}, {"name": "create", "type": "boolean"}], "return_type": "MultiplexedDatagramSocket", "signature": "public MultiplexedDatagramSocket getSocket(\n            DatagramPacketFilter filter,\n            boolean create)", "original_string": "    public MultiplexedDatagramSocket getSocket(\n            DatagramPacketFilter filter,\n            boolean create)\n        throws SocketException\n    {\n        return multiplexingXXXSocketSupport.getSocket(filter, create);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java", "class_name": "MultiplexingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java.MultiplexingDatagramSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "MultiplexedDatagramSocket", "classes": []}, "docstring": "\nGets a <tt>MultiplexedDatagramSocket</tt> which filters\n<tt>DatagramPacket</tt>s away from this <tt>DatagramSocket</tt> using a\nspecific <tt>DatagramPacketFilter</tt>. If <tt>create</tt> is true and\nsuch a <tt>MultiplexedDatagramSocket</tt> does not exist in this\ninstance, it is created.\n\n@param filter the <tt>DatagramPacketFilter</tt> to get a\n<tt>MultiplexedDatagramSocket</tt> for\n@param create whether or not to create a\n<tt>MultiplexedDatagramSocket</tt> if this instance does not already have\na socket for the given <tt>filter</tt>.\n@return a <tt>MultiplexedDatagramSocket</tt> which filters\n<tt>DatagramPacket</tt>s away from this <tt>DatagramSocket</tt> using the\nspecified <tt>filter</tt>\n@throws SocketException if creating the\n<tt>MultiplexedDatagramSocket</tt> for the specified <tt>filter</tt>\nfails.\n"}, {"uris": "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java.MultiplexingDatagramSocket.[int]getSoTimeout()", "name": "getSoTimeout", "arg_nums": 0, "params": [], "return_type": "int", "signature": "@Override\n    public int getSoTimeout()", "original_string": "    @Override\n    public int getSoTimeout()\n    {\n        return soTimeout;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java", "class_name": "MultiplexingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java.MultiplexingDatagramSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java.MultiplexingDatagramSocket.[void]multiplexingXXXSocketSupportDoReceive(DatagramPacket)", "name": "multiplexingXXXSocketSupportDoReceive", "arg_nums": 1, "params": [{"name": "p", "type": "DatagramPacket"}], "return_type": "void", "signature": "private void multiplexingXXXSocketSupportDoReceive(DatagramPacket p)", "original_string": "    private void multiplexingXXXSocketSupportDoReceive(DatagramPacket p)\n        throws IOException\n    {\n        super.receive(p);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java", "class_name": "MultiplexingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java.MultiplexingDatagramSocket", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nImplements {@link MultiplexingXXXSocketSupport#doReceive(DatagramPacket)}\non behalf of {@link #multiplexingXXXSocketSupport}. Receives a\n{@code DatagramPacket} from this socket.\n\n@param p the {@code DatagramPacket} into which to place the incoming data\n@throws IOException if an I/O error occurs\n"}, {"uris": "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java.MultiplexingDatagramSocket.[void]multiplexingXXXSocketSupportDoSetReceiveBufferSize(int)", "name": "multiplexingXXXSocketSupportDoSetReceiveBufferSize", "arg_nums": 1, "params": [{"name": "receiveBufferSize", "type": "int"}], "return_type": "void", "signature": "private void multiplexingXXXSocketSupportDoSetReceiveBufferSize(\n            int receiveBufferSize)", "original_string": "    private void multiplexingXXXSocketSupportDoSetReceiveBufferSize(\n            int receiveBufferSize)\n        throws SocketException\n    {\n        super.setReceiveBufferSize(receiveBufferSize);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java", "class_name": "MultiplexingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java.MultiplexingDatagramSocket", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nImplements\n{@link MultiplexingXXXSocketSupport#doSetReceiveBufferSize(int)} on\nbehalf of {@link #multiplexingXXXSocketSupport}. Sets the\n{@code SO_RCVBUF} option to the specified value for this\n{@code DatagramSocket}. The {@code SO_RCVBUF} option is used by the\nnetwork implementation as a hint to size the underlying network I/O\nbuffers. The {@code SO_RCVBUF} setting may also be used by the network\nimplementation to determine the maximum size of the packet that can be\nreceived on this socket.\n\n@param receiveBufferSize the size to which to set the receive buffer size\n@throws SocketException if there is an error in the underlying protocol,\nsuch as a UDP error\n"}, {"uris": "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java.MultiplexingDatagramSocket.[void]receive(DatagramPacket)", "name": "receive", "arg_nums": 1, "params": [{"name": "p", "type": "DatagramPacket"}], "return_type": "void", "signature": "@Override\n    public void receive(DatagramPacket p)", "original_string": "    @Override\n    public void receive(DatagramPacket p)\n        throws IOException\n    {\n        multiplexingXXXSocketSupport.receive(received, p, soTimeout);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java", "class_name": "MultiplexingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java.MultiplexingDatagramSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nReceives a datagram packet from this socket. The <tt>DatagramPacket</tt>s\nreturned by this method do not match any of the\n<tt>DatagramPacketFilter</tt>s of the <tt>MultiplexedDatagramSocket</tt>s\nassociated with this instance at the time of their receipt. When this\nmethod returns, the <tt>DatagramPacket</tt>'s buffer is filled with the\ndata received. The datagram packet also contains the sender's IP address,\nand the port number on the sender's machine.\n<p>\nThis method blocks until a datagram is received. The <tt>length</tt>\nfield of the datagram packet object contains the length of the received\nmessage. If the message is longer than the packet's length, the message\nis truncated.\n</p>\n\n@param p the <tt>DatagramPacket</tt> into which to place the incoming\ndata\n@throws IOException if an I/O error occurs\n@throws SocketTimeoutException if <tt>setSoTimeout(int)</tt> was\npreviously called and the timeout has expired\n@see DatagramSocket#receive(DatagramPacket)\n"}, {"uris": "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java.MultiplexingDatagramSocket.[void]receive(MultiplexedDatagramSocket,DatagramPacket)", "name": "receive", "arg_nums": 2, "params": [{"name": "multiplexed", "type": "MultiplexedDatagramSocket"}, {"name": "p", "type": "DatagramPacket"}], "return_type": "void", "signature": "void receive(MultiplexedDatagramSocket multiplexed, DatagramPacket p)", "original_string": "    void receive(MultiplexedDatagramSocket multiplexed, DatagramPacket p)\n        throws IOException\n    {\n        multiplexingXXXSocketSupport.receive(\n                multiplexed.received,\n                p,\n                multiplexed.getSoTimeout());\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java", "class_name": "MultiplexingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java.MultiplexingDatagramSocket", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nReceives a <tt>DatagramPacket</tt> from this <tt>DatagramSocket</tt> upon\nrequest from a specific <tt>MultiplexedDatagramSocket</tt>.\n\n@param multiplexed the <tt>MultiplexedDatagramSocket</tt> which requests\nthe receipt of a <tt>DatagramPacket</tt> from the network\n@param p the <tt>DatagramPacket</tt> to receive the data from the network\n@throws IOException if an I/O error occurs\n@throws SocketTimeoutException if <tt>setSoTimeout(int)</tt> was\npreviously called on <tt>multiplexed</tt> and the timeout has expired\n"}, {"uris": "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java.MultiplexingDatagramSocket.[void]setReceiveBufferSize(int)", "name": "setReceiveBufferSize", "arg_nums": 1, "params": [{"name": "receiveBufferSize", "type": "int"}], "return_type": "void", "signature": "@Override\n    public void setReceiveBufferSize(int receiveBufferSize)", "original_string": "    @Override\n    public void setReceiveBufferSize(int receiveBufferSize)\n        throws SocketException\n    {\n        multiplexingXXXSocketSupport.setReceiveBufferSize(receiveBufferSize);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java", "class_name": "MultiplexingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java.MultiplexingDatagramSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java.MultiplexingDatagramSocket.[void]setSoTimeout(int)", "name": "setSoTimeout", "arg_nums": 1, "params": [{"name": "timeout", "type": "int"}], "return_type": "void", "signature": "@Override\n    public void setSoTimeout(int timeout)", "original_string": "    @Override\n    public void setSoTimeout(int timeout)\n        throws SocketException\n    {\n        super.setSoTimeout(timeout);\n\n        soTimeout = timeout;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java", "class_name": "MultiplexingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java.MultiplexingDatagramSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDatagramSocket.java.GoogleRelayedCandidateDatagramSocket.[]GoogleRelayedCandidateDatagramSocket(GoogleRelayedCandidate,GoogleTurnCandidateHarvest,String)", "name": "GoogleRelayedCandidateDatagramSocket", "arg_nums": 3, "params": [{"name": "relayedCandidate", "type": "GoogleRelayedCandidate"}, {"name": "turnCandidateHarvest", "type": "GoogleTurnCandidateHarvest"}, {"name": "username", "type": "String"}], "return_type": "", "signature": "public GoogleRelayedCandidateDatagramSocket(\n            GoogleRelayedCandidate relayedCandidate,\n            GoogleTurnCandidateHarvest turnCandidateHarvest,\n            String username)", "original_string": "    public GoogleRelayedCandidateDatagramSocket(\n            GoogleRelayedCandidate relayedCandidate,\n            GoogleTurnCandidateHarvest turnCandidateHarvest,\n            String username)\n        throws SocketException\n    {\n        super(/* bindaddr */ (SocketAddress) null);\n\n        socketDelegate = new GoogleRelayedCandidateDelegate(\n            turnCandidateHarvest, username);\n        this.relayedCandidate = relayedCandidate;\n        this.turnCandidateHarvest = turnCandidateHarvest;\n\n        logger.finest(\"Create new GoogleRelayedCandidateDatagramSocket\");\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDatagramSocket.java", "class_name": "GoogleRelayedCandidateDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDatagramSocket.java.GoogleRelayedCandidateDatagramSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>GoogleRelayedCandidateDatagramSocket</tt> instance\nwhich is to be the <tt>socket</tt> of a specific\n<tt>RelayedCandidate</tt> harvested by a specific\n<tt>TurnCandidateHarvest</tt>.\n\n@param relayedCandidate the <tt>RelayedCandidate</tt> which is to use the\nnew instance as the value of its <tt>socket</tt> property\n@param turnCandidateHarvest the <tt>TurnCandidateHarvest</tt> which has\nharvested <tt>relayedCandidate</tt>\n@param username username\n@throws SocketException if anything goes wrong while initializing the new\n<tt>GoogleRelayedCandidateDatagramSocket</tt> instance\n"}, {"uris": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDatagramSocket.java.GoogleRelayedCandidateDatagramSocket.[void]close()", "name": "close", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Override\n    public void close()", "original_string": "    @Override\n    public void close()\n    {\n        synchronized (this)\n        {\n            if (this.closed)\n                return;\n            else\n                this.closed = true;\n        }\n\n        socketDelegate.close();\n        turnCandidateHarvest.close(this);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDatagramSocket.java", "class_name": "GoogleRelayedCandidateDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDatagramSocket.java.GoogleRelayedCandidateDatagramSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCloses this datagram socket.\n\n@see DatagramSocket#close()\n"}, {"uris": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDatagramSocket.java.GoogleRelayedCandidateDatagramSocket.[InetAddress]getLocalAddress()", "name": "getLocalAddress", "arg_nums": 0, "params": [], "return_type": "InetAddress", "signature": "@Override\n    public InetAddress getLocalAddress()", "original_string": "    @Override\n    public InetAddress getLocalAddress()\n    {\n        return getLocalSocketAddress().getAddress();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDatagramSocket.java", "class_name": "GoogleRelayedCandidateDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDatagramSocket.java.GoogleRelayedCandidateDatagramSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "InetAddress", "classes": []}, "docstring": "\nGets the local address to which the socket is bound.\n<tt>GoogleRelayedCandidateDatagramSocket</tt> returns the\n<tt>address</tt> of its <tt>localSocketAddress</tt>.\n<p>\nIf there is a security manager, its <tt>checkConnect</tt> method is first\ncalled with the host address and <tt>-1</tt> as its arguments to see if\nthe operation is allowed.\n</p>\n\n@return the local address to which the socket is bound, or an\n<tt>InetAddress</tt> representing any local address if either the socket\nis not bound, or the security manager <tt>checkConnect</tt> method does\nnot allow the operation\n@see #getLocalSocketAddress()\n@see DatagramSocket#getLocalAddress()\n"}, {"uris": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDatagramSocket.java.GoogleRelayedCandidateDatagramSocket.[int]getLocalPort()", "name": "getLocalPort", "arg_nums": 0, "params": [], "return_type": "int", "signature": "@Override\n    public int getLocalPort()", "original_string": "    @Override\n    public int getLocalPort()\n    {\n        return getLocalSocketAddress().getPort();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDatagramSocket.java", "class_name": "GoogleRelayedCandidateDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDatagramSocket.java.GoogleRelayedCandidateDatagramSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\nReturns the port number on the local host to which this socket is bound.\n<tt>GoogleRelayedCandidateDatagramSocket</tt> returns the <tt>port</tt>\nof its <tt>localSocketAddress</tt>.\n\n@return the port number on the local host to which this socket is bound\n@see #getLocalSocketAddress()\n@see DatagramSocket#getLocalPort()\n"}, {"uris": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDatagramSocket.java.GoogleRelayedCandidateDatagramSocket.[InetSocketAddress]getLocalSocketAddress()", "name": "getLocalSocketAddress", "arg_nums": 0, "params": [], "return_type": "InetSocketAddress", "signature": "@Override\n    public InetSocketAddress getLocalSocketAddress()", "original_string": "    @Override\n    public InetSocketAddress getLocalSocketAddress()\n    {\n        return getRelayedCandidate().getTransportAddress();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDatagramSocket.java", "class_name": "GoogleRelayedCandidateDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDatagramSocket.java.GoogleRelayedCandidateDatagramSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "InetSocketAddress", "classes": []}, "docstring": "\nReturns the address of the endpoint this socket is bound to, or\n<tt>null</tt> if it is not bound yet. Since\n<tt>GoogleRelayedCandidateDatagramSocket</tt> represents an\napplication-purposed <tt>DatagramSocket</tt> relaying data to and from a\nTURN server, the <tt>localSocketAddress</tt> is the\n<tt>transportAddress</tt> of the respective <tt>RelayedCandidate</tt>.\n\n@return a <tt>SocketAddress</tt> representing the local endpoint of this\nsocket, or <tt>null</tt> if it is not bound yet\n@see DatagramSocket#getLocalSocketAddress()\n"}, {"uris": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDatagramSocket.java.GoogleRelayedCandidateDatagramSocket.[GoogleRelayedCandidate]getRelayedCandidate()", "name": "getRelayedCandidate", "arg_nums": 0, "params": [], "return_type": "GoogleRelayedCandidate", "signature": "public final GoogleRelayedCandidate getRelayedCandidate()", "original_string": "    public final GoogleRelayedCandidate getRelayedCandidate()\n    {\n        return relayedCandidate;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDatagramSocket.java", "class_name": "GoogleRelayedCandidateDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDatagramSocket.java.GoogleRelayedCandidateDatagramSocket", "attributes": {"modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "return_type": "GoogleRelayedCandidate", "classes": []}, "docstring": "\nGets the <tt>RelayedCandidate</tt> which uses this instance as the value\nof its <tt>socket</tt> property.\n\n@return the <tt>RelayedCandidate</tt> which uses this instance as the\nvalue of its <tt>socket</tt> property\n"}, {"uris": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDatagramSocket.java.GoogleRelayedCandidateDatagramSocket.[void]processSuccess(Response,Request)", "name": "processSuccess", "arg_nums": 2, "params": [{"name": "response", "type": "Response"}, {"name": "request", "type": "Request"}], "return_type": "void", "signature": "public void processSuccess(Response response, Request request)", "original_string": "    public void processSuccess(Response response, Request request)\n    {\n        socketDelegate.processSuccess(response, request);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDatagramSocket.java", "class_name": "GoogleRelayedCandidateDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDatagramSocket.java.GoogleRelayedCandidateDatagramSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nNotifies this <tt>GoogleRelayedCandidateDatagramSocket</tt> that a\nspecific <tt>Request</tt> it has sent has received a STUN success\n<tt>Response</tt>.\n\n@param response the <tt>Response</tt> which responds to <tt>request</tt>\n@param request the <tt>Request</tt> sent by this instance to which\n<tt>response</tt> responds\n"}, {"uris": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDatagramSocket.java.GoogleRelayedCandidateDatagramSocket.[void]processResponse(StunResponseEvent)", "name": "processResponse", "arg_nums": 1, "params": [{"name": "response", "type": "StunResponseEvent"}], "return_type": "void", "signature": "public void processResponse(StunResponseEvent response)", "original_string": "    public void processResponse(StunResponseEvent response)\n    {\n        socketDelegate.processResponse(response);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDatagramSocket.java", "class_name": "GoogleRelayedCandidateDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDatagramSocket.java.GoogleRelayedCandidateDatagramSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nDispatch the specified response.\n\n@param response the response to dispatch.\n"}, {"uris": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDatagramSocket.java.GoogleRelayedCandidateDatagramSocket.[void]receive(DatagramPacket)", "name": "receive", "arg_nums": 1, "params": [{"name": "p", "type": "DatagramPacket"}], "return_type": "void", "signature": "@Override\n    public void receive(DatagramPacket p)", "original_string": "    @Override\n    public void receive(DatagramPacket p)\n        throws IOException\n    {\n        socketDelegate.receive(p);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDatagramSocket.java", "class_name": "GoogleRelayedCandidateDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDatagramSocket.java.GoogleRelayedCandidateDatagramSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nReceives a datagram packet from this socket. When this method returns,\nthe <tt>DatagramPacket</tt>'s buffer is filled with the data received.\nThe datagram packet also contains the sender's IP address, and the port\nnumber on the sender's machine.\n\n@param p the <tt>DatagramPacket</tt> into which to place the incoming\ndata\n@throws IOException if an I/O error occurs\n@see DatagramSocket#receive(DatagramPacket)\n"}, {"uris": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDatagramSocket.java.GoogleRelayedCandidateDatagramSocket.[void]send(DatagramPacket)", "name": "send", "arg_nums": 1, "params": [{"name": "p", "type": "DatagramPacket"}], "return_type": "void", "signature": "@Override\n    public void send(DatagramPacket p)", "original_string": "    @Override\n    public void send(DatagramPacket p)\n        throws IOException\n    {\n        socketDelegate.send(p);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDatagramSocket.java", "class_name": "GoogleRelayedCandidateDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDatagramSocket.java.GoogleRelayedCandidateDatagramSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSends a datagram packet from this socket. The <tt>DatagramPacket</tt>\nincludes information indicating the data to be sent, its length, the IP\naddress of the remote host, and the port number on the remote host.\n\n@param p the <tt>DatagramPacket</tt> to be sent\n@throws IOException if an I/O error occurs\n@see DatagramSocket#send(DatagramPacket)\n"}, {"uris": "src/main/java/org/ice4j/socket/MultiplexingXXXSocketSupport.java.MultiplexingXXXSocketSupport.[DatagramPacket]clone(DatagramPacket)", "name": "clone", "arg_nums": 1, "params": [{"name": "p", "type": "DatagramPacket"}], "return_type": "DatagramPacket", "signature": "public static DatagramPacket clone(DatagramPacket p)", "original_string": "    public static DatagramPacket clone(DatagramPacket p)\n    {\n        return clone(p, /* arraycopy */ true);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MultiplexingXXXSocketSupport.java", "class_name": "MultiplexingXXXSocketSupport", "class_uri": "src/main/java/org/ice4j/socket/MultiplexingXXXSocketSupport.java.MultiplexingXXXSocketSupport", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "DatagramPacket", "classes": []}, "docstring": "\nInitializes a new <tt>DatagramPacket</tt> instance which is a clone of a\nspecific <tt>DatagramPacket</tt> i.e. the properties of the clone\n<tt>DatagramPacket</tt> are clones of the specified\n<tt>DatagramPacket</tt>.\n\n@param p the <tt>DatagramPacket</tt> to clone\n@return a new <tt>DatagramPacket</tt> instance which is a clone of the\nspecified <tt>DatagramPacket</tt>\n"}, {"uris": "src/main/java/org/ice4j/socket/MultiplexingXXXSocketSupport.java.MultiplexingXXXSocketSupport.[DatagramPacket]clone(DatagramPacket,boolean)", "name": "clone", "arg_nums": 2, "params": [{"name": "p", "type": "DatagramPacket"}, {"name": "arraycopy", "type": "boolean"}], "return_type": "DatagramPacket", "signature": "private static DatagramPacket clone(DatagramPacket p, boolean arraycopy)", "original_string": "    private static DatagramPacket clone(DatagramPacket p, boolean arraycopy)\n    {\n        byte[] data;\n        int off;\n        int len;\n        InetAddress address;\n        int port;\n\n        synchronized (p)\n        {\n            data = p.getData();\n            off = p.getOffset();\n            len = p.getLength();\n\n            // Clone the data.\n            {\n                // The capacity of the specified p is preserved.\n                byte[] dataClone = new byte[data.length];\n\n                // However, only copy the range of data starting with off and\n                // spanning len number of bytes. Of course, preserve off and len\n                // in addition to the capacity.\n                if (arraycopy && (len > 0))\n                {\n                    int arraycopyOff, arraycopyLen;\n\n                    // If off and/or len are going to cause an exception though,\n                    // copy the whole data.\n                    if ((off >= 0)\n                            && (off < data.length)\n                            && (off + len <= data.length))\n                    {\n                        arraycopyOff = off;\n                        arraycopyLen = len;\n                    }\n                    else\n                    {\n                        arraycopyOff = 0;\n                        arraycopyLen = data.length;\n                    }\n                    System.arraycopy(\n                            data, arraycopyOff,\n                            dataClone, arraycopyOff,\n                            arraycopyLen);\n                }\n                data = dataClone;\n            }\n\n            address = p.getAddress();\n            port = p.getPort();\n        }\n\n        DatagramPacket c = new DatagramPacket(data, off, len);\n\n        if (address != null)\n            c.setAddress(address);\n        if (port >= 0)\n            c.setPort(port);\n\n        return c;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MultiplexingXXXSocketSupport.java", "class_name": "MultiplexingXXXSocketSupport", "class_uri": "src/main/java/org/ice4j/socket/MultiplexingXXXSocketSupport.java.MultiplexingXXXSocketSupport", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "DatagramPacket", "classes": []}, "docstring": "\nInitializes a new <tt>DatagramPacket</tt> instance which is a clone of a\nspecific <tt>DatagramPacket</tt> i.e. the properties of the clone\n<tt>DatagramPacket</tt> are clones of the specified\n<tt>DatagramPacket</tt>.\n\n@param p the <tt>DatagramPacket</tt> to clone\n@param arraycopy <tt>true</tt> if the actual bytes of the data of\n<tt>p</tt> are to be copied into the clone or <tt>false</tt> if only the\ncapacity of the data of <tt>p</tt> is to be cloned without copying the\nactual bytes of the data of <tt>p</tt>\n@return a new <tt>DatagramPacket</tt> instance which is a clone of the\nspecified <tt>DatagramPacket</tt>\n"}, {"uris": "src/main/java/org/ice4j/socket/MultiplexingXXXSocketSupport.java.MultiplexingXXXSocketSupport.[void]copy(DatagramPacket,DatagramPacket)", "name": "copy", "arg_nums": 2, "params": [{"name": "src", "type": "DatagramPacket"}, {"name": "dest", "type": "DatagramPacket"}], "return_type": "void", "signature": "public static void copy(DatagramPacket src, DatagramPacket dest)", "original_string": "    public static void copy(DatagramPacket src, DatagramPacket dest)\n    {\n        synchronized (dest)\n        {\n            dest.setAddress(src.getAddress());\n            dest.setPort(src.getPort());\n\n            byte[] srcData = src.getData();\n\n            if (srcData == null)\n            {\n                dest.setLength(0);\n            }\n            else\n            {\n                byte[] destData = dest.getData();\n\n                if (destData == null)\n                {\n                    dest.setLength(0);\n                }\n                else\n                {\n                    int destOffset = dest.getOffset();\n                    int destLength = destData.length - destOffset;\n                    int srcLength = src.getLength();\n\n                    if (destLength >= srcLength)\n                    {\n                        destLength = srcLength;\n                    }\n                    else if (logger.isLoggable(Level.WARNING))\n                    {\n                        logger.log(\n                                Level.WARNING,\n                                \"Truncating received DatagramPacket data!\");\n                    }\n                    System.arraycopy(\n                            srcData, src.getOffset(),\n                            destData, destOffset,\n                            destLength);\n                    dest.setLength(destLength);\n                }\n            }\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MultiplexingXXXSocketSupport.java", "class_name": "MultiplexingXXXSocketSupport", "class_uri": "src/main/java/org/ice4j/socket/MultiplexingXXXSocketSupport.java.MultiplexingXXXSocketSupport", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCopies the properties of a specific <tt>DatagramPacket</tt> to another\n<tt>DatagramPacket</tt>. The property values are not cloned.\n\n@param src the <tt>DatagramPacket</tt> which is to have its properties\ncopied to <tt>dest</tt>\n@param dest the <tt>DatagramPacket</tt> which is to have its properties\nset to the value of the respective properties of <tt>src</tt>\n"}, {"uris": "src/main/java/org/ice4j/socket/MultiplexingXXXSocketSupport.java.MultiplexingXXXSocketSupport.[]MultiplexingXXXSocketSupport()", "name": "MultiplexingXXXSocketSupport", "arg_nums": 0, "params": [], "return_type": "", "signature": "protected MultiplexingXXXSocketSupport()", "original_string": "    protected MultiplexingXXXSocketSupport()\n    {\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MultiplexingXXXSocketSupport.java", "class_name": "MultiplexingXXXSocketSupport", "class_uri": "src/main/java/org/ice4j/socket/MultiplexingXXXSocketSupport.java.MultiplexingXXXSocketSupport", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new {@code MultiplexingXXXSocketSupport} instance.\n"}, {"uris": "src/main/java/org/ice4j/socket/MultiplexingXXXSocketSupport.java.MultiplexingXXXSocketSupport.[void]acceptBySocketsOrThis(DatagramPacket)", "name": "acceptBySocketsOrThis", "arg_nums": 1, "params": [{"name": "p", "type": "DatagramPacket"}], "return_type": "void", "signature": "private void acceptBySocketsOrThis(DatagramPacket p)", "original_string": "    private void acceptBySocketsOrThis(DatagramPacket p)\n    {\n        synchronized (sockets)\n        {\n            boolean accepted = false;\n\n            for (MultiplexedXXXSocketT socket : sockets)\n            {\n                if (getFilter(socket).accept(p))\n                {\n                    SocketReceiveBuffer socketReceived = getReceived(socket);\n\n                    synchronized (socketReceived)\n                    {\n                        socketReceived.add(\n                                accepted ? clone(p, /* arraycopy */ true) : p);\n                        socketReceived.notifyAll();\n                    }\n                    accepted = true;\n\n                    // Emil Ivov: Don't break because we want all\n                    // filtering sockets to get the received packet.\n                }\n            }\n            if (!accepted)\n            {\n                SocketReceiveBuffer thisReceived = getReceived();\n\n                synchronized (thisReceived)\n                {\n                    thisReceived.add(p);\n                    thisReceived.notifyAll();\n                }\n            }\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MultiplexingXXXSocketSupport.java", "class_name": "MultiplexingXXXSocketSupport", "class_uri": "src/main/java/org/ice4j/socket/MultiplexingXXXSocketSupport.java.MultiplexingXXXSocketSupport", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nAccepts a {@code DatagramPacket} received by this socket and queues it\nfor receipt through either this multiplexing socket or its multiplexed\nsockets whose {@code DatagramPacketFilter}s accept {@code p}.\n\n@param p the {@code DatagramPacket} to be accepted by either this\nmultiplexing socket or its multiplexed sockets whose\n{@code DatagramPacketFilter}s accept {@code p}\n"}, {"uris": "src/main/java/org/ice4j/socket/MultiplexingXXXSocketSupport.java.MultiplexingXXXSocketSupport.[boolean]close(MultiplexedXXXSocketT)", "name": "close", "arg_nums": 1, "params": [{"name": "multiplexed", "type": "MultiplexedXXXSocketT"}], "return_type": "boolean", "signature": "boolean close(MultiplexedXXXSocketT multiplexed)", "original_string": "    boolean close(MultiplexedXXXSocketT multiplexed)\n    {\n        synchronized (sockets)\n        {\n            sockets.remove(multiplexed);\n\n            return !sockets.isEmpty();\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MultiplexingXXXSocketSupport.java", "class_name": "MultiplexingXXXSocketSupport", "class_uri": "src/main/java/org/ice4j/socket/MultiplexingXXXSocketSupport.java.MultiplexingXXXSocketSupport", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nCloses a specific <tt>MultiplexedDatagramSocket</tt> which filters\n<tt>DatagramPacket</tt>s away from this <tt>DatagramSocket</tt>.\n\n@param multiplexed the <tt>MultiplexedDatagramSocket</tt> to close\n@return {@code true} if there are remaining filtered sockets.\n"}, {"uris": "src/main/java/org/ice4j/socket/MultiplexingXXXSocketSupport.java.MultiplexingXXXSocketSupport.[MultiplexedXXXSocketT]createSocket(DatagramPacketFilter)", "name": "createSocket", "arg_nums": 1, "params": [{"name": "filter", "type": "DatagramPacketFilter"}], "return_type": "MultiplexedXXXSocketT", "signature": "protected abstract MultiplexedXXXSocketT createSocket(\n            DatagramPacketFilter filter)", "original_string": "    protected abstract MultiplexedXXXSocketT createSocket(\n            DatagramPacketFilter filter)\n        throws SocketException;", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MultiplexingXXXSocketSupport.java", "class_name": "MultiplexingXXXSocketSupport", "class_uri": "src/main/java/org/ice4j/socket/MultiplexingXXXSocketSupport.java.MultiplexingXXXSocketSupport", "attributes": {"modifiers": "protected abstract", "marker_annotations": [], "non_marker_annotations": ["protected", "abstract"], "comments": [], "return_type": "MultiplexedXXXSocketT", "classes": []}, "docstring": "\nInitializes a new multiplexed socket instance which is to be associated\nwith a specific {@code DatagramPacketFilter}.\n\n@param filter the {@code DatagramPacketFilter} to associate with the new\ninstance\n@return a new multiplexed socket associated with the specified\n{@code filter}\n@throws SocketException if there is an error in the underlying protocol,\nsuch as a TCP or UDP error\n"}, {"uris": "src/main/java/org/ice4j/socket/MultiplexingXXXSocketSupport.java.MultiplexingXXXSocketSupport.[void]doReceive(DatagramPacket)", "name": "doReceive", "arg_nums": 1, "params": [{"name": "p", "type": "DatagramPacket"}], "return_type": "void", "signature": "protected abstract void doReceive(DatagramPacket p)", "original_string": "    protected abstract void doReceive(DatagramPacket p)\n        throws IOException;", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MultiplexingXXXSocketSupport.java", "class_name": "MultiplexingXXXSocketSupport", "class_uri": "src/main/java/org/ice4j/socket/MultiplexingXXXSocketSupport.java.MultiplexingXXXSocketSupport", "attributes": {"modifiers": "protected abstract", "marker_annotations": [], "non_marker_annotations": ["protected", "abstract"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nReceives a {@code DatagramPacket} from this socket.\n\n@param p the {@code DatagramPacket} into which to place the incoming data\n@throws IOException if an I/O error occurs\n"}, {"uris": "src/main/java/org/ice4j/socket/MultiplexingXXXSocketSupport.java.MultiplexingXXXSocketSupport.[void]doSetReceiveBufferSize(int)", "name": "doSetReceiveBufferSize", "arg_nums": 1, "params": [{"name": "receiveBufferSize", "type": "int"}], "return_type": "void", "signature": "protected abstract void doSetReceiveBufferSize(int receiveBufferSize)", "original_string": "    protected abstract void doSetReceiveBufferSize(int receiveBufferSize)\n        throws SocketException;", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MultiplexingXXXSocketSupport.java", "class_name": "MultiplexingXXXSocketSupport", "class_uri": "src/main/java/org/ice4j/socket/MultiplexingXXXSocketSupport.java.MultiplexingXXXSocketSupport", "attributes": {"modifiers": "protected abstract", "marker_annotations": [], "non_marker_annotations": ["protected", "abstract"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets the {@code SO_RCVBUF} option to the specified value for this\n{@code DatagramSocket}. The {@code SO_RCVBUF} option is used by the\nnetwork implementation as a hint to size the underlying network I/O\nbuffers. The {@code SO_RCVBUF} setting may also be used by the network\nimplementation to determine the maximum size of the packet that can be\nreceived on this socket.\n\n@param receiveBufferSize the size to which to set the receive buffer size\n@throws SocketException if there is an error in the underlying protocol,\nsuch as a UDP error\n"}, {"uris": "src/main/java/org/ice4j/socket/MultiplexingXXXSocketSupport.java.MultiplexingXXXSocketSupport.[DatagramPacketFilter]getFilter(MultiplexedXXXSocketT)", "name": "getFilter", "arg_nums": 1, "params": [{"name": "socket", "type": "MultiplexedXXXSocketT"}], "return_type": "DatagramPacketFilter", "signature": "protected DatagramPacketFilter getFilter(MultiplexedXXXSocketT socket)", "original_string": "    protected DatagramPacketFilter getFilter(MultiplexedXXXSocketT socket)\n    {\n        return socket.getFilter();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MultiplexingXXXSocketSupport.java", "class_name": "MultiplexingXXXSocketSupport", "class_uri": "src/main/java/org/ice4j/socket/MultiplexingXXXSocketSupport.java.MultiplexingXXXSocketSupport", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "DatagramPacketFilter", "classes": []}, "docstring": "\nGets the {@code DatagramPacketFilter} associated with a specific\nmultiplexed socket.\n\n@param socket the multiplexed socket whose associated\n{@code DatagramPacketFilter} is to be retrieved\n@return the {@code DatagramPacketFilter} associated with {@code socket}\n"}, {"uris": "src/main/java/org/ice4j/socket/MultiplexingXXXSocketSupport.java.MultiplexingXXXSocketSupport.[SocketReceiveBuffer]getReceived()", "name": "getReceived", "arg_nums": 0, "params": [], "return_type": "SocketReceiveBuffer", "signature": "protected abstract SocketReceiveBuffer getReceived()", "original_string": "    protected abstract SocketReceiveBuffer getReceived();", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MultiplexingXXXSocketSupport.java", "class_name": "MultiplexingXXXSocketSupport", "class_uri": "src/main/java/org/ice4j/socket/MultiplexingXXXSocketSupport.java.MultiplexingXXXSocketSupport", "attributes": {"modifiers": "protected abstract", "marker_annotations": [], "non_marker_annotations": ["protected", "abstract"], "comments": [], "return_type": "SocketReceiveBuffer", "classes": []}, "docstring": "\nGets the list of {@code DatagramPacket}s received by this socket and not\naccepted by any (existing) {@code DatagramPacketFilter} at the time of\nreceipt.\n\n@return the list of {@code DatagramPacket}s received by this socket and\nnot accepted by any (existing) {@code DatagramPacketFilter} at the time of\nreceipt\n"}, {"uris": "src/main/java/org/ice4j/socket/MultiplexingXXXSocketSupport.java.MultiplexingXXXSocketSupport.[SocketReceiveBuffer]getReceived(MultiplexedXXXSocketT)", "name": "getReceived", "arg_nums": 1, "params": [{"name": "socket", "type": "MultiplexedXXXSocketT"}], "return_type": "SocketReceiveBuffer", "signature": "protected abstract SocketReceiveBuffer getReceived(\n            MultiplexedXXXSocketT socket)", "original_string": "    protected abstract SocketReceiveBuffer getReceived(\n            MultiplexedXXXSocketT socket);", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MultiplexingXXXSocketSupport.java", "class_name": "MultiplexingXXXSocketSupport", "class_uri": "src/main/java/org/ice4j/socket/MultiplexingXXXSocketSupport.java.MultiplexingXXXSocketSupport", "attributes": {"modifiers": "protected abstract", "marker_annotations": [], "non_marker_annotations": ["protected", "abstract"], "comments": [], "return_type": "SocketReceiveBuffer", "classes": []}, "docstring": "\nGets the list of {@code DatagramPacket}s received by this multiplexing\nsocket and accepted by the {@code DatagramPacketFilter} of a specific\nmultiplexed socket at the time of receipt.\n\n@param socket the multiplexed socket whose list of accepted received\n{@code DatagramPacket}s is to be returned\n@return the list of {@code DatagramPacket}s received by this multiplexing\nsocket and accepted by the {@code DatagramPacketFilter} of the\nmultiplexed {@code socket} at the time of receipt\n"}, {"uris": "src/main/java/org/ice4j/socket/MultiplexingXXXSocketSupport.java.MultiplexingXXXSocketSupport.[MultiplexedXXXSocketT]getSocket(DatagramPacketFilter)", "name": "getSocket", "arg_nums": 1, "params": [{"name": "filter", "type": "DatagramPacketFilter"}], "return_type": "MultiplexedXXXSocketT", "signature": "public MultiplexedXXXSocketT getSocket(DatagramPacketFilter filter)", "original_string": "    public MultiplexedXXXSocketT getSocket(DatagramPacketFilter filter)\n        throws SocketException\n    {\n        return getSocket(filter, /* create */ true);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MultiplexingXXXSocketSupport.java", "class_name": "MultiplexingXXXSocketSupport", "class_uri": "src/main/java/org/ice4j/socket/MultiplexingXXXSocketSupport.java.MultiplexingXXXSocketSupport", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "MultiplexedXXXSocketT", "classes": []}, "docstring": "\nGets a <tt>MultiplexedDatagramSocket</tt> which filters\n<tt>DatagramPacket</tt>s away from this <tt>DatagramSocket</tt> using a\nspecific <tt>DatagramPacketFilter</tt>. If such a\n<tt>MultiplexedDatagramSocket</tt> does not exist in this instance, it is\ncreated.\n\n@param filter the <tt>DatagramPacketFilter</tt> to get a\n<tt>MultiplexedDatagramSocket</tt> for\n@return a <tt>MultiplexedDatagramSocket</tt> which filters\n<tt>DatagramPacket</tt>s away from this <tt>DatagramSocket</tt> using the\nspecified <tt>filter</tt>\n@throws SocketException if creating the\n<tt>MultiplexedDatagramSocket</tt> for the specified <tt>filter</tt>\nfails\n"}, {"uris": "src/main/java/org/ice4j/socket/MultiplexingXXXSocketSupport.java.MultiplexingXXXSocketSupport.[MultiplexedXXXSocketT]getSocket(DatagramPacketFilter,boolean)", "name": "getSocket", "arg_nums": 2, "params": [{"name": "filter", "type": "DatagramPacketFilter"}, {"name": "create", "type": "boolean"}], "return_type": "MultiplexedXXXSocketT", "signature": "public MultiplexedXXXSocketT getSocket(\n            DatagramPacketFilter filter,\n            boolean create)", "original_string": "    public MultiplexedXXXSocketT getSocket(\n            DatagramPacketFilter filter,\n            boolean create)\n        throws SocketException\n    {\n        if (filter == null)\n            throw new NullPointerException(\"filter\");\n\n        synchronized (sockets)\n        {\n            // If a socket for the specified filter exists already, do not\n            // create a new one and return the existing.\n            for (MultiplexedXXXSocketT socket : sockets)\n            {\n                if (filter.equals(getFilter(socket)))\n                    return socket;\n            }\n\n            if (!create)\n                return null;\n\n            // Create a new socket for the specified filter.\n            MultiplexedXXXSocketT socket = createSocket(filter);\n\n            // Remember the new socket.\n            if (socket != null)\n            {\n                sockets.add(socket);\n\n                // A multiplexed socket may be created after packets matching\n                // its filter have been received. Pull them out of the\n                // multiplexing socket and into the newly-created multiplexed\n                // socket.\n\n                // XXX The fields received of both the multiplexed and the\n                // multiplexing sockets are used as synchronization roots (e.g.\n                // the method acceptBySocketsOrThis). In order to preserve the\n                // order of acquiring synchronization roots, perform the\n                // following procedure under the protection of the field\n                // socketsSyncRoot even though the field sockets will not be\n                // accessed.\n                moveReceivedFromThisToSocket(socket);\n            }\n\n            return socket;\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MultiplexingXXXSocketSupport.java", "class_name": "MultiplexingXXXSocketSupport", "class_uri": "src/main/java/org/ice4j/socket/MultiplexingXXXSocketSupport.java.MultiplexingXXXSocketSupport", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "MultiplexedXXXSocketT", "classes": []}, "docstring": "\nGets a <tt>MultiplexedDatagramSocket</tt> which filters\n<tt>DatagramPacket</tt>s away from this <tt>DatagramSocket</tt> using a\nspecific <tt>DatagramPacketFilter</tt>. If <tt>create</tt> is true and\nsuch a <tt>MultiplexedDatagramSocket</tt> does not exist in this\ninstance, it is created.\n\n@param filter the <tt>DatagramPacketFilter</tt> to get a\n<tt>MultiplexedDatagramSocket</tt> for\n@param create whether or not to create a\n<tt>MultiplexedDatagramSocket</tt> if this instance does not already have\na socket for the given <tt>filter</tt>.\n@return a <tt>MultiplexedDatagramSocket</tt> which filters\n<tt>DatagramPacket</tt>s away from this <tt>DatagramSocket</tt> using the\nspecified <tt>filter</tt>\n@throws SocketException if creating the\n<tt>MultiplexedDatagramSocket</tt> for the specified <tt>filter</tt>\nfails.\n"}, {"uris": "src/main/java/org/ice4j/socket/MultiplexingXXXSocketSupport.java.MultiplexingXXXSocketSupport.[void]moveReceivedFromThisToSocket(MultiplexedXXXSocketT)", "name": "moveReceivedFromThisToSocket", "arg_nums": 1, "params": [{"name": "socket", "type": "MultiplexedXXXSocketT"}], "return_type": "void", "signature": "private void moveReceivedFromThisToSocket(MultiplexedXXXSocketT socket)", "original_string": "    private void moveReceivedFromThisToSocket(MultiplexedXXXSocketT socket)\n    {\n        // Pull the packets which have been received already and are accepted by\n        // the specified multiplexed socket out of the multiplexing socket.\n        final SocketReceiveBuffer thisReceived = getReceived();\n        final DatagramPacketFilter socketFilter = getFilter(socket);\n        final List<DatagramPacket> toMove;\n\n        synchronized (thisReceived)\n        {\n            toMove = thisReceived.scan(socketFilter);\n        }\n\n        // Push the packets which have been accepted already and are accepted by\n        // the specified multiplexed socket into the multiplexed socket in\n        // question.\n        if (!toMove.isEmpty())\n        {\n            final SocketReceiveBuffer socketReceived = getReceived(socket);\n\n            synchronized (socketReceived)\n            {\n                for (DatagramPacket datagramPacket : toMove) {\n                    socketReceived.add(datagramPacket);\n                }\n                // The notifyAll will practically likely be unnecessary because\n                // the specified socket will likely be a newly-created one to\n                // which noone else has a reference. Anyway, dp the invocation\n                // for the purposes of consistency, clarity, and such.\n                socketReceived.notifyAll();\n            }\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MultiplexingXXXSocketSupport.java", "class_name": "MultiplexingXXXSocketSupport", "class_uri": "src/main/java/org/ice4j/socket/MultiplexingXXXSocketSupport.java.MultiplexingXXXSocketSupport", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nMoves packets which have been received from this multiplexing socket to\na specific multiplexed socket if they are accepted by the\n{@code DatagramPacketFilter} of the latter.\n\n@param socket the multiplexed socket into which received packets are to\nbe moved from this multiplexing socket if they are accepted by the\n{@code DatagramPacketFilter} of the former\n"}, {"uris": "src/main/java/org/ice4j/socket/MultiplexingXXXSocketSupport.java.MultiplexingXXXSocketSupport.[void]receive(SocketReceiveBuffer,DatagramPacket,int)", "name": "receive", "arg_nums": 3, "params": [{"name": "received", "type": "SocketReceiveBuffer"}, {"name": "p", "type": "DatagramPacket"}, {"name": "timeout", "type": "int"}], "return_type": "void", "signature": "void receive(SocketReceiveBuffer received, DatagramPacket p, int timeout)", "original_string": "    void receive(SocketReceiveBuffer received, DatagramPacket p, int timeout)\n        throws IOException\n    {\n        long startTime = System.currentTimeMillis();\n        DatagramPacket receivedPacket;\n\n        do\n        {\n            long now = System.currentTimeMillis();\n\n            // If there is a packet which has been received from the network and\n            // is to merely be received from the list of received\n            // DatagramPackets, then let it be received and do not throw a\n            // SocketTimeoutException.\n            synchronized (received)\n            {\n                receivedPacket = received.poll();\n                if (receivedPacket != null)\n                    break;\n            }\n\n            // Throw a SocketTimeoutException if the timeout is over/up.\n            long remainingTimeout;\n\n            if (timeout > 0)\n            {\n                remainingTimeout = timeout - (now - startTime);\n                if (remainingTimeout <= 0L)\n                {\n                    throw new SocketTimeoutException(\n                            Long.toString(remainingTimeout));\n                }\n            }\n            else\n            {\n                remainingTimeout = 1000L;\n            }\n\n            // Determine whether the caller will receive from the network or\n            // will wait for a previous caller to receive from the network.\n            boolean wait;\n\n            synchronized (receiveSyncRoot)\n            {\n                if (inReceive)\n                {\n                    wait = true;\n                }\n                else\n                {\n                    wait = false;\n                    inReceive = true;\n                }\n            }\n            try\n            {\n                if (wait)\n                {\n                    // The caller will wait for a previous caller to receive\n                    // from the network.\n                    synchronized (received)\n                    {\n                        if (received.isEmpty())\n                        {\n                            try\n                            {\n                                received.wait(remainingTimeout);\n                            }\n                            catch (InterruptedException ie)\n                            {\n                            }\n                        }\n                        else\n                        {\n                            received.notifyAll();\n                        }\n                    }\n                    continue;\n                }\n\n                // The pooled datagram packet instance will be used to receive\n                // from the network.\n                DatagramPacket receivePacket\n                    = receiveDatagramPacketsPool.poll();\n                if (receivePacket == null)\n                {\n                    receivePacket = new DatagramPacket(\n                        new byte[POOLED_DATAGRAM_PACKET_SIZE],\n                        POOLED_DATAGRAM_PACKET_SIZE);\n                }\n\n                receivePacket.setLength(POOLED_DATAGRAM_PACKET_SIZE);\n\n                synchronized (receiveSyncRoot)\n                {\n                    if (setReceiveBufferSize)\n                    {\n                        setReceiveBufferSize = false;\n                        try\n                        {\n                            doSetReceiveBufferSize(receiveBufferSize);\n                        }\n                        catch (Throwable t)\n                        {\n                            if (t instanceof ThreadDeath)\n                                throw (ThreadDeath) t;\n                        }\n                    }\n                }\n                doReceive(receivePacket);\n\n                // The caller received from the network. Copy/add the packet to\n                // the receive list of the sockets which accept it.\n                acceptBySocketsOrThis(receivePacket);\n            }\n            finally\n            {\n                synchronized (receiveSyncRoot)\n                {\n                    if (!wait)\n                        inReceive = false;\n                }\n            }\n        }\n        while (true);\n\n        copy(receivedPacket, p);\n\n        // receivePacket is a datagram packet retrieved from SocketReceiveBuffer\n        // SocketReceiveBuffers only store datagrams borrowed from pool,\n        // so return datagram back to pool.\n        receiveDatagramPacketsPool.offer(receivedPacket);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MultiplexingXXXSocketSupport.java", "class_name": "MultiplexingXXXSocketSupport", "class_uri": "src/main/java/org/ice4j/socket/MultiplexingXXXSocketSupport.java.MultiplexingXXXSocketSupport", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nReceives a <tt>DatagramPacket</tt> from a specific list of\n<tt>DatagramPacket</tt>s if it is not empty or from the network if the\nspecified list is empty. When this method returns, the\n<tt>DatagramPacket</tt>'s buffer is filled with the data received. The\ndatagram packet also contains the sender's IP address, and the port\nnumber on the sender's machine.\n\n@param received the list of previously received <tt>DatagramPacket</tt>\nfrom which the first is to be removed and returned if available\n@param p the <tt>DatagramPacket</tt> into which to place the incoming\ndata\n@param timeout the maximum time in milliseconds to wait for a\npacket. A timeout of zero is interpreted as an infinite\ntimeout\n@throws IOException if an I/O error occurs\n@throws SocketTimeoutException if <tt>timeout</tt> is positive and has\nexpired\n"}, {"uris": "src/main/java/org/ice4j/socket/MultiplexingXXXSocketSupport.java.MultiplexingXXXSocketSupport.[void]setReceiveBufferSize(int)", "name": "setReceiveBufferSize", "arg_nums": 1, "params": [{"name": "receiveBufferSize", "type": "int"}], "return_type": "void", "signature": "public void setReceiveBufferSize(int receiveBufferSize)", "original_string": "    public void setReceiveBufferSize(int receiveBufferSize)\n        throws SocketException\n    {\n        synchronized (receiveSyncRoot)\n        {\n            this.receiveBufferSize = receiveBufferSize;\n\n            if (inReceive)\n            {\n                setReceiveBufferSize = true;\n            }\n            else\n            {\n                doSetReceiveBufferSize(receiveBufferSize);\n                setReceiveBufferSize = false;\n            }\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MultiplexingXXXSocketSupport.java", "class_name": "MultiplexingXXXSocketSupport", "class_uri": "src/main/java/org/ice4j/socket/MultiplexingXXXSocketSupport.java.MultiplexingXXXSocketSupport", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets the {@code SO_RCVBUF} option to the specified value for this socket.\nThe {@code SO_RCVBUF} option is used by the network implementation as a\nhint to size the underlying network I/O buffers. The {@code SO_RCVBUF}\nsetting may also be used by the network implementation to determine the\nmaximum size of the packet that can be received on this socket.\n\n@param receiveBufferSize the size to which to set the receive buffer size\n@throws SocketException if there is an error in the underlying protocol,\nsuch as a TCP or UDP error\n"}, {"uris": "src/main/java/org/ice4j/socket/TCPInputStream.java.TCPInputStream.[]TCPInputStream(MultiplexingSocket)", "name": "TCPInputStream", "arg_nums": 1, "params": [{"name": "socket", "type": "MultiplexingSocket"}], "return_type": "", "signature": "public TCPInputStream(MultiplexingSocket socket)", "original_string": "    public TCPInputStream(MultiplexingSocket socket)\n    {\n        if (socket == null)\n            throw new NullPointerException(\"socket\");\n\n        this.socket = socket;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/TCPInputStream.java", "class_name": "TCPInputStream", "class_uri": "src/main/java/org/ice4j/socket/TCPInputStream.java.TCPInputStream", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>TCPInputStream</tt>.\n\n@param socket The inputStream for this instance.\n"}, {"uris": "src/main/java/org/ice4j/socket/TCPInputStream.java.TCPInputStream.[void]close()", "name": "close", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Override\n    public void close()", "original_string": "    @Override\n    public void close()\n        throws IOException\n    {\n        // TODO Auto-generated method stub\n        super.close();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/TCPInputStream.java", "class_name": "TCPInputStream", "class_uri": "src/main/java/org/ice4j/socket/TCPInputStream.java.TCPInputStream", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/TCPInputStream.java.TCPInputStream.[int]read()", "name": "read", "arg_nums": 0, "params": [], "return_type": "int", "signature": "@Override\n    public int read()", "original_string": "    @Override\n    public int read()\n        throws IOException\n    {\n        synchronized (readSyncRoot)\n        {\n            waitWhileInRead();\n            inRead = true;\n        }\n        try\n        {\n            do\n            {\n                int read = read0(b, 0, 1);\n\n                if (read == -1)\n                    return read;\n                if (read == 1)\n                    return b[0];\n            }\n            while (true);\n        }\n        finally\n        {\n            synchronized (readSyncRoot)\n            {\n                inRead = false;\n            }\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/TCPInputStream.java", "class_name": "TCPInputStream", "class_uri": "src/main/java/org/ice4j/socket/TCPInputStream.java.TCPInputStream", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/TCPInputStream.java.TCPInputStream.[int]read(byte[],int,int)", "name": "read", "arg_nums": 3, "params": [{"name": "b", "type": "byte[]"}, {"name": "off", "type": "int"}, {"name": "len", "type": "int"}], "return_type": "int", "signature": "@Override\n    public int read(byte[] b, int off, int len)", "original_string": "    @Override\n    public int read(byte[] b, int off, int len)\n        throws IOException\n    {\n        int read;\n\n        // The javadoc on InputStream.read(byte[], int, int) says that, if len\n        // is zero, no bytes are read and zero is returned.\n        if (len == 0)\n        {\n            read = 0;\n        }\n        else\n        {\n            synchronized (readSyncRoot)\n            {\n                waitWhileInRead();\n                inRead = true;\n            }\n            try\n            {\n                read = read0(b, off, len);\n            }\n            finally\n            {\n                synchronized (readSyncRoot)\n                {\n                    inRead = false;\n                }\n            }\n        }\n        return read;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/TCPInputStream.java", "class_name": "TCPInputStream", "class_uri": "src/main/java/org/ice4j/socket/TCPInputStream.java.TCPInputStream", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/TCPInputStream.java.TCPInputStream.[int]read0(byte[],int,int)", "name": "read0", "arg_nums": 3, "params": [{"name": "b", "type": "byte[]"}, {"name": "off", "type": "int"}, {"name": "len", "type": "int"}], "return_type": "int", "signature": "protected int read0(byte[] b, int off, int len)", "original_string": "    protected int read0(byte[] b, int off, int len)\n        throws IOException\n    {\n        int read;\n\n        do\n        {\n            if (packetLength > 0)\n            {\n                // Data has already been received from the network.\n                read = Math.min(packetLength, len);\n                System.arraycopy(packetData, packetOffset, b, off, read);\n                packetLength -= read;\n                packetOffset += read;\n                break;\n            }\n\n            // Receive from the network.\n\n            // Make sure that the receive buffer of this InputStream satisfies\n            // the requirements with respect to size of the socket.\n            int receiveBufferSize = socket.getReceiveBufferSize();\n\n            if (receiveBufferSize < 1)\n                receiveBufferSize = DEFAULT_RECEIVE_BUFFER_SIZE;\n            if ((packetData == null) || (packetData.length < receiveBufferSize))\n                packetData = new byte[receiveBufferSize];\n            if (packet == null)\n                packet = new DatagramPacket(packetData, 0, packetData.length);\n            else\n                packet.setData(packetData, 0, packetData.length);\n            packetLength = 0;\n            packetOffset = 0;\n\n            socket.receive(packet);\n\n            packetData = packet.getData();\n            packetLength = packet.getLength();\n            packetOffset = packet.getOffset();\n        }\n        while (true);\n\n        return read;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/TCPInputStream.java", "class_name": "TCPInputStream", "class_uri": "src/main/java/org/ice4j/socket/TCPInputStream.java.TCPInputStream", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "int", "classes": []}, "docstring": ""}, {"uris": "src/main/java/org/ice4j/socket/TCPInputStream.java.TCPInputStream.[long]skip(long)", "name": "skip", "arg_nums": 1, "params": [{"name": "n", "type": "long"}], "return_type": "long", "signature": "@Override\n    public long skip(long n)", "original_string": "    @Override\n    public long skip(long n)\n        throws IOException\n    {\n        // Optimizing the implementation of InputStream.skip(long) sounds like a\n        // nice idea in general. However, we do not expect the method to be used\n        // a lot. Consequently, we would rather go for simplicity.\n        return super.skip(n);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/TCPInputStream.java", "class_name": "TCPInputStream", "class_uri": "src/main/java/org/ice4j/socket/TCPInputStream.java.TCPInputStream", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "long", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/TCPInputStream.java.TCPInputStream.[void]waitWhileInRead()", "name": "waitWhileInRead", "arg_nums": 0, "params": [], "return_type": "void", "signature": "private void waitWhileInRead()", "original_string": "    private void waitWhileInRead()\n    {\n        boolean interrupted = false;\n\n        synchronized (readSyncRoot)\n        {\n            while (inRead)\n            {\n                try\n                {\n                    readSyncRoot.wait();\n                }\n                catch (InterruptedException ex)\n                {\n                    interrupted = true;\n                }\n            }\n        }\n        if (interrupted)\n            Thread.currentThread().interrupt();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/TCPInputStream.java", "class_name": "TCPInputStream", "class_uri": "src/main/java/org/ice4j/socket/TCPInputStream.java.TCPInputStream", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nWaits on {@link #readSyncRoot} while {@link #inRead} equals\n<tt>true</tt>.\n"}, {"uris": "src/main/java/org/ice4j/socket/DTLSDatagramFilter.java.DTLSDatagramFilter.[boolean]isDTLS(DatagramPacket)", "name": "isDTLS", "arg_nums": 1, "params": [{"name": "p", "type": "DatagramPacket"}], "return_type": "boolean", "signature": "public static boolean isDTLS(DatagramPacket p)", "original_string": "    public static boolean isDTLS(DatagramPacket p)\n    {\n        return p != null && isDTLS(p.getData(), p.getOffset(), p.getLength());\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DTLSDatagramFilter.java", "class_name": "DTLSDatagramFilter", "class_uri": "src/main/java/org/ice4j/socket/DTLSDatagramFilter.java.DTLSDatagramFilter", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nDetermines whether {@code p} looks like a DTLS packet.\n\n@param p the {@code DatagramPacket} to check.\n@return {@code true} if {@code p} looks like a DTLS packet; otherwise,\n{@code false}.\n"}, {"uris": "src/main/java/org/ice4j/socket/DTLSDatagramFilter.java.DTLSDatagramFilter.[boolean]isDTLS(byte[],int,int)", "name": "isDTLS", "arg_nums": 3, "params": [{"name": "data", "type": "byte[]"}, {"name": "off", "type": "int"}, {"name": "len", "type": "int"}], "return_type": "boolean", "signature": "public static boolean isDTLS(byte[] data, int off, int len)", "original_string": "    public static boolean isDTLS(byte[] data, int off, int len)\n    {\n        if (len > 0)\n        {\n            int fb = data[off] & 0xff;\n\n            return 19 < fb && fb < 64;\n        }\n\n        return false;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DTLSDatagramFilter.java", "class_name": "DTLSDatagramFilter", "class_uri": "src/main/java/org/ice4j/socket/DTLSDatagramFilter.java.DTLSDatagramFilter", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nDetermines whether the buffer represented by {@code data}, {@code off}\nand {@code len} looks like a DTLS packet.\n\n@param data the array that contains the data.\n@param off the offset.\n@param len the length.\n@return {@code true} if the buffer looks like a DTLS packet; otherwise,\n{@code false}.\n"}, {"uris": "src/main/java/org/ice4j/socket/DTLSDatagramFilter.java.DTLSDatagramFilter.[boolean]accept(DatagramPacket)", "name": "accept", "arg_nums": 1, "params": [{"name": "p", "type": "DatagramPacket"}], "return_type": "boolean", "signature": "@Override\n    public boolean accept(DatagramPacket p)", "original_string": "    @Override\n    public boolean accept(DatagramPacket p)\n    {\n        return isDTLS(p);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DTLSDatagramFilter.java", "class_name": "DTLSDatagramFilter", "class_uri": "src/main/java/org/ice4j/socket/DTLSDatagramFilter.java.DTLSDatagramFilter", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/MultiplexedDatagramSocket.java.MultiplexedDatagramSocket.[]MultiplexedDatagramSocket(MultiplexingDatagramSocket,DatagramPacketFilter)", "name": "MultiplexedDatagramSocket", "arg_nums": 2, "params": [{"name": "multiplexing", "type": "MultiplexingDatagramSocket"}, {"name": "filter", "type": "DatagramPacketFilter"}], "return_type": "", "signature": "MultiplexedDatagramSocket(\n            MultiplexingDatagramSocket multiplexing,\n            DatagramPacketFilter filter)", "original_string": "    MultiplexedDatagramSocket(\n            MultiplexingDatagramSocket multiplexing,\n            DatagramPacketFilter filter)\n        throws SocketException\n    {\n        /*\n         * Even if MultiplexingDatagramSocket allows MultiplexedDatagramSocket\n         * to perform bind, binding in the super will not execute correctly this\n         * early in the construction because the multiplexing field is not set\n         * yet. That is why MultiplexedDatagramSocket does not currently support\n         * bind at construction time.\n         */\n        super(multiplexing);\n\n        if (multiplexing == null)\n            throw new NullPointerException(\"multiplexing\");\n\n        this.multiplexing = multiplexing;\n        this.filter = filter;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MultiplexedDatagramSocket.java", "class_name": "MultiplexedDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/MultiplexedDatagramSocket.java.MultiplexedDatagramSocket", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>MultiplexedDatagramSocket</tt> which is unbound and\nfilters <tt>DatagramPacket</tt>s away from a specific\n<tt>MultiplexingDatagramSocket</tt> using a specific\n<tt>DatagramPacketFilter</tt>.\n\n@param multiplexing the <tt>MultiplexingDatagramSocket</tt> which does\nthe actual reading from the network and which forwards\n<tt>DatagramPacket</tt>s accepted by the specified <tt>filter</tt> to the\nnew instance\n@param filter the <tt>DatagramPacketFilter</tt> which determines which\n<tt>DatagramPacket</tt>s read from the network by the specified\n<tt>multiplexing</tt> are to be received through the new instance\n@throws SocketException if the socket could not be opened\n"}, {"uris": "src/main/java/org/ice4j/socket/MultiplexedDatagramSocket.java.MultiplexedDatagramSocket.[void]close()", "name": "close", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Override\n    public void close()", "original_string": "    @Override\n    public void close()\n    {\n        multiplexing.close(this);\n\n        // We intentionally do not call super.close(), because it eventually\n        // delegates to #multiplexing. We don't want to close #multiplexing\n        // just yet, because it may have other filtered sockets attached to it\n        // (or it needs to be kept open for other reasons)\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MultiplexedDatagramSocket.java", "class_name": "MultiplexedDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/MultiplexedDatagramSocket.java.MultiplexedDatagramSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCloses this datagram socket.\n<p>\nAny thread currently blocked in {@link #receive(DatagramPacket)} upon\nthis socket will throw a {@link SocketException}.\n</p>\n\n@see DatagramSocket#close()\n"}, {"uris": "src/main/java/org/ice4j/socket/MultiplexedDatagramSocket.java.MultiplexedDatagramSocket.[DatagramPacketFilter]getFilter()", "name": "getFilter", "arg_nums": 0, "params": [], "return_type": "DatagramPacketFilter", "signature": "@Override\n    public DatagramPacketFilter getFilter()", "original_string": "    @Override\n    public DatagramPacketFilter getFilter()\n    {\n        return filter;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MultiplexedDatagramSocket.java", "class_name": "MultiplexedDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/MultiplexedDatagramSocket.java.MultiplexedDatagramSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "DatagramPacketFilter", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/MultiplexedDatagramSocket.java.MultiplexedDatagramSocket.[void]receive(DatagramPacket)", "name": "receive", "arg_nums": 1, "params": [{"name": "p", "type": "DatagramPacket"}], "return_type": "void", "signature": "@Override\n    public void receive(DatagramPacket p)", "original_string": "    @Override\n    public void receive(DatagramPacket p)\n        throws IOException\n    {\n        multiplexing.receive(this, p);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MultiplexedDatagramSocket.java", "class_name": "MultiplexedDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/MultiplexedDatagramSocket.java.MultiplexedDatagramSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nReceives a datagram packet from this socket. When this method returns,\nthe <tt>DatagramPacket</tt>'s buffer is filled with the data received.\nThe datagram packet also contains the sender's IP address, and the port\nnumber on the sender's machine.\n<p>\nThis method blocks until a datagram is received. The <tt>length</tt>\nfield of the datagram packet object contains the length of the received\nmessage. If the message is longer than the packet's length, the message\nis truncated.\n</p>\n<p>\nIf there is a security manager, a packet cannot be received if the\nsecurity manager's <tt>checkAccept</tt> method does not allow it.\n</p>\n\n@param p the <tt>DatagramPacket</tt> into which to place the incoming\ndata\n@throws IOException if an I/O error occurs\n@see DatagramSocket#receive(DatagramPacket)\n"}, {"uris": "src/main/java/org/ice4j/socket/MultiplexedXXXSocket.java.MultiplexedXXXSocket.[DatagramPacketFilter]getFilter()", "name": "getFilter", "arg_nums": 0, "params": [], "return_type": "DatagramPacketFilter", "signature": "DatagramPacketFilter getFilter()", "original_string": "    DatagramPacketFilter getFilter();", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MultiplexedXXXSocket.java", "class_name": "MultiplexedXXXSocket", "class_uri": "src/main/java/org/ice4j/socket/MultiplexedXXXSocket.java.MultiplexedXXXSocket", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "DatagramPacketFilter", "classes": []}, "docstring": "\nGets the {@code DatagramPacketFilter} which determines which\n{@code DatagramPacket}s read from the network are to be received through\nthis socket.\n\n@return the {@code DatagramPacketFilter} which determines which\n{@code DatagramPacket}s read from the network are to be received through\nthis socket\n"}, {"uris": "src/main/java/org/ice4j/socket/StunDatagramPacketFilter.java.StunDatagramPacketFilter.[]StunDatagramPacketFilter()", "name": "StunDatagramPacketFilter", "arg_nums": 0, "params": [], "return_type": "", "signature": "public StunDatagramPacketFilter()", "original_string": "    public StunDatagramPacketFilter()\n    {\n        this(null);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/StunDatagramPacketFilter.java", "class_name": "StunDatagramPacketFilter", "class_uri": "src/main/java/org/ice4j/socket/StunDatagramPacketFilter.java.StunDatagramPacketFilter", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>StunDatagramPacketFilter</tt> which will accept\n<tt>DatagramPacket</tt>s which represent STUN messages received from\nany destination.\n"}, {"uris": "src/main/java/org/ice4j/socket/StunDatagramPacketFilter.java.StunDatagramPacketFilter.[]StunDatagramPacketFilter(TransportAddress)", "name": "StunDatagramPacketFilter", "arg_nums": 1, "params": [{"name": "stunServer", "type": "TransportAddress"}], "return_type": "", "signature": "public StunDatagramPacketFilter(TransportAddress stunServer)", "original_string": "    public StunDatagramPacketFilter(TransportAddress stunServer)\n    {\n        this.stunServer = stunServer;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/StunDatagramPacketFilter.java", "class_name": "StunDatagramPacketFilter", "class_uri": "src/main/java/org/ice4j/socket/StunDatagramPacketFilter.java.StunDatagramPacketFilter", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>StunDatagramPacketFilter</tt> which will accept\n<tt>DatagramPacket</tt>s which represent STUN messages and which are part\nof the communication with a specific STUN server (or any server if\n<tt>stunServer</tt> is <tt>null</tt>).\n\n@param stunServer the <tt>TransportAddress</tt> of the STUN server\n<tt>DatagramPacket</tt>s representing STUN messages from and to which\nwill be accepted by the new instance or <tt>null</tt> if we would like\nto accept stun messages from any destination.\n"}, {"uris": "src/main/java/org/ice4j/socket/StunDatagramPacketFilter.java.StunDatagramPacketFilter.[boolean]accept(DatagramPacket)", "name": "accept", "arg_nums": 1, "params": [{"name": "p", "type": "DatagramPacket"}], "return_type": "boolean", "signature": "public boolean accept(DatagramPacket p)", "original_string": "    public boolean accept(DatagramPacket p)\n    {\n        /*\n         * If we were instantiated for a specific STUN server, and the packet\n         * did not originate there, we reject it.\n         */\n        if ((stunServer != null) && !stunServer.equals(p.getSocketAddress()))\n            return false;\n\n        // If this is a STUN packet.\n        if (StunDatagramPacketFilter.isStunPacket(p))\n        {\n            byte[] data = p.getData();\n            int offset = p.getOffset();\n\n            byte b0 = data[offset];\n            byte b1 = data[offset + 1];\n            char method = (char) ((b0 & 0xFE) | (b1 & 0xEF));\n\n            return acceptMethod(method);\n        }\n        return false;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/StunDatagramPacketFilter.java", "class_name": "StunDatagramPacketFilter", "class_uri": "src/main/java/org/ice4j/socket/StunDatagramPacketFilter.java.StunDatagramPacketFilter", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nDetermines whether a specific <tt>DatagramPacket</tt> represents a STUN\nmessage and whether it is part of the communication with the STUN server\nif one was associated with this instance.\n\n@param p the <tt>DatagramPacket</tt> which is to be checked whether it is\na STUN message which is part of the communicator with the STUN server\nassociated with this instance\n@return <tt>true</tt> if the specified <tt>DatagramPacket</tt> represents\na STUN message which is part of the communication with the STUN server\nassociated with this instance; otherwise, <tt>false</tt>\n"}, {"uris": "src/main/java/org/ice4j/socket/StunDatagramPacketFilter.java.StunDatagramPacketFilter.[boolean]acceptMethod(char)", "name": "acceptMethod", "arg_nums": 1, "params": [{"name": "method", "type": "char"}], "return_type": "boolean", "signature": "protected boolean acceptMethod(char method)", "original_string": "    protected boolean acceptMethod(char method)\n    {\n        switch (method)\n        {\n        case Message.STUN_METHOD_BINDING:\n        case 0x0000:\n        case 0x0002:\n            return true;\n        default:\n            return false;\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/StunDatagramPacketFilter.java", "class_name": "StunDatagramPacketFilter", "class_uri": "src/main/java/org/ice4j/socket/StunDatagramPacketFilter.java.StunDatagramPacketFilter", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nDetermines whether this <tt>DatagramPacketFilter</tt> accepts a\n<tt>DatagramPacket</tt> which represents a STUN message with a specific\nSTUN method. <tt>StunDatagramPacketFilter</tt> only accepts the method\nBinding and the reserved methods 0x000 and 0x002/SharedSecret.\n\n@param method the STUN method of a STUN message represented by a\n<tt>DatagramPacket</tt> to be checked whether it is accepted by this\n<tt>DatagramPacketFilter</tt>\n@return <tt>true</tt> if this <tt>DatagramPacketFilter</tt> accepts the\n<tt>DatagramPacket</tt> which represents a STUN message with the\nspecified STUN method; otherwise, <tt>false</tt>\n"}, {"uris": "src/main/java/org/ice4j/socket/StunDatagramPacketFilter.java.StunDatagramPacketFilter.[boolean]equals(Object)", "name": "equals", "arg_nums": 1, "params": [{"name": "obj", "type": "Object"}], "return_type": "boolean", "signature": "@Override\n    public boolean equals(Object obj)", "original_string": "    @Override\n    public boolean equals(Object obj)\n    {\n        if (null == obj)\n            return false;\n        else if (this == obj)\n            return true;\n        else\n            return getClass().equals(obj.getClass());\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/StunDatagramPacketFilter.java", "class_name": "StunDatagramPacketFilter", "class_uri": "src/main/java/org/ice4j/socket/StunDatagramPacketFilter.java.StunDatagramPacketFilter", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nIndicates whether some other object is \"equal to\" this one.\n\n@param obj the reference object with which to compare.\n@return <tt>true</tt> if this <tt>StunDatagramPacketFilter</tt> is equal\nto the <tt>obj</tt> argument; <tt>false</tt>, otherwise.\n"}, {"uris": "src/main/java/org/ice4j/socket/StunDatagramPacketFilter.java.StunDatagramPacketFilter.[int]hashCode()", "name": "hashCode", "arg_nums": 0, "params": [], "return_type": "int", "signature": "@Override\n    public int hashCode()", "original_string": "    @Override\n    public int hashCode()\n    {\n        /*\n         * Overrides the super implementation in order to maintain the general\n         * contract of the hashCode method which states that equal objects must\n         * have equal hash codes.\n         */\n        return getClass().hashCode();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/StunDatagramPacketFilter.java", "class_name": "StunDatagramPacketFilter", "class_uri": "src/main/java/org/ice4j/socket/StunDatagramPacketFilter.java.StunDatagramPacketFilter", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\nReturns a hash code value for this object for the benefit of hashtables\nsuch as those provided by <tt>Hashtable</tt>.\n\n@return a hash code value for this object\n"}, {"uris": "src/main/java/org/ice4j/socket/StunDatagramPacketFilter.java.StunDatagramPacketFilter.[boolean]isStunPacket(DatagramPacket)", "name": "isStunPacket", "arg_nums": 1, "params": [{"name": "p", "type": "DatagramPacket"}], "return_type": "boolean", "signature": "public static boolean isStunPacket(DatagramPacket p)", "original_string": "    public static boolean isStunPacket(DatagramPacket p)\n    {\n        byte[] data = p.getData();\n        int offset = p.getOffset();\n        int length = p.getLength();\n\n        // All STUN messages MUST start with a 20-byte header followed by zero or more Attributes.\n        if (length < 20)\n        {\n            return false;\n        }\n\n        // The most significant 2 bits of every STUN message MUST be zeroes. This can be used to differentiate STUN\n        // packets from other protocols when STUN is multiplexed with other protocols on the same port.\n        if ((data[offset] & 0xC0) != 0)\n        {\n            return false;\n        }\n\n        // If the MAGIC COOKIE is present this is a STUN packet (RFC5389 compliant).\n        if (data[offset + 4] == Message.MAGIC_COOKIE[0]\n            && data[offset + 5] == Message.MAGIC_COOKIE[1]\n            && data[offset + 6] == Message.MAGIC_COOKIE[2]\n            && data[offset + 7] == Message.MAGIC_COOKIE[3])\n        {\n            return true;\n        }\n        // Else, this packet may be a STUN packet (RFC3489 compliant). To determine this, we must continue the checks.\n        else\n        {\n            // Checks if the length of the data correspond to the length field of the STUN header. The message length\n            // field of the STUN header does not include the 20-byte of the STUN header.\n            int total_header_length\n                = ((((int)data[2]) & 0xff) << 8)\n                + (((int) data[3]) & 0xff)\n                + 20;\n            return (length == total_header_length);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/StunDatagramPacketFilter.java", "class_name": "StunDatagramPacketFilter", "class_uri": "src/main/java/org/ice4j/socket/StunDatagramPacketFilter.java.StunDatagramPacketFilter", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nDetermines whether a specific <tt>DatagramPacket</tt> represents a STUN\n(or TURN) packet.\n\n@param p the <tt>DatagramPacket</tt> which is to be checked whether it is\na STUN message which is part of the communicator with the STUN server\nassociated with this instance\n\n@return True if the <tt>DatagramPacket</tt> represents a STUN\n(or TURN) packet. False, otherwise.\n"}, {"uris": "src/main/java/org/ice4j/socket/TCPOutputStream.java.TCPOutputStream.[]TCPOutputStream(OutputStream)", "name": "TCPOutputStream", "arg_nums": 1, "params": [{"name": "outputStream", "type": "OutputStream"}], "return_type": "", "signature": "public TCPOutputStream(OutputStream outputStream)", "original_string": "    public TCPOutputStream(OutputStream outputStream)\n    {\n        this.outputStream = outputStream;\n\n        // GoogleRelayedCandidateSocket will encapsulate data in TURN message so\n        // do not frame.\n        frame\n            = !(outputStream\n                    instanceof GoogleRelayedCandidateSocket.TCPOutputStream);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/TCPOutputStream.java", "class_name": "TCPOutputStream", "class_uri": "src/main/java/org/ice4j/socket/TCPOutputStream.java.TCPOutputStream", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>TCPOutputStream</tt>.\n\n@param outputStream original <tt>OutputStream</tt>\n"}, {"uris": "src/main/java/org/ice4j/socket/TCPOutputStream.java.TCPOutputStream.[void]close()", "name": "close", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Override\n    public void close()", "original_string": "    @Override\n    public void close()\n        throws IOException\n    {\n        outputStream.close();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/TCPOutputStream.java", "class_name": "TCPOutputStream", "class_uri": "src/main/java/org/ice4j/socket/TCPOutputStream.java.TCPOutputStream", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/TCPOutputStream.java.TCPOutputStream.[void]flush()", "name": "flush", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Override\n    public void flush()", "original_string": "    @Override\n    public void flush()\n        throws IOException\n    {\n        outputStream.flush();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/TCPOutputStream.java", "class_name": "TCPOutputStream", "class_uri": "src/main/java/org/ice4j/socket/TCPOutputStream.java.TCPOutputStream", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/TCPOutputStream.java.TCPOutputStream.[void]write(byte[],int,int)", "name": "write", "arg_nums": 3, "params": [{"name": "b", "type": "byte[]"}, {"name": "off", "type": "int"}, {"name": "len", "type": "int"}], "return_type": "void", "signature": "@Override\n    public void write(byte[] b, int off, int len)", "original_string": "    @Override\n    public void write(byte[] b, int off, int len)\n        throws IOException\n    {\n        if (frame)\n        {\n            int newLen = len + 2;\n            byte newB[] = new byte[newLen];\n\n            newB[0] = (byte) ((len >> 8) & 0xFF);\n            newB[1] = (byte) (len & 0xFF);\n            System.arraycopy(b, off, newB, 2, len);\n            outputStream.write(newB, 0, newLen);\n        }\n        else\n        {\n            outputStream.write(b, off, len);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/TCPOutputStream.java", "class_name": "TCPOutputStream", "class_uri": "src/main/java/org/ice4j/socket/TCPOutputStream.java.TCPOutputStream", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/TCPOutputStream.java.TCPOutputStream.[void]write(int)", "name": "write", "arg_nums": 1, "params": [{"name": "b", "type": "int"}], "return_type": "void", "signature": "@Override\n    public void write(int b)", "original_string": "    @Override\n    public void write(int b)\n        throws IOException\n    {\n        // TODO Auto-generated method stub\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/TCPOutputStream.java", "class_name": "TCPOutputStream", "class_uri": "src/main/java/org/ice4j/socket/TCPOutputStream.java.TCPOutputStream", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/MultiplexedSocket.java.MultiplexedSocket.[]MultiplexedSocket(MultiplexingSocket,DatagramPacketFilter)", "name": "MultiplexedSocket", "arg_nums": 2, "params": [{"name": "multiplexing", "type": "MultiplexingSocket"}, {"name": "filter", "type": "DatagramPacketFilter"}], "return_type": "", "signature": "MultiplexedSocket(\n            MultiplexingSocket multiplexing,\n            DatagramPacketFilter filter)", "original_string": "    MultiplexedSocket(\n            MultiplexingSocket multiplexing,\n            DatagramPacketFilter filter)\n        throws SocketException\n    {\n        /*\n         * Even if MultiplexingSocket allows MultiplexedSocket to perform bind,\n         * binding in the super will not execute correctly this early in the\n         * construction because the multiplexing field is not set yet. That is\n         * why MultiplexedSocket does not currently support bind at construction\n         * time.\n         */\n        super(multiplexing);\n\n        if (multiplexing == null)\n            throw new NullPointerException(\"multiplexing\");\n\n        this.multiplexing = multiplexing;\n        this.filter = filter;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MultiplexedSocket.java", "class_name": "MultiplexedSocket", "class_uri": "src/main/java/org/ice4j/socket/MultiplexedSocket.java.MultiplexedSocket", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>MultiplexedSocket</tt> which is unbound and filters\n<tt>DatagramPacket</tt>s away from a specific <tt>MultiplexingSocket</tt>\nusing a specific <tt>DatagramPacketFilter</tt>.\n\n@param multiplexing the <tt>MultiplexingSocket</tt> which does the actual\nreading from the network and which forwards <tt>DatagramPacket</tt>s\naccepted by the specified <tt>filter</tt> to the new instance\n@param filter the <tt>DatagramPacketFilter</tt> which determines which\n<tt>DatagramPacket</tt>s read from the network by the specified\n<tt>multiplexing</tt> are to be received through the new instance\n@throws SocketException if the socket could not be opened\n"}, {"uris": "src/main/java/org/ice4j/socket/MultiplexedSocket.java.MultiplexedSocket.[void]close()", "name": "close", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Override\n    public void close()", "original_string": "    @Override\n    public void close()\n    {\n        multiplexing.close(this);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MultiplexedSocket.java", "class_name": "MultiplexedSocket", "class_uri": "src/main/java/org/ice4j/socket/MultiplexedSocket.java.MultiplexedSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCloses this datagram socket.\n<p>\nAny thread currently blocked in {@link #receive(DatagramPacket)} upon\nthis socket will throw a {@link SocketException}.\n</p>\n\n@see Socket#close()\n"}, {"uris": "src/main/java/org/ice4j/socket/MultiplexedSocket.java.MultiplexedSocket.[DatagramPacketFilter]getFilter()", "name": "getFilter", "arg_nums": 0, "params": [], "return_type": "DatagramPacketFilter", "signature": "@Override\n    public DatagramPacketFilter getFilter()", "original_string": "    @Override\n    public DatagramPacketFilter getFilter()\n    {\n        return filter;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MultiplexedSocket.java", "class_name": "MultiplexedSocket", "class_uri": "src/main/java/org/ice4j/socket/MultiplexedSocket.java.MultiplexedSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "DatagramPacketFilter", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/MultiplexedSocket.java.MultiplexedSocket.[InputStream]getInputStream()", "name": "getInputStream", "arg_nums": 0, "params": [], "return_type": "InputStream", "signature": "@Override\n    public InputStream getInputStream()", "original_string": "    @Override\n    public InputStream getInputStream()\n    {\n        return inputStream;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MultiplexedSocket.java", "class_name": "MultiplexedSocket", "class_uri": "src/main/java/org/ice4j/socket/MultiplexedSocket.java.MultiplexedSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "InputStream", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/MultiplexedSocket.java.MultiplexedSocket.[void]receive(DatagramPacket)", "name": "receive", "arg_nums": 1, "params": [{"name": "p", "type": "DatagramPacket"}], "return_type": "void", "signature": "@Override\n    public void receive(DatagramPacket p)", "original_string": "    @Override\n    public void receive(DatagramPacket p)\n        throws IOException\n    {\n        multiplexing.receive(this, p);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MultiplexedSocket.java", "class_name": "MultiplexedSocket", "class_uri": "src/main/java/org/ice4j/socket/MultiplexedSocket.java.MultiplexedSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nReceives a datagram packet from this socket. When this method returns,\nthe <tt>DatagramPacket</tt>'s buffer is filled with the data received.\nThe datagram packet also contains the sender's IP address, and the port\nnumber on the sender's machine.\n<p>\nThis method blocks until a datagram is received. The <tt>length</tt>\nfield of the datagram packet object contains the length of the received\nmessage. If the message is longer than the packet's length, the message\nis truncated.\n</p>\n\n@param p the <tt>DatagramPacket</tt> into which to place the incoming\ndata\n@throws IOException if an I/O error occurs\n@see MultiplexingSocket#receive(DatagramPacket)\n"}, {"uris": "src/main/java/org/ice4j/socket/MergingDatagramSocket.java.MergingDatagramSocket.[]MergingDatagramSocket()", "name": "MergingDatagramSocket", "arg_nums": 0, "params": [], "return_type": "", "signature": "public MergingDatagramSocket()", "original_string": "    public MergingDatagramSocket()\n            throws SocketException\n    {\n        this(null);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MergingDatagramSocket.java", "class_name": "MergingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/MergingDatagramSocket.java.MergingDatagramSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new {@link MergingDatagramSocket} instance.\n@throws SocketException\n"}, {"uris": "src/main/java/org/ice4j/socket/MergingDatagramSocket.java.MergingDatagramSocket.[]MergingDatagramSocket(Logger)", "name": "MergingDatagramSocket", "arg_nums": 1, "params": [{"name": "parentLogger", "type": "Logger"}], "return_type": "", "signature": "public MergingDatagramSocket(Logger parentLogger)", "original_string": "    public MergingDatagramSocket(Logger parentLogger)\n            throws SocketException\n    {\n        logger = parentLogger.createChildLogger(this.getClass().getName());\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MergingDatagramSocket.java", "class_name": "MergingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/MergingDatagramSocket.java.MergingDatagramSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new {@link MergingDatagramSocket} instance.\n@param parentLogger the {@link Logger} parent logger from which we'll\n                    derive this class' logger instance\n@throws SocketException\n"}, {"uris": "src/main/java/org/ice4j/socket/MergingDatagramSocket.java.MergingDatagramSocket.[boolean]isClosed()", "name": "isClosed", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "@Override\n    public boolean isClosed()", "original_string": "    @Override\n    public boolean isClosed()\n    {\n        return closed;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MergingDatagramSocket.java", "class_name": "MergingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/MergingDatagramSocket.java.MergingDatagramSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/MergingDatagramSocket.java.MergingDatagramSocket.[void]close()", "name": "close", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Override\n    public void close()", "original_string": "    @Override\n    public void close()\n    {\n        try\n        {\n            super.close();\n        }\n        finally\n        {\n\n            if (isClosed())\n            {\n                return;\n            }\n            closed = true;\n            logger.info(\"Closing.\");\n\n            // XXX do we want to risk obtaining the lock here, or should we just\n            // let any thread in receive() find out about the close after it's\n            // next timeout?\n            synchronized (receiveLock)\n            {\n                receiveLock.notifyAll();\n            }\n\n            synchronized (socketContainersSyncRoot)\n            {\n                active = null;\n                for (SocketContainer container : socketContainers)\n                {\n                    container.close(false);\n                }\n                socketContainers = new SocketContainer[0];\n            }\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MergingDatagramSocket.java", "class_name": "MergingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/MergingDatagramSocket.java.MergingDatagramSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/MergingDatagramSocket.java.MergingDatagramSocket.[void]setSoTimeout(int)", "name": "setSoTimeout", "arg_nums": 1, "params": [{"name": "soTimeout", "type": "int"}], "return_type": "void", "signature": "@Override\n    public void setSoTimeout(int soTimeout)", "original_string": "    @Override\n    public void setSoTimeout(int soTimeout)\n    {\n        this.soTimeout = soTimeout;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MergingDatagramSocket.java", "class_name": "MergingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/MergingDatagramSocket.java.MergingDatagramSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/MergingDatagramSocket.java.MergingDatagramSocket.[int]getSoTimeout()", "name": "getSoTimeout", "arg_nums": 0, "params": [], "return_type": "int", "signature": "@Override\n    public int getSoTimeout()", "original_string": "    @Override\n    public int getSoTimeout()\n    {\n        return soTimeout;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MergingDatagramSocket.java", "class_name": "MergingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/MergingDatagramSocket.java.MergingDatagramSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/MergingDatagramSocket.java.MergingDatagramSocket.[void]send(DatagramPacket)", "name": "send", "arg_nums": 1, "params": [{"name": "pkt", "type": "DatagramPacket"}], "return_type": "void", "signature": "@Override\n    public void send(DatagramPacket pkt)", "original_string": "    @Override\n    public void send(DatagramPacket pkt)\n        throws IOException\n    {\n        SocketContainer active = getActiveSocket();\n        if (active != null)\n        {\n            active.send(pkt);\n        }\n        else\n        {\n            throw new IOException(\"No active socket.\");\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MergingDatagramSocket.java", "class_name": "MergingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/MergingDatagramSocket.java.MergingDatagramSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\n{@inheritDoc}\n<p/>\nThe current implementation delegates to the first container, but this is\nsubject to change.\n\n@param pkt the datagram to send.\n@throws IOException\n"}, {"uris": "src/main/java/org/ice4j/socket/MergingDatagramSocket.java.MergingDatagramSocket.[void]add(DelegatingSocket)", "name": "add", "arg_nums": 1, "params": [{"name": "socket", "type": "DelegatingSocket"}], "return_type": "void", "signature": "public void add(DelegatingSocket socket)", "original_string": "    public void add(DelegatingSocket socket)\n    {\n        Objects.requireNonNull(socket, \"socket\");\n        logger.debug(() -> \"Adding a DelegatingSocket instance: \"\n                        + socket.getLocalAddress());\n        doAdd(socket);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MergingDatagramSocket.java", "class_name": "MergingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/MergingDatagramSocket.java.MergingDatagramSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nAdds a {@link DelegatingSocket} instance to this merging socket. Note\nthat this will start a thread reading from the added socket.\n@param socket the socket to add.\n"}, {"uris": "src/main/java/org/ice4j/socket/MergingDatagramSocket.java.MergingDatagramSocket.[void]add(IceSocketWrapper)", "name": "add", "arg_nums": 1, "params": [{"name": "wrapper", "type": "IceSocketWrapper"}], "return_type": "void", "signature": "public void add(IceSocketWrapper wrapper)", "original_string": "    public void add(IceSocketWrapper wrapper)\n    {\n        Object socket = wrapper.getUDPSocket();\n        if (socket == null)\n        {\n            socket = wrapper.getTCPSocket();\n        }\n        doAdd(socket);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MergingDatagramSocket.java", "class_name": "MergingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/MergingDatagramSocket.java.MergingDatagramSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nAdds the socket instance wrapped by {@code wrapper} to this merging\nsocket. Note that this will start a thread reading from the added socket.\n@param wrapper the wrapper of the socket to add.\n"}, {"uris": "src/main/java/org/ice4j/socket/MergingDatagramSocket.java.MergingDatagramSocket.[void]add(DatagramSocket)", "name": "add", "arg_nums": 1, "params": [{"name": "socket", "type": "DatagramSocket"}], "return_type": "void", "signature": "public void add(DatagramSocket socket)", "original_string": "    public void add(DatagramSocket socket)\n    {\n        Objects.requireNonNull(socket, \"socket\");\n        logger.debug(() -> \"Adding a DatagramSocket instance: \"\n                + socket.getLocalAddress());\n        doAdd(socket);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MergingDatagramSocket.java", "class_name": "MergingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/MergingDatagramSocket.java.MergingDatagramSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nAdds a {@link DatagramSocket} instance to this merging socket. Note\nthat this will start a thread reading from the added socket.\n@param socket the socket to add.\n"}, {"uris": "src/main/java/org/ice4j/socket/MergingDatagramSocket.java.MergingDatagramSocket.[void]doAdd(Object)", "name": "doAdd", "arg_nums": 1, "params": [{"name": "socket", "type": "Object"}], "return_type": "void", "signature": "private void doAdd(Object socket)", "original_string": "    private void doAdd(Object socket)\n    {\n        Objects.requireNonNull(socket, \"socket\");\n\n        if (!(socket instanceof DelegatingSocket) &&\n            !(socket instanceof DatagramSocket))\n        {\n            throw new IllegalStateException(\"Socket type not supported: \"\n                    + socket.getClass().getName());\n        }\n\n        synchronized (socketContainersSyncRoot)\n        {\n            if (indexOf(socketContainers, socket) != -1)\n            {\n                logger.warn(\"Socket already added.\");\n                return;\n            }\n\n            SocketContainer socketContainer;\n            if (socket instanceof DelegatingSocket)\n            {\n                socketContainer = new SocketContainer((DelegatingSocket) socket);\n            }\n            else\n            {\n                socketContainer = new SocketContainer((DatagramSocket) socket);\n            }\n\n            SocketContainer[] newSocketContainers\n                = new SocketContainer[socketContainers.length + 1];\n            System.arraycopy(socketContainers, 0,\n                             newSocketContainers, 0,\n                             socketContainers.length);\n            newSocketContainers[socketContainers.length] = socketContainer;\n\n            socketContainers = newSocketContainers;\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MergingDatagramSocket.java", "class_name": "MergingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/MergingDatagramSocket.java.MergingDatagramSocket", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nAdds a socket (either a {@link DatagramSocket} or a\n{@link DelegatingSocket}) to the list of underlying sockets merged by\nthis {@link MergingDatagramSocket}.\n@param socket the socket to add.\n"}, {"uris": "src/main/java/org/ice4j/socket/MergingDatagramSocket.java.MergingDatagramSocket.[void]remove(DatagramSocket)", "name": "remove", "arg_nums": 1, "params": [{"name": "socket", "type": "DatagramSocket"}], "return_type": "void", "signature": "public void remove(DatagramSocket socket)", "original_string": "    public void remove(DatagramSocket socket)\n    {\n        doRemove(socket);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MergingDatagramSocket.java", "class_name": "MergingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/MergingDatagramSocket.java.MergingDatagramSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nRemoves a specific {@link DatagramSocket} from the list of sockets\nmerged by this {@link MergingDatagramSocket}.\n@param socket the {@link DatagramSocket} to remove.\n"}, {"uris": "src/main/java/org/ice4j/socket/MergingDatagramSocket.java.MergingDatagramSocket.[void]remove(DelegatingSocket)", "name": "remove", "arg_nums": 1, "params": [{"name": "socket", "type": "DelegatingSocket"}], "return_type": "void", "signature": "public void remove(DelegatingSocket socket)", "original_string": "    public void remove(DelegatingSocket socket)\n    {\n        doRemove(socket);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MergingDatagramSocket.java", "class_name": "MergingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/MergingDatagramSocket.java.MergingDatagramSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nRemoves a specific {@link DelegatingSocket} from the list of sockets\nmerged by this {@link MergingDatagramSocket}.\n@param socket the {@link DelegatingSocket} to remove.\n"}, {"uris": "src/main/java/org/ice4j/socket/MergingDatagramSocket.java.MergingDatagramSocket.[void]doRemove(Object)", "name": "doRemove", "arg_nums": 1, "params": [{"name": "socket", "type": "Object"}], "return_type": "void", "signature": "private void doRemove(Object socket)", "original_string": "    private void doRemove(Object socket)\n    {\n        SocketContainer socketContainer = null;\n\n        synchronized (socketContainersSyncRoot)\n        {\n            int i = indexOf(socketContainers, socket);\n            if (i >= 0)\n            {\n                socketContainer = socketContainers[i];\n\n                SocketContainer[] newSockets\n                    = new SocketContainer[socketContainers.length - 1];\n                if (i > 0)\n                {\n                    System.arraycopy(socketContainers, 0,\n                                     newSockets, 0,\n                                     i);\n                }\n                if (i < socketContainers.length - 1)\n                {\n                    System.arraycopy(socketContainers, i + 1,\n                                     newSockets, i,\n                                     socketContainers.length - i - 1);\n                }\n\n                socketContainers = newSockets;\n\n                if (socketContainer == active)\n                {\n                    // TODO: proper selection of a new active socket\n                    logger.warn(\n                        \"Removing the active socket. Won't be able to send \"\n                        + \"until a new one is elected.\");\n                    active = null;\n                }\n            }\n            else\n            {\n                logger.error(\"Cannot find socket to remove.\");\n            }\n        }\n\n        if (logger.isDebugEnabled())\n        {\n            logger.debug(\"Removed: \" + socketContainer);\n        }\n        if (socketContainer != null)\n        {\n            // We just removed it from the merging socket, so use remove=false\n            socketContainer.close(false);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MergingDatagramSocket.java", "class_name": "MergingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/MergingDatagramSocket.java.MergingDatagramSocket", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nRemoves a socket from the list of sockets merged by this\n{@link MergingDatagramSocket}.\n@param socket the socket to remove.\n"}, {"uris": "src/main/java/org/ice4j/socket/MergingDatagramSocket.java.MergingDatagramSocket.[int]indexOf(SocketContainer[],Object)", "name": "indexOf", "arg_nums": 2, "params": [{"name": "socketContainers", "type": "SocketContainer[]"}, {"name": "socket", "type": "Object"}], "return_type": "int", "signature": "private int indexOf(SocketContainer[] socketContainers, Object socket)", "original_string": "    private int indexOf(SocketContainer[] socketContainers, Object socket)\n    {\n        for (int i = 0; i < socketContainers.length; i++)\n        {\n            if (socketContainers[i].datagramSocket == socket ||\n                socketContainers[i].delegatingSocket == socket)\n            {\n                return i;\n            }\n        }\n        return -1;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MergingDatagramSocket.java", "class_name": "MergingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/MergingDatagramSocket.java.MergingDatagramSocket", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\nReturns the index in {@link #socketContainers} of the\n{@link SocketContainer} with socket equal to {@code socket}, or -1 if\nsuch a {@link SocketContainer} doesn't exist.\n\n@param socket the {@link DatagramSocket} to get the index of.\n@return the index in {@link #socketContainers} of the\n{@link SocketContainer} with socket equal to {@code socket}, or -1 if\nsuch a {@link SocketContainer} doesn't exist.\n"}, {"uris": "src/main/java/org/ice4j/socket/MergingDatagramSocket.java.MergingDatagramSocket.[SocketContainer]getActiveSocket()", "name": "getActiveSocket", "arg_nums": 0, "params": [], "return_type": "SocketContainer", "signature": "protected SocketContainer getActiveSocket()", "original_string": "    protected SocketContainer getActiveSocket()\n    {\n        return this.active;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MergingDatagramSocket.java", "class_name": "MergingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/MergingDatagramSocket.java.MergingDatagramSocket", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "SocketContainer", "classes": []}, "docstring": "\nTODO\n"}, {"uris": "src/main/java/org/ice4j/socket/MergingDatagramSocket.java.MergingDatagramSocket.[InetAddress]getLocalAddress()", "name": "getLocalAddress", "arg_nums": 0, "params": [], "return_type": "InetAddress", "signature": "@Override\n    public InetAddress getLocalAddress()", "original_string": "    @Override\n    public InetAddress getLocalAddress()\n    {\n        SocketContainer activeSocket = getActiveSocket();\n        return activeSocket == null ? null : activeSocket.getLocalAddress();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MergingDatagramSocket.java", "class_name": "MergingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/MergingDatagramSocket.java.MergingDatagramSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "InetAddress", "classes": []}, "docstring": "\n{@inheritDoc}\n</p>\nDelegates to the \"active\" socket, if one exists. Else returns\n{@code null}.\n"}, {"uris": "src/main/java/org/ice4j/socket/MergingDatagramSocket.java.MergingDatagramSocket.[int]getLocalPort()", "name": "getLocalPort", "arg_nums": 0, "params": [], "return_type": "int", "signature": "@Override\n    public int getLocalPort()", "original_string": "    @Override\n    public int getLocalPort()\n    {\n        SocketContainer activeSocket = getActiveSocket();\n        return activeSocket == null ? 0 : activeSocket.getLocalPort();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MergingDatagramSocket.java", "class_name": "MergingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/MergingDatagramSocket.java.MergingDatagramSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\n{@inheritDoc}\n</p>\nDelegates to the \"active\" socket, if one exists. Else returns\n{@code 0}.\nTODO: should we return 0 (unbound) or -1 (closed) if there are no\nsockets?\n"}, {"uris": "src/main/java/org/ice4j/socket/MergingDatagramSocket.java.MergingDatagramSocket.[SocketAddress]getLocalSocketAddress()", "name": "getLocalSocketAddress", "arg_nums": 0, "params": [], "return_type": "SocketAddress", "signature": "@Override\n    public SocketAddress getLocalSocketAddress()", "original_string": "    @Override\n    public SocketAddress getLocalSocketAddress()\n    {\n        SocketContainer activeSocket = getActiveSocket();\n        return\n            activeSocket == null ? null : activeSocket.getLocalSocketAddress();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MergingDatagramSocket.java", "class_name": "MergingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/MergingDatagramSocket.java.MergingDatagramSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "SocketAddress", "classes": []}, "docstring": "\n{@inheritDoc}\n</p>\nDelegates to the \"active\" socket, if one exists. Else returns\n{@code null}.\n"}, {"uris": "src/main/java/org/ice4j/socket/MergingDatagramSocket.java.MergingDatagramSocket.[boolean]accept(DatagramPacket)", "name": "accept", "arg_nums": 1, "params": [{"name": "p", "type": "DatagramPacket"}], "return_type": "boolean", "signature": "protected boolean accept(DatagramPacket p)", "original_string": "    protected boolean accept(DatagramPacket p)\n    {\n        // By default we accept all packets, and allow extending classes to\n        // override\n        return true;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MergingDatagramSocket.java", "class_name": "MergingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/MergingDatagramSocket.java.MergingDatagramSocket", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nChecks whether a particular {@link DatagramPacket}, received from one of\nthe underlying sockets of thins merging socket, should be accepted and\nprovided for reception from this {@link MergingDatagramSocket}.\n@param p the packet for which to decide whether to accept it or not.\n@return {@code true} iff {@code p} should be accepted.\n"}, {"uris": "src/main/java/org/ice4j/socket/MergingDatagramSocket.java.MergingDatagramSocket.[void]receive(DatagramPacket)", "name": "receive", "arg_nums": 1, "params": [{"name": "p", "type": "DatagramPacket"}], "return_type": "void", "signature": "@Override\n    public void receive(DatagramPacket p)", "original_string": "    @Override\n    public void receive(DatagramPacket p)\n            throws SocketTimeoutException,\n                   SocketClosedException\n    {\n        long start = System.currentTimeMillis();\n        int soTimeout = this.soTimeout;\n\n        // We need to hold the lock while checking for an available packet,\n        // otherwise we might end up wait()-ing if a packet becomes available\n        // after our check.\n        // We keep the loop inside the lock, because this prevents us from\n        // having to re-obtain the lock after wait() returns. All operations\n        // inside the block are non-blocking, except for wait(), so we run no\n        // risk of causing a deadlock by doing so.\n        synchronized (receiveLock)\n        {\n            do\n            {\n                if (isClosed())\n                {\n                    throw new SocketClosedException();\n                }\n\n                // Find the input socket with the oldest packet\n                SocketContainer[] socketContainers = this.socketContainers;\n                SocketContainer socketToReceiveFrom = null;\n                long firstTime = -1;\n                for (SocketContainer socketContainer : socketContainers)\n                {\n                    long f = socketContainer.getFirstReceivedTime();\n                    if (f > 0)\n                    {\n                        if (firstTime == -1 || firstTime > f)\n                        {\n                            firstTime = f;\n                            socketToReceiveFrom = socketContainer;\n                        }\n                    }\n                }\n\n                // If a packet is available, receive it\n                if (socketToReceiveFrom != null)\n                {\n                    socketToReceiveFrom.receive(p);\n\n                    if (accept(p))\n                    {\n                        socketToReceiveFrom.accepted(p);\n                        return;\n                    }\n                    else\n                    {\n                        numDiscardedPackets++;\n                        if (numDiscardedPackets % 100 == 1)\n                        {\n                            logger.info(\"Discarded \" + numDiscardedPackets\n                                    + \" packets. Last remote address:\"\n                                    + TransportAddress.redact(p.getSocketAddress()));\n                        }\n\n                        // Go on and receive the next packet in p.\n                        continue;\n                    }\n                }\n                // Otherwise wait on receiveLock.\n                else\n                {\n                    long waitTimeout = 500;\n                    if (soTimeout > 0)\n                    {\n                        long remaining\n                            = start + soTimeout\n                                    - System.currentTimeMillis();\n                        if (remaining <= 0)\n                            throw new SocketTimeoutException();\n\n                        waitTimeout = Math.min(waitTimeout, remaining);\n                    }\n                    try\n                    {\n                        receiveLock.wait(waitTimeout);\n                    }\n                    catch (InterruptedException ie)\n                    {\n                        Thread.currentThread().interrupt();\n                        // We haven't received a packet, but what else can we\n                        // do?\n                        return;\n                    }\n                }\n            }\n            while (true);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MergingDatagramSocket.java", "class_name": "MergingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/MergingDatagramSocket.java.MergingDatagramSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\n{@inheritDoc}\n</p>\nCopies into {@code p} a packet already received from one of the\nunderlying sockets. The socket is chosen on the base of the timestamp\nof the reception of the first packet in its queue (so that earlier\npackets are received first).\n@throws SocketTimeoutException if a socket timeout is set, and the\ncall fails to receive a packet within the timeout.\n@throws SocketClosedException if the socket is closed while\n"}, {"uris": "src/main/java/org/ice4j/socket/MergingDatagramSocket.java.MergingDatagramSocket.[void]initializeActive(IceSocketWrapper,TransportAddress)", "name": "initializeActive", "arg_nums": 2, "params": [{"name": "socketWrapper", "type": "IceSocketWrapper"}, {"name": "remoteAddress", "type": "TransportAddress"}], "return_type": "void", "signature": "protected void initializeActive(IceSocketWrapper socketWrapper,\n                                    TransportAddress remoteAddress)", "original_string": "    protected void initializeActive(IceSocketWrapper socketWrapper,\n                                    TransportAddress remoteAddress)\n    {\n        Object socket = socketWrapper.getTCPSocket();\n        if (socket == null)\n        {\n            socket = socketWrapper.getUDPSocket();\n        }\n\n        if (logger.isDebugEnabled())\n        {\n            logger.debug(\"Initializing the active container, socket=\" + socket\n                    + \"; remote address=\" + TransportAddress.redact(remoteAddress));\n        }\n\n        synchronized (socketContainersSyncRoot)\n        {\n            if (active != null)\n            {\n                // This means that we've received data before ICE completed.\n                // That is, the remote side sent application data, and our\n                // application invoked receive(). Though maybe unusual, this\n                // is not necessarily incorrect.\n                // Still, go on and replace the active socket with whatever\n                // ICE selected.\n                logger.warn(\"Active socket already initialized.\");\n            }\n\n            SocketContainer newActive = null;\n            for (SocketContainer container : socketContainers)\n            {\n                if (socket == container.datagramSocket\n                    || socket == container.delegatingSocket)\n                {\n                    newActive = container;\n                    break;\n                }\n            }\n\n            if (newActive == null)\n            {\n                logger.error(\"No SocketContainer found!\");\n                return;\n            }\n\n            newActive.remoteAddress = remoteAddress;\n            active = newActive;\n\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MergingDatagramSocket.java", "class_name": "MergingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/MergingDatagramSocket.java.MergingDatagramSocket", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nInitializes the active socket of this {@link MergingDatagramSocket}.\n@param socketWrapper the {@link IceSocketWrapper} instance wrapping the\nactual socket that should be used. Used to find the correct\n{@link SocketContainer}\n@param remoteAddress the remote address which was selected by ICE and\nand which should be used as the target.\n"}, {"uris": "src/main/java/org/ice4j/socket/DatagramSocketFactory.java.DatagramSocketFactory.[DatagramSocket]createUnboundDatagramSocket()", "name": "createUnboundDatagramSocket", "arg_nums": 0, "params": [], "return_type": "DatagramSocket", "signature": "public DatagramSocket createUnboundDatagramSocket()", "original_string": "    public DatagramSocket createUnboundDatagramSocket()\n        throws SocketException;", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DatagramSocketFactory.java", "class_name": "DatagramSocketFactory", "class_uri": "src/main/java/org/ice4j/socket/DatagramSocketFactory.java.DatagramSocketFactory", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "DatagramSocket", "classes": []}, "docstring": "\nCreates an unbound DatagramSocket:\n- i.e <tt>return new DatagramSocket((SocketAddress) null)</tt>.\n\n@return An unbound DatagramSocket.\n\n@throws SocketException if the socket could not be opened.\n"}, {"uris": "src/main/java/org/ice4j/socket/DatagramPacketFilter.java.DatagramPacketFilter.[boolean]accept(DatagramPacket)", "name": "accept", "arg_nums": 1, "params": [{"name": "p", "type": "DatagramPacket"}], "return_type": "boolean", "signature": "public boolean accept(DatagramPacket p)", "original_string": "    public boolean accept(DatagramPacket p);", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DatagramPacketFilter.java", "class_name": "DatagramPacketFilter", "class_uri": "src/main/java/org/ice4j/socket/DatagramPacketFilter.java.DatagramPacketFilter", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nDetermines whether a specific <tt>DatagramPacket</tt> is accepted by this\nfilter i.e. whether the caller should include the specified\n<tt>DatagramPacket</tt> in a selection based on this filter.\n\n@param p the <tt>DatagramPacket</tt> which is to be checked whether it is\naccepted by this filter\n@return <tt>true</tt> if this filter accepts the specified\n<tt>DatagramPacket</tt> i.e. if the caller should include the specified\n<tt>DatagramPacket</tt> in a selection based on this filter; otherwise,\n<tt>false</tt>\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[void]setDefaultDelegateFactory(DatagramSocketFactory)", "name": "setDefaultDelegateFactory", "arg_nums": 1, "params": [{"name": "factory", "type": "DatagramSocketFactory"}], "return_type": "void", "signature": "public static void setDefaultDelegateFactory(DatagramSocketFactory factory)", "original_string": "    public static void setDefaultDelegateFactory(DatagramSocketFactory factory)\n    {\n        delegateFactory = factory;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java", "class_name": "DelegatingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nIf a factory is provided, then any new instances of\nDelegatingDatagramSocket will automatically use a socket from  the\nfactory instead of the super class.\n\nIf this method is used, the factory class needs to ensure the socket\nobjects are properly constructed and initialized - in particular, any\ndefault receive buffer size specified through\nDelegatingDatagramSocket#setDefaultReceiveBufferSize() won't\nautomatically be applied to sockets obtain from the factory.\n\n@param factory The factory assigned to generates the new DatagramSocket\nfor each new DelegatingDatagramSocket which do not use a delegate socket.\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[void]setDefaultReceiveBufferSize(int)", "name": "setDefaultReceiveBufferSize", "arg_nums": 1, "params": [{"name": "size", "type": "int"}], "return_type": "void", "signature": "public static void setDefaultReceiveBufferSize(int size)", "original_string": "    public static void setDefaultReceiveBufferSize(int size)\n    {\n        defaultReceiveBufferSize = size;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java", "class_name": "DelegatingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSpecifies a default receive buffer size for the underlying sockets.\nThis function must be called before using the DelegatingDatagramSocket\nconstructor. The size must be greater than 0 to be effective.\n\n@see DatagramSocket#setReceiveBufferSize(int) for a discussion of the\neffect of changing this setting.\n\n@param size the size to which to set the receive buffer size. This value\nmust be greater than 0.\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[boolean]logNonStun(long)", "name": "logNonStun", "arg_nums": 1, "params": [{"name": "numOfPacket", "type": "long"}], "return_type": "boolean", "signature": "static boolean logNonStun(long numOfPacket)", "original_string": "    static boolean logNonStun(long numOfPacket)\n    {\n        return (numOfPacket == 1)\n                || (numOfPacket == 300)\n                || (numOfPacket == 500)\n                || (numOfPacket == 1000)\n                || ((numOfPacket % 5000) == 0);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java", "class_name": "DelegatingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nDetermines whether a packet should be logged, given the number of sent\nor received packets.\n\n@param numOfPacket the number of packets sent or received.\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[]DelegatingDatagramSocket()", "name": "DelegatingDatagramSocket", "arg_nums": 0, "params": [], "return_type": "", "signature": "public DelegatingDatagramSocket()", "original_string": "    public DelegatingDatagramSocket()\n        throws SocketException\n    {\n        this(null, new InetSocketAddress(0));\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java", "class_name": "DelegatingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>DelegatingDatagramSocket</tt> instance and binds it\nto any available port on the local host machine.  The socket will be\nbound to the wildcard address, an IP address chosen by the kernel.\n\n@throws SocketException if the socket could not be opened, or the socket\ncould not bind to the specified local port\n@see DatagramSocket#DatagramSocket()\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[]DelegatingDatagramSocket(DatagramSocket)", "name": "DelegatingDatagramSocket", "arg_nums": 1, "params": [{"name": "delegate", "type": "DatagramSocket"}], "return_type": "", "signature": "public DelegatingDatagramSocket(DatagramSocket delegate)", "original_string": "    public DelegatingDatagramSocket(DatagramSocket delegate)\n        throws SocketException\n    {\n        this(delegate, null);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java", "class_name": "DelegatingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>DelegatingDatagramSocket</tt> instance which to\nimplement the <tt>DatagramSocket</tt> functionality by delegating to a\nspecific <tt>DatagramSocket</tt>.\n\n@param delegate the <tt>DatagramSocket</tt> to which the new instance is\nto delegate\n@throws SocketException if anything goes wrong while initializing the new\n<tt>DelegatingDatagramSocket</tt> instance\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[]DelegatingDatagramSocket(int)", "name": "DelegatingDatagramSocket", "arg_nums": 1, "params": [{"name": "port", "type": "int"}], "return_type": "", "signature": "public DelegatingDatagramSocket(int port)", "original_string": "    public DelegatingDatagramSocket(int port)\n        throws SocketException\n    {\n        this(null, new InetSocketAddress(port));\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java", "class_name": "DelegatingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>DelegatingDatagramSocket</tt> instance  and binds\nit to the specified port on the local host machine.  The socket will be\nbound to the wildcard address, an IP address chosen by the kernel.\n\n@param port the port to bind the new socket to\n@throws SocketException if the socket could not be opened, or the socket\ncould not bind to the specified local port\n@see DatagramSocket#DatagramSocket(int)\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[]DelegatingDatagramSocket(int,InetAddress)", "name": "DelegatingDatagramSocket", "arg_nums": 2, "params": [{"name": "port", "type": "int"}, {"name": "laddr", "type": "InetAddress"}], "return_type": "", "signature": "public DelegatingDatagramSocket(int port, InetAddress laddr)", "original_string": "    public DelegatingDatagramSocket(int port, InetAddress laddr)\n        throws SocketException\n    {\n        this(null, new InetSocketAddress(laddr, port));\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java", "class_name": "DelegatingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>DelegatingDatagramSocket</tt> instance bound to the\nspecified local address.  The local port must be between 0 and 65535\ninclusive. If the IP address is 0.0.0.0, the socket will be bound to the\nwildcard address, an IP address chosen by the kernel.\n\n@param port the local port to bind the new socket to\n@param laddr the local address to bind the new socket to\n@throws SocketException if the socket could not be opened, or the socket\ncould not bind to the specified local port\n@see DatagramSocket#DatagramSocket(int, InetAddress)\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[]DelegatingDatagramSocket(SocketAddress)", "name": "DelegatingDatagramSocket", "arg_nums": 1, "params": [{"name": "bindaddr", "type": "SocketAddress"}], "return_type": "", "signature": "public DelegatingDatagramSocket(SocketAddress bindaddr)", "original_string": "    public DelegatingDatagramSocket(SocketAddress bindaddr)\n        throws SocketException\n    {\n        this(null, bindaddr);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java", "class_name": "DelegatingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nCreates a datagram socket, bound to the specified local socket address.\n<p>\nIf, if the address is <tt>null</tt>, creates an unbound socket.\n</p>\n\n@param bindaddr local socket address to bind, or <tt>null</tt> for an\nunbound socket\n@throws SocketException if the socket could not be opened, or the socket\ncould not bind to the specified local port\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[]DelegatingDatagramSocket(DatagramSocket,SocketAddress)", "name": "DelegatingDatagramSocket", "arg_nums": 2, "params": [{"name": "delegate", "type": "DatagramSocket"}, {"name": "address", "type": "SocketAddress"}], "return_type": "", "signature": "public DelegatingDatagramSocket(\n            DatagramSocket delegate,\n            SocketAddress address)", "original_string": "    public DelegatingDatagramSocket(\n            DatagramSocket delegate,\n            SocketAddress address)\n        throws SocketException\n    {\n        super((SocketAddress) null);\n\n        // Delegates the DatagramSocket functionality to the DatagramSocket\n        // given in parameter.\n        if (delegate != null)\n        {\n            this.delegate = delegate;\n        }\n        else\n        {\n            // Creates a custom DatagramSocket to replace classical \"java\"\n            // DatagramSocket and set it as a delegate Socket\n            if (delegateFactory != null)\n            {\n                this.delegate = delegateFactory.createUnboundDatagramSocket();\n            }\n            // Creates a socket directly connected to the network stack.\n            else\n            {\n                this.delegate = null;\n                initReceiveBufferSize();\n            }\n            // If not null, binds the delegate socket to the given address.\n            // Otherwise bind the \"super\" socket to this address.\n            bind(address);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java", "class_name": "DelegatingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>DelegatingDatagramSocket</tt> instance which\nimplements the <tt>DatagramSocket</tt> functionality. If delegate is not\nnull, then the DatagramSocket functionality is delegated to a specific\n<tt>DatagramSocket</tt>.\n\n@param delegate the <tt>DatagramSocket</tt> to which the new instance is\nto delegate.\n@param address The local socket address to bind, or <tt>null</tt> for an\nunbound socket.\n\n@throws SocketException if the socket could not be opened, or the socket\ncould not bind to the specified local port.\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[void]bind(SocketAddress)", "name": "bind", "arg_nums": 1, "params": [{"name": "addr", "type": "SocketAddress"}], "return_type": "void", "signature": "@Override\n    public void bind(SocketAddress addr)", "original_string": "    @Override\n    public void bind(SocketAddress addr)\n            throws SocketException\n    {\n        if (delegate == null)\n            super.bind(addr);\n        else\n            delegate.bind(addr);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java", "class_name": "DelegatingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nBinds this <tt>DatagramSocket</tt> to a specific address and port.\n<p>\nIf the address is <tt>null</tt>, then the system will pick up an\nephemeral port and a valid local address to bind the socket.\n</p>\n\n@param addr the address and port to bind to\n@throws SocketException if any error happens during the bind, or if the\nsocket is already bound\n@throws SecurityException if a security manager exists and its\n<tt>checkListen</tt> method doesn't allow the operation\n@throws IllegalArgumentException if <tt>addr</tt> is a\n<tt>SocketAddress</tt> subclass not supported by this socket\n@see DatagramSocket#bind(SocketAddress)\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[void]close()", "name": "close", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Override\n    public void close()", "original_string": "    @Override\n    public void close()\n    {\n        // We want both #delegate and super to actually get closed (and release\n        // the FDs which they hold). But super will not close unless isClosed()\n        // returns false. So we update the #closed flag last.\n        if (delegate != null)\n            delegate.close();\n\n        super.close();\n        closed = true;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java", "class_name": "DelegatingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nCloses this datagram socket.\n<p>\nAny thread currently blocked in {@link #receive(DatagramPacket)} upon\nthis socket will throw a {@link SocketException}.\n</p>\n\n@see DatagramSocket#close()\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[void]connect(InetAddress,int)", "name": "connect", "arg_nums": 2, "params": [{"name": "address", "type": "InetAddress"}, {"name": "port", "type": "int"}], "return_type": "void", "signature": "@Override\n    public void connect(InetAddress address, int port)", "original_string": "    @Override\n    public void connect(InetAddress address, int port)\n    {\n        if (delegate == null)\n            super.connect(address, port);\n        else\n            delegate.connect(address, port);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java", "class_name": "DelegatingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nConnects the socket to a remote address for this socket. When a socket is\nconnected to a remote address, packets may only be sent to or received\nfrom that address. By default a datagram socket is not connected.\n<p>\nIf the remote destination to which the socket is connected does not\nexist, or is otherwise unreachable, and if an ICMP destination\nunreachable packet has been received for that address, then a subsequent\ncall to {@link #send(DatagramPacket)} or {@link #receive(DatagramPacket)}\nmay throw a <tt>PortUnreachableException</tt>. Note, there is no\nguarantee that the exception will be thrown.\n</p>\n\n@param address the remote address for the socket\n@param port the remote port for the socket\n@throws IllegalArgumentException if the address is <tt>null</tt>, or the\nport is out of range\n@throws SecurityException if the caller is not allowed to send datagrams\nto and receive datagrams from the address and port\n@see DatagramSocket#connect(InetAddress, int)\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[void]connect(SocketAddress)", "name": "connect", "arg_nums": 1, "params": [{"name": "addr", "type": "SocketAddress"}], "return_type": "void", "signature": "@Override\n    public void connect(SocketAddress addr)", "original_string": "    @Override\n    public void connect(SocketAddress addr)\n        throws SocketException\n    {\n        if (delegate == null)\n            super.connect(addr);\n        else\n            delegate.connect(addr);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java", "class_name": "DelegatingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nConnects this socket to a remote socket address.\n\n@param addr the remote address\n@throws SocketException if the connect fails\n@throws IllegalArgumentException if <tt>addr</tt> is <tt>null</tt> or a\n<tt>SocketAddress</tt> subclass not supported by this socket\n@see DatagramSocket#connect(SocketAddress)\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[void]disconnect()", "name": "disconnect", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Override\n    public void disconnect()", "original_string": "    @Override\n    public void disconnect()\n    {\n        if (delegate == null)\n            super.disconnect();\n        else\n            delegate.disconnect();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java", "class_name": "DelegatingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nDisconnects the socket. This does nothing if the socket is not connected.\n\n@see DatagramSocket#disconnect()\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[boolean]getBroadcast()", "name": "getBroadcast", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "@Override\n    public boolean getBroadcast()", "original_string": "    @Override\n    public boolean getBroadcast()\n        throws SocketException\n    {\n        return\n            (delegate == null) ? super.getBroadcast() : delegate.getBroadcast();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java", "class_name": "DelegatingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nTests if <tt>SO_BROADCAST</tt> is enabled.\n\n@return a <tt>boolean</tt> indicating whether or not\n<tt>SO_BROADCAST</tt> is enabled\n@throws SocketException if there is an error in the underlying protocol,\nsuch as an UDP error\n@see DatagramSocket#getBroadcast()\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[DatagramChannel]getChannel()", "name": "getChannel", "arg_nums": 0, "params": [], "return_type": "DatagramChannel", "signature": "@Override\n    public DatagramChannel getChannel()", "original_string": "    @Override\n    public DatagramChannel getChannel()\n    {\n        return (delegate == null) ? super.getChannel() : delegate.getChannel();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java", "class_name": "DelegatingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "DatagramChannel", "classes": []}, "docstring": "\nReturns the unique {@link DatagramChannel} object associated with this\ndatagram socket, if any.\n<p>\nA datagram socket will have a channel if, and only if, the channel itself\nwas created via the {@link DatagramChannel#open()} method\n</p>\n\n@return the datagram channel associated with this datagram socket, or\n<tt>null</tt> if this socket was not created for a channel\n@see DatagramSocket#getChannel()\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[InetAddress]getInetAddress()", "name": "getInetAddress", "arg_nums": 0, "params": [], "return_type": "InetAddress", "signature": "@Override\n    public InetAddress getInetAddress()", "original_string": "    @Override\n    public InetAddress getInetAddress()\n    {\n        return\n            (delegate == null)\n                ? super.getInetAddress()\n                : delegate.getInetAddress();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java", "class_name": "DelegatingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "InetAddress", "classes": []}, "docstring": "\nReturns the address to which this socket is connected. Returns\n<tt>null</tt> if the socket is not connected.\n\n@return the address to which this socket is connected\n@see DatagramSocket#getInetAddress()\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[InetAddress]getLocalAddress()", "name": "getLocalAddress", "arg_nums": 0, "params": [], "return_type": "InetAddress", "signature": "@Override\n    public InetAddress getLocalAddress()", "original_string": "    @Override\n    public InetAddress getLocalAddress()\n    {\n        return\n            (delegate == null)\n                ? super.getLocalAddress()\n                : delegate.getLocalAddress();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java", "class_name": "DelegatingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "InetAddress", "classes": []}, "docstring": "\nGets the local address to which the socket is bound.\n<p>\nIf there is a security manager, its <tt>checkConnect</tt> method is first\ncalled with the host address and <tt>-1</tt> as its arguments to see if\nthe operation is allowed.\n\n@return the local address to which the socket is bound, or an\n<tt>InetAddress</tt> representing any local address if either the socket\nis not bound, or the security manager <tt>checkConnect</tt> method does\nnot allow the operation\n@see DatagramSocket#getLocalAddress()\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[int]getLocalPort()", "name": "getLocalPort", "arg_nums": 0, "params": [], "return_type": "int", "signature": "@Override\n    public int getLocalPort()", "original_string": "    @Override\n    public int getLocalPort()\n    {\n        return\n            (delegate == null) ? super.getLocalPort() : delegate.getLocalPort();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java", "class_name": "DelegatingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\nReturns the port number on the local host to which this socket is bound.\n\n@return the port number on the local host to which this socket is bound\n@see DatagramSocket#getLocalPort()\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[SocketAddress]getLocalSocketAddress()", "name": "getLocalSocketAddress", "arg_nums": 0, "params": [], "return_type": "SocketAddress", "signature": "@Override\n    public SocketAddress getLocalSocketAddress()", "original_string": "    @Override\n    public SocketAddress getLocalSocketAddress()\n    {\n        return\n            (delegate == null)\n                ? super.getLocalSocketAddress()\n                : delegate.getLocalSocketAddress();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java", "class_name": "DelegatingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "SocketAddress", "classes": []}, "docstring": "\nReturns the address of the endpoint this socket is bound to, or\n<tt>null</tt> if it is not bound yet.\n\n@return a <tt>SocketAddress</tt> representing the local endpoint of this\nsocket, or <tt>null</tt> if it is not bound yet\n@see DatagramSocket#getLocalSocketAddress()\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[int]getPort()", "name": "getPort", "arg_nums": 0, "params": [], "return_type": "int", "signature": "@Override\n    public int getPort()", "original_string": "    @Override\n    public int getPort()\n    {\n        return (delegate == null) ? super.getPort() : delegate.getPort();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java", "class_name": "DelegatingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\nReturns the port for this socket. Returns <tt>-1</tt> if the socket is\nnot connected.\n\n@return the port to which this socket is connected\n@see DatagramSocket#getPort()\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[int]getReceiveBufferSize()", "name": "getReceiveBufferSize", "arg_nums": 0, "params": [], "return_type": "int", "signature": "@Override\n    public int getReceiveBufferSize()", "original_string": "    @Override\n    public int getReceiveBufferSize()\n        throws SocketException\n    {\n        return\n            (delegate == null)\n                ? super.getReceiveBufferSize()\n                : delegate.getReceiveBufferSize();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java", "class_name": "DelegatingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\nGets the value of the <tt>SO_RCVBUF</tt> option for this\n<tt>DatagramSocket</tt>, that is the buffer size used by the platform for\ninput on this <tt>DatagramSocket</tt>.\n\n@return the value of the <tt>SO_RCVBUF</tt> option for this\n<tt>DatagramSocket</tt>\n@throws SocketException if there is an error in the underlying protocol,\nsuch as an UDP error\n@see DatagramSocket#getReceiveBufferSize()\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[SocketAddress]getRemoteSocketAddress()", "name": "getRemoteSocketAddress", "arg_nums": 0, "params": [], "return_type": "SocketAddress", "signature": "@Override\n    public SocketAddress getRemoteSocketAddress()", "original_string": "    @Override\n    public SocketAddress getRemoteSocketAddress()\n    {\n        return\n            (delegate == null)\n                ? super.getRemoteSocketAddress()\n                : delegate.getRemoteSocketAddress();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java", "class_name": "DelegatingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "SocketAddress", "classes": []}, "docstring": "\nReturns the address of the endpoint this socket is connected to, or\n<tt>null</tt> if it is unconnected.\n\n@return a <tt>SocketAddress</tt> representing the remote endpoint of this\nsocket, or <tt>null</tt> if it is not connected yet\n@see DatagramSocket#getRemoteSocketAddress()\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[boolean]getReuseAddress()", "name": "getReuseAddress", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "@Override\n    public boolean getReuseAddress()", "original_string": "    @Override\n    public boolean getReuseAddress()\n        throws SocketException\n    {\n        return\n            (delegate == null)\n                ? super.getReuseAddress()\n                : delegate.getReuseAddress();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java", "class_name": "DelegatingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nTests if <tt>SO_REUSEADDR</tt> is enabled.\n\n@return a <tt>boolean</tt> indicating whether or not\n<tt>SO_REUSEADDR</tt> is enabled\n@throws SocketException if there is an error in the underlying protocol,\nsuch as an UDP error\n@see DatagramSocket#getReuseAddress()\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[int]getSendBufferSize()", "name": "getSendBufferSize", "arg_nums": 0, "params": [], "return_type": "int", "signature": "@Override\n    public int getSendBufferSize()", "original_string": "    @Override\n    public int getSendBufferSize()\n        throws SocketException\n    {\n        return\n            (delegate == null)\n                ? super.getSendBufferSize()\n                : delegate.getSendBufferSize();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java", "class_name": "DelegatingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\nGets the value of the <tt>SO_SNDBUF</tt> option for this\n<tt>DatagramSocket</tt>, that is the buffer size used by the platform for\noutput on this <tt>DatagramSocket</tt>.\n\n@return the value of the <tt>SO_SNDBUF</tt> option for this\n<tt>DatagramSocket</tt>\n@throws SocketException if there is an error in the underlying protocol,\nsuch as an UDP error\n@see DatagramSocket#getSendBufferSize()\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[int]getSoTimeout()", "name": "getSoTimeout", "arg_nums": 0, "params": [], "return_type": "int", "signature": "@Override\n    public int getSoTimeout()", "original_string": "    @Override\n    public int getSoTimeout()\n        throws SocketException\n    {\n        return\n            (delegate == null) ? super.getSoTimeout() : delegate.getSoTimeout();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java", "class_name": "DelegatingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\nRetrieves setting for <tt>SO_TIMEOUT</tt>.  Zero returned implies that\nthe option is disabled (i.e., timeout of infinity).\n\n@return the setting for <tt>SO_TIMEOUT</tt>\n@throws SocketException if there is an error in the underlying protocol,\nsuch as an UDP error\n@see DatagramSocket#getSoTimeout()\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[int]getTrafficClass()", "name": "getTrafficClass", "arg_nums": 0, "params": [], "return_type": "int", "signature": "@Override\n    public int getTrafficClass()", "original_string": "    @Override\n    public int getTrafficClass()\n        throws SocketException\n    {\n        return\n            (delegate == null)\n                ? super.getTrafficClass()\n                : delegate.getTrafficClass();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java", "class_name": "DelegatingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\nGets the traffic class or type-of-service in the IP datagram header for\npackets sent from this <tt>DatagramSocket</tt>.\n<p>\nAs the underlying network implementation may ignore the traffic class or\ntype-of-service set using {@link #setTrafficClass(int)} this method may\nreturn a different value than was previously set using the\n{@link #setTrafficClass(int)} method on this <tt>DatagramSocket</tt>.\n</p>\n\n@return the traffic class or type-of-service already set\n@throws SocketException if there is an error obtaining the traffic class\nor type-of-service value\n@see DatagramSocket#getTrafficClass()\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[boolean]isBound()", "name": "isBound", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "@Override\n    public boolean isBound()", "original_string": "    @Override\n    public boolean isBound()\n    {\n        return (delegate == null) ? super.isBound() : delegate.isBound();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java", "class_name": "DelegatingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nReturns the binding state of the socket.\n\n@return <tt>true</tt> if the socket successfully bound to an address;\notherwise, <tt>false</tt>\n@see DatagramSocket#isBound()\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[boolean]isClosed()", "name": "isClosed", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "@Override\n    public boolean isClosed()", "original_string": "    @Override\n    public boolean isClosed()\n    {\n        return closed;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java", "class_name": "DelegatingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nReturns whether the socket is closed or not.\n\n@return <tt>true</tt> if the socket has been closed; otherwise,\n<tt>false</tt>\n@see DatagramSocket#isClosed()\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[boolean]isConnected()", "name": "isConnected", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "@Override\n    public boolean isConnected()", "original_string": "    @Override\n    public boolean isConnected()\n    {\n        return (delegate == null) ? super.isConnected() :\n            delegate.isConnected();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java", "class_name": "DelegatingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\nReturns the connection state of the socket.\n\n@return <tt>true</tt> if the socket successfully connected to a server;\notherwise, <tt>false</tt>\n@see DatagramSocket#isConnected()\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[void]receive(DatagramPacket)", "name": "receive", "arg_nums": 1, "params": [{"name": "p", "type": "DatagramPacket"}], "return_type": "void", "signature": "@Override\n    public void receive(DatagramPacket p)", "original_string": "    @Override\n    public void receive(DatagramPacket p)\n        throws IOException\n    {\n        if (delegate == null)\n        {\n            // If the packet length is too small, then the\n            // DatagramSocket.receive function will truncate the received\n            // datagram. This problem appears when reusing the same\n            // DatagramPacket i.e. if the first time we use the DatagramPacket\n            // to receive a small packet and the second time a bigger one, then\n            // after the first packet is received, the length is set to the size\n            // of the first packet and the second packet is truncated.\n            // http://docs.oracle.com/javase/6/docs/api/java/net/DatagramSocket.html\n            //\n            // XXX(boris): I think the above is wrong. I don't interpret the\n            // API description this way, and testing on a couple of different\n            // environments shows that  DatagramSocket.receive() grows the\n            // packet's length to as much as much as the array (and offset)\n            // would allow. I am leaving the code because it seems harmless.\n            byte[] data = p.getData();\n\n            p.setLength((data == null) ? 0 : (data.length - p.getOffset()));\n\n            super.receive(p);\n\n            if (StunDatagramPacketFilter.isStunPacket(p)\n                    || logNonStun(++nbReceivedPackets))\n            {\n                StunStack.logPacketToPcap(\n                        p,\n                        false,\n                        getLocalAddress(),\n                        getLocalPort());\n            }\n        }\n        else\n        {\n            delegate.receive(p);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java", "class_name": "DelegatingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nReceives a datagram packet from this socket. When this method returns,\nthe <tt>DatagramPacket</tt>'s buffer is filled with the data received.\nThe datagram packet also contains the sender's IP address, and the port\nnumber on the sender's machine.\n<p>\nThis method blocks until a datagram is received. The <tt>length</tt>\nfield of the datagram packet object contains the length of the received\nmessage. If the message is longer than the packet's length, the message\nis truncated.\n</p>\n<p>\nIf there is a security manager, a packet cannot be received if the\nsecurity manager's <tt>checkAccept</tt> method does not allow it.\n</p>\n\n@param p the <tt>DatagramPacket</tt> into which to place the incoming\ndata\n@throws IOException if an I/O error occurs\n@see DatagramSocket#receive(DatagramPacket)\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[void]send(DatagramPacket)", "name": "send", "arg_nums": 1, "params": [{"name": "p", "type": "DatagramPacket"}], "return_type": "void", "signature": "@Override\n    public void send(DatagramPacket p)", "original_string": "    @Override\n    public void send(DatagramPacket p)\n        throws IOException\n    {\n        // Sends the packet to the final DatagramSocket\n        if (delegate == null)\n        {\n            try\n            {\n                super.send(p);\n            }\n            // DIRTY, DIRTY, DIRTY!!!\n            // Here we correct a java under MAC OSX bug when dealing with\n            // ipv6 local interface: the destination address (as well as the\n            // source address) under java / MAC OSX must have a scope ID,\n            // i.e.  \"fe80::1%en1\".  This correction (the whole \"catch\") is to\n            // be removed as soon as java under MAC OSX implements a real ipv6\n            // network stack.\n            catch(Exception ex)\n            {\n                InetAddress tmpAddr = p.getAddress();\n                if (((ex instanceof NoRouteToHostException)\n                            || (ex.getMessage() != null\n                                && ex.getMessage().equals(\"No route to host\")))\n                        && (tmpAddr instanceof Inet6Address)\n                        && (tmpAddr.isLinkLocalAddress()))\n                {\n                    Inet6Address newAddr = Inet6Address.getByAddress(\n                            \"\",\n                            tmpAddr.getAddress(),\n                            ((Inet6Address) super.getLocalAddress())\n                            .getScopeId());\n                    p.setAddress(newAddr);\n\n                    super.send(p);\n                }\n                else if (ex instanceof IOException)\n                {\n                    throw((IOException)ex);\n                }\n           }\n\n            if (logNonStun(++nbSentPackets))\n            {\n                StunStack.logPacketToPcap(\n                        p,\n                        true,\n                        getLocalAddress(),\n                        getLocalPort());\n            }\n        }\n        // Else, the delegate socket will encapsulate the packet.\n        else\n        {\n            delegate.send(p);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java", "class_name": "DelegatingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSends a datagram packet from this socket. The <tt>DatagramPacket</tt>\nincludes information indicating the data to be sent, its length, the IP\naddress of the remote host, and the port number on the remote host.\n<p>\nIf there is a security manager, and the socket is not currently connected\nto a remote address, this method first performs some security checks.\nFirst, if <tt>p.getAddress().isMulticastAddress()</tt> is true, this\nmethod calls the security manager's <tt>checkMulticast</tt> method with\n<tt>p.getAddress()</tt> as its argument. If the evaluation of that\nexpression is <tt>false</tt>, this method instead calls the security\nmanager's <tt>checkConnect</tt> method with arguments\n<tt>p.getAddress().getHostAddress()</tt> and <tt>p.getPort()</tt>. Each\ncall to a security manager method could result in a\n<tt>SecurityException</tt> if the operation is not allowed.\n</p>\n\n@param p the <tt>DatagramPacket</tt> to be sent\n@throws IOException if an I/O error occurs\n@see DatagramSocket#send(DatagramPacket)\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[void]setBroadcast(boolean)", "name": "setBroadcast", "arg_nums": 1, "params": [{"name": "on", "type": "boolean"}], "return_type": "void", "signature": "@Override\n    public void setBroadcast(boolean on)", "original_string": "    @Override\n    public void setBroadcast(boolean on)\n        throws SocketException\n    {\n        if (delegate == null)\n            super.setBroadcast(on);\n        else\n            delegate.setBroadcast(on);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java", "class_name": "DelegatingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nEnables/disables <tt>SO_BROADCAST</tt>.\n\n@param on whether or not to have broadcast turned on\n@throws SocketException if there is an error in the underlying protocol,\nsuch as an UDP error\n@see DatagramSocket#setBroadcast(boolean)\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[void]setReceiveBufferSize(int)", "name": "setReceiveBufferSize", "arg_nums": 1, "params": [{"name": "size", "type": "int"}], "return_type": "void", "signature": "@Override\n    public void setReceiveBufferSize(int size)", "original_string": "    @Override\n    public void setReceiveBufferSize(int size)\n        throws SocketException\n    {\n        if (delegate == null)\n            super.setReceiveBufferSize(size);\n        else\n            delegate.setReceiveBufferSize(size);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java", "class_name": "DelegatingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets the <tt>SO_RCVBUF</tt> option to the specified value for this\n<tt>DatagramSocket</tt>. The <tt>SO_RCVBUF</tt> option is used by the\nnetwork implementation as a hint to size the underlying network I/O\nbuffers. The <tt>SO_RCVBUF</tt> setting may also be used by the network\nimplementation to determine the maximum size of the packet that can be\nreceived on this socket.\n<p>\nBecause <tt>SO_RCVBUF</tt> is a hint, applications that want to verify\nwhat size the buffers were set to should call\n{@link #getReceiveBufferSize()}.\n</p>\n\n@param size the size to which to set the receive buffer size. The value\nmust be greater than zero\n@throws SocketException if there is an error in the underlying protocol,\nsuch as an UDP error\n@throws IllegalArgumentException if the value is zero or is negative\n@see DatagramSocket#setReceiveBufferSize(int)\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[void]setReuseAddress(boolean)", "name": "setReuseAddress", "arg_nums": 1, "params": [{"name": "on", "type": "boolean"}], "return_type": "void", "signature": "@Override\n    public void setReuseAddress(boolean on)", "original_string": "    @Override\n    public void setReuseAddress(boolean on)\n        throws SocketException\n    {\n        if (delegate == null)\n            super.setReuseAddress(on);\n        else\n            delegate.setReuseAddress(on);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java", "class_name": "DelegatingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nEnables/disables the <tt>SO_REUSEADDR</tt> socket option.\n\n@param on whether to enable or disable the <tt>SO_REUSEADDR</tt> socket\noption\n@throws SocketException if an error occurs enabling or disabling the\n<tt>SO_RESUEADDR</tt> socket option, or the socket is closed\n@see DatagramSocket#setReuseAddress(boolean)\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[void]setSendBufferSize(int)", "name": "setSendBufferSize", "arg_nums": 1, "params": [{"name": "size", "type": "int"}], "return_type": "void", "signature": "@Override\n    public void setSendBufferSize(int size)", "original_string": "    @Override\n    public void setSendBufferSize(int size)\n        throws SocketException\n    {\n        if (delegate == null)\n            super.setSendBufferSize(size);\n        else\n            delegate.setSendBufferSize(size);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java", "class_name": "DelegatingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets the <tt>SO_SNDBUF</tt> option to the specified value for this\n<tt>DatagramSocket</tt>. The <tt>SO_SNDBUF</tt> option is used by the\nnetwork implementation as a hint to size the underlying network I/O\nbuffers. The <tt>SO_SNDBUF</tt> setting may also be used by the network\nimplementation to determine the maximum size of the packet that can be\nsent on this socket.\n<p>\nAs <tt>SO_SNDBUF</tt> is a hint, applications that want to verify what\nsize the buffer is should call {@link #getSendBufferSize()}.\n</p>\n<p>\nIncreasing the buffer size may allow multiple outgoing packets to be\nqueued by the network implementation when the send rate is high.\n</p>\n\n@param size the size to which to set the send buffer size. The value must\nbe greater than zero\n@throws SocketException if there is an error in the underlying protocol,\nsuch as an UDP error\n@throws IllegalArgumentException if the value is zero or is negative\n@see DatagramSocket#setSendBufferSize(int)\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[void]setSoTimeout(int)", "name": "setSoTimeout", "arg_nums": 1, "params": [{"name": "timeout", "type": "int"}], "return_type": "void", "signature": "@Override\n    public void setSoTimeout(int timeout)", "original_string": "    @Override\n    public void setSoTimeout(int timeout)\n        throws SocketException\n    {\n        if (delegate == null)\n            super.setSoTimeout(timeout);\n        else\n            delegate.setSoTimeout(timeout);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java", "class_name": "DelegatingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nEnables/disables <tt>SO_TIMEOUT</tt> with the specified timeout, in\nmilliseconds. With this option set to a non-zero timeout, a call to\n{@link #receive(DatagramPacket)} for this <tt>DatagramSocket</tt> will\nblock for only this amount of time.  If the timeout expires, a\n<tt>SocketTimeoutException</tt> is raised, though the\n<tt>DatagramSocket</tt> is still valid.  The option must be enabled prior\nto entering the blocking operation to have effect.  The timeout must be\ngreater than zero. A timeout of zero is interpreted as an infinite\ntimeout.\n\n@param timeout the specified timeout in milliseconds\n@throws SocketException if there is an error in the underlying protocol,\nsuch as an UDP error\n@see DatagramSocket#setSoTimeout(int)\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[void]setTrafficClass(int)", "name": "setTrafficClass", "arg_nums": 1, "params": [{"name": "tc", "type": "int"}], "return_type": "void", "signature": "@Override\n    public void setTrafficClass(int tc)", "original_string": "    @Override\n    public void setTrafficClass(int tc)\n        throws SocketException\n    {\n        if (delegate == null)\n            super.setTrafficClass(tc);\n        else\n            delegate.setTrafficClass(tc);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java", "class_name": "DelegatingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nSets traffic class or type-of-service octet in the IP datagram header for\ndatagrams sent from this <tt>DatagramSocket</tt>. As the underlying\nnetwork implementation may ignore this value applications should consider\nit a hint.\n\n@param tc an <tt>int</tt> value for the bitset\n@throws SocketException if there is an error setting the traffic class or\ntype-of-service\n@see DatagramSocket#setTrafficClass(int)\n"}, {"uris": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[void]initReceiveBufferSize()", "name": "initReceiveBufferSize", "arg_nums": 0, "params": [], "return_type": "void", "signature": "private void initReceiveBufferSize()", "original_string": "    private void initReceiveBufferSize()\n        throws SocketException\n    {\n        // Only change the buffer size on the real underlying DatagramSocket.\n        if (delegate == null && defaultReceiveBufferSize > 0)\n        {\n            super.setReceiveBufferSize(defaultReceiveBufferSize);\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java", "class_name": "DelegatingDatagramSocket", "class_uri": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\nA utility method used by the constructors to ensure the receive buffer\nsize is set to the preferred default.\n\nThis implementation only has an impact of there is no delegate, in other\nwords, if we really are using the superclass socket implementation as the\nraw socket.\n\n@throws SocketException if there is an error in the underlying protocol,\nsuch as an UDP error.\n"}, {"uris": "src/main/java/org/ice4j/socket/IceTcpServerSocketWrapper.java.IceTcpServerSocketWrapper.[]IceTcpServerSocketWrapper(ServerSocket,Component)", "name": "IceTcpServerSocketWrapper", "arg_nums": 2, "params": [{"name": "serverSocket", "type": "ServerSocket"}, {"name": "component", "type": "Component"}], "return_type": "", "signature": "public IceTcpServerSocketWrapper(ServerSocket serverSocket,\n        Component component)", "original_string": "    public IceTcpServerSocketWrapper(ServerSocket serverSocket,\n        Component component)\n    {\n        this.serverSocket = serverSocket;\n        this.component = component;\n        acceptThread = new ThreadAccept();\n        acceptThread.start();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/IceTcpServerSocketWrapper.java", "class_name": "IceTcpServerSocketWrapper", "class_uri": "src/main/java/org/ice4j/socket/IceTcpServerSocketWrapper.java.IceTcpServerSocketWrapper", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new <tt>IceTcpServerSocketWrapper</tt>.\n\n@param serverSocket TCP <tt>ServerSocket</tt>\n@param component related <tt>Component</tt>\n"}, {"uris": "src/main/java/org/ice4j/socket/IceTcpServerSocketWrapper.java.IceTcpServerSocketWrapper.[void]send(DatagramPacket)", "name": "send", "arg_nums": 1, "params": [{"name": "p", "type": "DatagramPacket"}], "return_type": "void", "signature": "@Override\n    public void send(DatagramPacket p)", "original_string": "    @Override\n    public void send(DatagramPacket p) throws IOException\n    {\n        /* Do nothing for the moment */\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/IceTcpServerSocketWrapper.java", "class_name": "IceTcpServerSocketWrapper", "class_uri": "src/main/java/org/ice4j/socket/IceTcpServerSocketWrapper.java.IceTcpServerSocketWrapper", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/IceTcpServerSocketWrapper.java.IceTcpServerSocketWrapper.[void]receive(DatagramPacket)", "name": "receive", "arg_nums": 1, "params": [{"name": "p", "type": "DatagramPacket"}], "return_type": "void", "signature": "@Override\n    public void receive(DatagramPacket p)", "original_string": "    @Override\n    public void receive(DatagramPacket p) throws IOException\n    {\n        /* Do nothing for the moment */\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/IceTcpServerSocketWrapper.java", "class_name": "IceTcpServerSocketWrapper", "class_uri": "src/main/java/org/ice4j/socket/IceTcpServerSocketWrapper.java.IceTcpServerSocketWrapper", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/IceTcpServerSocketWrapper.java.IceTcpServerSocketWrapper.[void]close()", "name": "close", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Override\n    public void close()", "original_string": "    @Override\n    public void close()\n    {\n        try\n        {\n            isRun = false;\n            serverSocket.close();\n            for (Socket s : sockets)\n            {\n                s.close();\n            }\n        }\n        catch(IOException e)\n        {\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/IceTcpServerSocketWrapper.java", "class_name": "IceTcpServerSocketWrapper", "class_uri": "src/main/java/org/ice4j/socket/IceTcpServerSocketWrapper.java.IceTcpServerSocketWrapper", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/IceTcpServerSocketWrapper.java.IceTcpServerSocketWrapper.[InetAddress]getLocalAddress()", "name": "getLocalAddress", "arg_nums": 0, "params": [], "return_type": "InetAddress", "signature": "@Override\n    public InetAddress getLocalAddress()", "original_string": "    @Override\n    public InetAddress getLocalAddress()\n    {\n        return serverSocket.getInetAddress();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/IceTcpServerSocketWrapper.java", "class_name": "IceTcpServerSocketWrapper", "class_uri": "src/main/java/org/ice4j/socket/IceTcpServerSocketWrapper.java.IceTcpServerSocketWrapper", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "InetAddress", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/IceTcpServerSocketWrapper.java.IceTcpServerSocketWrapper.[int]getLocalPort()", "name": "getLocalPort", "arg_nums": 0, "params": [], "return_type": "int", "signature": "@Override\n    public int getLocalPort()", "original_string": "    @Override\n    public int getLocalPort()\n    {\n        return serverSocket.getLocalPort();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/IceTcpServerSocketWrapper.java", "class_name": "IceTcpServerSocketWrapper", "class_uri": "src/main/java/org/ice4j/socket/IceTcpServerSocketWrapper.java.IceTcpServerSocketWrapper", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/IceTcpServerSocketWrapper.java.IceTcpServerSocketWrapper.[SocketAddress]getLocalSocketAddress()", "name": "getLocalSocketAddress", "arg_nums": 0, "params": [], "return_type": "SocketAddress", "signature": "@Override\n    public SocketAddress getLocalSocketAddress()", "original_string": "    @Override\n    public SocketAddress getLocalSocketAddress()\n    {\n        return serverSocket.getLocalSocketAddress();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/IceTcpServerSocketWrapper.java", "class_name": "IceTcpServerSocketWrapper", "class_uri": "src/main/java/org/ice4j/socket/IceTcpServerSocketWrapper.java.IceTcpServerSocketWrapper", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "SocketAddress", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/IceTcpServerSocketWrapper.java.IceTcpServerSocketWrapper.[Socket]getTCPSocket()", "name": "getTCPSocket", "arg_nums": 0, "params": [], "return_type": "Socket", "signature": "@Override\n    public Socket getTCPSocket()", "original_string": "    @Override\n    public Socket getTCPSocket()\n    {\n        if (sockets.size() > 0)\n        {\n            return sockets.get(0);\n        }\n\n        return null;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/IceTcpServerSocketWrapper.java", "class_name": "IceTcpServerSocketWrapper", "class_uri": "src/main/java/org/ice4j/socket/IceTcpServerSocketWrapper.java.IceTcpServerSocketWrapper", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Socket", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/IceTcpServerSocketWrapper.java.IceTcpServerSocketWrapper.[DatagramSocket]getUDPSocket()", "name": "getUDPSocket", "arg_nums": 0, "params": [], "return_type": "DatagramSocket", "signature": "@Override\n    public DatagramSocket getUDPSocket()", "original_string": "    @Override\n    public DatagramSocket getUDPSocket()\n    {\n        return null;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/IceTcpServerSocketWrapper.java", "class_name": "IceTcpServerSocketWrapper", "class_uri": "src/main/java/org/ice4j/socket/IceTcpServerSocketWrapper.java.IceTcpServerSocketWrapper", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "DatagramSocket", "classes": []}, "docstring": "\n{@inheritDoc}\n"}, {"uris": "src/main/java/org/ice4j/socket/MuxServerSocketChannelFactory.java.MuxServerSocketChannelFactory.[ServerSocketChannel]openAndBindServerSocketChannel(Map<String, Object>,SocketAddress,int)", "name": "openAndBindServerSocketChannel", "arg_nums": 3, "params": [{"name": "properties", "type": "Map<String, Object>"}, {"name": "endpoint", "type": "SocketAddress"}, {"name": "backlog", "type": "int"}], "return_type": "ServerSocketChannel", "signature": "public static ServerSocketChannel openAndBindServerSocketChannel(\n            Map<String, Object> properties,\n            SocketAddress endpoint,\n            int backlog)", "original_string": "    public static ServerSocketChannel openAndBindServerSocketChannel(\n            Map<String, Object> properties,\n            SocketAddress endpoint,\n            int backlog)\n        throws IOException\n    {\n        ServerSocketChannel channel = ServerSocketChannel.open();\n        // Apply the specified properties.\n        ServerSocket socket = channel.socket();\n\n        if (properties != null && !properties.isEmpty())\n        {\n            for (Map.Entry<String, Object> property\n                    : properties.entrySet())\n            {\n                String name = property.getKey();\n\n                if (SOCKET_REUSE_ADDRESS_PROPERTY_NAME.equals(name))\n                {\n                    Object value = property.getValue();\n                    boolean on;\n\n                    if (value == null)\n                        on = false;\n                    else if (value instanceof Boolean)\n                        on = (Boolean) value;\n                    else\n                        on = Boolean.parseBoolean(value.toString());\n\n                    socket.setReuseAddress(on);\n                }\n            }\n        }\n\n        socket.bind(endpoint, backlog);\n\n        return channel;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/MuxServerSocketChannelFactory.java", "class_name": "MuxServerSocketChannelFactory", "class_uri": "src/main/java/org/ice4j/socket/MuxServerSocketChannelFactory.java.MuxServerSocketChannelFactory", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "ServerSocketChannel", "classes": []}, "docstring": "\nOpens and binds a new {@code ServerSocketChannel} instance.\n\n@param properties a {@code Map} of the values to be assigned to\nproperties of the underlying {@link ServerSocketChannel} which is to\nactually listen on the specified {@code endpoint}. If the new instance is\nnot the first to open and bind the specified {@code endpoint}, the\n{@code properties} and their respective values may not be used.\n@param endpoint the IP and port the new instance is to bind to\n@param backlog the requested maximum number of pending incoming\nconnections to be queued. If the new instance is not the first to open\nand bind the specified {@code endpoint}, the value may not be used.\n@return a new {@code ServerSocketChannel} instance open and bound on the\nspecified listening {@code endpoint}\n@throws IOException if an I/O error occurs\n"}, {"uris": "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java.BaseDelegatingSocketChannel.[]BaseDelegatingSocketChannel(T)", "name": "BaseDelegatingSocketChannel", "arg_nums": 1, "params": [{"name": "delegate", "type": "T"}], "return_type": "", "signature": "public BaseDelegatingSocketChannel(T delegate)", "original_string": "    public BaseDelegatingSocketChannel(T delegate)\n    {\n        super(delegate.provider());\n\n        this.delegate = delegate;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java", "class_name": "BaseDelegatingSocketChannel", "class_uri": "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java.BaseDelegatingSocketChannel", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "docstring": "\nInitializes a new {@code BaseDelegatingSocketChannel} instance which is\nto delegate (its method calls) to a specific {@code SocketChannel}.\n\n@param delegate the {@code SocketChannel} the new instance is to delegate\n(its method calls) to\n"}, {"uris": "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java.BaseDelegatingSocketChannel.[SocketChannel]bind(SocketAddress)", "name": "bind", "arg_nums": 1, "params": [{"name": "local", "type": "SocketAddress"}], "return_type": "SocketChannel", "signature": "@Override\n    public SocketChannel bind(SocketAddress local)", "original_string": "    @Override\n    public SocketChannel bind(SocketAddress local)\n        throws IOException\n    {\n        delegate.bind(local);\n        return this;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java", "class_name": "BaseDelegatingSocketChannel", "class_uri": "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java.BaseDelegatingSocketChannel", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "SocketChannel", "classes": []}, "docstring": "\n{@inheritDoc}\n\nForwards to {@link #delegate} and returns {@code this}.\n"}, {"uris": "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java.BaseDelegatingSocketChannel.[boolean]connect(SocketAddress)", "name": "connect", "arg_nums": 1, "params": [{"name": "remote", "type": "SocketAddress"}], "return_type": "boolean", "signature": "@Override\n    public boolean connect(SocketAddress remote)", "original_string": "    @Override\n    public boolean connect(SocketAddress remote)\n        throws IOException\n    {\n        return delegate.connect(remote);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java", "class_name": "BaseDelegatingSocketChannel", "class_uri": "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java.BaseDelegatingSocketChannel", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\n{@inheritDoc}\n\nForwards to {@link #delegate}.\n"}, {"uris": "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java.BaseDelegatingSocketChannel.[boolean]finishConnect()", "name": "finishConnect", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "@Override\n    public boolean finishConnect()", "original_string": "    @Override\n    public boolean finishConnect()\n        throws IOException\n    {\n        return delegate.finishConnect();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java", "class_name": "BaseDelegatingSocketChannel", "class_uri": "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java.BaseDelegatingSocketChannel", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\n{@inheritDoc}\n\nForwards to {@link #delegate}.\n"}, {"uris": "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java.BaseDelegatingSocketChannel.[SocketAddress]getLocalAddress()", "name": "getLocalAddress", "arg_nums": 0, "params": [], "return_type": "SocketAddress", "signature": "@Override\n    public SocketAddress getLocalAddress()", "original_string": "    @Override\n    public SocketAddress getLocalAddress()\n        throws IOException\n    {\n        return delegate.getLocalAddress();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java", "class_name": "BaseDelegatingSocketChannel", "class_uri": "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java.BaseDelegatingSocketChannel", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "SocketAddress", "classes": []}, "docstring": "\n{@inheritDoc}\n\nForwards to {@link #delegate}.\n"}, {"uris": "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java.BaseDelegatingSocketChannel.[U]getOption(SocketOption<U>)", "name": "getOption", "arg_nums": 1, "params": [{"name": "name", "type": "SocketOption<U>"}], "return_type": "U", "signature": "@Override\n    public <U> U getOption(SocketOption<U> name)", "original_string": "    @Override\n    public <U> U getOption(SocketOption<U> name)\n        throws IOException\n    {\n        return delegate.getOption(name);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java", "class_name": "BaseDelegatingSocketChannel", "class_uri": "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java.BaseDelegatingSocketChannel", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "U", "classes": []}, "docstring": "\n{@inheritDoc}\n\nForwards to {@link #delegate}.\n"}, {"uris": "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java.BaseDelegatingSocketChannel.[SocketAddress]getRemoteAddress()", "name": "getRemoteAddress", "arg_nums": 0, "params": [], "return_type": "SocketAddress", "signature": "@Override\n    public SocketAddress getRemoteAddress()", "original_string": "    @Override\n    public SocketAddress getRemoteAddress()\n        throws IOException\n    {\n        return delegate.getRemoteAddress();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java", "class_name": "BaseDelegatingSocketChannel", "class_uri": "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java.BaseDelegatingSocketChannel", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "SocketAddress", "classes": []}, "docstring": "\n{@inheritDoc}\n\nForwards to {@link #delegate}.\n"}, {"uris": "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java.BaseDelegatingSocketChannel.[void]implCloseSelectableChannel()", "name": "implCloseSelectableChannel", "arg_nums": 0, "params": [], "return_type": "void", "signature": "@Override\n    protected void implCloseSelectableChannel()", "original_string": "    @Override\n    protected void implCloseSelectableChannel()\n        throws IOException\n    {\n        delegate.close();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java", "class_name": "BaseDelegatingSocketChannel", "class_uri": "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java.BaseDelegatingSocketChannel", "attributes": {"modifiers": "@Override\n    protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\n{@inheritDoc}\n\nForwards to {@link #delegate}.\n"}, {"uris": "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java.BaseDelegatingSocketChannel.[void]implConfigureBlocking(boolean)", "name": "implConfigureBlocking", "arg_nums": 1, "params": [{"name": "block", "type": "boolean"}], "return_type": "void", "signature": "@Override\n    protected void implConfigureBlocking(boolean block)", "original_string": "    @Override\n    protected void implConfigureBlocking(boolean block)\n        throws IOException\n    {\n        delegate.configureBlocking(block);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java", "class_name": "BaseDelegatingSocketChannel", "class_uri": "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java.BaseDelegatingSocketChannel", "attributes": {"modifiers": "@Override\n    protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "docstring": "\n{@inheritDoc}\n\nForwards to {@link #delegate}.\n"}, {"uris": "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java.BaseDelegatingSocketChannel.[Socket]implSocket(Socket)", "name": "implSocket", "arg_nums": 1, "params": [{"name": "socket", "type": "Socket"}], "return_type": "Socket", "signature": "protected Socket implSocket(Socket socket)", "original_string": "    protected Socket implSocket(Socket socket)\n        throws IOException\n    {\n        return new DelegatingSocket(socket, this);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java", "class_name": "BaseDelegatingSocketChannel", "class_uri": "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java.BaseDelegatingSocketChannel", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Socket", "classes": []}, "docstring": "\nAllows extenders to optionally configure (e.g. wrap) the {@code Socket}\nof {@link #delegate} and before it is returned by {@link #socket()}.\n\n@param socket the {@code Socket} of {@code delegate}\n@return the {@code Socket} to be returned by {@link #socket()} (in place\nof {@code socket})\n@throws IOException if an I/O error occurs\n"}, {"uris": "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java.BaseDelegatingSocketChannel.[boolean]isConnected()", "name": "isConnected", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "@Override\n    public boolean isConnected()", "original_string": "    @Override\n    public boolean isConnected()\n    {\n        return delegate.isConnected();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java", "class_name": "BaseDelegatingSocketChannel", "class_uri": "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java.BaseDelegatingSocketChannel", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\n{@inheritDoc}\n\nForwards to {@link #delegate}.\n"}, {"uris": "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java.BaseDelegatingSocketChannel.[boolean]isConnectionPending()", "name": "isConnectionPending", "arg_nums": 0, "params": [], "return_type": "boolean", "signature": "@Override\n    public boolean isConnectionPending()", "original_string": "    @Override\n    public boolean isConnectionPending()\n    {\n        return delegate.isConnectionPending();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java", "class_name": "BaseDelegatingSocketChannel", "class_uri": "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java.BaseDelegatingSocketChannel", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "docstring": "\n{@inheritDoc}\n\nForwards to {@link #delegate}.\n"}, {"uris": "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java.BaseDelegatingSocketChannel.[int]read(ByteBuffer)", "name": "read", "arg_nums": 1, "params": [{"name": "dst", "type": "ByteBuffer"}], "return_type": "int", "signature": "@Override\n    public int read(ByteBuffer dst)", "original_string": "    @Override\n    public int read(ByteBuffer dst)\n        throws IOException\n    {\n        return delegate.read(dst);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java", "class_name": "BaseDelegatingSocketChannel", "class_uri": "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java.BaseDelegatingSocketChannel", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\n{@inheritDoc}\n\nForwards to {@link #delegate}.\n"}, {"uris": "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java.BaseDelegatingSocketChannel.[long]read(ByteBuffer[],int,int)", "name": "read", "arg_nums": 3, "params": [{"name": "dsts", "type": "ByteBuffer[]"}, {"name": "offset", "type": "int"}, {"name": "length", "type": "int"}], "return_type": "long", "signature": "@Override\n    public long read(ByteBuffer[] dsts, int offset, int length)", "original_string": "    @Override\n    public long read(ByteBuffer[] dsts, int offset, int length)\n        throws IOException\n    {\n        return delegate.read(dsts, offset, length);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java", "class_name": "BaseDelegatingSocketChannel", "class_uri": "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java.BaseDelegatingSocketChannel", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "long", "classes": []}, "docstring": "\n{@inheritDoc}\n\nForwards to {@link #delegate}.\n"}, {"uris": "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java.BaseDelegatingSocketChannel.[SocketChannel]setOption(SocketOption<U>,U)", "name": "setOption", "arg_nums": 2, "params": [{"name": "name", "type": "SocketOption<U>"}, {"name": "value", "type": "U"}], "return_type": "SocketChannel", "signature": "@Override\n    public <U> SocketChannel setOption(SocketOption<U> name, U value)", "original_string": "    @Override\n    public <U> SocketChannel setOption(SocketOption<U> name, U value)\n        throws IOException\n    {\n        delegate.setOption(name, value);\n        return this;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java", "class_name": "BaseDelegatingSocketChannel", "class_uri": "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java.BaseDelegatingSocketChannel", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "SocketChannel", "classes": []}, "docstring": "\n{@inheritDoc}\n\nForwards to {@link #delegate} and returns {@code this}.\n"}, {"uris": "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java.BaseDelegatingSocketChannel.[SocketChannel]shutdownInput()", "name": "shutdownInput", "arg_nums": 0, "params": [], "return_type": "SocketChannel", "signature": "@Override\n    public SocketChannel shutdownInput()", "original_string": "    @Override\n    public SocketChannel shutdownInput()\n        throws IOException\n    {\n        delegate.shutdownInput();\n        return this;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java", "class_name": "BaseDelegatingSocketChannel", "class_uri": "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java.BaseDelegatingSocketChannel", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "SocketChannel", "classes": []}, "docstring": "\n{@inheritDoc}\n\nForwards to {@link #delegate} and returns {@code this}.\n"}, {"uris": "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java.BaseDelegatingSocketChannel.[SocketChannel]shutdownOutput()", "name": "shutdownOutput", "arg_nums": 0, "params": [], "return_type": "SocketChannel", "signature": "@Override\n    public SocketChannel shutdownOutput()", "original_string": "    @Override\n    public SocketChannel shutdownOutput()\n        throws IOException\n    {\n        delegate.shutdownOutput();\n        return this;\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java", "class_name": "BaseDelegatingSocketChannel", "class_uri": "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java.BaseDelegatingSocketChannel", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "SocketChannel", "classes": []}, "docstring": "\n{@inheritDoc}\n\nForwards to {@link #delegate} and returns {@code this}.\n"}, {"uris": "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java.BaseDelegatingSocketChannel.[Socket]socket()", "name": "socket", "arg_nums": 0, "params": [], "return_type": "Socket", "signature": "@Override\n    public Socket socket()", "original_string": "    @Override\n    public Socket socket()\n    {\n        Socket socket = delegate.socket();\n\n        synchronized (socketSyncRoot)\n        {\n            if (this.socket == null)\n            {\n                if (socket != null)\n                {\n                    try\n                    {\n                        this.socket = implSocket(socket);\n                    }\n                    catch (IOException ioe)\n                    {\n                        throw new RuntimeException(ioe);\n                    }\n                }\n            }\n            else if (socket == null)\n            {\n                this.socket = null;\n            }\n            else\n            {\n                // TODO For the sake of completeness, maybe check that the\n                // value of this.socket still delegates to the latest value of\n                // socket. However, the value of socket is very likely final so\n                // do not bother with it at the time of this writing.\n            }\n            return this.socket;\n        }\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java", "class_name": "BaseDelegatingSocketChannel", "class_uri": "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java.BaseDelegatingSocketChannel", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Socket", "classes": []}, "docstring": "\n{@inheritDoc}\n\nAllows wrapping the {@code socket} of {@link #delegate}.\n"}, {"uris": "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java.BaseDelegatingSocketChannel.[Set<SocketOption<?>>]supportedOptions()", "name": "supportedOptions", "arg_nums": 0, "params": [], "return_type": "Set<SocketOption<?>>", "signature": "@Override\n    public Set<SocketOption<?>> supportedOptions()", "original_string": "    @Override\n    public Set<SocketOption<?>> supportedOptions()\n    {\n        return delegate.supportedOptions();\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java", "class_name": "BaseDelegatingSocketChannel", "class_uri": "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java.BaseDelegatingSocketChannel", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Set<SocketOption<?>>", "classes": []}, "docstring": "\n{@inheritDoc}\n\nForwards to {@link #delegate}.\n"}, {"uris": "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java.BaseDelegatingSocketChannel.[int]write(ByteBuffer)", "name": "write", "arg_nums": 1, "params": [{"name": "src", "type": "ByteBuffer"}], "return_type": "int", "signature": "@Override\n    public int write(ByteBuffer src)", "original_string": "    @Override\n    public int write(ByteBuffer src)\n        throws IOException\n    {\n        return delegate.write(src);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java", "class_name": "BaseDelegatingSocketChannel", "class_uri": "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java.BaseDelegatingSocketChannel", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "docstring": "\n{@inheritDoc}\n\nForwards to {@link #delegate}.\n"}, {"uris": "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java.BaseDelegatingSocketChannel.[long]write(ByteBuffer[],int,int)", "name": "write", "arg_nums": 3, "params": [{"name": "srcs", "type": "ByteBuffer[]"}, {"name": "offset", "type": "int"}, {"name": "length", "type": "int"}], "return_type": "long", "signature": "@Override\n    public long write(ByteBuffer[] srcs, int offset, int length)", "original_string": "    @Override\n    public long write(ByteBuffer[] srcs, int offset, int length)\n        throws IOException\n    {\n        return delegate.write(srcs, offset, length);\n    }", "default_arguments": null, "file": "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java", "class_name": "BaseDelegatingSocketChannel", "class_uri": "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java.BaseDelegatingSocketChannel", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "long", "classes": []}, "docstring": "\n{@inheritDoc}\n\nForwards to {@link #delegate}.\n"}]