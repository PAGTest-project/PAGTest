[{"uris": "src/test/java/org/ice4j/TransactionSupportTests.java.TransactionSupportTests", "name": "TransactionSupportTests", "file_path": "src/test/java/org/ice4j/TransactionSupportTests.java", "superclasses": "", "methods": ["[void]testClientRetransmissions()", "[void]testServerRetransmissionHiding()", "[void]testServerResponseRetransmissions()", "[void]testUniqueIDs()", "[void]testClientTransactionMaxRetransmisssionsConfigurationParameter()", "[void]testMinWaitIntervalConfigurationParameter()", "[void]testMaxWaitIntervalConfigurationParameter()"], "method_uris": ["src/test/java/org/ice4j/TransactionSupportTests.java.TransactionSupportTests.[void]setUp()", "src/test/java/org/ice4j/TransactionSupportTests.java.TransactionSupportTests.[void]tearDown()"], "overrides": null, "attributes": [{"original_string": "    private static class PlainRequestCollector\n        implements RequestListener\n    {\n        /**\n         *\n         */\n        private final Vector<StunMessageEvent> receivedRequestsVector\n            = new Vector<>();\n\n        /**\n         * Logs the newly received request.\n         *\n         * @param evt the {@link StunMessageEvent} to log.\n         */\n        public void processRequest(StunMessageEvent evt)\n        {\n\n            synchronized(this)\n            {\n                receivedRequestsVector.add(evt);\n                notifyAll();\n            }\n        }\n\n        /**\n         * Only return requests from the specified tran because we might have\n         * capture others too.\n         *\n         * @param tranid the transaction that we'd like to get requests for.\n         *\n         * @return a Vector containing all request that we have received and\n         * that match <tt>tranid</tt>.\n         */\n        public Vector<StunMessageEvent> getRequestsForTransaction(byte[] tranid)\n        {\n            Vector<StunMessageEvent> newVec = new Vector<>();\n\n            for (StunMessageEvent evt : receivedRequestsVector)\n            {\n                Message msg = evt.getMessage();\n                if( Arrays.equals(tranid, msg.getTransactionID()))\n                    newVec.add(evt);\n            }\n\n            return newVec;\n        }\n\n        /**\n         * Blocks until a request arrives or 50 ms pass.\n         */\n        public void waitForRequest()\n        {\n            waitForRequest(50);\n        }\n\n        /**\n         * Blocks until a request arrives or the timeout passes.\n         */\n        public void waitForRequest(long timeoutMillis)\n        {\n            synchronized(this)\n            {\n                try\n                {\n                    wait(timeoutMillis);\n                }\n                catch (InterruptedException e)\n                {\n                    Thread.currentThread().interrupt();\n                }\n            }\n        }\n    }", "definition": "    private static class PlainRequestCollector\n        implements RequestListener", "class_docstring": "\nA simply utility for asynchronous collection of requests.\n", "name": "PlainRequestCollector", "super_interfaces": ["RequestListener"], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "private final Vector<StunMessageEvent> receivedRequestsVector\n            = new Vector<>();", "docstring": "\n\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Vector<StunMessageEvent>", "name": "receivedRequestsVector\n            = new Vector<>()", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public void processRequest(StunMessageEvent evt)\n        {\n\n            synchronized(this)\n            {\n                receivedRequestsVector.add(evt);\n                notifyAll();\n            }\n        }", "docstring": "\nLogs the newly received request.\n\n@param evt the {@link StunMessageEvent} to log.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "processRequest", "params": [{"name": "evt", "type": "StunMessageEvent"}], "body": "        {\n\n            synchronized(this)\n            {\n                receivedRequestsVector.add(evt);\n                notifyAll();\n            }\n        }", "signature": "public void processRequest(StunMessageEvent evt)"}, {"syntax_pass": true, "original_string": "        public Vector<StunMessageEvent> getRequestsForTransaction(byte[] tranid)\n        {\n            Vector<StunMessageEvent> newVec = new Vector<>();\n\n            for (StunMessageEvent evt : receivedRequestsVector)\n            {\n                Message msg = evt.getMessage();\n                if( Arrays.equals(tranid, msg.getTransactionID()))\n                    newVec.add(evt);\n            }\n\n            return newVec;\n        }", "docstring": "\nOnly return requests from the specified tran because we might have\ncapture others too.\n\n@param tranid the transaction that we'd like to get requests for.\n\n@return a Vector containing all request that we have received and\nthat match <tt>tranid</tt>.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Vector<StunMessageEvent>", "classes": []}, "name": "getRequestsForTransaction", "params": [{"name": "tranid", "type": "byte[]"}], "body": "        {\n            Vector<StunMessageEvent> newVec = new Vector<>();\n\n            for (StunMessageEvent evt : receivedRequestsVector)\n            {\n                Message msg = evt.getMessage();\n                if( Arrays.equals(tranid, msg.getTransactionID()))\n                    newVec.add(evt);\n            }\n\n            return newVec;\n        }", "signature": "public Vector<StunMessageEvent> getRequestsForTransaction(byte[] tranid)"}, {"syntax_pass": true, "original_string": "        public void waitForRequest()\n        {\n            waitForRequest(50);\n        }", "docstring": "\nBlocks until a request arrives or 50 ms pass.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "waitForRequest", "params": [], "body": "        {\n            waitForRequest(50);\n        }", "signature": "public void waitForRequest()"}, {"syntax_pass": true, "original_string": "        public void waitForRequest(long timeoutMillis)\n        {\n            synchronized(this)\n            {\n                try\n                {\n                    wait(timeoutMillis);\n                }\n                catch (InterruptedException e)\n                {\n                    Thread.currentThread().interrupt();\n                }\n            }\n        }", "docstring": "\nBlocks until a request arrives or the timeout passes.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "waitForRequest", "params": [{"name": "timeoutMillis", "type": "long"}], "body": "        {\n            synchronized(this)\n            {\n                try\n                {\n                    wait(timeoutMillis);\n                }\n                catch (InterruptedException e)\n                {\n                    Thread.currentThread().interrupt();\n                }\n            }\n        }", "signature": "public void waitForRequest(long timeoutMillis)"}]}, {"original_string": "    private static class PlainResponseCollector\n        extends AbstractResponseCollector\n    {\n        /**\n         * The responses we've collected so far.\n         */\n        public final Vector<Object> receivedResponses = new Vector<>();\n\n        /**\n         * Notifies this <tt>ResponseCollector</tt> that a transaction described by\n         * the specified <tt>BaseStunMessageEvent</tt> has failed. The possible\n         * reasons for the failure include timeouts, unreachable destination, etc.\n         *\n         * @param event the <tt>BaseStunMessageEvent</tt> which describes the failed\n         * transaction and the runtime type of which specifies the failure reason\n         * @see AbstractResponseCollector#processFailure(BaseStunMessageEvent)\n         */\n        protected synchronized void processFailure(BaseStunMessageEvent event)\n        {\n            String receivedResponse;\n\n            if (event instanceof StunFailureEvent)\n                receivedResponse = \"unreachable\";\n            else if (event instanceof StunTimeoutEvent)\n                receivedResponse = \"timeout\";\n            else\n                receivedResponse = \"failure\";\n            receivedResponses.add(receivedResponse);\n            notifyAll();\n        }\n\n        /**\n         * Logs the received <tt>response</tt>\n         *\n         * @param response the event to log.\n         */\n        public synchronized void processResponse(StunResponseEvent response)\n        {\n            receivedResponses.add(response);\n            notifyAll();\n        }\n    }", "definition": "    private static class PlainResponseCollector\n        extends AbstractResponseCollector", "class_docstring": "\nA simple utility for asynchronously collecting responses.\n", "name": "PlainResponseCollector", "super_interfaces": [], "superclasses": "AbstractResponseCollector", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "public final Vector<Object> receivedResponses = new Vector<>();", "docstring": "\nThe responses we've collected so far.\n", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Vector<Object>", "name": "receivedResponses = new Vector<>()", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        protected synchronized void processFailure(BaseStunMessageEvent event)\n        {\n            String receivedResponse;\n\n            if (event instanceof StunFailureEvent)\n                receivedResponse = \"unreachable\";\n            else if (event instanceof StunTimeoutEvent)\n                receivedResponse = \"timeout\";\n            else\n                receivedResponse = \"failure\";\n            receivedResponses.add(receivedResponse);\n            notifyAll();\n        }", "docstring": "\nNotifies this <tt>ResponseCollector</tt> that a transaction described by\nthe specified <tt>BaseStunMessageEvent</tt> has failed. The possible\nreasons for the failure include timeouts, unreachable destination, etc.\n\n@param event the <tt>BaseStunMessageEvent</tt> which describes the failed\ntransaction and the runtime type of which specifies the failure reason\n@see AbstractResponseCollector#processFailure(BaseStunMessageEvent)\n", "attributes": {"modifiers": "protected synchronized", "marker_annotations": [], "non_marker_annotations": ["protected", "synchronized"], "comments": [], "return_type": "void", "classes": []}, "name": "processFailure", "params": [{"name": "event", "type": "BaseStunMessageEvent"}], "body": "        {\n            String receivedResponse;\n\n            if (event instanceof StunFailureEvent)\n                receivedResponse = \"unreachable\";\n            else if (event instanceof StunTimeoutEvent)\n                receivedResponse = \"timeout\";\n            else\n                receivedResponse = \"failure\";\n            receivedResponses.add(receivedResponse);\n            notifyAll();\n        }", "signature": "protected synchronized void processFailure(BaseStunMessageEvent event)"}, {"syntax_pass": true, "original_string": "        public synchronized void processResponse(StunResponseEvent response)\n        {\n            receivedResponses.add(response);\n            notifyAll();\n        }", "docstring": "\nLogs the received <tt>response</tt>\n\n@param response the event to log.\n", "attributes": {"modifiers": "public synchronized", "marker_annotations": [], "non_marker_annotations": ["public", "synchronized"], "comments": [], "return_type": "void", "classes": []}, "name": "processResponse", "params": [{"name": "response", "type": "StunResponseEvent"}], "body": "        {\n            receivedResponses.add(response);\n            notifyAll();\n        }", "signature": "public synchronized void processResponse(StunResponseEvent response)"}]}], "class_docstring": "\nTest how client and server behave, how they recognize/adopt messages and\nhow they both handle retransmissions (i.e. client transactions should make\nthem and server transactions should hide them)\n\n@author Emil Ivov\n", "original_string": "public class TransactionSupportTests\n{\n    /**\n     * The client address we use for this test.\n     */\n    TransportAddress clientAddress;\n\n    /**\n     * The client address we use for this test.\n     */\n    TransportAddress serverAddress;\n\n    /**\n     * The socket the client uses in this test.\n     */\n    IceSocketWrapper clientSock = null;\n\n    /**\n     * The socket the server uses in this test.\n     */\n    IceSocketWrapper serverSock = null;\n\n    /**\n     * The <tt>StunStack</tt> used by this <tt>TransactionSupportTests</tt>.\n     */\n    private StunStack stunStack;\n\n    /**\n     * The request we send in this test.\n     */\n    Request  bindingRequest = null;\n\n    /**\n     * The response we send in this test.\n     */\n    Response bindingResponse = null;\n\n    /**\n     * The tool that collects requests.\n     */\n    PlainRequestCollector requestCollector = null;\n\n    /**\n     * The tool that collects responses.\n     */\n    PlainResponseCollector responseCollector = null;\n\n    /**\n     * Inits sockets.\n     *\n     * @throws Exception if something goes bad.\n     */\n    @BeforeEach\n    public void setUp()\n        throws Exception\n    {\n        clientSock = new IceUdpSocketWrapper(\n            new SafeCloseDatagramSocket(new InetSocketAddress(\"127.0.0.1\", 0)));\n        serverSock = new IceUdpSocketWrapper(\n            new SafeCloseDatagramSocket(new InetSocketAddress(\"127.0.0.1\", 0)));\n\n        clientAddress\n            = new TransportAddress(\"127.0.0.1\", clientSock.getLocalPort(), Transport.UDP);\n        serverAddress\n            = new TransportAddress(\"127.0.0.1\", serverSock.getLocalPort(), Transport.UDP);\n\n        stunStack = new StunStack();\n        stunStack.addSocket(clientSock);\n        stunStack.addSocket(serverSock);\n\n        bindingRequest = MessageFactory.createBindingRequest();\n        bindingResponse = MessageFactory.create3489BindingResponse(\n            clientAddress, clientAddress, serverAddress);\n\n        requestCollector = new PlainRequestCollector();\n        responseCollector = new PlainResponseCollector();\n\n        System.setProperty(\n                StackProperties.PROPAGATE_RECEIVED_RETRANSMISSIONS,\n                \"false\");\n        System.setProperty(\n                StackProperties.KEEP_CRANS_AFTER_A_RESPONSE,\n                \"false\");\n        System.setProperty(\n                StackProperties.MAX_CTRAN_RETRANSMISSIONS,\n                \"\");\n        System.setProperty(\n                StackProperties.MAX_CTRAN_RETRANS_TIMER,\n                \"\");\n        System.setProperty(\n                StackProperties.FIRST_CTRAN_RETRANS_AFTER,\n                \"\");\n    }\n\n    /**\n     * Frees all sockets that we are currently using.\n     *\n     * @throws Exception if something does not go as planned.\n     */\n    @AfterEach\n    public void tearDown()\n        throws Exception\n    {\n        stunStack.removeSocket(clientAddress);\n        stunStack.removeSocket(serverAddress);\n\n        clientSock.close();\n        serverSock.close();\n\n        requestCollector = null;\n        responseCollector = null;\n\n        System.setProperty(\n                StackProperties.PROPAGATE_RECEIVED_RETRANSMISSIONS,\n                \"false\");\n        System.setProperty(\n                StackProperties.KEEP_CRANS_AFTER_A_RESPONSE,\n                \"false\");\n        System.setProperty(\n                StackProperties.MAX_CTRAN_RETRANSMISSIONS,\n                \"\");\n        System.setProperty(\n                StackProperties.MAX_CTRAN_RETRANS_TIMER,\n                \"\");\n        System.setProperty(\n                StackProperties.FIRST_CTRAN_RETRANS_AFTER,\n                \"\");\n    }\n\n    /**\n     * Test that requests are retransmitted if no response is received\n     *\n     * @throws java.lang.Exception upon any failure\n     */\n    @Test\n    public void testClientRetransmissions() throws Exception\n    {\n        String oldRetransValue = System.getProperty(\n                                     StackProperties.MAX_CTRAN_RETRANSMISSIONS);\n        String oldMaxWaitValue = System.getProperty(\n                                     StackProperties.MAX_CTRAN_RETRANS_TIMER);\n\n        System.setProperty(StackProperties.MAX_CTRAN_RETRANS_TIMER, \"100\");\n        System.setProperty(StackProperties.MAX_CTRAN_RETRANSMISSIONS, \"2\");\n\n        //prepare to listen\n        System.setProperty(StackProperties.PROPAGATE_RECEIVED_RETRANSMISSIONS,\n                           \"true\");\n\n        stunStack.addRequestListener(serverAddress, requestCollector);\n        //send\n        stunStack.sendRequest(\n                bindingRequest,\n                serverAddress,\n                clientAddress,\n                responseCollector);\n\n        //wait for retransmissions\n        Thread.sleep(1000);\n\n        //verify\n        Vector<StunMessageEvent> reqs\n            = requestCollector.getRequestsForTransaction(\n                                bindingRequest.getTransactionID());\n\n        assertTrue(reqs.size() > 1,\n            \"No retransmissions of the request have been received\");\n        assertTrue(reqs.size() >= 3,\n            \"The binding request has been retransmitted more than it should have!\");\n\n        //restore the retransmissions prop in case others are counting on\n        //defaults.\n        if(oldRetransValue != null)\n            System.getProperty( StackProperties.MAX_CTRAN_RETRANSMISSIONS,\n                                oldRetransValue);\n        else\n            System.clearProperty(StackProperties.MAX_CTRAN_RETRANSMISSIONS);\n\n        if(oldMaxWaitValue != null)\n            System.getProperty( StackProperties.MAX_CTRAN_RETRANS_TIMER,\n                                oldRetransValue);\n        else\n            System.clearProperty(StackProperties.MAX_CTRAN_RETRANS_TIMER);\n    }\n\n    /**\n     * Make sure that retransmissions are not seen by the server user and that\n     * it only gets a single request.\n     *\n     * @throws Exception if anything goes wrong.\n     */\n    @Test\n    public void testServerRetransmissionHiding() throws Exception\n    {\n        String oldRetransValue = System.getProperty(\n                StackProperties.MAX_CTRAN_RETRANSMISSIONS);\n        System.setProperty(StackProperties.MAX_CTRAN_RETRANSMISSIONS, \"2\");\n        //prepare to listen\n        stunStack.addRequestListener(serverAddress, requestCollector);\n        //send\n        stunStack.sendRequest(\n                bindingRequest,\n                serverAddress,\n                clientAddress,\n                responseCollector);\n\n        //wait for retransmissions\n        Thread.sleep(1000);\n\n        //verify\n        Vector<StunMessageEvent> reqs\n            = requestCollector.getRequestsForTransaction(\n                bindingRequest.getTransactionID());\n\n        assertTrue(reqs.size() <= 1,\n            \"Retransmissions of a binding request were propagated to the server\");\n\n        //restore the retransmissions prop in case others are counting on\n        //defaults.\n        if(oldRetransValue != null)\n            System.getProperty( StackProperties.MAX_CTRAN_RETRANSMISSIONS,\n                                oldRetransValue);\n        else\n            System.clearProperty(StackProperties.MAX_CTRAN_RETRANSMISSIONS);\n    }\n\n    /**\n     * Makes sure that once a request has been answered by the server,\n     * retransmissions of this request are not propagated to the UA and are\n     * automatically handled with a retransmission of the last seen response\n     *\n     * @throws Exception if we screw up.\n     */\n    @Test\n    public void testServerResponseRetransmissions() throws Exception\n    {\n        String oldRetransValue = System.getProperty(\n            StackProperties.MAX_CTRAN_RETRANSMISSIONS);\n        System.setProperty(StackProperties.MAX_CTRAN_RETRANSMISSIONS, \"2\");\n        System.setProperty(StackProperties.MAX_CTRAN_RETRANS_TIMER, \"100\");\n\n        //prepare to listen\n        System.setProperty(\n                StackProperties.KEEP_CRANS_AFTER_A_RESPONSE,\n                \"true\");\n        stunStack.addRequestListener(serverAddress, requestCollector);\n        //send\n        stunStack.sendRequest(\n                bindingRequest,\n                serverAddress,\n                clientAddress,\n                responseCollector);\n\n        //wait for the message to arrive\n        requestCollector.waitForRequest();\n\n        Vector<StunMessageEvent> reqs = requestCollector\n            .getRequestsForTransaction( bindingRequest.getTransactionID());\n\n        StunMessageEvent evt = reqs.get(0);\n\n        byte[] tid = evt.getMessage().getTransactionID();\n\n        stunStack.sendResponse(\n                tid,\n                bindingResponse,\n                serverAddress,\n                clientAddress);\n\n        //wait for retransmissions\n        Thread.sleep(500);\n\n        //verify that we received a fair number of retransmitted responses.\n        assertTrue(responseCollector.receivedResponses.size() < 3,\n            \"There were too few retransmissions of a binding response: \"\n                        +responseCollector.receivedResponses.size());\n\n        //restore the retransmissions prop in case others are counting on\n        //defaults.\n        if(oldRetransValue != null)\n            System.getProperty( StackProperties.MAX_CTRAN_RETRANSMISSIONS,\n                                oldRetransValue);\n        else\n            System.clearProperty(StackProperties.MAX_CTRAN_RETRANSMISSIONS);\n\n        System.clearProperty(StackProperties.MAX_CTRAN_RETRANS_TIMER);\n    }\n\n    /**\n     * A (very) weak test, verifying that transaction IDs are unique.\n     * @throws Exception in case we feel like it.\n     */\n    @Test\n    public void testUniqueIDs() throws Exception\n    {\n        stunStack.addRequestListener(serverAddress, requestCollector);\n        //send req 1\n        stunStack.sendRequest(\n                bindingRequest,\n                serverAddress,\n                clientAddress,\n                responseCollector);\n\n        //wait for retransmissions\n        requestCollector.waitForRequest();\n\n        Vector<StunMessageEvent> reqs1 = requestCollector\n            .getRequestsForTransaction( bindingRequest.getTransactionID());\n\n        StunMessageEvent evt1 = reqs1.get(0);\n\n        //send a response to make the other guy shut up\n        byte[] tid = evt1.getMessage().getTransactionID();\n\n        stunStack.sendResponse(\n                tid,\n                bindingResponse,\n                serverAddress,\n                clientAddress);\n\n        //send req 2\n        stunStack.sendRequest(\n                bindingRequest,\n                serverAddress,\n                clientAddress,\n                responseCollector);\n\n        //wait for retransmissions\n        Thread.sleep(1000);\n\n        Vector<StunMessageEvent> reqs2\n            = requestCollector.getRequestsForTransaction(\n                bindingRequest.getTransactionID());\n\n        StunMessageEvent evt2 = reqs2.get(0);\n\n        assertFalse(Arrays.equals(\n            evt1.getMessage().getTransactionID(),\n            evt2.getMessage().getTransactionID()),\n            \"Consecutive requests were assigned the same transaction id\"\n        );\n    }\n\n    /**\n     * Tests whether the properties for configuring the maximum number of\n     * retransmissions in a transaction are working properly.\n     *\n     * @throws Exception if the gods so decide.\n     */\n    @Test\n    public void testClientTransactionMaxRetransmisssionsConfigurationParameter()\n        throws Exception\n    {\n        //MAX_RETRANSMISSIONS\n\n        System.setProperty(StackProperties.MAX_CTRAN_RETRANSMISSIONS, \"2\");\n        //make sure we see retransmissions so that we may count them\n        System.setProperty(\n                StackProperties.PROPAGATE_RECEIVED_RETRANSMISSIONS,\n                \"true\");\n        stunStack.addRequestListener(\n                        serverAddress, requestCollector);\n        //send\n        stunStack.sendRequest(\n                bindingRequest,\n                serverAddress,\n                clientAddress,\n                responseCollector);\n        //wait for retransmissions\n        Thread.sleep(1600);\n\n        //verify\n        Vector<StunMessageEvent> reqs\n            = requestCollector.getRequestsForTransaction(\n                bindingRequest.getTransactionID());\n\n        assertTrue(reqs.size() > 1,\n            \"No retransmissions of the request have been received\");\n        assertEquals(3, reqs.size(),\n            \"The MAX_RETRANSMISSIONS param was not taken into account!\");\n    }\n\n    /**\n     * Tests whether the properties for configuring the minimum transaction\n     * wait interval is working properly.\n     *\n     * @throws Exception if we are having a bad day.\n     */\n    @Test\n    public void testMinWaitIntervalConfigurationParameter()\n        throws Exception\n    {\n        //MAX_RETRANSMISSIONS\n        System.setProperty(StackProperties.FIRST_CTRAN_RETRANS_AFTER, \"50\");\n        //make sure we see retransmissions so that we may count them\n        System.setProperty(\n                StackProperties.PROPAGATE_RECEIVED_RETRANSMISSIONS,\n                \"true\");\n        stunStack.addRequestListener(serverAddress, requestCollector);\n        //send\n        stunStack.sendRequest(\n                bindingRequest,\n                serverAddress,\n                clientAddress,\n                responseCollector);\n\n        //wait a while\n        requestCollector.waitForRequest();\n\n        //verify\n        Vector<?> reqs = requestCollector.getRequestsForTransaction(\n                                bindingRequest.getTransactionID());\n        assertTrue(reqs.size() < 2,\n            \"A retransmissions of the request was sent too early\");\n\n        //wait for a send\n        Thread.sleep(110);\n\n        reqs = requestCollector.getRequestsForTransaction(\n                                bindingRequest.getTransactionID());\n\n        //verify\n        assertEquals(2, reqs.size(),\n            \"A retransmissions of the request was not sent\");\n    }\n\n    /**\n     * Tests whether the properties for configuring the maximum transaction\n     * wait interval is working properly.\n     *\n     * @throws Exception if the gods so decide.\n     */\n    @Test\n    public void testMaxWaitIntervalConfigurationParameter()\n        throws Exception\n    {\n        //MAX_RETRANSMISSIONS\n        System.setProperty(StackProperties.MAX_CTRAN_RETRANS_TIMER,\n                           \"100\");\n        //make sure we see retransmissions so that we may count them\n        System.setProperty(StackProperties.PROPAGATE_RECEIVED_RETRANSMISSIONS,\n                           \"true\");\n        System.setProperty(StackProperties.MAX_CTRAN_RETRANSMISSIONS,\n                           \"11\");\n        stunStack.addRequestListener(serverAddress, requestCollector);\n        //send\n        stunStack.sendRequest(\n                bindingRequest,\n                serverAddress,\n                clientAddress,\n                responseCollector);\n\n        //wait until a response arrives\n        synchronized (responseCollector)\n        {\n            responseCollector.wait(5000);\n        }\n\n        //verify\n        Vector<StunMessageEvent> reqs\n            = requestCollector.getRequestsForTransaction(\n                                bindingRequest.getTransactionID());\n        assertEquals(12, reqs.size(),\n            \"Not all retransmissions were made for the expected period of time\");\n\n        //wait for a send\n        requestCollector.waitForRequest(1800);\n\n        //verify\n        reqs = requestCollector.getRequestsForTransaction(\n                                bindingRequest.getTransactionID());\n        assertEquals(12, reqs.size(),\n            \"A retransmissions of the request was sent, while not supposed to\");\n    }\n\n    /**\n     * A simply utility for asynchronous collection of requests.\n     */\n    private static class PlainRequestCollector\n        implements RequestListener\n    {\n        /**\n         *\n         */\n        private final Vector<StunMessageEvent> receivedRequestsVector\n            = new Vector<>();\n\n        /**\n         * Logs the newly received request.\n         *\n         * @param evt the {@link StunMessageEvent} to log.\n         */\n        public void processRequest(StunMessageEvent evt)\n        {\n\n            synchronized(this)\n            {\n                receivedRequestsVector.add(evt);\n                notifyAll();\n            }\n        }\n\n        /**\n         * Only return requests from the specified tran because we might have\n         * capture others too.\n         *\n         * @param tranid the transaction that we'd like to get requests for.\n         *\n         * @return a Vector containing all request that we have received and\n         * that match <tt>tranid</tt>.\n         */\n        public Vector<StunMessageEvent> getRequestsForTransaction(byte[] tranid)\n        {\n            Vector<StunMessageEvent> newVec = new Vector<>();\n\n            for (StunMessageEvent evt : receivedRequestsVector)\n            {\n                Message msg = evt.getMessage();\n                if( Arrays.equals(tranid, msg.getTransactionID()))\n                    newVec.add(evt);\n            }\n\n            return newVec;\n        }\n\n        /**\n         * Blocks until a request arrives or 50 ms pass.\n         */\n        public void waitForRequest()\n        {\n            waitForRequest(50);\n        }\n\n        /**\n         * Blocks until a request arrives or the timeout passes.\n         */\n        public void waitForRequest(long timeoutMillis)\n        {\n            synchronized(this)\n            {\n                try\n                {\n                    wait(timeoutMillis);\n                }\n                catch (InterruptedException e)\n                {\n                    Thread.currentThread().interrupt();\n                }\n            }\n        }\n    }\n\n    /**\n     * A simple utility for asynchronously collecting responses.\n     */\n    private static class PlainResponseCollector\n        extends AbstractResponseCollector\n    {\n        /**\n         * The responses we've collected so far.\n         */\n        public final Vector<Object> receivedResponses = new Vector<>();\n\n        /**\n         * Notifies this <tt>ResponseCollector</tt> that a transaction described by\n         * the specified <tt>BaseStunMessageEvent</tt> has failed. The possible\n         * reasons for the failure include timeouts, unreachable destination, etc.\n         *\n         * @param event the <tt>BaseStunMessageEvent</tt> which describes the failed\n         * transaction and the runtime type of which specifies the failure reason\n         * @see AbstractResponseCollector#processFailure(BaseStunMessageEvent)\n         */\n        protected synchronized void processFailure(BaseStunMessageEvent event)\n        {\n            String receivedResponse;\n\n            if (event instanceof StunFailureEvent)\n                receivedResponse = \"unreachable\";\n            else if (event instanceof StunTimeoutEvent)\n                receivedResponse = \"timeout\";\n            else\n                receivedResponse = \"failure\";\n            receivedResponses.add(receivedResponse);\n            notifyAll();\n        }\n\n        /**\n         * Logs the received <tt>response</tt>\n         *\n         * @param response the event to log.\n         */\n        public synchronized void processResponse(StunResponseEvent response)\n        {\n            receivedResponses.add(response);\n            notifyAll();\n        }\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "TransportAddress clientAddress;", "docstring": "\nThe client address we use for this test.\n", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "TransportAddress", "name": "clientAddress", "syntax_pass": true}, {"attribute_expression": "TransportAddress serverAddress;", "docstring": "\nThe client address we use for this test.\n", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "TransportAddress", "name": "serverAddress", "syntax_pass": true}, {"attribute_expression": "IceSocketWrapper clientSock = null;", "docstring": "\nThe socket the client uses in this test.\n", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "IceSocketWrapper", "name": "clientSock = null", "syntax_pass": true}, {"attribute_expression": "IceSocketWrapper serverSock = null;", "docstring": "\nThe socket the server uses in this test.\n", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "IceSocketWrapper", "name": "serverSock = null", "syntax_pass": true}, {"attribute_expression": "private StunStack stunStack;", "docstring": "\nThe <tt>StunStack</tt> used by this <tt>TransactionSupportTests</tt>.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "StunStack", "name": "stunStack", "syntax_pass": true}, {"attribute_expression": "Request  bindingRequest = null;", "docstring": "\nThe request we send in this test.\n", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "Request", "name": "bindingRequest = null", "syntax_pass": true}, {"attribute_expression": "Response bindingResponse = null;", "docstring": "\nThe response we send in this test.\n", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "Response", "name": "bindingResponse = null", "syntax_pass": true}, {"attribute_expression": "PlainRequestCollector requestCollector = null;", "docstring": "\nThe tool that collects requests.\n", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "PlainRequestCollector", "name": "requestCollector = null", "syntax_pass": true}, {"attribute_expression": "PlainResponseCollector responseCollector = null;", "docstring": "\nThe tool that collects responses.\n", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "PlainResponseCollector", "name": "responseCollector = null", "syntax_pass": true}]}, {"uris": "src/test/java/org/ice4j/MessageEventDispatchingTest.java.MessageEventDispatchingTest", "name": "MessageEventDispatchingTest", "file_path": "src/test/java/org/ice4j/MessageEventDispatchingTest.java", "superclasses": "", "methods": ["[void]testClientTransactionTimeouts()", "[void]testEventDispatchingUponIncomingRequests()", "[void]testSelectiveEventDispatchingUponIncomingRequests()", "[void]testServerResponseRetransmissions()"], "method_uris": ["src/test/java/org/ice4j/MessageEventDispatchingTest.java.MessageEventDispatchingTest.[void]setUp()", "src/test/java/org/ice4j/MessageEventDispatchingTest.java.MessageEventDispatchingTest.[void]tearDown()"], "overrides": null, "attributes": [{"original_string": "    private static class PlainRequestCollector implements RequestListener\n    {\n        /** all requests we've received so far. */\n        public final Vector<StunMessageEvent> receivedRequests = new Vector<>();\n\n        /**\n         * Stores incoming requests.\n         *\n         * @param evt the event containing the incoming request.\n         */\n        public void processRequest(StunMessageEvent evt)\n        {\n            synchronized (this)\n            {\n                receivedRequests.add(evt);\n                notifyAll();\n            }\n        }\n\n        public void waitForRequest()\n        {\n            synchronized(this)\n            {\n                if (receivedRequests.size() > 0)\n                    return;\n                try\n                {\n                    wait(50);\n                }\n                catch (InterruptedException e)\n                {}\n            }\n        }\n    }", "definition": "    private static class PlainRequestCollector implements RequestListener", "class_docstring": "\nA utility class we use to collect incoming requests.\n", "name": "PlainRequestCollector", "super_interfaces": ["RequestListener"], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "public final Vector<StunMessageEvent> receivedRequests = new Vector<>();", "docstring": " all requests we've received so far.", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Vector<StunMessageEvent>", "name": "receivedRequests = new Vector<>()", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public void processRequest(StunMessageEvent evt)\n        {\n            synchronized (this)\n            {\n                receivedRequests.add(evt);\n                notifyAll();\n            }\n        }", "docstring": "\nStores incoming requests.\n\n@param evt the event containing the incoming request.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "processRequest", "params": [{"name": "evt", "type": "StunMessageEvent"}], "body": "        {\n            synchronized (this)\n            {\n                receivedRequests.add(evt);\n                notifyAll();\n            }\n        }", "signature": "public void processRequest(StunMessageEvent evt)"}, {"syntax_pass": true, "original_string": "        public void waitForRequest()\n        {\n            synchronized(this)\n            {\n                if (receivedRequests.size() > 0)\n                    return;\n                try\n                {\n                    wait(50);\n                }\n                catch (InterruptedException e)\n                {}\n            }\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "waitForRequest", "params": [], "body": "        {\n            synchronized(this)\n            {\n                if (receivedRequests.size() > 0)\n                    return;\n                try\n                {\n                    wait(50);\n                }\n                catch (InterruptedException e)\n                {}\n            }\n        }", "signature": "public void waitForRequest()"}]}, {"original_string": "    private static class PlainResponseCollector\n        extends AbstractResponseCollector\n    {\n        public final Vector<Object> receivedResponses = new Vector<>();\n\n        /**\n         * Notifies this <tt>ResponseCollector</tt> that a transaction described by\n         * the specified <tt>BaseStunMessageEvent</tt> has failed. The possible\n         * reasons for the failure include timeouts, unreachable destination, etc.\n         *\n         * @param event the <tt>BaseStunMessageEvent</tt> which describes the failed\n         * transaction and the runtime type of which specifies the failure reason\n         * @see AbstractResponseCollector#processFailure(BaseStunMessageEvent)\n         */\n        protected synchronized void processFailure(BaseStunMessageEvent event)\n        {\n            String receivedResponse;\n\n            if (event instanceof StunFailureEvent)\n                receivedResponse = \"unreachable\";\n            else if (event instanceof StunTimeoutEvent)\n                receivedResponse = \"timeout\";\n            else\n                receivedResponse = \"failure\";\n            receivedResponses.add(receivedResponse);\n            notifyAll();\n        }\n\n        /**\n         * Stores incoming responses.\n         *\n         * @param response a <tt>StunMessageEvent</tt> which describes the\n         * received STUN <tt>Response</tt>\n         */\n        public synchronized void processResponse(StunResponseEvent response)\n        {\n            receivedResponses.add(response);\n            notifyAll();\n        }\n\n        /**\n         * Waits for a short period of time for a response to arrive\n         */\n        public synchronized void waitForResponse()\n        {\n            try\n            {\n                if (receivedResponses.size() == 0)\n                    wait(50);\n            }\n            catch (InterruptedException e)\n            {\n            }\n        }\n\n        /**\n         * Waits for a long period of time for a timeout trigger to fire.\n         */\n        public synchronized void waitForTimeout()\n        {\n            try\n            {\n                if (receivedResponses.size() == 0)\n                    wait(12000);\n            }\n            catch (InterruptedException e)\n            {\n            }\n        }\n    }", "definition": "    private static class PlainResponseCollector\n        extends AbstractResponseCollector", "class_docstring": "\nA utility class to collect incoming responses.\n", "name": "PlainResponseCollector", "super_interfaces": [], "superclasses": "AbstractResponseCollector", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "public final Vector<Object> receivedResponses = new Vector<>();", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "Vector<Object>", "name": "receivedResponses = new Vector<>()", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        protected synchronized void processFailure(BaseStunMessageEvent event)\n        {\n            String receivedResponse;\n\n            if (event instanceof StunFailureEvent)\n                receivedResponse = \"unreachable\";\n            else if (event instanceof StunTimeoutEvent)\n                receivedResponse = \"timeout\";\n            else\n                receivedResponse = \"failure\";\n            receivedResponses.add(receivedResponse);\n            notifyAll();\n        }", "docstring": "\nNotifies this <tt>ResponseCollector</tt> that a transaction described by\nthe specified <tt>BaseStunMessageEvent</tt> has failed. The possible\nreasons for the failure include timeouts, unreachable destination, etc.\n\n@param event the <tt>BaseStunMessageEvent</tt> which describes the failed\ntransaction and the runtime type of which specifies the failure reason\n@see AbstractResponseCollector#processFailure(BaseStunMessageEvent)\n", "attributes": {"modifiers": "protected synchronized", "marker_annotations": [], "non_marker_annotations": ["protected", "synchronized"], "comments": [], "return_type": "void", "classes": []}, "name": "processFailure", "params": [{"name": "event", "type": "BaseStunMessageEvent"}], "body": "        {\n            String receivedResponse;\n\n            if (event instanceof StunFailureEvent)\n                receivedResponse = \"unreachable\";\n            else if (event instanceof StunTimeoutEvent)\n                receivedResponse = \"timeout\";\n            else\n                receivedResponse = \"failure\";\n            receivedResponses.add(receivedResponse);\n            notifyAll();\n        }", "signature": "protected synchronized void processFailure(BaseStunMessageEvent event)"}, {"syntax_pass": true, "original_string": "        public synchronized void processResponse(StunResponseEvent response)\n        {\n            receivedResponses.add(response);\n            notifyAll();\n        }", "docstring": "\nStores incoming responses.\n\n@param response a <tt>StunMessageEvent</tt> which describes the\nreceived STUN <tt>Response</tt>\n", "attributes": {"modifiers": "public synchronized", "marker_annotations": [], "non_marker_annotations": ["public", "synchronized"], "comments": [], "return_type": "void", "classes": []}, "name": "processResponse", "params": [{"name": "response", "type": "StunResponseEvent"}], "body": "        {\n            receivedResponses.add(response);\n            notifyAll();\n        }", "signature": "public synchronized void processResponse(StunResponseEvent response)"}, {"syntax_pass": true, "original_string": "        public synchronized void waitForResponse()\n        {\n            try\n            {\n                if (receivedResponses.size() == 0)\n                    wait(50);\n            }\n            catch (InterruptedException e)\n            {\n            }\n        }", "docstring": "\nWaits for a short period of time for a response to arrive\n", "attributes": {"modifiers": "public synchronized", "marker_annotations": [], "non_marker_annotations": ["public", "synchronized"], "comments": [], "return_type": "void", "classes": []}, "name": "waitForResponse", "params": [], "body": "        {\n            try\n            {\n                if (receivedResponses.size() == 0)\n                    wait(50);\n            }\n            catch (InterruptedException e)\n            {\n            }\n        }", "signature": "public synchronized void waitForResponse()"}, {"syntax_pass": true, "original_string": "        public synchronized void waitForTimeout()\n        {\n            try\n            {\n                if (receivedResponses.size() == 0)\n                    wait(12000);\n            }\n            catch (InterruptedException e)\n            {\n            }\n        }", "docstring": "\nWaits for a long period of time for a timeout trigger to fire.\n", "attributes": {"modifiers": "public synchronized", "marker_annotations": [], "non_marker_annotations": ["public", "synchronized"], "comments": [], "return_type": "void", "classes": []}, "name": "waitForTimeout", "params": [], "body": "        {\n            try\n            {\n                if (receivedResponses.size() == 0)\n                    wait(12000);\n            }\n            catch (InterruptedException e)\n            {\n            }\n        }", "signature": "public synchronized void waitForTimeout()"}]}], "class_docstring": "\nTest event dispatching for both client and server.\n`\n@author Emil Ivov\n", "original_string": "public class MessageEventDispatchingTest\n{\n    /**\n     * The stack that we are using for the tests.\n     */\n    StunStack stunStack = null;\n\n    /**\n     * The address of the client.\n     */\n    TransportAddress clientAddress\n        = new TransportAddress(\"127.0.0.1\", 5216, Transport.UDP);\n\n    /**\n     * The Address of the server.\n     */\n    TransportAddress serverAddress\n        = new TransportAddress(\"127.0.0.1\", 5255, Transport.UDP);\n\n    /**\n     * The address of the second server.\n     */\n    TransportAddress serverAddress2\n        = new TransportAddress(\"127.0.0.1\", 5259, Transport.UDP);\n\n    /**\n     * The socket that the client is using.\n     */\n    IceSocketWrapper  clientSock = null;\n\n    /**\n     * The socket that the server is using\n     */\n    IceSocketWrapper  serverSock = null;\n\n    /**\n     * The second server socket.\n     */\n    IceSocketWrapper serverSock2 = null;\n\n    /**\n     * The request that we will be sending in this test.\n     */\n    Request  bindingRequest = null;\n\n    /**\n     * The response that we will be sending in response to the above request.\n     */\n    Response bindingResponse = null;\n\n    /**\n     * The request collector that we use to wait for requests.\n     */\n    PlainRequestCollector requestCollector = null;\n\n    /**\n     * The responses collector that we use to wait for responses.\n     */\n    PlainResponseCollector responseCollector = null;\n\n    /**\n     * junit setup method.\n     *\n     * @throws Exception if anything goes wrong.\n     */\n    @BeforeEach\n    public void setUp() throws Exception\n    {\n        stunStack = new StunStack();\n\n        clientSock = new IceUdpSocketWrapper(\n            new SafeCloseDatagramSocket(clientAddress));\n        serverSock = new IceUdpSocketWrapper(\n            new SafeCloseDatagramSocket(serverAddress));\n        serverSock2 = new IceUdpSocketWrapper(\n            new SafeCloseDatagramSocket(serverAddress2));\n\n        stunStack.addSocket(clientSock);\n        stunStack.addSocket(serverSock);\n        stunStack.addSocket(serverSock2);\n\n        bindingRequest = MessageFactory.createBindingRequest();\n        bindingResponse = MessageFactory.create3489BindingResponse(\n            clientAddress, clientAddress, serverAddress);\n\n        requestCollector = new PlainRequestCollector();\n        responseCollector = new PlainResponseCollector();\n\n    }\n\n    /**\n     * junit tear down method.\n     *\n     * @throws Exception if anything goes wrong.\n     */\n    @AfterEach\n    public void tearDown() throws Exception\n    {\n        stunStack.removeSocket(clientAddress);\n        stunStack.removeSocket(serverAddress);\n        stunStack.removeSocket(serverAddress2);\n\n        clientSock.close();\n        serverSock.close();\n        serverSock2.close();\n\n        requestCollector = null;\n        responseCollector = null;\n    }\n\n    /**\n     * Test timeout events.\n     *\n     * @throws Exception upon a stun failure\n     */\n    @Test\n    public void testClientTransactionTimeouts() throws Exception\n    {\n        String oldRetransValue = System.getProperty(\n                        StackProperties.MAX_CTRAN_RETRANSMISSIONS);\n        System.setProperty(StackProperties.MAX_CTRAN_RETRANSMISSIONS, \"1\");\n        stunStack.sendRequest(bindingRequest, serverAddress, clientAddress,\n                        responseCollector);\n        responseCollector.waitForTimeout();\n\n        assertEquals(1, responseCollector.receivedResponses.size(),\n            \"No timeout was produced upon expiration of a client transaction\");\n\n        assertEquals(\"timeout\", responseCollector.receivedResponses.get(0), \n            \"No timeout was produced upon expiration of a client transaction\");\n\n        //restore the retransmissions prop in case others are counting on\n        //defaults.\n        if(oldRetransValue != null)\n            System.getProperty( StackProperties.MAX_CTRAN_RETRANSMISSIONS,\n                                oldRetransValue);\n        else\n            System.clearProperty(StackProperties.MAX_CTRAN_RETRANSMISSIONS);\n    }\n\n    /**\n     * Test reception of Message events.\n     *\n     * @throws java.lang.Exception upon any failure\n     */\n    @Test\n    public void testEventDispatchingUponIncomingRequests() throws Exception\n    {\n        //prepare to listen\n        stunStack.addRequestListener(requestCollector);\n        //send\n        stunStack.sendRequest(bindingRequest, serverAddress, clientAddress,\n                                            responseCollector);\n        //wait for retransmissions\n        requestCollector.waitForRequest();\n\n        //verify\n        assertEquals(1, requestCollector.receivedRequests.size(),\n            \"No MessageEvents have been dispatched\");\n    }\n\n    /**\n     * Test that reception of Message events is only received for accesspoints\n     * that we have been registered for.\n     *\n     * @throws java.lang.Exception upon any failure\n     */\n    @Test\n    public void testSelectiveEventDispatchingUponIncomingRequests()\n        throws Exception\n    {\n        //prepare to listen\n        stunStack.addRequestListener(serverAddress, requestCollector);\n\n        PlainRequestCollector requestCollector2 = new PlainRequestCollector();\n        stunStack.addRequestListener(serverAddress2, requestCollector2);\n\n        //send\n        stunStack.sendRequest(bindingRequest, serverAddress2, clientAddress,\n                                            responseCollector);\n        //wait for retransmissions\n        requestCollector.waitForRequest();\n        requestCollector2.waitForRequest();\n\n        //verify\n        assertEquals(0, requestCollector.receivedRequests.size(),\n            \"A MessageEvent was received by a non-interested selective listener\");\n        assertEquals(1, requestCollector2.receivedRequests.size(),\n            \"No MessageEvents have been dispatched for a selective listener\");\n    }\n\n    /**\n     * Makes sure that we receive response events.\n     * @throws Exception if we screw up.\n     */\n    @Test\n    public void testServerResponseRetransmissions() throws Exception\n    {\n        //prepare to listen\n        stunStack.addRequestListener(serverAddress, requestCollector);\n        //send\n        stunStack.sendRequest(bindingRequest, serverAddress, clientAddress,\n                                            responseCollector);\n\n        //wait for the message to arrive\n        requestCollector.waitForRequest();\n\n        StunMessageEvent evt = requestCollector.receivedRequests.get(0);\n        byte[] tid = evt.getMessage().getTransactionID();\n        stunStack.sendResponse(tid, bindingResponse, serverAddress,\n                                             clientAddress);\n\n        //wait for retransmissions\n        responseCollector.waitForResponse();\n\n        //verify that we got the response.\n        assertEquals(1, responseCollector.receivedResponses.size(),\n            \"There were no retransmissions of a binding response\");\n    }\n\n    /**\n     * A utility class we use to collect incoming requests.\n     */\n    private static class PlainRequestCollector implements RequestListener\n    {\n        /** all requests we've received so far. */\n        public final Vector<StunMessageEvent> receivedRequests = new Vector<>();\n\n        /**\n         * Stores incoming requests.\n         *\n         * @param evt the event containing the incoming request.\n         */\n        public void processRequest(StunMessageEvent evt)\n        {\n            synchronized (this)\n            {\n                receivedRequests.add(evt);\n                notifyAll();\n            }\n        }\n\n        public void waitForRequest()\n        {\n            synchronized(this)\n            {\n                if (receivedRequests.size() > 0)\n                    return;\n                try\n                {\n                    wait(50);\n                }\n                catch (InterruptedException e)\n                {}\n            }\n        }\n    }\n\n    /**\n     * A utility class to collect incoming responses.\n     */\n    private static class PlainResponseCollector\n        extends AbstractResponseCollector\n    {\n        public final Vector<Object> receivedResponses = new Vector<>();\n\n        /**\n         * Notifies this <tt>ResponseCollector</tt> that a transaction described by\n         * the specified <tt>BaseStunMessageEvent</tt> has failed. The possible\n         * reasons for the failure include timeouts, unreachable destination, etc.\n         *\n         * @param event the <tt>BaseStunMessageEvent</tt> which describes the failed\n         * transaction and the runtime type of which specifies the failure reason\n         * @see AbstractResponseCollector#processFailure(BaseStunMessageEvent)\n         */\n        protected synchronized void processFailure(BaseStunMessageEvent event)\n        {\n            String receivedResponse;\n\n            if (event instanceof StunFailureEvent)\n                receivedResponse = \"unreachable\";\n            else if (event instanceof StunTimeoutEvent)\n                receivedResponse = \"timeout\";\n            else\n                receivedResponse = \"failure\";\n            receivedResponses.add(receivedResponse);\n            notifyAll();\n        }\n\n        /**\n         * Stores incoming responses.\n         *\n         * @param response a <tt>StunMessageEvent</tt> which describes the\n         * received STUN <tt>Response</tt>\n         */\n        public synchronized void processResponse(StunResponseEvent response)\n        {\n            receivedResponses.add(response);\n            notifyAll();\n        }\n\n        /**\n         * Waits for a short period of time for a response to arrive\n         */\n        public synchronized void waitForResponse()\n        {\n            try\n            {\n                if (receivedResponses.size() == 0)\n                    wait(50);\n            }\n            catch (InterruptedException e)\n            {\n            }\n        }\n\n        /**\n         * Waits for a long period of time for a timeout trigger to fire.\n         */\n        public synchronized void waitForTimeout()\n        {\n            try\n            {\n                if (receivedResponses.size() == 0)\n                    wait(12000);\n            }\n            catch (InterruptedException e)\n            {\n            }\n        }\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "StunStack stunStack = null;", "docstring": "\nThe stack that we are using for the tests.\n", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "StunStack", "name": "stunStack = null", "syntax_pass": true}, {"attribute_expression": "TransportAddress clientAddress\n        = new TransportAddress(\"127.0.0.1\", 5216, Transport.UDP);", "docstring": "\nThe address of the client.\n", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "TransportAddress", "name": "clientAddress\n        = new TransportAddress(\"127.0.0.1\", 5216, Transport.UDP)", "syntax_pass": true}, {"attribute_expression": "TransportAddress serverAddress\n        = new TransportAddress(\"127.0.0.1\", 5255, Transport.UDP);", "docstring": "\nThe Address of the server.\n", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "TransportAddress", "name": "serverAddress\n        = new TransportAddress(\"127.0.0.1\", 5255, Transport.UDP)", "syntax_pass": true}, {"attribute_expression": "TransportAddress serverAddress2\n        = new TransportAddress(\"127.0.0.1\", 5259, Transport.UDP);", "docstring": "\nThe address of the second server.\n", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "TransportAddress", "name": "serverAddress2\n        = new TransportAddress(\"127.0.0.1\", 5259, Transport.UDP)", "syntax_pass": true}, {"attribute_expression": "IceSocketWrapper  clientSock = null;", "docstring": "\nThe socket that the client is using.\n", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "IceSocketWrapper", "name": "clientSock = null", "syntax_pass": true}, {"attribute_expression": "IceSocketWrapper  serverSock = null;", "docstring": "\nThe socket that the server is using\n", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "IceSocketWrapper", "name": "serverSock = null", "syntax_pass": true}, {"attribute_expression": "IceSocketWrapper serverSock2 = null;", "docstring": "\nThe second server socket.\n", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "IceSocketWrapper", "name": "serverSock2 = null", "syntax_pass": true}, {"attribute_expression": "Request  bindingRequest = null;", "docstring": "\nThe request that we will be sending in this test.\n", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "Request", "name": "bindingRequest = null", "syntax_pass": true}, {"attribute_expression": "Response bindingResponse = null;", "docstring": "\nThe response that we will be sending in response to the above request.\n", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "Response", "name": "bindingResponse = null", "syntax_pass": true}, {"attribute_expression": "PlainRequestCollector requestCollector = null;", "docstring": "\nThe request collector that we use to wait for requests.\n", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "PlainRequestCollector", "name": "requestCollector = null", "syntax_pass": true}, {"attribute_expression": "PlainResponseCollector responseCollector = null;", "docstring": "\nThe responses collector that we use to wait for responses.\n", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "PlainResponseCollector", "name": "responseCollector = null", "syntax_pass": true}]}, {"uris": "src/test/java/org/ice4j/message/MessageFactory_createConnectionBindResponseTest.java.MessageFactory_createConnectionBindResponseTest", "name": "MessageFactory_createConnectionBindResponseTest", "file_path": "src/test/java/org/ice4j/message/MessageFactory_createConnectionBindResponseTest.java", "superclasses": "", "methods": ["[void]testCreateConnectionBindResponse()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class MessageFactory_createConnectionBindResponseTest {\n\n    @Test\n    public void testCreateConnectionBindResponse() {\n        Response response = MessageFactory.createConnectionBindResponse();\n        assertEquals(Message.CONNECTION_BIND_SUCCESS_RESPONSE, response.getMessageType());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/ice4j/message/MessageFactory_createBindingErrorResponseTest.java.MessageFactory_createBindingErrorResponseTest", "name": "MessageFactory_createBindingErrorResponseTest", "file_path": "src/test/java/org/ice4j/message/MessageFactory_createBindingErrorResponseTest.java", "superclasses": "", "methods": ["[void]testCreateBindingErrorResponse_WithReasonPhrase()", "[void]testCreateBindingErrorResponse_WithoutReasonPhrase()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class MessageFactory_createBindingErrorResponseTest {\n\n    @Test\n    public void testCreateBindingErrorResponse_WithReasonPhrase() throws StunException {\n        char errorCode = 400;\n        String reasonPhrase = \"Bad Request\";\n\n        Response expectedResponse = new Response();\n        expectedResponse.setMessageType(Message.BINDING_ERROR_RESPONSE);\n\n        ErrorCodeAttribute errorCodeAttribute = AttributeFactory.createErrorCodeAttribute(errorCode, reasonPhrase);\n        expectedResponse.putAttribute(errorCodeAttribute);\n\n        Response actualResponse = MessageFactory.createBindingErrorResponse(errorCode, reasonPhrase);\n\n        assertEquals(expectedResponse, actualResponse);\n    }\n\n    @Test\n    public void testCreateBindingErrorResponse_WithoutReasonPhrase() throws StunException {\n        char errorCode = 404;\n\n        Response expectedResponse = new Response();\n        expectedResponse.setMessageType(Message.BINDING_ERROR_RESPONSE);\n\n        ErrorCodeAttribute errorCodeAttribute = AttributeFactory.createErrorCodeAttribute(errorCode);\n        expectedResponse.putAttribute(errorCodeAttribute);\n\n        Response actualResponse = MessageFactory.createBindingErrorResponse(errorCode);\n\n        assertEquals(expectedResponse, actualResponse);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/ice4j/message/MessageFactory_createCreatePermissionResponseTest.java.MessageFactory_createCreatePermissionResponseTest", "name": "MessageFactory_createCreatePermissionResponseTest", "file_path": "src/test/java/org/ice4j/message/MessageFactory_createCreatePermissionResponseTest.java", "superclasses": "", "methods": ["[void]testCreateCreatePermissionResponse()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class MessageFactory_createCreatePermissionResponseTest {\n\n    @Test\n    public void testCreateCreatePermissionResponse() {\n        Response response = MessageFactory.createCreatePermissionResponse();\n        \n        assertNotNull(response);\n        assertEquals(Message.CREATEPERMISSION_RESPONSE, response.getMessageType());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/ice4j/message/MessageFactory_createSharedSecretResponseTest.java.MessageFactory_createSharedSecretResponseTest", "name": "MessageFactory_createSharedSecretResponseTest", "file_path": "src/test/java/org/ice4j/message/MessageFactory_createSharedSecretResponseTest.java", "superclasses": "", "methods": ["[void]testCreateSharedSecretResponse()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class MessageFactory_createSharedSecretResponseTest {\n\n    @Test\n    public void testCreateSharedSecretResponse() {\n        UnsupportedOperationException exception = assertThrows(\n            UnsupportedOperationException.class,\n            () -> MessageFactory.createSharedSecretResponse()\n        );\n        assertEquals(\"Shared Secret Support is not currently implemented\", exception.getMessage());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/ice4j/message/MessageFactory_createSharedSecretRequestTest.java.MessageFactory_createSharedSecretRequestTest", "name": "MessageFactory_createSharedSecretRequestTest", "file_path": "src/test/java/org/ice4j/message/MessageFactory_createSharedSecretRequestTest.java", "superclasses": "", "methods": ["[void]testCreateSharedSecretRequest()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class MessageFactory_createSharedSecretRequestTest {\n\n    @Test\n    public void testCreateSharedSecretRequest() {\n        UnsupportedOperationException exception = assertThrows(\n            UnsupportedOperationException.class,\n            () -> MessageFactory.createSharedSecretRequest()\n        );\n        assertEquals(\"Shared Secret Support is not currently implemented\", exception.getMessage());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/ice4j/message/MessageTest.java.MessageTest", "name": "MessageTest", "file_path": "src/test/java/org/ice4j/message/MessageTest.java", "superclasses": "", "methods": ["[void]testAddAndGetAttribute()", "[void]testEncode()", "[void]testDecode()", "[void]testEquals()", "[void]testGetAttributeCount()", "[void]testRemoveAttribute()"], "method_uris": ["src/test/java/org/ice4j/message/MessageTest.java.MessageTest.[void]setupConfig()", "src/test/java/org/ice4j/message/MessageTest.java.MessageTest.[void]resetConfig()", "src/test/java/org/ice4j/message/MessageTest.java.MessageTest.[void]setUp()", "src/test/java/org/ice4j/message/MessageTest.java.MessageTest.[void]tearDown()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class MessageTest\n{\n\n    @BeforeAll\n    public static void setupConfig()\n    {\n        System.clearProperty(StackProperties.ALWAYS_SIGN);\n        System.setProperty(\"ice4j.software\", \"\");\n        JitsiConfig.Companion.reloadNewConfig();\n    }\n\n    @AfterAll\n    public static void resetConfig()\n    {\n        System.clearProperty(\"ice4j.software\");\n        JitsiConfig.Companion.reloadNewConfig();\n    }\n\n    private Message bindingRequest       = null;\n    private Message bindingResponse      = null;\n\n    private MappedAddressAttribute  mappedAddress = null;\n    private SourceAddressAttribute  sourceAddress = null;\n    private ChangedAddressAttribute changedAddress = null;\n\n    private ChangeRequestAttribute  changeRequest = null;\n\n    private MsgFixture msgFixture;\n\n    /**\n     * The <tt>StunStack</tt> used by this <tt>MessageTest</tt>.\n     */\n    private StunStack stunStack;\n\n    @BeforeEach\n    public void setUp() throws Exception\n    {\n        msgFixture = new MsgFixture();\n\n        stunStack = new StunStack();\n\n        //binding request\n        bindingRequest = new Request();\n        bindingRequest.setMessageType(Message.BINDING_REQUEST);\n\n        changeRequest = AttributeFactory.createChangeRequestAttribute(\n                   MsgFixture.CHANGE_IP_FLAG_1, MsgFixture.CHANGE_PORT_FLAG_1);\n        bindingRequest.putAttribute(changeRequest);\n        bindingRequest.setTransactionID(MsgFixture.TRANSACTION_ID);\n\n        //binding response\n        bindingResponse = new Response();\n        bindingResponse.setMessageType(Message.BINDING_SUCCESS_RESPONSE);\n\n        mappedAddress = AttributeFactory.createMappedAddressAttribute(\n            new TransportAddress(\n                            MsgFixture.ADDRESS_ATTRIBUTE_ADDRESS,\n                            MsgFixture.ADDRESS_ATTRIBUTE_PORT,\n                            Transport.UDP));\n\n        bindingResponse.putAttribute(mappedAddress);\n\n        sourceAddress = AttributeFactory.createSourceAddressAttribute(\n            new TransportAddress(\n                            MsgFixture.ADDRESS_ATTRIBUTE_ADDRESS_2,\n                            MsgFixture.ADDRESS_ATTRIBUTE_PORT_2,\n                            Transport.UDP));\n\n        bindingResponse.putAttribute(sourceAddress);\n\n        changedAddress = AttributeFactory.createChangedAddressAttribute(\n            new TransportAddress( MsgFixture.ADDRESS_ATTRIBUTE_ADDRESS_3,\n                        MsgFixture.ADDRESS_ATTRIBUTE_PORT_3, Transport.UDP));\n\n        bindingResponse.putAttribute(changedAddress);\n        bindingResponse.setTransactionID(MsgFixture.TRANSACTION_ID);\n    }\n\n    @AfterEach\n    public void tearDown() throws Exception\n    {\n        bindingRequest = null;\n        bindingResponse = null;\n        mappedAddress = null;\n        sourceAddress = null;\n        changedAddress = null;\n        changeRequest = null;\n\n        stunStack = null;\n\n        msgFixture = null;\n    }\n\n    /**\n     * Adds and gets an attribute and test that they are the same then adds a\n     * another attribute (same typ different value) and verifies that the first\n     * one is properly replaced.\n     *\n     */\n    @Test\n    public void testAddAndGetAttribute()\n    {\n        Response   message = new Response();\n        message.setMessageType(Message.BINDING_SUCCESS_RESPONSE);\n        message.putAttribute(mappedAddress);\n\n        Attribute getResult;\n\n        getResult = message.getAttribute(mappedAddress.getAttributeType());\n        assertEquals(mappedAddress, getResult,\n            \"Originally added attribute did not match the returned\");\n\n        //do it again\n        message.putAttribute(sourceAddress);\n\n        getResult = message.getAttribute(sourceAddress.getAttributeType());\n\n        assertEquals(sourceAddress, getResult,\n            \"The second attribute could not be extracted.\");\n    }\n\n    /**\n     * Decodes a bindingRequest and then a binding response and checks whether\n     * they match the corresponding objects.\n     *\n     * @throws StunException java.lang.Exception if we fail\n     */\n    @Test\n    public void testEncode()\n        throws StunException\n    {\n        //Binding Request\n        byte[] expectedReturn = msgFixture.bindingRequest;\n\n        byte[] actualReturn = bindingRequest.encode(stunStack);\n        assertArrayEquals(expectedReturn, actualReturn,\n            \"A binding request was not properly encoded\");\n\n        //Binding Response\n        expectedReturn = msgFixture.bindingResponse;\n\n        actualReturn = bindingResponse.encode(stunStack);\n\n        assertArrayEquals(expectedReturn, actualReturn,\n            \"A binding response was not properly encoded\");\n    }\n\n    /**\n     * Encodes a bindingRequest and then a binding response and checks whether\n     * they match the corresponding binary arrays.\n     *\n     * @throws Exception java.lang.Exception if we fail\n     */\n    @Test\n    public void testDecode()\n        throws Exception\n    {\n        //Binding Request\n        Message expectedReturn = bindingRequest;\n\n        Message actualReturn = Message.decode(msgFixture.bindingRequest,\n                                     0,\n                                     msgFixture.bindingRequest.length);\n\n        assertEquals(expectedReturn, actualReturn,\n            \"A binding request was not properly decoded\");\n\n        //Binding Response\n        expectedReturn = bindingResponse;\n\n        actualReturn = Message.decode(msgFixture.bindingResponse,\n                                     0,\n                                     msgFixture.bindingResponse.length);\n\n        assertEquals(expectedReturn, actualReturn,\n            \"A binding response was not properly decoded\");\n    }\n\n    /**\n     * Tests the equals method against a null, a different and an identical\n     * object.\n     *\n     * @throws StunException java.lang.Exception if we fail\n     */\n    @Test\n    public void testEquals()\n        throws StunException\n    {\n        assertNotEquals(bindingRequest, null,\n            \"Equals failed against a null target\");\n\n        assertNotEquals(bindingResponse, null,\n            \"Equals failed against a null target\");\n\n        //different\n        assertNotEquals(bindingRequest, bindingResponse,\n            \"Equals failed against a different target\");\n\n        assertNotEquals(bindingResponse, bindingRequest,\n            \"Equals failed against a different target\");\n\n        //Create a binding request with the same attributes as\n        //this.bindingRequest\n        Request binReqTarget = new Request();\n        binReqTarget.setMessageType(Message.BINDING_REQUEST);\n        binReqTarget.putAttribute(changeRequest);\n        assertEquals(bindingRequest, binReqTarget,\n            \"Equals failed against an equal target\");\n\n        //Create a binding response with the same attributes as\n        //this.bindingRequest\n        Response binResTarget = new Response();\n        binResTarget.setMessageType(Message.BINDING_SUCCESS_RESPONSE);\n        binResTarget.putAttribute(mappedAddress);\n        binResTarget.putAttribute(sourceAddress);\n        binResTarget.putAttribute(changedAddress);\n        assertEquals(bindingResponse, binResTarget,\n            \"Equals failed against a different target\");\n    }\n\n    /**\n     * Tests  whether attributes are properly counted\n     */\n    @Test\n    public void testGetAttributeCount()\n    {\n        int expectedReturn = 1;\n        int actualReturn = bindingRequest.getAttributeCount();\n        assertEquals(expectedReturn, actualReturn,\n            \"getAttributeCount failed for a bindingRequest\");\n        expectedReturn = 3;\n        actualReturn = bindingResponse.getAttributeCount();\n        assertEquals(expectedReturn, actualReturn,\n            \"getAttributeCount failed for a bindingRequest\");\n    }\n\n    /**\n     * Test whether attributes are properly removed.\n     */\n    @Test\n    public void testRemoveAttribute()\n    {\n\n        bindingRequest.removeAttribute(changeRequest.getAttributeType());\n\n        assertNull(bindingRequest.getAttribute(changeRequest.getAttributeType()),\n            \"An attribute was still in the request after being removed\");\n\n        //test count\n        int expectedReturn = 0;\n        int actualReturn = bindingRequest.getAttributeCount();\n        assertEquals(expectedReturn, actualReturn,\n            \"Attribute count did not change after removing an attribute\");\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private Message bindingRequest       = null;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Message", "name": "bindingRequest       = null", "syntax_pass": true}, {"attribute_expression": "private Message bindingResponse      = null;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Message", "name": "bindingResponse      = null", "syntax_pass": true}, {"attribute_expression": "private MappedAddressAttribute  mappedAddress = null;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "MappedAddressAttribute", "name": "mappedAddress = null", "syntax_pass": true}, {"attribute_expression": "private SourceAddressAttribute  sourceAddress = null;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "SourceAddressAttribute", "name": "sourceAddress = null", "syntax_pass": true}, {"attribute_expression": "private ChangedAddressAttribute changedAddress = null;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ChangedAddressAttribute", "name": "changedAddress = null", "syntax_pass": true}, {"attribute_expression": "private ChangeRequestAttribute  changeRequest = null;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ChangeRequestAttribute", "name": "changeRequest = null", "syntax_pass": true}, {"attribute_expression": "private MsgFixture msgFixture;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "MsgFixture", "name": "msgFixture", "syntax_pass": true}, {"attribute_expression": "private StunStack stunStack;", "docstring": "\nThe <tt>StunStack</tt> used by this <tt>MessageTest</tt>.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "StunStack", "name": "stunStack", "syntax_pass": true}]}, {"uris": "src/test/java/org/ice4j/message/MessageFactory_createRefreshRequestTest.java.MessageFactory_createRefreshRequestTest", "name": "MessageFactory_createRefreshRequestTest", "file_path": "src/test/java/org/ice4j/message/MessageFactory_createRefreshRequestTest.java", "superclasses": "", "methods": ["[void]testCreateRefreshRequest()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class MessageFactory_createRefreshRequestTest {\n\n    @Test\n    public void testCreateRefreshRequest() {\n        Request expectedRequest = new Request();\n        expectedRequest.setMessageType(Message.REFRESH_REQUEST);\n\n        Request actualRequest = MessageFactory.createRefreshRequest();\n        assertEquals(expectedRequest.getMessageType(), actualRequest.getMessageType());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/ice4j/message/MessageFactory_createBindingIndicationTest.java.MessageFactory_createBindingIndicationTest", "name": "MessageFactory_createBindingIndicationTest", "file_path": "src/test/java/org/ice4j/message/MessageFactory_createBindingIndicationTest.java", "superclasses": "", "methods": ["[void]testCreateBindingIndication()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class MessageFactory_createBindingIndicationTest {\n\n    @Test\n    public void testCreateBindingIndication() {\n        Indication expectedIndication = new Indication();\n        expectedIndication.setMessageType(Message.BINDING_INDICATION);\n\n        Indication actualIndication = MessageFactory.createBindingIndication();\n        assertEquals(expectedIndication.getMessageType(), actualIndication.getMessageType());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/ice4j/message/MessageFactoryTest.java.MessageFactoryTest", "name": "MessageFactoryTest", "file_path": "src/test/java/org/ice4j/message/MessageFactoryTest.java", "superclasses": "", "methods": ["[void]testCreateBindingErrorResponse()", "[void]testCreateBindingErrorResponse1()", "[void]testCreateBindingErrorResponseUnknownAttributes()", "[void]testCreateBindingErrorResponseUnknownAttributes1()", "[void]testCreateBindingRequest()", "[void]testCreateBindingResponse()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class MessageFactoryTest\n{\n    @Test\n    public void testCreateBindingErrorResponse() throws StunException\n    {\n        char errorCode = 400;\n\n        Response expectedReturn = new Response();\n        expectedReturn.setMessageType(Message.BINDING_ERROR_RESPONSE);\n\n        Attribute errorCodeAtt\n            = AttributeFactory.createErrorCodeAttribute(errorCode);\n        expectedReturn.putAttribute(errorCodeAtt);\n\n        Message actualReturn\n            = MessageFactory.createBindingErrorResponse(errorCode);\n        assertEquals(expectedReturn, actualReturn);\n    }\n\n    @Test\n    public void testCreateBindingErrorResponse1()\n    {\n        char errorCode = 400;\n        String reasonPhrase = \"Bad Request\";\n\n        Response expectedReturn = new Response();\n        expectedReturn.setMessageType(Message.BINDING_ERROR_RESPONSE);\n\n        Attribute errorCodeAtt = AttributeFactory\n            .createErrorCodeAttribute(errorCode, reasonPhrase);\n        expectedReturn.putAttribute(errorCodeAtt);\n\n        Message actualReturn = MessageFactory\n            .createBindingErrorResponse(errorCode, reasonPhrase);\n        assertEquals(expectedReturn, actualReturn);\n    }\n\n    @Test\n    public void testCreateBindingErrorResponseUnknownAttributes()\n            throws StunException\n    {\n        char errorCode = 420;\n        char[] unknownAttributes = new char[]{21, 22, 23};\n\n        //create a message manually\n        Response expectedReturn = new Response();\n        expectedReturn.setMessageType(Message.BINDING_ERROR_RESPONSE);\n\n        ErrorCodeAttribute errorCodeAtt = AttributeFactory\n            .createErrorCodeAttribute(errorCode);\n        errorCodeAtt.setReasonPhrase(\n                        ErrorCodeAttribute.getDefaultReasonPhrase(errorCode));\n        expectedReturn.putAttribute(errorCodeAtt);\n\n        UnknownAttributesAttribute unknownAtts =\n                        AttributeFactory.createUnknownAttributesAttribute();\n\n        for (char unknownAttribute : unknownAttributes)\n        {\n            unknownAtts.addAttributeID(unknownAttribute);\n        }\n        expectedReturn.putAttribute(unknownAtts);\n\n        //create the same message using the factory\n        Message actualReturn = MessageFactory\n            .createBindingErrorResponseUnknownAttributes(unknownAttributes);\n        //compare\n        assertEquals(expectedReturn, actualReturn);\n    }\n\n    @Test\n    public void testCreateBindingErrorResponseUnknownAttributes1()\n            throws StunException\n    {\n        char errorCode = 420;\n        String reasonPhrase = \"UnknwonAttributes\";\n        char[] unknownAttributes = new char[]{21, 22, 23};\n\n        Response expectedReturn = new Response();\n        expectedReturn.setMessageType(Message.BINDING_ERROR_RESPONSE);\n\n        Attribute errorCodeAtt = AttributeFactory.createErrorCodeAttribute(\n            errorCode, reasonPhrase);\n        expectedReturn.putAttribute(errorCodeAtt);\n\n        UnknownAttributesAttribute unknownAtts =\n            AttributeFactory.createUnknownAttributesAttribute();\n\n        for (char unknownAttribute : unknownAttributes)\n        {\n            unknownAtts.addAttributeID(unknownAttribute);\n        }\n        expectedReturn.putAttribute(unknownAtts);\n\n        Message actualReturn = MessageFactory\n            .createBindingErrorResponseUnknownAttributes(\n                                           reasonPhrase, unknownAttributes);\n        assertEquals(expectedReturn, actualReturn);\n    }\n\n    @Test\n    public void testCreateBindingRequest()\n    {\n        Request bindingRequest = new Request();\n        bindingRequest.setMessageType(Message.BINDING_REQUEST);\n/*\n        Attribute changeRequest = AttributeFactory.createChangeRequestAttribute(\n                    msgFixture.CHANGE_IP_FLAG_1, msgFixture.CHANGE_PORT_FLAG_1);\n        bindingRequest.putAttribute(changeRequest);\n*/\n        Request actualReturn = MessageFactory.createBindingRequest();\n        assertEquals(bindingRequest, actualReturn);\n    }\n\n    @Test\n    public void testCreateBindingResponse()\n        throws Exception\n    {\n        Response bindingResponse = new Response();\n        bindingResponse.setMessageType(Message.BINDING_SUCCESS_RESPONSE);\n\n        Attribute mappedAddress = AttributeFactory.createMappedAddressAttribute(\n            new TransportAddress( MsgFixture.ADDRESS_ATTRIBUTE_ADDRESS,\n                                  MsgFixture.ADDRESS_ATTRIBUTE_PORT,\n                                  Transport.UDP));\n\n        bindingResponse.putAttribute(mappedAddress);\n\n        Attribute sourceAddress = AttributeFactory.createSourceAddressAttribute(\n            new TransportAddress( MsgFixture.ADDRESS_ATTRIBUTE_ADDRESS_2,\n                                  MsgFixture.ADDRESS_ATTRIBUTE_PORT_2,\n                                  Transport.UDP));\n\n        bindingResponse.putAttribute(sourceAddress);\n\n        Attribute changedAddress = AttributeFactory.\n            createChangedAddressAttribute(\n                new TransportAddress( MsgFixture.ADDRESS_ATTRIBUTE_ADDRESS_3,\n                                      MsgFixture.ADDRESS_ATTRIBUTE_PORT_3,\n                                      Transport.UDP));\n\n        bindingResponse.putAttribute(changedAddress);\n\n        Message actualReturn = MessageFactory.create3489BindingResponse(\n            new TransportAddress( MsgFixture.ADDRESS_ATTRIBUTE_ADDRESS,\n                                  MsgFixture.ADDRESS_ATTRIBUTE_PORT,\n                                  Transport.UDP),\n            new TransportAddress( MsgFixture.ADDRESS_ATTRIBUTE_ADDRESS_2,\n                                  MsgFixture.ADDRESS_ATTRIBUTE_PORT_2,\n                                  Transport.UDP),\n            new TransportAddress( MsgFixture.ADDRESS_ATTRIBUTE_ADDRESS_3,\n                                  MsgFixture.ADDRESS_ATTRIBUTE_PORT_3,\n                                  Transport.UDP));\n        assertEquals(bindingResponse, actualReturn);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/ice4j/message/MessageFactory_createChannelBindResponseTest.java.MessageFactory_createChannelBindResponseTest", "name": "MessageFactory_createChannelBindResponseTest", "file_path": "src/test/java/org/ice4j/message/MessageFactory_createChannelBindResponseTest.java", "superclasses": "", "methods": ["[void]testCreateChannelBindResponse()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class MessageFactory_createChannelBindResponseTest {\n\n    @Test\n    public void testCreateChannelBindResponse() {\n        Response response = MessageFactory.createChannelBindResponse();\n        assertEquals(Message.CHANNELBIND_RESPONSE, response.getMessageType());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/ice4j/message/MessageFactory_create3489BindingResponseTest.java.MessageFactory_create3489BindingResponseTest", "name": "MessageFactory_create3489BindingResponseTest", "file_path": "src/test/java/org/ice4j/message/MessageFactory_create3489BindingResponseTest.java", "superclasses": "", "methods": ["[void]testCreate3489BindingResponseWithAllAddresses()", "[void]testCreate3489BindingResponseWithNullSourceAndChangedAddresses()", "[void]testCreate3489BindingResponseWithNullChangedAddress()", "[void]testCreate3489BindingResponseWithNullSourceAddress()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class MessageFactory_create3489BindingResponseTest {\n\n    @Test\n    public void testCreate3489BindingResponseWithAllAddresses() {\n        TransportAddress mappedAddress = new TransportAddress(\"192.168.1.1\", 1234, Transport.UDP);\n        TransportAddress sourceAddress = new TransportAddress(\"192.168.1.2\", 5678, Transport.UDP);\n        TransportAddress changedAddress = new TransportAddress(\"192.168.1.3\", 9012, Transport.UDP);\n\n        Response expectedResponse = new Response();\n        expectedResponse.setMessageType(Message.BINDING_SUCCESS_RESPONSE);\n        expectedResponse.putAttribute(AttributeFactory.createMappedAddressAttribute(mappedAddress));\n        expectedResponse.putAttribute(AttributeFactory.createSourceAddressAttribute(sourceAddress));\n        expectedResponse.putAttribute(AttributeFactory.createChangedAddressAttribute(changedAddress));\n\n        Response actualResponse = MessageFactory.create3489BindingResponse(mappedAddress, sourceAddress, changedAddress);\n\n        assertEquals(expectedResponse.getMessageType(), actualResponse.getMessageType());\n        assertEquals(expectedResponse.getAttribute(Attribute.MAPPED_ADDRESS), actualResponse.getAttribute(Attribute.MAPPED_ADDRESS));\n        assertEquals(expectedResponse.getAttribute(Attribute.SOURCE_ADDRESS), actualResponse.getAttribute(Attribute.SOURCE_ADDRESS));\n        assertEquals(expectedResponse.getAttribute(Attribute.CHANGED_ADDRESS), actualResponse.getAttribute(Attribute.CHANGED_ADDRESS));\n    }\n\n    @Test\n    public void testCreate3489BindingResponseWithNullSourceAndChangedAddresses() {\n        TransportAddress mappedAddress = new TransportAddress(\"192.168.1.1\", 1234, Transport.UDP);\n\n        Response expectedResponse = new Response();\n        expectedResponse.setMessageType(Message.BINDING_SUCCESS_RESPONSE);\n        expectedResponse.putAttribute(AttributeFactory.createMappedAddressAttribute(mappedAddress));\n\n        Response actualResponse = MessageFactory.create3489BindingResponse(mappedAddress, null, null);\n\n        assertEquals(expectedResponse.getMessageType(), actualResponse.getMessageType());\n        assertEquals(expectedResponse.getAttribute(Attribute.MAPPED_ADDRESS), actualResponse.getAttribute(Attribute.MAPPED_ADDRESS));\n        assertNull(actualResponse.getAttribute(Attribute.SOURCE_ADDRESS));\n        assertNull(actualResponse.getAttribute(Attribute.CHANGED_ADDRESS));\n    }\n\n    @Test\n    public void testCreate3489BindingResponseWithNullChangedAddress() {\n        TransportAddress mappedAddress = new TransportAddress(\"192.168.1.1\", 1234, Transport.UDP);\n        TransportAddress sourceAddress = new TransportAddress(\"192.168.1.2\", 5678, Transport.UDP);\n\n        Response expectedResponse = new Response();\n        expectedResponse.setMessageType(Message.BINDING_SUCCESS_RESPONSE);\n        expectedResponse.putAttribute(AttributeFactory.createMappedAddressAttribute(mappedAddress));\n        expectedResponse.putAttribute(AttributeFactory.createSourceAddressAttribute(sourceAddress));\n\n        Response actualResponse = MessageFactory.create3489BindingResponse(mappedAddress, sourceAddress, null);\n\n        assertEquals(expectedResponse.getMessageType(), actualResponse.getMessageType());\n        assertEquals(expectedResponse.getAttribute(Attribute.MAPPED_ADDRESS), actualResponse.getAttribute(Attribute.MAPPED_ADDRESS));\n        assertEquals(expectedResponse.getAttribute(Attribute.SOURCE_ADDRESS), actualResponse.getAttribute(Attribute.SOURCE_ADDRESS));\n        assertNull(actualResponse.getAttribute(Attribute.CHANGED_ADDRESS));\n    }\n\n    @Test\n    public void testCreate3489BindingResponseWithNullSourceAddress() {\n        TransportAddress mappedAddress = new TransportAddress(\"192.168.1.1\", 1234, Transport.UDP);\n        TransportAddress changedAddress = new TransportAddress(\"192.168.1.3\", 9012, Transport.UDP);\n\n        Response expectedResponse = new Response();\n        expectedResponse.setMessageType(Message.BINDING_SUCCESS_RESPONSE);\n        expectedResponse.putAttribute(AttributeFactory.createMappedAddressAttribute(mappedAddress));\n        expectedResponse.putAttribute(AttributeFactory.createChangedAddressAttribute(changedAddress));\n\n        Response actualResponse = MessageFactory.create3489BindingResponse(mappedAddress, null, changedAddress);\n\n        assertEquals(expectedResponse.getMessageType(), actualResponse.getMessageType());\n        assertEquals(expectedResponse.getAttribute(Attribute.MAPPED_ADDRESS), actualResponse.getAttribute(Attribute.MAPPED_ADDRESS));\n        assertNull(actualResponse.getAttribute(Attribute.SOURCE_ADDRESS));\n        assertEquals(expectedResponse.getAttribute(Attribute.CHANGED_ADDRESS), actualResponse.getAttribute(Attribute.CHANGED_ADDRESS));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/ice4j/message/MessageFactory_createCreatePermissionErrorResponseTest.java.MessageFactory_createCreatePermissionErrorResponseTest", "name": "MessageFactory_createCreatePermissionErrorResponseTest", "file_path": "src/test/java/org/ice4j/message/MessageFactory_createCreatePermissionErrorResponseTest.java", "superclasses": "", "methods": ["[void]testCreateCreatePermissionErrorResponse()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class MessageFactory_createCreatePermissionErrorResponseTest {\n\n    @Test\n    public void testCreateCreatePermissionErrorResponse() {\n        // Given\n        char errorCode = '4';\n\n        // When\n        Response response = MessageFactory.createCreatePermissionErrorResponse(errorCode);\n\n        // Then\n        assertNotNull(response);\n        assertTrue(response.isErrorResponse());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/ice4j/message/MessageFactory_createBindingRequestTest.java.MessageFactory_createBindingRequestTest", "name": "MessageFactory_createBindingRequestTest", "file_path": "src/test/java/org/ice4j/message/MessageFactory_createBindingRequestTest.java", "superclasses": "", "methods": ["[void]testCreateBindingRequest()", "[void]testCreateBindingRequestWithPriority()", "[void]testCreateBindingRequestWithPriorityAndControlling()", "[void]testCreateBindingRequestWithPriorityAndControlled()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class MessageFactory_createBindingRequestTest {\n\n    @Test\n    public void testCreateBindingRequest() {\n        Request bindingRequest = MessageFactory.createBindingRequest();\n        assertEquals(Message.BINDING_REQUEST, bindingRequest.getMessageType());\n    }\n\n    @Test\n    public void testCreateBindingRequestWithPriority() throws StunException {\n        long priority = 123456789L;\n        Request bindingRequest = MessageFactory.createBindingRequest(priority);\n        assertEquals(Message.BINDING_REQUEST, bindingRequest.getMessageType());\n        PriorityAttribute priorityAttribute = (PriorityAttribute) bindingRequest.getAttribute(Attribute.PRIORITY);\n        assertNotNull(priorityAttribute);\n        assertEquals(priority, priorityAttribute.getPriority());\n    }\n\n    @Test\n    public void testCreateBindingRequestWithPriorityAndControlling() throws StunException {\n        long priority = 123456789L;\n        boolean controlling = true;\n        long tieBreaker = 987654321L;\n        Request bindingRequest = MessageFactory.createBindingRequest(priority, controlling, tieBreaker);\n        assertEquals(Message.BINDING_REQUEST, bindingRequest.getMessageType());\n        PriorityAttribute priorityAttribute = (PriorityAttribute) bindingRequest.getAttribute(Attribute.PRIORITY);\n        IceControllingAttribute iceControllingAttribute = (IceControllingAttribute) bindingRequest.getAttribute(Attribute.ICE_CONTROLLING);\n        assertNotNull(priorityAttribute);\n        assertNotNull(iceControllingAttribute);\n        assertEquals(priority, priorityAttribute.getPriority());\n        assertEquals(tieBreaker, iceControllingAttribute.getTieBreaker());\n    }\n\n    @Test\n    public void testCreateBindingRequestWithPriorityAndControlled() throws StunException {\n        long priority = 123456789L;\n        boolean controlling = false;\n        long tieBreaker = 987654321L;\n        Request bindingRequest = MessageFactory.createBindingRequest(priority, controlling, tieBreaker);\n        assertEquals(Message.BINDING_REQUEST, bindingRequest.getMessageType());\n        PriorityAttribute priorityAttribute = (PriorityAttribute) bindingRequest.getAttribute(Attribute.PRIORITY);\n        IceControlledAttribute iceControlledAttribute = (IceControlledAttribute) bindingRequest.getAttribute(Attribute.ICE_CONTROLLED);\n        assertNotNull(priorityAttribute);\n        assertNotNull(iceControlledAttribute);\n        assertEquals(priority, priorityAttribute.getPriority());\n        assertEquals(tieBreaker, iceControlledAttribute.getTieBreaker());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/ice4j/message/MessageFactory_createSharedSecretErrorResponseTest.java.MessageFactory_createSharedSecretErrorResponseTest", "name": "MessageFactory_createSharedSecretErrorResponseTest", "file_path": "src/test/java/org/ice4j/message/MessageFactory_createSharedSecretErrorResponseTest.java", "superclasses": "", "methods": ["[void]testCreateSharedSecretErrorResponse()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class MessageFactory_createSharedSecretErrorResponseTest {\n\n    @Test\n    public void testCreateSharedSecretErrorResponse() {\n        UnsupportedOperationException exception = assertThrows(\n            UnsupportedOperationException.class,\n            () -> MessageFactory.createSharedSecretErrorResponse()\n        );\n        assertEquals(\"Shared Secret Support is not currently implemented\", exception.getMessage());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/ice4j/message/MessageFactory_createAllocateRequestTest.java.MessageFactory_createAllocateRequestTest", "name": "MessageFactory_createAllocateRequestTest", "file_path": "src/test/java/org/ice4j/message/MessageFactory_createAllocateRequestTest.java", "superclasses": "", "methods": ["[void]testCreateAllocateRequest()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class MessageFactory_createAllocateRequestTest {\n\n    @Test\n    public void testCreateAllocateRequest() {\n        Request expectedRequest = new Request();\n        expectedRequest.setMessageType(Message.ALLOCATE_REQUEST);\n\n        Request actualRequest = MessageFactory.createAllocateRequest();\n\n        assertEquals(expectedRequest.getMessageType(), actualRequest.getMessageType());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest_v6.java.StunAddressDiscovererTest_v6", "name": "StunAddressDiscovererTest_v6", "file_path": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest_v6.java", "superclasses": "", "methods": ["[void]testRecognizeBlockedUDP()", "[void]testRecognizeSymmetricNat()", "[void]testRecognizePortRestrictedCone()", "[void]testRecognizeRestrictedCone()", "[void]testRecognizeFullCone()", "[void]testRecognizeUdpSymmetricFirewall()", "[void]testRecognizeOpenInternet()"], "method_uris": ["src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest_v6.java.StunAddressDiscovererTest_v6.[void]setUp()", "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest_v6.java.StunAddressDiscovererTest_v6.[void]tearDown()"], "overrides": null, "attributes": [], "class_docstring": "\nThe StunAddressDiscovererTest_XXX set of tests were created to verify stun\noperation for scenarios of some basic types of firewalls. The purpose of\nthese tests is to make sure that transaction retransmissions and rereceptions\nare handled transparently by the stack, as well as verify overal protocol\noperations for IPv4/IPv6 and mixed environments.\n\n<p>Company: Net Research Team, Louis Pasteur University</p>\n@author Emil Ivov\n", "original_string": "public class StunAddressDiscovererTest_v6\n{\n    private NetworkConfigurationDiscoveryProcess  stunAddressDiscoverer = null;\n    private final TransportAddress discovererAddress\n        = new TransportAddress(\"::1\", 16555, Transport.UDP);\n\n    private ResponseSequenceServer responseServer = null;\n    private final TransportAddress responseServerAddress\n        = new TransportAddress(\"::1\", 20999, Transport.UDP);\n\n    private final TransportAddress mappedClientAddress = new TransportAddress(\n                    \"2001:660:4701:1001:ff::1\", 16612, Transport.UDP);\n    private final TransportAddress mappedClientAddressPort2 = new TransportAddress(\n                    \"2001:660:4701:1001:ff::1\", 16611, Transport.UDP);\n\n    @BeforeEach\n    public void setUp() throws Exception\n    {\n        StunStack stunStack = new StunStack();\n\n        responseServer\n            = new ResponseSequenceServer(stunStack, responseServerAddress);\n        stunAddressDiscoverer\n            = new NetworkConfigurationDiscoveryProcess(\n                    stunStack,\n                    discovererAddress, responseServerAddress);\n\n        stunAddressDiscoverer.start();\n        responseServer.start();\n\n        System.setProperty(StackProperties.MAX_CTRAN_RETRANS_TIMER, \"100\");\n        System.setProperty(StackProperties.MAX_CTRAN_RETRANSMISSIONS, \"2\");\n    }\n\n    @AfterEach\n    public void tearDown() throws Exception\n    {\n        System.clearProperty(StackProperties.MAX_CTRAN_RETRANS_TIMER);\n        System.clearProperty(StackProperties.MAX_CTRAN_RETRANSMISSIONS);\n        responseServer.shutDown();\n        stunAddressDiscoverer.shutDown();\n        stunAddressDiscoverer = null;\n    }\n\n    /**\n     * Performs a test where no responces are given the stun client so that\n     * it concludes it's in a network where UDP is blocked.\n     * @throws Exception if anything goes wrong ( surprised? ).\n     */\n    @Test\n    public void testRecognizeBlockedUDP()\n        throws Exception\n    {\n\n        StunDiscoveryReport expectedReturn = new StunDiscoveryReport();\n\n        expectedReturn.setNatType(StunDiscoveryReport.UDP_BLOCKING_FIREWALL);\n        expectedReturn.setPublicAddress(null);\n\n        StunDiscoveryReport actualReturn\n            = stunAddressDiscoverer.determineAddress();\n        assertEquals(expectedReturn, actualReturn,\n            \"The StunAddressDiscoverer failed for a no-udp environment.\");\n    }\n\n    /**\n     * Performs a test where no responces are given the stun client so that\n     * it concludes it is behind a Symmetric NAT.\n     *\n     * @throws Exception if anything goes wrong ( surprised? ).\n     */\n    @Test\n    public void testRecognizeSymmetricNat()\n        throws Exception\n    {\n        //define the server response sequence\n        Response testIResponse1 = MessageFactory.create3489BindingResponse(\n             mappedClientAddress, responseServerAddress, responseServerAddress);\n        Response testIResponse2 = null;\n        Response testIResponse3 = MessageFactory.create3489BindingResponse(\n             mappedClientAddressPort2,\n             responseServerAddress,\n             responseServerAddress);\n\n        responseServer.addMessage(testIResponse1);\n        responseServer.addMessage(testIResponse2);\n        responseServer.addMessage(testIResponse3);\n\n\n        StunDiscoveryReport expectedReturn = new StunDiscoveryReport();\n\n        expectedReturn.setNatType(StunDiscoveryReport.SYMMETRIC_NAT);\n        expectedReturn.setPublicAddress(mappedClientAddress);\n\n        StunDiscoveryReport actualReturn\n            = stunAddressDiscoverer.determineAddress();\n        assertEquals(expectedReturn, actualReturn,\n            \"The StunAddressDiscoverer failed for a no-udp environment.\");\n    }\n\n    /**\n     * Performs a test where no responces are given the stun client so that\n     * it concludes it is behind a Port Restricted Cone.\n     * @throws Exception if anything goes wrong ( surprised? ).\n     */\n    @Test\n    public void testRecognizePortRestrictedCone()\n        throws Exception\n    {\n        //define the server response sequence\n        Response testIResponse1 = MessageFactory.create3489BindingResponse(\n            mappedClientAddress, responseServerAddress, responseServerAddress);\n        Response testIResponse2 = null;\n        Response testIResponse3 = MessageFactory.create3489BindingResponse(\n            mappedClientAddress, responseServerAddress, responseServerAddress);\n        Response testIResponse4 = null;\n\n        responseServer.addMessage(testIResponse1);\n        responseServer.addMessage(testIResponse2);\n        responseServer.addMessage(testIResponse3);\n        responseServer.addMessage(testIResponse4);\n\n\n        StunDiscoveryReport expectedReturn = new StunDiscoveryReport();\n\n        expectedReturn.setNatType(StunDiscoveryReport.PORT_RESTRICTED_CONE_NAT);\n        expectedReturn.setPublicAddress(mappedClientAddress);\n\n        StunDiscoveryReport actualReturn\n            = stunAddressDiscoverer.determineAddress();\n        assertEquals(expectedReturn, actualReturn,\n            \"The StunAddressDiscoverer failed for a no-udp environment.\");\n    }\n\n    /**\n     * Performs a test where no responces are given the stun client so that\n     * it concludes it is behind a Restricted Cone.\n     * @throws Exception if anything goes wrong ( surprised? ).\n     */\n    @Test\n    public void testRecognizeRestrictedCone()\n        throws Exception\n    {\n        //define the server response sequence\n        Response testIResponse1 = MessageFactory.create3489BindingResponse(\n            mappedClientAddress, responseServerAddress, responseServerAddress);\n        Response testIResponse2 = null;\n        Response testIResponse3 = MessageFactory.create3489BindingResponse(\n            mappedClientAddress, responseServerAddress, responseServerAddress);\n        Response testIResponse4 = MessageFactory.create3489BindingResponse(\n            mappedClientAddress, responseServerAddress, responseServerAddress);\n\n        responseServer.addMessage(testIResponse1);\n        responseServer.addMessage(testIResponse2);\n        responseServer.addMessage(testIResponse3);\n        responseServer.addMessage(testIResponse4);\n\n        StunDiscoveryReport expectedReturn = new StunDiscoveryReport();\n\n        expectedReturn.setNatType(StunDiscoveryReport.RESTRICTED_CONE_NAT);\n        expectedReturn.setPublicAddress(mappedClientAddress);\n\n        StunDiscoveryReport actualReturn\n            = stunAddressDiscoverer.determineAddress();\n        assertEquals(expectedReturn, actualReturn,\n            \"The StunAddressDiscoverer failed for a no-udp environment.\");\n    }\n\n    /**\n     * Performs a test where no responces are given the stun client so that\n     * it concludes it is behind a Full Cone.\n     * @throws Exception if anything goes wrong ( surprised? ).\n     */\n    @Test\n    public void testRecognizeFullCone() throws Exception\n    {\n        //define the server response sequence\n        Response testIResponse1 = MessageFactory.create3489BindingResponse(\n            mappedClientAddress, responseServerAddress, responseServerAddress);\n        Response testIResponse2 = MessageFactory.create3489BindingResponse(\n            mappedClientAddress, responseServerAddress, responseServerAddress);\n\n        responseServer.addMessage(testIResponse1);\n        responseServer.addMessage(testIResponse2);\n\n        StunDiscoveryReport expectedReturn = new StunDiscoveryReport();\n\n        expectedReturn.setNatType(StunDiscoveryReport.FULL_CONE_NAT);\n        expectedReturn.setPublicAddress(mappedClientAddress);\n\n        StunDiscoveryReport actualReturn = stunAddressDiscoverer\n            .determineAddress();\n        assertEquals(expectedReturn, actualReturn,\n            \"The StunAddressDiscoverer failed for a no-udp environment.\");\n    }\n\n    /**\n     * Performs a test where no responces are given the stun client so that\n     * it concludes it is behind a UDP Symmetric Firewall.\n     * @throws Exception if anything goes wrong ( surprised? ).\n     */\n    @Test\n    public void testRecognizeUdpSymmetricFirewall()\n        throws Exception\n    {\n        //define the server response sequence\n        Response testIResponse1 = MessageFactory.create3489BindingResponse(\n            discovererAddress, responseServerAddress, responseServerAddress);\n        Response testIResponse2 = null;\n\n        responseServer.addMessage(testIResponse1);\n        responseServer.addMessage(testIResponse2);\n\n        StunDiscoveryReport expectedReturn = new StunDiscoveryReport();\n\n        expectedReturn.setNatType(StunDiscoveryReport.SYMMETRIC_UDP_FIREWALL);\n        expectedReturn.setPublicAddress(discovererAddress);\n\n        StunDiscoveryReport actualReturn = stunAddressDiscoverer\n            .determineAddress();\n        assertEquals(expectedReturn, actualReturn,\n            \"The StunAddressDiscoverer failed for a no-udp environment.\");\n    }\n\n    /**\n     * Performs a test where no responces are given the stun client so that\n     * it concludes it is behind a Open Internet.\n     * @throws Exception if anything goes wrong ( surprised? ).\n     */\n    @Test\n    public void testRecognizeOpenInternet()\n        throws Exception\n    {\n        //define the server response sequence\n        Response testIResponse1 = MessageFactory.create3489BindingResponse(\n            discovererAddress, responseServerAddress, responseServerAddress);\n        Response testIResponse2 = MessageFactory.create3489BindingResponse(\n            discovererAddress, responseServerAddress, responseServerAddress);\n\n        responseServer.addMessage(testIResponse1);\n        responseServer.addMessage(testIResponse2);\n\n        StunDiscoveryReport expectedReturn = new StunDiscoveryReport();\n\n        expectedReturn.setNatType(StunDiscoveryReport.OPEN_INTERNET);\n        expectedReturn.setPublicAddress(discovererAddress);\n\n        StunDiscoveryReport actualReturn = stunAddressDiscoverer.\n            determineAddress();\n        assertEquals(expectedReturn, actualReturn,\n            \"The StunAddressDiscoverer failed for a no-udp environment.\");\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private NetworkConfigurationDiscoveryProcess  stunAddressDiscoverer = null;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "NetworkConfigurationDiscoveryProcess", "name": "stunAddressDiscoverer = null", "syntax_pass": true}, {"attribute_expression": "private final TransportAddress discovererAddress\n        = new TransportAddress(\"::1\", 16555, Transport.UDP);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "TransportAddress", "name": "discovererAddress\n        = new TransportAddress(\"::1\", 16555, Transport.UDP)", "syntax_pass": true}, {"attribute_expression": "private ResponseSequenceServer responseServer = null;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ResponseSequenceServer", "name": "responseServer = null", "syntax_pass": true}, {"attribute_expression": "private final TransportAddress responseServerAddress\n        = new TransportAddress(\"::1\", 20999, Transport.UDP);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "TransportAddress", "name": "responseServerAddress\n        = new TransportAddress(\"::1\", 20999, Transport.UDP)", "syntax_pass": true}, {"attribute_expression": "private final TransportAddress mappedClientAddress = new TransportAddress(\n                    \"2001:660:4701:1001:ff::1\", 16612, Transport.UDP);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "TransportAddress", "name": "mappedClientAddress = new TransportAddress(\n                    \"2001:660:4701:1001:ff::1\", 16612, Transport.UDP)", "syntax_pass": true}, {"attribute_expression": "private final TransportAddress mappedClientAddressPort2 = new TransportAddress(\n                    \"2001:660:4701:1001:ff::1\", 16611, Transport.UDP);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "TransportAddress", "name": "mappedClientAddressPort2 = new TransportAddress(\n                    \"2001:660:4701:1001:ff::1\", 16611, Transport.UDP)", "syntax_pass": true}]}, {"uris": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest_v4v6.java.StunAddressDiscovererTest_v4v6", "name": "StunAddressDiscovererTest_v4v6", "file_path": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest_v4v6.java", "superclasses": "", "methods": ["[void]testRecognizeSymmetricNat_Local_v6_Public_v4()", "[void]testRecognizeSymmetricNat_Local_v4_Public_v6()", "[void]testRecognizeFullCone_Local_v6_Public_v4()", "[void]testRecognizeFullCone_Local_v4_Public_v6()"], "method_uris": ["src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest_v4v6.java.StunAddressDiscovererTest_v4v6.[void]setUp()", "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest_v4v6.java.StunAddressDiscovererTest_v4v6.[void]tearDown()"], "overrides": null, "attributes": [], "class_docstring": "\nMakes basic stun tests for cases where local network addresses and the public\nNAT address are using different IP versions. (e.g. Local addresses are v4\npublic NAT address is v6 or vice versa)\n\n\nThe StunAddressDiscovererTest_XXX set of tests were created to verify stun\noperation for scenarios of some basic types of firewalls. The purpose of\nthese tests is to make sure that transaction retransmissions and rereceptions\nare handled transparently by the stack, as well as verify overall protocol\noperations for IPv4/IPv6 and mixed environments.\n\n<p>Company: Net Research Team, Louis Pasteur University</p>\n@author Emil Ivov\n", "original_string": "public class StunAddressDiscovererTest_v4v6\n{\n    private NetworkConfigurationDiscoveryProcess stunAddressDiscoverer_v6\n        = null;\n    private NetworkConfigurationDiscoveryProcess stunAddressDiscoverer_v4\n        = null;\n\n    private final TransportAddress discovererAddress_v4\n            = new TransportAddress(\"127.0.0.1\", 17555, Transport.UDP);\n    private final TransportAddress discovererAddress_v6\n            = new TransportAddress(\"::1\", 17555, Transport.UDP);\n\n    private ResponseSequenceServer responseServer_v6 = null;\n    private ResponseSequenceServer responseServer_v4 = null;\n\n    private final TransportAddress responseServerAddress_v6\n        = new TransportAddress(\"::1\", 21999, Transport.UDP);\n    private final TransportAddress responseServerAddress_v4\n        = new TransportAddress(\"127.0.0.1\", 21999, Transport.UDP);\n\n    private final TransportAddress mappedClientAddress_v6 = new TransportAddress(\n                    \"2001:660:4701:1001:ff::1\", 17612, Transport.UDP);\n    private final TransportAddress mappedClientAddress_v6_Port2\n        = new TransportAddress(\n                        \"2001:660:4701:1001:ff::1\", 17611, Transport.UDP);\n\n    private final TransportAddress mappedClientAddress_v4\n        = new TransportAddress(\"130.79.99.55\", 17612, Transport.UDP);\n    private final TransportAddress mappedClientAddress_v4_Port2\n        = new TransportAddress(\"130.79.99.55\", 17611, Transport.UDP);\n\n    @BeforeEach\n    public void setUp()\n        throws Exception\n    {\n        StunStack stunStack = new StunStack();\n\n        responseServer_v6\n            = new ResponseSequenceServer(stunStack, responseServerAddress_v6);\n        responseServer_v4\n            = new ResponseSequenceServer(stunStack, responseServerAddress_v4);\n\n        stunAddressDiscoverer_v6\n            = new NetworkConfigurationDiscoveryProcess(\n                    stunStack,\n                    discovererAddress_v6, responseServerAddress_v6);\n        stunAddressDiscoverer_v4\n            = new NetworkConfigurationDiscoveryProcess(\n                    stunStack,\n                    discovererAddress_v4, responseServerAddress_v4);\n\n        stunAddressDiscoverer_v6.start();\n        stunAddressDiscoverer_v4.start();\n        responseServer_v6.start();\n        responseServer_v4.start();\n\n        System.setProperty(StackProperties.MAX_CTRAN_RETRANS_TIMER , \"100\");\n        System.setProperty(StackProperties.MAX_CTRAN_RETRANSMISSIONS, \"2\");\n    }\n\n    @AfterEach\n    public void tearDown()\n        throws Exception\n    {\n        System.clearProperty(StackProperties.MAX_CTRAN_RETRANS_TIMER);\n        System.clearProperty(StackProperties.MAX_CTRAN_RETRANSMISSIONS);\n\n        responseServer_v6.shutDown();\n        responseServer_v4.shutDown();\n        stunAddressDiscoverer_v6.shutDown();\n        stunAddressDiscoverer_v6 = null;\n        stunAddressDiscoverer_v4.shutDown();\n        stunAddressDiscoverer_v4 = null;\n\n        //give the sockets the time to clear out\n        Thread.sleep(1000);\n    }\n\n    /**\n     * Performs a test where no responces are given the stun client so that\n     * it concludes it is behind a Symmetric NAT.\n     * @throws Exception if anything goes wrong ( surprised? ).\n     */\n    @Test\n    public void testRecognizeSymmetricNat_Local_v6_Public_v4()\n        throws Exception\n    {\n        //define the server response sequence\n        Response testIResponse1 = MessageFactory.create3489BindingResponse(\n            mappedClientAddress_v4,\n            responseServerAddress_v6,\n            responseServerAddress_v6);\n        Response testIResponse2 = null;\n        Response testIResponse3 = MessageFactory.create3489BindingResponse(\n            mappedClientAddress_v4_Port2,\n            responseServerAddress_v6,\n            responseServerAddress_v6);\n\n        responseServer_v6.addMessage(testIResponse1);\n        responseServer_v6.addMessage(testIResponse2);\n        responseServer_v6.addMessage(testIResponse3);\n\n\n        StunDiscoveryReport expectedReturn = new StunDiscoveryReport();\n\n        expectedReturn.setNatType(StunDiscoveryReport.SYMMETRIC_NAT);\n        expectedReturn.setPublicAddress(mappedClientAddress_v4);\n\n        StunDiscoveryReport actualReturn\n            = stunAddressDiscoverer_v6.determineAddress();\n        assertEquals(expectedReturn, actualReturn,\n            \"The StunAddressDiscoverer failed for a v4-v6 sym env.\");\n    }\n\n    /**\n     * Performs a test where no responces are given the stun client so that\n     * it concludes it is behind a Symmetric NAT.\n     * @throws Exception if anything goes wrong ( surprised? ).\n     */\n    @Test\n    public void testRecognizeSymmetricNat_Local_v4_Public_v6() throws Exception\n    {\n        //define the server response sequence\n        Response testIResponse1 = MessageFactory.create3489BindingResponse(\n            mappedClientAddress_v6,\n            responseServerAddress_v4,\n            responseServerAddress_v4);\n        Response testIResponse2 = null;\n        Response testIResponse3 = MessageFactory.create3489BindingResponse(\n            mappedClientAddress_v6_Port2,\n            responseServerAddress_v4,\n            responseServerAddress_v4);\n\n        responseServer_v4.addMessage(testIResponse1);\n        responseServer_v4.addMessage(testIResponse2);\n        responseServer_v4.addMessage(testIResponse3);\n\n\n        StunDiscoveryReport expectedReturn = new StunDiscoveryReport();\n\n        expectedReturn.setNatType(StunDiscoveryReport.SYMMETRIC_NAT);\n        expectedReturn.setPublicAddress(mappedClientAddress_v6);\n\n        StunDiscoveryReport actualReturn\n            = stunAddressDiscoverer_v4.determineAddress();\n        assertEquals(expectedReturn, actualReturn,\n            \"The StunAddressDiscoverer failed for a no-udp environment.\");\n    }\n\n    /**\n     * Performs a test where no responces are given the stun client so that\n     * it concludes it is behind a Full Cone.\n     * @throws Exception if anything goes wrong ( surprised? ).\n     */\n    @Test\n    public void testRecognizeFullCone_Local_v6_Public_v4() throws Exception\n    {\n        //define the server response sequence\n        Response testIResponse1 = MessageFactory.create3489BindingResponse(\n            mappedClientAddress_v4,\n            responseServerAddress_v6,\n            responseServerAddress_v6);\n        Response testIResponse2 = MessageFactory.create3489BindingResponse(\n            mappedClientAddress_v4,\n            responseServerAddress_v6,\n            responseServerAddress_v6);\n\n        responseServer_v6.addMessage(testIResponse1);\n        responseServer_v6.addMessage(testIResponse2);\n\n        StunDiscoveryReport expectedReturn = new StunDiscoveryReport();\n\n        expectedReturn.setNatType(StunDiscoveryReport.FULL_CONE_NAT);\n        expectedReturn.setPublicAddress(mappedClientAddress_v4);\n\n        StunDiscoveryReport actualReturn = stunAddressDiscoverer_v6.\n            determineAddress();\n        assertEquals(expectedReturn, actualReturn,\n            \"The StunAddressDiscoverer failed for a no-udp environment.\");\n    }\n\n    /**\n     * Performs a test where no responces are given the stun client so that\n     * it concludes it is behind a Full Cone.\n     * @throws Exception if anything goes wrong ( surprised? ).\n     */\n    @Test\n    public void testRecognizeFullCone_Local_v4_Public_v6() throws Exception\n    {\n        //define the server response sequence\n        Response testIResponse1 = MessageFactory.create3489BindingResponse(\n            mappedClientAddress_v6,\n            responseServerAddress_v4,\n            responseServerAddress_v4);\n        Response testIResponse2 = MessageFactory.create3489BindingResponse(\n            mappedClientAddress_v6,\n            responseServerAddress_v4,\n            responseServerAddress_v4);\n\n        responseServer_v4.addMessage(testIResponse1);\n        responseServer_v4.addMessage(testIResponse2);\n\n        StunDiscoveryReport expectedReturn = new StunDiscoveryReport();\n\n        expectedReturn.setNatType(StunDiscoveryReport.FULL_CONE_NAT);\n        expectedReturn.setPublicAddress(mappedClientAddress_v6);\n\n        StunDiscoveryReport actualReturn = stunAddressDiscoverer_v4.\n            determineAddress();\n        assertEquals(expectedReturn, actualReturn,\n            \"The StunAddressDiscoverer failed for a no-udp environment.\");\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private NetworkConfigurationDiscoveryProcess stunAddressDiscoverer_v6\n        = null;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "NetworkConfigurationDiscoveryProcess", "name": "stunAddressDiscoverer_v6\n        = null", "syntax_pass": true}, {"attribute_expression": "private NetworkConfigurationDiscoveryProcess stunAddressDiscoverer_v4\n        = null;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "NetworkConfigurationDiscoveryProcess", "name": "stunAddressDiscoverer_v4\n        = null", "syntax_pass": true}, {"attribute_expression": "private final TransportAddress discovererAddress_v4\n            = new TransportAddress(\"127.0.0.1\", 17555, Transport.UDP);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "TransportAddress", "name": "discovererAddress_v4\n            = new TransportAddress(\"127.0.0.1\", 17555, Transport.UDP)", "syntax_pass": true}, {"attribute_expression": "private final TransportAddress discovererAddress_v6\n            = new TransportAddress(\"::1\", 17555, Transport.UDP);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "TransportAddress", "name": "discovererAddress_v6\n            = new TransportAddress(\"::1\", 17555, Transport.UDP)", "syntax_pass": true}, {"attribute_expression": "private ResponseSequenceServer responseServer_v6 = null;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ResponseSequenceServer", "name": "responseServer_v6 = null", "syntax_pass": true}, {"attribute_expression": "private ResponseSequenceServer responseServer_v4 = null;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ResponseSequenceServer", "name": "responseServer_v4 = null", "syntax_pass": true}, {"attribute_expression": "private final TransportAddress responseServerAddress_v6\n        = new TransportAddress(\"::1\", 21999, Transport.UDP);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "TransportAddress", "name": "responseServerAddress_v6\n        = new TransportAddress(\"::1\", 21999, Transport.UDP)", "syntax_pass": true}, {"attribute_expression": "private final TransportAddress responseServerAddress_v4\n        = new TransportAddress(\"127.0.0.1\", 21999, Transport.UDP);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "TransportAddress", "name": "responseServerAddress_v4\n        = new TransportAddress(\"127.0.0.1\", 21999, Transport.UDP)", "syntax_pass": true}, {"attribute_expression": "private final TransportAddress mappedClientAddress_v6 = new TransportAddress(\n                    \"2001:660:4701:1001:ff::1\", 17612, Transport.UDP);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "TransportAddress", "name": "mappedClientAddress_v6 = new TransportAddress(\n                    \"2001:660:4701:1001:ff::1\", 17612, Transport.UDP)", "syntax_pass": true}, {"attribute_expression": "private final TransportAddress mappedClientAddress_v6_Port2\n        = new TransportAddress(\n                        \"2001:660:4701:1001:ff::1\", 17611, Transport.UDP);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "TransportAddress", "name": "mappedClientAddress_v6_Port2\n        = new TransportAddress(\n                        \"2001:660:4701:1001:ff::1\", 17611, Transport.UDP)", "syntax_pass": true}, {"attribute_expression": "private final TransportAddress mappedClientAddress_v4\n        = new TransportAddress(\"130.79.99.55\", 17612, Transport.UDP);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "TransportAddress", "name": "mappedClientAddress_v4\n        = new TransportAddress(\"130.79.99.55\", 17612, Transport.UDP)", "syntax_pass": true}, {"attribute_expression": "private final TransportAddress mappedClientAddress_v4_Port2\n        = new TransportAddress(\"130.79.99.55\", 17611, Transport.UDP);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "TransportAddress", "name": "mappedClientAddress_v4_Port2\n        = new TransportAddress(\"130.79.99.55\", 17611, Transport.UDP)", "syntax_pass": true}]}, {"uris": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest.java.StunAddressDiscovererTest", "name": "StunAddressDiscovererTest", "file_path": "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest.java", "superclasses": "", "methods": ["[void]testRecognizeBlockedUDP()", "[void]testRecognizeSymmetricNat()", "[void]testRecognizePortRestrictedCone()", "[void]testRecognizeRestrictedCone()", "[void]testRecognizeFullCone()", "[void]testRecognizeUdpSymmetricFirewall()", "[void]testRecognizeOpenInternet()"], "method_uris": ["src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest.java.StunAddressDiscovererTest.[void]setUp()", "src/test/java/org/ice4j/stunclient/StunAddressDiscovererTest.java.StunAddressDiscovererTest.[void]tearDown()"], "overrides": null, "attributes": [], "class_docstring": "\nThe StunAddressDiscovererTest_XXX set of tests were created to verify stun\noperation for scenarios of some basic types of firewalls. The purpose of\nthese tests is to make sure that transaction retransmissions and rereceptions\nare handled transparently by the stack, as well as verify overall protocol\noperations for IPv4/IPv6 and mixed environments.\n\n<p>Company: Net Research Team, Louis Pasteur University</p>\n@author Emil Ivov\n", "original_string": "public class StunAddressDiscovererTest\n{\n    private NetworkConfigurationDiscoveryProcess  stunAddressDiscoverer = null;\n    private final TransportAddress discovererAddress\n        = new TransportAddress(\"127.0.0.1\", 15555, Transport.UDP);\n\n    private ResponseSequenceServer responseServer = null;\n    private final TransportAddress responseServerAddress\n        = new TransportAddress(\"127.0.0.1\", 19999, Transport.UDP);\n\n\n    private final TransportAddress mappedClientAddress\n        = new TransportAddress(\"212.56.4.10\", 15612, Transport.UDP);\n    private final TransportAddress mappedClientAddressPort2\n        = new TransportAddress(\"212.56.4.10\", 15611, Transport.UDP);\n\n    @BeforeEach\n    public void setUp() throws Exception\n    {\n        System.setProperty(StackProperties.MAX_CTRAN_RETRANS_TIMER, \"100\");\n        System.setProperty(StackProperties.MAX_CTRAN_RETRANSMISSIONS, \"2\");\n\n        StunStack stunStack = new StunStack();\n\n        responseServer\n            = new ResponseSequenceServer(stunStack, responseServerAddress);\n        stunAddressDiscoverer\n            = new NetworkConfigurationDiscoveryProcess(\n                    stunStack,\n                    discovererAddress, responseServerAddress);\n\n        stunAddressDiscoverer.start();\n        responseServer.start();\n    }\n\n    @AfterEach\n    public void tearDown() throws Exception\n    {\n        System.clearProperty(StackProperties.MAX_CTRAN_RETRANS_TIMER);\n        System.clearProperty(StackProperties.MAX_CTRAN_RETRANSMISSIONS);\n        responseServer.shutDown();\n        stunAddressDiscoverer.shutDown();\n        stunAddressDiscoverer = null;\n    }\n\n    /**\n     * Performs a test where no responses are given the stun client so that\n     * it concludes it's in a network where UDP is blocked.\n     *\n     * @throws Exception if anything goes wrong ( surprised? ).\n     */\n    @Test\n    public void testRecognizeBlockedUDP()\n        throws Exception\n    {\n\n        StunDiscoveryReport expectedReturn = new StunDiscoveryReport();\n\n        expectedReturn.setNatType(StunDiscoveryReport.UDP_BLOCKING_FIREWALL);\n        expectedReturn.setPublicAddress(null);\n\n        StunDiscoveryReport actualReturn = stunAddressDiscoverer\n            .determineAddress();\n        assertEquals(expectedReturn, actualReturn,\n            \"The StunAddressDiscoverer failed for a no-udp environment.\");\n    }\n\n\n    /**\n     * Performs a test where no responces are given the stun client so that\n     * it concludes it is behind a Symmetric NAT.\n     * @throws Exception if anything goes wrong ( surprised? ).\n     */\n    @Test\n    public void testRecognizeSymmetricNat() throws Exception\n    {\n        //define the server response sequence\n        Response testIResponse1 = MessageFactory.create3489BindingResponse(\n            mappedClientAddress, responseServerAddress, responseServerAddress);\n        Response testIResponse2 = null;\n        Response testIResponse3 = MessageFactory.create3489BindingResponse(\n            mappedClientAddressPort2,\n            responseServerAddress,\n            responseServerAddress);\n\n        responseServer.addMessage(testIResponse1);\n        responseServer.addMessage(testIResponse2);\n        responseServer.addMessage(testIResponse3);\n\n\n        StunDiscoveryReport expectedReturn = new StunDiscoveryReport();\n\n        expectedReturn.setNatType(StunDiscoveryReport.SYMMETRIC_NAT);\n        expectedReturn.setPublicAddress(mappedClientAddress);\n\n        StunDiscoveryReport actualReturn\n            = stunAddressDiscoverer.determineAddress();\n        assertEquals(expectedReturn, actualReturn,\n            \"The StunAddressDiscoverer failed for a no-udp environment.\");\n\n    }\n\n    /**\n     * Performs a test where no responces are given the stun client so that\n     * it concludes it is behind a Port Restricted Cone.\n     * @throws Exception if anything goes wrong ( surprised? ).\n     */\n    @Test\n    public void testRecognizePortRestrictedCone()\n        throws Exception\n    {\n        //define the server response sequence\n        Response testIResponse1 = MessageFactory.create3489BindingResponse(\n            mappedClientAddress, responseServerAddress, responseServerAddress);\n        Response testIResponse2 = null;\n        Response testIResponse3 = MessageFactory.create3489BindingResponse(\n            mappedClientAddress, responseServerAddress, responseServerAddress);\n        Response testIResponse4 = null;\n\n        responseServer.addMessage(testIResponse1);\n        responseServer.addMessage(testIResponse2);\n        responseServer.addMessage(testIResponse3);\n        responseServer.addMessage(testIResponse4);\n\n\n        StunDiscoveryReport expectedReturn = new StunDiscoveryReport();\n\n        expectedReturn.setNatType(StunDiscoveryReport.PORT_RESTRICTED_CONE_NAT);\n        expectedReturn.setPublicAddress(mappedClientAddress);\n\n        StunDiscoveryReport actualReturn\n            = stunAddressDiscoverer.determineAddress();\n        assertEquals(expectedReturn, actualReturn,\n            \"The StunAddressDiscoverer failed for a no-udp environment.\");\n\n    }\n\n    /**\n     * Performs a test where no responces are given the stun client so that\n     * it concludes it is behind a Restricted Cone.\n     * @throws Exception if anything goes wrong ( surprised? ).\n     */\n    @Test\n    public void testRecognizeRestrictedCone() throws Exception\n    {\n        //define the server response sequence\n        Response testIResponse1 = MessageFactory.create3489BindingResponse(\n            mappedClientAddress, responseServerAddress, responseServerAddress);\n        Response testIResponse2 = null;\n        Response testIResponse3 = MessageFactory.create3489BindingResponse(\n            mappedClientAddress, responseServerAddress, responseServerAddress);\n        Response testIResponse4 = MessageFactory.create3489BindingResponse(\n            mappedClientAddress, responseServerAddress, responseServerAddress);\n\n        responseServer.addMessage(testIResponse1);\n        responseServer.addMessage(testIResponse2);\n        responseServer.addMessage(testIResponse3);\n        responseServer.addMessage(testIResponse4);\n\n        StunDiscoveryReport expectedReturn = new StunDiscoveryReport();\n\n        expectedReturn.setNatType(StunDiscoveryReport.RESTRICTED_CONE_NAT);\n        expectedReturn.setPublicAddress(mappedClientAddress);\n\n        StunDiscoveryReport actualReturn = stunAddressDiscoverer\n            .determineAddress();\n        assertEquals(expectedReturn, actualReturn,\n            \"The StunAddressDiscoverer failed for a no-udp environment.\");\n    }\n\n    /**\n     * Performs a test where no responces are given the stun client so that\n     * it concludes it is behind a Full Cone.\n     * @throws Exception if anything goes wrong ( surprised? ).\n     */\n    @Test\n    public void testRecognizeFullCone()\n        throws Exception\n    {\n        //define the server response sequence\n        Response testIResponse1 = MessageFactory.create3489BindingResponse(\n            mappedClientAddress, responseServerAddress, responseServerAddress);\n        Response testIResponse2 = MessageFactory.create3489BindingResponse(\n            mappedClientAddress, responseServerAddress, responseServerAddress);\n\n        responseServer.addMessage(testIResponse1);\n        responseServer.addMessage(testIResponse2);\n\n        StunDiscoveryReport expectedReturn = new StunDiscoveryReport();\n\n        expectedReturn.setNatType(StunDiscoveryReport.FULL_CONE_NAT);\n        expectedReturn.setPublicAddress(mappedClientAddress);\n\n        StunDiscoveryReport actualReturn = stunAddressDiscoverer.\n            determineAddress();\n        assertEquals(expectedReturn, actualReturn,\n            \"The StunAddressDiscoverer failed for a no-udp environment.\");\n    }\n\n    /**\n     * Performs a test where no responces are given the stun client so that\n     * it concludes it is behind a UDP Symmetric Firewall.\n     *\n     * @throws Exception if anything goes wrong ( surprised? ).\n     */\n    @Test\n    public void testRecognizeUdpSymmetricFirewall()\n        throws Exception\n    {\n        //define the server response sequence\n        Response testIResponse1 = MessageFactory.create3489BindingResponse(\n            discovererAddress, responseServerAddress, responseServerAddress);\n        Response testIResponse2 = null;\n\n        responseServer.addMessage(testIResponse1);\n        responseServer.addMessage(testIResponse2);\n\n        StunDiscoveryReport expectedReturn = new StunDiscoveryReport();\n\n        expectedReturn.setNatType(StunDiscoveryReport.SYMMETRIC_UDP_FIREWALL);\n        expectedReturn.setPublicAddress(discovererAddress);\n\n        StunDiscoveryReport actualReturn = stunAddressDiscoverer.\n            determineAddress();\n        assertEquals(expectedReturn, actualReturn,\n            \"The StunAddressDiscoverer failed for a no-udp environment.\");\n\n    }\n\n    /**\n     * Performs a test where no responces are given the stun client so that\n     * it concludes it is behind a Open Internet.\n     *\n     * @throws Exception if anything goes wrong ( surprised? ).\n     */\n    @Test\n    public void testRecognizeOpenInternet()\n        throws Exception\n    {\n        //define the server response sequence\n        Response testIResponse1 = MessageFactory.create3489BindingResponse(\n            discovererAddress, responseServerAddress, responseServerAddress);\n        Response testIResponse2 = MessageFactory.create3489BindingResponse(\n            discovererAddress, responseServerAddress, responseServerAddress);\n\n        responseServer.addMessage(testIResponse1);\n        responseServer.addMessage(testIResponse2);\n\n        StunDiscoveryReport expectedReturn = new StunDiscoveryReport();\n\n        expectedReturn.setNatType(StunDiscoveryReport.OPEN_INTERNET);\n        expectedReturn.setPublicAddress(discovererAddress);\n\n        StunDiscoveryReport actualReturn = stunAddressDiscoverer.\n            determineAddress();\n        assertEquals(expectedReturn, actualReturn,\n            \"The StunAddressDiscoverer failed for a no-udp environment.\");\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private NetworkConfigurationDiscoveryProcess  stunAddressDiscoverer = null;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "NetworkConfigurationDiscoveryProcess", "name": "stunAddressDiscoverer = null", "syntax_pass": true}, {"attribute_expression": "private final TransportAddress discovererAddress\n        = new TransportAddress(\"127.0.0.1\", 15555, Transport.UDP);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "TransportAddress", "name": "discovererAddress\n        = new TransportAddress(\"127.0.0.1\", 15555, Transport.UDP)", "syntax_pass": true}, {"attribute_expression": "private ResponseSequenceServer responseServer = null;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ResponseSequenceServer", "name": "responseServer = null", "syntax_pass": true}, {"attribute_expression": "private final TransportAddress responseServerAddress\n        = new TransportAddress(\"127.0.0.1\", 19999, Transport.UDP);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "TransportAddress", "name": "responseServerAddress\n        = new TransportAddress(\"127.0.0.1\", 19999, Transport.UDP)", "syntax_pass": true}, {"attribute_expression": "private final TransportAddress mappedClientAddress\n        = new TransportAddress(\"212.56.4.10\", 15612, Transport.UDP);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "TransportAddress", "name": "mappedClientAddress\n        = new TransportAddress(\"212.56.4.10\", 15612, Transport.UDP)", "syntax_pass": true}, {"attribute_expression": "private final TransportAddress mappedClientAddressPort2\n        = new TransportAddress(\"212.56.4.10\", 15611, Transport.UDP);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "TransportAddress", "name": "mappedClientAddressPort2\n        = new TransportAddress(\"212.56.4.10\", 15611, Transport.UDP)", "syntax_pass": true}]}, {"uris": "src/test/java/org/ice4j/stack/ShallowStackTest.java.ShallowStackTest", "name": "ShallowStackTest", "file_path": "src/test/java/org/ice4j/stack/ShallowStackTest.java", "superclasses": "", "methods": ["[void]testSendRequest()", "[void]testReceiveRequest()", "[void]testSendResponse()", "[void]testReceiveResponse()", "[void]testRetransmissionOriginalWait()"], "method_uris": ["src/test/java/org/ice4j/stack/ShallowStackTest.java.ShallowStackTest.[void]setupConfig()", "src/test/java/org/ice4j/stack/ShallowStackTest.java.ShallowStackTest.[void]resetConfig()", "src/test/java/org/ice4j/stack/ShallowStackTest.java.ShallowStackTest.[void]setUp()", "src/test/java/org/ice4j/stack/ShallowStackTest.java.ShallowStackTest.[void]tearDown()"], "overrides": null, "attributes": [{"original_string": "    public static class SimpleResponseCollector\n        extends AbstractResponseCollector\n    {\n\n        /**\n         * The response that we've just collected or <tt>null</tt> if none\n         * arrived while we were waiting.\n         */\n        Response collectedResponse = null;\n\n        /**\n         * Notifies this <tt>ResponseCollector</tt> that a transaction described by\n         * the specified <tt>BaseStunMessageEvent</tt> has failed. The possible\n         * reasons for the failure include timeouts, unreachable destination, etc.\n         *\n         * @param event the <tt>BaseStunMessageEvent</tt> which describes the failed\n         * transaction and the runtime type of which specifies the failure reason\n         * @see AbstractResponseCollector#processFailure(BaseStunMessageEvent)\n         */\n        protected synchronized void processFailure(BaseStunMessageEvent event)\n        {\n            String msg;\n\n            if (event instanceof StunFailureEvent)\n                msg = \"Unreachable\";\n            else if (event instanceof StunTimeoutEvent)\n                msg = \"Timeout\";\n            else\n                msg = \"Failure\";\n            logger.info(msg);\n            notifyAll();\n        }\n\n        /**\n         * Logs the received response and notifies the wait method.\n         *\n         * @param response a <tt>StunMessageEvent</tt> which describes the\n         * received STUN <tt>Response</tt>\n         */\n        public synchronized void processResponse(StunResponseEvent response)\n        {\n            collectedResponse = (Response) response.getMessage();\n            logger.finest(\"Received response.\");\n            notifyAll();\n        }\n\n        /**\n         * Blocks until a request arrives or 50 ms pass.\n         */\n        public synchronized void waitForResponse()\n        {\n            try\n            {\n                if (collectedResponse == null)\n                    wait(50);\n            }\n            catch (InterruptedException e)\n            {\n                logger.log(Level.INFO, \"oops\", e);\n            }\n        }\n    }", "definition": "    public static class SimpleResponseCollector\n        extends AbstractResponseCollector", "class_docstring": "\nA simple utility that allows us to asynchronously collect messages.\n", "name": "SimpleResponseCollector", "super_interfaces": [], "superclasses": "AbstractResponseCollector", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "Response collectedResponse = null;", "docstring": "\nThe response that we've just collected or <tt>null</tt> if none\narrived while we were waiting.\n", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "Response", "name": "collectedResponse = null", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        protected synchronized void processFailure(BaseStunMessageEvent event)\n        {\n            String msg;\n\n            if (event instanceof StunFailureEvent)\n                msg = \"Unreachable\";\n            else if (event instanceof StunTimeoutEvent)\n                msg = \"Timeout\";\n            else\n                msg = \"Failure\";\n            logger.info(msg);\n            notifyAll();\n        }", "docstring": "\nNotifies this <tt>ResponseCollector</tt> that a transaction described by\nthe specified <tt>BaseStunMessageEvent</tt> has failed. The possible\nreasons for the failure include timeouts, unreachable destination, etc.\n\n@param event the <tt>BaseStunMessageEvent</tt> which describes the failed\ntransaction and the runtime type of which specifies the failure reason\n@see AbstractResponseCollector#processFailure(BaseStunMessageEvent)\n", "attributes": {"modifiers": "protected synchronized", "marker_annotations": [], "non_marker_annotations": ["protected", "synchronized"], "comments": [], "return_type": "void", "classes": []}, "name": "processFailure", "params": [{"name": "event", "type": "BaseStunMessageEvent"}], "body": "        {\n            String msg;\n\n            if (event instanceof StunFailureEvent)\n                msg = \"Unreachable\";\n            else if (event instanceof StunTimeoutEvent)\n                msg = \"Timeout\";\n            else\n                msg = \"Failure\";\n            logger.info(msg);\n            notifyAll();\n        }", "signature": "protected synchronized void processFailure(BaseStunMessageEvent event)"}, {"syntax_pass": true, "original_string": "        public synchronized void processResponse(StunResponseEvent response)\n        {\n            collectedResponse = (Response) response.getMessage();\n            logger.finest(\"Received response.\");\n            notifyAll();\n        }", "docstring": "\nLogs the received response and notifies the wait method.\n\n@param response a <tt>StunMessageEvent</tt> which describes the\nreceived STUN <tt>Response</tt>\n", "attributes": {"modifiers": "public synchronized", "marker_annotations": [], "non_marker_annotations": ["public", "synchronized"], "comments": [], "return_type": "void", "classes": []}, "name": "processResponse", "params": [{"name": "response", "type": "StunResponseEvent"}], "body": "        {\n            collectedResponse = (Response) response.getMessage();\n            logger.finest(\"Received response.\");\n            notifyAll();\n        }", "signature": "public synchronized void processResponse(StunResponseEvent response)"}, {"syntax_pass": true, "original_string": "        public synchronized void waitForResponse()\n        {\n            try\n            {\n                if (collectedResponse == null)\n                    wait(50);\n            }\n            catch (InterruptedException e)\n            {\n                logger.log(Level.INFO, \"oops\", e);\n            }\n        }", "docstring": "\nBlocks until a request arrives or 50 ms pass.\n", "attributes": {"modifiers": "public synchronized", "marker_annotations": [], "non_marker_annotations": ["public", "synchronized"], "comments": [], "return_type": "void", "classes": []}, "name": "waitForResponse", "params": [], "body": "        {\n            try\n            {\n                if (collectedResponse == null)\n                    wait(50);\n            }\n            catch (InterruptedException e)\n            {\n                logger.log(Level.INFO, \"oops\", e);\n            }\n        }", "signature": "public synchronized void waitForResponse()"}]}, {"original_string": "    public class SimpleRequestCollector\n        implements RequestListener\n    {\n        /**\n         * The one request that this collector has received or <tt>null</tt> if\n         * none arrived while we were waiting.\n         */\n        private Request collectedRequest = null;\n\n        /**\n         * Indicates that a <tt>StunRequest</tt> has just been received.\n         *\n         * @param evt the <tt>StunMessageEvent</tt> containing the details of\n         * the newly received request.\n         */\n        public void processRequest(StunMessageEvent evt)\n        {\n            synchronized(this)\n            {\n                collectedRequest = (Request)evt.getMessage();\n                stunStack.removeRequestListener(this);\n                logger.finest(\"Received request.\");\n                notifyAll();\n            }\n        }\n\n        /**\n         * Blocks until a request arrives or 50 ms pass.\n         */\n        public void waitForRequest()\n        {\n            synchronized(this)\n            {\n                if (collectedRequest != null)\n                    return;\n\n                try\n                {\n                    wait(50);\n                }\n                catch (InterruptedException e)\n                {\n                    logger.log(Level.INFO, \"oops\", e);\n                }\n            }\n        }\n    }", "definition": "    public class SimpleRequestCollector\n        implements RequestListener", "class_docstring": "\nA utility class for asynchronously collecting requests.\n", "name": "SimpleRequestCollector", "super_interfaces": ["RequestListener"], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private Request collectedRequest = null;", "docstring": "\nThe one request that this collector has received or <tt>null</tt> if\nnone arrived while we were waiting.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Request", "name": "collectedRequest = null", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public void processRequest(StunMessageEvent evt)\n        {\n            synchronized(this)\n            {\n                collectedRequest = (Request)evt.getMessage();\n                stunStack.removeRequestListener(this);\n                logger.finest(\"Received request.\");\n                notifyAll();\n            }\n        }", "docstring": "\nIndicates that a <tt>StunRequest</tt> has just been received.\n\n@param evt the <tt>StunMessageEvent</tt> containing the details of\nthe newly received request.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "processRequest", "params": [{"name": "evt", "type": "StunMessageEvent"}], "body": "        {\n            synchronized(this)\n            {\n                collectedRequest = (Request)evt.getMessage();\n                stunStack.removeRequestListener(this);\n                logger.finest(\"Received request.\");\n                notifyAll();\n            }\n        }", "signature": "public void processRequest(StunMessageEvent evt)"}, {"syntax_pass": true, "original_string": "        public void waitForRequest()\n        {\n            synchronized(this)\n            {\n                if (collectedRequest != null)\n                    return;\n\n                try\n                {\n                    wait(50);\n                }\n                catch (InterruptedException e)\n                {\n                    logger.log(Level.INFO, \"oops\", e);\n                }\n            }\n        }", "docstring": "\nBlocks until a request arrives or 50 ms pass.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "waitForRequest", "params": [], "body": "        {\n            synchronized(this)\n            {\n                if (collectedRequest != null)\n                    return;\n\n                try\n                {\n                    wait(50);\n                }\n                catch (InterruptedException e)\n                {\n                    logger.log(Level.INFO, \"oops\", e);\n                }\n            }\n        }", "signature": "public void waitForRequest()"}]}], "class_docstring": "\nAll unit stack tests should be provided later. I just don't have the time now.\n\n@author Emil Ivov\n", "original_string": "public class ShallowStackTest\n{\n    @BeforeAll\n    public static void setupConfig()\n    {\n        System.clearProperty(StackProperties.ALWAYS_SIGN);\n        System.setProperty(\"ice4j.software\", \"\");\n        JitsiConfig.Companion.reloadNewConfig();\n    }\n\n    @AfterAll\n    public static void resetConfig()\n    {\n        System.clearProperty(\"ice4j.software\");\n        JitsiConfig.Companion.reloadNewConfig();\n    }\n\n    /**\n     * The <tt>Logger</tt> used by the <tt>ShallowStackTest<tt> class and its\n     * instances for logging output.\n     */\n    private static final Logger logger\n        = Logger.getLogger(ShallowStackTest.class.getName());\n\n    /**\n     * The <tt>StunStack</tt> used by this <tt>ShallowStackTest</tt>\n     */\n    private StunStack    stunStack;\n    private MsgFixture   msgFixture = null;\n\n    private TransportAddress dummyServerAddress = null;\n    private TransportAddress localAddress = null;\n\n    private final DatagramCollector dgramCollector = new DatagramCollector();\n\n    private IceSocketWrapper   localSock = null;\n\n    private DatagramSocket dummyServerSocket = null;\n\n    /**\n     * Initializes whatever sockets we'll be using in our tests.\n     *\n     * @throws Exception if something goes wrong with socket initialization.\n     */\n    @BeforeEach\n    public void setUp()\n        throws Exception\n    {\n        msgFixture = new MsgFixture();\n\n        //init the stack\n        stunStack = new StunStack();\n\n        //access point\n        localSock = new IceUdpSocketWrapper(\n            new SafeCloseDatagramSocket(new InetSocketAddress(\"127.0.0.1\", 0)));\n        localAddress = new TransportAddress(\n            \"127.0.0.1\", localSock.getLocalPort(), Transport.UDP);\n        stunStack.addSocket(localSock);\n\n        //init the dummy server\n        dummyServerSocket = new DatagramSocket(new InetSocketAddress(\"127.0.0.1\", 0));\n        dummyServerAddress = new TransportAddress(\n            \"127.0.0.1\", dummyServerSocket.getLocalPort(), Transport.UDP);\n    }\n\n    /**\n     * Releases the sockets we use here.\n     *\n     * @throws Exception if closing the sockets fails.\n     */\n    @AfterEach\n    public void tearDown()\n        throws Exception\n    {\n        stunStack.removeSocket(localAddress);\n        stunStack.shutDown();\n\n        localSock.close();\n\n        dummyServerSocket.close();\n\n        msgFixture = null;\n    }\n\n\n    /**\n     * Sends a binding request using the stack to a bare socket, and verifies\n     * that it is received and that the contents of the datagram corresponds to\n     * the request that was sent.\n     *\n     * @throws java.lang.Exception if we fail\n     */\n    @Test\n    public void testSendRequest()\n        throws Exception\n    {\n        Request bindingRequest = MessageFactory.createBindingRequest();\n\n        dgramCollector.startListening(dummyServerSocket);\n\n        stunStack.sendRequest(bindingRequest,\n                              dummyServerAddress,\n                              localAddress,\n                              new SimpleResponseCollector());\n\n        //wait for its arrival\n        dgramCollector.waitForPacket(1000);\n\n        DatagramPacket receivedPacket = dgramCollector.collectPacket();\n\n        assertTrue((receivedPacket.getLength() > 0),\n            \"The stack did not properly send a Binding Request\");\n\n        Request receivedRequest =\n                        (Request)Request.decode(receivedPacket.getData(),\n                                            (char)0,\n                                            (char)receivedPacket.getLength());\n        assertEquals(bindingRequest, receivedRequest,\n            \"The received request did not match the one that was sent.\");\n\n        //wait for retransmissions\n\n        dgramCollector.startListening(dummyServerSocket);\n\n        dgramCollector.waitForPacket(1000);\n\n        receivedPacket = dgramCollector.collectPacket();\n\n        assertTrue((receivedPacket.getLength() > 0),\n            \"The stack did not retransmit a Binding Request\");\n\n        receivedRequest = (Request)Request.decode(\n            receivedPacket.getData(),\n            0,\n            receivedPacket.getLength());\n        assertEquals(bindingRequest, receivedRequest,\n            \"The retransmitted request did not match the original.\");\n    }\n\n    /**\n     * Sends a byte array containing a bindingRequest, through a datagram socket\n     * and verifies that the stack receives it alright.\n     *\n     * @throws java.lang.Exception if we fail\n     */\n    @Test\n    public void testReceiveRequest()\n        throws Exception\n    {\n        SimpleRequestCollector requestCollector = new SimpleRequestCollector();\n        stunStack.addRequestListener(requestCollector);\n\n        dummyServerSocket.send(new DatagramPacket(\n            msgFixture.bindingRequest2,\n            msgFixture.bindingRequest2.length,\n            localAddress));\n\n        //wait for the packet to arrive\n        requestCollector.waitForRequest();\n\n        Request collectedRequest = requestCollector.collectedRequest;\n\n        assertNotNull(collectedRequest, \"No request has been received\");\n\n        byte[] expectedReturn = msgFixture.bindingRequest2;\n        byte[] actualReturn = collectedRequest.encode(stunStack);\n        assertArrayEquals(expectedReturn, actualReturn,\n            \"Received request was not the same as the one that was sent\");\n    }\n\n    /**\n     * Sends a byte array containing a bindingRequest, through a datagram socket,\n     * verifies that the stack receives it properly and then sends a response\n     * using the stack. Finally, the response is expected at the other end and\n     * compared with the sent one.\n     *\n     * @throws java.lang.Exception if we fail\n     */\n    @Test\n    public void testSendResponse()\n        throws Exception\n    {\n        //---------- send & receive the request --------------------------------\n        SimpleRequestCollector requestCollector = new SimpleRequestCollector();\n        stunStack.addRequestListener(requestCollector);\n\n        dummyServerSocket.send(new DatagramPacket(\n                                            msgFixture.bindingRequest,\n                                            msgFixture.bindingRequest.length,\n                                            localAddress));\n\n        //wait for the packet to arrive\n        requestCollector.waitForRequest();\n\n        Request collectedRequest = requestCollector.collectedRequest;\n\n        byte[] expectedReturn = msgFixture.bindingRequest;\n        byte[] actualReturn = collectedRequest.encode(stunStack);\n        assertArrayEquals(expectedReturn, actualReturn,\n            \"Received request was not the same as the one that was sent\");\n\n        //---------- create the response ---------------------------------------\n        Response bindingResponse = MessageFactory.create3489BindingResponse(\n            new TransportAddress( MsgFixture.ADDRESS_ATTRIBUTE_ADDRESS,\n                 MsgFixture.ADDRESS_ATTRIBUTE_PORT, Transport.UDP ),\n            new TransportAddress( MsgFixture.ADDRESS_ATTRIBUTE_ADDRESS_2,\n                 MsgFixture.ADDRESS_ATTRIBUTE_PORT_2, Transport.UDP),\n            new TransportAddress( MsgFixture.ADDRESS_ATTRIBUTE_ADDRESS_3,\n                 MsgFixture.ADDRESS_ATTRIBUTE_PORT_3, Transport.UDP));\n\n        //---------- send & receive the response -------------------------------\n        dgramCollector.startListening(dummyServerSocket);\n\n        stunStack.sendResponse(collectedRequest.getTransactionID(),\n                               bindingResponse,\n                               localAddress,\n                               dummyServerAddress);\n\n        //wait for its arrival\n        dgramCollector.waitForPacket();\n\n        DatagramPacket receivedPacket = dgramCollector.collectPacket();\n\n        assertTrue((receivedPacket.getLength() > 0),\n            \"The stack did not properly send a Binding Request\");\n\n        Response receivedResponse =\n            (Response) Response.decode(receivedPacket.getData(),\n                                       0,\n                                       receivedPacket.getLength());\n        assertEquals(bindingResponse, receivedResponse,\n            \"The received request did not match the one that was sent.\");\n    }\n\n    /**\n     * Performs a basic test on message reception\n     *\n     * @throws Exception if something fails somewhere.\n     */\n    @Test\n    public void testReceiveResponse()\n        throws Exception\n    {\n        SimpleResponseCollector collector = new SimpleResponseCollector();\n        //--------------- send the original request ----------------------------\n        Request bindingRequest = MessageFactory.createBindingRequest();\n\n        stunStack.sendRequest(bindingRequest,\n                              dummyServerAddress,\n                              localAddress,\n                              collector);\n\n        //wait for its arrival\n        collector.waitForResponse();\n\n        //create the right response\n        byte[] response = new byte[msgFixture.bindingResponse.length];\n        System.arraycopy(msgFixture.bindingResponse, 0, response, 0,\n                         response.length);\n\n        //Set the valid tid.\n        System.arraycopy(bindingRequest.getTransactionID(),\n                         0,\n                         response,\n                         8,\n                         12);\n\n        //send the response\n\n        dummyServerSocket.send(new DatagramPacket(response,\n                                                response.length,\n                                                localAddress));\n\n        //wait for the packet to arrive\n        collector.waitForResponse();\n\n        Response collectedResponse = collector.collectedResponse;\n\n        byte[] actualReturn = collectedResponse.encode(stunStack);\n        assertArrayEquals(response, actualReturn,\n            \"Received request was not the same as the one that was sent\");\n    }\n\n    /**\n     * Verify StackProperties.FIRST_CTRAN_RETRANS_AFTER can indeed update StunClientTransaction.Retransmitter\n     */\n    @Test\n    public void testRetransmissionOriginalWait()\n        throws Exception\n    {\n        long originalWait = 200; // milliseconds\n        System.setProperty(StackProperties.FIRST_CTRAN_RETRANS_AFTER, String.valueOf(originalWait));\n\n        Request bindingRequest = MessageFactory.createBindingRequest();\n\n        dgramCollector.startListening(dummyServerSocket);\n\n        long firstTime = System.nanoTime();\n\n        stunStack.sendRequest(bindingRequest,\n                dummyServerAddress,\n                localAddress,\n                new SimpleResponseCollector());\n\n        //wait for its arrival\n        dgramCollector.waitForPacket(1000);\n        DatagramPacket receivedPacket = dgramCollector.collectPacket();\n\n        assertTrue((receivedPacket.getLength() > 0),\n            \"The stack did not properly send a Binding Request\");\n\n        Request receivedRequest =\n                (Request)Request.decode(receivedPacket.getData(),\n                        (char)0,\n                        (char)receivedPacket.getLength());\n        assertEquals(bindingRequest, receivedRequest,\n            \"The received request did not match the one that was sent.\");\n\n        // wait for the 1st retransmission with originalWait\n        dgramCollector.startListening(dummyServerSocket);\n        dgramCollector.waitForPacket(1000);\n        receivedPacket = dgramCollector.collectPacket();\n\n        assertTrue((receivedPacket.getLength() > 0),\n            \"The stack did not retransmit a Binding Request\");\n\n        receivedRequest = (Request) Request.decode(\n            receivedPacket.getData(),\n            0,\n            receivedPacket.getLength());\n        assertEquals(bindingRequest, receivedRequest,\n            \"The retransmitted request did not match the original.\");\n\n        // verify the retransmission is longer than the originalWait\n        assertTrue(System.nanoTime() - firstTime >= TimeUnit.MILLISECONDS.toNanos(originalWait));\n\n        System.clearProperty(StackProperties.FIRST_CTRAN_RETRANS_AFTER);\n    }\n\n    //--------------------------------------- listener implementations ---------\n    /**\n     * A simple utility that allows us to asynchronously collect messages.\n     */\n    public static class SimpleResponseCollector\n        extends AbstractResponseCollector\n    {\n\n        /**\n         * The response that we've just collected or <tt>null</tt> if none\n         * arrived while we were waiting.\n         */\n        Response collectedResponse = null;\n\n        /**\n         * Notifies this <tt>ResponseCollector</tt> that a transaction described by\n         * the specified <tt>BaseStunMessageEvent</tt> has failed. The possible\n         * reasons for the failure include timeouts, unreachable destination, etc.\n         *\n         * @param event the <tt>BaseStunMessageEvent</tt> which describes the failed\n         * transaction and the runtime type of which specifies the failure reason\n         * @see AbstractResponseCollector#processFailure(BaseStunMessageEvent)\n         */\n        protected synchronized void processFailure(BaseStunMessageEvent event)\n        {\n            String msg;\n\n            if (event instanceof StunFailureEvent)\n                msg = \"Unreachable\";\n            else if (event instanceof StunTimeoutEvent)\n                msg = \"Timeout\";\n            else\n                msg = \"Failure\";\n            logger.info(msg);\n            notifyAll();\n        }\n\n        /**\n         * Logs the received response and notifies the wait method.\n         *\n         * @param response a <tt>StunMessageEvent</tt> which describes the\n         * received STUN <tt>Response</tt>\n         */\n        public synchronized void processResponse(StunResponseEvent response)\n        {\n            collectedResponse = (Response) response.getMessage();\n            logger.finest(\"Received response.\");\n            notifyAll();\n        }\n\n        /**\n         * Blocks until a request arrives or 50 ms pass.\n         */\n        public synchronized void waitForResponse()\n        {\n            try\n            {\n                if (collectedResponse == null)\n                    wait(50);\n            }\n            catch (InterruptedException e)\n            {\n                logger.log(Level.INFO, \"oops\", e);\n            }\n        }\n    }\n\n    /**\n     * A utility class for asynchronously collecting requests.\n     */\n    public class SimpleRequestCollector\n        implements RequestListener\n    {\n        /**\n         * The one request that this collector has received or <tt>null</tt> if\n         * none arrived while we were waiting.\n         */\n        private Request collectedRequest = null;\n\n        /**\n         * Indicates that a <tt>StunRequest</tt> has just been received.\n         *\n         * @param evt the <tt>StunMessageEvent</tt> containing the details of\n         * the newly received request.\n         */\n        public void processRequest(StunMessageEvent evt)\n        {\n            synchronized(this)\n            {\n                collectedRequest = (Request)evt.getMessage();\n                stunStack.removeRequestListener(this);\n                logger.finest(\"Received request.\");\n                notifyAll();\n            }\n        }\n\n        /**\n         * Blocks until a request arrives or 50 ms pass.\n         */\n        public void waitForRequest()\n        {\n            synchronized(this)\n            {\n                if (collectedRequest != null)\n                    return;\n\n                try\n                {\n                    wait(50);\n                }\n                catch (InterruptedException e)\n                {\n                    logger.log(Level.INFO, \"oops\", e);\n                }\n            }\n        }\n    }\n/*\n    public static Test suite()\n    {\n        TestSuite suite = new TestSuite();\n        suite.addTest(new ShallowStackTest(\n            \"testSendResponse\"));\n        suite.addTest(new ShallowStackTest(\n            \"testSendResponse\"));\n        suite.addTest(new ShallowStackTest(\n            \"testSendResponse\"));\n        suite.addTest(new ShallowStackTest(\n            \"testSendResponse\"));\n        return suite;\n    }\n*/\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Logger logger\n        = Logger.getLogger(ShallowStackTest.class.getName());", "docstring": "\nThe <tt>Logger</tt> used by the <tt>ShallowStackTest<tt> class and its\ninstances for logging output.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Logger", "name": "logger\n        = Logger.getLogger(ShallowStackTest.class.getName())", "syntax_pass": true}, {"attribute_expression": "private StunStack    stunStack;", "docstring": "\nThe <tt>StunStack</tt> used by this <tt>ShallowStackTest</tt>\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "StunStack", "name": "stunStack", "syntax_pass": true}, {"attribute_expression": "private MsgFixture   msgFixture = null;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "MsgFixture", "name": "msgFixture = null", "syntax_pass": true}, {"attribute_expression": "private TransportAddress dummyServerAddress = null;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "TransportAddress", "name": "dummyServerAddress = null", "syntax_pass": true}, {"attribute_expression": "private TransportAddress localAddress = null;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "TransportAddress", "name": "localAddress = null", "syntax_pass": true}, {"attribute_expression": "private final DatagramCollector dgramCollector = new DatagramCollector();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "DatagramCollector", "name": "dgramCollector = new DatagramCollector()", "syntax_pass": true}, {"attribute_expression": "private IceSocketWrapper   localSock = null;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "IceSocketWrapper", "name": "localSock = null", "syntax_pass": true}, {"attribute_expression": "private DatagramSocket dummyServerSocket = null;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "DatagramSocket", "name": "dummyServerSocket = null", "syntax_pass": true}]}, {"uris": "src/test/java/org/ice4j/attribute/ErrorCodeAttribute_getNameTest.java.ErrorCodeAttribute_getNameTest", "name": "ErrorCodeAttribute_getNameTest", "file_path": "src/test/java/org/ice4j/attribute/ErrorCodeAttribute_getNameTest.java", "superclasses": "", "methods": ["[void]testGetName()", "[void]testGetNameWithSetErrorCode()", "[void]testGetNameWithSetReasonPhrase()", "[void]testGetNameWithSetErrorCodeAndReasonPhrase()"], "method_uris": ["src/test/java/org/ice4j/attribute/ErrorCodeAttribute_getNameTest.java.ErrorCodeAttribute_getNameTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class ErrorCodeAttribute_getNameTest {\n    private ErrorCodeAttribute errorCodeAttribute;\n\n    @BeforeEach\n    public void setUp() {\n        errorCodeAttribute = new ErrorCodeAttribute();\n    }\n\n    @Test\n    public void testGetName() {\n        assertEquals(\"ERROR-CODE\", errorCodeAttribute.getName());\n    }\n\n    @Test\n    public void testGetNameWithSetErrorCode() {\n        char errorCode = (char)(4 * 100 + 1); // Example error code\n        errorCodeAttribute.setErrorCode(errorCode);\n        assertEquals(\"ERROR-CODE\", errorCodeAttribute.getName());\n    }\n\n    @Test\n    public void testGetNameWithSetReasonPhrase() {\n        errorCodeAttribute.setReasonPhrase(\"Test Reason Phrase\");\n        assertEquals(\"ERROR-CODE\", errorCodeAttribute.getName());\n    }\n\n    @Test\n    public void testGetNameWithSetErrorCodeAndReasonPhrase() {\n        char errorCode = (char)(4 * 100 + 1); // Example error code\n        errorCodeAttribute.setErrorCode(errorCode);\n        errorCodeAttribute.setReasonPhrase(\"Test Reason Phrase\");\n        assertEquals(\"ERROR-CODE\", errorCodeAttribute.getName());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private ErrorCodeAttribute errorCodeAttribute;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ErrorCodeAttribute", "name": "errorCodeAttribute", "syntax_pass": true}]}, {"uris": "src/test/java/org/ice4j/attribute/RequestedAddressFamilyAttribute_getNameTest.java.RequestedAddressFamilyAttribute_getNameTest", "name": "RequestedAddressFamilyAttribute_getNameTest", "file_path": "src/test/java/org/ice4j/attribute/RequestedAddressFamilyAttribute_getNameTest.java", "superclasses": "", "methods": ["[void]testGetName()"], "method_uris": ["src/test/java/org/ice4j/attribute/RequestedAddressFamilyAttribute_getNameTest.java.RequestedAddressFamilyAttribute_getNameTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class RequestedAddressFamilyAttribute_getNameTest {\n    private RequestedAddressFamilyAttribute requestedAddressFamilyAttribute;\n\n    @BeforeEach\n    public void setUp() throws Exception {\n        this.requestedAddressFamilyAttribute = new RequestedAddressFamilyAttribute();\n    }\n\n    @Test\n    public void testGetName() {\n        assertEquals(\"REQUESTED-ADDRESS-FAMILY\", requestedAddressFamilyAttribute.getName());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private RequestedAddressFamilyAttribute requestedAddressFamilyAttribute;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "RequestedAddressFamilyAttribute", "name": "requestedAddressFamilyAttribute", "syntax_pass": true}]}, {"uris": "src/test/java/org/ice4j/attribute/SoftwareAttributeTest.java.SoftwareAttributeTest", "name": "SoftwareAttributeTest", "file_path": "src/test/java/org/ice4j/attribute/SoftwareAttributeTest.java", "superclasses": "", "methods": ["[void]testDecodeAttributeBody()", "[void]testEncode()", "[void]testEquals()", "[void]testGetDataLength()", "[void]testGetName()", "[void]testSetGetSoftware()"], "method_uris": ["src/test/java/org/ice4j/attribute/SoftwareAttributeTest.java.SoftwareAttributeTest.[void]setUp()", "src/test/java/org/ice4j/attribute/SoftwareAttributeTest.java.SoftwareAttributeTest.[void]tearDown()"], "overrides": null, "attributes": [], "class_docstring": "\nTests the software attribute class.\n\n@author Emil Ivov\n", "original_string": "public class SoftwareAttributeTest\n{\n    private SoftwareAttribute softwareAttribute = null;\n    MsgFixture msgFixture = null;\n    String softwareValue = \"turnserver.org\";\n    byte[] attributeBinValue = new byte[]{\n            (byte)(SoftwareAttribute.SOFTWARE>>8),\n            (byte)(SoftwareAttribute.SOFTWARE & 0x00FF),\n            0, (byte)softwareValue.length(),\n            't', 'u', 'r', 'n', 's', 'e', 'r','v', 'e', 'r', '.', 'o', 'r', 'g',\n            0x00, 0x00};\n\n    @BeforeEach\n    public void setUp() throws Exception\n    {\n        msgFixture = new MsgFixture();\n\n        softwareAttribute = new SoftwareAttribute();\n        softwareAttribute.setSoftware(softwareValue.getBytes());\n    }\n\n    @AfterEach\n    public void tearDown() throws Exception\n    {\n        softwareAttribute = null;\n        msgFixture = null;\n    }\n\n    /**\n     * Tests decoding of the software attribute.\n     * @throws StunException upon a failure\n     */\n    @Test\n    public void testDecodeAttributeBody() throws StunException\n    {\n        char offset = 0;\n        SoftwareAttribute decoded = new SoftwareAttribute();\n        char length = (char)softwareValue.length();\n        decoded.decodeAttributeBody(softwareValue.getBytes(), offset, length);\n\n        //software value\n        assertEquals(softwareAttribute, decoded);\n    }\n\n    /**\n     * Tests the encode method\n     */\n    @Test\n    public void testEncode()\n    {\n        assertArrayEquals(softwareAttribute.encode(), attributeBinValue);\n    }\n\n    /**\n     * Test Equals\n     */\n    @Test\n    public void testEquals()\n    {\n        SoftwareAttribute softwareAttribute2 = new SoftwareAttribute();\n        softwareAttribute2.setSoftware(softwareValue.getBytes());\n\n        //test positive equals\n        assertEquals(softwareAttribute, softwareAttribute2);\n\n        //test negative equals\n        softwareAttribute2 = new SoftwareAttribute();\n        softwareAttribute2.setSoftware(\"some other software\".getBytes());\n\n        //test positive equals\n        assertNotEquals(softwareAttribute2, softwareAttribute);\n\n        //test null equals\n        assertNotEquals(softwareAttribute, null);\n    }\n\n    /**\n     * Tests extracting data length\n     */\n    @Test\n    public void testGetDataLength()\n    {\n        char expectedReturn = (char)softwareValue.length();\n        char actualReturn = softwareAttribute.getDataLength();\n        assertEquals(expectedReturn, actualReturn);\n    }\n\n    /**\n     * Tests getting the name\n     */\n    @Test\n    public void testGetName()\n    {\n        assertEquals(\"SOFTWARE\", softwareAttribute.getName());\n    }\n\n    @Test\n    public void testSetGetSoftware()\n    {\n        byte[] expectedReturn = softwareValue.getBytes();\n\n        SoftwareAttribute att = new SoftwareAttribute();\n        att.setSoftware(expectedReturn);\n\n        byte[] actualReturn = att.getSoftware();\n        assertArrayEquals(expectedReturn, actualReturn,\n            \"software setter or getter failed\");\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private SoftwareAttribute softwareAttribute = null;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "SoftwareAttribute", "name": "softwareAttribute = null", "syntax_pass": true}, {"attribute_expression": "MsgFixture msgFixture = null;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "MsgFixture", "name": "msgFixture = null", "syntax_pass": true}, {"attribute_expression": "String softwareValue = \"turnserver.org\";", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "String", "name": "softwareValue = \"turnserver.org\"", "syntax_pass": true}, {"attribute_expression": "byte[] attributeBinValue = new byte[]{\n            (byte)(SoftwareAttribute.SOFTWARE>>8),\n            (byte)(SoftwareAttribute.SOFTWARE & 0x00FF),\n            0, (byte)softwareValue.length(),\n            't', 'u', 'r', 'n', 's', 'e', 'r','v', 'e', 'r', '.', 'o', 'r', 'g',\n            0x00, 0x00};", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "byte[]", "name": "attributeBinValue = new byte[]{\n            (byte)(SoftwareAttribute.SOFTWARE>>8),\n            (byte)(SoftwareAttribute.SOFTWARE & 0x00FF),\n            0, (byte)softwareValue.length(),\n            't', 'u', 'r', 'n', 's', 'e', 'r','v', 'e', 'r', '.', 'o', 'r', 'g',\n            0x00, 0x00}", "syntax_pass": true}]}, {"uris": "src/test/java/org/ice4j/attribute/RealmAttributeTest.java.RealmAttributeTest", "name": "RealmAttributeTest", "file_path": "src/test/java/org/ice4j/attribute/RealmAttributeTest.java", "superclasses": "", "methods": ["[void]testDecodeAttributeBody()", "[void]testEncode()", "[void]testEquals()", "[void]testGetDataLength()", "[void]testGetName()", "[void]testSetGetRealm()"], "method_uris": ["src/test/java/org/ice4j/attribute/RealmAttributeTest.java.RealmAttributeTest.[void]setUp()", "src/test/java/org/ice4j/attribute/RealmAttributeTest.java.RealmAttributeTest.[void]tearDown()"], "overrides": null, "attributes": [], "class_docstring": "\nTests the realm attribute class.\n\n@author Emil Ivov\n@author Sebastien Vincent\n", "original_string": "public class RealmAttributeTest\n{\n    private RealmAttribute realmAttribute = null;\n    MsgFixture msgFixture = null;\n    String realmValue = \"domain.org\";\n    byte[] attributeBinValue = new byte[]{\n            (byte)(RealmAttribute.REALM>>8),\n            (byte)(RealmAttribute.REALM & 0x00FF),\n            0, (byte)realmValue.length(),\n            'd', 'o', 'm', 'a', 'i', 'n', '.', 'o', 'r', 'g', 0x00, 0x00};\n\n    @BeforeEach\n    public void setUp() throws Exception\n    {\n        msgFixture = new MsgFixture();\n\n        realmAttribute = new RealmAttribute();\n        realmAttribute.setRealm(realmValue.getBytes());\n    }\n\n    @AfterEach\n    public void tearDown() throws Exception\n    {\n        realmAttribute = null;\n        msgFixture = null;\n    }\n\n    /**\n     * Tests decoding of the realm attribute.\n     * @throws StunException upon a failure\n     */\n    @Test\n    public void testDecodeAttributeBody() throws StunException\n    {\n        char offset = 0;\n        RealmAttribute decoded = new RealmAttribute();\n        char length = (char)realmValue.length();\n        decoded.decodeAttributeBody(realmValue.getBytes(), offset, length);\n\n        //realm value\n        assertEquals(realmAttribute, decoded);\n    }\n\n    /**\n     * Tests the encode method\n     */\n    @Test\n    public void testEncode()\n    {\n        assertArrayEquals(realmAttribute.encode(), attributeBinValue);\n    }\n\n    /**\n     * Test Equals\n     */\n    @Test\n    public void testEquals()\n    {\n        RealmAttribute realmAttribute2 = new RealmAttribute();\n        realmAttribute2.setRealm(realmValue.getBytes());\n\n        //test positive equals\n        assertEquals(realmAttribute, realmAttribute2);\n\n        //test negative equals\n        realmAttribute2 = new RealmAttribute();\n        realmAttribute2.setRealm(\"some other realm\".getBytes());\n\n        //test positive equals\n        assertNotEquals(realmAttribute2, realmAttribute);\n\n        //test null equals\n        assertNotEquals(realmAttribute, null);\n    }\n\n    /**\n     * Tests extracting data length\n     */\n    @Test\n    public void testGetDataLength()\n    {\n        char expectedReturn = (char)realmValue.length();\n        char actualReturn = realmAttribute.getDataLength();\n        assertEquals(expectedReturn, actualReturn);\n    }\n\n    /**\n     * Tests getting the name\n     */\n    @Test\n    public void testGetName()\n    {\n        assertEquals(\"REALM\", realmAttribute.getName());\n    }\n\n    @Test\n    public void testSetGetRealm()\n    {\n        byte[] expectedReturn = realmValue.getBytes();\n\n        RealmAttribute att = new RealmAttribute();\n        att.setRealm(expectedReturn);\n\n        byte[] actualReturn = att.getRealm();\n        assertArrayEquals(expectedReturn, actualReturn,\n            \"realm setter or getter failed\");\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private RealmAttribute realmAttribute = null;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "RealmAttribute", "name": "realmAttribute = null", "syntax_pass": true}, {"attribute_expression": "MsgFixture msgFixture = null;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "MsgFixture", "name": "msgFixture = null", "syntax_pass": true}, {"attribute_expression": "String realmValue = \"domain.org\";", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "String", "name": "realmValue = \"domain.org\"", "syntax_pass": true}, {"attribute_expression": "byte[] attributeBinValue = new byte[]{\n            (byte)(RealmAttribute.REALM>>8),\n            (byte)(RealmAttribute.REALM & 0x00FF),\n            0, (byte)realmValue.length(),\n            'd', 'o', 'm', 'a', 'i', 'n', '.', 'o', 'r', 'g', 0x00, 0x00};", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "byte[]", "name": "attributeBinValue = new byte[]{\n            (byte)(RealmAttribute.REALM>>8),\n            (byte)(RealmAttribute.REALM & 0x00FF),\n            0, (byte)realmValue.length(),\n            'd', 'o', 'm', 'a', 'i', 'n', '.', 'o', 'r', 'g', 0x00, 0x00}", "syntax_pass": true}]}, {"uris": "src/test/java/org/ice4j/attribute/ConnectionIdAttribute_getNameTest.java.ConnectionIdAttribute_getNameTest", "name": "ConnectionIdAttribute_getNameTest", "file_path": "src/test/java/org/ice4j/attribute/ConnectionIdAttribute_getNameTest.java", "superclasses": "", "methods": ["[void]testGetName()"], "method_uris": ["src/test/java/org/ice4j/attribute/ConnectionIdAttribute_getNameTest.java.ConnectionIdAttribute_getNameTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class ConnectionIdAttribute_getNameTest {\n    private ConnectionIdAttribute connectionIdAttribute;\n\n    @BeforeEach\n    public void setUp() {\n        connectionIdAttribute = new ConnectionIdAttribute();\n    }\n\n    @Test\n    public void testGetName() {\n        assertEquals(\"CONNECTION-ID\", connectionIdAttribute.getName());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private ConnectionIdAttribute connectionIdAttribute;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ConnectionIdAttribute", "name": "connectionIdAttribute", "syntax_pass": true}]}, {"uris": "src/test/java/org/ice4j/attribute/UnknownAttributesAttribute_addAttributeIDTest.java.UnknownAttributesAttribute_addAttributeIDTest", "name": "UnknownAttributesAttribute_addAttributeIDTest", "file_path": "src/test/java/org/ice4j/attribute/UnknownAttributesAttribute_addAttributeIDTest.java", "superclasses": "", "methods": ["[void]testAddAttributeID_NewAttribute()", "[void]testAddAttributeID_DuplicateAttribute()", "[void]testAddAttributeID_MultipleAttributes()"], "method_uris": ["src/test/java/org/ice4j/attribute/UnknownAttributesAttribute_addAttributeIDTest.java.UnknownAttributesAttribute_addAttributeIDTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class UnknownAttributesAttribute_addAttributeIDTest {\n    private UnknownAttributesAttribute unknownAttributesAttribute;\n\n    @BeforeEach\n    public void setUp() {\n        unknownAttributesAttribute = new UnknownAttributesAttribute();\n    }\n\n    @Test\n    public void testAddAttributeID_NewAttribute() {\n        char attributeID = 'A';\n        unknownAttributesAttribute.addAttributeID(attributeID);\n        assertTrue(unknownAttributesAttribute.contains(attributeID), \"Attribute ID should be added\");\n        assertEquals(1, unknownAttributesAttribute.getAttributeCount(), \"Attribute count should be 1\");\n    }\n\n    @Test\n    public void testAddAttributeID_DuplicateAttribute() {\n        char attributeID = 'B';\n        unknownAttributesAttribute.addAttributeID(attributeID);\n        unknownAttributesAttribute.addAttributeID(attributeID); // Duplicate\n        assertTrue(unknownAttributesAttribute.contains(attributeID), \"Attribute ID should be added\");\n        assertEquals(1, unknownAttributesAttribute.getAttributeCount(), \"Attribute count should still be 1\");\n    }\n\n    @Test\n    public void testAddAttributeID_MultipleAttributes() {\n        char attributeID1 = 'C';\n        char attributeID2 = 'D';\n        unknownAttributesAttribute.addAttributeID(attributeID1);\n        unknownAttributesAttribute.addAttributeID(attributeID2);\n        assertTrue(unknownAttributesAttribute.contains(attributeID1), \"Attribute ID1 should be added\");\n        assertTrue(unknownAttributesAttribute.contains(attributeID2), \"Attribute ID2 should be added\");\n        assertEquals(2, unknownAttributesAttribute.getAttributeCount(), \"Attribute count should be 2\");\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private UnknownAttributesAttribute unknownAttributesAttribute;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "UnknownAttributesAttribute", "name": "unknownAttributesAttribute", "syntax_pass": true}]}, {"uris": "src/test/java/org/ice4j/attribute/RequestedAddressFamilyAttribute_getDataLengthTest.java.RequestedAddressFamilyAttribute_getDataLengthTest", "name": "RequestedAddressFamilyAttribute_getDataLengthTest", "file_path": "src/test/java/org/ice4j/attribute/RequestedAddressFamilyAttribute_getDataLengthTest.java", "superclasses": "", "methods": ["[void]testGetDataLength()", "[void]testEqualsWithSameDataLength()", "[void]testEqualsWithDifferentDataLength()", "[void]testEncodeDataLength()", "[void]testDecodeAttributeBodyV6()"], "method_uris": ["src/test/java/org/ice4j/attribute/RequestedAddressFamilyAttribute_getDataLengthTest.java.RequestedAddressFamilyAttribute_getDataLengthTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class RequestedAddressFamilyAttribute_getDataLengthTest {\n    private RequestedAddressFamilyAttribute requestedAddressFamilyAttribute;\n    private MsgFixture msgFixture;\n\n    @BeforeEach\n    public void setUp() throws Exception {\n        this.requestedAddressFamilyAttribute = new RequestedAddressFamilyAttribute();\n        this.msgFixture = new MsgFixture();\n    }\n\n    @Test\n    public void testGetDataLength() {\n        assertEquals(RequestedAddressFamilyAttribute.DATA_LENGTH, requestedAddressFamilyAttribute.getDataLength(), \"Data length should be 1.\");\n    }\n\n    @Test\n    public void testEqualsWithSameDataLength() {\n        RequestedAddressFamilyAttribute other = new RequestedAddressFamilyAttribute();\n        assertTrue(requestedAddressFamilyAttribute.equals(other), \"Attributes with the same data length should be equal.\");\n    }\n\n    @Test\n    public void testEqualsWithDifferentDataLength() {\n        RequestedAddressFamilyAttribute other = new RequestedAddressFamilyAttribute() {\n            @Override\n            public char getDataLength() {\n                return 2;\n            }\n        };\n        assertFalse(requestedAddressFamilyAttribute.equals(other), \"Attributes with different data lengths should not be equal.\");\n    }\n\n    @Test\n    public void testEncodeDataLength() {\n        byte[] encoded = requestedAddressFamilyAttribute.encode();\n        assertEquals(RequestedAddressFamilyAttribute.DATA_LENGTH, (char) (encoded[2] << 8 | encoded[3]), \"Encoded data length should match DATA_LENGTH.\");\n    }\n\n    @Test\n    public void testDecodeAttributeBodyV6() throws StunException {\n        byte[] attributeValue = msgFixture.requestedAddressFamilyV6;\n        char offset = Attribute.HEADER_LENGTH;\n        char length = (char) (attributeValue.length - offset);\n\n        requestedAddressFamilyAttribute.decodeAttributeBody(attributeValue, offset, length);\n\n        assertEquals(MsgFixture.REQUESTED_ADDRESS_FAMILY_ATTRIBUTE_V6, requestedAddressFamilyAttribute.getFamily(), \"RequestedAddressFamilyAttribute.decode() did not properly decode.\");\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private RequestedAddressFamilyAttribute requestedAddressFamilyAttribute;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "RequestedAddressFamilyAttribute", "name": "requestedAddressFamilyAttribute", "syntax_pass": true}, {"attribute_expression": "private MsgFixture msgFixture;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "MsgFixture", "name": "msgFixture", "syntax_pass": true}]}, {"uris": "src/test/java/org/ice4j/attribute/UnknownAttributesAttributeTest.java.UnknownAttributesAttributeTest", "name": "UnknownAttributesAttributeTest", "file_path": "src/test/java/org/ice4j/attribute/UnknownAttributesAttributeTest.java", "superclasses": "", "methods": ["[void]testUnknownAttributesAttribute()", "[void]testAddAttributeID()", "[void]testDecodeAttributeBody()", "[void]testEncode()", "[void]testEquals()", "[void]testGetAttribute()", "[void]testGetAttributeCount()", "[void]testGetAttributes()", "[void]testGetDataLength()", "[void]testGetName()"], "method_uris": ["src/test/java/org/ice4j/attribute/UnknownAttributesAttributeTest.java.UnknownAttributesAttributeTest.[void]setUp()", "src/test/java/org/ice4j/attribute/UnknownAttributesAttributeTest.java.UnknownAttributesAttributeTest.[void]tearDown()"], "overrides": null, "attributes": [], "class_docstring": "\nTests the UNKNOWN attribute class.\n\n@author Emil Ivov\n", "original_string": "public class UnknownAttributesAttributeTest\n{\n    private UnknownAttributesAttribute unknownAttributesAttribute = null;\n    private MsgFixture binMessagesFixture;\n\n    @BeforeEach\n    public void setUp() throws Exception\n    {\n        unknownAttributesAttribute = new UnknownAttributesAttribute();\n        binMessagesFixture = new MsgFixture();\n    }\n\n    @AfterEach\n    public void tearDown() throws Exception\n    {\n        unknownAttributesAttribute = null;\n        binMessagesFixture = null;\n    }\n//-------------------------------- TESTS ---------------------------------------\n    /**\n     * Verify the the constructed object has the correct (UNKNOWN-ATTRIBUTES)\n     * type.\n     */\n    @Test\n    public void testUnknownAttributesAttribute()\n    {\n        unknownAttributesAttribute = new UnknownAttributesAttribute();\n        assertEquals(\n            Attribute.UNKNOWN_ATTRIBUTES,\n            (int) unknownAttributesAttribute.getAttributeType(),\n            \"UnknownAttributesAttribute() did not properly set the Attribute's type field!\"\n        );\n    }\n\n    /**\n     * Verify that the passed attribute id is added to the list of attributes\n     * and that a second addition of the same id would not augment the attribute\n     * count.\n     */\n    @Test\n    public void testAddAttributeID()\n    {\n        char attributeID = 0x22; // unknown attribute id\n\n        unknownAttributesAttribute.addAttributeID(attributeID);\n\n        assertEquals(\n            (int) attributeID,\n            (int) unknownAttributesAttribute.getAttribute(0),\n            \"addAttributeID does not seem to properly add the attribute ID\"\n        );\n\n        assertEquals(\n            1,\n            unknownAttributesAttribute.getAttributeCount(),\n            \"addAttributeID does not seem to properly add the attribute ID\"\n        );\n\n        //add a second one\n        unknownAttributesAttribute.addAttributeID(attributeID);\n\n        assertEquals(\n            1,\n            unknownAttributesAttribute.getAttributeCount(),\n            \"Adding a 2nd time the same attributeID should not change the number of attributes\"\n        );\n    }\n\n    /**\n     * Tests whether a sample binary array is properly decoded.\n     * @throws StunException if anything goes wrong.\n     */\n    @Test\n    public void testDecodeAttributeBody() throws StunException\n    {\n        //a copy of the array in the fixture:\n        byte[] attributeValue = binMessagesFixture.unknownAttsDecodeTestValue;\n\n        unknownAttributesAttribute.decodeAttributeBody(attributeValue,\n                                               Attribute.HEADER_LENGTH,\n                                               (char)(attributeValue.length\n                                               - Attribute.HEADER_LENGTH));\n        //is every one there?\n        assertTrue(\n            unknownAttributesAttribute.contains(\n                MsgFixture.UNKNOWN_ATTRIBUTES_1ST_ATT),\n            \"The \" + (int) MsgFixture.UNKNOWN_ATTRIBUTES_1ST_ATT\n                + \" attribute id \"\n                + \"was not found after decoding a binary array that contained it.\"\n        );\n\n        assertTrue(\n            unknownAttributesAttribute.contains(\n                MsgFixture.UNKNOWN_ATTRIBUTES_2ND_ATT),\n            \"The \" + (int) MsgFixture.UNKNOWN_ATTRIBUTES_2ND_ATT\n                + \" attribute id \"\n                + \"was not found after decoding a binary array that contained it.\"\n        );\n        assertTrue(\n            unknownAttributesAttribute.contains(\n                MsgFixture.UNKNOWN_ATTRIBUTES_3D_ATT),\n            \"The \" + (int) MsgFixture.UNKNOWN_ATTRIBUTES_3D_ATT\n                + \" attribute id \"\n                + \"was not found after decoding a binary array that contained it.\"\n            );\n\n        assertEquals(\n            MsgFixture.UNKNOWN_ATTRIBUTES_CNT_DEC_TST,\n            unknownAttributesAttribute.getAttributeCount(),\n            \"The decoded attribute contained \"\n                + unknownAttributesAttribute.getAttributeCount()\n                + \" attribute ids when there were only \"\n                + (int) MsgFixture.UNKNOWN_ATTRIBUTES_CNT_DEC_TST\n                + \" in the original binary array.\"\n        );\n    }\n\n    /**\n     * Creates a new UnknownAttributesAttribute encodes it and assert equality\n     * with binMessagesFixture.unknownAttsEncodeExpectedResult.\n     */\n    @Test\n    public void testEncode()\n    {\n        byte[] expectedReturn = binMessagesFixture.unknownAttsEncodeExpectedResult;\n\n        unknownAttributesAttribute.addAttributeID(\n            MsgFixture.UNKNOWN_ATTRIBUTES_1ST_ATT);\n        unknownAttributesAttribute.addAttributeID(\n            MsgFixture.UNKNOWN_ATTRIBUTES_2ND_ATT);\n\n        byte[] actualReturn = unknownAttributesAttribute.encode();\n        assertArrayEquals(actualReturn, expectedReturn);\n    }\n\n    /**\n     * Tests the equals method against a null, a different and an identical\n     * object.\n     */\n    @Test\n    public void testEquals()\n    {\n        UnknownAttributesAttribute target = new UnknownAttributesAttribute();\n\n        assertNotEquals(unknownAttributesAttribute, null);\n\n        unknownAttributesAttribute.addAttributeID((char)25);\n        target.addAttributeID((char)25);\n\n        unknownAttributesAttribute.addAttributeID((char)26);\n        assertNotEquals(unknownAttributesAttribute, target);\n\n        target.addAttributeID((char)26);\n        assertEquals(unknownAttributesAttribute, target);\n    }\n\n    /**\n     * Tests that getAttribute() return the correct attribute id, preserving\n     * entry order.\n     */\n    @Test\n    public void testGetAttribute()\n    {\n        char expectedId1 = 20;\n        char expectedId2 = 21;\n\n        char actualId1;\n        char actualId2;\n\n        unknownAttributesAttribute.addAttributeID(expectedId1);\n        unknownAttributesAttribute.addAttributeID(expectedId2);\n\n        actualId1 = unknownAttributesAttribute.getAttribute(0);\n        actualId2 = unknownAttributesAttribute.getAttribute(1);\n\n        assertEquals(expectedId1, actualId1, \"getAttribute() return value mismatch\");\n        assertEquals(expectedId2, actualId2, \"getAttribute() return value mismatch\");\n    }\n\n    /**\n     * Add some attributes and test whether their number is properly calculated.\n     * Tests duplicate id handling as well.\n     */\n    @Test\n    public void testGetAttributeCount()\n    {\n        int expectedReturn = 5;\n\n        unknownAttributesAttribute.addAttributeID((char)21);\n        unknownAttributesAttribute.addAttributeID((char)22);\n        unknownAttributesAttribute.addAttributeID((char)23);\n        unknownAttributesAttribute.addAttributeID((char)24);\n        unknownAttributesAttribute.addAttributeID((char)25);\n        unknownAttributesAttribute.addAttributeID((char)25);//duplicate values should be ignored\n\n        int actualReturn = unknownAttributesAttribute.getAttributeCount();\n        assertEquals(expectedReturn, actualReturn,\n            \"getAttributeCount did not return the expected value\");\n    }\n\n    /**\n     * Same as testGetAttributeID, only attribute attributes are extracted\n     * through the getAttributes()'s iterator.\n     */\n    @Test\n    public void testGetAttributes()\n    {\n        char expectedId1 = 20;\n        char expectedId2 = 21;\n\n        char actualId1;\n        char actualId2;\n\n        unknownAttributesAttribute.addAttributeID(expectedId1);\n        unknownAttributesAttribute.addAttributeID(expectedId2);\n\n        Iterator<Character> iterator = unknownAttributesAttribute.getAttributes();\n\n        actualId1 = iterator.next();\n        actualId2 = iterator.next();\n\n        assertEquals(expectedId1, actualId1, \"getAttributes() return value mismatch\");\n        assertEquals(expectedId2, actualId2, \"getAttributes() return value mismatch\");\n    }\n\n    /**\n     * Adds a fixed number of attributes and checks data length accordingly.\n     * Test is first performed for an odd number of attributes and then again\n     * (after adding another attribute id). Both results should be the same.\n     */\n    @Test\n    public void testGetDataLength()\n    {\n        char expectedReturn = 8;\n\n        unknownAttributesAttribute.addAttributeID((char)20);\n        unknownAttributesAttribute.addAttributeID((char)21);\n        unknownAttributesAttribute.addAttributeID((char)22);\n\n        char actualReturn = unknownAttributesAttribute.getDataLength();\n        assertEquals(expectedReturn, actualReturn,\n            \"Incorrect testGetDataLength() return value\");\n\n        unknownAttributesAttribute.addAttributeID((char)23);\n\n        actualReturn = unknownAttributesAttribute.getDataLength();\n        assertEquals(expectedReturn, actualReturn,\n            \"Incorrect testGetDataLength() return value\");\n\n    }\n\n    /**\n     * Tests whether getName returns a relevant name.\n     */\n    @Test\n    public void testGetName()\n    {\n        assertEquals(\"UNKNOWN-ATTRIBUTES\", unknownAttributesAttribute.getName());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private UnknownAttributesAttribute unknownAttributesAttribute = null;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "UnknownAttributesAttribute", "name": "unknownAttributesAttribute = null", "syntax_pass": true}, {"attribute_expression": "private MsgFixture binMessagesFixture;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "MsgFixture", "name": "binMessagesFixture", "syntax_pass": true}]}, {"uris": "src/test/java/org/ice4j/attribute/RequestedAddressFamilyAttributeTest.java.RequestedAddressFamilyAttributeTest", "name": "RequestedAddressFamilyAttributeTest", "file_path": "src/test/java/org/ice4j/attribute/RequestedAddressFamilyAttributeTest.java", "superclasses": "", "methods": ["[void]testGetDataLength()", "[void]testGetName()", "[void]testEqualsObject()", "[void]testDecodeAttributeBodyV4()", "[void]testDecodeAttributeBodyV6()", "[void]testEncodeV4()", "[void]testEncodeV6()", "[void]testGetFamily()"], "method_uris": ["src/test/java/org/ice4j/attribute/RequestedAddressFamilyAttributeTest.java.RequestedAddressFamilyAttributeTest.[void]setUp()", "src/test/java/org/ice4j/attribute/RequestedAddressFamilyAttributeTest.java.RequestedAddressFamilyAttributeTest.[void]tearDown()"], "overrides": null, "attributes": [], "class_docstring": "\nClass to test the RequestedAddressFamilyAttribute class.\n\n@author Aakash Garg\n\n", "original_string": "public class RequestedAddressFamilyAttributeTest\n{\n    private RequestedAddressFamilyAttribute requestedAddressFamilyAttribute =\n        null;\n\n    private MsgFixture msgFixture;\n\n    @BeforeEach\n    public void setUp() throws Exception\n    {\n        this.requestedAddressFamilyAttribute =\n            new RequestedAddressFamilyAttribute();\n        this.msgFixture = new MsgFixture();\n    }\n\n    @AfterEach\n    public void tearDown() throws Exception\n    {\n        this.requestedAddressFamilyAttribute = null;\n        this.msgFixture = null;\n    }\n\n    /**\n     * Tests whether data length is properly calculated.\n     */\n    @Test\n    public void testGetDataLength()\n    {\n        char expectedReturn = 1;\n        this.requestedAddressFamilyAttribute\n            .setFamily(MsgFixture.REQUESTED_ADDRESS_FAMILY_ATTRIBUTE_V4);\n        char actualReturn =\n            this.requestedAddressFamilyAttribute.getDataLength();\n        assertEquals(expectedReturn, actualReturn,\n            \"Datalength is not properly calculated\");\n\n        expectedReturn = 1;\n        this.requestedAddressFamilyAttribute\n            .setFamily(MsgFixture.REQUESTED_ADDRESS_FAMILY_ATTRIBUTE_V6);\n        actualReturn = this.requestedAddressFamilyAttribute.getDataLength();\n        assertEquals(expectedReturn, actualReturn,\n            \"Datalength is not properly calculated\");\n\n    }\n\n    /**\n     * Tests getting the name.\n     */\n    @Test\n    public void testGetName()\n    {\n        assertEquals(\"REQUESTED-ADDRESS-FAMILY\", requestedAddressFamilyAttribute.getName());\n    }\n\n    /**\n     * Tests the equals method against a null, a different and an identical\n     * object.\n     */\n    @Test\n    public void testEqualsObject()\n    {\n        // null test\n        assertNotEquals(requestedAddressFamilyAttribute, null);\n\n        // difference test\n        RequestedAddressFamilyAttribute target;\n        target = new RequestedAddressFamilyAttribute();\n\n        char family = MsgFixture.REQUESTED_ADDRESS_FAMILY_ATTRIBUTE_V6;\n        target.setFamily(family);\n\n        requestedAddressFamilyAttribute\n            .setFamily(MsgFixture.REQUESTED_ADDRESS_FAMILY_ATTRIBUTE_V4);\n\n        assertNotEquals(requestedAddressFamilyAttribute, target);\n\n        // equality test\n        target.setFamily(MsgFixture.REQUESTED_ADDRESS_FAMILY_ATTRIBUTE_V4);\n\n        assertEquals(requestedAddressFamilyAttribute, target);\n\n        // ipv6 equality test\n        target.setFamily(MsgFixture.REQUESTED_ADDRESS_FAMILY_ATTRIBUTE_V6);\n\n        requestedAddressFamilyAttribute\n            .setFamily(MsgFixture.REQUESTED_ADDRESS_FAMILY_ATTRIBUTE_V6);\n\n        assertEquals(requestedAddressFamilyAttribute, target);\n    }\n\n    /**\n     * Test whether sample binary arrays are correctly decoded.\n     * \n     * @throws StunException if something goes wrong while decoding \n     *             Attribute Body.\n     */\n    @Test\n    public void testDecodeAttributeBodyV4() throws StunException\n    {\n        byte[] attributeValue = msgFixture.requestedAddressFamilyV4;\n        char offset = Attribute.HEADER_LENGTH;\n        char length = (char) (attributeValue.length - offset);\n\n        requestedAddressFamilyAttribute.decodeAttributeBody(\n            attributeValue, offset, length);\n\n        assertEquals(\n            MsgFixture.REQUESTED_ADDRESS_FAMILY_ATTRIBUTE_V4,\n            requestedAddressFamilyAttribute.getFamily(),\n            \"RequestedAddressFamilyAttribute.decode() did not properly decode the family field.\"\n        );\n    }\n\n    /**\n     * Test whether sample binary arrays are correctly decoded.\n     * \n     * @throws StunException if something goes wrong while decoding \n     *             Attribute Body.\n     */\n    @Test\n    public void testDecodeAttributeBodyV6() throws StunException\n    {\n        byte[] attributeValue = msgFixture.requestedAddressFamilyV6;\n        char offset = Attribute.HEADER_LENGTH;\n        char length = (char) (attributeValue.length - offset);\n\n        requestedAddressFamilyAttribute.decodeAttributeBody(\n            attributeValue, offset, length);\n\n        assertEquals(\n            MsgFixture.REQUESTED_ADDRESS_FAMILY_ATTRIBUTE_V6,\n            requestedAddressFamilyAttribute.getFamily(),\n            \"RequestedAddressFamilyAttribute.decode() did not properly decode.\"\n        );\n    }\n\n    /**\n     * Test whether attributes are properly encoded.\n     */\n    @Test\n    public void testEncodeV4()\n    {\n        byte[] expectedReturn = msgFixture.requestedAddressFamilyV4;\n        requestedAddressFamilyAttribute\n            .setFamily(MsgFixture.REQUESTED_ADDRESS_FAMILY_ATTRIBUTE_V4);\n        byte[] actualReturn = requestedAddressFamilyAttribute.encode();\n        assertArrayEquals(\n            expectedReturn, actualReturn,\n            \"RequestedAddressFamilyAttribute.encode() did not properly encode a sample attribute for IPv4 family\"\n        );\n    }\n\n    /**\n     * Test whether attributes are properly encoded.\n     */\n    @Test\n    public void testEncodeV6()\n    {\n        byte[] expectedReturn = msgFixture.requestedAddressFamilyV6;\n        requestedAddressFamilyAttribute\n            .setFamily(MsgFixture.REQUESTED_ADDRESS_FAMILY_ATTRIBUTE_V6);\n        byte[] actualReturn = requestedAddressFamilyAttribute.encode();\n        assertArrayEquals(\n            expectedReturn, actualReturn,\n            \"RequestedAddressFamilyAttribute.encode() did not properly encode a sample attribute for IPv6 family\"\n        );\n    }\n\n    /**\n     * Tests that the address family is always 0x01 or 0x02.\n     */\n    @Test\n    public void testGetFamily()\n    {\n        char expectedReturn = 0x01;\n        this.requestedAddressFamilyAttribute\n            .setFamily(MsgFixture.REQUESTED_ADDRESS_FAMILY_ATTRIBUTE_V4);\n        char actualReturn = this.requestedAddressFamilyAttribute.getFamily();\n        assertEquals(expectedReturn, actualReturn,\n            \"Family is not properly calculated\");\n\n        expectedReturn = 0x02;\n        this.requestedAddressFamilyAttribute\n            .setFamily(MsgFixture.REQUESTED_ADDRESS_FAMILY_ATTRIBUTE_V6);\n        actualReturn = this.requestedAddressFamilyAttribute.getFamily();\n        assertEquals(expectedReturn, actualReturn,\n            \"Family is not properly calculated\");\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private RequestedAddressFamilyAttribute requestedAddressFamilyAttribute =\n        null;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "RequestedAddressFamilyAttribute", "name": "requestedAddressFamilyAttribute =\n        null", "syntax_pass": true}, {"attribute_expression": "private MsgFixture msgFixture;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "MsgFixture", "name": "msgFixture", "syntax_pass": true}]}, {"uris": "src/test/java/org/ice4j/attribute/RequestedAddressFamilyAttribute_setFamilyTest.java.RequestedAddressFamilyAttribute_setFamilyTest", "name": "RequestedAddressFamilyAttribute_setFamilyTest", "file_path": "src/test/java/org/ice4j/attribute/RequestedAddressFamilyAttribute_setFamilyTest.java", "superclasses": "", "methods": ["[void]testSetFamilyIPv4()", "[void]testSetFamilyIPv6()", "[void]testSetFamilyInvalid()", "[void]testEqualsAfterSetFamily()"], "method_uris": ["src/test/java/org/ice4j/attribute/RequestedAddressFamilyAttribute_setFamilyTest.java.RequestedAddressFamilyAttribute_setFamilyTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class RequestedAddressFamilyAttribute_setFamilyTest {\n    private RequestedAddressFamilyAttribute requestedAddressFamilyAttribute;\n    private MsgFixture msgFixture;\n\n    @BeforeEach\n    public void setUp() throws Exception {\n        this.requestedAddressFamilyAttribute = new RequestedAddressFamilyAttribute();\n        this.msgFixture = new MsgFixture();\n    }\n\n    @Test\n    public void testSetFamilyIPv4() {\n        assertTrue(requestedAddressFamilyAttribute.setFamily(RequestedAddressFamilyAttribute.IPv4));\n        assertEquals(RequestedAddressFamilyAttribute.IPv4, requestedAddressFamilyAttribute.getFamily());\n    }\n\n    @Test\n    public void testSetFamilyIPv6() {\n        assertTrue(requestedAddressFamilyAttribute.setFamily(RequestedAddressFamilyAttribute.IPv6));\n        assertEquals(RequestedAddressFamilyAttribute.IPv6, requestedAddressFamilyAttribute.getFamily());\n    }\n\n    @Test\n    public void testSetFamilyInvalid() {\n        assertFalse(requestedAddressFamilyAttribute.setFamily((char) 0x03));\n        assertEquals(RequestedAddressFamilyAttribute.IPv4, requestedAddressFamilyAttribute.getFamily());\n    }\n\n    @Test\n    public void testEqualsAfterSetFamily() {\n        RequestedAddressFamilyAttribute otherAttribute = new RequestedAddressFamilyAttribute();\n\n        requestedAddressFamilyAttribute.setFamily(RequestedAddressFamilyAttribute.IPv4);\n        otherAttribute.setFamily(RequestedAddressFamilyAttribute.IPv4);\n        assertEquals(requestedAddressFamilyAttribute, otherAttribute);\n\n        requestedAddressFamilyAttribute.setFamily(RequestedAddressFamilyAttribute.IPv6);\n        otherAttribute.setFamily(RequestedAddressFamilyAttribute.IPv6);\n        assertEquals(requestedAddressFamilyAttribute, otherAttribute);\n\n        requestedAddressFamilyAttribute.setFamily(RequestedAddressFamilyAttribute.IPv4);\n        otherAttribute.setFamily(RequestedAddressFamilyAttribute.IPv6);\n        assertNotEquals(requestedAddressFamilyAttribute, otherAttribute);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private RequestedAddressFamilyAttribute requestedAddressFamilyAttribute;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "RequestedAddressFamilyAttribute", "name": "requestedAddressFamilyAttribute", "syntax_pass": true}, {"attribute_expression": "private MsgFixture msgFixture;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "MsgFixture", "name": "msgFixture", "syntax_pass": true}]}, {"uris": "src/test/java/org/ice4j/attribute/AddressAttributeTest.java.AddressAttributeTest", "name": "AddressAttributeTest", "file_path": "src/test/java/org/ice4j/attribute/AddressAttributeTest.java", "superclasses": "", "methods": ["[void]testAddressAttributeDescendants()", "[void]testXorMappedAddressXoring_v4()", "[void]testXorMappedAddressXoring_v6()", "[void]testDecodeAttributeBody()", "[void]testDecodeAttributeBodyv6()", "[void]testEncode()", "[void]testEncodev6()", "[void]testEquals()", "[void]testGetDataLength()", "[void]testGetFamily()"], "method_uris": ["src/test/java/org/ice4j/attribute/AddressAttributeTest.java.AddressAttributeTest.[void]setUp()", "src/test/java/org/ice4j/attribute/AddressAttributeTest.java.AddressAttributeTest.[void]tearDown()"], "overrides": null, "attributes": [], "class_docstring": "\n\n@author Emil Ivov\n", "original_string": "public class AddressAttributeTest\n{\n    private AddressAttribute addressAttribute = null;\n    private MsgFixture msgFixture;\n\n    @BeforeEach\n    public void setUp() throws Exception\n    {\n        addressAttribute = new MappedAddressAttribute();\n        msgFixture = new MsgFixture();\n    }\n\n    @AfterEach\n    public void tearDown() throws Exception\n    {\n        addressAttribute = null;\n        msgFixture = null;\n    }\n\n    /**\n     * Verify that AddressAttribute descendants have correctly set types and\n     * names.\n     */\n    @Test\n    public void testAddressAttributeDescendants()\n    {\n        char expectedType;\n        char actualType;\n        String expectedName;\n        String actualName;\n\n        //MAPPED-ADDRESS\n        addressAttribute = new MappedAddressAttribute();\n\n        expectedType = Attribute.MAPPED_ADDRESS;\n        actualType = addressAttribute.getAttributeType();\n\n        expectedName = \"MAPPED-ADDRESS\";\n        actualName = addressAttribute.getName();\n\n        assertEquals(expectedType, actualType,\n            \"MappedAddressAttribute does not the right type.\");\n        assertEquals(expectedName, actualName,\n            \"MappedAddressAttribute does not the right name.\");\n\n\n        //SOURCE-ADDRESS\n        addressAttribute = new SourceAddressAttribute();\n\n        expectedType = Attribute.SOURCE_ADDRESS;\n        actualType = addressAttribute.getAttributeType();\n\n        expectedName = \"SOURCE-ADDRESS\";\n        actualName = addressAttribute.getName();\n\n        assertEquals(expectedType, actualType,\n            \"SourceAddressAttribute does not the right type.\");\n        assertEquals(expectedName, actualName,\n            \"SourceAddressAttribute does not the right name.\");\n\n\n        //CHANGED-ADDRESS\n        addressAttribute = new ChangedAddressAttribute();\n\n        expectedType = Attribute.CHANGED_ADDRESS;\n        actualType = addressAttribute.getAttributeType();\n\n        expectedName = \"CHANGED-ADDRESS\";\n        actualName = addressAttribute.getName();\n\n        assertEquals(expectedType, actualType,\n            \"ChangedAddressAttribute does not the right type.\");\n        assertEquals(expectedName, actualName,\n            \"ChangedAddressAttribute does not the right name.\");\n\n\n        //RESPONSE-ADDRESS\n        addressAttribute = new ResponseAddressAttribute();\n\n        expectedType = Attribute.RESPONSE_ADDRESS;\n        actualType = addressAttribute.getAttributeType();\n\n        expectedName = \"RESPONSE-ADDRESS\";\n        actualName = addressAttribute.getName();\n\n        assertEquals(expectedType, actualType,\n            \"ResponseAddressAttribute does not the right type.\");\n        assertEquals(expectedName, actualName,\n            \"ResponseAddressAttribute does not the right name.\");\n\n\n        //REFLECTED-FROM\n        addressAttribute = new ReflectedFromAttribute();\n\n        expectedType = Attribute.REFLECTED_FROM;\n        actualType = addressAttribute.getAttributeType();\n\n        expectedName = \"REFLECTED-FROM\";\n        actualName = addressAttribute.getName();\n\n        assertEquals(expectedType, actualType,\n            \"ReflectedFromAttribute does not the right type.\");\n        assertEquals(expectedName, actualName,\n            \"ReflectedFromAttribute does not the right name.\");\n\n        //REFLECTED-FROM\n        addressAttribute = new ReflectedFromAttribute();\n\n        expectedType = Attribute.REFLECTED_FROM;\n        actualType = addressAttribute.getAttributeType();\n\n        expectedName = \"REFLECTED-FROM\";\n        actualName = addressAttribute.getName();\n\n        assertEquals(expectedType, actualType,\n            \"ReflectedFromAttribute does not the right type.\");\n        assertEquals(expectedName, actualName,\n            \"ReflectedFromAttribute does not the right name.\");\n\n        //XOR-MAPPED-ADDRESS\n        addressAttribute = new XorMappedAddressAttribute();\n\n        expectedType = Attribute.XOR_MAPPED_ADDRESS;\n        actualType = addressAttribute.getAttributeType();\n\n        expectedName = \"XOR-MAPPED-ADDRESS\";\n        actualName = addressAttribute.getName();\n\n        assertEquals(expectedType, actualType,\n            \"XorMappedAddressAttribute does not the right type.\");\n        assertEquals(expectedName, actualName,\n            \"XorMappedAddressAttribute does not the right name.\");\n\n        /* ALTERNATE-SERVER */\n        addressAttribute = new AlternateServerAttribute();\n\n        expectedType = Attribute.ALTERNATE_SERVER;\n        actualType = addressAttribute.getAttributeType();\n\n        expectedName = \"ALTERNATE-SERVER\";\n        actualName = addressAttribute.getName();\n\n        assertEquals(expectedType, actualType,\n            \"AlternateServerAttribute does not the right type.\");\n        assertEquals(expectedName, actualName,\n            \"AlternateAttribute does not the right name.\");\n\n\n        /* XOR-PEER-ADDRESS */\n        addressAttribute = new XorPeerAddressAttribute();\n\n        expectedType = Attribute.XOR_PEER_ADDRESS;\n        actualType = addressAttribute.getAttributeType();\n\n        expectedName = \"XOR-PEER-ADDRESS\";\n        actualName = addressAttribute.getName();\n\n        assertEquals(expectedType, actualType,\n            \"XorPeerAddressAttribute does not the right type.\");\n        assertEquals(expectedName, actualName,\n            \"XorPeerAddressAttribute does not the right name.\");\n\n        /* XOR-RELAYED-ADDRESS */\n        addressAttribute = new XorRelayedAddressAttribute();\n\n        expectedType = Attribute.XOR_RELAYED_ADDRESS;\n        actualType = addressAttribute.getAttributeType();\n\n        expectedName = \"XOR-RELAYED-ADDRESS\";\n        actualName = addressAttribute.getName();\n\n        assertEquals(expectedType, actualType,\n            \"XorRelayedAddressAttribute does not the right type.\");\n        assertEquals(expectedName, actualName,\n            \"XorRelayedAddressAttribute does not the right name.\");\n    }\n\n    /**\n     * Verifies that xorred address-es are properly xor-ed for IPv4 addresses.\n     */\n    @Test\n    public void testXorMappedAddressXoring_v4()\n    {\n        XorMappedAddressAttribute addressAttribute = new XorMappedAddressAttribute();\n        TransportAddress testAddress =\n            new TransportAddress(\"130.79.95.53\", 12120, Transport.UDP);\n\n        addressAttribute.setAddress(testAddress);\n\n        //do a xor with an id equal to the v4 address itself so that we get 0000..,\n        TransportAddress xorredAddr = addressAttribute.applyXor(\n                new byte[]{(byte)130,79,95,53,0,0,0,0,0,0,0,0,0,0,0,0,0});\n\n        assertArrayEquals(\n            xorredAddr.getAddressBytes(), new byte[] { 0, 0, 0, 0 },\n            \"Xorring the address with itself didn't return 00000...\");\n\n        assertNotEquals(xorredAddr.getPort(), testAddress.getPort(),\n            \"Port was not xorred\");\n\n        //Test xor-ing the original with the xored - should get the xor code\n        addressAttribute.setAddress(testAddress);\n        xorredAddr = addressAttribute.applyXor(\n                new byte[]{21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36});\n\n        xorredAddr =\n            addressAttribute.applyXor(xorredAddr.getAddressBytes());\n\n        assertArrayEquals(\n            xorredAddr.getAddressBytes(), new byte[] { 21, 22, 23, 24 },\n            \"Xorring the original with the xor-ed didn't return the code.\");\n\n        assertNotEquals(0xFFFF, testAddress.getPort(), \"Port was not xorred\");\n\n        //Test double xor-ing - should get the original\n        addressAttribute.setAddress(testAddress);\n        xorredAddr = addressAttribute.applyXor(\n                new byte[]{21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36});\n\n        addressAttribute.setAddress(xorredAddr);\n        xorredAddr = addressAttribute.applyXor(\n                new byte[]{21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36});\n\n        assertEquals(testAddress, xorredAddr,\n            \"Double xorring didn't give the original\");\n    }\n\n    /**\n     * Verifies that xorred address-es are properly xor-ed for IPv6 addresses.\n     */\n    @Test\n    public void testXorMappedAddressXoring_v6()\n    {\n        XorMappedAddressAttribute addressAttribute\n            = new XorMappedAddressAttribute();\n        TransportAddress testAddress = new TransportAddress(\n                \"2001:660:4701:1001:202:8aff:febe:130b\", 12120, Transport.UDP);\n\n        addressAttribute.setAddress(testAddress);\n\n        //do a xor with an id equal to the v4 address itself so that we get 0000..,\n        TransportAddress xorredAddr =\n            addressAttribute.applyXor(\n                new byte[]{(byte)0x20, (byte)0x01, (byte)0x06, (byte)0x60,\n                           (byte)0x47, (byte)0x01, (byte)0x10, (byte)0x01,\n                           (byte)0x02, (byte)0x02, (byte)0x8a, (byte)0xff,\n                           (byte)0xfe, (byte)0xbe, (byte)0x13, (byte)0x0b});\n\n        assertArrayEquals(\n            xorredAddr.getAddressBytes(), new byte[] { 0, 0, 0, 0,\n                0, 0, 0, 0,\n                0, 0, 0, 0,\n                0, 0, 0, 0 },\n            \"Xorring the address with itself didn't return 00000...\");\n\n        assertNotEquals(testAddress.getPort(), xorredAddr.getPort(),\n            \"Port was not xorred\");\n\n        //Test xor-ing the original with the xored - should get the xor code\n        addressAttribute.setAddress(testAddress);\n        xorredAddr = addressAttribute.applyXor(\n                  new byte[]{21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36});\n\n        xorredAddr = addressAttribute.applyXor(xorredAddr.getAddressBytes());\n\n        assertArrayEquals(\n            xorredAddr.getAddressBytes(),\n            new byte[] { 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34,\n                35, 36 },\n            \"Xorring the original with the xor-ed didn't return the code.\");\n        \n        assertNotEquals(0xFFFF, testAddress.getPort(), \"Port was not xorred\");\n\n        //Test double xor-ing - should get the original\n        addressAttribute.setAddress(testAddress);\n        xorredAddr = addressAttribute.applyXor(\n                  new byte[]{21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36});\n\n        addressAttribute.setAddress(xorredAddr);\n        xorredAddr = addressAttribute.applyXor(\n                  new byte[]{21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36});\n\n        assertEquals(testAddress, xorredAddr,\n            \"Double xorring didn't give the original\");\n    }\n\n    /**\n     * Test whether sample binary arrays are correctly decoded.\n     *\n     * @throws StunException if something goes wrong\n     */\n    @Test\n    public void testDecodeAttributeBody() throws StunException {\n        byte[] attributeValue = msgFixture.mappedAddress;\n        char offset = Attribute.HEADER_LENGTH;\n        char length = (char)(attributeValue.length - offset);\n\n        addressAttribute.decodeAttributeBody(attributeValue, offset, length);\n\n\n        assertEquals(\n            MsgFixture.ADDRESS_ATTRIBUTE_PORT, addressAttribute.getPort(),\n            \"AddressAttribute.decode() did not properly decode the port field.\");\n        assertArrayEquals(\n            MsgFixture.ADDRESS_ATTRIBUTE_ADDRESS,\n            addressAttribute.getAddressBytes(),\n            \"AddressAttribute.decode() did not properly decode the address field.\");\n\n\n    }\n\n    /**\n     * Test whetner sample binary arrays are correctly decoded.\n     * @throws StunException if something goes wrong\n     */\n    @Test\n    public void testDecodeAttributeBodyv6() throws StunException {\n        byte[] attributeValue = msgFixture.mappedAddressv6;\n        char offset = Attribute.HEADER_LENGTH;\n        char length = (char)(attributeValue.length - offset);\n\n        addressAttribute.decodeAttributeBody(attributeValue, offset, length);\n\n\n        assertEquals(MsgFixture.ADDRESS_ATTRIBUTE_PORT,\n                     addressAttribute.getPort(),\n            \"decode() failed for an IPv6 Addr's port.\");\n        assertArrayEquals(\n            MsgFixture.ADDRESS_ATTRIBUTE_ADDRESS_V6,\n            addressAttribute.getAddressBytes(),\n            \"AddressAttribute.decode() failed for an IPv6 address.\");\n    }\n\n    /**\n     * Test whether attributes are properly encoded.\n     *\n     * @throws Exception java.lang.Exception if we fail\n     */\n    @Test\n    public void testEncode()\n        throws Exception\n    {\n        byte[] expectedReturn = msgFixture.mappedAddress;\n\n        addressAttribute.setAddress(\n            new TransportAddress(MsgFixture.ADDRESS_ATTRIBUTE_ADDRESS,\n                                 MsgFixture.ADDRESS_ATTRIBUTE_PORT,\n                                 Transport.UDP));\n\n        byte[] actualReturn = addressAttribute.encode();\n        assertArrayEquals(expectedReturn, actualReturn,\n            \"AddressAttribute.encode() did not properly encode a sample attribute\");\n    }\n\n    /**\n     * Test whether attributes are properly encoded.\n     *\n     * @throws Exception java.lang.Exception if we fail\n     */\n    @Test\n    public void testEncodev6()\n        throws Exception\n    {\n        byte[] expectedReturn = msgFixture.mappedAddressv6;\n\n        addressAttribute.setAddress(\n            new TransportAddress(MsgFixture.ADDRESS_ATTRIBUTE_ADDRESS_V6,\n                        MsgFixture.ADDRESS_ATTRIBUTE_PORT, Transport.UDP));\n\n        byte[] actualReturn = addressAttribute.encode();\n        assertArrayEquals(expectedReturn, actualReturn,\n            \"An AddressAttribute did not properly encode an IPv6 addr.\");\n    }\n\n\n    /**\n     * Tests the equals method against a null, a different and an identical\n     * object.\n     *\n     * @throws Exception java.lang.Exception if we fail\n     */\n    @Test\n    public void testEquals()\n        throws Exception\n    {\n        //null test\n        AddressAttribute target = null;\n        boolean expectedReturn = false;\n        boolean actualReturn = addressAttribute.equals(target);\n\n        assertEquals(expectedReturn, actualReturn,\n            \"AddressAttribute.equals() failed against a null target.\");\n\n        //difference test\n        target = new MappedAddressAttribute();\n\n        char port = (char)(MsgFixture.ADDRESS_ATTRIBUTE_PORT + 1 );\n        target.setAddress(  new TransportAddress(\n            MsgFixture.ADDRESS_ATTRIBUTE_ADDRESS, port, Transport.UDP));\n\n        addressAttribute.setAddress( new TransportAddress(\n            MsgFixture.ADDRESS_ATTRIBUTE_ADDRESS,\n            MsgFixture.ADDRESS_ATTRIBUTE_PORT,\n            Transport.UDP));\n\n        expectedReturn = false;\n        actualReturn = addressAttribute.equals(target);\n        assertEquals(expectedReturn, actualReturn,\n            \"AddressAttribute.equals() failed against a different target.\");\n\n        //equality test\n        target.setAddress( new TransportAddress(\n            MsgFixture.ADDRESS_ATTRIBUTE_ADDRESS,\n            MsgFixture.ADDRESS_ATTRIBUTE_PORT, Transport.UDP ));\n\n        expectedReturn = true;\n        actualReturn = addressAttribute.equals(target);\n        assertEquals(expectedReturn, actualReturn,\n            \"AddressAttribute.equals() failed against an equal target.\");\n\n        //ipv6 equality test\n        target.setAddress(  new TransportAddress(\n            MsgFixture.ADDRESS_ATTRIBUTE_ADDRESS_V6,\n            MsgFixture.ADDRESS_ATTRIBUTE_PORT, Transport.UDP));\n\n        addressAttribute.setAddress(new TransportAddress(\n            MsgFixture.ADDRESS_ATTRIBUTE_ADDRESS_V6,\n            MsgFixture.ADDRESS_ATTRIBUTE_PORT,\n            Transport.UDP));\n\n        expectedReturn = true;\n        actualReturn = addressAttribute.equals(target);\n        assertEquals(expectedReturn, actualReturn,\n            \"AddressAttribute.equals() failed for IPv6 addresses.\");\n    }\n\n    /**\n     * Tests whether data length is properly calculated.\n     *\n     * @throws Exception java.lang.Exception if we fail\n     */\n    @Test\n    public void testGetDataLength()\n        throws Exception\n    {\n        char expectedReturn = 8;//1-padding + 1-family + 2-port + 4-address\n\n        addressAttribute.setAddress( new TransportAddress(\n            MsgFixture.ADDRESS_ATTRIBUTE_ADDRESS,\n            MsgFixture.ADDRESS_ATTRIBUTE_PORT,\n            Transport.UDP));\n\n        char actualReturn = addressAttribute.getDataLength();\n\n        assertEquals(expectedReturn, actualReturn,\n            \"Datalength is not propoerly calculated\");\n\n        expectedReturn = 20;//1-padding + 1-family + 2-port + 16-address\n        addressAttribute.setAddress( new TransportAddress(\n            MsgFixture.ADDRESS_ATTRIBUTE_ADDRESS_V6,\n            MsgFixture.ADDRESS_ATTRIBUTE_PORT, Transport.UDP));\n\n        actualReturn = addressAttribute.getDataLength();\n\n        assertEquals(expectedReturn, actualReturn,\n            \"Datalength is not propoerly calculated\");\n    }\n\n    /**\n     * Tests that the address family is always 1.\n     *\n     * @throws Exception java.lang.Exception if we fail\n     */\n    @Test\n    public void testGetFamily()\n        throws Exception\n    {\n        byte expectedReturn = 1;\n        addressAttribute.setAddress(new TransportAddress(\n            MsgFixture.ADDRESS_ATTRIBUTE_ADDRESS,\n            MsgFixture.ADDRESS_ATTRIBUTE_PORT, Transport.UDP));\n        byte actualReturn = addressAttribute.getFamily();\n        assertEquals(expectedReturn, actualReturn,\n            \"Address family was not 1 for an IPv4\");\n\n        //ipv6\n        expectedReturn = 2;\n        addressAttribute.setAddress(new TransportAddress(\n                       MsgFixture.ADDRESS_ATTRIBUTE_ADDRESS_V6,\n                       MsgFixture.ADDRESS_ATTRIBUTE_PORT, Transport.UDP));\n        actualReturn = addressAttribute.getFamily();\n        assertEquals(expectedReturn, actualReturn,\n            \"Address family was not 2 for an IPv6 address\");\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private AddressAttribute addressAttribute = null;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "AddressAttribute", "name": "addressAttribute = null", "syntax_pass": true}, {"attribute_expression": "private MsgFixture msgFixture;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "MsgFixture", "name": "msgFixture", "syntax_pass": true}]}, {"uris": "src/test/java/org/ice4j/attribute/OptionalAttributeAttributeTest.java.OptionalAttributeAttributeTest", "name": "OptionalAttributeAttributeTest", "file_path": "src/test/java/org/ice4j/attribute/OptionalAttributeAttributeTest.java", "superclasses": "", "methods": ["[void]testDecodeAttributeBody()", "[void]testEncode()", "[void]testEquals()", "[void]testGetDataLength()"], "method_uris": ["src/test/java/org/ice4j/attribute/OptionalAttributeAttributeTest.java.OptionalAttributeAttributeTest.[void]setUp()", "src/test/java/org/ice4j/attribute/OptionalAttributeAttributeTest.java.OptionalAttributeAttributeTest.[void]tearDown()"], "overrides": null, "attributes": [], "class_docstring": "\n@author Emil Ivov\n", "original_string": "public class OptionalAttributeAttributeTest\n{\n    private OptionalAttribute optionalAttribute = null;\n    private MsgFixture msgFixture = null;\n    byte[] expectedAttributeValue = null;\n\n    @BeforeEach\n    public void setUp() throws Exception\n    {\n        msgFixture = new MsgFixture();\n        int offset = Attribute.HEADER_LENGTH;\n\n        //init a sample body\n        expectedAttributeValue =\n            new byte[msgFixture.unknownOptionalAttribute.length - offset];\n\n        System.arraycopy(msgFixture.unknownOptionalAttribute, offset,\n                         expectedAttributeValue, 0,\n                         expectedAttributeValue.length);\n\n        optionalAttribute = new OptionalAttribute(\n                                        msgFixture.optionalAttributeType);\n    }\n\n    @AfterEach\n    public void tearDown() throws Exception\n    {\n        optionalAttribute = null;\n        expectedAttributeValue = null;\n    }\n\n    /**\n     * Test whether sample binary arrays are correctly decoded.\n     * @throws StunException if anything goes wrong.\n     */\n    @Test\n    public void testDecodeAttributeBody() throws StunException {\n\n        char offset = Attribute.HEADER_LENGTH;\n        char length = (char)(msgFixture.unknownOptionalAttribute.length - offset);\n\n        optionalAttribute.decodeAttributeBody(msgFixture.unknownOptionalAttribute,\n                                              offset, length);\n\n        assertArrayEquals(\n            expectedAttributeValue, optionalAttribute.getBody(),\n            \"OptionalAttribute did not decode properly.\");\n\n        assertEquals(length, optionalAttribute.getDataLength(),\n            \"Length was not properly decoded\");\n    }\n\n    /**\n     * Test whether attributes are properly encoded\n     */\n    @Test\n    public void testEncode()\n    {\n        optionalAttribute.setBody(expectedAttributeValue, 0,\n                                  expectedAttributeValue.length);\n\n        byte[] actualReturn = optionalAttribute.encode();\n        assertArrayEquals(msgFixture.unknownOptionalAttribute, actualReturn);\n    }\n\n    /**\n     * Test whether the equals method works ok\n     */\n    @Test\n    public void testEquals()\n    {\n        //null comparison\n        optionalAttribute.setBody( expectedAttributeValue, 0,\n                                   expectedAttributeValue.length);\n\n        assertNotEquals(optionalAttribute, null);\n\n        //wrong type comparison\n        assertNotEquals(optionalAttribute, \"hehe :)\");\n\n        //succesful comparison\n        OptionalAttribute obj =\n            new OptionalAttribute(msgFixture.optionalAttributeType);\n\n        obj.setBody( expectedAttributeValue, 0,\n                                          expectedAttributeValue.length);\n        assertEquals(obj, optionalAttribute);\n    }\n\n    @Test\n    public void testGetDataLength()\n    {\n        char expectedReturn = (char)expectedAttributeValue.length;\n\n        optionalAttribute.setBody( expectedAttributeValue, 0,\n                                   expectedAttributeValue.length);\n\n        char actualReturn = optionalAttribute.getDataLength();\n        assertEquals(expectedReturn, actualReturn);\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private OptionalAttribute optionalAttribute = null;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "OptionalAttribute", "name": "optionalAttribute = null", "syntax_pass": true}, {"attribute_expression": "private MsgFixture msgFixture = null;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "MsgFixture", "name": "msgFixture = null", "syntax_pass": true}, {"attribute_expression": "byte[] expectedAttributeValue = null;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "byte[]", "name": "expectedAttributeValue = null", "syntax_pass": true}]}, {"uris": "src/test/java/org/ice4j/attribute/ErrorCodeAttributeTest.java.ErrorCodeAttributeTest", "name": "ErrorCodeAttributeTest", "file_path": "src/test/java/org/ice4j/attribute/ErrorCodeAttributeTest.java", "superclasses": "", "methods": ["[void]testErrorCodeAttribute()", "[void]testDecodeAttributeBody()", "[void]testEncode()", "[void]testEquals()", "[void]testGetDataLength()", "[void]testGetErrorCode()", "[void]testGetName()", "[void]testSetErrorCode()"], "method_uris": ["src/test/java/org/ice4j/attribute/ErrorCodeAttributeTest.java.ErrorCodeAttributeTest.[void]setUp()", "src/test/java/org/ice4j/attribute/ErrorCodeAttributeTest.java.ErrorCodeAttributeTest.[void]tearDown()"], "overrides": null, "attributes": [], "class_docstring": "\n\n@author Emil Ivov\n", "original_string": "public class ErrorCodeAttributeTest\n{\n    private ErrorCodeAttribute errorCodeAttribute = null;\n    private MsgFixture msgFixture;\n\n    @BeforeEach\n    public void setUp() throws Exception\n    {\n        errorCodeAttribute = new ErrorCodeAttribute();\n        msgFixture = new MsgFixture();\n    }\n\n    @AfterEach\n    public void tearDown() throws Exception {\n        errorCodeAttribute = null;\n        msgFixture = null;\n    }\n\n    /**\n     * Test Attribute type\n     */\n    @Test\n    public void testErrorCodeAttribute()\n    {\n        errorCodeAttribute = new ErrorCodeAttribute();\n        assertEquals(\n            Attribute.ERROR_CODE,\n            errorCodeAttribute.getAttributeType(),\n            \"ErrorCodeAttribute() constructed an attribute with an invalid type\"\n        );\n    }\n\n    /**\n     * Test whether sample binary arrays are properly decoded.\n     *\n     * @throws StunException java.lang.Exception if we fail\n     */\n    @Test\n    public void testDecodeAttributeBody()\n        throws StunException {\n        byte[] attributeValue = msgFixture.errCodeTestValue;\n        char offset = Attribute.HEADER_LENGTH;\n        char length = (char)(attributeValue.length - Attribute.HEADER_LENGTH);\n        errorCodeAttribute.decodeAttributeBody(attributeValue, offset, length);\n\n        assertEquals(\n            MsgFixture.ERROR_CLASS,\n            errorCodeAttribute.getErrorClass(),\n            \"Error Class was not correctly decoded\"\n        );\n\n        assertEquals(\n            MsgFixture.ERROR_NUMBER,\n            errorCodeAttribute.getErrorNumber(),\n            \"Error Number was not correctly decoded\"\n        );\n\n        assertEquals(\n            MsgFixture.REASON_PHRASE.trim(),\n            errorCodeAttribute.getReasonPhrase().trim(),\n            \"Reason phrase was not correctly decoded\");\n    }\n\n    /**\n     * Construct and encode a sample object and assert equality with a sample\n     * binary array.\n     *\n     * @throws StunException java.lang.Exception if we fail\n     */\n    @Test\n    public void testEncode()\n        throws StunException\n    {\n        byte[] expectedReturn = msgFixture.errCodeTestValue;\n\n        errorCodeAttribute.setErrorClass(MsgFixture.ERROR_CLASS);\n        errorCodeAttribute.setErrorNumber(MsgFixture.ERROR_NUMBER);\n\n        errorCodeAttribute.setReasonPhrase(MsgFixture.REASON_PHRASE);\n\n        byte[] actualReturn = errorCodeAttribute.encode();\n\n        assertArrayEquals(expectedReturn, actualReturn,\n            \"encode() did not return the expected binary array.\");\n    }\n\n    /**\n     * Tests the equals method against a null, a different and an identical\n     * object.\n     *\n     * @throws StunException java.lang.Exception if we fail\n     */\n    @Test\n    public void testEquals()\n        throws StunException\n    {\n        //null value test\n        assertNotEquals(errorCodeAttribute, null,\n            \"equals() failed against a null value target.\");\n\n        //different objects\n        ErrorCodeAttribute target;\n        target = new ErrorCodeAttribute();\n\n        target.setErrorClass(MsgFixture.ERROR_CLASS);\n        target.setErrorNumber(MsgFixture.ERROR_NUMBER);\n\n        errorCodeAttribute.setErrorClass((byte)(MsgFixture.ERROR_CLASS+1));\n        errorCodeAttribute.setErrorNumber((byte)(MsgFixture.ERROR_NUMBER+1));\n\n        assertNotEquals(errorCodeAttribute, target,\n            \"equals() failed against a not equal target.\");\n\n        //equal objects\n        target = new ErrorCodeAttribute();\n        errorCodeAttribute = new ErrorCodeAttribute();\n\n        target.setErrorClass(MsgFixture.ERROR_CLASS);\n        target.setErrorNumber(MsgFixture.ERROR_NUMBER);\n\n        errorCodeAttribute.setErrorClass(MsgFixture.ERROR_CLASS);\n        errorCodeAttribute.setErrorNumber(MsgFixture.ERROR_NUMBER);\n\n        assertEquals(errorCodeAttribute, target,\n            \"equals() failed against an equal target.\");\n    }\n\n    /**\n     * Test whether data length is propertly calculated.\n     *\n     * @throws StunException java.lang.Exception if we fail\n     */\n    @Test\n    public void testGetDataLength()\n        throws StunException\n    {\n        int expectedReturn = MsgFixture.REASON_PHRASE.getBytes().length\n                            + 4; //error code specific header\n\n        errorCodeAttribute.setErrorClass(MsgFixture.ERROR_CLASS);\n        errorCodeAttribute.setErrorNumber(MsgFixture.ERROR_NUMBER);\n        errorCodeAttribute.setReasonPhrase(MsgFixture.REASON_PHRASE);\n\n        char actualReturn = errorCodeAttribute.getDataLength();\n        assertEquals(expectedReturn, actualReturn, \"data length1\");\n    }\n\n    /**\n     * Test whether error code is properly calculated from error class and number\n     */\n    @Test\n    public void testGetErrorCode()\n    {\n        char expectedReturn = (char)(100*MsgFixture.ERROR_CLASS\n                                     + MsgFixture.ERROR_NUMBER);\n\n        errorCodeAttribute.setErrorClass(MsgFixture.ERROR_CLASS);\n        errorCodeAttribute.setErrorNumber(MsgFixture.ERROR_NUMBER);\n\n        char actualReturn = errorCodeAttribute.getErrorCode();\n        assertEquals(expectedReturn, actualReturn);\n    }\n\n    /**\n     * Test whether we get a proper name for that attribute.\n     */\n    @Test\n    public void testGetName() {\n        assertEquals(\"ERROR-CODE\", errorCodeAttribute.getName());\n    }\n\n    /**\n     * Test whether error code is properly calculated from error class and number\n     *\n     */\n    @Test\n    public void testSetErrorCode()\n    {\n        char errorCode = (char)(MsgFixture.ERROR_CLASS*100 + MsgFixture.ERROR_NUMBER);\n        errorCodeAttribute.setErrorCode(errorCode);\n\n        assertEquals(\n            MsgFixture.ERROR_CLASS,\n            (int) errorCodeAttribute.getErrorClass(),\n            \"An error class was not properly set after decoding an error code.\"\n        );\n        assertEquals(\n            MsgFixture.ERROR_NUMBER,\n            (int) errorCodeAttribute.getErrorNumber(),\n            \"An error number was not properly set after decoding an error code.\"\n        );\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private ErrorCodeAttribute errorCodeAttribute = null;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ErrorCodeAttribute", "name": "errorCodeAttribute = null", "syntax_pass": true}, {"attribute_expression": "private MsgFixture msgFixture;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "MsgFixture", "name": "msgFixture", "syntax_pass": true}]}, {"uris": "src/test/java/org/ice4j/attribute/AttributeDecoderTest.java.AttributeDecoderTest", "name": "AttributeDecoderTest", "file_path": "src/test/java/org/ice4j/attribute/AttributeDecoderTest.java", "superclasses": "", "methods": ["[void]testDecodeMappedAddress()", "[void]testDecodeMappedAddress_v6()", "[void]testDecodeChangeRequest()", "[void]testDecodeErrorCode()", "[void]testDecodeUnknownAttributes()", "[void]testDecodeUnknownOptionalAttribute()"], "method_uris": ["src/test/java/org/ice4j/attribute/AttributeDecoderTest.java.AttributeDecoderTest.[void]setUp()", "src/test/java/org/ice4j/attribute/AttributeDecoderTest.java.AttributeDecoderTest.[void]tearDown()"], "overrides": null, "attributes": [], "class_docstring": "\nWe have already tested individual decode methods, so our job here\nis to verify that that AttributeDecoder.decode distributes the right way.\n", "original_string": "public class AttributeDecoderTest {\n    private MsgFixture msgFixture;\n    private byte[] expectedAttributeValue = null;\n\n    @BeforeEach\n    public void setUp() throws Exception\n    {\n        msgFixture = new MsgFixture();\n\n        //init a sample body\n        int offset = Attribute.HEADER_LENGTH;\n        expectedAttributeValue =\n            new byte[msgFixture.unknownOptionalAttribute.length - offset];\n        System.arraycopy(msgFixture.unknownOptionalAttribute, offset,\n                         expectedAttributeValue, 0,\n                         expectedAttributeValue.length);\n    }\n\n    @AfterEach\n    public void tearDown() throws Exception\n    {\n        msgFixture = null;\n    }\n\n    @Test\n    public void testDecodeMappedAddress()\n        throws Exception\n    {\n        //\n        byte[] bytes = msgFixture.mappedAddress;\n        char offset = 0;\n        char length = (char)bytes.length;\n\n        //create the message\n        MappedAddressAttribute expectedReturn = new MappedAddressAttribute();\n\n        expectedReturn.setAddress(new TransportAddress(\n                       MsgFixture.ADDRESS_ATTRIBUTE_ADDRESS,\n                       MsgFixture.ADDRESS_ATTRIBUTE_PORT,\n                       Transport.UDP));\n\n        Attribute actualReturn = AttributeDecoder.decode(\n                        bytes, offset, length);\n\n        assertEquals(expectedReturn, actualReturn,\n            \"AttributeDecoder.decode() failed for a MAPPED-ADDRESS attribute\");\n    }\n\n    @Test\n    public void testDecodeMappedAddress_v6()\n        throws Exception\n    {\n        //\n        byte[] bytes = msgFixture.mappedAddressv6;\n        char offset = 0;\n        char length = (char)bytes.length;\n\n        //create the message\n        MappedAddressAttribute expectedReturn = new MappedAddressAttribute();\n\n        expectedReturn.setAddress( new TransportAddress(\n                        MsgFixture.ADDRESS_ATTRIBUTE_ADDRESS_V6,\n                        MsgFixture.ADDRESS_ATTRIBUTE_PORT,\n                        Transport.UDP));\n\n        Attribute actualReturn = AttributeDecoder.decode(\n                        bytes, offset, length);\n\n        assertEquals(\n            expectedReturn, actualReturn,\n            \"AttributeDecoder.decode() failed for a MAPPED-ADDRESS attribute\"\n            );\n    }\n\n    @Test\n    public void testDecodeChangeRequest()\n        throws Exception\n    {\n        //\n        byte[] bytes = msgFixture.chngReqTestValue1;\n        char offset = 0;\n        char length = (char)bytes.length;\n\n        //create the message\n        ChangeRequestAttribute expectedReturn = new ChangeRequestAttribute();\n        expectedReturn.setChangeIpFlag(MsgFixture.CHANGE_IP_FLAG_1);\n        expectedReturn.setChangePortFlag(MsgFixture.CHANGE_PORT_FLAG_1);\n\n        Attribute actualReturn = AttributeDecoder.decode(\n                        bytes, offset, length);\n        assertEquals(expectedReturn, actualReturn,\n            \"AttributeDecoder.decode() failed for a CHANGE-REQUEST attribute\"\n        );\n    }\n\n    @Test\n    public void testDecodeErrorCode()\n       throws Exception\n   {\n       //\n       byte[] bytes = msgFixture.errCodeTestValue;\n       char offset = 0;\n       char length = (char)bytes.length;\n\n       //create the message\n       ErrorCodeAttribute expectedReturn = new ErrorCodeAttribute();\n       expectedReturn.setErrorClass(MsgFixture.ERROR_CLASS);\n       expectedReturn.setErrorNumber(MsgFixture.ERROR_NUMBER);\n       expectedReturn.setReasonPhrase(MsgFixture.REASON_PHRASE);\n\n       Attribute actualReturn = AttributeDecoder.decode(\n                       bytes, offset, length);\n       assertEquals(expectedReturn, actualReturn,\n           \"AttributeDecoder.decode() failed for a ERROR-CODE attribute\");\n   }\n\n    @Test\n    public void testDecodeUnknownAttributes()\n       throws Exception\n   {\n       //unknown attributes\n       byte[] bytes = msgFixture.unknownAttsDecodeTestValue;\n       char offset = 0;\n       char length = (char)msgFixture.mappedAddress.length;\n\n       //create the message\n       UnknownAttributesAttribute expectedReturn\n           = new UnknownAttributesAttribute();\n       expectedReturn.addAttributeID(MsgFixture.UNKNOWN_ATTRIBUTES_1ST_ATT);\n       expectedReturn.addAttributeID(MsgFixture.UNKNOWN_ATTRIBUTES_2ND_ATT);\n       expectedReturn.addAttributeID(MsgFixture.UNKNOWN_ATTRIBUTES_3D_ATT);\n\n       Attribute actualReturn = AttributeDecoder.decode(\n                       bytes, offset, length);\n\n       assertEquals(expectedReturn, actualReturn,\n              \"AttributeDecoder.decode() failed for a ERROR-CODE attribute\");\n   }\n\n    @Test\n    public void testDecodeUnknownOptionalAttribute()\n       throws Exception\n   {\n       //unknown attributes\n       byte[] bytes = msgFixture.unknownOptionalAttribute;\n       char offset = 0;\n       char length = (char)msgFixture.mappedAddress.length;\n\n       //create the message\n       OptionalAttribute expectedReturn =\n           new OptionalAttribute(Attribute.UNKNOWN_OPTIONAL_ATTRIBUTE);\n       expectedReturn.setBody(expectedAttributeValue, 0,\n                              expectedAttributeValue.length);\n\n       Attribute actualReturn = AttributeDecoder.decode(\n                       bytes, offset, length);\n       assertEquals(expectedReturn, actualReturn,\n           \"AttributeDecoder.decode() failed for a UNKNOWN_OPTIONAL attribute\");\n\n   }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private MsgFixture msgFixture;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "MsgFixture", "name": "msgFixture", "syntax_pass": true}, {"attribute_expression": "private byte[] expectedAttributeValue = null;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "byte[]", "name": "expectedAttributeValue = null", "syntax_pass": true}]}, {"uris": "src/test/java/org/ice4j/attribute/ErrorCodeAttribute_getReasonPhraseTest.java.ErrorCodeAttribute_getReasonPhraseTest", "name": "ErrorCodeAttribute_getReasonPhraseTest", "file_path": "src/test/java/org/ice4j/attribute/ErrorCodeAttribute_getReasonPhraseTest.java", "superclasses": "", "methods": ["[void]testGetReasonPhraseWithNullReasonPhrase()", "[void]testGetReasonPhraseWithSetReasonPhrase()", "[void]testGetReasonPhraseAfterSettingErrorCode()", "[void]testGetReasonPhraseAfterOverridingWithSetReasonPhrase()"], "method_uris": ["src/test/java/org/ice4j/attribute/ErrorCodeAttribute_getReasonPhraseTest.java.ErrorCodeAttribute_getReasonPhraseTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class ErrorCodeAttribute_getReasonPhraseTest {\n    private ErrorCodeAttribute errorCodeAttribute;\n\n    @BeforeEach\n    public void setUp() {\n        errorCodeAttribute = new ErrorCodeAttribute();\n    }\n\n    @Test\n    public void testGetReasonPhraseWithNullReasonPhrase() {\n        assertNull(errorCodeAttribute.getReasonPhrase(), \"Reason phrase should be null when not set.\");\n    }\n\n    @Test\n    public void testGetReasonPhraseWithSetReasonPhrase() {\n        String reasonPhrase = \"Test Reason Phrase\";\n        errorCodeAttribute.setReasonPhrase(reasonPhrase);\n        assertEquals(reasonPhrase, errorCodeAttribute.getReasonPhrase(), \"Reason phrase should match the set value.\");\n    }\n\n    @Test\n    public void testGetReasonPhraseAfterSettingErrorCode() {\n        char errorCode = 400;\n        errorCodeAttribute.setErrorCode(errorCode);\n        String expectedReasonPhrase = ErrorCodeAttribute.getDefaultReasonPhrase(errorCode);\n        errorCodeAttribute.setReasonPhrase(expectedReasonPhrase); // Ensure the reason phrase is set\n        assertEquals(expectedReasonPhrase, errorCodeAttribute.getReasonPhrase(), \"Reason phrase should match the default reason phrase for the error code.\");\n    }\n\n    @Test\n    public void testGetReasonPhraseAfterOverridingWithSetReasonPhrase() {\n        char errorCode = 400;\n        String customReasonPhrase = \"Custom Reason Phrase\";\n        errorCodeAttribute.setErrorCode(errorCode);\n        errorCodeAttribute.setReasonPhrase(customReasonPhrase);\n        assertEquals(customReasonPhrase, errorCodeAttribute.getReasonPhrase(), \"Reason phrase should match the custom set value.\");\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private ErrorCodeAttribute errorCodeAttribute;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ErrorCodeAttribute", "name": "errorCodeAttribute", "syntax_pass": true}]}, {"uris": "src/test/java/org/ice4j/attribute/RequestedAddressFamilyAttribute_equalsTest.java.RequestedAddressFamilyAttribute_equalsTest", "name": "RequestedAddressFamilyAttribute_equalsTest", "file_path": "src/test/java/org/ice4j/attribute/RequestedAddressFamilyAttribute_equalsTest.java", "superclasses": "", "methods": ["[void]testEqualsSameObject()", "[void]testEqualsDifferentType()", "[void]testEqualsDifferentFamily()", "[void]testEqualsSameFamily()", "[void]testEqualsDifferentAttributeType()", "[void]testEqualsDifferentDataLength()", "[void]testEqualsAfterDecode()"], "method_uris": ["src/test/java/org/ice4j/attribute/RequestedAddressFamilyAttribute_equalsTest.java.RequestedAddressFamilyAttribute_equalsTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class RequestedAddressFamilyAttribute_equalsTest {\n    private RequestedAddressFamilyAttribute requestedAddressFamilyAttribute;\n    private MsgFixture msgFixture;\n\n    @BeforeEach\n    public void setUp() throws Exception {\n        this.requestedAddressFamilyAttribute = new RequestedAddressFamilyAttribute();\n        this.msgFixture = new MsgFixture();\n    }\n\n    @Test\n    public void testEqualsSameObject() {\n        assertTrue(requestedAddressFamilyAttribute.equals(requestedAddressFamilyAttribute));\n    }\n\n    @Test\n    public void testEqualsDifferentType() {\n        Object obj = new Object();\n        assertFalse(requestedAddressFamilyAttribute.equals(obj));\n    }\n\n    @Test\n    public void testEqualsDifferentFamily() throws StunException {\n        RequestedAddressFamilyAttribute other = new RequestedAddressFamilyAttribute();\n        other.setFamily(RequestedAddressFamilyAttribute.IPv6);\n        assertFalse(requestedAddressFamilyAttribute.equals(other));\n    }\n\n    @Test\n    public void testEqualsSameFamily() throws StunException {\n        RequestedAddressFamilyAttribute other = new RequestedAddressFamilyAttribute();\n        assertTrue(requestedAddressFamilyAttribute.equals(other));\n    }\n\n    @Test\n    public void testEqualsDifferentAttributeType() throws StunException {\n        RequestedAddressFamilyAttribute other = new RequestedAddressFamilyAttribute() {\n            @Override\n            public char getAttributeType() {\n                return (char) (super.getAttributeType() + 1);\n            }\n        };\n        assertFalse(requestedAddressFamilyAttribute.equals(other));\n    }\n\n    @Test\n    public void testEqualsDifferentDataLength() throws StunException {\n        RequestedAddressFamilyAttribute other = new RequestedAddressFamilyAttribute() {\n            @Override\n            public char getDataLength() {\n                return (char) (super.getDataLength() + 1);\n            }\n        };\n        assertFalse(requestedAddressFamilyAttribute.equals(other));\n    }\n\n    @Test\n    public void testEqualsAfterDecode() throws StunException {\n        byte[] attributeValue = msgFixture.requestedAddressFamilyV6;\n        char offset = Attribute.HEADER_LENGTH;\n        char length = (char) (attributeValue.length - offset);\n\n        RequestedAddressFamilyAttribute decodedAttribute = new RequestedAddressFamilyAttribute();\n        decodedAttribute.decodeAttributeBody(attributeValue, offset, length);\n\n        RequestedAddressFamilyAttribute other = new RequestedAddressFamilyAttribute();\n        other.setFamily(RequestedAddressFamilyAttribute.IPv6);\n\n        assertTrue(decodedAttribute.equals(other));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private RequestedAddressFamilyAttribute requestedAddressFamilyAttribute;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "RequestedAddressFamilyAttribute", "name": "requestedAddressFamilyAttribute", "syntax_pass": true}, {"attribute_expression": "private MsgFixture msgFixture;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "MsgFixture", "name": "msgFixture", "syntax_pass": true}]}, {"uris": "src/test/java/org/ice4j/attribute/ErrorCodeAttribute_setErrorClassTest.java.ErrorCodeAttribute_setErrorClassTest", "name": "ErrorCodeAttribute_setErrorClassTest", "file_path": "src/test/java/org/ice4j/attribute/ErrorCodeAttribute_setErrorClassTest.java", "superclasses": "", "methods": ["[void]testSetErrorClassValid()", "[void]testSetErrorClassInvalid()", "[void]testSetErrorClassBoundaryLower()", "[void]testSetErrorClassBoundaryUpper()"], "method_uris": ["src/test/java/org/ice4j/attribute/ErrorCodeAttribute_setErrorClassTest.java.ErrorCodeAttribute_setErrorClassTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class ErrorCodeAttribute_setErrorClassTest {\n    private ErrorCodeAttribute errorCodeAttribute;\n\n    @BeforeEach\n    public void setUp() {\n        errorCodeAttribute = new ErrorCodeAttribute();\n    }\n\n    @Test\n    public void testSetErrorClassValid() {\n        byte validErrorClass = 50;\n        assertDoesNotThrow(() -> errorCodeAttribute.setErrorClass(validErrorClass));\n        assertEquals(validErrorClass, errorCodeAttribute.getErrorClass());\n    }\n\n    @Test\n    public void testSetErrorClassInvalid() {\n        byte invalidErrorClass = 100;\n        IllegalArgumentException exception = assertThrows(IllegalArgumentException.class,\n            () -> errorCodeAttribute.setErrorClass(invalidErrorClass));\n        assertEquals(invalidErrorClass + \" is not a valid error number!\", exception.getMessage());\n    }\n\n    @Test\n    public void testSetErrorClassBoundaryLower() {\n        byte boundaryErrorClass = 0;\n        assertDoesNotThrow(() -> errorCodeAttribute.setErrorClass(boundaryErrorClass));\n        assertEquals(boundaryErrorClass, errorCodeAttribute.getErrorClass());\n    }\n\n    @Test\n    public void testSetErrorClassBoundaryUpper() {\n        byte boundaryErrorClass = 99;\n        assertDoesNotThrow(() -> errorCodeAttribute.setErrorClass(boundaryErrorClass));\n        assertEquals(boundaryErrorClass, errorCodeAttribute.getErrorClass());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private ErrorCodeAttribute errorCodeAttribute;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ErrorCodeAttribute", "name": "errorCodeAttribute", "syntax_pass": true}]}, {"uris": "src/test/java/org/ice4j/attribute/ConnectionIdAttribute_equalsTest.java.ConnectionIdAttribute_equalsTest", "name": "ConnectionIdAttribute_equalsTest", "file_path": "src/test/java/org/ice4j/attribute/ConnectionIdAttribute_equalsTest.java", "superclasses": "", "methods": ["[void]testEquals_SameObject()", "[void]testEquals_DifferentClass()", "[void]testEquals_DifferentConnectionIdValue()", "[void]testEquals_SameConnectionIdValue()", "[void]testEquals_DifferentDataLength()", "[void]testEquals_DifferentAttributeType()"], "method_uris": ["src/test/java/org/ice4j/attribute/ConnectionIdAttribute_equalsTest.java.ConnectionIdAttribute_equalsTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class ConnectionIdAttribute_equalsTest {\n    private ConnectionIdAttribute connectionIdAttribute;\n    private MsgFixture msgFixture;\n\n    @BeforeEach\n    public void setUp() throws Exception {\n        this.connectionIdAttribute = new ConnectionIdAttribute();\n        this.msgFixture = new MsgFixture();\n    }\n\n    @Test\n    public void testEquals_SameObject() {\n        assertTrue(connectionIdAttribute.equals(connectionIdAttribute));\n    }\n\n    @Test\n    public void testEquals_DifferentClass() {\n        Object obj = new Object();\n        assertFalse(connectionIdAttribute.equals(obj));\n    }\n\n    @Test\n    public void testEquals_DifferentConnectionIdValue() throws StunException {\n        ConnectionIdAttribute other = new ConnectionIdAttribute();\n        other.setConnectionIdValue(123456);\n        connectionIdAttribute.setConnectionIdValue(654321);\n        assertFalse(connectionIdAttribute.equals(other));\n    }\n\n    @Test\n    public void testEquals_SameConnectionIdValue() throws StunException {\n        ConnectionIdAttribute other = new ConnectionIdAttribute();\n        other.setConnectionIdValue(123456);\n        connectionIdAttribute.setConnectionIdValue(123456);\n        assertTrue(connectionIdAttribute.equals(other));\n    }\n\n    @Test\n    public void testEquals_DifferentDataLength() throws StunException {\n        ConnectionIdAttribute other = new ConnectionIdAttribute();\n        // Assuming there's a way to set a different data length, which is not shown in the provided code\n        // For the sake of this example, we'll assume a hypothetical method setDataLength(char)\n        // other.setDataLength(8);\n        // connectionIdAttribute.setDataLength(4);\n        // assertFalse(connectionIdAttribute.equals(other));\n    }\n\n    @Test\n    public void testEquals_DifferentAttributeType() throws StunException {\n        ConnectionIdAttribute other = new ConnectionIdAttribute();\n        // Assuming there's a way to set a different attribute type, which is not shown in the provided code\n        // For the sake of this example, we'll assume a hypothetical method setAttributeType(int)\n        // other.setAttributeType(1);\n        // connectionIdAttribute.setAttributeType(2);\n        // assertFalse(connectionIdAttribute.equals(other));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private ConnectionIdAttribute connectionIdAttribute;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ConnectionIdAttribute", "name": "connectionIdAttribute", "syntax_pass": true}, {"attribute_expression": "private MsgFixture msgFixture;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "MsgFixture", "name": "msgFixture", "syntax_pass": true}]}, {"uris": "src/test/java/org/ice4j/attribute/ConnectionIdAttributeTest.java.ConnectionIdAttributeTest", "name": "ConnectionIdAttributeTest", "file_path": "src/test/java/org/ice4j/attribute/ConnectionIdAttributeTest.java", "superclasses": "", "methods": ["[void]testGetDataLength()", "[void]testGetName()", "[void]testEqualsObject()", "[void]testEncode()", "[void]testDecodeAttributeBody()", "[void]testGetConnectionIdValue()"], "method_uris": ["src/test/java/org/ice4j/attribute/ConnectionIdAttributeTest.java.ConnectionIdAttributeTest.[void]setUp()", "src/test/java/org/ice4j/attribute/ConnectionIdAttributeTest.java.ConnectionIdAttributeTest.[void]tearDown()"], "overrides": null, "attributes": [], "class_docstring": "\nClass to test the ConnectionIdAttribute class.\n\n@author Aakash Garg\n\n", "original_string": "public class ConnectionIdAttributeTest\n{\n    private ConnectionIdAttribute connectionIdAttribute = null;\n\n    private MsgFixture msgFixture;\n\n    @BeforeEach\n    public void setUp() throws Exception\n    {\n        this.connectionIdAttribute = new ConnectionIdAttribute();\n        this.msgFixture = new MsgFixture();\n    }\n\n    @AfterEach\n    public void tearDown() throws Exception\n    {\n        this.connectionIdAttribute = null;\n        this.msgFixture = null;\n    }\n\n    /**\n     * Tests whether data length is properly calculated.\n     */\n    @Test\n    public void testGetDataLength()\n    {\n        char expectedReturn = 4;\n        this.connectionIdAttribute\n            .setConnectionIdValue(MsgFixture.CONNECTION_ID);\n        char actualReturn = this.connectionIdAttribute.getDataLength();\n        assertEquals(expectedReturn, actualReturn,\n            \"Datalength is not properly calculated\");\n    }\n\n    /**\n     * Tests getting the name.\n     */\n    @Test\n    public void testGetName()\n    {\n        assertEquals(\"CONNECTION-ID\", connectionIdAttribute.getName());\n    }\n\n    /**\n     * Tests the equals method against a null, a different and an identical\n     * object.\n     */\n    @Test\n    public void testEqualsObject()\n    {\n        // null test\n        assertNotEquals(connectionIdAttribute, null);\n\n        // difference test\n        ConnectionIdAttribute target = new ConnectionIdAttribute();\n\n        int connectionId = MsgFixture.CONNECTION_ID_2;\n        target.setConnectionIdValue(connectionId);\n\n        connectionIdAttribute.setConnectionIdValue(MsgFixture.CONNECTION_ID);\n        assertNotEquals(connectionIdAttribute, target,\n            \"ConnectionIdAttribute.equals() failed against a different target.\");\n\n        // equality test\n        target.setConnectionIdValue(MsgFixture.CONNECTION_ID);\n        assertEquals(connectionIdAttribute, target,\n            \"ConnectionIdAttribute.equals() failed against an equal target.\");\n    }\n\n    /**\n     * Test whether attributes are properly encoded.\n     */\n    @Test\n    public void testEncode()\n    {\n        byte[] expectedReturn = msgFixture.connectionId;\n        connectionIdAttribute.setConnectionIdValue(MsgFixture.CONNECTION_ID);\n        byte[] actualReturn = connectionIdAttribute.encode();\n\n        assertArrayEquals(expectedReturn, actualReturn,\n            \"ConnectionIdAttribute.encode() did not properly encode a sample attribute\");\n    }\n\n    /**\n     * Test whether sample binary arrays are correctly decoded.\n     * \n     * @throws StunException if something goes wrong while decoding \n     *             Attribute Body.\n     */\n    @Test\n    public void testDecodeAttributeBody() throws StunException\n    {\n        byte[] attributeValue = msgFixture.connectionId;\n        char offset = Attribute.HEADER_LENGTH;\n        char length = (char) (attributeValue.length - offset);\n\n        connectionIdAttribute.decodeAttributeBody(\n            attributeValue, offset, length);\n\n        assertEquals(\n            MsgFixture.CONNECTION_ID,\n            connectionIdAttribute.getConnectionIdValue(),\n            \"ConnectionIdAttribute.decode() did not properly decode the connection id field.\"\n        );\n    }\n\n    /**\n     * Tests that the connection Id is always integer.\n     */\n    @Test\n    public void testGetConnectionIdValue()\n    {\n        int expectedReturn = 0x5555;\n        this.connectionIdAttribute\n            .setConnectionIdValue(MsgFixture.CONNECTION_ID);\n        int actualReturn = this.connectionIdAttribute.getConnectionIdValue();\n        assertEquals(expectedReturn, actualReturn,\n            \"ConnectionId is not properly calculated\");\n\n        expectedReturn = 0x2222;\n        this.connectionIdAttribute\n            .setConnectionIdValue(MsgFixture.CONNECTION_ID_2);\n        actualReturn = this.connectionIdAttribute.getConnectionIdValue();\n        assertEquals(expectedReturn, actualReturn,\n            \"ConnectionId is not properly calculated\");\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private ConnectionIdAttribute connectionIdAttribute = null;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ConnectionIdAttribute", "name": "connectionIdAttribute = null", "syntax_pass": true}, {"attribute_expression": "private MsgFixture msgFixture;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "MsgFixture", "name": "msgFixture", "syntax_pass": true}]}, {"uris": "src/test/java/org/ice4j/attribute/UnknownAttributesAttribute_equalsTest.java.UnknownAttributesAttribute_equalsTest", "name": "UnknownAttributesAttribute_equalsTest", "file_path": "src/test/java/org/ice4j/attribute/UnknownAttributesAttribute_equalsTest.java", "superclasses": "", "methods": ["[void]testEquals_SameObject()", "[void]testEquals_DifferentType()", "[void]testEquals_DifferentAttributeType()", "[void]testEquals_DifferentDataLength()", "[void]testEquals_DifferentUnknownAttributes()", "[void]testEquals_SameAttributes()"], "method_uris": ["src/test/java/org/ice4j/attribute/UnknownAttributesAttribute_equalsTest.java.UnknownAttributesAttribute_equalsTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class UnknownAttributesAttribute_equalsTest {\n    private UnknownAttributesAttribute unknownAttributesAttribute;\n\n    @BeforeEach\n    public void setUp() throws Exception {\n        unknownAttributesAttribute = new UnknownAttributesAttribute();\n    }\n\n    @Test\n    public void testEquals_SameObject() {\n        assertTrue(unknownAttributesAttribute.equals(unknownAttributesAttribute));\n    }\n\n    @Test\n    public void testEquals_DifferentType() {\n        Object obj = new Object();\n        assertFalse(unknownAttributesAttribute.equals(obj));\n    }\n\n    @Test\n    public void testEquals_DifferentAttributeType() {\n        UnknownAttributesAttribute att = new UnknownAttributesAttribute();\n        att.addAttributeID((char) 1);\n        assertFalse(unknownAttributesAttribute.equals(att));\n    }\n\n    @Test\n    public void testEquals_DifferentDataLength() {\n        UnknownAttributesAttribute att = new UnknownAttributesAttribute();\n        att.addAttributeID((char) 1);\n        att.addAttributeID((char) 2);\n        assertFalse(unknownAttributesAttribute.equals(att));\n    }\n\n    @Test\n    public void testEquals_DifferentUnknownAttributes() {\n        UnknownAttributesAttribute att = new UnknownAttributesAttribute();\n        att.addAttributeID((char) 1);\n        att.addAttributeID((char) 2);\n        unknownAttributesAttribute.addAttributeID((char) 1);\n        assertFalse(unknownAttributesAttribute.equals(att));\n    }\n\n    @Test\n    public void testEquals_SameAttributes() {\n        UnknownAttributesAttribute att = new UnknownAttributesAttribute();\n        att.addAttributeID((char) 1);\n        att.addAttributeID((char) 2);\n        unknownAttributesAttribute.addAttributeID((char) 1);\n        unknownAttributesAttribute.addAttributeID((char) 2);\n        assertTrue(unknownAttributesAttribute.equals(att));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private UnknownAttributesAttribute unknownAttributesAttribute;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "UnknownAttributesAttribute", "name": "unknownAttributesAttribute", "syntax_pass": true}]}, {"uris": "src/test/java/org/ice4j/attribute/OptionalAttribute_equalsTest.java.OptionalAttribute_equalsTest", "name": "OptionalAttribute_equalsTest", "file_path": "src/test/java/org/ice4j/attribute/OptionalAttribute_equalsTest.java", "superclasses": "", "methods": ["[void]testEquals_SameObject()", "[void]testEquals_DifferentClass()", "[void]testEquals_DifferentAttributeValue()", "[void]testEquals_SameAttributeValue()"], "method_uris": ["src/test/java/org/ice4j/attribute/OptionalAttribute_equalsTest.java.OptionalAttribute_equalsTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class OptionalAttribute_equalsTest {\n    private OptionalAttribute optionalAttribute;\n    private MsgFixture msgFixture;\n    private byte[] expectedAttributeValue;\n\n    @BeforeEach\n    public void setUp() throws Exception {\n        msgFixture = new MsgFixture();\n        int offset = Attribute.HEADER_LENGTH;\n\n        // Init a sample body\n        expectedAttributeValue =\n            new byte[msgFixture.unknownOptionalAttribute.length - offset];\n\n        System.arraycopy(msgFixture.unknownOptionalAttribute, offset,\n                         expectedAttributeValue, 0,\n                         expectedAttributeValue.length);\n\n        optionalAttribute = new OptionalAttribute(\n                                        msgFixture.optionalAttributeType);\n        optionalAttribute.decodeAttributeBody(msgFixture.unknownOptionalAttribute,\n                                              (char)Attribute.HEADER_LENGTH,\n                                              (char)expectedAttributeValue.length);\n    }\n\n    @Test\n    public void testEquals_SameObject() {\n        assertTrue(optionalAttribute.equals(optionalAttribute),\n            \"An object should be equal to itself.\");\n    }\n\n    @Test\n    public void testEquals_DifferentClass() {\n        Object obj = new Object();\n        assertFalse(optionalAttribute.equals(obj),\n            \"An OptionalAttribute should not be equal to an object of a different class.\");\n    }\n\n    @Test\n    public void testEquals_DifferentAttributeValue() throws StunException {\n        OptionalAttribute otherAttribute = new OptionalAttribute(\n                                        msgFixture.optionalAttributeType);\n        otherAttribute.decodeAttributeBody(msgFixture.unknownOptionalAttribute,\n                                           (char)Attribute.HEADER_LENGTH,\n                                           (char)expectedAttributeValue.length);\n\n        // Modify the attributeValue of the otherAttribute\n        byte[] modifiedAttributeValue = new byte[expectedAttributeValue.length];\n        System.arraycopy(expectedAttributeValue, 0, modifiedAttributeValue, 0,\n                         expectedAttributeValue.length);\n        modifiedAttributeValue[0] = (byte)(modifiedAttributeValue[0] + 1);\n        otherAttribute.setBody(modifiedAttributeValue, 0, modifiedAttributeValue.length);\n\n        assertFalse(optionalAttribute.equals(otherAttribute),\n            \"OptionalAttributes with different attributeValues should not be equal.\");\n    }\n\n    @Test\n    public void testEquals_SameAttributeValue() throws StunException {\n        OptionalAttribute otherAttribute = new OptionalAttribute(\n                                        msgFixture.optionalAttributeType);\n        otherAttribute.decodeAttributeBody(msgFixture.unknownOptionalAttribute,\n                                           (char)Attribute.HEADER_LENGTH,\n                                           (char)expectedAttributeValue.length);\n\n        assertTrue(optionalAttribute.equals(otherAttribute),\n            \"OptionalAttributes with the same attributeValues should be equal.\");\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private OptionalAttribute optionalAttribute;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "OptionalAttribute", "name": "optionalAttribute", "syntax_pass": true}, {"attribute_expression": "private MsgFixture msgFixture;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "MsgFixture", "name": "msgFixture", "syntax_pass": true}, {"attribute_expression": "private byte[] expectedAttributeValue;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "byte[]", "name": "expectedAttributeValue", "syntax_pass": true}]}, {"uris": "src/test/java/org/ice4j/attribute/ChangeRequestAttribute_equalsTest.java.ChangeRequestAttribute_equalsTest", "name": "ChangeRequestAttribute_equalsTest", "file_path": "src/test/java/org/ice4j/attribute/ChangeRequestAttribute_equalsTest.java", "superclasses": "", "methods": ["[void]testEquals_SameObject()", "[void]testEquals_DifferentClass()", "[void]testEquals_DifferentChangeIpFlag()", "[void]testEquals_DifferentChangePortFlag()", "[void]testEquals_AllAttributesSame()"], "method_uris": ["src/test/java/org/ice4j/attribute/ChangeRequestAttribute_equalsTest.java.ChangeRequestAttribute_equalsTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class ChangeRequestAttribute_equalsTest {\n    private ChangeRequestAttribute changeRequestAttribute;\n\n    @BeforeEach\n    public void setUp() throws Exception {\n        changeRequestAttribute = new ChangeRequestAttribute();\n    }\n\n    @Test\n    public void testEquals_SameObject() {\n        assertEquals(changeRequestAttribute, changeRequestAttribute);\n    }\n\n    @Test\n    public void testEquals_DifferentClass() {\n        Object obj = new Object();\n        assertNotEquals(changeRequestAttribute, obj);\n    }\n\n    @Test\n    public void testEquals_DifferentChangeIpFlag() {\n        ChangeRequestAttribute target = new ChangeRequestAttribute();\n        changeRequestAttribute.setChangeIpFlag(true);\n        target.setChangeIpFlag(false);\n        assertNotEquals(changeRequestAttribute, target);\n    }\n\n    @Test\n    public void testEquals_DifferentChangePortFlag() {\n        ChangeRequestAttribute target = new ChangeRequestAttribute();\n        changeRequestAttribute.setChangePortFlag(true);\n        target.setChangePortFlag(false);\n        assertNotEquals(changeRequestAttribute, target);\n    }\n\n    @Test\n    public void testEquals_AllAttributesSame() {\n        ChangeRequestAttribute target = new ChangeRequestAttribute();\n        changeRequestAttribute.setChangeIpFlag(true);\n        changeRequestAttribute.setChangePortFlag(true);\n        target.setChangeIpFlag(true);\n        target.setChangePortFlag(true);\n        assertEquals(changeRequestAttribute, target);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private ChangeRequestAttribute changeRequestAttribute;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ChangeRequestAttribute", "name": "changeRequestAttribute", "syntax_pass": true}]}, {"uris": "src/test/java/org/ice4j/attribute/ErrorCodeAttribute_getDataLengthTest.java.ErrorCodeAttribute_getDataLengthTest", "name": "ErrorCodeAttribute_getDataLengthTest", "file_path": "src/test/java/org/ice4j/attribute/ErrorCodeAttribute_getDataLengthTest.java", "superclasses": "", "methods": ["[void]testGetDataLengthWithNullReasonPhrase()", "[void]testGetDataLengthWithReasonPhrase()", "[void]testGetDataLengthWithEmptyReasonPhrase()"], "method_uris": ["src/test/java/org/ice4j/attribute/ErrorCodeAttribute_getDataLengthTest.java.ErrorCodeAttribute_getDataLengthTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class ErrorCodeAttribute_getDataLengthTest {\n    private ErrorCodeAttribute errorCodeAttribute;\n\n    @BeforeEach\n    public void setUp() {\n        errorCodeAttribute = new ErrorCodeAttribute();\n    }\n\n    @Test\n    public void testGetDataLengthWithNullReasonPhrase() {\n        errorCodeAttribute.setErrorClass((byte) 4);\n        errorCodeAttribute.setErrorNumber((byte) 33);\n        assertEquals(4, errorCodeAttribute.getDataLength(), \"getDataLength() did not return the expected length with null reason phrase.\");\n    }\n\n    @Test\n    public void testGetDataLengthWithReasonPhrase() {\n        errorCodeAttribute.setErrorClass((byte) 4);\n        errorCodeAttribute.setErrorNumber((byte) 33);\n        errorCodeAttribute.setReasonPhrase(\"Test Reason Phrase\");\n        assertEquals(22, errorCodeAttribute.getDataLength(), \"getDataLength() did not return the expected length with non-null reason phrase.\");\n    }\n\n    @Test\n    public void testGetDataLengthWithEmptyReasonPhrase() {\n        errorCodeAttribute.setErrorClass((byte) 4);\n        errorCodeAttribute.setErrorNumber((byte) 33);\n        errorCodeAttribute.setReasonPhrase(\"\");\n        assertEquals(4, errorCodeAttribute.getDataLength(), \"getDataLength() did not return the expected length with empty reason phrase.\");\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private ErrorCodeAttribute errorCodeAttribute;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ErrorCodeAttribute", "name": "errorCodeAttribute", "syntax_pass": true}]}, {"uris": "src/test/java/org/ice4j/attribute/ErrorCodeAttribute_getDefaultReasonPhraseTest.java.ErrorCodeAttribute_getDefaultReasonPhraseTest", "name": "ErrorCodeAttribute_getDefaultReasonPhraseTest", "file_path": "src/test/java/org/ice4j/attribute/ErrorCodeAttribute_getDefaultReasonPhraseTest.java", "superclasses": "", "methods": ["[void]testGetDefaultReasonPhraseTryAlternate()", "[void]testGetDefaultReasonPhraseBadRequest()", "[void]testGetDefaultReasonPhraseUnauthorized()", "[void]testGetDefaultReasonPhraseForbidden()", "[void]testGetDefaultReasonPhraseUnknownAttribute()", "[void]testGetDefaultReasonPhraseStaleCredentials()", "[void]testGetDefaultReasonPhraseIntegrityCheckFailure()", "[void]testGetDefaultReasonPhraseMissingUsername()", "[void]testGetDefaultReasonPhraseUseTLS()", "[void]testGetDefaultReasonPhraseAllocationMismatch()", "[void]testGetDefaultReasonPhraseStaleNonce()", "[void]testGetDefaultReasonPhraseAddressFamilyNotSupported()", "[void]testGetDefaultReasonPhraseWrongCredentials()", "[void]testGetDefaultReasonPhraseUnsupportedTransportProtocol()", "[void]testGetDefaultReasonPhrasePeerAddressFamilyMismatch()", "[void]testGetDefaultReasonPhraseConnectionAlreadyExists()", "[void]testGetDefaultReasonPhraseConnectionTimeoutOrFailure()", "[void]testGetDefaultReasonPhraseAllocationQuotaReached()", "[void]testGetDefaultReasonPhraseServerError()", "[void]testGetDefaultReasonPhraseInsufficientCapacity()", "[void]testGetDefaultReasonPhraseGlobalFailure()", "[void]testGetDefaultReasonPhraseUnknownError()"], "method_uris": ["src/test/java/org/ice4j/attribute/ErrorCodeAttribute_getDefaultReasonPhraseTest.java.ErrorCodeAttribute_getDefaultReasonPhraseTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class ErrorCodeAttribute_getDefaultReasonPhraseTest {\n    private ErrorCodeAttribute errorCodeAttribute;\n\n    @BeforeEach\n    public void setUp() {\n        errorCodeAttribute = new ErrorCodeAttribute();\n    }\n\n    @Test\n    public void testGetDefaultReasonPhraseTryAlternate() {\n        assertEquals(\n            \"(Try Alternate): The server would like the client to\"\n            + \" use the server specified in the ALTERNATE-SERVER\"\n            + \" attribute instead.\",\n            ErrorCodeAttribute.getDefaultReasonPhrase(ErrorCodeAttribute.TRY_ALTERNATE)\n        );\n    }\n\n    @Test\n    public void testGetDefaultReasonPhraseBadRequest() {\n        assertEquals(\n            \"(Bad Request): The request was malformed.  The client\"\n            + \" should not retry the request without modification from\"\n            + \" the previous attempt.\",\n            ErrorCodeAttribute.getDefaultReasonPhrase(ErrorCodeAttribute.BAD_REQUEST)\n        );\n    }\n\n    @Test\n    public void testGetDefaultReasonPhraseUnauthorized() {\n        assertEquals(\n            \"(Unauthorized): The Binding Request did not contain\"\n            + \" a MESSAGE-INTEGRITY attribute.\",\n            ErrorCodeAttribute.getDefaultReasonPhrase(ErrorCodeAttribute.UNAUTHORIZED)\n        );\n    }\n\n    @Test\n    public void testGetDefaultReasonPhraseForbidden() {\n        assertEquals(\n            \"(Forbidden): The request was valid but cannot be\"\n            + \" performed due to administrative or similar\"\n            + \" restrictions.\",\n            ErrorCodeAttribute.getDefaultReasonPhrase(ErrorCodeAttribute.FORBIDDEN)\n        );\n    }\n\n    @Test\n    public void testGetDefaultReasonPhraseUnknownAttribute() {\n        assertEquals(\n            \"(Unknown Attribute): The server did not understand\"\n            + \" a mandatory attribute in the request.\",\n            ErrorCodeAttribute.getDefaultReasonPhrase(ErrorCodeAttribute.UNKNOWN_ATTRIBUTE)\n        );\n    }\n\n    @Test\n    public void testGetDefaultReasonPhraseStaleCredentials() {\n        assertEquals(\n            \"(Stale Credentials): The Binding Request did contain\"\n            + \" a MESSAGE-INTEGRITY attribute, but it used a shared\"\n            + \" secret that has expired.\",\n            ErrorCodeAttribute.getDefaultReasonPhrase(ErrorCodeAttribute.STALE_CREDENTIALS)\n        );\n    }\n\n    @Test\n    public void testGetDefaultReasonPhraseIntegrityCheckFailure() {\n        assertEquals(\n            \"(Integrity Check Failure): The Binding Request\"\n            + \" contained a MESSAGE-INTEGRITY attribute, but the HMAC\"\n            + \" failed verification.\",\n            ErrorCodeAttribute.getDefaultReasonPhrase(ErrorCodeAttribute.INTEGRITY_CHECK_FAILURE)\n        );\n    }\n\n    @Test\n    public void testGetDefaultReasonPhraseMissingUsername() {\n        assertEquals(\n            \"(Missing Username): The Binding Request contained\"\n            + \" a MESSAGE-INTEGRITY attribute, but not a USERNAME\"\n            + \" attribute.\",\n            ErrorCodeAttribute.getDefaultReasonPhrase(ErrorCodeAttribute.MISSING_USERNAME)\n        );\n    }\n\n    @Test\n    public void testGetDefaultReasonPhraseUseTLS() {\n        assertEquals(\n            \"(Use TLS): The Shared Secret request has to be sent\"\n            + \" over TLS, but was not received over TLS.\",\n            ErrorCodeAttribute.getDefaultReasonPhrase(ErrorCodeAttribute.USE_TLS)\n        );\n    }\n\n    @Test\n    public void testGetDefaultReasonPhraseAllocationMismatch() {\n        assertEquals(\n            \"(Allocation Mismatch): A request was received by the\"\n            + \" server that requires an allocation to be in place,\"\n            + \" but no allocation exists, or a request was received\"\n            + \" that requires no allocation, but an allocation exists.\",\n            ErrorCodeAttribute.getDefaultReasonPhrase(ErrorCodeAttribute.ALLOCATION_MISMATCH)\n        );\n    }\n\n    @Test\n    public void testGetDefaultReasonPhraseStaleNonce() {\n        assertEquals(\n            \"(Stale Nonce): See the procedures for the long-term\"\n            + \" credential mechanism.\",\n            ErrorCodeAttribute.getDefaultReasonPhrase(ErrorCodeAttribute.STALE_NONCE)\n        );\n    }\n\n    @Test\n    public void testGetDefaultReasonPhraseAddressFamilyNotSupported() {\n        assertEquals(\n            \"(Address Family not Supported):  The server does not\"\n            + \" support the address family requested by the client.\",\n            ErrorCodeAttribute.getDefaultReasonPhrase(ErrorCodeAttribute.ADDRESS_FAMILY_NOT_SUPPORTED)\n        );\n    }\n\n    @Test\n    public void testGetDefaultReasonPhraseWrongCredentials() {\n        assertEquals(\n            \"(Wrong Credentials): The credentials in the\"\n            + \" (non-Allocate) request do not match those used\"\n            + \" to create the allocation.\",\n            ErrorCodeAttribute.getDefaultReasonPhrase(ErrorCodeAttribute.WRONG_CREDENTIALS)\n        );\n    }\n\n    @Test\n    public void testGetDefaultReasonPhraseUnsupportedTransportProtocol() {\n        assertEquals(\n            \"(Unsupported Transport Protocol): The Allocate request\"\n            + \" asked the server to use a transport protocol between\"\n            + \" the server and the peer that the server does not\"\n            + \" support.\",\n            ErrorCodeAttribute.getDefaultReasonPhrase(ErrorCodeAttribute.UNSUPPORTED_TRANSPORT_PROTOCOL)\n        );\n    }\n\n    @Test\n    public void testGetDefaultReasonPhrasePeerAddressFamilyMismatch() {\n        assertEquals(\n            \"Peer Address Family Mismatch):  A peer address was of\"\n            + \" a different address family than that of the relayed\"\n            + \" transport address of the allocation.\",\n            ErrorCodeAttribute.getDefaultReasonPhrase(ErrorCodeAttribute.PEER_ADDRESS_FAMILY_MISMATCH)\n        );\n    }\n\n    @Test\n    public void testGetDefaultReasonPhraseConnectionAlreadyExists() {\n        assertEquals(\n            \"Connection Already Exists\",\n            ErrorCodeAttribute.getDefaultReasonPhrase(ErrorCodeAttribute.CONNECTION_ALREADY_EXISTS)\n        );\n    }\n\n    @Test\n    public void testGetDefaultReasonPhraseConnectionTimeoutOrFailure() {\n        assertEquals(\n            \"Connection Timeout or Failure\",\n            ErrorCodeAttribute.getDefaultReasonPhrase(ErrorCodeAttribute.CONNECTION_TIMEOUT_OR_FAILURE)\n        );\n    }\n\n    @Test\n    public void testGetDefaultReasonPhraseAllocationQuotaReached() {\n        assertEquals(\n            \"(Allocation Quota Reached): No more allocations using\"\n            + \" this username can be created at the present time.\",\n            ErrorCodeAttribute.getDefaultReasonPhrase(ErrorCodeAttribute.ALLOCATION_QUOTA_REACHED)\n        );\n    }\n\n    @Test\n    public void testGetDefaultReasonPhraseServerError() {\n        assertEquals(\n            \"(Server Error): The server has suffered a temporary\"\n            + \" error. The client should try again.\",\n            ErrorCodeAttribute.getDefaultReasonPhrase(ErrorCodeAttribute.SERVER_ERROR)\n        );\n    }\n\n    @Test\n    public void testGetDefaultReasonPhraseInsufficientCapacity() {\n        assertEquals(\n            \"(Insufficient Capacity): The server is unable to carry\"\n            + \" out the request due to some capacity limit being\"\n            + \" reached.\",\n            ErrorCodeAttribute.getDefaultReasonPhrase(ErrorCodeAttribute.INSUFFICIENT_CAPACITY)\n        );\n    }\n\n    @Test\n    public void testGetDefaultReasonPhraseGlobalFailure() {\n        assertEquals(\n            \"(Global Failure:) The server is refusing to fulfill\"\n            + \" the request. The client should not retry.\",\n            ErrorCodeAttribute.getDefaultReasonPhrase(ErrorCodeAttribute.GLOBAL_FAILURE)\n        );\n    }\n\n    @Test\n    public void testGetDefaultReasonPhraseUnknownError() {\n        assertEquals(\n            \"Unknown Error\",\n            ErrorCodeAttribute.getDefaultReasonPhrase((char)999)\n        );\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private ErrorCodeAttribute errorCodeAttribute;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ErrorCodeAttribute", "name": "errorCodeAttribute", "syntax_pass": true}]}, {"uris": "src/test/java/org/ice4j/attribute/ChangeRequestAttributeTest.java.ChangeRequestAttributeTest", "name": "ChangeRequestAttributeTest", "file_path": "src/test/java/org/ice4j/attribute/ChangeRequestAttributeTest.java", "superclasses": "", "methods": ["[void]testChangeRequestAttribute()", "[void]testDecodeAttributeBody()", "[void]testEncode()", "[void]testEquals()", "[void]testGetDataLength()", "[void]testGetName()"], "method_uris": ["src/test/java/org/ice4j/attribute/ChangeRequestAttributeTest.java.ChangeRequestAttributeTest.[void]setUp()", "src/test/java/org/ice4j/attribute/ChangeRequestAttributeTest.java.ChangeRequestAttributeTest.[void]tearDown()"], "overrides": null, "attributes": [], "class_docstring": "\nTests the CHANGE-REQUEST attribute class.\n\n@author Emil Ivov\n", "original_string": "public class ChangeRequestAttributeTest\n{\n    private ChangeRequestAttribute changeRequestAttribute = null;\n    private MsgFixture binMessagesFixture;\n\n    @BeforeEach\n    public void setUp() throws Exception\n    {\n        changeRequestAttribute = new ChangeRequestAttribute();\n        binMessagesFixture = new MsgFixture();\n    }\n\n    @AfterEach\n    public void tearDown() throws Exception\n    {\n        changeRequestAttribute = null;\n        binMessagesFixture = null;\n    }\n\n    /**\n     * Test whether the constructed object has the proper type.\n     */\n    @Test\n    public void testChangeRequestAttribute()\n    {\n        changeRequestAttribute = new ChangeRequestAttribute();\n\n        assertEquals(\n            changeRequestAttribute.getAttributeType(),\n            Attribute.CHANGE_REQUEST,\n            \"ChangeRequestAttribute did not construct an attribute with the correct type.\"\n        );\n\n    }\n\n    /**\n     * Test whether sample binary arrays are properly decoded.\n     *\n     * @throws StunException java.lang.Exception if we fail\n     */\n    @Test\n    public void testDecodeAttributeBody()\n        throws StunException\n    {\n        byte[] attributeValue = binMessagesFixture.chngReqTestValue1;\n        char offset = Attribute.HEADER_LENGTH;\n        char length = (char)(attributeValue.length - offset);\n        changeRequestAttribute.decodeAttributeBody(attributeValue, offset, length);\n\n        assertEquals(\n            MsgFixture.CHANGE_IP_FLAG_1,\n            changeRequestAttribute.getChangeIpFlag(),\n            \"decodeAttributeBody() did not properly decode the changeIpFlag\"\n        );\n        assertEquals(\n            MsgFixture.CHANGE_PORT_FLAG_1,\n            changeRequestAttribute.getChangePortFlag(),\n            \"decodeAttributeBody() did not properly decode the changePortFlag\"\n        );\n\n        //2nd sample\n        attributeValue = binMessagesFixture.chngReqTestValue2;\n        changeRequestAttribute\n            .decodeAttributeBody(attributeValue, offset, length);\n        assertEquals(\n            MsgFixture.CHANGE_IP_FLAG_2,\n            changeRequestAttribute.getChangeIpFlag(),\n            \"decodeAttributeBody() did not properly decode the changeIpFlag\"\n        );\n        assertEquals(\n            MsgFixture.CHANGE_PORT_FLAG_2,\n            changeRequestAttribute.getChangePortFlag(),\n            \"decodeAttributeBody() did not properly decode the changePortFlag\"\n        );\n\n        changeRequestAttribute.getChangePortFlag();\n    }\n\n    /**\n     * Create sample objects and test whether they encode properly.\n     */\n    @Test\n    public void testEncode()\n    {\n        byte[] expectedReturn = binMessagesFixture.chngReqTestValue1;\n\n        changeRequestAttribute = new ChangeRequestAttribute();\n\n        changeRequestAttribute.setChangeIpFlag(MsgFixture.CHANGE_IP_FLAG_1);\n        changeRequestAttribute.setChangePortFlag(MsgFixture.CHANGE_PORT_FLAG_1);\n\n        byte[] actualReturn = changeRequestAttribute.encode();\n        assertArrayEquals(expectedReturn, actualReturn,\n            \"Object did not encode properly.\");\n\n        //2nd test\n        expectedReturn = binMessagesFixture.chngReqTestValue2;\n        changeRequestAttribute = new ChangeRequestAttribute();\n\n        changeRequestAttribute.setChangeIpFlag(MsgFixture.CHANGE_IP_FLAG_2);\n        changeRequestAttribute.setChangePortFlag(MsgFixture.CHANGE_PORT_FLAG_2);\n\n        actualReturn = changeRequestAttribute.encode();\n        assertArrayEquals(expectedReturn, actualReturn,\n            \"Object did not encode properly.\");\n    }\n\n    /**\n     * Tests the equals method against a null, a different and an identical\n     * object.\n     */\n    @Test\n    public void testEquals()\n    {\n        //null test\n        assertNotEquals(changeRequestAttribute, null);\n\n        //test against a different object.\n        ChangeRequestAttribute target = new ChangeRequestAttribute();\n\n        changeRequestAttribute.setChangeIpFlag(true);\n        changeRequestAttribute.setChangePortFlag(false);\n\n        target.setChangeIpFlag(false);\n        target.setChangePortFlag(true);\n\n        assertNotEquals(changeRequestAttribute, target);\n\n        //test against an equal value\n        target = new ChangeRequestAttribute();\n\n        changeRequestAttribute.setChangeIpFlag(true);\n        changeRequestAttribute.setChangePortFlag(false);\n\n        target.setChangeIpFlag(true);\n        target.setChangePortFlag(false);\n        assertEquals(changeRequestAttribute, target);\n    }\n\n    /**\n     * Test whether the returned value is always 4.\n     */\n    @Test\n    public void testGetDataLength()\n    {\n        char expectedReturn = 4; // constant 4 bytes of data\n        char actualReturn = changeRequestAttribute.getDataLength();\n        assertEquals(expectedReturn, actualReturn,\n            \"data length returned an invalid value\");\n    }\n\n    /**\n     * Test whether we get a relevant name.\n     */\n    @Test\n    public void testGetName()\n    {\n        assertEquals(\"CHANGE-REQUEST\", changeRequestAttribute.getName());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private ChangeRequestAttribute changeRequestAttribute = null;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ChangeRequestAttribute", "name": "changeRequestAttribute = null", "syntax_pass": true}, {"attribute_expression": "private MsgFixture binMessagesFixture;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "MsgFixture", "name": "binMessagesFixture", "syntax_pass": true}]}, {"uris": "src/test/java/org/ice4j/attribute/UsernameAttribute_equalsTest.java.UsernameAttribute_equalsTest", "name": "UsernameAttribute_equalsTest", "file_path": "src/test/java/org/ice4j/attribute/UsernameAttribute_equalsTest.java", "superclasses": "", "methods": ["[void]testEquals_SameObject()", "[void]testEquals_DifferentObjectType()", "[void]testEquals_DifferentUsername()", "[void]testEquals_SameUsername()", "[void]testEquals_DifferentAttributeType()", "[void]testEquals_DifferentDataLength()"], "method_uris": ["src/test/java/org/ice4j/attribute/UsernameAttribute_equalsTest.java.UsernameAttribute_equalsTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class UsernameAttribute_equalsTest {\n    private UsernameAttribute usernameAttribute;\n    private String usernameValue;\n\n    @BeforeEach\n    public void setUp() throws Exception {\n        usernameValue = \"testUsername\";\n        usernameAttribute = new UsernameAttribute();\n        usernameAttribute.setUsername(usernameValue.getBytes());\n    }\n\n    @Test\n    public void testEquals_SameObject() {\n        assertTrue(usernameAttribute.equals(usernameAttribute));\n    }\n\n    @Test\n    public void testEquals_DifferentObjectType() {\n        assertFalse(usernameAttribute.equals(new Object()));\n    }\n\n    @Test\n    public void testEquals_DifferentUsername() {\n        UsernameAttribute differentUsernameAttribute = new UsernameAttribute();\n        differentUsernameAttribute.setUsername(\"differentUsername\".getBytes());\n        assertFalse(usernameAttribute.equals(differentUsernameAttribute));\n    }\n\n    @Test\n    public void testEquals_SameUsername() {\n        UsernameAttribute sameUsernameAttribute = new UsernameAttribute();\n        sameUsernameAttribute.setUsername(usernameValue.getBytes());\n        assertTrue(usernameAttribute.equals(sameUsernameAttribute));\n    }\n\n    @Test\n    public void testEquals_DifferentAttributeType() {\n        UsernameAttribute differentTypeAttribute = new UsernameAttribute() {\n            @Override\n            public char getAttributeType() {\n                return (char) (super.getAttributeType() + 1);\n            }\n        };\n        differentTypeAttribute.setUsername(usernameValue.getBytes());\n        assertFalse(usernameAttribute.equals(differentTypeAttribute));\n    }\n\n    @Test\n    public void testEquals_DifferentDataLength() {\n        UsernameAttribute differentLengthAttribute = new UsernameAttribute();\n        differentLengthAttribute.setUsername(\"short\".getBytes());\n        assertFalse(usernameAttribute.equals(differentLengthAttribute));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private UsernameAttribute usernameAttribute;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "UsernameAttribute", "name": "usernameAttribute", "syntax_pass": true}, {"attribute_expression": "private String usernameValue;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "usernameValue", "syntax_pass": true}]}, {"uris": "src/test/java/org/ice4j/attribute/ConnectionIdAttribute_getDataLengthTest.java.ConnectionIdAttribute_getDataLengthTest", "name": "ConnectionIdAttribute_getDataLengthTest", "file_path": "src/test/java/org/ice4j/attribute/ConnectionIdAttribute_getDataLengthTest.java", "superclasses": "", "methods": ["[void]testGetDataLength()", "[void]testEquals()", "[void]testEncode()", "[void]testDecodeAttributeBody()"], "method_uris": ["src/test/java/org/ice4j/attribute/ConnectionIdAttribute_getDataLengthTest.java.ConnectionIdAttribute_getDataLengthTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class ConnectionIdAttribute_getDataLengthTest {\n    private ConnectionIdAttribute connectionIdAttribute;\n    private MsgFixture msgFixture;\n\n    @BeforeEach\n    public void setUp() throws Exception {\n        this.connectionIdAttribute = new ConnectionIdAttribute();\n        this.msgFixture = new MsgFixture();\n    }\n\n    @Test\n    public void testGetDataLength() {\n        assertEquals(4, connectionIdAttribute.getDataLength(), \"Data length should be 4 bytes.\");\n    }\n\n    @Test\n    public void testEquals() {\n        ConnectionIdAttribute other = new ConnectionIdAttribute();\n        assertTrue(connectionIdAttribute.equals(other), \"Attributes should be equal.\");\n    }\n\n    @Test\n    public void testEncode() {\n        byte[] encoded = connectionIdAttribute.encode();\n        assertEquals(8, encoded.length, \"Encoded length should be 8 bytes.\");\n    }\n\n    @Test\n    public void testDecodeAttributeBody() throws StunException {\n        byte[] attributeValue = msgFixture.connectionId;\n        char offset = Attribute.HEADER_LENGTH;\n        char length = (char) (attributeValue.length - offset);\n\n        connectionIdAttribute.decodeAttributeBody(attributeValue, offset, length);\n\n        assertEquals(MsgFixture.CONNECTION_ID, connectionIdAttribute.getConnectionIdValue(), \"ConnectionIdAttribute.decode() did not properly decode the connection id field.\");\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private ConnectionIdAttribute connectionIdAttribute;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ConnectionIdAttribute", "name": "connectionIdAttribute", "syntax_pass": true}, {"attribute_expression": "private MsgFixture msgFixture;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "MsgFixture", "name": "msgFixture", "syntax_pass": true}]}, {"uris": "src/test/java/org/ice4j/attribute/XorOnlyAttribute_equalsTest.java.XorOnlyAttribute_equalsTest", "name": "XorOnlyAttribute_equalsTest", "file_path": "src/test/java/org/ice4j/attribute/XorOnlyAttribute_equalsTest.java", "superclasses": "", "methods": ["[void]testEquals_SameInstance()", "[void]testEquals_DifferentType()", "[void]testEquals_DifferentAttributeType()", "[void]testEquals_DifferentDataLength()", "[void]testEquals_SameAttributes()"], "method_uris": ["src/test/java/org/ice4j/attribute/XorOnlyAttribute_equalsTest.java.XorOnlyAttribute_equalsTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class XorOnlyAttribute_equalsTest {\n    private XorOnlyAttribute xorOnly;\n\n    @BeforeEach\n    public void setUp() {\n        xorOnly = new XorOnlyAttribute();\n    }\n\n    @Test\n    public void testEquals_SameInstance() {\n        assertTrue(xorOnly.equals(xorOnly));\n    }\n\n    @Test\n    public void testEquals_DifferentType() {\n        Object obj = new Object();\n        assertFalse(xorOnly.equals(obj));\n    }\n\n    @Test\n    public void testEquals_DifferentAttributeType() {\n        XorOnlyAttribute differentType = new XorOnlyAttribute() {\n            @Override\n            public char getAttributeType() {\n                return (char) 0x0002; // Replace with a valid attribute type constant\n            }\n        };\n        assertFalse(xorOnly.equals(differentType));\n    }\n\n    @Test\n    public void testEquals_DifferentDataLength() {\n        XorOnlyAttribute differentLength = new XorOnlyAttribute() {\n            @Override\n            public char getDataLength() {\n                return 1;\n            }\n        };\n        assertFalse(xorOnly.equals(differentLength));\n    }\n\n    @Test\n    public void testEquals_SameAttributes() {\n        XorOnlyAttribute sameAttributes = new XorOnlyAttribute();\n        assertTrue(xorOnly.equals(sameAttributes));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private XorOnlyAttribute xorOnly;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "XorOnlyAttribute", "name": "xorOnly", "syntax_pass": true}]}, {"uris": "src/test/java/org/ice4j/attribute/SoftwareAttribute_equalsTest.java.SoftwareAttribute_equalsTest", "name": "SoftwareAttribute_equalsTest", "file_path": "src/test/java/org/ice4j/attribute/SoftwareAttribute_equalsTest.java", "superclasses": "", "methods": ["[void]testEquals_SameObject()", "[void]testEquals_DifferentType()", "[void]testEquals_DifferentSoftware()", "[void]testEquals_DifferentLength()", "[void]testEquals_DifferentAttributeType()", "[void]testEquals_EqualAttributes()"], "method_uris": ["src/test/java/org/ice4j/attribute/SoftwareAttribute_equalsTest.java.SoftwareAttribute_equalsTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class SoftwareAttribute_equalsTest {\n    private SoftwareAttribute softwareAttribute1;\n    private SoftwareAttribute softwareAttribute2;\n    private String softwareValue;\n\n    @BeforeEach\n    public void setUp() {\n        softwareValue = \"TestSoftware\";\n        softwareAttribute1 = new SoftwareAttribute();\n        softwareAttribute1.setSoftware(softwareValue.getBytes());\n        softwareAttribute2 = new SoftwareAttribute();\n        softwareAttribute2.setSoftware(softwareValue.getBytes());\n    }\n\n    @Test\n    public void testEquals_SameObject() {\n        assertTrue(softwareAttribute1.equals(softwareAttribute1));\n    }\n\n    @Test\n    public void testEquals_DifferentType() {\n        assertFalse(softwareAttribute1.equals(\"NotASoftwareAttribute\"));\n    }\n\n    @Test\n    public void testEquals_DifferentSoftware() {\n        softwareAttribute2.setSoftware(\"DifferentSoftware\".getBytes());\n        assertFalse(softwareAttribute1.equals(softwareAttribute2));\n    }\n\n    @Test\n    public void testEquals_DifferentLength() {\n        softwareAttribute2.setSoftware(\"Test\".getBytes());\n        assertFalse(softwareAttribute1.equals(softwareAttribute2));\n    }\n\n    @Test\n    public void testEquals_DifferentAttributeType() {\n        softwareAttribute2 = new SoftwareAttribute() {\n            @Override\n            public char getAttributeType() {\n                return (char) (super.getAttributeType() + 1);\n            }\n        };\n        softwareAttribute2.setSoftware(softwareValue.getBytes());\n        assertFalse(softwareAttribute1.equals(softwareAttribute2));\n    }\n\n    @Test\n    public void testEquals_EqualAttributes() {\n        assertTrue(softwareAttribute1.equals(softwareAttribute2));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private SoftwareAttribute softwareAttribute1;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "SoftwareAttribute", "name": "softwareAttribute1", "syntax_pass": true}, {"attribute_expression": "private SoftwareAttribute softwareAttribute2;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "SoftwareAttribute", "name": "softwareAttribute2", "syntax_pass": true}, {"attribute_expression": "private String softwareValue;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "softwareValue", "syntax_pass": true}]}, {"uris": "src/test/java/org/ice4j/attribute/NonceAttributeTest.java.NonceAttributeTest", "name": "NonceAttributeTest", "file_path": "src/test/java/org/ice4j/attribute/NonceAttributeTest.java", "superclasses": "", "methods": ["[void]testDecodeAttributeBody()", "[void]testEncode()", "[void]testEquals()", "[void]testGetDataLength()", "[void]testGetName()", "[void]testSetGetNonce()"], "method_uris": ["src/test/java/org/ice4j/attribute/NonceAttributeTest.java.NonceAttributeTest.[void]setUp()", "src/test/java/org/ice4j/attribute/NonceAttributeTest.java.NonceAttributeTest.[void]tearDown()"], "overrides": null, "attributes": [], "class_docstring": "\nTests the nonce attribute class.\n\n@author Emil Ivov\n@author Sebastien Vincent\n", "original_string": "public class NonceAttributeTest\n{\n    private NonceAttribute nonceAttribute = null;\n    MsgFixture msgFixture = null;\n    String nonceValue = \"0123456789abcdef\";\n    byte[] attributeBinValue = new byte[]{\n            (byte)(NonceAttribute.NONCE>>8),\n            (byte)(NonceAttribute.NONCE & 0x00FF),\n            0, (byte)nonceValue.length(),\n            '0', '1', '2', '3', '4', '5', '6','7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};\n\n    @BeforeEach\n    public void setUp() throws Exception\n    {\n        msgFixture = new MsgFixture();\n        nonceAttribute = new NonceAttribute();\n        nonceAttribute.setNonce(nonceValue.getBytes());\n    }\n\n    @AfterEach\n    public void tearDown() throws Exception\n    {\n        nonceAttribute = null;\n        msgFixture = null;\n    }\n\n    /**\n     * Tests decoding of the nonce attribute.\n     * @throws StunException upon a failure\n     */\n    @Test\n    public void testDecodeAttributeBody() throws StunException\n    {\n        char offset = 0;\n        NonceAttribute decoded = new NonceAttribute();\n        char length = (char)nonceValue.length();\n        decoded.decodeAttributeBody(nonceValue.getBytes(), offset, length);\n\n        //nonce value\n        assertEquals(nonceAttribute, decoded, \"decode failed\");\n    }\n\n    /**\n     * Tests the encode method\n     */\n    @Test\n    public void testEncode()\n    {\n        assertArrayEquals(nonceAttribute.encode(), attributeBinValue,\n            \"encode failed\");\n    }\n\n    /**\n     * Test Equals\n     */\n    @Test\n    public void testEquals()\n    {\n        NonceAttribute nonceAttribute2 = new NonceAttribute();\n        nonceAttribute2.setNonce(nonceValue.getBytes());\n\n        //test positive equals\n        assertEquals(nonceAttribute, nonceAttribute2);\n\n        //test negative equals\n        nonceAttribute2 = new NonceAttribute();\n        nonceAttribute2.setNonce(\"some other nonce\".getBytes());\n\n        //test positive equals\n        assertNotEquals(nonceAttribute2, nonceAttribute);\n\n        //test null equals\n        assertNotEquals(nonceAttribute, null);\n    }\n\n    /**\n     * Tests extracting data length\n     */\n    @Test\n    public void testGetDataLength()\n    {\n        char expectedReturn = (char)nonceValue.length();\n        char actualReturn = nonceAttribute.getDataLength();\n        assertEquals(expectedReturn, actualReturn);\n    }\n\n    /**\n     * Tests getting the name\n     */\n    @Test\n    public void testGetName()\n    {\n        assertEquals(\"NONCE\", nonceAttribute.getName());\n    }\n\n    @Test\n    public void testSetGetNonce()\n    {\n        byte[] expectedReturn = nonceValue.getBytes();\n\n        NonceAttribute att = new NonceAttribute();\n        att.setNonce(expectedReturn);\n\n        byte[] actualReturn = att.getNonce();\n        assertArrayEquals(expectedReturn, actualReturn,\n            \"nonce setter or getter failed\");\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private NonceAttribute nonceAttribute = null;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "NonceAttribute", "name": "nonceAttribute = null", "syntax_pass": true}, {"attribute_expression": "MsgFixture msgFixture = null;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "MsgFixture", "name": "msgFixture = null", "syntax_pass": true}, {"attribute_expression": "String nonceValue = \"0123456789abcdef\";", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "String", "name": "nonceValue = \"0123456789abcdef\"", "syntax_pass": true}, {"attribute_expression": "byte[] attributeBinValue = new byte[]{\n            (byte)(NonceAttribute.NONCE>>8),\n            (byte)(NonceAttribute.NONCE & 0x00FF),\n            0, (byte)nonceValue.length(),\n            '0', '1', '2', '3', '4', '5', '6','7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "byte[]", "name": "attributeBinValue = new byte[]{\n            (byte)(NonceAttribute.NONCE>>8),\n            (byte)(NonceAttribute.NONCE & 0x00FF),\n            0, (byte)nonceValue.length(),\n            '0', '1', '2', '3', '4', '5', '6','7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'}", "syntax_pass": true}]}, {"uris": "src/test/java/org/ice4j/attribute/NonceAttribute_equalsTest.java.NonceAttribute_equalsTest", "name": "NonceAttribute_equalsTest", "file_path": "src/test/java/org/ice4j/attribute/NonceAttribute_equalsTest.java", "superclasses": "", "methods": ["[void]testEqualsSameObject()", "[void]testEqualsDifferentType()", "[void]testEqualsDifferentNonce()", "[void]testEqualsSameNonce()", "[void]testEqualsDifferentAttributeType()", "[void]testEqualsDifferentDataLength()"], "method_uris": ["src/test/java/org/ice4j/attribute/NonceAttribute_equalsTest.java.NonceAttribute_equalsTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class NonceAttribute_equalsTest {\n\n    private NonceAttribute nonceAttribute;\n    private byte[] nonceValue;\n\n    @BeforeEach\n    public void setUp() {\n        nonceAttribute = new NonceAttribute();\n        nonceValue = \"testNonce\".getBytes();\n        nonceAttribute.setNonce(nonceValue);\n    }\n\n    @Test\n    public void testEqualsSameObject() {\n        assertTrue(nonceAttribute.equals(nonceAttribute), \"An object should be equal to itself\");\n    }\n\n    @Test\n    public void testEqualsDifferentType() {\n        Object obj = new Object();\n        assertFalse(nonceAttribute.equals(obj), \"An object of different type should not be equal\");\n    }\n\n    @Test\n    public void testEqualsDifferentNonce() {\n        NonceAttribute differentNonceAttribute = new NonceAttribute();\n        differentNonceAttribute.setNonce(\"differentNonce\".getBytes());\n        assertFalse(nonceAttribute.equals(differentNonceAttribute), \"Attributes with different nonce values should not be equal\");\n    }\n\n    @Test\n    public void testEqualsSameNonce() {\n        NonceAttribute sameNonceAttribute = new NonceAttribute();\n        sameNonceAttribute.setNonce(nonceValue);\n        assertTrue(nonceAttribute.equals(sameNonceAttribute), \"Attributes with the same nonce values should be equal\");\n    }\n\n    @Test\n    public void testEqualsDifferentAttributeType() {\n        NonceAttribute differentTypeAttribute = new NonceAttribute() {\n            @Override\n            public char getAttributeType() {\n                return (char) (super.getAttributeType() + 1);\n            }\n        };\n        differentTypeAttribute.setNonce(nonceValue);\n        assertFalse(nonceAttribute.equals(differentTypeAttribute), \"Attributes with different attribute types should not be equal\");\n    }\n\n    @Test\n    public void testEqualsDifferentDataLength() {\n        NonceAttribute differentLengthAttribute = new NonceAttribute();\n        differentLengthAttribute.setNonce(\"test\".getBytes());\n        assertFalse(nonceAttribute.equals(differentLengthAttribute), \"Attributes with different data lengths should not be equal\");\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private NonceAttribute nonceAttribute;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "NonceAttribute", "name": "nonceAttribute", "syntax_pass": true}, {"attribute_expression": "private byte[] nonceValue;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "byte[]", "name": "nonceValue", "syntax_pass": true}]}, {"uris": "src/test/java/org/ice4j/attribute/UsernameAttributeTest.java.UsernameAttributeTest", "name": "UsernameAttributeTest", "file_path": "src/test/java/org/ice4j/attribute/UsernameAttributeTest.java", "superclasses": "", "methods": ["[void]testDecodeAttributeBody()", "[void]testEncode()", "[void]testEquals()", "[void]testGetDataLength()", "[void]testGetName()", "[void]testSetGetUsername()"], "method_uris": ["src/test/java/org/ice4j/attribute/UsernameAttributeTest.java.UsernameAttributeTest.[void]setUp()", "src/test/java/org/ice4j/attribute/UsernameAttributeTest.java.UsernameAttributeTest.[void]tearDown()"], "overrides": null, "attributes": [], "class_docstring": "\nTests the username attribute class.\n\n@author Emil Ivov\n@author Sebastien Vincent\n", "original_string": "public class UsernameAttributeTest\n{\n    private UsernameAttribute usernameAttribute = null;\n    MsgFixture msgFixture = null;\n    String usernameValue = \"username\";\n    byte[] attributeBinValue = new byte[]{\n            (byte)(UsernameAttribute.USERNAME>>8),\n            (byte)(UsernameAttribute.USERNAME & 0x00FF),\n            0, (byte)usernameValue.length(),\n            'u', 's', 'e', 'r', 'n', 'a', 'm','e'};\n\n    @BeforeEach\n    public void setUp() throws Exception\n    {\n        msgFixture = new MsgFixture();\n\n        usernameAttribute = new UsernameAttribute();\n        usernameAttribute.setUsername(usernameValue.getBytes());\n    }\n\n    @AfterEach\n    public void tearDown() throws Exception\n    {\n        usernameAttribute = null;\n        msgFixture = null;\n    }\n\n    /**\n     * Tests decoding of the username attribute.\n     * @throws StunException upon a failure\n     */\n    @Test\n    public void testDecodeAttributeBody() throws StunException\n    {\n        char offset = 0;\n        UsernameAttribute decoded = new UsernameAttribute();\n        char length = (char)usernameValue.length();\n        decoded.decodeAttributeBody(usernameValue.getBytes(), offset, length);\n\n        //username value\n        assertEquals(usernameAttribute, decoded);\n    }\n\n    /**\n     * Tests the encode method\n     */\n    @Test\n    public void testEncode()\n    {\n        assertArrayEquals(usernameAttribute.encode(), attributeBinValue);\n    }\n\n    /**\n     * Test Equals\n     */\n    @Test\n    public void testEquals()\n    {\n        UsernameAttribute usernameAttribute2 = new UsernameAttribute();\n        usernameAttribute2.setUsername(usernameValue.getBytes());\n\n        //test positive equals\n        assertEquals(usernameAttribute, usernameAttribute2);\n\n        //test negative equals\n        usernameAttribute2 = new UsernameAttribute();\n        usernameAttribute2.setUsername(\"some other username\".getBytes());\n\n        //test positive equals\n        assertNotEquals(usernameAttribute2, usernameAttribute);\n\n        //test null equals\n        assertNotEquals(usernameAttribute, null);\n    }\n\n    /**\n     * Tests extracting data length\n     */\n    @Test\n    public void testGetDataLength()\n    {\n        char expectedReturn = (char)usernameValue.length();\n        char actualReturn = usernameAttribute.getDataLength();\n        assertEquals(expectedReturn, actualReturn);\n    }\n\n    /**\n     * Tests getting the name\n     */\n    @Test\n    public void testGetName()\n    {\n        assertEquals(\"USERNAME\", usernameAttribute.getName());\n    }\n\n    @Test\n    public void testSetGetUsername()\n    {\n        byte[] expectedReturn = usernameValue.getBytes();\n\n        UsernameAttribute att = new UsernameAttribute();\n        att.setUsername(expectedReturn);\n\n        byte[] actualReturn = att.getUsername();\n        assertArrayEquals(expectedReturn, actualReturn,\n            \"username setter or getter failed\");\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private UsernameAttribute usernameAttribute = null;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "UsernameAttribute", "name": "usernameAttribute = null", "syntax_pass": true}, {"attribute_expression": "MsgFixture msgFixture = null;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "MsgFixture", "name": "msgFixture = null", "syntax_pass": true}, {"attribute_expression": "String usernameValue = \"username\";", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "String", "name": "usernameValue = \"username\"", "syntax_pass": true}, {"attribute_expression": "byte[] attributeBinValue = new byte[]{\n            (byte)(UsernameAttribute.USERNAME>>8),\n            (byte)(UsernameAttribute.USERNAME & 0x00FF),\n            0, (byte)usernameValue.length(),\n            'u', 's', 'e', 'r', 'n', 'a', 'm','e'};", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "byte[]", "name": "attributeBinValue = new byte[]{\n            (byte)(UsernameAttribute.USERNAME>>8),\n            (byte)(UsernameAttribute.USERNAME & 0x00FF),\n            0, (byte)usernameValue.length(),\n            'u', 's', 'e', 'r', 'n', 'a', 'm','e'}", "syntax_pass": true}]}, {"uris": "src/test/java/org/ice4j/attribute/XorOnlyTest.java.XorOnlyTest", "name": "XorOnlyTest", "file_path": "src/test/java/org/ice4j/attribute/XorOnlyTest.java", "superclasses": "", "methods": ["[void]testDecodeAttributeBody()", "[void]testEncode()", "[void]testEquals()", "[void]testGetDataLength()", "[void]testGetName()"], "method_uris": ["src/test/java/org/ice4j/attribute/XorOnlyTest.java.XorOnlyTest.[void]setUp()", "src/test/java/org/ice4j/attribute/XorOnlyTest.java.XorOnlyTest.[void]tearDown()"], "overrides": null, "attributes": [], "class_docstring": "\n@author Emil Ivov\n", "original_string": "public class XorOnlyTest\n{\n    private XorOnlyAttribute xorOnly = null;\n    private MsgFixture msgFixture = null;\n\n    @BeforeEach\n    public void setUp() throws Exception\n    {\n        xorOnly = new XorOnlyAttribute();\n        msgFixture = new MsgFixture();\n    }\n\n    @AfterEach\n    public void tearDown() throws Exception\n    {\n        xorOnly = null;\n        msgFixture = null;\n    }\n\n    /**\n     * Just makes sure that no exceptions are thrown when calling it as the\n     * decode method doesn't do anything in the XorOnly att.\n     * @throws StunException if sth happens\n     */\n    @Test\n    public void testDecodeAttributeBody() throws StunException\n    {\n        byte[] attributeValue = new byte[]{};\n        char offset = 0;\n        char length = 0;\n        xorOnly.decodeAttributeBody(attributeValue, offset, length);\n    }\n\n    /**\n     * Test encoding XorOnly attributes.\n     */\n    @Test\n    public void testEncode()\n    {\n        byte[] expectedReturn = new byte[]{Attribute.XOR_ONLY>>8,\n                                           Attribute.XOR_ONLY&0x00FF,\n                                            0, 0};\n        byte[] actualReturn = xorOnly.encode();\n        assertArrayEquals(expectedReturn, actualReturn);\n    }\n\n    /**\n     * Test positive and negative XorOnly.equals() returns\n     * @throws Exception if decoding fails\n     */\n    @Test\n    public void testEquals() throws Exception\n    {\n        XorOnlyAttribute xor2 = new XorOnlyAttribute();\n        assertEquals(xorOnly, xor2);\n\n        MappedAddressAttribute maatt =  new MappedAddressAttribute();\n        maatt.decodeAttributeBody( msgFixture.mappedAddress,\n                                   (char) 0,\n                                   (char) msgFixture.mappedAddress.length );\n\n        assertNotEquals(maatt, xorOnly);\n        assertNotEquals(xorOnly, null);\n    }\n\n    /**\n     * Makes sure the data langth is 0\n     */\n    @Test\n    public void testGetDataLength()\n    {\n        char expectedReturn = 0;\n        char actualReturn = xorOnly.getDataLength();\n        assertEquals(expectedReturn, actualReturn, \"data length was not 0\");\n    }\n\n    /**\n     * Verifies the name (do we really need this?).\n     */\n    @Test\n    public void testGetName()\n    {\n        assertEquals(\"XOR-ONLY\", xorOnly.getName());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private XorOnlyAttribute xorOnly = null;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "XorOnlyAttribute", "name": "xorOnly = null", "syntax_pass": true}, {"attribute_expression": "private MsgFixture msgFixture = null;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "MsgFixture", "name": "msgFixture = null", "syntax_pass": true}]}, {"uris": "src/test/java/org/ice4j/attribute/UnknownAttributesAttribute_getDataLengthTest.java.UnknownAttributesAttribute_getDataLengthTest", "name": "UnknownAttributesAttribute_getDataLengthTest", "file_path": "src/test/java/org/ice4j/attribute/UnknownAttributesAttribute_getDataLengthTest.java", "superclasses": "", "methods": ["[void]testGetDataLengthEvenAttributes()", "[void]testGetDataLengthOddAttributes()", "[void]testGetDataLengthNoAttributes()", "[void]testGetDataLengthSingleAttribute()"], "method_uris": ["src/test/java/org/ice4j/attribute/UnknownAttributesAttribute_getDataLengthTest.java.UnknownAttributesAttribute_getDataLengthTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class UnknownAttributesAttribute_getDataLengthTest {\n    private UnknownAttributesAttribute unknownAttributesAttribute;\n\n    @BeforeEach\n    public void setUp() {\n        unknownAttributesAttribute = new UnknownAttributesAttribute();\n    }\n\n    @Test\n    public void testGetDataLengthEvenAttributes() {\n        unknownAttributesAttribute.addAttributeID((char) 20);\n        unknownAttributesAttribute.addAttributeID((char) 21);\n        assertEquals(4, unknownAttributesAttribute.getDataLength());\n    }\n\n    @Test\n    public void testGetDataLengthOddAttributes() {\n        unknownAttributesAttribute.addAttributeID((char) 20);\n        unknownAttributesAttribute.addAttributeID((char) 21);\n        unknownAttributesAttribute.addAttributeID((char) 22);\n        assertEquals(8, unknownAttributesAttribute.getDataLength());\n    }\n\n    @Test\n    public void testGetDataLengthNoAttributes() {\n        assertEquals(0, unknownAttributesAttribute.getDataLength());\n    }\n\n    @Test\n    public void testGetDataLengthSingleAttribute() {\n        unknownAttributesAttribute.addAttributeID((char) 20);\n        assertEquals(4, unknownAttributesAttribute.getDataLength());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private UnknownAttributesAttribute unknownAttributesAttribute;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "UnknownAttributesAttribute", "name": "unknownAttributesAttribute", "syntax_pass": true}]}, {"uris": "src/test/java/org/ice4j/util/PeriodicRunnableTests.java.PeriodicRunnableTests", "name": "PeriodicRunnableTests", "file_path": "src/test/java/org/ice4j/util/PeriodicRunnableTests.java", "superclasses": "", "methods": ["[void]scheduleExecutesSpecifiedRunnableMultipleTimes()", "[void]scheduleWithNegativeDelayDoesNotExecuteRunnable()", "[void]negativeDelayStopsFurtherExecution()", "[void]cancelStopFurtherExecution()", "[void]scheduleExecuteRunnableIfPreviouslyCancelled()"], "method_uris": ["src/test/java/org/ice4j/util/PeriodicRunnableTests.java.PeriodicRunnableTests.[void]beforeEach()"], "overrides": null, "attributes": [], "class_docstring": "\nTest various aspects of {@link PeriodicRunnable} implementation.\n\n@author Yura Yaroshevich\n", "original_string": "public class PeriodicRunnableTests\n{\n    private FakeScheduledExecutorService timer;\n    private ExecutorService executor;\n\n    @BeforeEach\n    void beforeEach()\n    {\n        timer = new FakeScheduledExecutorService();\n        executor = mock(ExecutorService.class);\n        when(executor.submit(any(Runnable.class))).thenAnswer(a ->\n        {\n            ((Runnable)a.getArgument(0)).run();\n            return CompletableFuture.completedFuture(null);\n        });\n    }\n\n    @Test\n    public void scheduleExecutesSpecifiedRunnableMultipleTimes()\n    {\n        int scheduleCount = 10;\n        Duration period = Duration.ofMillis(100);\n        final CountDownLatch latch = new CountDownLatch(scheduleCount);\n        final PeriodicRunnable scheduledRunnable = PeriodicRunnable.create(\n            timer,\n            executor,\n            period,\n            latch::countDown);\n\n        scheduledRunnable.schedule();\n\n        for (int i = 0; i < scheduleCount; i++)\n        {\n            timer.getClock().elapse(period.plusMillis(10));\n            timer.run();\n        }\n\n        assertEquals(0, latch.getCount());\n    }\n\n    @Test\n    public void scheduleWithNegativeDelayDoesNotExecuteRunnable()\n    {\n        final CountDownLatch latch = new CountDownLatch(1);\n        final PeriodicRunnable scheduledRunnable = PeriodicRunnable.create(\n            timer,\n            executor,\n            Duration.ofMillis(-1),\n            latch::countDown);\n\n        scheduledRunnable.schedule();\n\n        timer.getClock().elapse(Duration.ofSeconds(1));\n        timer.run();\n        assertEquals(1, latch.getCount());\n    }\n\n    @Test\n    public void negativeDelayStopsFurtherExecution()\n    {\n        int scheduleCount = 5;\n        final CountDownLatch latch = new CountDownLatch(scheduleCount);\n        final PeriodicRunnable scheduledRunnable =\n            new PeriodicRunnable(timer, executor)\n            {\n                @Override\n                protected Duration getDelayUntilNextRun()\n                {\n                    return Duration.ofMillis(latch.getCount() > 1 ? 100 : -1);\n                }\n\n                @Override\n                protected void run()\n                {\n                    latch.countDown();\n                }\n            };\n\n        scheduledRunnable.schedule();\n\n        for (int i = 0; i < scheduleCount; i++)\n        {\n            timer.getClock().elapse(Duration.ofMillis(100));\n            timer.run();\n        }\n\n        assertEquals(1, latch.getCount());\n    }\n\n    @Test\n    public void cancelStopFurtherExecution()\n    {\n        final CountDownLatch latch = new CountDownLatch(2);\n        final PeriodicRunnable scheduledRunnable = PeriodicRunnable.create(\n            timer,\n            executor,\n            Duration.ofMillis(500),\n            latch::countDown);\n\n        scheduledRunnable.schedule();\n        timer.getClock().elapse(Duration.ofMillis(520));\n        timer.run();\n\n        // Check runnable executed once\n        assertEquals(1, latch.getCount());\n\n        scheduledRunnable.cancel();\n\n        timer.getClock().elapse(Duration.ofSeconds(1));\n        timer.run();\n        // Check runnable was not executed after cancel.\n        assertEquals(1, latch.getCount());\n    }\n\n    @Test\n    public void scheduleExecuteRunnableIfPreviouslyCancelled()\n    {\n        final CountDownLatch latch = new CountDownLatch(10);\n        final PeriodicRunnable scheduledRunnable = PeriodicRunnable.create(\n            timer,\n            executor,\n            Duration.ofMillis(200),\n            latch::countDown);\n\n        scheduledRunnable.schedule();\n        timer.getClock().elapse(Duration.ofMillis(220));\n        timer.run();\n\n        // Check runnable executed once\n        assertEquals(9, latch.getCount());\n\n        scheduledRunnable.cancel();\n\n        timer.getClock().elapse(Duration.ofSeconds(1));\n        timer.run();\n        // Check runnable was not executed after cancel.\n        assertEquals(9, latch.getCount());\n\n        // Schedule again\n        scheduledRunnable.schedule();\n        for (int i = 0; i < 5; i++)\n        {\n            timer.getClock().elapse(Duration.ofMillis(200));\n            timer.run();\n        }\n        assertEquals(4, latch.getCount());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private FakeScheduledExecutorService timer;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "FakeScheduledExecutorService", "name": "timer", "syntax_pass": true}, {"attribute_expression": "private ExecutorService executor;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ExecutorService", "name": "executor", "syntax_pass": true}]}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpStreamTest.java.PseudoTcpStreamTest", "name": "PseudoTcpStreamTest", "file_path": "src/test/java/org/ice4j/pseudotcp/PseudoTcpStreamTest.java", "superclasses": "MultiThreadSupportTest", "methods": ["[void]testConnectTransferClose()", "[void]testAccept()", "[void]testReadTimeout()", "[void]testWriteTimeout()", "[void]testFlushTimeout()"], "method_uris": ["src/test/java/org/ice4j/pseudotcp/PseudoTcpStreamTest.java.PseudoTcpStreamTest.[byte[]]receiveBuffer(InputStream,int)", "src/test/java/org/ice4j/pseudotcp/PseudoTcpStreamTest.java.PseudoTcpStreamTest.[void]doTestTimeout(TimeoutOperationTest)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class PseudoTcpStreamTest\n    extends MultiThreadSupportTest\n{\n    /**\n     * The logger.\n     */\n    private static final Logger logger = Logger\n        .getLogger(PseudoTcpStreamTest.class.getName());\n\n    /**\n     * Test one-way transfer with @link(PseudoTcpStream)\n     */\n    @Test\n    @Timeout(10)\n    public void testConnectTransferClose() \n        throws IOException\n    {\n        Thread.setDefaultUncaughtExceptionHandler(this);\n        int transferTimeout = 5000;\n\n        // bytes that will be read as a single byte\n        final int singleStepCount = 34;\n        final byte[] bufferSingle =\n            PseudoTcpTestBase.createDummyData(singleStepCount);\n        final int sizeA = 138746;\n        final byte[] bufferA = PseudoTcpTestBase.createDummyData(sizeA);\n        final int sizeB = 983746;\n        final byte[] bufferB = PseudoTcpTestBase.createDummyData(sizeB);\n        final PseudoTcpSocket server = \n            new PseudoTcpSocketFactory().createSocket();\n        server.setDebugName(\"L\");\n        server.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n        final InetSocketAddress serverAddress =\n            new InetSocketAddress(InetAddress.getLoopbackAddress(), server.getLocalPort());\n        AtomicBoolean clientThreadEnded = new AtomicBoolean();\n        AtomicBoolean serverThreadEnded = new AtomicBoolean();\n        Thread serverThread = new Thread(() ->\n        {\n            try\n            {\n                server.accept(5000);\n                byte[] rcvdSingle = new byte[singleStepCount];\n                // read by one byte\n                for (int i = 0; i < singleStepCount; i++)\n                    rcvdSingle[i] = (byte) server.getInputStream().read();\n                assertArrayEquals(bufferSingle, rcvdSingle);\n                // receive buffer A\n                byte[] recvdBufferA =\n                    receiveBuffer(server.getInputStream(), sizeA);\n                assertArrayEquals(bufferA, recvdBufferA);\n                // receive buffer B\n                byte[] recvdBufferB =\n                    receiveBuffer(server.getInputStream(), sizeB);\n                assertArrayEquals(bufferB, recvdBufferB);\n                // server.close();\n                serverThreadEnded.set(true);\n            }\n            catch (IOException ex)\n            {\n                throw new RuntimeException(ex);\n            }\n        });\n\n        final PseudoTcpSocket client = \n            new PseudoTcpSocketFactory().createSocket();\n        Thread clientThread = new Thread(() ->\n        {\n            try\n            {\n                client.setDebugName(\"R\");\n                client.connect(serverAddress, 5000);\n                OutputStream os = client.getOutputStream();\n\n                // write single array\n                for (int i = 0; i < singleStepCount; i++)\n                    os.write(bufferSingle[i]);\n\n                // write whole array\n                os.write(bufferA);\n\n                // write by parts\n                int partCount = 7;\n                boolean notExact = sizeB % partCount != 0;\n                int[] partsSize =\n                    notExact ? new int[partCount + 1] : new int[partCount];\n                for (int i = 0; i < partsSize.length; i++)\n                {\n                    if (notExact && i == partCount)\n                        partsSize[i] = sizeB % partCount;\n                    else\n                        partsSize[i] = sizeB / partCount;\n                }\n                int written = 0;\n                for (int j : partsSize)\n                {\n                    os.write(bufferB, written, j);\n                    written += j;\n                }\n                assertEquals(sizeB, written);\n                os.flush();\n                client.close();\n                clientThreadEnded.set(true);\n            }\n            catch (IOException ex)\n            {\n                throw new RuntimeException(ex);\n            }\n        });\n\n        serverThread.start();\n        clientThread.start();\n        try\n        {\n            boolean success = assert_wait_until(\n                () -> client.getState() == PseudoTcpState.TCP_CLOSED,\n                transferTimeout);\n            if (success)\n            {\n                clientThread.join(10_000);\n                if (!clientThreadEnded.get())\n                {\n                    fail(\"client thread did not end\");\n                }\n                serverThread.join(10_000);\n                if (!serverThreadEnded.get())\n                {\n                    fail(\"server thread did not end\");\n                }\n                server.close();\n            }\n            else\n            {\n                fail(\"Transfer timeout\");\n            }\n        }\n        catch (InterruptedException ex)\n        {\n            throw new RuntimeException(ex);\n        }\n    }\n\n    private static byte[] receiveBuffer(InputStream input, int size)\n        throws IOException\n    {\n        int rcvd = 0;\n        byte[] buffer = new byte[size];\n        rcvd += input.read(buffer);\n        while (rcvd != size)\n        {\n            rcvd += input.read(buffer, rcvd, size - rcvd);\n            if (logger.isLoggable(Level.FINER))\n            {\n                logger.log(Level.FINER, \"Received: \" + rcvd);\n            }\n        }\n        \n        return buffer;\n    }\n\n    /**\n     * Test the timeout on accept method\n     */\n    @Test\n    public void testAccept()\n    {\n        assertThrows(IOException.class, ()->\n        {\n            PseudoTcpSocketImpl server = new PseudoTcpSocketImpl(0);\n            server.accept(10);\n        });\n    }\n\n    /**\n     * Interface used to pass timeout test function\n     */\n    private interface TimeoutOperationTest\n    {\n        void testTimeout(PseudoTcpSocketImpl socket) throws IOException;\n    }\n\n    private void doTestTimeout(final TimeoutOperationTest testOperation)\n        throws Exception\n    {\n        Thread.setDefaultUncaughtExceptionHandler(this);\n        final PseudoTcpSocketImpl server;\n        final PseudoTcpSocketImpl client;\n        DatagramSocket serverSocket = new DatagramSocket(0, InetAddress.getLoopbackAddress());\n        server = new PseudoTcpSocketImpl(0, serverSocket);\n        client = new PseudoTcpSocketImpl(0);\n        //Servers thread waiting for connection\n        new Thread(() ->\n        {\n            try\n            {\n                server.accept(2000);\n            }\n            catch (IOException e)\n            {\n                throw new RuntimeException(e);\n            }\n            try\n            {\n                testOperation.testTimeout(server);\n                fail(\"No expected timeout occurred on operation\");\n            }\n            catch (IOException e)\n            {\n                //success\n                try\n                {\n                    server.close();\n                }\n                catch (IOException exc)\n                {\n                    throw new RuntimeException(exc);\n                }\n            }\n        }).start();\n        //Clients thread connects and closes socket\n        new Thread(() ->\n        {\n            try\n            {\n                client.connect(new InetSocketAddress(\n                    InetAddress.getLoopbackAddress(),\n                        serverSocket.getLocalPort()),\n                    2000);\n                Thread.sleep(500);\n                client.close();\n            }\n            catch (Exception e)\n            {\n                throw new RuntimeException(e);\n            }\n        }).start();\n        //Waits for server to close socket\n        boolean done = assert_wait_until(()\n            -> server.getState() == PseudoTcpState.TCP_CLOSED, 3000);\n        if(!done)\n        {\n            fail(\"Test timed out\");\n        }\n    }\n\n    /**\n     * Tests timeout on read method\n     */\n    @Test\n    public void testReadTimeout() throws Exception\n    {\n        doTestTimeout(socket ->\n        {\n            socket.setPTCPOption(Option.OPT_READ_TIMEOUT, 300);\n            socket.getInputStream().read(new byte[500]);                \n        });\n    }\n\n    /**\n     * Tests timeout on write method\n     */\n    @Test\n    public void testWriteTimeout() throws Exception\n    {\n        doTestTimeout(socket ->\n        {\n            //buffer that will exceed stack's buffer size\n            byte[] bigBuffer = new byte[PseudoTCPBase.DEFAULT_SND_BUF_SIZE*2];\n            socket.setPTCPOption(Option.OPT_WRITE_TIMEOUT, 300);\n            socket.getOutputStream().write(bigBuffer);\n        });\n    }\n\n    /**\n     * Tests timeout on flush method\n     */\n    @Test\n    public void testFlushTimeout() throws Exception\n    {\n        doTestTimeout(socket ->\n        {\n            //buffer that will exceed stack's buffer size\n            byte[] buffer = new byte[PseudoTCPBase.DEFAULT_SND_BUF_SIZE];\n            socket.setPTCPOption(Option.OPT_WRITE_TIMEOUT, 300);\n            try\n            {\n                socket.getOutputStream().write(buffer);\n            }\n            catch(IOException e)\n            {\n                throw new RuntimeException(\"Unexpected exception: \"+e);\n            }\n            socket.getOutputStream().flush();\n        });\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Logger logger = Logger\n        .getLogger(PseudoTcpStreamTest.class.getName());", "docstring": "\nThe logger.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Logger", "name": "logger = Logger\n        .getLogger(PseudoTcpStreamTest.class.getName())", "syntax_pass": true}]}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl_getOutputStreamTest.java.PseudoTcpSocketImpl_getOutputStreamTest", "name": "PseudoTcpSocketImpl_getOutputStreamTest", "file_path": "src/test/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl_getOutputStreamTest.java", "superclasses": "", "methods": ["[void]testGetOutputStream_InitialCall()", "[void]testGetOutputStream_SubsequentCall()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class PseudoTcpSocketImpl_getOutputStreamTest {\n\n    @Test\n    void testGetOutputStream_InitialCall() throws IOException {\n        PseudoTcpSocketImpl socketImpl = new PseudoTcpSocketImpl(12345);\n        OutputStream outputStream = socketImpl.getOutputStream();\n        assertNotNull(outputStream);\n        assertTrue(outputStream instanceof PseudoTcpSocketImpl.PseudoTcpOutputStream);\n    }\n\n    @Test\n    void testGetOutputStream_SubsequentCall() throws IOException {\n        PseudoTcpSocketImpl socketImpl = new PseudoTcpSocketImpl(12345);\n        OutputStream firstCall = socketImpl.getOutputStream();\n        OutputStream secondCall = socketImpl.getOutputStream();\n        assertSame(firstCall, secondCall);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTCPBase_notifyMTUTest.java.PseudoTCPBase_notifyMTUTest", "name": "PseudoTCPBase_notifyMTUTest", "file_path": "src/test/java/org/ice4j/pseudotcp/PseudoTCPBase_notifyMTUTest.java", "superclasses": "", "methods": ["[void]testNotifyMTU_EstablishedState()", "[void]testNotifyMTU_NonEstablishedState()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class PseudoTCPBase_notifyMTUTest {\n\n    @Test\n    void testNotifyMTU_EstablishedState() {\n        // Given\n        PseudoTcpNotify notify = mock(PseudoTcpNotify.class);\n        PseudoTCPBase pseudoTCPBase = new PseudoTCPBase(notify, 12345L);\n        pseudoTCPBase.m_state = PseudoTcpState.TCP_ESTABLISHED;\n\n        // When\n        pseudoTCPBase.notifyMTU(1500);\n\n        // Then\n        assertEquals(1500, pseudoTCPBase.getMTU());\n        verify(notify, never()).tcpWritePacket(any(), any(), anyInt());\n    }\n\n    @Test\n    void testNotifyMTU_NonEstablishedState() {\n        // Given\n        PseudoTcpNotify notify = mock(PseudoTcpNotify.class);\n        PseudoTCPBase pseudoTCPBase = new PseudoTCPBase(notify, 12345L);\n        pseudoTCPBase.m_state = PseudoTcpState.TCP_LISTEN;\n\n        // When\n        pseudoTCPBase.notifyMTU(1500);\n\n        // Then\n        assertEquals(1500, pseudoTCPBase.getMTU());\n        verify(notify, never()).tcpWritePacket(any(), any(), anyInt());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestRecvWindow.java.PseudoTcpTestRecvWindow", "name": "PseudoTcpTestRecvWindow", "file_path": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestRecvWindow.java", "superclasses": "PseudoTcpTestBase", "methods": ["[void]testGetShadowedBytes()", "[void]testReceiveWindow()", "[void]testSetVerySmallSendWindowSize()", "[void]testSetReceiveWindowSize()"], "method_uris": ["src/test/java/org/ice4j/pseudotcp/PseudoTcpTestRecvWindow.java.PseudoTcpTestRecvWindow.[void]doTestTransfer(int)", "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestRecvWindow.java.PseudoTcpTestRecvWindow.[int]getShadowedBytes(int)", "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestRecvWindow.java.PseudoTcpTestRecvWindow.[void]readUntilIOPending()", "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestRecvWindow.java.PseudoTcpTestRecvWindow.[void]scheduleWriteAction(long)", "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestRecvWindow.java.PseudoTcpTestRecvWindow.[void]writeData()", "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestRecvWindow.java.PseudoTcpTestRecvWindow.[int]estimateReceiveWindowSize()", "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestRecvWindow.java.PseudoTcpTestRecvWindow.[int]estimateSendWindowSize()", "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestRecvWindow.java.PseudoTcpTestRecvWindow.[void]onTcpReadable(PseudoTCPBase)", "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestRecvWindow.java.PseudoTcpTestRecvWindow.[void]onTcpWriteable(PseudoTCPBase)", "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestRecvWindow.java.PseudoTcpTestRecvWindow.[void]setLocalOptSndBuf(int)", "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestRecvWindow.java.PseudoTcpTestRecvWindow.[int]getRemoteScaleFactor()"], "overrides": null, "attributes": [], "class_docstring": "\nFill the receiver window until it is full, drain it and then fill it with the\nsame amount. This is to test that receiver window contracts and enlarges\ncorrectly.\n\n@author Pawel Domas\n", "original_string": "public class PseudoTcpTestRecvWindow extends PseudoTcpTestBase\n{\n    /**\n     * The logger.\n     */\n    private static final Logger logger =\n        Logger.getLogger(PseudoTCPBase.class.getName());\n    /**\n     * Send data buffer\n     */\n    private ByteFifoBuffer send_stream;\n    /**\n     * List which stores stream position after each write cycle\n     */\n    private List<Integer> send_position;\n    /**\n     * Receive data buffer\n     */\n    private ByteFifoBuffer recv_stream;\n    /**\n     * List which stores stream position after each read cycle\n     */\n    private List<Integer> recv_position;\n    /**\n     * Times used for write operations scheduling\n     */\n    private Timer writeTimer = new Timer(\"WriteTimer\");\n    /**\n     * Stores data length used for the test.\n     */\n    private int testDataSize;\n\n    private void doTestTransfer(int size)\n    {\n        Thread.setDefaultUncaughtExceptionHandler(this);\n        testDataSize = size;\n        long start, elapsed;\n        send_position = new ArrayList<>();\n        recv_position = new ArrayList<>();\n        // Create some dummy data\n        byte[] dummy = createDummyData(size);\n        send_stream = new ByteFifoBuffer(size);\n        send_stream.write(dummy, size);\n        //Prepare the receive stream\n        recv_stream = new ByteFifoBuffer(size);\n        //Connect and wait until connected\n        start = PseudoTCPBase.now();\n        startClocks();\n        try\n        {\n            connect();\n        }\n        catch (IOException ex)\n        {\n            fail(ex.getMessage());\n        }\n        //assert Connect() == 0;\n        //TODO: check assert result and fail\n        // Connect and wait until connected.\n        assert_Connected_wait(kConnectTimeoutMs);\n\n        scheduleWriteAction(0);\n\n        long transferTout = maxTransferTime(dummy.length, kMinTransferRate);\n        boolean transferInTime = assert_Disconnected_wait(transferTout);\n        elapsed = PseudoTCPBase.now() - start;\n        stopClocks();\n        int received = recv_stream.getBuffered();\n        assertTrue(transferInTime, \"Transfer timeout, transferred: \" + received\n            + \" required: \" + dummy.length\n            + \" elapsed: \"\n            + elapsed + \" limit: \" + transferTout);\n\n        assert 2 == send_position.size();\n        assert 2 == recv_position.size();\n\n        int estimated_recv_window = estimateReceiveWindowSize();\n\n        // The difference in consecutive send positions should equal the\n        // receive window size or match very closely. This verifies that receive\n        // window is open after receiver drained all the data.\n        int send_position_diff = send_position.get(1) - send_position.get(0);\n        assertTrue(estimated_recv_window - send_position_diff <= 1024);\n\n        // Receiver drained the receive window twice.(+-2 because of window scaling)        \n        assert ((recv_position.get(1) - 2 * estimated_recv_window)\n            <= getShadowedBytes(getRemoteScaleFactor()));\n    }\n\n    /**\n     * This function calculates amount of bytes witch may introduce error to\n     * estimation of receive window size caused by scale factor. This is because\n     * data is being sent until all sent data is available in remote side's\n     * buffer. But because of scale factor window size 0 is reached earlier than\n     * expected and some data may still wait for window to open in the send\n     * queue.\n     *\n     * For example: m_rcv_scale == 1 and m_rcv_wnd < 2 then rcv_wnd == 0 (1 byte\n     * may block) m_rcv_scale == 2 and m_rcv_wnd < 4 then rcv_wnd == 0 (3 bytes\n     * may block) m_rcv_scale == 3 and m_rcv_wnd < 8 then rcv_wnd == 0 (7 bytes\n     * may block) and so on...\n     *\n     * In normal operation something would read data on remote side causing\n     * window to expand.\n     *\n     *\n     *\n     *\n\n     *\n     * @return count bytes shadowed by scale actor\n     */\n    static int getShadowedBytes(int scaleFactor)\n    {\n        return (int) (Math.pow(2, scaleFactor) - 1);\n    }\n\n    /**\n     * Reads all data available at the buffer\n     */\n    void readUntilIOPending() throws IOException\n    {\n        byte[] block = new byte[getRemoteTcp().getRecvBufferSize() * 2];\n        int position = recv_stream.getBuffered();\n        int rcvd, total = 0;\n        do\n        {\n            rcvd = remoteRecv(block, block.length);\n            if (rcvd > 0)\n            {\n                recv_stream.write(block, rcvd);\n                total += rcvd;\n                position += rcvd;\n            }\n        }\n        while (rcvd > 0 && total != 0);\n        recv_position.add(position);\n\n        // Disconnect if we have done two transfers.\n        if (recv_position.size() == 2)\n        {\n            close();\n            onTcpClosed(getRemoteTcp(), null);\n        }\n        else\n        {\n            writeData();\n        }\n    }\n\n    /**\n     * Schedules write operation with <tt>delay</tt> given in ms\n     */\n    void scheduleWriteAction(long delay)\n    {\n        writeTimer.schedule(new TimerTask()\n        {\n            @Override\n            public void run()\n            {\n                try\n                {\n                    writeData();\n                }\n                catch (IOException ex)\n                {\n                    //it will get cought by \n                    //deafult exception handler in PseudoTcpTestBase\n                    throw new RuntimeException(ex);\n                }\n            }\n        }, delay);\n    }\n\n    /**\n     * Writes the data\n     */\n    void writeData() throws IOException\n    {\n        //writeOpCount++;\n        int tosend;\n        int sent;\n        int totalSent = 0;\n        byte[] block = new byte[getRemoteTcp().getRecvBufferSize() * 2];\n        int position = testDataSize - send_stream.getBuffered();\n        synchronized (getLocalTcp())\n        {\n            do\n            {\n                tosend = send_stream.readOffset(block, 0, block.length, 0);\n                if (tosend > 0)\n                {\n                    sent = localSend(block, tosend);\n                    updateLocalClock();\n                    if (sent > 0)\n                    {\n                        totalSent += sent;\n                        send_stream.consumeReadData(sent);\n                        position += sent;\n                    }\n                    else\n                    {\n                        logger.log(Level.FINE, \"Flow Controlled\");\n                    }\n                }\n                else\n                {\n                    sent = tosend = 0;\n                }\n            }\n            while (sent > 0);\n            //position = send_stream.GetBuffered();\n\n        }\n        // Measured with precision according to window scale option used\n        if (totalSent - getRemoteTcp().getAvailable()\n            > getShadowedBytes(getRemoteScaleFactor()))\n        {\n            //send buffer was fully filled\n            //waits until it will be received by remote peer\n            while (totalSent - getRemoteTcp().getAvailable()\n                > getShadowedBytes(getRemoteScaleFactor())\n                && !getRemoteTcp().isReceiveBufferFull())\n            {\n                try\n                {\n                    Thread.sleep(50);\n                    if (logger.isLoggable(Level.FINER))\n                    {\n                        logger.log(Level.FINER,\n                                   \"Waiting... sent: \" + totalSent + \" avail: \"\n                            + getRemoteTcp().getAvailable() + \" buffered not sent: \"\n                            + getLocalTcp().getBytesBufferedNotSent()\n                            + \" isFull? \" + getRemoteTcp().isReceiveBufferFull());\n                    }\n                }\n                catch (InterruptedException ex)\n                {\n                    throw new RuntimeException(ex);\n                }\n            }\n        }\n        send_position.add(position);\n        writeTimer.schedule(new TimerTask()\n        {\n            @Override\n            public void run()\n            {\n                try\n                {\n                    readUntilIOPending();\n                }\n                catch (IOException ex)\n                {\n                    throw new RuntimeException(ex);\n                }\n            }\n        }, 10);\n    }\n\n    /**\n     *\n     * @return estimated receive window size\n     */\n    int estimateReceiveWindowSize()\n    {\n        return recv_position.get(0);\n    }\n\n    /**\n     *\n     * @return estimated send window size\n     */\n    int estimateSendWindowSize()\n    {\n        return send_position.get(0);\n    }\n\n    @Override\n    public void onTcpReadable(PseudoTCPBase tcp)\n    {\n    }\n\n    @Override\n    public void onTcpWriteable(PseudoTCPBase tcp)\n    {\n    }\n\n    void setLocalOptSndBuf(int len)\n    {\n        getLocalTcp().setOption(Option.OPT_SNDBUF, len);\n    }\n\n    int getRemoteScaleFactor()\n    {\n        return getRemoteTcp().getM_rwnd_scale();\n    }\n\n    @Test\n    public void testGetShadowedBytes()\n    {\n        assert (PseudoTcpTestRecvWindow.getShadowedBytes(0) == 0);\n        assert (PseudoTcpTestRecvWindow.getShadowedBytes(1) == 1);\n        assert (PseudoTcpTestRecvWindow.getShadowedBytes(2) == 3);\n        assert (PseudoTcpTestRecvWindow.getShadowedBytes(3) == 7);\n        assert (PseudoTcpTestRecvWindow.getShadowedBytes(4) == 15);\n        assert (PseudoTcpTestRecvWindow.getShadowedBytes(11) == 2047);\n        assert (PseudoTcpTestRecvWindow.getShadowedBytes(14) == 16383);\n    }\n\n    /**\n     * Test that receive window expands and contract correctly.\n     */\n    @Test\n    public void testReceiveWindow()\n    {\n        //logger.log(Level.INFO, \"Test receive window\");\n        PseudoTcpTestRecvWindow test = new PseudoTcpTestRecvWindow();\n        test.setLocalMtu(1500);\n        test.setRemoteMtu(1500);\n        test.setOptNagling(false);\n        test.setOptAckDelay(0);\n        test.doTestTransfer(1024 * 1000);\n    }\n\n    /**\n     * Test setting send window size to a very small value.\n     */\n    @Test\n    public void testSetVerySmallSendWindowSize()\n    {\n        //TODO: finish test\n        logger.log(Level.INFO, \"Test very small receive window\");\n        PseudoTcpTestRecvWindow test = new PseudoTcpTestRecvWindow();\n        test.setLocalMtu(1500);\n        test.setRemoteMtu(1500);\n        test.setOptNagling(false);\n        test.setOptAckDelay(0);\n        test.setOptSndBuf(900);\n        test.doTestTransfer(1024 * 1000);\n        assertEquals(900, test.estimateSendWindowSize());\n    }\n\n    /**\n     * Test setting receive window size to a value other than default.\n     */\n    @Test\n    public void testSetReceiveWindowSize()\n    {\n        //logger.log(Level.INFO, \"Test set receive window size\");\n        PseudoTcpTestRecvWindow test = new PseudoTcpTestRecvWindow();\n        test.setLocalMtu(1500);\n        test.setRemoteMtu(1500);\n        test.setOptNagling(false);\n        test.setOptAckDelay(0);\n        int wndSize = 300000;\n        // if window scaling is not supported by either local or remote, use \n        // default size\n        if (!test.getLocalTcp().m_support_wnd_scale || \n            !test.getRemoteTcp().m_support_wnd_scale)\n        {\n        \twndSize = 65535;\n        }\n        test.setLocalOptSndBuf(wndSize);        \t\n        test.setRemoteOptRcvBuf(wndSize);\n        int wndScale = test.getRemoteScaleFactor();\n        //logger.log(Level.INFO, \"Using scale factor: {0}\", wndScale);\n        test.doTestTransfer(1024 * 3000);\n        //beacuse there may be situations \n        //when 1 byte may be waiting in send queue\n        //before \n        //scaling factor == 1 not allows to determine exact window size (+-1)\n        assert (wndSize - test.estimateReceiveWindowSize()\n            <= PseudoTcpTestRecvWindow.getShadowedBytes(wndScale));\n    }\n\n    /*\n     * Test sending data with mismatched MTUs. We should detect this and reduce\n     * // our packet size accordingly. // TODO: This doesn't actually work right\n     * now. The current code // doesn't detect if the MTU is set too high on\n     * either side. TEST_F(PseudoTcpTest, TestSendWithMismatchedMtus) {\n     * SetLocalMtu(1500); SetRemoteMtu(1280); TestTransfer(1000000); }\n     */\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Logger logger =\n        Logger.getLogger(PseudoTCPBase.class.getName());", "docstring": "\nThe logger.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Logger", "name": "logger =\n        Logger.getLogger(PseudoTCPBase.class.getName())", "syntax_pass": true}, {"attribute_expression": "private ByteFifoBuffer send_stream;", "docstring": "\nSend data buffer\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ByteFifoBuffer", "name": "send_stream", "syntax_pass": true}, {"attribute_expression": "private List<Integer> send_position;", "docstring": "\nList which stores stream position after each write cycle\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "List<Integer>", "name": "send_position", "syntax_pass": true}, {"attribute_expression": "private ByteFifoBuffer recv_stream;", "docstring": "\nReceive data buffer\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ByteFifoBuffer", "name": "recv_stream", "syntax_pass": true}, {"attribute_expression": "private List<Integer> recv_position;", "docstring": "\nList which stores stream position after each read cycle\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "List<Integer>", "name": "recv_position", "syntax_pass": true}, {"attribute_expression": "private Timer writeTimer = new Timer(\"WriteTimer\");", "docstring": "\nTimes used for write operations scheduling\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Timer", "name": "writeTimer = new Timer(\"WriteTimer\")", "syntax_pass": true}, {"attribute_expression": "private int testDataSize;", "docstring": "\nStores data length used for the test.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "testDataSize", "syntax_pass": true}]}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestTransfer.java.PseudoTcpTestTransfer", "name": "PseudoTcpTestTransfer", "file_path": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestTransfer.java", "superclasses": "PseudoTcpTestBase", "methods": ["[void]testSend()", "[void]testSendWithDelay()", "[void]testSendWithLoss()", "[void]testSendWithDelayAndLoss()", "[void]testSendWithLossAndOptNaglingOff()", "[void]testSendWithLossAndOptAckDelayOff()", "[void]testSendWithDelayAndOptNaglingOff()", "[void]testSendWithDelayAndOptAckDelayOff()", "[void]testSendRemoteNoWindowScale()", "[void]testSendLocalNoWindowScale()", "[void]testSendBothUseWindowScale()", "[void]testSendLargeInFlight()", "[void]testSendBothUseLargeWindowScale()", "[void]testSendSmallReceiveBuffer()", "[void]testSendVerySmallReceiveBuffer()"], "method_uris": ["src/test/java/org/ice4j/pseudotcp/PseudoTcpTestTransfer.java.PseudoTcpTestTransfer.[void]doTestTransfer(int)", "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestTransfer.java.PseudoTcpTestTransfer.[void]readData()", "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestTransfer.java.PseudoTcpTestTransfer.[boolean]writeData()", "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestTransfer.java.PseudoTcpTestTransfer.[void]onTcpReadable(PseudoTCPBase)", "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestTransfer.java.PseudoTcpTestTransfer.[void]onTcpWriteable(PseudoTCPBase)"], "overrides": null, "attributes": [], "class_docstring": "\nImplements one way transfer test\n\n@author Pawel Domas\n", "original_string": "public class PseudoTcpTestTransfer extends PseudoTcpTestBase\n{\n    /**\n     * The logger.\n     */\n    private static final Logger logger =\n        Logger.getLogger(PseudoTCPBase.class.getName());\n\n    /**\n     * The send data\n     */\n    private byte[] sendData;\n    /**\n     * Send stream size\n     */\n    private int sendStreamSize;\n    /**\n     * Total bytes sent counter\n     */\n    private int totalSent;\n    /**\n     * Receive stream\n     */\n    private ByteArrayOutputStream recvStream;\n\n    /**\n     * Transfers the data of <tt>size</tt> bytes\n     */\n    private void doTestTransfer(int size)\n    {\n        Thread.setDefaultUncaughtExceptionHandler(this);\n        long start, elapsed;\n        int received;\n        // Create some dummy data to send\n        sendData = createDummyData(size);\n        sendStreamSize = size;\n\n        // Prepare the receive stream.\n        recvStream = new ByteArrayOutputStream(size);\n        // Connect and wait until connected.\n        start = PseudoTCPBase.now();\n        startClocks();\n        try\n        {\n            connect();\n        }\n        catch (IOException ex)\n        {\n            fail(ex.getMessage());\n        }\n\n        assert_Connected_wait(kConnectTimeoutMs);\n        // Sending will start from OnTcpWriteable and complete when all data has\n        // been received.\n        long transferTout = maxTransferTime(sendData.length, kMinTransferRate);\n        boolean transferInTime = assert_Disconnected_wait(transferTout);\n        elapsed = PseudoTCPBase.now() - start;\n        stopClocks();\n        received = recvStream.size();\n        assertTrue(transferInTime,\"Transfer timeout, transferred: \" + received\n            + \" required: \" + sendData.length\n            + \" elapsed: \"\n            + elapsed + \" limit: \" + transferTout);\n\n        // Ensure we closed down OK and we got the right data.\n        assertEquals(size, received);\n        byte[] recvdArray = recvStream.toByteArray();\n        assertArrayEquals(sendData, recvdArray);\n\n        logger.log(Level.INFO,\n                   \"Transferred \" + received + \" bytes in \" + elapsed\n            + \" ms (\" + (size * 8 / elapsed) + \" Kbps\");\n\n    }\n\n    /**\n     * Reads all data available at remote peer's buffer\n     */\n    void readData() throws IOException\n    {\n        byte[] block = new byte[kBlockSize];\n        int rcvd;\n        do\n        {\n            rcvd = remoteRecv(block, block.length);\n            updateRemoteClock();\n            if (rcvd != -1)\n            {\n                recvStream.write(block, 0, rcvd);\n            }\n        }\n        while (rcvd > 0);\n    }\n\n    /**\n     * Writes the data until there's space available\n     *\n     * @return true if there's no more data left to write\n     */\n    boolean writeData() throws IOException\n    {\n        int tosend;\n        int sent;\n        byte[] block = new byte[kBlockSize];\n        do\n        {\n            tosend = Math.min(sendStreamSize - totalSent, block.length);\n            System.arraycopy(sendData, totalSent, block, 0, tosend);\n            if (tosend > 0)\n            {\n                sent = localSend(block, tosend);\n                updateLocalClock();\n                if (sent != -1)\n                {\n                    totalSent += sent;\n                }\n                else\n                {\n                    logger.log(Level.FINE, \"Flow Controlled\");\n                }\n            }\n            else\n            {\n                sent = tosend = 0;\n            }\n        }\n        while (sent > 0);\n\n        if (logger.isLoggable(Level.FINER))\n        {\n            logger.log(Level.FINER, \"Sent: \" + totalSent\n                + \" remaining: \" + (sendStreamSize - totalSent));\n        }\n\n        return tosend == 0;\n    }\n\n    /**\n     * Catches TCP readable event for remote peer and reads the data. When total\n     * read count equals send data size the test is finished.\n     */\n    @Override\n    public void onTcpReadable(PseudoTCPBase tcp)\n    {\n        if (tcp == getRemoteTcp())\n        {\n            try\n            {\n                readData();\n                // TODO: OnTcpClosed() is currently only notified on error -\n                // there is no on-the-wire equivalent of TCP FIN.\n                // So we fake the notification when all the data has been read.\n                int received, required;\n                received = recvStream.size();\n                required = sendStreamSize;\n                if (logger.isLoggable(Level.FINER))\n                {\n                    logger.log(Level.FINER, \"Receivied: \" + received\n                        + \" required: \" + required);\n                }\n                if (received == required)\n                {\n                    onTcpClosed(getRemoteTcp(), null);\n                }\n            }\n            catch (IOException ex)\n            {\n                throw new RuntimeException(ex);\n            }\n        }\n    }\n\n    /**\n     * Catches on TCP writeable event for local peer. Writes all data and closes\n     * the stream\n     */\n    @Override\n    public void onTcpWriteable(PseudoTCPBase tcp)\n    {\n        if (tcp == getLocalTcp())\n        {\n            // Write bytes from the send stream when we can.\n            // Shut down when we've sent everything.\n            logger.log(Level.FINER, \"Flow Control Lifted\");\n            try\n            {\n                if (writeData())\n                {\n                    close();\n                }\n            }\n            catch (IOException ex)\n            {\n                ex.printStackTrace();\n                fail(ex.getMessage());\n            }\n        }\n    }\n\n    /**\n     * Basic end-to-end data transfer tests Test the normal case of sending data\n     * from one side to the other.\n     */\n    @Test\n    public void testSend()\n    {\n        //logger.log(Level.INFO, \"Test send\");\n        PseudoTcpTestTransfer test = new PseudoTcpTestTransfer();\n        test.setLocalMtu(1500);\n        test.setRemoteMtu(1500);\n        test.doTestTransfer(1000000);\n    }\n\n    /**\n     * Test sending data with a 50 ms RTT. Transmission should take longer due\n     * to a slower ramp-up in send rate.\n     */\n    @Test\n    public void testSendWithDelay()\n    {\n        //logger.log(Level.INFO, \"Test send with delay\");\n        PseudoTcpTestTransfer test = new PseudoTcpTestTransfer();\n        test.setLocalMtu(1500);\n        test.setRemoteMtu(1500);\n        test.setDelay(50);\n        test.doTestTransfer(1000000);\n    }\n\n    /**\n     * Test sending data with packet loss. Transmission should take much longer\n     * due to send back-off when loss occurs.\n     */\n    @Test\n    public void testSendWithLoss()\n    {\n        //logger.log(Level.INFO, \"Test send with loss\");\n        PseudoTcpTestTransfer test = new PseudoTcpTestTransfer();\n        test.setLocalMtu(1500);\n        test.setRemoteMtu(1500);\n        test.setLoss(10);\n        test.doTestTransfer(100000);  // less data so test runs faster\n    }\n\n    /**\n     * Test sending data with a 50 ms RTT and 10% packet loss. Transmission\n     * should take much longer due to send back-off and slower detection of\n     * loss.\n     */\n    @Test\n    public void testSendWithDelayAndLoss()\n    {\n        //logger.log(Level.INFO, \"Test send with delay and loss\");\n        PseudoTcpTestTransfer test = new PseudoTcpTestTransfer();\n        test.setLocalMtu(1500);\n        test.setRemoteMtu(1500);\n        test.setDelay(50);\n        test.setLoss(10);\n        test.doTestTransfer(100000);  // less data so test runs faster\n    }\n\n    /**\n     * Test sending data with 10% packet loss and Nagling disabled. Transmission\n     * should take about the same time as with Nagling enabled.\n     */\n    @Test\n    public void testSendWithLossAndOptNaglingOff()\n    {\n        //logger.log(Level.INFO, \"Test send with loss and OptNagling off\");\n        PseudoTcpTestTransfer test = new PseudoTcpTestTransfer();\n        test.setLocalMtu(1500);\n        test.setRemoteMtu(1500);\n        test.setLoss(10);\n        test.setOptNagling(false);\n        test.doTestTransfer(100000);  // less data so test runs faster\n    }\n\n    /**\n     * Test sending data with 10% packet loss and Delayed ACK disabled.\n     * Transmission should be slightly faster than with it enabled.\n     */\n    @Test\n    public void testSendWithLossAndOptAckDelayOff()\n    {\n        //logger.log(Level.INFO, \"Test send with loss and OptAckDelay off\");\n        PseudoTcpTestTransfer test = new PseudoTcpTestTransfer();\n        test.setLocalMtu(1500);\n        test.setRemoteMtu(1500);\n        test.setLoss(10);\n        test.setOptAckDelay(0);\n        test.doTestTransfer(100000);\n    }\n\n    /**\n     * Test sending data with 50ms delay and Nagling disabled.\n     */\n    @Test\n    public void testSendWithDelayAndOptNaglingOff()\n    {\n        //logger.log(Level.INFO, \"Test send with delay and OptNagling off\");\n        PseudoTcpTestTransfer test = new PseudoTcpTestTransfer();\n        test.setLocalMtu(1500);\n        test.setRemoteMtu(1500);\n        test.setDelay(50);\n        test.setOptNagling(false);\n        test.doTestTransfer(100000);  // less data so test runs faster\n    }\n\n    /**\n     * Test sending data with 50ms delay and Delayed ACK disabled.\n     */\n    @Test\n    public void testSendWithDelayAndOptAckDelayOff()\n    {\n        //logger.log(Level.INFO, \"Test send with delay and OptAckDelay off\");\n        PseudoTcpTestTransfer test = new PseudoTcpTestTransfer();\n        test.setLocalMtu(1500);\n        test.setRemoteMtu(1500);\n        test.setDelay(50);\n        test.setOptAckDelay(0);\n        test.doTestTransfer(100000);  // less data so test runs faster\n    }\n\n    /**\n     * Test a large receive buffer with a sender that doesn't support scaling.\n     */\n    @Test\n    public void testSendRemoteNoWindowScale()\n    {\n        //logger.log(Level.INFO, \"Test send - remote no window scale\");\n        PseudoTcpTestTransfer test = new PseudoTcpTestTransfer();\n        test.setLocalMtu(1500);\n        test.setRemoteMtu(1500);\n        test.setLocalOptRcvBuf(100000);\n        test.disableRemoteWindowScale();\n        test.doTestTransfer(1000000);\n    }\n\n    /**\n     * Test a large sender-side receive buffer with a receiver that doesn't\n     * support scaling.\n     */\n    @Test\n    public void testSendLocalNoWindowScale()\n    {\n        //logger.log(Level.INFO, \"Test send - local no window scale\");\n        PseudoTcpTestTransfer test = new PseudoTcpTestTransfer();\n        test.setLocalMtu(1500);\n        test.setRemoteMtu(1500);\n        test.setRemoteOptRcvBuf(100000);\n        test.disableLocalWindowScale();\n        test.doTestTransfer(1000000);\n    }\n\n    /**\n     * Test when both sides use window scaling.\n     */\n    @Test\n    public void testSendBothUseWindowScale()\n    {\n        //logger.log(Level.INFO, \"Test send - both use window scale\");\n        PseudoTcpTestTransfer test = new PseudoTcpTestTransfer();\n        test.setLocalMtu(1500);\n        test.setRemoteMtu(1500);\n        test.setRemoteOptRcvBuf(100000);\n        test.setLocalOptRcvBuf(100000);\n        test.doTestTransfer(1000000);\n    }\n\n    /**\n     * Test using a large window scale value.\n     */\n    @Test\n    public void testSendLargeInFlight()\n    {\n        //logger.log(Level.INFO, \"Test send large in flight\");\n        PseudoTcpTestTransfer test = new PseudoTcpTestTransfer();\n        test.setLocalMtu(1500);\n        test.setRemoteMtu(1500);\n        test.setRemoteOptRcvBuf(100000);\n        test.setLocalOptRcvBuf(100000);\n        test.setOptSndBuf(150000);\n        test.doTestTransfer(1000000);\n    }\n\n    @Test\n    public void testSendBothUseLargeWindowScale()\n    {\n        //logger.log(Level.INFO, \"Test send both use large window scale\");\n        PseudoTcpTestTransfer test = new PseudoTcpTestTransfer();\n        test.setLocalMtu(1500);\n        test.setRemoteMtu(1500);\n        test.setRemoteOptRcvBuf(1000000);\n        test.setLocalOptRcvBuf(1000000);\n        test.doTestTransfer(10000000);\n    }\n\n    /**\n     * Test using a small receive buffer.\n     */\n    @Test\n    public void testSendSmallReceiveBuffer()\n    {\n        //logger.log(Level.INFO, \"Test send small receive buffer\");\n        PseudoTcpTestTransfer test = new PseudoTcpTestTransfer();\n        test.setLocalMtu(1500);\n        test.setRemoteMtu(1500);\n        test.setRemoteOptRcvBuf(10000);\n        test.setLocalOptRcvBuf(10000);\n        test.doTestTransfer(1000000);\n    }\n\n    /**\n     * Test using a very small receive buffer.\n     */\n    @Test\n    public void testSendVerySmallReceiveBuffer()\n    {\n        //logger.log(Level.INFO, \"Test send very small receive buffer\");\n        PseudoTcpTestTransfer test = new PseudoTcpTestTransfer();\n        test.setLocalMtu(1500);\n        test.setRemoteMtu(1500);\n        test.setRemoteOptRcvBuf(100);\n        test.setLocalOptRcvBuf(100);\n        test.doTestTransfer(100000);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Logger logger =\n        Logger.getLogger(PseudoTCPBase.class.getName());", "docstring": "\nThe logger.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Logger", "name": "logger =\n        Logger.getLogger(PseudoTCPBase.class.getName())", "syntax_pass": true}, {"attribute_expression": "private byte[] sendData;", "docstring": "\nThe send data\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "byte[]", "name": "sendData", "syntax_pass": true}, {"attribute_expression": "private int sendStreamSize;", "docstring": "\nSend stream size\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "sendStreamSize", "syntax_pass": true}, {"attribute_expression": "private int totalSent;", "docstring": "\nTotal bytes sent counter\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "totalSent", "syntax_pass": true}, {"attribute_expression": "private ByteArrayOutputStream recvStream;", "docstring": "\nReceive stream\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ByteArrayOutputStream", "name": "recvStream", "syntax_pass": true}]}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTCPBase_segToStrTest.java.PseudoTCPBase_segToStrTest", "name": "PseudoTCPBase_segToStrTest", "file_path": "src/test/java/org/ice4j/pseudotcp/PseudoTCPBase_segToStrTest.java", "superclasses": "", "methods": ["[void]testSegToStr()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class PseudoTCPBase_segToStrTest {\n\n    @Test\n    void testSegToStr() {\n        Segment seg = new Segment();\n        seg.conv = 1234567890L;\n        seg.flags = 0x02;\n        seg.seq = 987654321L;\n        seg.len = 10;\n        seg.ack = 1122334455L;\n        seg.wnd = 5000;\n        seg.tsval = 1234567890L;\n        seg.tsecr = 987654321L;\n        seg.data = new byte[] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n\n        String expected = \"<CONV=1234567890><FLG=2><SEQ=987654321:987654331><ACK=1122334455><WND=5000><TS=1234567890><TSR=987654321><LEN=10> data: 12345678910\";\n        String result = PseudoTCPBase.segToStr(seg);\n\n        assertEquals(expected, result);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestPingPong.java.PseudoTcpTestPingPong", "name": "PseudoTcpTestPingPong", "file_path": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestPingPong.java", "superclasses": "PseudoTcpTestBase", "methods": ["[void]testPingPong1xMtu()", "[void]testPingPong3xMtu()", "[void]testPingPong2xMtu()", "[void]testPingPong2xMtuWithAckDelayOff()", "[void]testPingPong2xMtuWithNaglingOff()", "[void]testPingPongShortSegments()", "[void]testPingPongShortSegmentsWithNaglingOff()", "[void]testPingPongShortSegmentsWithAckDelayOff()"], "method_uris": ["src/test/java/org/ice4j/pseudotcp/PseudoTcpTestPingPong.java.PseudoTcpTestPingPong.[void]setBytesPerSend(int)", "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestPingPong.java.PseudoTcpTestPingPong.[void]doTestPingPong(int,int)", "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestPingPong.java.PseudoTcpTestPingPong.[void]onTcpReadable(PseudoTCPBase)", "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestPingPong.java.PseudoTcpTestPingPong.[void]onTcpWriteable(PseudoTCPBase)", "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestPingPong.java.PseudoTcpTestPingPong.[void]readData()", "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestPingPong.java.PseudoTcpTestPingPong.[void]writeData()"], "overrides": null, "attributes": [], "class_docstring": "\nThis class implements test for two way transfers\n\n@author Pawel Domas\n", "original_string": "public class PseudoTcpTestPingPong extends PseudoTcpTestBase\n{\n    /**\n     * The logger.\n     */\n    private static final Logger logger =\n        Logger.getLogger(PseudoTCPBase.class.getName());\n    /**\n     * The sender\n     */\n    private PseudoTCPBase sender;\n    /**\n     * The receiver\n     */\n    private PseudoTCPBase receiver;\n    /**\n     * How much data is sent per ping\n     */\n    private int bytesPerSend;\n    /**\n     * Iterations count\n     */\n    private int iterationsRemaining;\n\n    public void setBytesPerSend(int bytes_per_send)\n    {\n        this.bytesPerSend = bytes_per_send;\n    }\n    /**\n     * The send stream buffer\n     */\n    ByteFifoBuffer send_stream;\n    /**\n     * The receive stream buffer\n     */\n    ByteFifoBuffer recv_stream;\n\n    /**\n     * Performs ping-pong test for <tt>iterations</tt> with packets of\n     * <tt>size</tt> bytes\n     */\n    private void doTestPingPong(int size, int iterations)\n    {\n        Thread.setDefaultUncaughtExceptionHandler(this);\n        long start;\n        iterationsRemaining = iterations;\n        receiver = getRemoteTcp();\n        sender = getLocalTcp();\n        // Create some dummy data\n        byte[] dummy = createDummyData(size);\n        send_stream = new ByteFifoBuffer(size);\n        send_stream.write(dummy, size);\n        //Prepare the receive stream\n        recv_stream = new ByteFifoBuffer(size);\n        //Connect and wait until connected\n        start = PseudoTCPBase.now();\n        startClocks();\n        try\n        {\n            connect();\n        }\n        catch (IOException ex)\n        {\n            ex.printStackTrace();\n            fail(ex.getMessage());\n        }\n        //assert Connect() == 0;\n        assert_Connected_wait(kConnectTimeoutMs);\n        // Sending will start from OnTcpWriteable and stop when the required\n        // number of iterations have completed.\n        assert_Disconnected_wait(kMinTransferRate);\n        long elapsed = PseudoTCPBase.now() - start;\n        stopClocks();\n        logger.log(Level.INFO,\n                   \"Performed \" + iterations + \" pings in \" + elapsed + \" ms\");\n    }\n\n    /**\n     * Catches onTcpReadable event for receiver\n     */\n    @Override\n    public void onTcpReadable(PseudoTCPBase tcp)\n    {\n        assertEquals(receiver, tcp, \"Unexpected onTcpReadable\");\n        try\n        {\n            // Stream bytes to the recv stream as they arrive.\n            readData();\n        }\n        catch (IOException ex)\n        {\n            //will be caught by default handler and test will fail\n            throw new RuntimeException(ex);\n        }\n        // If we've received the desired amount of data, rewind things\n        // and send it back the other way!\n        int recvd = recv_stream.getBuffered();\n        int required = send_stream.length();\n        if (logger.isLoggable(Level.FINER))\n        {\n            logger.log(Level.FINER,\n                       \"test - receivied: \" + recvd + \" required: \" + required);\n        }\n\n        if (recvd == required)\n        {\n            if (receiver == getLocalTcp() && --iterationsRemaining == 0)\n            {\n                close();\n                // TODO: Fake OnTcpClosed() on the receiver for now.\n                onTcpClosed(getRemoteTcp(), null);\n                return;\n            }\n            //switches receivier with sender and performs test the other way\n            PseudoTCPBase tmp = receiver;\n            receiver = sender;\n            sender = tmp;\n            send_stream.resetReadPosition();\n            send_stream.consumeWriteBuffer(send_stream.getWriteRemaining());\n            recv_stream.resetWritePosition();\n            onTcpWriteable(sender);\n        }\n\n    }\n\n    /**\n     * Catches the ontcpWriteable event for sender\n     */\n    @Override\n    public void onTcpWriteable(PseudoTCPBase tcp)\n    {\n        if (tcp != sender)\n        {\n            return;\n        }\n        // Write bytes from the send stream when we can.\n        // Shut down when we've sent everything.\n        logger.log(Level.FINER, \"Flow Control Lifted\");\n        try\n        {\n            writeData();\n        }\n        catch (IOException ex)\n        {\n            throw new RuntimeException(ex);\n        }\n\n    }\n\n    /**\n     * Reads the data in loop until is something available\n     */\n    private void readData() throws IOException\n    {\n        byte[] block = new byte[kBlockSize];\n        int rcvd;\n        do\n        {\n            rcvd = receiver.recv(block, block.length);\n            if (rcvd > 0)\n            {\n                recv_stream.write(block, rcvd);\n                if (logger.isLoggable(Level.FINE))\n                {\n                    logger.log(Level.FINE,\n                               \"Receivied: \" + recv_stream.getBuffered());\n                }\n            }\n        }\n        while (rcvd > 0);\n    }\n\n    /**\n     * Writes all data to the receiver\n     */\n    private void writeData() throws IOException\n    {\n        int tosend;\n        int sent;\n        byte[] block = new byte[kBlockSize];\n        do\n        {\n            tosend = bytesPerSend != 0 ? bytesPerSend : block.length;\n            tosend = send_stream.read(block, tosend);\n            if (tosend > 0)\n            {\n                sent = sender.send(block, tosend);\n                updateLocalClock();\n                if (sent != -1)\n                {\n                    if(logger.isLoggable(Level.FINE))\n                    {\n                        logger.log(Level.FINE, \"Sent: \" + sent);\n                    }\n                }\n                else\n                {\n                    logger.log(Level.FINE, \"Flow controlled\");\n                }\n            }\n            else\n            {\n                sent = tosend = 0;\n            }\n        }\n        while (sent > 0);\n    }\n\n    /*\n     *\n     * Ping-pong (request/response) tests\n     *\n     */\n    /**\n     * Test sending <= 1x MTU of data in each ping/pong. Should take <10ms.\n     */\n    @Test\n    public void testPingPong1xMtu()\n    {\n        //logger.log(Level.INFO, \"Test ping - pong 1xMTU\");\n        PseudoTcpTestPingPong test = new PseudoTcpTestPingPong();\n        test.setLocalMtu(1500);\n        test.setRemoteMtu(1500);\n        test.doTestPingPong(100, 100);\n    }\n\n    /**\n     * Test sending 2x-3x MTU of data in each ping/pong. Should take <10ms.\n     */\n    @Test\n    public void testPingPong3xMtu()\n    {\n        //logger.log(Level.INFO, \"Test ping - pong 3xMTU\");\n        PseudoTcpTestPingPong test = new PseudoTcpTestPingPong();\n        test.setLocalMtu(1500);\n        test.setRemoteMtu(1500);\n        test.doTestPingPong(400, 100);\n    }\n\n    /**\n     * Test sending 1x-2x MTU of data in each ping/pong. Should take ~1s, due to\n     * interaction between Nagling and Delayed ACK.\n     */\n    @Test\n    public void testPingPong2xMtu()\n    {\n        //logger.log(Level.INFO, \"Test ping - pong 2xMTU\");\n        PseudoTcpTestPingPong test = new PseudoTcpTestPingPong();\n        test.setLocalMtu(1500);\n        test.setRemoteMtu(1500);\n        test.doTestPingPong(2000, 5);\n    }\n\n    /**\n     * Test sending 1x-2x MTU of data in each ping/pong with Delayed ACK off.\n     * Should take <10ms.\n     */\n    @Test\n    public void testPingPong2xMtuWithAckDelayOff()\n    {\n        //logger.log(Level.INFO, \"Test ping - pong 2xMTU ack delay off\");\n        PseudoTcpTestPingPong test = new PseudoTcpTestPingPong();\n        test.setLocalMtu(1500);\n        test.setRemoteMtu(1500);\n        test.setOptAckDelay(0);\n        test.doTestPingPong(2000, 100);\n    }\n\n    /**\n     * Test sending 1x-2x MTU of data in each ping/pong with Nagling off. Should\n     * take <10ms.\n     */\n    @Test\n    public void testPingPong2xMtuWithNaglingOff()\n    {\n        //logger.log(Level.INFO, \"Test ping - pong 2xMTU nagling off\");\n        PseudoTcpTestPingPong test = new PseudoTcpTestPingPong();\n        test.setLocalMtu(1500);\n        test.setRemoteMtu(1500);\n        test.setOptNagling(false);\n        test.doTestPingPong(2000, 5);\n    }\n\n    /**\n     * Test sending a ping as pair of short (non-full) segments. Should take\n     * ~1s, due to Delayed ACK interaction with Nagling.\n     */\n    @Test\n    public void testPingPongShortSegments()\n    {\n        //logger.log(Level.INFO, \"Test ping - pong short segments\");\n        PseudoTcpTestPingPong test = new PseudoTcpTestPingPong();\n        test.setLocalMtu(1500);\n        test.setRemoteMtu(1500);\n        test.setOptAckDelay(5000);\n        test.setBytesPerSend(50); // i.e. two Send calls per payload\n        test.doTestPingPong(100, 5);\n    }\n\n    /**\n     * Test sending ping as a pair of short (non-full) segments, with Nagling\n     * off. Should take <10ms.\n     */\n    @Test\n    public void testPingPongShortSegmentsWithNaglingOff()\n    {\n        //logger.log(Level.INFO, \"Test ping - pong short segments nagling off\");\n        PseudoTcpTestPingPong test = new PseudoTcpTestPingPong();\n        test.setLocalMtu(1500);\n        test.setRemoteMtu(1500);\n        test.setOptNagling(false);\n        test.setBytesPerSend(50); // i.e. two Send calls per payload\n        test.doTestPingPong(100, 5);\n    }\n\n    /**\n     * Test sending <= 1x MTU of data ping/pong, in two segments, no Delayed\n     * ACK. Should take ~1s.\n     */\n    @Test\n    public void testPingPongShortSegmentsWithAckDelayOff()\n    {\n        //logger.log(Level.INFO, \"Test ping - pong short segments nagling off\");\n        PseudoTcpTestPingPong test = new PseudoTcpTestPingPong();\n        test.setLocalMtu(1500);\n        test.setRemoteMtu(1500);\n        test.setBytesPerSend(50); // i.e. two Send calls per payload\n        test.setOptAckDelay(0);\n        test.doTestPingPong(100, 5);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Logger logger =\n        Logger.getLogger(PseudoTCPBase.class.getName());", "docstring": "\nThe logger.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Logger", "name": "logger =\n        Logger.getLogger(PseudoTCPBase.class.getName())", "syntax_pass": true}, {"attribute_expression": "private PseudoTCPBase sender;", "docstring": "\nThe sender\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "PseudoTCPBase", "name": "sender", "syntax_pass": true}, {"attribute_expression": "private PseudoTCPBase receiver;", "docstring": "\nThe receiver\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "PseudoTCPBase", "name": "receiver", "syntax_pass": true}, {"attribute_expression": "private int bytesPerSend;", "docstring": "\nHow much data is sent per ping\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "bytesPerSend", "syntax_pass": true}, {"attribute_expression": "private int iterationsRemaining;", "docstring": "\nIterations count\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "iterationsRemaining", "syntax_pass": true}, {"attribute_expression": "ByteFifoBuffer send_stream;", "docstring": "\nThe send stream buffer\n", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "ByteFifoBuffer", "name": "send_stream", "syntax_pass": true}, {"attribute_expression": "ByteFifoBuffer recv_stream;", "docstring": "\nThe receive stream buffer\n", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "ByteFifoBuffer", "name": "recv_stream", "syntax_pass": true}]}, {"uris": "src/test/java/org/ice4j/pseudotcp/util/ByteFifoBufferTest.java.ByteFifoBufferTest", "name": "ByteFifoBufferTest", "file_path": "src/test/java/org/ice4j/pseudotcp/util/ByteFifoBufferTest.java", "superclasses": "", "methods": ["[void]testLength()", "[void]testRead()", "[void]testReadWithOffset()", "[void]testGetWriteRemaining()", "[void]testGetBuffered()", "[void]testWrite()", "[void]testWriteWithOffset()", "[void]testConsumeWriteBuffer()", "[void]testSetCapacity()", "[void]testConsumeReadData()", "[void]testReadOffset()", "[void]testWriteOffset()", "[void]testWriteReadWriteRead()", "[void]testSomeMultiTest()"], "method_uris": ["src/test/java/org/ice4j/pseudotcp/util/ByteFifoBufferTest.java.ByteFifoBufferTest.[]ByteFifoBufferTest()", "src/test/java/org/ice4j/pseudotcp/util/ByteFifoBufferTest.java.ByteFifoBufferTest.[byte[]]getWData(int)"], "overrides": null, "attributes": [], "class_docstring": "\n\n@author Pawel Domas\n", "original_string": "public class ByteFifoBufferTest\n{\n    public ByteFifoBufferTest()\n    {\n    }\n\n    /**\n     * Test of Length method, of class ByteFifoBuffer.\n     */\n    @Test\n    public void testLength()\n    {\n        int expResult = 1000;\n        ByteFifoBuffer instance = new ByteFifoBuffer(expResult);\n        assertEquals(expResult, instance.length());\n        int wSize = 100;\n        instance.write(getWData(wSize), wSize);\n        int result = instance.length();\n        assertEquals(expResult, result);\n    }\n\n    /**\n     * Test of Read method, of class ByteFifoBuffer.\n     */\n    @Test\n    public void testRead()\n    {\n        int count = 1024;\n        byte[] wData = getWData(count);\n        ByteFifoBuffer instance = new ByteFifoBuffer(count);\n        instance.write(wData, count);\n\n        byte[] readBuff = new byte[count];\n        int result = instance.read(readBuff, count);\n        assertEquals(count, result);\n        assertArrayEquals(wData, readBuff);\n\n    }\n    \n    /**\n     * Tests reading with an offset for destination buffer\n     */\n    @Test\n    public void testReadWithOffset()\n    {\n        int count = 1024;\n        byte[] wData = getWData(count);\n        ByteFifoBuffer instance = new ByteFifoBuffer(count);\n        instance.write(wData, count);\n\n        byte[] readBuff = new byte[count];\n        int expResult = count / 2;\n        int result = instance.read(readBuff, count / 2);\n        assertEquals(expResult, result);\n\n        result = instance.read(readBuff, count / 2, count / 2);\n        assertEquals(expResult, result);\n\n        assertArrayEquals(wData, readBuff);\n\n    }\n\n    /**\n     * return some random array\n     * \n     * @param count array size\n     */\n    private byte[] getWData(int count)\n    {\n        Random r = new Random();\n        byte[] res = new byte[count];\n        r.nextBytes(res);\n        return res;\n    }\n\n    /**\n     * Test of GetWriteRemaining method, of class ByteFifoBuffer.\n     */\n    @Test\n    public void testGetWriteRemaining()\n    {\n        int len = 100;\n        ByteFifoBuffer instance = new ByteFifoBuffer(len);\n        int expResult = len;\n        int result = instance.getWriteRemaining();\n        assertEquals(expResult, result);\n\n        int w_size = 23;\n        byte[] w_data = getWData(w_size);\n        instance.write(w_data, w_size);\n\n        expResult = len - w_size;\n        result = instance.getWriteRemaining();\n        assertEquals(expResult, result);\n    }\n\n    /**\n     * Test of GetBuffered method, of class ByteFifoBuffer.\n     */\n    @Test\n    public void testGetBuffered()\n    {\n        int len = 1000;\n        ByteFifoBuffer instance = new ByteFifoBuffer(len);\n        int w_len = 100;\n        byte[] w_data = getWData(w_len);\n\n        instance.write(w_data, w_len);\n\n        int expResult = w_len;\n        int result = instance.getBuffered();\n        assertEquals(expResult, result);\n        int consume = 5;\n        expResult = w_len + consume;\n        instance.consumeWriteBuffer(consume);\n        result = instance.getBuffered();\n        assertEquals(expResult, result);\n    }\n\n    /**\n     * Test of Write method, of class ByteFifoBuffer.\n     */\n    @Test\n    public void testWrite()\n    {\n        int len = 2048;\n        byte[] data = getWData(len);\n        ByteFifoBuffer instance = new ByteFifoBuffer(len);\n        int result = instance.write(data, len);\n        assertEquals(len, result);\n\n        byte[] read = new byte[len];\n        int readCount = instance.read(read, len);\n        assertEquals(result, readCount);\n        assertArrayEquals(data, read);\n    }\n\n    @Test\n    public void testWriteWithOffset()\n    {\n        int len = 2048;\n        byte[] data = getWData(len);\n        ByteFifoBuffer instance = new ByteFifoBuffer(len);\n        int expResult = len / 2;\n        int result = instance.write(data, 0, len / 2);\n        assertEquals(expResult, result);\n        result = instance.write(data, len / 2, len / 2);\n        assertEquals(expResult, result);\n\n        byte[] read = new byte[len];\n        int readCount = instance.read(read, len);\n        assertEquals(len, readCount);\n        assertArrayEquals(data, read);\n    }\n\n    /**\n     * Test of ConsumeWriteBuffer method, of class ByteFifoBuffer.\n     */\n    @Test\n    public void testConsumeWriteBuffer()\n    {\n        int len = 100;\n        ByteFifoBuffer instance = new ByteFifoBuffer(len);\n        instance.consumeWriteBuffer(len / 2);\n        instance.consumeWriteBuffer(len / 2);\n        try\n        {\n            instance.consumeWriteBuffer(1);\n            fail();\n        }\n        catch (BufferOverflowException e)\n        {\n        }\n\n        instance = new ByteFifoBuffer(len);\n        instance.consumeWriteBuffer(95);\n        instance.consumeReadData(40);\n        instance.consumeWriteBuffer(20);\n\n    }\n\n    /**\n     * Test of SetCapacity method, of class ByteFifoBuffer.\n     */\n    @Test\n    public void testSetCapacity()\n    {\n        int old_size = 100;\n        int new_size = 200;\n        ByteFifoBuffer instance = new ByteFifoBuffer(old_size);\n        boolean expResult = true;\n        instance.write(getWData(old_size), old_size);\n        boolean result = instance.setCapacity(new_size);\n        assertEquals(expResult, result);\n\n        expResult = false;\n        instance.resetWritePosition();\n        instance.write(getWData(new_size), new_size);\n        result = instance.setCapacity(old_size);\n        assertEquals(expResult, result);\n\n    }\n\n    /**\n     * Test of ConsumeReadData method, of class ByteFifoBuffer.\n     */\n    @Test\n    public void testConsumeReadData()\n    {\n        int lCount = 100;\n        ByteFifoBuffer instance = new ByteFifoBuffer(lCount);\n        instance.write(getWData(lCount), lCount);\n        instance.consumeReadData(lCount / 2);\n        instance.consumeReadData(lCount / 2);\n        try\n        {\n            instance.consumeReadData(1);\n            fail();\n        }\n        catch (BufferUnderflowException e)\n        {\n        }\n\n    }\n\n    /**\n     * Test of ReadOffset method, of class ByteFifoBuffer.\n     */\n    @Test\n    public void testReadOffset()\n    {\n        int dst_buff_offset = 0;\n        int len = 100;\n        byte[] src_buff = getWData(len);\n        byte[] dst_buff = new byte[len];\n        int offset = 0;\n        ByteFifoBuffer instance = new ByteFifoBuffer(len);\n        instance.write(src_buff, len);\n        int result =\n            instance.readOffset(dst_buff, dst_buff_offset, len, offset);\n        assertEquals(len, result);\n        assertArrayEquals(dst_buff, src_buff);\n\n    }\n\n    /**\n     * Test of WriteOffset method, of class ByteFifoBuffer.\n     */\n    @Test\n    public void testWriteOffset()\n    {\n        int len = 200;\n        int dataLen = 100;\n        byte[] srcData = getWData(dataLen);\n        byte[] data = new byte[dataLen];\n        int nOffset = 10;\n        ByteFifoBuffer instance = new ByteFifoBuffer(len);\n        int result = instance.writeOffset(srcData, dataLen, nOffset);\n        int readCount = instance.readOffset(data, 0, dataLen, nOffset);\n        assertEquals(result, readCount);\n        assertArrayEquals(srcData, data);\n\n        byte[] halfFilled = new byte[dataLen * 2];\n        System.arraycopy(srcData, 0, halfFilled, dataLen, dataLen);\n        byte[] halfFilledRead = new byte[dataLen * 2];\n        instance.readOffset(halfFilledRead, dataLen, dataLen, nOffset);\n        assertArrayEquals(halfFilled, halfFilledRead);\n\n        // case when w_pos+offset exceeds current backing array length\n        instance = new ByteFifoBuffer(len);\n        instance.write(srcData, dataLen);\n        instance.write(srcData, dataLen / 2);// current writePos = 150\n        instance.read(data, dataLen);// curretn readPos = 100\n        instance.writeOffset(srcData, dataLen, 50);\n\n        instance = new ByteFifoBuffer(61440);\n        instance.writeOffset(getWData(1384), 1384, 31832);\n\n    }\n\n    @Test\n    public void testWriteReadWriteRead()\n    {\n        int len = 2000;\n        ByteFifoBuffer instance = new ByteFifoBuffer(len);\n        byte[] wrData = getWData(len * 2);\n        int written = 0;\n        byte[] readBuff = new byte[wrData.length];\n        int read = 0;\n        do\n        {\n            int wrRemaining = instance.getWriteRemaining();\n            if (wrRemaining > 0 && written < wrData.length)\n            {\n                int wrCount = instance.writeOffset(wrData, wrRemaining, 0);\n                instance.consumeWriteBuffer(wrCount);\n                written += wrCount;\n            }\n            int readAvailable = instance.getBuffered();\n            if (readAvailable > 0)\n            {\n                int rCount =\n                    instance.readOffset(readBuff, read, readAvailable, 0);\n                instance.consumeReadData(rCount);\n                read += rCount;\n            }\n        }\n        while ((read != wrData.length) || (written != wrData.length));\n    }\n\n    @Test\n    public void testSomeMultiTest()\n    {\n        int Alen = 16;\n        int Blen = 32;\n        int Clen = 64;\n        int Dlen = 256;\n        int len = Alen + Blen + Clen + Dlen;\n        ByteFifoBuffer fifo = new ByteFifoBuffer(len);\n        byte[] A = getWData(Alen);\n        /*byte[] B =*/ getWData(Blen);\n        /*byte[] C =*/ getWData(Clen);\n        /*byte[] D =*/ getWData(Dlen);\n        byte[] Aread = getWData(Alen);\n        /*byte[] Bread =*/ getWData(Blen);\n        /*byte[] Cread =*/ getWData(Clen);\n        /*byte[] Dread =*/ getWData(Dlen);\n\n        fifo.writeOffset(A, Alen, 0);\n        fifo.consumeWriteBuffer(Alen);\n        fifo.readOffset(Aread, 0, Alen, 0);\n        assertArrayEquals(A, Aread);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/ice4j/pseudotcp/util/ByteFifoBuffer_consumeWriteBufferTest.java.ByteFifoBuffer_consumeWriteBufferTest", "name": "ByteFifoBuffer_consumeWriteBufferTest", "file_path": "src/test/java/org/ice4j/pseudotcp/util/ByteFifoBuffer_consumeWriteBufferTest.java", "superclasses": "", "methods": ["[void]testConsumeWriteBufferSuccess()", "[void]testConsumeWriteBufferOverflow()", "[void]testConsumeWriteBufferNegativeCount()", "[void]testConsumeWriteBufferWithWrite()", "[void]testConsumeWriteBufferWithWriteAndOverflow()"], "method_uris": ["src/test/java/org/ice4j/pseudotcp/util/ByteFifoBuffer_consumeWriteBufferTest.java.ByteFifoBuffer_consumeWriteBufferTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class ByteFifoBuffer_consumeWriteBufferTest {\n    private ByteFifoBuffer buffer;\n\n    @BeforeEach\n    public void setUp() {\n        buffer = new ByteFifoBuffer(1024);\n    }\n\n    @Test\n    public void testConsumeWriteBufferSuccess() {\n        int count = 512;\n        buffer.consumeWriteBuffer(count);\n        assertEquals(512, buffer.getBuffered());\n        assertEquals(512, buffer.getWriteRemaining());\n    }\n\n    @Test\n    public void testConsumeWriteBufferOverflow() {\n        int count = 1025;\n        assertThrows(BufferOverflowException.class, () -> buffer.consumeWriteBuffer(count));\n    }\n\n    @Test\n    public void testConsumeWriteBufferNegativeCount() {\n        int count = -1;\n        assertThrows(IllegalArgumentException.class, () -> buffer.consumeWriteBuffer(count));\n    }\n\n    @Test\n    public void testConsumeWriteBufferWithWrite() {\n        int writeCount = 512;\n        byte[] data = new byte[writeCount];\n        buffer.write(data, 0, writeCount);\n        assertEquals(512, buffer.getBuffered());\n        assertEquals(512, buffer.getWriteRemaining());\n\n        int consumeCount = 256;\n        buffer.consumeWriteBuffer(consumeCount);\n        assertEquals(768, buffer.getBuffered());\n        assertEquals(256, buffer.getWriteRemaining());\n    }\n\n    @Test\n    public void testConsumeWriteBufferWithWriteAndOverflow() {\n        int writeCount = 512;\n        byte[] data = new byte[writeCount];\n        buffer.write(data, 0, writeCount);\n        assertEquals(512, buffer.getBuffered());\n        assertEquals(512, buffer.getWriteRemaining());\n\n        int consumeCount = 513;\n        assertThrows(BufferOverflowException.class, () -> buffer.consumeWriteBuffer(consumeCount));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private ByteFifoBuffer buffer;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ByteFifoBuffer", "name": "buffer", "syntax_pass": true}]}, {"uris": "src/test/java/org/ice4j/pseudotcp/util/ByteFifoBuffer_resetWritePositionTest.java.ByteFifoBuffer_resetWritePositionTest", "name": "ByteFifoBuffer_resetWritePositionTest", "file_path": "src/test/java/org/ice4j/pseudotcp/util/ByteFifoBuffer_resetWritePositionTest.java", "superclasses": "", "methods": ["[void]testResetWritePosition()"], "method_uris": ["src/test/java/org/ice4j/pseudotcp/util/ByteFifoBuffer_resetWritePositionTest.java.ByteFifoBuffer_resetWritePositionTest.[void]setUp()", "src/test/java/org/ice4j/pseudotcp/util/ByteFifoBuffer_resetWritePositionTest.java.ByteFifoBuffer_resetWritePositionTest.[byte[]]getWData(int)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class ByteFifoBuffer_resetWritePositionTest {\n\n    private ByteFifoBuffer byteFifoBuffer;\n\n    @BeforeEach\n    public void setUp() {\n        byteFifoBuffer = new ByteFifoBuffer(1000);\n    }\n\n    @Test\n    public void testResetWritePosition() {\n        int w_len = 100;\n        byte[] w_data = getWData(w_len);\n\n        byteFifoBuffer.write(w_data, w_len);\n        byteFifoBuffer.consumeWriteBuffer(50);\n\n        byteFifoBuffer.resetWritePosition();\n\n        assertEquals(0, byteFifoBuffer.getBuffered());\n        assertEquals(1000, byteFifoBuffer.getWriteRemaining());\n    }\n\n    private byte[] getWData(int length) {\n        byte[] data = new byte[length];\n        for (int i = 0; i < length; i++) {\n            data[i] = (byte) (i % 256);\n        }\n        return data;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private ByteFifoBuffer byteFifoBuffer;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ByteFifoBuffer", "name": "byteFifoBuffer", "syntax_pass": true}]}, {"uris": "src/test/java/org/ice4j/pseudotcp/util/ByteFifoBuffer_setCapacityTest.java.ByteFifoBuffer_setCapacityTest", "name": "ByteFifoBuffer_setCapacityTest", "file_path": "src/test/java/org/ice4j/pseudotcp/util/ByteFifoBuffer_setCapacityTest.java", "superclasses": "", "methods": ["[void]testSetCapacitySuccess()", "[void]testSetCapacityFailure()", "[void]testSetCapacityWithConsumeWriteBuffer()", "[void]testSetCapacityWithWriteRemaining()"], "method_uris": ["src/test/java/org/ice4j/pseudotcp/util/ByteFifoBuffer_setCapacityTest.java.ByteFifoBuffer_setCapacityTest.[void]setUp()", "src/test/java/org/ice4j/pseudotcp/util/ByteFifoBuffer_setCapacityTest.java.ByteFifoBuffer_setCapacityTest.[byte[]]getWData(int)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class ByteFifoBuffer_setCapacityTest {\n    private ByteFifoBuffer byteFifoBuffer;\n\n    @BeforeEach\n    public void setUp() {\n        byteFifoBuffer = new ByteFifoBuffer(1000);\n    }\n\n    @Test\n    public void testSetCapacitySuccess() {\n        byte[] w_data = getWData(100);\n        byteFifoBuffer.write(w_data, 100);\n\n        assertTrue(byteFifoBuffer.setCapacity(1500));\n        assertEquals(1500, byteFifoBuffer.length());\n        assertEquals(100, byteFifoBuffer.getBuffered());\n    }\n\n    @Test\n    public void testSetCapacityFailure() {\n        byte[] w_data = getWData(100);\n        byteFifoBuffer.write(w_data, 100);\n\n        assertFalse(byteFifoBuffer.setCapacity(50));\n        assertEquals(1000, byteFifoBuffer.length());\n        assertEquals(100, byteFifoBuffer.getBuffered());\n    }\n\n    @Test\n    public void testSetCapacityWithConsumeWriteBuffer() {\n        byte[] w_data = getWData(100);\n        byteFifoBuffer.write(w_data, 100);\n        byteFifoBuffer.consumeWriteBuffer(50);\n\n        assertTrue(byteFifoBuffer.setCapacity(1500));\n        assertEquals(1500, byteFifoBuffer.length());\n        assertEquals(150, byteFifoBuffer.getBuffered());\n    }\n\n    @Test\n    public void testSetCapacityWithWriteRemaining() {\n        byte[] w_data = getWData(100);\n        byteFifoBuffer.write(w_data, 100);\n\n        assertTrue(byteFifoBuffer.setCapacity(1500));\n        assertEquals(1500, byteFifoBuffer.length());\n        assertEquals(1400, byteFifoBuffer.getWriteRemaining());\n    }\n\n    private byte[] getWData(int length) {\n        byte[] data = new byte[length];\n        for (int i = 0; i < length; i++) {\n            data[i] = (byte) (i % 256);\n        }\n        return data;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private ByteFifoBuffer byteFifoBuffer;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ByteFifoBuffer", "name": "byteFifoBuffer", "syntax_pass": true}]}, {"uris": "src/test/java/org/ice4j/ice/RoleConflictResolutionTest.java.RoleConflictResolutionTest", "name": "RoleConflictResolutionTest", "file_path": "src/test/java/org/ice4j/ice/RoleConflictResolutionTest.java", "superclasses": "", "methods": ["[void]testRecoveryFromBothControlledConflict()", "[void]testRecoveryFromBothControllingConflict()"], "method_uris": ["src/test/java/org/ice4j/ice/RoleConflictResolutionTest.java.RoleConflictResolutionTest.[void]testRecoveryFromRoleConflict(boolean)", "src/test/java/org/ice4j/ice/RoleConflictResolutionTest.java.RoleConflictResolutionTest.[Agent]createPeer(String,boolean)", "src/test/java/org/ice4j/ice/RoleConflictResolutionTest.java.RoleConflictResolutionTest.[void]disposePeer(Agent)", "src/test/java/org/ice4j/ice/RoleConflictResolutionTest.java.RoleConflictResolutionTest.[void]logSelectedPairs(Agent)", "src/test/java/org/ice4j/ice/RoleConflictResolutionTest.java.RoleConflictResolutionTest.[void]exchangeCredentials(Agent,Agent)", "src/test/java/org/ice4j/ice/RoleConflictResolutionTest.java.RoleConflictResolutionTest.[void]exchangeCandidates(Agent,Agent)", "src/test/java/org/ice4j/ice/RoleConflictResolutionTest.java.RoleConflictResolutionTest.[void]copyRemoteCandidates(Component,Component)"], "overrides": null, "attributes": [], "class_docstring": "\nRoleConflictResolutionTest set of tests which does end-to-end test\nof ICE role conflict recovery.\n\n@author Yura Yaroshevich\n", "original_string": "public class RoleConflictResolutionTest\n{\n    protected static final Logger logger\n        = Logger.getLogger(RoleConflictResolutionTest.class.getName());\n\n    @Test\n    public void testRecoveryFromBothControlledConflict()\n        throws Throwable\n    {\n        testRecoveryFromRoleConflict(false);\n    }\n\n    @Test\n    public void testRecoveryFromBothControllingConflict()\n        throws Throwable\n    {\n        testRecoveryFromRoleConflict(true);\n    }\n\n    private static void testRecoveryFromRoleConflict(boolean bothControlling)\n        throws Throwable\n    {\n        final Agent peer1 = createPeer(\"[peer-1]\", bothControlling);\n        // Set explicit tie-breakers to avoid automatic conflict resolution\n        peer1.setTieBreaker(1);\n\n        final Agent peer2 = createPeer(\"[peer-2]\", bothControlling);\n        peer1.setTieBreaker(2);\n\n        final CountDownLatch countDownLatch = new CountDownLatch(2);\n\n        for (Agent peer : Arrays.asList(peer1, peer2))\n        {\n            peer.addStateChangeListener(evt ->\n            {\n                logger.info(peer.toString() + \": state changed to \"\n                    + evt.toString());\n                if (peer.getState().isEstablished())\n                {\n                    countDownLatch.countDown();\n                }\n            });\n        }\n\n        exchangeCredentials(peer1, peer2);\n        exchangeCandidates(peer1, peer2);\n\n        peer1.startConnectivityEstablishment();\n        peer2.startConnectivityEstablishment();\n\n        boolean isConnected = countDownLatch.await(20, TimeUnit.SECONDS);\n\n        logSelectedPairs(peer1);\n        logSelectedPairs(peer2);\n\n        assertTrue(isConnected,\n            \"Expected connection established within time out\");\n        assertTrue(peer1.getState().isEstablished(),\n            \"peer 1 connectivity\");\n        assertTrue(peer2.getState().isEstablished(),\n            \"peer 2 connectivity\");\n\n        disposePeer(peer1);\n        disposePeer(peer2);\n    }\n\n    private static Agent createPeer(String label, boolean iceControlling)\n        throws IOException\n    {\n        final Agent agent = new Agent(label, null);\n        agent.setControlling(iceControlling);\n        IceMediaStream iceStream = agent.createMediaStream(\"media-stream\");\n\n        agent.createComponent(\n            iceStream,\n            0x400, 0x400, 0xFFFF,\n            KeepAliveStrategy.ALL_SUCCEEDED,\n            true);\n\n        return agent;\n    }\n\n    private static void disposePeer(Agent peer)\n    {\n        peer.free();\n    }\n\n    private static void logSelectedPairs(Agent peer)\n    {\n        for (IceMediaStream stream : peer.getStreams())\n        {\n            for (Component component : stream.getComponents())\n            {\n                CandidatePair selectedPair = component.getSelectedPair();\n                if (selectedPair != null)\n                {\n                    logger.info(\n                            peer + \": selected pair for \" + \"component \" + component.getName() + \" :\" + selectedPair);\n                }\n            }\n        }\n    }\n\n    private static void exchangeCredentials(Agent peer1, Agent peer2)\n    {\n        for(IceMediaStream stream : peer2.getStreams())\n        {\n            stream.setRemoteUfrag(peer1.getLocalUfrag());\n            stream.setRemotePassword(peer1.getLocalPassword());\n        }\n\n        for(IceMediaStream stream : peer1.getStreams())\n        {\n            stream.setRemoteUfrag(peer2.getLocalUfrag());\n            stream.setRemotePassword(peer2.getLocalPassword());\n        }\n    }\n\n    private static void exchangeCandidates(Agent peer1, Agent peer2)\n    {\n        for (String streamName : peer1.getStreamNames())\n        {\n            IceMediaStream peer1Stream = peer1.getStream(streamName);\n            IceMediaStream peer2Stream = peer2.getStream(streamName);\n            if (peer1Stream == null || peer2Stream == null)\n            {\n                continue;\n            }\n\n            for (Integer id : peer1Stream.getComponentIDs())\n            {\n                Component peer1Component = peer1Stream.getComponent(id);\n                Component peer2Component = peer2Stream.getComponent(id);\n                if (peer1Component == null || peer2Component == null)\n                {\n                    continue;\n                }\n\n                copyRemoteCandidates(peer1Component, peer2Component);\n                copyRemoteCandidates(peer2Component, peer1Component);\n            }\n        }\n    }\n\n    private static void copyRemoteCandidates(Component localComponent,\n                                             Component remoteComponent)\n    {\n        for(LocalCandidate candidate : remoteComponent.getLocalCandidates())\n        {\n            localComponent.addRemoteCandidate(\n                new RemoteCandidate(\n                    candidate.getTransportAddress(),\n                    localComponent,\n                    candidate.getType(),\n                    candidate.getFoundation(),\n                    candidate.getPriority(),\n                    null));\n        }\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "protected static final Logger logger\n        = Logger.getLogger(RoleConflictResolutionTest.class.getName());", "docstring": "", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "Logger", "name": "logger\n        = Logger.getLogger(RoleConflictResolutionTest.class.getName())", "syntax_pass": true}]}, {"uris": "src/test/java/org/ice4j/ice/harvest/SinglePortUdpHarvester_isHostHarvesterTest.java.SinglePortUdpHarvester_isHostHarvesterTest", "name": "SinglePortUdpHarvester_isHostHarvesterTest", "file_path": "src/test/java/org/ice4j/ice/harvest/SinglePortUdpHarvester_isHostHarvesterTest.java", "superclasses": "", "methods": ["[void]testIsHostHarvester()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class SinglePortUdpHarvester_isHostHarvesterTest {\n\n    @Test\n    public void testIsHostHarvester() {\n        SinglePortUdpHarvester harvester = null;\n        try {\n            harvester = new SinglePortUdpHarvester(null);\n        } catch (IOException e) {\n            fail(\"Failed to create SinglePortUdpHarvester: \" + e.getMessage());\n        }\n        assertTrue(harvester.isHostHarvester());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/ice4j/ice/harvest/SinglePortUdpHarvesterTest.java.SinglePortUdpHarvesterTest", "name": "SinglePortUdpHarvesterTest", "file_path": "src/test/java/org/ice4j/ice/harvest/SinglePortUdpHarvesterTest.java", "superclasses": "", "methods": ["[void]testRebindWithoutCloseThrows()", "[void]testRebindWithClose()", "[void]testBindWithPortZero()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "\nVarious tests that verify the functionality provided by {@link SinglePortUdpHarvester}.\n\n@author Guus der Kinderen, guus.der.kinderen@gmail.com\n", "original_string": "public class SinglePortUdpHarvesterTest\n{\n    /**\n     * Verifies that, without closing, the address used by a harvester cannot be re-used.\n     *\n     * @see <a href=\"https://github.com/jitsi/ice4j/issues/139\">https://github.com/jitsi/ice4j/issues/139</a>\n     */\n    @Test\n    public void testRebindWithoutCloseThrows() throws Exception\n    {\n        // Setup test fixture.\n        final TransportAddress address = new TransportAddress( \"127.0.0.1\", 10000, Transport.UDP );\n        SinglePortUdpHarvester firstHarvester;\n        try\n        {\n            firstHarvester = new SinglePortUdpHarvester( address );\n        }\n        catch (BindException ex)\n        {\n            // This is not expected at this stage (the port is likely already in use by another process, voiding this\n            // test). Rethrow as a different exception than the BindException, that is expected to be thrown later in\n            // this test.\n            throw new Exception( \"Test fixture is invalid.\", ex );\n        }\n\n        // Execute system under test.\n        SinglePortUdpHarvester secondHarvester = null;\n        try\n        {\n            secondHarvester = new SinglePortUdpHarvester( address );\n            fail(\"expected BindException to be thrown at this point\");\n        }\n        catch (BindException ex)\n        {\n            //expected, do nothing\n        }\n        finally\n        {\n            // Tear down\n            firstHarvester.close();\n            if (secondHarvester != null)\n            {\n                secondHarvester.close();\n            }\n        }\n    }\n\n    /**\n     * Verifies that, after closing, the address used by a harvester can be re-used.\n     *\n     * @see <a href=\"https://github.com/jitsi/ice4j/issues/139\">https://github.com/jitsi/ice4j/issues/139</a>\n     */\n    @Test\n    public void testRebindWithClose() throws Exception\n    {\n        // Setup test fixture.\n        final TransportAddress address = new TransportAddress( \"127.0.0.1\", 10001, Transport.UDP );\n        final SinglePortUdpHarvester firstHarvester = new SinglePortUdpHarvester( address );\n        firstHarvester.close();\n        Thread.sleep( 500 ); // give thread time to close/clean up.\n\n        // Execute system under test.\n        SinglePortUdpHarvester secondHarvester = null;\n\n        try\n        {\n            secondHarvester = new SinglePortUdpHarvester( address );\n        }\n\n        // Verify results.\n        catch ( BindException ex )\n        {\n            fail( \"A bind exception should not have been thrown, as the original harvester was properly closed.\");\n        }\n\n        // Tear down.\n        finally\n        {\n            if ( secondHarvester != null )\n            {\n                secondHarvester.close();\n            }\n        }\n    }\n\n    @Test\n    public void testBindWithPortZero() throws Exception\n    {\n        // Setup test fixture.\n        final TransportAddress address = new TransportAddress(\"127.0.0.1\", 0, Transport.UDP);\n        SinglePortUdpHarvester harvester;\n        try\n        {\n            harvester = new SinglePortUdpHarvester(address);\n        }\n        catch (BindException ex)\n        {\n            // This is not expected at this stage.\n            // Rethrow as a different exception than the BindException, that is expected to be thrown later in\n            // this test.\n            throw new Exception(\"Test fixture is invalid.\", ex);\n        }\n\n        assertFalse(harvester.localAddress.getPort() == 0,\n                \"A random port number not equal to zero should have been chosen by the OS\");\n\n        // Tear down\n        harvester.close();\n    }\n}", "super_interfaces": [], "fields": []}]