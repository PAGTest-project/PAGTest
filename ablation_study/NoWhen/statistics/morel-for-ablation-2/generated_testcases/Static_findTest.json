[{"strategy": "retry", "code": "\npackage net.hydromatic.morel.util;\n\nimport com.google.common.collect.ImmutableList;\nimport org.junit.jupiter.api.Test;\n\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.function.Predicate;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class Static_findTest {\n\n    @Test\n    public void testFindRandomAccessList() {\n        List<Integer> list = ImmutableList.of(1, 2, 3, 4, 5);\n        Predicate<Integer> predicate = i -> i == 3;\n        int result = Static.find(list, predicate);\n        assertEquals(2, result);\n    }\n\n    @Test\n    public void testFindNonRandomAccessList() {\n        List<Integer> list = new NonRandomAccessList<>(ImmutableList.of(1, 2, 3, 4, 5));\n        Predicate<Integer> predicate = i -> i == 3;\n        int result = Static.find(list, predicate);\n        assertEquals(2, result);\n    }\n\n    @Test\n    public void testFindNoMatch() {\n        List<Integer> list = ImmutableList.of(1, 2, 3, 4, 5);\n        Predicate<Integer> predicate = i -> i == 6;\n        int result = Static.find(list, predicate);\n        assertEquals(-1, result);\n    }\n\n    private static class NonRandomAccessList<E> implements List<E> {\n        private final List<E> delegate;\n\n        NonRandomAccessList(List<E> delegate) {\n            this.delegate = delegate;\n        }\n\n        @Override\n        public int size() {\n            return delegate.size();\n        }\n\n        @Override\n        public boolean isEmpty() {\n            return delegate.isEmpty();\n        }\n\n        @Override\n        public boolean contains(Object o) {\n            return delegate.contains(o);\n        }\n\n        @Override\n        public Iterator<E> iterator() {\n            return delegate.iterator();\n        }\n\n        @Override\n        public Object[] toArray() {\n            return delegate.toArray();\n        }\n\n        @Override\n        public <T> T[] toArray(T[] a) {\n            return delegate.toArray(a);\n        }\n\n        @Override\n        public boolean add(E e) {\n            return delegate.add(e);\n        }\n\n        @Override\n        public boolean remove(Object o) {\n            return delegate.remove(o);\n        }\n\n        @Override\n        public boolean containsAll(Collection<?> c) {\n            return delegate.containsAll(c);\n        }\n\n        @Override\n        public boolean addAll(Collection<? extends E> c) {\n            return delegate.addAll(c);\n        }\n\n        @Override\n        public boolean addAll(int index, Collection<? extends E> c) {\n            return delegate.addAll(index, c);\n        }\n\n        @Override\n        public boolean removeAll(Collection<?> c) {\n            return delegate.removeAll(c);\n        }\n\n        @Override\n        public boolean retainAll(Collection<?> c) {\n            return delegate.retainAll(c);\n        }\n\n        @Override\n        public void clear() {\n            delegate.clear();\n        }\n\n        @Override\n        public E get(int index) {\n            return delegate.get(index);\n        }\n\n        @Override\n        public E set(int index, E element) {\n            return delegate.set(index, element);\n        }\n\n        @Override\n        public void add(int index, E element) {\n            delegate.add(index, element);\n        }\n\n        @Override\n        public E remove(int index) {\n            return delegate.remove(index);\n        }\n\n        @Override\n        public int indexOf(Object o) {\n            return delegate.indexOf(o);\n        }\n\n        @Override\n        public int lastIndexOf(Object o) {\n            return delegate.lastIndexOf(o);\n        }\n\n        @Override\n        public ListIterator<E> listIterator() {\n            return delegate.listIterator();\n        }\n\n        @Override\n        public ListIterator<E> listIterator(int index) {\n            return delegate.listIterator(index);\n        }\n\n        @Override\n        public List<E> subList(int fromIndex, int toIndex) {\n            return delegate.subList(fromIndex, toIndex);\n        }\n    }\n}\n"}]