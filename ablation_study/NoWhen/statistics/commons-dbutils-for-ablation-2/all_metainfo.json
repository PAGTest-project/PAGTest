[{"relative_path": "src/test/java/org/apache/commons/dbutils/BeanProcessorTest.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils;\n\nimport static org.junit.Assert.assertArrayEquals;\n\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class BeanProcessorTest extends BaseTestCase {\n\n    private static final class IndexedPropertyTestClass {\n        private String name;\n        // Indexed variable with indexed getter and setter\n        private List<String> things;\n        // Indexed variable without indexed getter or setter\n        private List<String> stuff;\n\n        public String getName() {\n            return name;\n        }\n\n        public List<String> getStuff() {\n            return stuff;\n        }\n\n        public String getThing(final int idx) {\n            return things.get(idx);\n        }\n\n        public List<String> getThings() {\n            return things;\n        }\n\n        public void setName(final String name) {\n            this.name = name;\n        }\n\n        public void setStuff(final List<String> stuff) {\n            this.stuff = stuff;\n        }\n\n        public void setThing(final int idx, final String thing) {\n            this.things.set(idx, thing);\n        }\n\n        public void setThings(final List<String> things) {\n            this.things = things;\n        }\n    }\n\n    public static class MapColumnToAnnotationFieldBean {\n        private String one;\n\n        private String two;\n\n        private String three;\n\n        private String four;\n\n        public String getFour() {\n            return four;\n        }\n\n        public String getOne() {\n            return one;\n        }\n\n        @Column(name = \"three_\")\n        public String getThree() {\n            return three;\n        }\n\n        public String getTwo() {\n            return two;\n        }\n\n        public void setFour(final String four) {\n            this.four = four;\n        }\n\n        public void setOne(final String one) {\n            this.one = one;\n        }\n\n        public void setThree(final String three) {\n            this.three = three;\n        }\n\n        public void setTwo(final String two) {\n            this.two = two;\n        }\n    }\n\n    public static class MapColumnToPropertiesBean {\n        private String one;\n\n        private String two;\n\n        private String three;\n\n        private String four;\n\n        public String getFour() {\n            return four;\n        }\n\n        public String getOne() {\n            return one;\n        }\n\n        public String getThree() {\n            return three;\n        }\n\n        public String getTwo() {\n            return two;\n        }\n\n        public void setFour(final String four) {\n            this.four = four;\n        }\n\n        public void setOne(final String one) {\n            this.one = one;\n        }\n\n        public void setThree(final String three) {\n            this.three = three;\n        }\n\n        public void setTwo(final String two) {\n            this.two = two;\n        }\n    }\n\n    private static final class TestNoGetter {\n        private String testField;\n\n        /**\n         * Add setter to trigger JavaBeans to populate a PropertyDescriptor\n         *\n         * @param testField The new testField value\n         */\n        public void setTestField(final String testField) {\n            this.testField = testField;\n        }\n    }\n\n    private static final class TestWrongSetter {\n        private Integer testField;\n\n        public Integer getTestField() {\n            return testField;\n        }\n\n        /**\n         * dbutils checks for a setter with exactly 1 param. This tests resilience to a found setter that doesn't match expectations.\n         *\n         * @param idx\n         * @param testField\n         */\n        public void setTestField(final int idx, final Integer testField) {\n            this.testField = testField;\n        }\n    }\n\n    private static final BeanProcessor beanProc = new BeanProcessor();\n\n    public void testCheckAnnotationOnMissingReadMethod() throws Exception {\n        final String[] colNames = { \"testField\" };\n        final ResultSetMetaData metaData = MockResultSetMetaData.create(colNames);\n\n        final String testField = \"first\";\n        final Object[][] rows = { new Object[] { testField } };\n\n        final ResultSet rs = MockResultSet.create(metaData, rows);\n        assertTrue(rs.next());\n        TestNoGetter testCls = new TestNoGetter();\n        testCls = beanProc.populateBean(rs, testCls);\n        assertEquals(testCls.testField, \"first\");\n    }\n\n    /**\n     * Based on the report in DBUTILS-150. This test validates that indexed property descriptors are not used, and indexed getter/setter methods are not\n     * inspected.\n     *\n     * @throws Exception\n     * @see <a href=\"https://issues.apache.org/jira/browse/DBUTILS-150\">DBUTILS-150</a>\n     */\n    public void testIndexedPropertyDescriptor() throws Exception {\n        final String[] colNames = { \"name\", \"things\", \"stuff\" };\n        final ResultSetMetaData metaData = MockResultSetMetaData.create(colNames);\n\n        final String name = \"first\";\n        final List<String> things = Arrays.asList(\"1\", \"2\", \"3\", \"4\");\n        final List<String> stuff = things;\n        final Object[][] rows = { new Object[] { name, things, stuff } };\n\n        final ResultSet rs = MockResultSet.create(metaData, rows);\n        assertTrue(rs.next());\n        IndexedPropertyTestClass testCls = new IndexedPropertyTestClass();\n        testCls = beanProc.populateBean(rs, testCls);\n        assertEquals(name, testCls.getName());\n        assertArrayEquals(things.toArray(), testCls.getThings().toArray());\n        assertArrayEquals(stuff.toArray(), testCls.getStuff().toArray());\n    }\n\n    public void testMapColumnToAnnotationField() throws Exception {\n        final String[] columnNames = { \"test\", \"test\", \"three_\" };\n        final String[] columnLabels = { \"one\", \"two\", null };\n        final ResultSetMetaData rsmd = ProxyFactory.instance().createResultSetMetaData(new MockResultSetMetaData(columnNames, columnLabels));\n        final PropertyDescriptor[] props = Introspector.getBeanInfo(MapColumnToAnnotationFieldBean.class).getPropertyDescriptors();\n\n        final int[] columns = beanProc.mapColumnsToProperties(rsmd, props);\n        for (int i = 1; i < columns.length; i++) {\n            assertTrue(columns[i] != BeanProcessor.PROPERTY_NOT_FOUND);\n        }\n    }\n\n    public void testMapColumnToProperties() throws Exception {\n        final String[] columnNames = { \"test\", \"test\", \"three\" };\n        final String[] columnLabels = { \"one\", \"two\", null };\n        final ResultSetMetaData rsmd = ProxyFactory.instance().createResultSetMetaData(new MockResultSetMetaData(columnNames, columnLabels));\n        final PropertyDescriptor[] props = Introspector.getBeanInfo(MapColumnToPropertiesBean.class).getPropertyDescriptors();\n\n        final int[] columns = beanProc.mapColumnsToProperties(rsmd, props);\n        for (int i = 1; i < columns.length; i++) {\n            assertTrue(columns[i] != BeanProcessor.PROPERTY_NOT_FOUND);\n        }\n    }\n\n    public void testMapColumnToPropertiesWithOverrides() throws Exception {\n        final Map<String, String> columnToPropertyOverrides = new HashMap<>();\n        columnToPropertyOverrides.put(\"five\", \"four\");\n        final BeanProcessor beanProc = new BeanProcessor(columnToPropertyOverrides);\n        final String[] columnNames = { \"test\", \"test\", \"three\", \"five\" };\n        final String[] columnLabels = { \"one\", \"two\", null, null };\n        final ResultSetMetaData rsmd = ProxyFactory.instance().createResultSetMetaData(new MockResultSetMetaData(columnNames, columnLabels));\n        final PropertyDescriptor[] props = Introspector.getBeanInfo(MapColumnToPropertiesBean.class).getPropertyDescriptors();\n\n        final int[] columns = beanProc.mapColumnsToProperties(rsmd, props);\n        for (int i = 1; i < columns.length; i++) {\n            assertTrue(columns[i] != BeanProcessor.PROPERTY_NOT_FOUND);\n        }\n    }\n\n    public void testProcessWithPopulateBean() throws SQLException {\n        TestBean b = new TestBean();\n        final ResultSet rs = getResultSet();\n        assertTrue(rs.next());\n        b = beanProc.populateBean(rs, b);\n        assertEquals(13.0, b.getColumnProcessorDoubleTest(), 0);\n        assertEquals(b.getThree(), TestBean.Ordinal.THREE);\n\n        assertTrue(rs.next());\n        b = beanProc.populateBean(rs, b);\n        assertEquals(13.0, b.getColumnProcessorDoubleTest(), 0);\n        assertEquals(b.getThree(), TestBean.Ordinal.SIX);\n\n        assertFalse(rs.next());\n    }\n\n    public void testProcessWithToBean() throws SQLException {\n        final ResultSet rs = getResultSet();\n        assertTrue(rs.next());\n        TestBean b = beanProc.toBean(rs, TestBean.class);\n        assertEquals(13.0, b.getColumnProcessorDoubleTest(), 0);\n        assertEquals(b.getThree(), TestBean.Ordinal.THREE);\n\n        assertTrue(rs.next());\n        b = beanProc.toBean(rs, TestBean.class);\n        assertEquals(13.0, b.getColumnProcessorDoubleTest(), 0);\n        assertEquals(b.getThree(), TestBean.Ordinal.SIX);\n\n        assertFalse(rs.next());\n    }\n\n    public void testWrongSetterParamCount() throws Exception {\n        final String[] colNames = { \"testField\" };\n        final ResultSetMetaData metaData = MockResultSetMetaData.create(colNames);\n\n        final Integer testField = 1;\n        final Object[][] rows = { new Object[] { testField } };\n\n        final ResultSet rs = MockResultSet.create(metaData, rows);\n        assertTrue(rs.next());\n        TestWrongSetter testCls = new TestWrongSetter();\n        testCls = beanProc.populateBean(rs, testCls);\n        assertNull(testCls.testField);\n    }\n}\n", "file_hash": "dc71d7a719dfe6917369646db816f78fc0ae856bfd462bb419f8040d5dca82b2", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils;", "import static org.junit.Assert.assertArrayEquals;", "import java.beans.Introspector;", "import java.beans.PropertyDescriptor;", "import java.sql.ResultSet;", "import java.sql.ResultSetMetaData;", "import java.sql.SQLException;", "import java.util.Arrays;", "import java.util.HashMap;", "import java.util.List;", "import java.util.Map;"], "methods": [], "classes": [{"original_string": "public class BeanProcessorTest extends BaseTestCase {\n\n    private static final class IndexedPropertyTestClass {\n        private String name;\n        // Indexed variable with indexed getter and setter\n        private List<String> things;\n        // Indexed variable without indexed getter or setter\n        private List<String> stuff;\n\n        public String getName() {\n            return name;\n        }\n\n        public List<String> getStuff() {\n            return stuff;\n        }\n\n        public String getThing(final int idx) {\n            return things.get(idx);\n        }\n\n        public List<String> getThings() {\n            return things;\n        }\n\n        public void setName(final String name) {\n            this.name = name;\n        }\n\n        public void setStuff(final List<String> stuff) {\n            this.stuff = stuff;\n        }\n\n        public void setThing(final int idx, final String thing) {\n            this.things.set(idx, thing);\n        }\n\n        public void setThings(final List<String> things) {\n            this.things = things;\n        }\n    }\n\n    public static class MapColumnToAnnotationFieldBean {\n        private String one;\n\n        private String two;\n\n        private String three;\n\n        private String four;\n\n        public String getFour() {\n            return four;\n        }\n\n        public String getOne() {\n            return one;\n        }\n\n        @Column(name = \"three_\")\n        public String getThree() {\n            return three;\n        }\n\n        public String getTwo() {\n            return two;\n        }\n\n        public void setFour(final String four) {\n            this.four = four;\n        }\n\n        public void setOne(final String one) {\n            this.one = one;\n        }\n\n        public void setThree(final String three) {\n            this.three = three;\n        }\n\n        public void setTwo(final String two) {\n            this.two = two;\n        }\n    }\n\n    public static class MapColumnToPropertiesBean {\n        private String one;\n\n        private String two;\n\n        private String three;\n\n        private String four;\n\n        public String getFour() {\n            return four;\n        }\n\n        public String getOne() {\n            return one;\n        }\n\n        public String getThree() {\n            return three;\n        }\n\n        public String getTwo() {\n            return two;\n        }\n\n        public void setFour(final String four) {\n            this.four = four;\n        }\n\n        public void setOne(final String one) {\n            this.one = one;\n        }\n\n        public void setThree(final String three) {\n            this.three = three;\n        }\n\n        public void setTwo(final String two) {\n            this.two = two;\n        }\n    }\n\n    private static final class TestNoGetter {\n        private String testField;\n\n        /**\n         * Add setter to trigger JavaBeans to populate a PropertyDescriptor\n         *\n         * @param testField The new testField value\n         */\n        public void setTestField(final String testField) {\n            this.testField = testField;\n        }\n    }\n\n    private static final class TestWrongSetter {\n        private Integer testField;\n\n        public Integer getTestField() {\n            return testField;\n        }\n\n        /**\n         * dbutils checks for a setter with exactly 1 param. This tests resilience to a found setter that doesn't match expectations.\n         *\n         * @param idx\n         * @param testField\n         */\n        public void setTestField(final int idx, final Integer testField) {\n            this.testField = testField;\n        }\n    }\n\n    private static final BeanProcessor beanProc = new BeanProcessor();\n\n    public void testCheckAnnotationOnMissingReadMethod() throws Exception {\n        final String[] colNames = { \"testField\" };\n        final ResultSetMetaData metaData = MockResultSetMetaData.create(colNames);\n\n        final String testField = \"first\";\n        final Object[][] rows = { new Object[] { testField } };\n\n        final ResultSet rs = MockResultSet.create(metaData, rows);\n        assertTrue(rs.next());\n        TestNoGetter testCls = new TestNoGetter();\n        testCls = beanProc.populateBean(rs, testCls);\n        assertEquals(testCls.testField, \"first\");\n    }\n\n    /**\n     * Based on the report in DBUTILS-150. This test validates that indexed property descriptors are not used, and indexed getter/setter methods are not\n     * inspected.\n     *\n     * @throws Exception\n     * @see <a href=\"https://issues.apache.org/jira/browse/DBUTILS-150\">DBUTILS-150</a>\n     */\n    public void testIndexedPropertyDescriptor() throws Exception {\n        final String[] colNames = { \"name\", \"things\", \"stuff\" };\n        final ResultSetMetaData metaData = MockResultSetMetaData.create(colNames);\n\n        final String name = \"first\";\n        final List<String> things = Arrays.asList(\"1\", \"2\", \"3\", \"4\");\n        final List<String> stuff = things;\n        final Object[][] rows = { new Object[] { name, things, stuff } };\n\n        final ResultSet rs = MockResultSet.create(metaData, rows);\n        assertTrue(rs.next());\n        IndexedPropertyTestClass testCls = new IndexedPropertyTestClass();\n        testCls = beanProc.populateBean(rs, testCls);\n        assertEquals(name, testCls.getName());\n        assertArrayEquals(things.toArray(), testCls.getThings().toArray());\n        assertArrayEquals(stuff.toArray(), testCls.getStuff().toArray());\n    }\n\n    public void testMapColumnToAnnotationField() throws Exception {\n        final String[] columnNames = { \"test\", \"test\", \"three_\" };\n        final String[] columnLabels = { \"one\", \"two\", null };\n        final ResultSetMetaData rsmd = ProxyFactory.instance().createResultSetMetaData(new MockResultSetMetaData(columnNames, columnLabels));\n        final PropertyDescriptor[] props = Introspector.getBeanInfo(MapColumnToAnnotationFieldBean.class).getPropertyDescriptors();\n\n        final int[] columns = beanProc.mapColumnsToProperties(rsmd, props);\n        for (int i = 1; i < columns.length; i++) {\n            assertTrue(columns[i] != BeanProcessor.PROPERTY_NOT_FOUND);\n        }\n    }\n\n    public void testMapColumnToProperties() throws Exception {\n        final String[] columnNames = { \"test\", \"test\", \"three\" };\n        final String[] columnLabels = { \"one\", \"two\", null };\n        final ResultSetMetaData rsmd = ProxyFactory.instance().createResultSetMetaData(new MockResultSetMetaData(columnNames, columnLabels));\n        final PropertyDescriptor[] props = Introspector.getBeanInfo(MapColumnToPropertiesBean.class).getPropertyDescriptors();\n\n        final int[] columns = beanProc.mapColumnsToProperties(rsmd, props);\n        for (int i = 1; i < columns.length; i++) {\n            assertTrue(columns[i] != BeanProcessor.PROPERTY_NOT_FOUND);\n        }\n    }\n\n    public void testMapColumnToPropertiesWithOverrides() throws Exception {\n        final Map<String, String> columnToPropertyOverrides = new HashMap<>();\n        columnToPropertyOverrides.put(\"five\", \"four\");\n        final BeanProcessor beanProc = new BeanProcessor(columnToPropertyOverrides);\n        final String[] columnNames = { \"test\", \"test\", \"three\", \"five\" };\n        final String[] columnLabels = { \"one\", \"two\", null, null };\n        final ResultSetMetaData rsmd = ProxyFactory.instance().createResultSetMetaData(new MockResultSetMetaData(columnNames, columnLabels));\n        final PropertyDescriptor[] props = Introspector.getBeanInfo(MapColumnToPropertiesBean.class).getPropertyDescriptors();\n\n        final int[] columns = beanProc.mapColumnsToProperties(rsmd, props);\n        for (int i = 1; i < columns.length; i++) {\n            assertTrue(columns[i] != BeanProcessor.PROPERTY_NOT_FOUND);\n        }\n    }\n\n    public void testProcessWithPopulateBean() throws SQLException {\n        TestBean b = new TestBean();\n        final ResultSet rs = getResultSet();\n        assertTrue(rs.next());\n        b = beanProc.populateBean(rs, b);\n        assertEquals(13.0, b.getColumnProcessorDoubleTest(), 0);\n        assertEquals(b.getThree(), TestBean.Ordinal.THREE);\n\n        assertTrue(rs.next());\n        b = beanProc.populateBean(rs, b);\n        assertEquals(13.0, b.getColumnProcessorDoubleTest(), 0);\n        assertEquals(b.getThree(), TestBean.Ordinal.SIX);\n\n        assertFalse(rs.next());\n    }\n\n    public void testProcessWithToBean() throws SQLException {\n        final ResultSet rs = getResultSet();\n        assertTrue(rs.next());\n        TestBean b = beanProc.toBean(rs, TestBean.class);\n        assertEquals(13.0, b.getColumnProcessorDoubleTest(), 0);\n        assertEquals(b.getThree(), TestBean.Ordinal.THREE);\n\n        assertTrue(rs.next());\n        b = beanProc.toBean(rs, TestBean.class);\n        assertEquals(13.0, b.getColumnProcessorDoubleTest(), 0);\n        assertEquals(b.getThree(), TestBean.Ordinal.SIX);\n\n        assertFalse(rs.next());\n    }\n\n    public void testWrongSetterParamCount() throws Exception {\n        final String[] colNames = { \"testField\" };\n        final ResultSetMetaData metaData = MockResultSetMetaData.create(colNames);\n\n        final Integer testField = 1;\n        final Object[][] rows = { new Object[] { testField } };\n\n        final ResultSet rs = MockResultSet.create(metaData, rows);\n        assertTrue(rs.next());\n        TestWrongSetter testCls = new TestWrongSetter();\n        testCls = beanProc.populateBean(rs, testCls);\n        assertNull(testCls.testField);\n    }\n}", "definition": "public class BeanProcessorTest extends BaseTestCase", "class_docstring": "", "name": "BeanProcessorTest", "super_interfaces": [], "superclasses": "BaseTestCase", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private static final BeanProcessor beanProc = new BeanProcessor();", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "BeanProcessor", "name": "beanProc = new BeanProcessor()", "syntax_pass": true}], "classes": [{"original_string": "    private static final class IndexedPropertyTestClass {\n        private String name;\n        // Indexed variable with indexed getter and setter\n        private List<String> things;\n        // Indexed variable without indexed getter or setter\n        private List<String> stuff;\n\n        public String getName() {\n            return name;\n        }\n\n        public List<String> getStuff() {\n            return stuff;\n        }\n\n        public String getThing(final int idx) {\n            return things.get(idx);\n        }\n\n        public List<String> getThings() {\n            return things;\n        }\n\n        public void setName(final String name) {\n            this.name = name;\n        }\n\n        public void setStuff(final List<String> stuff) {\n            this.stuff = stuff;\n        }\n\n        public void setThing(final int idx, final String thing) {\n            this.things.set(idx, thing);\n        }\n\n        public void setThings(final List<String> things) {\n            this.things = things;\n        }\n    }", "definition": "    private static final class IndexedPropertyTestClass", "class_docstring": "", "name": "IndexedPropertyTestClass", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "fields": [{"attribute_expression": "private String name;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "name", "syntax_pass": true}, {"attribute_expression": "private List<String> things;", "docstring": " Indexed variable with indexed getter and setter", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "List<String>", "name": "things", "syntax_pass": true}, {"attribute_expression": "private List<String> stuff;", "docstring": " Indexed variable without indexed getter or setter", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "List<String>", "name": "stuff", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public String getName() {\n            return name;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getName", "params": [], "body": "                                {\n            return name;\n        }", "signature": "public String getName()"}, {"syntax_pass": true, "original_string": "        public List<String> getStuff() {\n            return stuff;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<String>", "classes": []}, "name": "getStuff", "params": [], "body": "                                       {\n            return stuff;\n        }", "signature": "public List<String> getStuff()"}, {"syntax_pass": true, "original_string": "        public String getThing(final int idx) {\n            return things.get(idx);\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getThing", "params": [{"name": "idx", "type": "int"}], "body": "                                              {\n            return things.get(idx);\n        }", "signature": "public String getThing(final int idx)"}, {"syntax_pass": true, "original_string": "        public List<String> getThings() {\n            return things;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<String>", "classes": []}, "name": "getThings", "params": [], "body": "                                        {\n            return things;\n        }", "signature": "public List<String> getThings()"}, {"syntax_pass": true, "original_string": "        public void setName(final String name) {\n            this.name = name;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setName", "params": [{"name": "name", "type": "String"}], "body": "                                               {\n            this.name = name;\n        }", "signature": "public void setName(final String name)"}, {"syntax_pass": true, "original_string": "        public void setStuff(final List<String> stuff) {\n            this.stuff = stuff;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setStuff", "params": [{"name": "stuff", "type": "List<String>"}], "body": "                                                       {\n            this.stuff = stuff;\n        }", "signature": "public void setStuff(final List<String> stuff)"}, {"syntax_pass": true, "original_string": "        public void setThing(final int idx, final String thing) {\n            this.things.set(idx, thing);\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setThing", "params": [{"name": "idx", "type": "int"}, {"name": "thing", "type": "String"}], "body": "                                                                {\n            this.things.set(idx, thing);\n        }", "signature": "public void setThing(final int idx, final String thing)"}, {"syntax_pass": true, "original_string": "        public void setThings(final List<String> things) {\n            this.things = things;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setThings", "params": [{"name": "things", "type": "List<String>"}], "body": "                                                         {\n            this.things = things;\n        }", "signature": "public void setThings(final List<String> things)"}]}, {"original_string": "    public static class MapColumnToAnnotationFieldBean {\n        private String one;\n\n        private String two;\n\n        private String three;\n\n        private String four;\n\n        public String getFour() {\n            return four;\n        }\n\n        public String getOne() {\n            return one;\n        }\n\n        @Column(name = \"three_\")\n        public String getThree() {\n            return three;\n        }\n\n        public String getTwo() {\n            return two;\n        }\n\n        public void setFour(final String four) {\n            this.four = four;\n        }\n\n        public void setOne(final String one) {\n            this.one = one;\n        }\n\n        public void setThree(final String three) {\n            this.three = three;\n        }\n\n        public void setTwo(final String two) {\n            this.two = two;\n        }\n    }", "definition": "    public static class MapColumnToAnnotationFieldBean", "class_docstring": "", "name": "MapColumnToAnnotationFieldBean", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "private String one;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "one", "syntax_pass": true}, {"attribute_expression": "private String two;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "two", "syntax_pass": true}, {"attribute_expression": "private String three;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "three", "syntax_pass": true}, {"attribute_expression": "private String four;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "four", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public String getFour() {\n            return four;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getFour", "params": [], "body": "                                {\n            return four;\n        }", "signature": "public String getFour()"}, {"syntax_pass": true, "original_string": "        public String getOne() {\n            return one;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getOne", "params": [], "body": "                               {\n            return one;\n        }", "signature": "public String getOne()"}, {"syntax_pass": true, "original_string": "        @Column(name = \"three_\")\n        public String getThree() {\n            return three;\n        }", "docstring": "", "attributes": {"modifiers": "@Column(name = \"three_\")\n        public", "marker_annotations": [], "non_marker_annotations": ["@Column(name = \"three_\")", "public"], "comments": [], "return_type": "String", "classes": []}, "name": "getThree", "params": [], "body": "                                 {\n            return three;\n        }", "signature": "@Column(name = \"three_\")\n        public String getThree()"}, {"syntax_pass": true, "original_string": "        public String getTwo() {\n            return two;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getTwo", "params": [], "body": "                               {\n            return two;\n        }", "signature": "public String getTwo()"}, {"syntax_pass": true, "original_string": "        public void setFour(final String four) {\n            this.four = four;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setFour", "params": [{"name": "four", "type": "String"}], "body": "                                               {\n            this.four = four;\n        }", "signature": "public void setFour(final String four)"}, {"syntax_pass": true, "original_string": "        public void setOne(final String one) {\n            this.one = one;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setOne", "params": [{"name": "one", "type": "String"}], "body": "                                             {\n            this.one = one;\n        }", "signature": "public void setOne(final String one)"}, {"syntax_pass": true, "original_string": "        public void setThree(final String three) {\n            this.three = three;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setThree", "params": [{"name": "three", "type": "String"}], "body": "                                                 {\n            this.three = three;\n        }", "signature": "public void setThree(final String three)"}, {"syntax_pass": true, "original_string": "        public void setTwo(final String two) {\n            this.two = two;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setTwo", "params": [{"name": "two", "type": "String"}], "body": "                                             {\n            this.two = two;\n        }", "signature": "public void setTwo(final String two)"}]}, {"original_string": "    public static class MapColumnToPropertiesBean {\n        private String one;\n\n        private String two;\n\n        private String three;\n\n        private String four;\n\n        public String getFour() {\n            return four;\n        }\n\n        public String getOne() {\n            return one;\n        }\n\n        public String getThree() {\n            return three;\n        }\n\n        public String getTwo() {\n            return two;\n        }\n\n        public void setFour(final String four) {\n            this.four = four;\n        }\n\n        public void setOne(final String one) {\n            this.one = one;\n        }\n\n        public void setThree(final String three) {\n            this.three = three;\n        }\n\n        public void setTwo(final String two) {\n            this.two = two;\n        }\n    }", "definition": "    public static class MapColumnToPropertiesBean", "class_docstring": "", "name": "MapColumnToPropertiesBean", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "private String one;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "one", "syntax_pass": true}, {"attribute_expression": "private String two;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "two", "syntax_pass": true}, {"attribute_expression": "private String three;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "three", "syntax_pass": true}, {"attribute_expression": "private String four;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "four", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public String getFour() {\n            return four;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getFour", "params": [], "body": "                                {\n            return four;\n        }", "signature": "public String getFour()"}, {"syntax_pass": true, "original_string": "        public String getOne() {\n            return one;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getOne", "params": [], "body": "                               {\n            return one;\n        }", "signature": "public String getOne()"}, {"syntax_pass": true, "original_string": "        public String getThree() {\n            return three;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getThree", "params": [], "body": "                                 {\n            return three;\n        }", "signature": "public String getThree()"}, {"syntax_pass": true, "original_string": "        public String getTwo() {\n            return two;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getTwo", "params": [], "body": "                               {\n            return two;\n        }", "signature": "public String getTwo()"}, {"syntax_pass": true, "original_string": "        public void setFour(final String four) {\n            this.four = four;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setFour", "params": [{"name": "four", "type": "String"}], "body": "                                               {\n            this.four = four;\n        }", "signature": "public void setFour(final String four)"}, {"syntax_pass": true, "original_string": "        public void setOne(final String one) {\n            this.one = one;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setOne", "params": [{"name": "one", "type": "String"}], "body": "                                             {\n            this.one = one;\n        }", "signature": "public void setOne(final String one)"}, {"syntax_pass": true, "original_string": "        public void setThree(final String three) {\n            this.three = three;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setThree", "params": [{"name": "three", "type": "String"}], "body": "                                                 {\n            this.three = three;\n        }", "signature": "public void setThree(final String three)"}, {"syntax_pass": true, "original_string": "        public void setTwo(final String two) {\n            this.two = two;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setTwo", "params": [{"name": "two", "type": "String"}], "body": "                                             {\n            this.two = two;\n        }", "signature": "public void setTwo(final String two)"}]}, {"original_string": "    private static final class TestNoGetter {\n        private String testField;\n\n        /**\n         * Add setter to trigger JavaBeans to populate a PropertyDescriptor\n         *\n         * @param testField The new testField value\n         */\n        public void setTestField(final String testField) {\n            this.testField = testField;\n        }\n    }", "definition": "    private static final class TestNoGetter", "class_docstring": "", "name": "TestNoGetter", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "fields": [{"attribute_expression": "private String testField;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "testField", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public void setTestField(final String testField) {\n            this.testField = testField;\n        }", "docstring": "\nAdd setter to trigger JavaBeans to populate a PropertyDescriptor\n\n@param testField The new testField value\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setTestField", "params": [{"name": "testField", "type": "String"}], "body": "                                                         {\n            this.testField = testField;\n        }", "signature": "public void setTestField(final String testField)"}]}, {"original_string": "    private static final class TestWrongSetter {\n        private Integer testField;\n\n        public Integer getTestField() {\n            return testField;\n        }\n\n        /**\n         * dbutils checks for a setter with exactly 1 param. This tests resilience to a found setter that doesn't match expectations.\n         *\n         * @param idx\n         * @param testField\n         */\n        public void setTestField(final int idx, final Integer testField) {\n            this.testField = testField;\n        }\n    }", "definition": "    private static final class TestWrongSetter", "class_docstring": "", "name": "TestWrongSetter", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "fields": [{"attribute_expression": "private Integer testField;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Integer", "name": "testField", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public Integer getTestField() {\n            return testField;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Integer", "classes": []}, "name": "getTestField", "params": [], "body": "                                      {\n            return testField;\n        }", "signature": "public Integer getTestField()"}, {"syntax_pass": true, "original_string": "        public void setTestField(final int idx, final Integer testField) {\n            this.testField = testField;\n        }", "docstring": "\ndbutils checks for a setter with exactly 1 param. This tests resilience to a found setter that doesn't match expectations.\n\n@param idx\n@param testField\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setTestField", "params": [{"name": "idx", "type": "int"}, {"name": "testField", "type": "Integer"}], "body": "                                                                         {\n            this.testField = testField;\n        }", "signature": "public void setTestField(final int idx, final Integer testField)"}]}]}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public void testCheckAnnotationOnMissingReadMethod() throws Exception {\n        final String[] colNames = { \"testField\" };\n        final ResultSetMetaData metaData = MockResultSetMetaData.create(colNames);\n\n        final String testField = \"first\";\n        final Object[][] rows = { new Object[] { testField } };\n\n        final ResultSet rs = MockResultSet.create(metaData, rows);\n        assertTrue(rs.next());\n        TestNoGetter testCls = new TestNoGetter();\n        testCls = beanProc.populateBean(rs, testCls);\n        assertEquals(testCls.testField, \"first\");\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testCheckAnnotationOnMissingReadMethod", "params": [], "body": "                                                                          {\n        final String[] colNames = { \"testField\" };\n        final ResultSetMetaData metaData = MockResultSetMetaData.create(colNames);\n\n        final String testField = \"first\";\n        final Object[][] rows = { new Object[] { testField } };\n\n        final ResultSet rs = MockResultSet.create(metaData, rows);\n        assertTrue(rs.next());\n        TestNoGetter testCls = new TestNoGetter();\n        testCls = beanProc.populateBean(rs, testCls);\n        assertEquals(testCls.testField, \"first\");\n    }", "signature": "public void testCheckAnnotationOnMissingReadMethod()"}, {"syntax_pass": true, "original_string": "    public void testIndexedPropertyDescriptor() throws Exception {\n        final String[] colNames = { \"name\", \"things\", \"stuff\" };\n        final ResultSetMetaData metaData = MockResultSetMetaData.create(colNames);\n\n        final String name = \"first\";\n        final List<String> things = Arrays.asList(\"1\", \"2\", \"3\", \"4\");\n        final List<String> stuff = things;\n        final Object[][] rows = { new Object[] { name, things, stuff } };\n\n        final ResultSet rs = MockResultSet.create(metaData, rows);\n        assertTrue(rs.next());\n        IndexedPropertyTestClass testCls = new IndexedPropertyTestClass();\n        testCls = beanProc.populateBean(rs, testCls);\n        assertEquals(name, testCls.getName());\n        assertArrayEquals(things.toArray(), testCls.getThings().toArray());\n        assertArrayEquals(stuff.toArray(), testCls.getStuff().toArray());\n    }", "docstring": "\nBased on the report in DBUTILS-150. This test validates that indexed property descriptors are not used, and indexed getter/setter methods are not\ninspected.\n\n@throws Exception\n@see <a href=\"https://issues.apache.org/jira/browse/DBUTILS-150\">DBUTILS-150</a>\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testIndexedPropertyDescriptor", "params": [], "body": "                                                                 {\n        final String[] colNames = { \"name\", \"things\", \"stuff\" };\n        final ResultSetMetaData metaData = MockResultSetMetaData.create(colNames);\n\n        final String name = \"first\";\n        final List<String> things = Arrays.asList(\"1\", \"2\", \"3\", \"4\");\n        final List<String> stuff = things;\n        final Object[][] rows = { new Object[] { name, things, stuff } };\n\n        final ResultSet rs = MockResultSet.create(metaData, rows);\n        assertTrue(rs.next());\n        IndexedPropertyTestClass testCls = new IndexedPropertyTestClass();\n        testCls = beanProc.populateBean(rs, testCls);\n        assertEquals(name, testCls.getName());\n        assertArrayEquals(things.toArray(), testCls.getThings().toArray());\n        assertArrayEquals(stuff.toArray(), testCls.getStuff().toArray());\n    }", "signature": "public void testIndexedPropertyDescriptor()"}, {"syntax_pass": true, "original_string": "    public void testMapColumnToAnnotationField() throws Exception {\n        final String[] columnNames = { \"test\", \"test\", \"three_\" };\n        final String[] columnLabels = { \"one\", \"two\", null };\n        final ResultSetMetaData rsmd = ProxyFactory.instance().createResultSetMetaData(new MockResultSetMetaData(columnNames, columnLabels));\n        final PropertyDescriptor[] props = Introspector.getBeanInfo(MapColumnToAnnotationFieldBean.class).getPropertyDescriptors();\n\n        final int[] columns = beanProc.mapColumnsToProperties(rsmd, props);\n        for (int i = 1; i < columns.length; i++) {\n            assertTrue(columns[i] != BeanProcessor.PROPERTY_NOT_FOUND);\n        }\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testMapColumnToAnnotationField", "params": [], "body": "                                                                  {\n        final String[] columnNames = { \"test\", \"test\", \"three_\" };\n        final String[] columnLabels = { \"one\", \"two\", null };\n        final ResultSetMetaData rsmd = ProxyFactory.instance().createResultSetMetaData(new MockResultSetMetaData(columnNames, columnLabels));\n        final PropertyDescriptor[] props = Introspector.getBeanInfo(MapColumnToAnnotationFieldBean.class).getPropertyDescriptors();\n\n        final int[] columns = beanProc.mapColumnsToProperties(rsmd, props);\n        for (int i = 1; i < columns.length; i++) {\n            assertTrue(columns[i] != BeanProcessor.PROPERTY_NOT_FOUND);\n        }\n    }", "signature": "public void testMapColumnToAnnotationField()"}, {"syntax_pass": true, "original_string": "    public void testMapColumnToProperties() throws Exception {\n        final String[] columnNames = { \"test\", \"test\", \"three\" };\n        final String[] columnLabels = { \"one\", \"two\", null };\n        final ResultSetMetaData rsmd = ProxyFactory.instance().createResultSetMetaData(new MockResultSetMetaData(columnNames, columnLabels));\n        final PropertyDescriptor[] props = Introspector.getBeanInfo(MapColumnToPropertiesBean.class).getPropertyDescriptors();\n\n        final int[] columns = beanProc.mapColumnsToProperties(rsmd, props);\n        for (int i = 1; i < columns.length; i++) {\n            assertTrue(columns[i] != BeanProcessor.PROPERTY_NOT_FOUND);\n        }\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testMapColumnToProperties", "params": [], "body": "                                                             {\n        final String[] columnNames = { \"test\", \"test\", \"three\" };\n        final String[] columnLabels = { \"one\", \"two\", null };\n        final ResultSetMetaData rsmd = ProxyFactory.instance().createResultSetMetaData(new MockResultSetMetaData(columnNames, columnLabels));\n        final PropertyDescriptor[] props = Introspector.getBeanInfo(MapColumnToPropertiesBean.class).getPropertyDescriptors();\n\n        final int[] columns = beanProc.mapColumnsToProperties(rsmd, props);\n        for (int i = 1; i < columns.length; i++) {\n            assertTrue(columns[i] != BeanProcessor.PROPERTY_NOT_FOUND);\n        }\n    }", "signature": "public void testMapColumnToProperties()"}, {"syntax_pass": true, "original_string": "    public void testMapColumnToPropertiesWithOverrides() throws Exception {\n        final Map<String, String> columnToPropertyOverrides = new HashMap<>();\n        columnToPropertyOverrides.put(\"five\", \"four\");\n        final BeanProcessor beanProc = new BeanProcessor(columnToPropertyOverrides);\n        final String[] columnNames = { \"test\", \"test\", \"three\", \"five\" };\n        final String[] columnLabels = { \"one\", \"two\", null, null };\n        final ResultSetMetaData rsmd = ProxyFactory.instance().createResultSetMetaData(new MockResultSetMetaData(columnNames, columnLabels));\n        final PropertyDescriptor[] props = Introspector.getBeanInfo(MapColumnToPropertiesBean.class).getPropertyDescriptors();\n\n        final int[] columns = beanProc.mapColumnsToProperties(rsmd, props);\n        for (int i = 1; i < columns.length; i++) {\n            assertTrue(columns[i] != BeanProcessor.PROPERTY_NOT_FOUND);\n        }\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testMapColumnToPropertiesWithOverrides", "params": [], "body": "                                                                          {\n        final Map<String, String> columnToPropertyOverrides = new HashMap<>();\n        columnToPropertyOverrides.put(\"five\", \"four\");\n        final BeanProcessor beanProc = new BeanProcessor(columnToPropertyOverrides);\n        final String[] columnNames = { \"test\", \"test\", \"three\", \"five\" };\n        final String[] columnLabels = { \"one\", \"two\", null, null };\n        final ResultSetMetaData rsmd = ProxyFactory.instance().createResultSetMetaData(new MockResultSetMetaData(columnNames, columnLabels));\n        final PropertyDescriptor[] props = Introspector.getBeanInfo(MapColumnToPropertiesBean.class).getPropertyDescriptors();\n\n        final int[] columns = beanProc.mapColumnsToProperties(rsmd, props);\n        for (int i = 1; i < columns.length; i++) {\n            assertTrue(columns[i] != BeanProcessor.PROPERTY_NOT_FOUND);\n        }\n    }", "signature": "public void testMapColumnToPropertiesWithOverrides()"}, {"syntax_pass": true, "original_string": "    public void testProcessWithPopulateBean() throws SQLException {\n        TestBean b = new TestBean();\n        final ResultSet rs = getResultSet();\n        assertTrue(rs.next());\n        b = beanProc.populateBean(rs, b);\n        assertEquals(13.0, b.getColumnProcessorDoubleTest(), 0);\n        assertEquals(b.getThree(), TestBean.Ordinal.THREE);\n\n        assertTrue(rs.next());\n        b = beanProc.populateBean(rs, b);\n        assertEquals(13.0, b.getColumnProcessorDoubleTest(), 0);\n        assertEquals(b.getThree(), TestBean.Ordinal.SIX);\n\n        assertFalse(rs.next());\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testProcessWithPopulateBean", "params": [], "body": "                                                                  {\n        TestBean b = new TestBean();\n        final ResultSet rs = getResultSet();\n        assertTrue(rs.next());\n        b = beanProc.populateBean(rs, b);\n        assertEquals(13.0, b.getColumnProcessorDoubleTest(), 0);\n        assertEquals(b.getThree(), TestBean.Ordinal.THREE);\n\n        assertTrue(rs.next());\n        b = beanProc.populateBean(rs, b);\n        assertEquals(13.0, b.getColumnProcessorDoubleTest(), 0);\n        assertEquals(b.getThree(), TestBean.Ordinal.SIX);\n\n        assertFalse(rs.next());\n    }", "signature": "public void testProcessWithPopulateBean()"}, {"syntax_pass": true, "original_string": "    public void testProcessWithToBean() throws SQLException {\n        final ResultSet rs = getResultSet();\n        assertTrue(rs.next());\n        TestBean b = beanProc.toBean(rs, TestBean.class);\n        assertEquals(13.0, b.getColumnProcessorDoubleTest(), 0);\n        assertEquals(b.getThree(), TestBean.Ordinal.THREE);\n\n        assertTrue(rs.next());\n        b = beanProc.toBean(rs, TestBean.class);\n        assertEquals(13.0, b.getColumnProcessorDoubleTest(), 0);\n        assertEquals(b.getThree(), TestBean.Ordinal.SIX);\n\n        assertFalse(rs.next());\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testProcessWithToBean", "params": [], "body": "                                                            {\n        final ResultSet rs = getResultSet();\n        assertTrue(rs.next());\n        TestBean b = beanProc.toBean(rs, TestBean.class);\n        assertEquals(13.0, b.getColumnProcessorDoubleTest(), 0);\n        assertEquals(b.getThree(), TestBean.Ordinal.THREE);\n\n        assertTrue(rs.next());\n        b = beanProc.toBean(rs, TestBean.class);\n        assertEquals(13.0, b.getColumnProcessorDoubleTest(), 0);\n        assertEquals(b.getThree(), TestBean.Ordinal.SIX);\n\n        assertFalse(rs.next());\n    }", "signature": "public void testProcessWithToBean()"}, {"syntax_pass": true, "original_string": "    public void testWrongSetterParamCount() throws Exception {\n        final String[] colNames = { \"testField\" };\n        final ResultSetMetaData metaData = MockResultSetMetaData.create(colNames);\n\n        final Integer testField = 1;\n        final Object[][] rows = { new Object[] { testField } };\n\n        final ResultSet rs = MockResultSet.create(metaData, rows);\n        assertTrue(rs.next());\n        TestWrongSetter testCls = new TestWrongSetter();\n        testCls = beanProc.populateBean(rs, testCls);\n        assertNull(testCls.testField);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testWrongSetterParamCount", "params": [], "body": "                                                             {\n        final String[] colNames = { \"testField\" };\n        final ResultSetMetaData metaData = MockResultSetMetaData.create(colNames);\n\n        final Integer testField = 1;\n        final Object[][] rows = { new Object[] { testField } };\n\n        final ResultSet rs = MockResultSet.create(metaData, rows);\n        assertTrue(rs.next());\n        TestWrongSetter testCls = new TestWrongSetter();\n        testCls = beanProc.populateBean(rs, testCls);\n        assertNull(testCls.testField);\n    }", "signature": "public void testWrongSetterParamCount()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/dbutils/BaseResultSetHandlerTest.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils;\n\nimport java.sql.SQLException;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Map;\n\nimport org.junit.Test;\n\npublic final class BaseResultSetHandlerTest extends BaseTestCase {\n\n    private static final class ToMapCollectionHandler extends BaseResultSetHandler<Collection<Map<String, Object>>> {\n\n        @Override\n        protected Collection<Map<String, Object>> handle() throws SQLException {\n            final Collection<Map<String, Object>> result = new LinkedList<>();\n\n            while (next()) {\n                final Map<String, Object> current = new HashMap<>();\n\n                for (int i = 1; i <= getMetaData().getColumnCount(); i++) {\n                    current.put(getMetaData().getColumnName(i), getObject(i));\n                }\n\n                result.add(current);\n            }\n\n            return result;\n        }\n\n    }\n\n    @Test\n    public void testHandleWithoutExplicitResultSetInvocation() throws Exception {\n        final Collection<Map<String, Object>> result = new ToMapCollectionHandler().handle(createMockResultSet());\n\n        assertFalse(result.isEmpty());\n\n        for (final Map<String, Object> current : result) {\n            assertTrue(current.containsKey(\"one\"));\n            assertTrue(current.containsKey(\"two\"));\n            assertTrue(current.containsKey(\"three\"));\n            assertTrue(current.containsKey(\"notInBean\"));\n            assertTrue(current.containsKey(\"intTest\"));\n            assertTrue(current.containsKey(\"integerTest\"));\n            assertTrue(current.containsKey(\"nullObjectTest\"));\n            assertTrue(current.containsKey(\"nullPrimitiveTest\"));\n            assertTrue(current.containsKey(\"notDate\"));\n            assertTrue(current.containsKey(\"columnProcessorDoubleTest\"));\n        }\n    }\n\n}\n", "file_hash": "bf53c0b2ae1b24cfc6c5519cde8fe9f3b4b500b484d7eb56eae3ed96c08be352", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils;", "import java.sql.SQLException;", "import java.util.Collection;", "import java.util.HashMap;", "import java.util.LinkedList;", "import java.util.Map;", "import org.junit.Test;"], "methods": [], "classes": [{"original_string": "public final class BaseResultSetHandlerTest extends BaseTestCase {\n\n    private static final class ToMapCollectionHandler extends BaseResultSetHandler<Collection<Map<String, Object>>> {\n\n        @Override\n        protected Collection<Map<String, Object>> handle() throws SQLException {\n            final Collection<Map<String, Object>> result = new LinkedList<>();\n\n            while (next()) {\n                final Map<String, Object> current = new HashMap<>();\n\n                for (int i = 1; i <= getMetaData().getColumnCount(); i++) {\n                    current.put(getMetaData().getColumnName(i), getObject(i));\n                }\n\n                result.add(current);\n            }\n\n            return result;\n        }\n\n    }\n\n    @Test\n    public void testHandleWithoutExplicitResultSetInvocation() throws Exception {\n        final Collection<Map<String, Object>> result = new ToMapCollectionHandler().handle(createMockResultSet());\n\n        assertFalse(result.isEmpty());\n\n        for (final Map<String, Object> current : result) {\n            assertTrue(current.containsKey(\"one\"));\n            assertTrue(current.containsKey(\"two\"));\n            assertTrue(current.containsKey(\"three\"));\n            assertTrue(current.containsKey(\"notInBean\"));\n            assertTrue(current.containsKey(\"intTest\"));\n            assertTrue(current.containsKey(\"integerTest\"));\n            assertTrue(current.containsKey(\"nullObjectTest\"));\n            assertTrue(current.containsKey(\"nullPrimitiveTest\"));\n            assertTrue(current.containsKey(\"notDate\"));\n            assertTrue(current.containsKey(\"columnProcessorDoubleTest\"));\n        }\n    }\n\n}", "definition": "public final class BaseResultSetHandlerTest extends BaseTestCase", "class_docstring": "", "name": "BaseResultSetHandlerTest", "super_interfaces": [], "superclasses": "BaseTestCase", "attributes": {"modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "fields": [], "classes": [{"original_string": "    private static final class ToMapCollectionHandler extends BaseResultSetHandler<Collection<Map<String, Object>>> {\n\n        @Override\n        protected Collection<Map<String, Object>> handle() throws SQLException {\n            final Collection<Map<String, Object>> result = new LinkedList<>();\n\n            while (next()) {\n                final Map<String, Object> current = new HashMap<>();\n\n                for (int i = 1; i <= getMetaData().getColumnCount(); i++) {\n                    current.put(getMetaData().getColumnName(i), getObject(i));\n                }\n\n                result.add(current);\n            }\n\n            return result;\n        }\n\n    }", "definition": "    private static final class ToMapCollectionHandler extends BaseResultSetHandler<Collection<Map<String, Object>>>", "class_docstring": "", "name": "ToMapCollectionHandler", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @Override\n        protected Collection<Map<String, Object>> handle() throws SQLException {\n            final Collection<Map<String, Object>> result = new LinkedList<>();\n\n            while (next()) {\n                final Map<String, Object> current = new HashMap<>();\n\n                for (int i = 1; i <= getMetaData().getColumnCount(); i++) {\n                    current.put(getMetaData().getColumnName(i), getObject(i));\n                }\n\n                result.add(current);\n            }\n\n            return result;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Collection<Map<String, Object>>", "classes": []}, "name": "handle", "params": [], "body": "                                                                               {\n            final Collection<Map<String, Object>> result = new LinkedList<>();\n\n            while (next()) {\n                final Map<String, Object> current = new HashMap<>();\n\n                for (int i = 1; i <= getMetaData().getColumnCount(); i++) {\n                    current.put(getMetaData().getColumnName(i), getObject(i));\n                }\n\n                result.add(current);\n            }\n\n            return result;\n        }", "signature": "@Override\n        protected Collection<Map<String, Object>> handle()"}]}]}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void testHandleWithoutExplicitResultSetInvocation() throws Exception {\n        final Collection<Map<String, Object>> result = new ToMapCollectionHandler().handle(createMockResultSet());\n\n        assertFalse(result.isEmpty());\n\n        for (final Map<String, Object> current : result) {\n            assertTrue(current.containsKey(\"one\"));\n            assertTrue(current.containsKey(\"two\"));\n            assertTrue(current.containsKey(\"three\"));\n            assertTrue(current.containsKey(\"notInBean\"));\n            assertTrue(current.containsKey(\"intTest\"));\n            assertTrue(current.containsKey(\"integerTest\"));\n            assertTrue(current.containsKey(\"nullObjectTest\"));\n            assertTrue(current.containsKey(\"nullPrimitiveTest\"));\n            assertTrue(current.containsKey(\"notDate\"));\n            assertTrue(current.containsKey(\"columnProcessorDoubleTest\"));\n        }\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testHandleWithoutExplicitResultSetInvocation", "params": [], "body": "                                                                                {\n        final Collection<Map<String, Object>> result = new ToMapCollectionHandler().handle(createMockResultSet());\n\n        assertFalse(result.isEmpty());\n\n        for (final Map<String, Object> current : result) {\n            assertTrue(current.containsKey(\"one\"));\n            assertTrue(current.containsKey(\"two\"));\n            assertTrue(current.containsKey(\"three\"));\n            assertTrue(current.containsKey(\"notInBean\"));\n            assertTrue(current.containsKey(\"intTest\"));\n            assertTrue(current.containsKey(\"integerTest\"));\n            assertTrue(current.containsKey(\"nullObjectTest\"));\n            assertTrue(current.containsKey(\"nullPrimitiveTest\"));\n            assertTrue(current.containsKey(\"notDate\"));\n            assertTrue(current.containsKey(\"columnProcessorDoubleTest\"));\n        }\n    }", "signature": "@Test\n    public void testHandleWithoutExplicitResultSetInvocation()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/dbutils/MockResultSet.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils;\n\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Set;\n\n/**\n * MockResultSet dynamically implements the ResultSet interface.\n */\npublic class MockResultSet implements InvocationHandler {\n\n    private static final Set<String> METHOD_NAMES = Set.of(\"isLast\", \"hashCode\", \"toString\", \"equals\");\n\n    /**\n     * Create a {@code MockResultSet} proxy object. This is equivalent to:\n     *\n     * <pre>\n     * ProxyFactory.instance().createResultSet(new MockResultSet(metaData, rows));\n     * </pre>\n     *\n     * @param metaData\n     * @param rows     A null value indicates an empty {@code ResultSet}.\n     */\n    public static ResultSet create(final ResultSetMetaData metaData, final Object[][] rows) {\n        return ProxyFactory.instance().createResultSet(new MockResultSet(metaData, rows));\n    }\n\n    private Object[] currentRow;\n\n    private Iterator<Object[]> iter;\n\n    private final ResultSetMetaData metaData;\n\n    private Boolean wasNull = Boolean.FALSE;\n\n    /**\n     * MockResultSet constructor.\n     *\n     * @param metaData\n     * @param rows     A null value indicates an empty {@code ResultSet}.\n     */\n    public MockResultSet(final ResultSetMetaData metaData, final Object[][] rows) {\n        this.metaData = metaData;\n        if (rows == null) {\n            final List<Object[]> empty = Collections.emptyList();\n            this.iter = empty.iterator();\n        } else {\n            this.iter = Arrays.asList(rows).iterator();\n        }\n    }\n\n    /**\n     * The get* methods can have an int column index or a String column name as the parameter. This method handles both cases and returns the column index that\n     * the client is trying to get at.\n     *\n     * @param args\n     * @return A column index.\n     * @throws SQLException if a database access error occurs\n     */\n    private int columnIndex(final Object[] args) throws SQLException {\n\n        if (args[0] instanceof Integer) {\n            return ((Integer) args[0]).intValue();\n\n        }\n        if (args[0] instanceof String) {\n            return columnNameToIndex((String) args[0]);\n\n        }\n        throw new SQLException(args[0] + \" must be Integer or String\");\n    }\n\n    /**\n     * Returns the column index for the given column name.\n     *\n     * @return A 1 based index\n     * @throws SQLException if the column name is invalid\n     */\n    private int columnNameToIndex(final String columnName) throws SQLException {\n        for (int i = 0; i < this.currentRow.length; i++) {\n            final int c = i + 1;\n            if (this.metaData.getColumnName(c).equalsIgnoreCase(columnName)) {\n                return c;\n            }\n        }\n\n        throw new SQLException(columnName + \" is not a valid column name.\");\n    }\n\n    /**\n     * Gets the boolean value at the given column index.\n     *\n     * @param columnIndex A 1 based index.\n     * @throws SQLException if a database access error occurs\n     */\n    protected Object getBoolean(final int columnIndex) throws SQLException {\n        final Object obj = this.currentRow[columnIndex - 1];\n        setWasNull(obj);\n\n        try {\n            return obj == null ? Boolean.FALSE : Boolean.valueOf(obj.toString());\n\n        } catch (final NumberFormatException e) {\n            throw new SQLException(e.getMessage());\n        }\n    }\n\n    /**\n     * Gets the byte value at the given column index.\n     *\n     * @param columnIndex A 1 based index.\n     * @throws SQLException if a database access error occurs\n     */\n    protected Object getByte(final int columnIndex) throws SQLException {\n        final Object obj = this.currentRow[columnIndex - 1];\n        setWasNull(obj);\n\n        try {\n            return obj == null ? Byte.valueOf((byte) 0) : Byte.valueOf(obj.toString());\n\n        } catch (final NumberFormatException e) {\n            throw new SQLException(e.getMessage());\n        }\n    }\n\n    /**\n     * Gets the double value at the given column index.\n     *\n     * @param columnIndex A 1 based index.\n     * @throws SQLException if a database access error occurs\n     */\n    protected Object getDouble(final int columnIndex) throws SQLException {\n        final Object obj = this.currentRow[columnIndex - 1];\n        setWasNull(obj);\n\n        try {\n            return obj == null ? Double.valueOf(0) : Double.valueOf(obj.toString());\n\n        } catch (final NumberFormatException e) {\n            throw new SQLException(e.getMessage());\n        }\n    }\n\n    /**\n     * Gets the float value at the given column index.\n     *\n     * @param columnIndex A 1 based index.\n     * @throws SQLException if a database access error occurs\n     */\n    protected Object getFloat(final int columnIndex) throws SQLException {\n        final Object obj = this.currentRow[columnIndex - 1];\n        setWasNull(obj);\n\n        try {\n            return obj == null ? Float.valueOf(0) : Float.valueOf(obj.toString());\n\n        } catch (final NumberFormatException e) {\n            throw new SQLException(e.getMessage());\n        }\n    }\n\n    /**\n     * Gets the int value at the given column index.\n     *\n     * @param columnIndex A 1 based index.\n     * @throws SQLException if a database access error occurs\n     */\n    protected Object getInt(final int columnIndex) throws SQLException {\n        final Object obj = this.currentRow[columnIndex - 1];\n        setWasNull(obj);\n\n        try {\n            return obj == null ? Integer.valueOf(0) : Integer.valueOf(obj.toString());\n\n        } catch (final NumberFormatException e) {\n            throw new SQLException(e.getMessage());\n        }\n    }\n\n    /**\n     * Gets the long value at the given column index.\n     *\n     * @param columnIndex A 1 based index.\n     * @throws SQLException if a database access error occurs\n     */\n    protected Object getLong(final int columnIndex) throws SQLException {\n        final Object obj = this.currentRow[columnIndex - 1];\n        setWasNull(obj);\n\n        try {\n            return obj == null ? Long.valueOf(0) : Long.valueOf(obj.toString());\n\n        } catch (final NumberFormatException e) {\n            throw new SQLException(e.getMessage());\n        }\n    }\n\n    /**\n     * @throws SQLException\n     */\n    protected ResultSetMetaData getMetaData() throws SQLException {\n        return this.metaData;\n    }\n\n    /**\n     * Gets the object at the given column index.\n     *\n     * @param columnIndex A 1 based index.\n     * @throws SQLException if a database access error occurs\n     */\n    protected Object getObject(final int columnIndex) throws SQLException {\n        final Object obj = this.currentRow[columnIndex - 1];\n        setWasNull(obj);\n        return obj;\n    }\n\n    /**\n     * Gets the short value at the given column index.\n     *\n     * @param columnIndex A 1 based index.\n     * @throws SQLException if a database access error occurs\n     */\n    protected Object getShort(final int columnIndex) throws SQLException {\n        final Object obj = this.currentRow[columnIndex - 1];\n        setWasNull(obj);\n\n        try {\n            return obj == null ? Short.valueOf((short) 0) : Short.valueOf(obj.toString());\n\n        } catch (final NumberFormatException e) {\n            throw new SQLException(e.getMessage());\n        }\n    }\n\n    /**\n     * Gets the String at the given column index.\n     *\n     * @param columnIndex A 1 based index.\n     * @throws SQLException if a database access error occurs\n     */\n    protected String getString(final int columnIndex) throws SQLException {\n        final Object obj = getObject(columnIndex);\n        setWasNull(obj);\n        return Objects.toString(obj, null);\n    }\n\n    private Object handleColumnMethod(final String methodName, final Object[] args) throws SQLException {\n        switch (methodName) {\n            case \"getBoolean\":\n                return getBoolean(columnIndex(args));\n            case \"getByte\":\n                return getByte(columnIndex(args));\n            case \"getDouble\":\n                return getDouble(columnIndex(args));\n            case \"getFloat\":\n                return getFloat(columnIndex(args));\n            case \"getInt\":\n                return getInt(columnIndex(args));\n            case \"getLong\":\n                return getLong(columnIndex(args));\n            case \"getObject\":\n                return getObject(columnIndex(args));\n            case \"getShort\":\n                return getShort(columnIndex(args));\n            case \"getString\":\n                return getString(columnIndex(args));\n            case \"wasNull\":\n                return wasNull();\n            default:\n                throw new UnsupportedOperationException(\"Unsupported column method: \" + methodName);\n        }\n    }\n\n    private Object handleNonColumnMethod(final String methodName, final Object proxy, final Object[] args) throws SQLException {\n        switch (methodName) {\n            case \"isLast\":\n                return isLast();\n            case \"hashCode\":\n                return Integer.valueOf(System.identityHashCode(proxy));\n            case \"toString\":\n                return \"MockResultSet \" + System.identityHashCode(proxy);\n            case \"equals\":\n                return Boolean.valueOf(proxy == args[0]);\n            default:\n                throw new UnsupportedOperationException(\"Unsupported non-column method: \" + methodName);\n        }\n    }\n\n    @Override\n    public Object invoke(final Object proxy, final Method method, final Object[] args)\n        throws Throwable {\n\n        final String methodName = method.getName();\n        switch (methodName) {\n        case \"getMetaData\":\n            return getMetaData();\n        case \"next\":\n            return next();\n        case \"previous\":\n            break;\n        case \"close\":\n            break;\n        default:\n            if (isColumnMethod(methodName)) {\n                return handleColumnMethod(methodName, args);\n            } else if (METHOD_NAMES.contains(methodName)) {\n                return handleNonColumnMethod(methodName, proxy, args);\n            }\n            break;\n        }\n        throw new UnsupportedOperationException(\"Unsupported method: \" + methodName);\n    }\n\n    private boolean isColumnMethod(final String methodName) {\n        return methodName.startsWith(\"get\") || methodName.equals(\"wasNull\");\n    }\n\n    /**\n     * @throws SQLException\n     */\n    protected Boolean isLast() throws SQLException {\n        return this.iter.hasNext() ? Boolean.FALSE : Boolean.TRUE;\n    }\n\n    /**\n     * @throws SQLException\n     */\n    protected Boolean next() throws SQLException {\n        if (!this.iter.hasNext()) {\n            return Boolean.FALSE;\n        }\n        this.currentRow = iter.next();\n        return Boolean.TRUE;\n    }\n\n    /**\n     * Assigns this.wasNull a Boolean value based on the object passed in.\n     *\n     * @param isNull\n     */\n    private void setWasNull(final Object isNull) {\n        this.wasNull = isNull == null ? Boolean.TRUE : Boolean.FALSE;\n    }\n\n    /**\n     * @throws SQLException\n     */\n    protected Boolean wasNull() throws SQLException {\n        return this.wasNull;\n    }\n}\n", "file_hash": "495bf70826c6f23834d73915ab8714dc69ede545d743325618ec042ed78c1ee8", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils;", "import java.lang.reflect.InvocationHandler;", "import java.lang.reflect.Method;", "import java.sql.ResultSet;", "import java.sql.ResultSetMetaData;", "import java.sql.SQLException;", "import java.util.Arrays;", "import java.util.Collections;", "import java.util.Iterator;", "import java.util.List;", "import java.util.Objects;", "import java.util.Set;"], "methods": [], "classes": [{"original_string": "public class MockResultSet implements InvocationHandler {\n\n    private static final Set<String> METHOD_NAMES = Set.of(\"isLast\", \"hashCode\", \"toString\", \"equals\");\n\n    /**\n     * Create a {@code MockResultSet} proxy object. This is equivalent to:\n     *\n     * <pre>\n     * ProxyFactory.instance().createResultSet(new MockResultSet(metaData, rows));\n     * </pre>\n     *\n     * @param metaData\n     * @param rows     A null value indicates an empty {@code ResultSet}.\n     */\n    public static ResultSet create(final ResultSetMetaData metaData, final Object[][] rows) {\n        return ProxyFactory.instance().createResultSet(new MockResultSet(metaData, rows));\n    }\n\n    private Object[] currentRow;\n\n    private Iterator<Object[]> iter;\n\n    private final ResultSetMetaData metaData;\n\n    private Boolean wasNull = Boolean.FALSE;\n\n    /**\n     * MockResultSet constructor.\n     *\n     * @param metaData\n     * @param rows     A null value indicates an empty {@code ResultSet}.\n     */\n    public MockResultSet(final ResultSetMetaData metaData, final Object[][] rows) {\n        this.metaData = metaData;\n        if (rows == null) {\n            final List<Object[]> empty = Collections.emptyList();\n            this.iter = empty.iterator();\n        } else {\n            this.iter = Arrays.asList(rows).iterator();\n        }\n    }\n\n    /**\n     * The get* methods can have an int column index or a String column name as the parameter. This method handles both cases and returns the column index that\n     * the client is trying to get at.\n     *\n     * @param args\n     * @return A column index.\n     * @throws SQLException if a database access error occurs\n     */\n    private int columnIndex(final Object[] args) throws SQLException {\n\n        if (args[0] instanceof Integer) {\n            return ((Integer) args[0]).intValue();\n\n        }\n        if (args[0] instanceof String) {\n            return columnNameToIndex((String) args[0]);\n\n        }\n        throw new SQLException(args[0] + \" must be Integer or String\");\n    }\n\n    /**\n     * Returns the column index for the given column name.\n     *\n     * @return A 1 based index\n     * @throws SQLException if the column name is invalid\n     */\n    private int columnNameToIndex(final String columnName) throws SQLException {\n        for (int i = 0; i < this.currentRow.length; i++) {\n            final int c = i + 1;\n            if (this.metaData.getColumnName(c).equalsIgnoreCase(columnName)) {\n                return c;\n            }\n        }\n\n        throw new SQLException(columnName + \" is not a valid column name.\");\n    }\n\n    /**\n     * Gets the boolean value at the given column index.\n     *\n     * @param columnIndex A 1 based index.\n     * @throws SQLException if a database access error occurs\n     */\n    protected Object getBoolean(final int columnIndex) throws SQLException {\n        final Object obj = this.currentRow[columnIndex - 1];\n        setWasNull(obj);\n\n        try {\n            return obj == null ? Boolean.FALSE : Boolean.valueOf(obj.toString());\n\n        } catch (final NumberFormatException e) {\n            throw new SQLException(e.getMessage());\n        }\n    }\n\n    /**\n     * Gets the byte value at the given column index.\n     *\n     * @param columnIndex A 1 based index.\n     * @throws SQLException if a database access error occurs\n     */\n    protected Object getByte(final int columnIndex) throws SQLException {\n        final Object obj = this.currentRow[columnIndex - 1];\n        setWasNull(obj);\n\n        try {\n            return obj == null ? Byte.valueOf((byte) 0) : Byte.valueOf(obj.toString());\n\n        } catch (final NumberFormatException e) {\n            throw new SQLException(e.getMessage());\n        }\n    }\n\n    /**\n     * Gets the double value at the given column index.\n     *\n     * @param columnIndex A 1 based index.\n     * @throws SQLException if a database access error occurs\n     */\n    protected Object getDouble(final int columnIndex) throws SQLException {\n        final Object obj = this.currentRow[columnIndex - 1];\n        setWasNull(obj);\n\n        try {\n            return obj == null ? Double.valueOf(0) : Double.valueOf(obj.toString());\n\n        } catch (final NumberFormatException e) {\n            throw new SQLException(e.getMessage());\n        }\n    }\n\n    /**\n     * Gets the float value at the given column index.\n     *\n     * @param columnIndex A 1 based index.\n     * @throws SQLException if a database access error occurs\n     */\n    protected Object getFloat(final int columnIndex) throws SQLException {\n        final Object obj = this.currentRow[columnIndex - 1];\n        setWasNull(obj);\n\n        try {\n            return obj == null ? Float.valueOf(0) : Float.valueOf(obj.toString());\n\n        } catch (final NumberFormatException e) {\n            throw new SQLException(e.getMessage());\n        }\n    }\n\n    /**\n     * Gets the int value at the given column index.\n     *\n     * @param columnIndex A 1 based index.\n     * @throws SQLException if a database access error occurs\n     */\n    protected Object getInt(final int columnIndex) throws SQLException {\n        final Object obj = this.currentRow[columnIndex - 1];\n        setWasNull(obj);\n\n        try {\n            return obj == null ? Integer.valueOf(0) : Integer.valueOf(obj.toString());\n\n        } catch (final NumberFormatException e) {\n            throw new SQLException(e.getMessage());\n        }\n    }\n\n    /**\n     * Gets the long value at the given column index.\n     *\n     * @param columnIndex A 1 based index.\n     * @throws SQLException if a database access error occurs\n     */\n    protected Object getLong(final int columnIndex) throws SQLException {\n        final Object obj = this.currentRow[columnIndex - 1];\n        setWasNull(obj);\n\n        try {\n            return obj == null ? Long.valueOf(0) : Long.valueOf(obj.toString());\n\n        } catch (final NumberFormatException e) {\n            throw new SQLException(e.getMessage());\n        }\n    }\n\n    /**\n     * @throws SQLException\n     */\n    protected ResultSetMetaData getMetaData() throws SQLException {\n        return this.metaData;\n    }\n\n    /**\n     * Gets the object at the given column index.\n     *\n     * @param columnIndex A 1 based index.\n     * @throws SQLException if a database access error occurs\n     */\n    protected Object getObject(final int columnIndex) throws SQLException {\n        final Object obj = this.currentRow[columnIndex - 1];\n        setWasNull(obj);\n        return obj;\n    }\n\n    /**\n     * Gets the short value at the given column index.\n     *\n     * @param columnIndex A 1 based index.\n     * @throws SQLException if a database access error occurs\n     */\n    protected Object getShort(final int columnIndex) throws SQLException {\n        final Object obj = this.currentRow[columnIndex - 1];\n        setWasNull(obj);\n\n        try {\n            return obj == null ? Short.valueOf((short) 0) : Short.valueOf(obj.toString());\n\n        } catch (final NumberFormatException e) {\n            throw new SQLException(e.getMessage());\n        }\n    }\n\n    /**\n     * Gets the String at the given column index.\n     *\n     * @param columnIndex A 1 based index.\n     * @throws SQLException if a database access error occurs\n     */\n    protected String getString(final int columnIndex) throws SQLException {\n        final Object obj = getObject(columnIndex);\n        setWasNull(obj);\n        return Objects.toString(obj, null);\n    }\n\n    private Object handleColumnMethod(final String methodName, final Object[] args) throws SQLException {\n        switch (methodName) {\n            case \"getBoolean\":\n                return getBoolean(columnIndex(args));\n            case \"getByte\":\n                return getByte(columnIndex(args));\n            case \"getDouble\":\n                return getDouble(columnIndex(args));\n            case \"getFloat\":\n                return getFloat(columnIndex(args));\n            case \"getInt\":\n                return getInt(columnIndex(args));\n            case \"getLong\":\n                return getLong(columnIndex(args));\n            case \"getObject\":\n                return getObject(columnIndex(args));\n            case \"getShort\":\n                return getShort(columnIndex(args));\n            case \"getString\":\n                return getString(columnIndex(args));\n            case \"wasNull\":\n                return wasNull();\n            default:\n                throw new UnsupportedOperationException(\"Unsupported column method: \" + methodName);\n        }\n    }\n\n    private Object handleNonColumnMethod(final String methodName, final Object proxy, final Object[] args) throws SQLException {\n        switch (methodName) {\n            case \"isLast\":\n                return isLast();\n            case \"hashCode\":\n                return Integer.valueOf(System.identityHashCode(proxy));\n            case \"toString\":\n                return \"MockResultSet \" + System.identityHashCode(proxy);\n            case \"equals\":\n                return Boolean.valueOf(proxy == args[0]);\n            default:\n                throw new UnsupportedOperationException(\"Unsupported non-column method: \" + methodName);\n        }\n    }\n\n    @Override\n    public Object invoke(final Object proxy, final Method method, final Object[] args)\n        throws Throwable {\n\n        final String methodName = method.getName();\n        switch (methodName) {\n        case \"getMetaData\":\n            return getMetaData();\n        case \"next\":\n            return next();\n        case \"previous\":\n            break;\n        case \"close\":\n            break;\n        default:\n            if (isColumnMethod(methodName)) {\n                return handleColumnMethod(methodName, args);\n            } else if (METHOD_NAMES.contains(methodName)) {\n                return handleNonColumnMethod(methodName, proxy, args);\n            }\n            break;\n        }\n        throw new UnsupportedOperationException(\"Unsupported method: \" + methodName);\n    }\n\n    private boolean isColumnMethod(final String methodName) {\n        return methodName.startsWith(\"get\") || methodName.equals(\"wasNull\");\n    }\n\n    /**\n     * @throws SQLException\n     */\n    protected Boolean isLast() throws SQLException {\n        return this.iter.hasNext() ? Boolean.FALSE : Boolean.TRUE;\n    }\n\n    /**\n     * @throws SQLException\n     */\n    protected Boolean next() throws SQLException {\n        if (!this.iter.hasNext()) {\n            return Boolean.FALSE;\n        }\n        this.currentRow = iter.next();\n        return Boolean.TRUE;\n    }\n\n    /**\n     * Assigns this.wasNull a Boolean value based on the object passed in.\n     *\n     * @param isNull\n     */\n    private void setWasNull(final Object isNull) {\n        this.wasNull = isNull == null ? Boolean.TRUE : Boolean.FALSE;\n    }\n\n    /**\n     * @throws SQLException\n     */\n    protected Boolean wasNull() throws SQLException {\n        return this.wasNull;\n    }\n}", "definition": "public class MockResultSet implements InvocationHandler", "class_docstring": "\nMockResultSet dynamically implements the ResultSet interface.\n", "name": "MockResultSet", "super_interfaces": ["InvocationHandler"], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private static final Set<String> METHOD_NAMES = Set.of(\"isLast\", \"hashCode\", \"toString\", \"equals\");", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Set<String>", "name": "METHOD_NAMES = Set.of(\"isLast\", \"hashCode\", \"toString\", \"equals\")", "syntax_pass": true}, {"attribute_expression": "private Object[] currentRow;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Object[]", "name": "currentRow", "syntax_pass": true}, {"attribute_expression": "private Iterator<Object[]> iter;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Iterator<Object[]>", "name": "iter", "syntax_pass": true}, {"attribute_expression": "private final ResultSetMetaData metaData;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ResultSetMetaData", "name": "metaData", "syntax_pass": true}, {"attribute_expression": "private Boolean wasNull = Boolean.FALSE;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Boolean", "name": "wasNull = Boolean.FALSE", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public static ResultSet create(final ResultSetMetaData metaData, final Object[][] rows) {\n        return ProxyFactory.instance().createResultSet(new MockResultSet(metaData, rows));\n    }", "docstring": "\nCreate a {@code MockResultSet} proxy object. This is equivalent to:\n\n<pre>\nProxyFactory.instance().createResultSet(new MockResultSet(metaData, rows));\n</pre>\n\n@param metaData\n@param rows     A null value indicates an empty {@code ResultSet}.\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "ResultSet", "classes": []}, "name": "create", "params": [{"name": "metaData", "type": "ResultSetMetaData"}, {"name": "rows", "type": "Object[][]"}], "body": "                                                                                            {\n        return ProxyFactory.instance().createResultSet(new MockResultSet(metaData, rows));\n    }", "signature": "public static ResultSet create(final ResultSetMetaData metaData, final Object[][] rows)"}, {"syntax_pass": true, "original_string": "    public MockResultSet(final ResultSetMetaData metaData, final Object[][] rows) {\n        this.metaData = metaData;\n        if (rows == null) {\n            final List<Object[]> empty = Collections.emptyList();\n            this.iter = empty.iterator();\n        } else {\n            this.iter = Arrays.asList(rows).iterator();\n        }\n    }", "docstring": "\nMockResultSet constructor.\n\n@param metaData\n@param rows     A null value indicates an empty {@code ResultSet}.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "MockResultSet", "params": [{"name": "metaData", "type": "ResultSetMetaData"}, {"name": "rows", "type": "Object[][]"}], "body": "                                                                                  {\n        this.metaData = metaData;\n        if (rows == null) {\n            final List<Object[]> empty = Collections.emptyList();\n            this.iter = empty.iterator();\n        } else {\n            this.iter = Arrays.asList(rows).iterator();\n        }\n    }", "signature": "public MockResultSet(final ResultSetMetaData metaData, final Object[][] rows)"}, {"syntax_pass": true, "original_string": "    private int columnIndex(final Object[] args) throws SQLException {\n\n        if (args[0] instanceof Integer) {\n            return ((Integer) args[0]).intValue();\n\n        }\n        if (args[0] instanceof String) {\n            return columnNameToIndex((String) args[0]);\n\n        }\n        throw new SQLException(args[0] + \" must be Integer or String\");\n    }", "docstring": "\nThe get* methods can have an int column index or a String column name as the parameter. This method handles both cases and returns the column index that\nthe client is trying to get at.\n\n@param args\n@return A column index.\n@throws SQLException if a database access error occurs\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "int", "classes": []}, "name": "columnIndex", "params": [{"name": "args", "type": "Object[]"}], "body": "                                                                     {\n\n        if (args[0] instanceof Integer) {\n            return ((Integer) args[0]).intValue();\n\n        }\n        if (args[0] instanceof String) {\n            return columnNameToIndex((String) args[0]);\n\n        }\n        throw new SQLException(args[0] + \" must be Integer or String\");\n    }", "signature": "private int columnIndex(final Object[] args)"}, {"syntax_pass": true, "original_string": "    private int columnNameToIndex(final String columnName) throws SQLException {\n        for (int i = 0; i < this.currentRow.length; i++) {\n            final int c = i + 1;\n            if (this.metaData.getColumnName(c).equalsIgnoreCase(columnName)) {\n                return c;\n            }\n        }\n\n        throw new SQLException(columnName + \" is not a valid column name.\");\n    }", "docstring": "\nReturns the column index for the given column name.\n\n@return A 1 based index\n@throws SQLException if the column name is invalid\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "int", "classes": []}, "name": "columnNameToIndex", "params": [{"name": "columnName", "type": "String"}], "body": "                                                                               {\n        for (int i = 0; i < this.currentRow.length; i++) {\n            final int c = i + 1;\n            if (this.metaData.getColumnName(c).equalsIgnoreCase(columnName)) {\n                return c;\n            }\n        }\n\n        throw new SQLException(columnName + \" is not a valid column name.\");\n    }", "signature": "private int columnNameToIndex(final String columnName)"}, {"syntax_pass": true, "original_string": "    protected Object getBoolean(final int columnIndex) throws SQLException {\n        final Object obj = this.currentRow[columnIndex - 1];\n        setWasNull(obj);\n\n        try {\n            return obj == null ? Boolean.FALSE : Boolean.valueOf(obj.toString());\n\n        } catch (final NumberFormatException e) {\n            throw new SQLException(e.getMessage());\n        }\n    }", "docstring": "\nGets the boolean value at the given column index.\n\n@param columnIndex A 1 based index.\n@throws SQLException if a database access error occurs\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Object", "classes": []}, "name": "getBoolean", "params": [{"name": "columnIndex", "type": "int"}], "body": "                                                                           {\n        final Object obj = this.currentRow[columnIndex - 1];\n        setWasNull(obj);\n\n        try {\n            return obj == null ? Boolean.FALSE : Boolean.valueOf(obj.toString());\n\n        } catch (final NumberFormatException e) {\n            throw new SQLException(e.getMessage());\n        }\n    }", "signature": "protected Object getBoolean(final int columnIndex)"}, {"syntax_pass": true, "original_string": "    protected Object getByte(final int columnIndex) throws SQLException {\n        final Object obj = this.currentRow[columnIndex - 1];\n        setWasNull(obj);\n\n        try {\n            return obj == null ? Byte.valueOf((byte) 0) : Byte.valueOf(obj.toString());\n\n        } catch (final NumberFormatException e) {\n            throw new SQLException(e.getMessage());\n        }\n    }", "docstring": "\nGets the byte value at the given column index.\n\n@param columnIndex A 1 based index.\n@throws SQLException if a database access error occurs\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Object", "classes": []}, "name": "getByte", "params": [{"name": "columnIndex", "type": "int"}], "body": "                                                                        {\n        final Object obj = this.currentRow[columnIndex - 1];\n        setWasNull(obj);\n\n        try {\n            return obj == null ? Byte.valueOf((byte) 0) : Byte.valueOf(obj.toString());\n\n        } catch (final NumberFormatException e) {\n            throw new SQLException(e.getMessage());\n        }\n    }", "signature": "protected Object getByte(final int columnIndex)"}, {"syntax_pass": true, "original_string": "    protected Object getDouble(final int columnIndex) throws SQLException {\n        final Object obj = this.currentRow[columnIndex - 1];\n        setWasNull(obj);\n\n        try {\n            return obj == null ? Double.valueOf(0) : Double.valueOf(obj.toString());\n\n        } catch (final NumberFormatException e) {\n            throw new SQLException(e.getMessage());\n        }\n    }", "docstring": "\nGets the double value at the given column index.\n\n@param columnIndex A 1 based index.\n@throws SQLException if a database access error occurs\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Object", "classes": []}, "name": "getDouble", "params": [{"name": "columnIndex", "type": "int"}], "body": "                                                                          {\n        final Object obj = this.currentRow[columnIndex - 1];\n        setWasNull(obj);\n\n        try {\n            return obj == null ? Double.valueOf(0) : Double.valueOf(obj.toString());\n\n        } catch (final NumberFormatException e) {\n            throw new SQLException(e.getMessage());\n        }\n    }", "signature": "protected Object getDouble(final int columnIndex)"}, {"syntax_pass": true, "original_string": "    protected Object getFloat(final int columnIndex) throws SQLException {\n        final Object obj = this.currentRow[columnIndex - 1];\n        setWasNull(obj);\n\n        try {\n            return obj == null ? Float.valueOf(0) : Float.valueOf(obj.toString());\n\n        } catch (final NumberFormatException e) {\n            throw new SQLException(e.getMessage());\n        }\n    }", "docstring": "\nGets the float value at the given column index.\n\n@param columnIndex A 1 based index.\n@throws SQLException if a database access error occurs\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Object", "classes": []}, "name": "getFloat", "params": [{"name": "columnIndex", "type": "int"}], "body": "                                                                         {\n        final Object obj = this.currentRow[columnIndex - 1];\n        setWasNull(obj);\n\n        try {\n            return obj == null ? Float.valueOf(0) : Float.valueOf(obj.toString());\n\n        } catch (final NumberFormatException e) {\n            throw new SQLException(e.getMessage());\n        }\n    }", "signature": "protected Object getFloat(final int columnIndex)"}, {"syntax_pass": true, "original_string": "    protected Object getInt(final int columnIndex) throws SQLException {\n        final Object obj = this.currentRow[columnIndex - 1];\n        setWasNull(obj);\n\n        try {\n            return obj == null ? Integer.valueOf(0) : Integer.valueOf(obj.toString());\n\n        } catch (final NumberFormatException e) {\n            throw new SQLException(e.getMessage());\n        }\n    }", "docstring": "\nGets the int value at the given column index.\n\n@param columnIndex A 1 based index.\n@throws SQLException if a database access error occurs\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Object", "classes": []}, "name": "getInt", "params": [{"name": "columnIndex", "type": "int"}], "body": "                                                                       {\n        final Object obj = this.currentRow[columnIndex - 1];\n        setWasNull(obj);\n\n        try {\n            return obj == null ? Integer.valueOf(0) : Integer.valueOf(obj.toString());\n\n        } catch (final NumberFormatException e) {\n            throw new SQLException(e.getMessage());\n        }\n    }", "signature": "protected Object getInt(final int columnIndex)"}, {"syntax_pass": true, "original_string": "    protected Object getLong(final int columnIndex) throws SQLException {\n        final Object obj = this.currentRow[columnIndex - 1];\n        setWasNull(obj);\n\n        try {\n            return obj == null ? Long.valueOf(0) : Long.valueOf(obj.toString());\n\n        } catch (final NumberFormatException e) {\n            throw new SQLException(e.getMessage());\n        }\n    }", "docstring": "\nGets the long value at the given column index.\n\n@param columnIndex A 1 based index.\n@throws SQLException if a database access error occurs\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Object", "classes": []}, "name": "getLong", "params": [{"name": "columnIndex", "type": "int"}], "body": "                                                                        {\n        final Object obj = this.currentRow[columnIndex - 1];\n        setWasNull(obj);\n\n        try {\n            return obj == null ? Long.valueOf(0) : Long.valueOf(obj.toString());\n\n        } catch (final NumberFormatException e) {\n            throw new SQLException(e.getMessage());\n        }\n    }", "signature": "protected Object getLong(final int columnIndex)"}, {"syntax_pass": true, "original_string": "    protected ResultSetMetaData getMetaData() throws SQLException {\n        return this.metaData;\n    }", "docstring": "\n@throws SQLException\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "ResultSetMetaData", "classes": []}, "name": "getMetaData", "params": [], "body": "                                                                  {\n        return this.metaData;\n    }", "signature": "protected ResultSetMetaData getMetaData()"}, {"syntax_pass": true, "original_string": "    protected Object getObject(final int columnIndex) throws SQLException {\n        final Object obj = this.currentRow[columnIndex - 1];\n        setWasNull(obj);\n        return obj;\n    }", "docstring": "\nGets the object at the given column index.\n\n@param columnIndex A 1 based index.\n@throws SQLException if a database access error occurs\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Object", "classes": []}, "name": "getObject", "params": [{"name": "columnIndex", "type": "int"}], "body": "                                                                          {\n        final Object obj = this.currentRow[columnIndex - 1];\n        setWasNull(obj);\n        return obj;\n    }", "signature": "protected Object getObject(final int columnIndex)"}, {"syntax_pass": true, "original_string": "    protected Object getShort(final int columnIndex) throws SQLException {\n        final Object obj = this.currentRow[columnIndex - 1];\n        setWasNull(obj);\n\n        try {\n            return obj == null ? Short.valueOf((short) 0) : Short.valueOf(obj.toString());\n\n        } catch (final NumberFormatException e) {\n            throw new SQLException(e.getMessage());\n        }\n    }", "docstring": "\nGets the short value at the given column index.\n\n@param columnIndex A 1 based index.\n@throws SQLException if a database access error occurs\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Object", "classes": []}, "name": "getShort", "params": [{"name": "columnIndex", "type": "int"}], "body": "                                                                         {\n        final Object obj = this.currentRow[columnIndex - 1];\n        setWasNull(obj);\n\n        try {\n            return obj == null ? Short.valueOf((short) 0) : Short.valueOf(obj.toString());\n\n        } catch (final NumberFormatException e) {\n            throw new SQLException(e.getMessage());\n        }\n    }", "signature": "protected Object getShort(final int columnIndex)"}, {"syntax_pass": true, "original_string": "    protected String getString(final int columnIndex) throws SQLException {\n        final Object obj = getObject(columnIndex);\n        setWasNull(obj);\n        return Objects.toString(obj, null);\n    }", "docstring": "\nGets the String at the given column index.\n\n@param columnIndex A 1 based index.\n@throws SQLException if a database access error occurs\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "String", "classes": []}, "name": "getString", "params": [{"name": "columnIndex", "type": "int"}], "body": "                                                                          {\n        final Object obj = getObject(columnIndex);\n        setWasNull(obj);\n        return Objects.toString(obj, null);\n    }", "signature": "protected String getString(final int columnIndex)"}, {"syntax_pass": true, "original_string": "    private Object handleColumnMethod(final String methodName, final Object[] args) throws SQLException {\n        switch (methodName) {\n            case \"getBoolean\":\n                return getBoolean(columnIndex(args));\n            case \"getByte\":\n                return getByte(columnIndex(args));\n            case \"getDouble\":\n                return getDouble(columnIndex(args));\n            case \"getFloat\":\n                return getFloat(columnIndex(args));\n            case \"getInt\":\n                return getInt(columnIndex(args));\n            case \"getLong\":\n                return getLong(columnIndex(args));\n            case \"getObject\":\n                return getObject(columnIndex(args));\n            case \"getShort\":\n                return getShort(columnIndex(args));\n            case \"getString\":\n                return getString(columnIndex(args));\n            case \"wasNull\":\n                return wasNull();\n            default:\n                throw new UnsupportedOperationException(\"Unsupported column method: \" + methodName);\n        }\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Object", "classes": []}, "name": "handleColumnMethod", "params": [{"name": "methodName", "type": "String"}, {"name": "args", "type": "Object[]"}], "body": "                                                                                                        {\n        switch (methodName) {\n            case \"getBoolean\":\n                return getBoolean(columnIndex(args));\n            case \"getByte\":\n                return getByte(columnIndex(args));\n            case \"getDouble\":\n                return getDouble(columnIndex(args));\n            case \"getFloat\":\n                return getFloat(columnIndex(args));\n            case \"getInt\":\n                return getInt(columnIndex(args));\n            case \"getLong\":\n                return getLong(columnIndex(args));\n            case \"getObject\":\n                return getObject(columnIndex(args));\n            case \"getShort\":\n                return getShort(columnIndex(args));\n            case \"getString\":\n                return getString(columnIndex(args));\n            case \"wasNull\":\n                return wasNull();\n            default:\n                throw new UnsupportedOperationException(\"Unsupported column method: \" + methodName);\n        }\n    }", "signature": "private Object handleColumnMethod(final String methodName, final Object[] args)"}, {"syntax_pass": true, "original_string": "    private Object handleNonColumnMethod(final String methodName, final Object proxy, final Object[] args) throws SQLException {\n        switch (methodName) {\n            case \"isLast\":\n                return isLast();\n            case \"hashCode\":\n                return Integer.valueOf(System.identityHashCode(proxy));\n            case \"toString\":\n                return \"MockResultSet \" + System.identityHashCode(proxy);\n            case \"equals\":\n                return Boolean.valueOf(proxy == args[0]);\n            default:\n                throw new UnsupportedOperationException(\"Unsupported non-column method: \" + methodName);\n        }\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Object", "classes": []}, "name": "handleNonColumnMethod", "params": [{"name": "methodName", "type": "String"}, {"name": "proxy", "type": "Object"}, {"name": "args", "type": "Object[]"}], "body": "                                                                                                                               {\n        switch (methodName) {\n            case \"isLast\":\n                return isLast();\n            case \"hashCode\":\n                return Integer.valueOf(System.identityHashCode(proxy));\n            case \"toString\":\n                return \"MockResultSet \" + System.identityHashCode(proxy);\n            case \"equals\":\n                return Boolean.valueOf(proxy == args[0]);\n            default:\n                throw new UnsupportedOperationException(\"Unsupported non-column method: \" + methodName);\n        }\n    }", "signature": "private Object handleNonColumnMethod(final String methodName, final Object proxy, final Object[] args)"}, {"syntax_pass": true, "original_string": "    @Override\n    public Object invoke(final Object proxy, final Method method, final Object[] args)\n        throws Throwable {\n\n        final String methodName = method.getName();\n        switch (methodName) {\n        case \"getMetaData\":\n            return getMetaData();\n        case \"next\":\n            return next();\n        case \"previous\":\n            break;\n        case \"close\":\n            break;\n        default:\n            if (isColumnMethod(methodName)) {\n                return handleColumnMethod(methodName, args);\n            } else if (METHOD_NAMES.contains(methodName)) {\n                return handleNonColumnMethod(methodName, proxy, args);\n            }\n            break;\n        }\n        throw new UnsupportedOperationException(\"Unsupported method: \" + methodName);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object", "classes": []}, "name": "invoke", "params": [{"name": "proxy", "type": "Object"}, {"name": "method", "type": "Method"}, {"name": "args", "type": "Object[]"}], "body": "                         {\n\n        final String methodName = method.getName();\n        switch (methodName) {\n        case \"getMetaData\":\n            return getMetaData();\n        case \"next\":\n            return next();\n        case \"previous\":\n            break;\n        case \"close\":\n            break;\n        default:\n            if (isColumnMethod(methodName)) {\n                return handleColumnMethod(methodName, args);\n            } else if (METHOD_NAMES.contains(methodName)) {\n                return handleNonColumnMethod(methodName, proxy, args);\n            }\n            break;\n        }\n        throw new UnsupportedOperationException(\"Unsupported method: \" + methodName);\n    }", "signature": "@Override\n    public Object invoke(final Object proxy, final Method method, final Object[] args)"}, {"syntax_pass": true, "original_string": "    private boolean isColumnMethod(final String methodName) {\n        return methodName.startsWith(\"get\") || methodName.equals(\"wasNull\");\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isColumnMethod", "params": [{"name": "methodName", "type": "String"}], "body": "                                                            {\n        return methodName.startsWith(\"get\") || methodName.equals(\"wasNull\");\n    }", "signature": "private boolean isColumnMethod(final String methodName)"}, {"syntax_pass": true, "original_string": "    protected Boolean isLast() throws SQLException {\n        return this.iter.hasNext() ? Boolean.FALSE : Boolean.TRUE;\n    }", "docstring": "\n@throws SQLException\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Boolean", "classes": []}, "name": "isLast", "params": [], "body": "                                                   {\n        return this.iter.hasNext() ? Boolean.FALSE : Boolean.TRUE;\n    }", "signature": "protected Boolean isLast()"}, {"syntax_pass": true, "original_string": "    protected Boolean next() throws SQLException {\n        if (!this.iter.hasNext()) {\n            return Boolean.FALSE;\n        }\n        this.currentRow = iter.next();\n        return Boolean.TRUE;\n    }", "docstring": "\n@throws SQLException\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Boolean", "classes": []}, "name": "next", "params": [], "body": "                                                 {\n        if (!this.iter.hasNext()) {\n            return Boolean.FALSE;\n        }\n        this.currentRow = iter.next();\n        return Boolean.TRUE;\n    }", "signature": "protected Boolean next()"}, {"syntax_pass": true, "original_string": "    private void setWasNull(final Object isNull) {\n        this.wasNull = isNull == null ? Boolean.TRUE : Boolean.FALSE;\n    }", "docstring": "\nAssigns this.wasNull a Boolean value based on the object passed in.\n\n@param isNull\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "setWasNull", "params": [{"name": "isNull", "type": "Object"}], "body": "                                                 {\n        this.wasNull = isNull == null ? Boolean.TRUE : Boolean.FALSE;\n    }", "signature": "private void setWasNull(final Object isNull)"}, {"syntax_pass": true, "original_string": "    protected Boolean wasNull() throws SQLException {\n        return this.wasNull;\n    }", "docstring": "\n@throws SQLException\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Boolean", "classes": []}, "name": "wasNull", "params": [], "body": "                                                    {\n        return this.wasNull;\n    }", "signature": "protected Boolean wasNull()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/dbutils/QueryRunnerTest.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils;\n\nimport static org.junit.Assert.fail;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.ArgumentMatchers.eq;\nimport static org.mockito.Mockito.doThrow;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.never;\nimport static org.mockito.Mockito.times;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\nimport java.sql.CallableStatement;\nimport java.sql.Connection;\nimport java.sql.ParameterMetaData;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.sql.Statement;\nimport java.sql.Types;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.sql.DataSource;\n\nimport org.apache.commons.dbutils.handlers.ArrayHandler;\nimport org.apache.commons.dbutils.handlers.ScalarHandler;\nimport org.junit.Assert;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.Mock;\nimport org.mockito.invocation.InvocationOnMock;\nimport org.mockito.junit.MockitoJUnitRunner;\nimport org.mockito.stubbing.Answer;\n\n@SuppressWarnings(\"boxing\") // test code\n@RunWith(MockitoJUnitRunner.class)\npublic class QueryRunnerTest {\n    //\n    // Random tests\n    //\n    final class MyBean {\n        private int a;\n        private double b;\n        private String c;\n\n        public int getA() {\n            return a;\n        }\n\n        public double getB() {\n            return b;\n        }\n\n        public String getC() {\n            return c;\n        }\n\n        public void setA(final int a) {\n            this.a = a;\n        }\n\n        public void setB(final double b) {\n            this.b = b;\n        }\n\n        public void setC(final String c) {\n            this.c = c;\n        }\n    }\n\n    private QueryRunner runner;\n\n    private ArrayHandler handler;\n\n    @Mock\n    private DataSource dataSource;\n\n    @Mock\n    private Connection conn;\n\n    @Mock\n    private PreparedStatement prepStmt;\n\n    @Mock\n    private Statement stmt;\n\n    @Mock\n    private CallableStatement call;\n\n    @Mock\n    private ParameterMetaData meta;\n\n    @Mock\n    private ResultSet results;\n\n    @Mock\n    private ResultSetMetaData resultsMeta;\n\n    //\n    // Batch test cases\n    //\n\n    // helper method for calling batch when an exception is expected\n    private void callBatchWithException(final String sql, final Object[][] params) throws Exception {\n        when(meta.getParameterCount()).thenReturn(2);\n        boolean caught = false;\n\n        try {\n            runner.batch(sql, params);\n\n            verify(prepStmt, times(1)).getParameterMetaData();\n            verify(prepStmt, times(2)).addBatch();\n            verify(prepStmt, times(1)).executeBatch();\n            verify(prepStmt, times(1)).close();    // make sure the statement is closed\n            verify(conn, times(1)).close();    // make sure the connection is closed\n        } catch (final SQLException e) {\n            System.out.println(\"[TEST] The following exception is expected:\");\n            System.out.println(e);\n            caught = true;\n        }\n\n        if (!caught) {\n            fail(\"Exception never thrown, but expected\");\n        }\n    }\n\n    // helper method for calling execute when an exception is expected\n    private void callExecuteWithException(final Object... params) throws Exception {\n        boolean caught = false;\n\n        try {\n            when(meta.getParameterCount()).thenReturn(2);\n            runner.query(\"{call my_proc(?, ?)}\", handler, params);\n\n        } catch (final SQLException e) {\n            caught = true;\n        }\n\n        if (!caught) {\n            fail(\"Exception never thrown, but expected\");\n        }\n    }\n\n    // helper method for calling execute when an exception is expected\n    private void callExecuteWithResultSetWithException(final Object... params) throws Exception {\n        boolean caught = false;\n\n        try {\n            when(meta.getParameterCount()).thenReturn(2);\n            runner.execute(\"{call my_proc(?, ?)}\", handler, params);\n\n        } catch (final SQLException e) {\n            caught = true;\n        }\n\n        if (!caught) {\n            fail(\"Exception never thrown, but expected\");\n        }\n    }\n\n    private void callGoodBatch(final Connection conn, final Object[][] params) throws Exception {\n        when(meta.getParameterCount()).thenReturn(2);\n        runner.batch(conn, \"select * from blah where ? = ?\", params);\n\n        verify(prepStmt, times(1)).getParameterMetaData();\n        verify(prepStmt, times(2)).addBatch();\n        verify(prepStmt, times(1)).executeBatch();\n        // make sure we closed the statement\n        verify(prepStmt, times(1)).close();\n        // make sure we do not close the connection, since QueryRunner.batch(Connection, String, Object[][]) does not close connections\n        verify(conn, times(0)).close();\n    }\n\n    private void callGoodBatch(final Object[][] params) throws Exception {\n        callGoodBatch(params, true);\n    }\n\n    private void callGoodBatch(final Object[][] params, final boolean pmdCheck) throws Exception {\n        when(meta.getParameterCount()).thenReturn(2);\n        runner.batch(\"select * from blah where ? = ?\", params);\n\n        verify(prepStmt, times(pmdCheck ? 1 : 0)).getParameterMetaData();\n        verify(prepStmt, times(2)).addBatch();\n        verify(prepStmt, times(1)).executeBatch();\n        verify(prepStmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(1)).close();    // make sure we closed the connection\n    }\n\n    private void callGoodExecute() throws Exception {\n        when(call.execute()).thenReturn(false);\n        when(call.getUpdateCount()).thenReturn(3);\n\n        when(meta.getParameterCount()).thenReturn(2);\n        int result = runner.execute(\"{call my_proc(?, ?)}\", \"unit\", \"test\");\n\n        Assert.assertEquals(3, result);\n\n        verify(call, times(1)).execute();\n        verify(call, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(1)).close();    // make sure we do not close the connection\n\n        // call the other variation of query\n        when(meta.getParameterCount()).thenReturn(0);\n        result = runner.execute(\"{call my_proc()}\");\n\n        Assert.assertEquals(3, result);\n\n        verify(call, times(2)).execute();\n        verify(call, times(2)).close();    // make sure we closed the statement\n        verify(conn, times(2)).close();    // make sure we do not close the connection\n\n        // Test single OUT parameter\n        when(meta.getParameterCount()).thenReturn(1);\n        when(call.getObject(1)).thenReturn(42);\n        final OutParameter<Integer> intParam =\n            new OutParameter<>(Types.INTEGER, Integer.class);\n        result = runner.execute(\"{?= call my_proc()}\", intParam);\n\n        Assert.assertEquals(42, intParam.getValue().intValue());\n        Assert.assertEquals(3, result);\n\n        verify(call, times(3)).execute();\n        verify(call, times(3)).close();    // make sure we closed the statement\n        verify(conn, times(3)).close();    // make sure we do not close the connection\n\n        // Test OUT parameters with IN parameters\n        when(meta.getParameterCount()).thenReturn(3);\n        when(call.getObject(1)).thenReturn(4242);\n        intParam.setValue(null);\n        result = runner.execute(\"{?= call my_proc(?, ?)}\", intParam, \"unit\", \"test\");\n\n        Assert.assertEquals(4242, intParam.getValue().intValue());\n        Assert.assertEquals(3, result);\n\n        verify(call, times(4)).execute();\n        verify(call, times(4)).close();    // make sure we closed the statement\n        verify(conn, times(4)).close();    // make sure we do not close the connection\n\n        // Test INOUT parameters\n        when(meta.getParameterCount()).thenReturn(3);\n        when(call.getObject(1)).thenReturn(24);\n        when(call.getObject(3)).thenReturn(\"out\");\n        intParam.setValue(null);\n        final OutParameter<String> stringParam =\n            new OutParameter<>(Types.VARCHAR, String.class, \"in\");\n        result = runner.execute(\"{?= call my_proc(?, ?)}\", intParam, \"test\", stringParam);\n\n        Assert.assertEquals(24, intParam.getValue().intValue());\n        Assert.assertEquals(\"out\", stringParam.getValue());\n        Assert.assertEquals(3, result);\n\n        verify(call, times(5)).execute();\n        verify(call, times(5)).close();    // make sure we closed the statement\n        verify(conn, times(5)).close();    // make sure we do not close the connection\n    }\n\n    //\n    // Execute tests\n    //\n    private void callGoodExecute(final Connection conn) throws Exception {\n        when(call.execute()).thenReturn(false);\n        when(call.getUpdateCount()).thenReturn(3);\n\n        when(meta.getParameterCount()).thenReturn(2);\n        int result = runner.execute(conn, \"{call my_proc(?, ?)}\", \"unit\", \"test\");\n\n        Assert.assertEquals(3, result);\n\n        verify(call, times(1)).execute();\n        verify(call, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we do not close the connection\n\n        // call the other variation of query\n        when(meta.getParameterCount()).thenReturn(0);\n        result = runner.execute(conn, \"{call my_proc()}\");\n\n        Assert.assertEquals(3, result);\n\n        verify(call, times(2)).execute();\n        verify(call, times(2)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we do not close the connection\n\n        // Test single OUT parameter\n        when(meta.getParameterCount()).thenReturn(1);\n        when(call.getObject(1)).thenReturn(42);\n        final OutParameter<Integer> intParam =\n            new OutParameter<>(Types.INTEGER, Integer.class);\n        result = runner.execute(conn, \"{?= call my_proc()}\", intParam);\n\n        Assert.assertEquals(42, intParam.getValue().intValue());\n        Assert.assertEquals(3, result);\n\n        verify(call, times(3)).execute();\n        verify(call, times(3)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we do not close the connection\n\n        // Test OUT parameters with IN parameters\n        when(meta.getParameterCount()).thenReturn(3);\n        when(call.getObject(1)).thenReturn(4242);\n        intParam.setValue(null);\n        result = runner.execute(conn, \"{?= call my_proc(?, ?)}\", intParam, \"unit\", \"test\");\n\n        Assert.assertEquals(4242, intParam.getValue().intValue());\n        Assert.assertEquals(3, result);\n\n        verify(call, times(4)).execute();\n        verify(call, times(4)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we do not close the connection\n\n        // Test INOUT parameters\n        when(meta.getParameterCount()).thenReturn(3);\n        when(call.getObject(1)).thenReturn(24);\n        when(call.getObject(3)).thenReturn(\"out\");\n        intParam.setValue(null);\n        final OutParameter<String> stringParam =\n            new OutParameter<>(Types.VARCHAR, String.class, \"in\");\n        result = runner.execute(conn, \"{?= call my_proc(?, ?)}\", intParam, \"test\", stringParam);\n\n        Assert.assertEquals(24, intParam.getValue().intValue());\n        Assert.assertEquals(\"out\", stringParam.getValue());\n        Assert.assertEquals(3, result);\n\n        verify(call, times(5)).execute();\n        verify(call, times(5)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we do not close the connection\n    }\n\n    private void callGoodExecuteWithResultSet() throws Exception {\n        when(call.execute()).thenReturn(true);\n\n        when(meta.getParameterCount()).thenReturn(2);\n        runner.execute(\"{call my_proc(?, ?)}\", handler, \"unit\", \"test\");\n\n        verify(call, times(1)).execute();\n        verify(results, times(1)).close();\n        verify(call, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(1)).close();    // make sure we do not close the connection\n\n        // call the other variation of query\n        when(meta.getParameterCount()).thenReturn(0);\n        runner.execute(\"{call my_proc()}\", handler);\n\n        verify(call, times(2)).execute();\n        verify(results, times(2)).close();\n        verify(call, times(2)).close();    // make sure we closed the statement\n        verify(conn, times(2)).close();    // make sure we do not close the connection\n\n        // Test single OUT parameter\n        when(meta.getParameterCount()).thenReturn(1);\n        when(call.getObject(1)).thenReturn(42);\n        final OutParameter<Integer> intParam =\n            new OutParameter<>(Types.INTEGER, Integer.class);\n        runner.execute(\"{?= call my_proc()}\", handler, intParam);\n\n        Assert.assertEquals(42, intParam.getValue().intValue());\n\n        verify(call, times(3)).execute();\n        verify(results, times(3)).close();\n        verify(call, times(3)).close();    // make sure we closed the statement\n        verify(conn, times(3)).close();    // make sure we do not close the connection\n\n        // Test OUT parameters with IN parameters\n        when(meta.getParameterCount()).thenReturn(3);\n        when(call.getObject(1)).thenReturn(4242);\n        intParam.setValue(null);\n        runner.execute(\"{?= call my_proc(?, ?)}\", handler, intParam, \"unit\", \"test\");\n\n        Assert.assertEquals(4242, intParam.getValue().intValue());\n\n        verify(call, times(4)).execute();\n        verify(results, times(4)).close();\n        verify(call, times(4)).close();    // make sure we closed the statement\n        verify(conn, times(4)).close();    // make sure we do not close the connection\n\n        // Test INOUT parameters\n        when(meta.getParameterCount()).thenReturn(3);\n        when(call.getObject(1)).thenReturn(24);\n        when(call.getObject(3)).thenReturn(\"out\");\n        intParam.setValue(null);\n        final OutParameter<String> stringParam =\n            new OutParameter<>(Types.VARCHAR, String.class, \"in\");\n        runner.execute(\"{?= call my_proc(?, ?)}\", handler, intParam, \"test\", stringParam);\n\n        Assert.assertEquals(24, intParam.getValue().intValue());\n        Assert.assertEquals(\"out\", stringParam.getValue());\n\n        verify(call, times(5)).execute();\n        verify(results, times(5)).close();\n        verify(call, times(5)).close();    // make sure we closed the statement\n        verify(conn, times(5)).close();    // make sure we do not close the connection\n    }\n\n    private void callGoodExecuteWithResultSet(final Connection conn) throws Exception {\n        when(call.execute()).thenReturn(true);\n\n        when(meta.getParameterCount()).thenReturn(2);\n        runner.execute(conn, \"{call my_proc(?, ?)}\", handler, \"unit\", \"test\");\n\n        verify(call, times(1)).execute();\n        verify(results, times(1)).close();\n        verify(call, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we do not close the connection\n\n        // call the other variation of query\n        when(meta.getParameterCount()).thenReturn(0);\n        runner.execute(conn, \"{call my_proc()}\", handler);\n\n        verify(call, times(2)).execute();\n        verify(results, times(2)).close();\n        verify(call, times(2)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we do not close the connection\n\n        // Test single OUT parameter\n        when(meta.getParameterCount()).thenReturn(1);\n        when(call.getObject(1)).thenReturn(42);\n        final OutParameter<Integer> intParam =\n            new OutParameter<>(Types.INTEGER, Integer.class);\n        runner.execute(conn, \"{?= call my_proc()}\", handler, intParam);\n\n        Assert.assertEquals(42, intParam.getValue().intValue());\n\n        verify(call, times(3)).execute();\n        verify(results, times(3)).close();\n        verify(call, times(3)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we do not close the connection\n\n        // Test OUT parameters with IN parameters\n        when(meta.getParameterCount()).thenReturn(3);\n        when(call.getObject(1)).thenReturn(4242);\n        intParam.setValue(null);\n        runner.execute(conn, \"{?= call my_proc(?, ?)}\", handler, intParam, \"unit\", \"test\");\n\n        Assert.assertEquals(4242, intParam.getValue().intValue());\n\n        verify(call, times(4)).execute();\n        verify(results, times(4)).close();\n        verify(call, times(4)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we do not close the connection\n\n        // Test INOUT parameters\n        when(meta.getParameterCount()).thenReturn(3);\n        when(call.getObject(1)).thenReturn(24);\n        when(call.getObject(3)).thenReturn(\"out\");\n        intParam.setValue(null);\n        final OutParameter<String> stringParam =\n            new OutParameter<>(Types.VARCHAR, String.class, \"in\");\n        runner.execute(conn, \"{?= call my_proc(?, ?)}\", handler, intParam, \"test\", stringParam);\n\n        Assert.assertEquals(24, intParam.getValue().intValue());\n        Assert.assertEquals(\"out\", stringParam.getValue());\n\n        verify(call, times(5)).execute();\n        verify(results, times(5)).close();\n        verify(call, times(5)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we do not close the connection\n    }\n\n    private void callGoodQuery() throws Exception {\n        when(meta.getParameterCount()).thenReturn(2);\n        String sql = \"select * from blah where ? = ?\";\n        runner.query(sql, handler, \"unit\", \"test\");\n\n        verify(prepStmt, times(1)).executeQuery();\n        verify(results, times(1)).close();\n        verify(prepStmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(1)).close();    // make sure we closed the connection\n\n        // call the other variation of query\n        sql = \"select * from blah\";\n        runner.query(sql, handler);\n\n        verify(stmt, times(1)).executeQuery(sql);\n        verify(results, times(2)).close();\n        verify(stmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(2)).close();    // make sure we closed the connection\n    }\n\n    //\n    // Query test cases\n    //\n    private void callGoodQuery(final Connection conn) throws Exception {\n        when(meta.getParameterCount()).thenReturn(2);\n        String sql = \"select * from blah where ? = ?\";\n        runner.query(conn, sql, handler, \"unit\", \"test\");\n\n        verify(prepStmt, times(1)).executeQuery();\n        verify(results, times(1)).close();\n        verify(prepStmt, times(1)).close();    // make sure we closed the statement\n        // make sure we do not close the connection, since QueryRunner.query(Connection, String, ResultSetHandler<T>, Object...) does not close connections\n        verify(conn, times(0)).close();\n        // call the other variation of query\n        sql = \"select * from blah\";\n        runner.query(conn, sql, handler);\n\n        verify(stmt, times(1)).executeQuery(sql);\n        verify(results, times(2)).close();\n        verify(stmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we do not close the connection, see above\n    }\n\n    private void callGoodUpdate() throws Exception {\n        when(meta.getParameterCount()).thenReturn(2);\n        String sql = \"update blah set ? = ?\";\n        runner.update(sql, \"unit\", \"test\");\n\n        verify(prepStmt, times(1)).executeUpdate();\n        verify(prepStmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(1)).close();    // make sure we closed the connection\n\n        // call the other variation\n        when(meta.getParameterCount()).thenReturn(0);\n        sql = \"update blah set unit = test\";\n        runner.update(sql);\n\n        verify(stmt, times(1)).executeUpdate(sql);\n        verify(stmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(2)).close();    // make sure we closed the connection\n\n        // call the other variation\n        when(meta.getParameterCount()).thenReturn(1);\n        sql = \"update blah set unit = ?\";\n        runner.update(sql, \"test\");\n\n        verify(prepStmt, times(2)).executeUpdate();\n        verify(prepStmt, times(2)).close();    // make sure we closed the statement\n        verify(conn, times(3)).close();    // make sure we closed the connection\n    }\n\n    //\n    // Update test cases\n    //\n    private void callGoodUpdate(final Connection conn) throws Exception {\n        when(meta.getParameterCount()).thenReturn(2);\n        runner.update(conn, \"update blah set ? = ?\", \"unit\", \"test\");\n\n        verify(prepStmt, times(1)).executeUpdate();\n        verify(prepStmt, times(1)).close();    // make sure we closed the statement\n        // make sure we do not close the connection, since QueryRunner.update(Connection, String, Object...) does not close connections\n        verify(conn, times(0)).close();\n        // call the other variation\n        when(meta.getParameterCount()).thenReturn(0);\n        final String sql = \"update blah set unit = test\";\n        runner.update(conn, sql);\n\n        verify(stmt, times(1)).executeUpdate(sql);\n        verify(stmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we do not close the connection, see above\n\n        // call the other variation\n        when(meta.getParameterCount()).thenReturn(1);\n        runner.update(conn, \"update blah set unit = ?\", \"test\");\n\n        verify(prepStmt, times(2)).executeUpdate();\n        verify(prepStmt, times(2)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we do not close the connection, see above\n    }\n\n    /** Helper method for calling batch when an exception is expected. */\n    private void callQueryWithException(final Object... params) throws Exception {\n        boolean caught = false;\n\n        try {\n            when(meta.getParameterCount()).thenReturn(2);\n            final String sql = \"select * from blah where ? = ?\";\n            runner.query(sql, handler, params);\n\n            verify(prepStmt, never()).close(); // make sure the statement is still open\n            verify(prepStmt, times(1)).executeQuery();\n            verify(prepStmt, times(1)).close(); // make sure we closed the statement\n            verify(results, times(1)).close();\n            verify(conn, times(1)).close(); // make sure we closed the connection\n        } catch (final SQLException e) {\n            caught = true;\n        }\n\n        if (!caught) {\n            fail(\"Exception never thrown, but expected\");\n        }\n    }\n\n    // helper method for calling batch when an exception is expected\n    private void callUpdateWithException(final Object... params) throws Exception {\n        boolean caught = false;\n\n        try {\n            when(meta.getParameterCount()).thenReturn(2);\n            final String sql = \"select * from blah where ? = ?\";\n            runner.update(sql, params);\n\n            verify(prepStmt, times(1)).executeUpdate();\n            verify(prepStmt, times(1)).close(); // make sure we closed the statement\n            verify(conn, times(1)).close(); // make sure we closed the connection\n        } catch (final SQLException e) {\n            caught = true;\n        }\n\n        if (!caught) {\n            fail(\"Exception never thrown, but expected\");\n        }\n    }\n\n    @Before\n    public void setUp() throws Exception {\n        when(dataSource.getConnection()).thenReturn(conn);\n\n        when(conn.prepareStatement(any(String.class))).thenReturn(prepStmt);\n        when(prepStmt.getParameterMetaData()).thenReturn(meta);\n        when(prepStmt.executeQuery()).thenReturn(results);\n\n        when(conn.createStatement()).thenReturn(stmt);\n        when(stmt.executeQuery(any(String.class))).thenReturn(results);\n\n        when(conn.prepareCall(any(String.class))).thenReturn(call);\n        when(call.getParameterMetaData()).thenReturn(meta);\n        when(call.getResultSet()).thenReturn(results);\n        when(call.getMoreResults()).thenReturn(false);\n\n        when(results.next()).thenReturn(false);\n\n         handler = new ArrayHandler();\n         runner = new QueryRunner(dataSource);\n    }\n\n    @Test\n    public void testAddBatchExceptionOnAdd() throws Exception {\n        final String[][] params = { { \"unit\", \"unit\" }, { \"test\", \"test\" } };\n\n        doThrow(new SQLException()).when(prepStmt).addBatch();\n\n        callBatchWithException(\"select * from blah where ? = ?\", params);\n    }\n\n    @Test(expected = SQLException.class)\n    public void testBadPrepareConnection() throws Exception {\n        runner = new QueryRunner();\n        runner.update(\"update blah set unit = test\");\n    }\n\n    @Test\n    public void testExecuteBatchExceptionOnExec() throws Exception {\n        final String[][] params = { { \"unit\", \"unit\" }, { \"test\", \"test\" } };\n\n        doThrow(new SQLException()).when(prepStmt).executeBatch();\n\n        callBatchWithException(\"select * from blah where ? = ?\", params);\n    }\n\n    @Test\n    public void testExecuteException() throws Exception {\n        callExecuteWithException(handler, \"unit\", \"test\");\n    }\n\n    @Test\n    public void testExecuteQueryException() throws Exception {\n        callQueryWithException(handler, \"unit\", \"test\");\n    }\n\n    @Test\n    public void testExecuteUpdateException() throws Exception {\n        doThrow(new SQLException()).when(prepStmt).executeUpdate();\n\n        callUpdateWithException(\"unit\", \"test\");\n    }\n\n    @Test\n    public void testExecuteWithMultipleResultSets() throws Exception {\n        when(call.execute()).thenReturn(true);\n        when(call.getMoreResults()).thenAnswer(new Answer<Boolean>() {\n            private int count = 1;\n            @Override\n            public Boolean answer(final InvocationOnMock invocation) {\n                return ++count <= 3;\n            }\n        });\n        when(meta.getParameterCount()).thenReturn(0);\n        final List<Object[]> objects = runner.execute(\"{call my_proc()}\", handler);\n\n        Assert.assertEquals(3, objects.size());\n        verify(call, times(1)).execute();\n        verify(results, times(3)).close();\n        verify(call, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(1)).close();    // make sure we close the connection\n\n    }\n\n    @Test\n    public void testExecuteWithResultSetException() throws Exception {\n        callExecuteWithResultSetWithException(handler, \"unit\", \"test\");\n    }\n\n    @Test\n    public void testFillStatementWithBean() throws Exception {\n        final MyBean bean = new MyBean();\n        when(meta.getParameterCount()).thenReturn(3);\n        runner.fillStatementWithBean(prepStmt, bean, \"a\", \"b\", \"c\");\n    }\n\n    @Test(expected = NullPointerException.class)\n    public void testFillStatementWithBeanNullNames() throws Exception {\n        final MyBean bean = new MyBean();\n        runner.fillStatementWithBean(prepStmt, bean, \"a\", \"b\", null);\n    }\n\n    @Test\n    public void testGoodBatch() throws Exception {\n        final String[][] params = { { \"unit\", \"unit\" }, { \"test\", \"test\" } };\n\n        callGoodBatch(params);\n    }\n\n    @Test\n    public void testGoodBatchDefaultConstructor() throws Exception {\n        runner = new QueryRunner();\n        final String[][] params = { { \"unit\", \"unit\" }, { \"test\", \"test\" } };\n\n        callGoodBatch(conn, params);\n    }\n\n    @Test\n    public void testGoodBatchInsert() throws Exception {\n        results = mock(ResultSet.class);\n        resultsMeta = mock(ResultSetMetaData.class);\n\n        when(meta.getParameterCount()).thenReturn(2);\n        when(conn.prepareStatement(any(String.class), eq(Statement.RETURN_GENERATED_KEYS))).thenReturn(prepStmt);\n        when(prepStmt.getGeneratedKeys()).thenReturn(results);\n        when(results.next()).thenReturn(true).thenReturn(true).thenReturn(false);\n\n        final ResultSetHandler<List<Object>> handler = rs -> {\n            final List<Object> objects = new ArrayList<>();\n            while (rs.next()) {\n                objects.add(new Object());\n            }\n            return objects;\n        };\n\n        final Object[][] params = new Object[2][2];\n        params[0][0] = \"Test\";\n        params[0][1] = \"Blah\";\n        params[1][0] = \"Test2\";\n        params[1][1] = \"Blah2\";\n\n        final List<Object> generatedKeys = runner.insertBatch(\"INSERT INTO blah(col1, col2) VALUES(?,?)\", handler, params);\n\n        verify(prepStmt, times(2)).addBatch();\n        verify(prepStmt, times(1)).executeBatch();\n        verify(prepStmt, times(1)).close(); // make sure we closed the statement\n        verify(conn, times(1)).close(); // make sure we closed the connection\n\n        Assert.assertEquals(2, generatedKeys.size());\n    }\n\n    @Test\n    public void testGoodBatchPmdTrue() throws Exception {\n        runner = new QueryRunner(dataSource, true);\n        final String[][] params = { { \"unit\", \"unit\" }, { \"test\", \"test\" } };\n\n        callGoodBatch(params, false);\n    }\n\n    @Test\n    public void testGoodExecute() throws Exception {\n        callGoodExecute();\n    }\n\n    @Test\n    public void testGoodExecuteDefaultConstructor() throws Exception {\n        runner = new QueryRunner();\n        callGoodExecute(conn);\n    }\n\n    @Test\n    public void testGoodExecutePmdTrue() throws Exception {\n        runner = new QueryRunner(true);\n        callGoodExecute(conn);\n    }\n\n    @Test\n    public void testGoodExecuteWithResultSet() throws Exception {\n        callGoodExecuteWithResultSet();\n    }\n\n    @Test\n    public void testGoodExecuteWithResultSetDefaultConstructor() throws Exception {\n        runner = new QueryRunner();\n        callGoodExecuteWithResultSet(conn);\n    }\n\n    @Test\n    public void testGoodExecuteWithResultSetPmdTrue() throws Exception {\n        runner = new QueryRunner(true);\n        callGoodExecuteWithResultSet(conn);\n    }\n\n    @Test\n    public void testGoodInsert() throws Exception {\n        results = mock(ResultSet.class);\n\n        when(meta.getParameterCount()).thenReturn(2);\n        when(conn.prepareStatement(any(String.class), eq(Statement.RETURN_GENERATED_KEYS))).thenReturn(prepStmt);\n        when(prepStmt.getGeneratedKeys()).thenReturn(results);\n        when(results.next()).thenReturn(true).thenReturn(false);\n        when(results.getObject(1)).thenReturn(1L);\n\n        final Long generatedKey = runner.insert(\"INSERT INTO blah(col1, col2) VALUES(?,?)\", new ScalarHandler<>(), \"unit\", \"test\");\n\n        verify(prepStmt, times(1)).executeUpdate();\n        verify(prepStmt, times(1)).close(); // make sure we closed the statement\n        verify(conn, times(1)).close(); // make sure we closed the connection\n\n        Assert.assertEquals(1L, generatedKey.longValue());\n    }\n\n    @Test\n    public void testGoodQuery() throws Exception {\n        callGoodQuery();\n    }\n\n    @Test\n    public void testGoodQueryDefaultConstructor() throws Exception {\n        runner = new QueryRunner();\n        callGoodQuery(conn);\n    }\n\n    @Test\n    public void testGoodQueryPmdTrue() throws Exception {\n        runner = new QueryRunner(true);\n        callGoodQuery(conn);\n    }\n\n    @Test\n    public void testGoodUpdate() throws Exception {\n        callGoodUpdate();\n    }\n\n    @Test\n    public void testGoodUpdateDefaultConstructor() throws Exception {\n        runner = new QueryRunner();\n        callGoodUpdate(conn);\n    }\n\n    @Test\n    public void testGoodUpdatePmdTrue() throws Exception {\n        runner = new QueryRunner(true);\n        callGoodUpdate(conn);\n    }\n\n    @Test\n    public void testNoParamsExecute() throws Exception {\n        callGoodExecute();\n    }\n\n    @Test\n    public void testNoParamsExecuteWithResultSet() throws Exception {\n        callExecuteWithResultSetWithException();\n    }\n\n    @Test\n    public void testNoParamsQuery() throws Exception {\n        callGoodQuery();\n    }\n\n    @Test\n    public void testNoParamsUpdate() throws Exception {\n        callGoodUpdate();\n    }\n\n    @Test(expected = SQLException.class)\n    public void testNullConnectionBatch() throws Exception {\n        final String[][] params = { { \"unit\", \"unit\" }, { \"test\", \"test\" } };\n\n        when(dataSource.getConnection()).thenReturn(null);\n\n        runner.batch(\"select * from blah where ? = ?\", params);\n    }\n\n    @Test(expected = SQLException.class)\n    public void testNullConnectionExecute() throws Exception {\n        when(dataSource.getConnection()).thenReturn(null);\n\n        runner.execute(\"{call my_proc(?, ?)}\", \"unit\", \"test\");\n    }\n\n    @Test(expected = SQLException.class)\n    public void testNullConnectionExecuteWithResultSet() throws Exception {\n        when(dataSource.getConnection()).thenReturn(null);\n\n        runner.execute(\"{call my_proc(?, ?)}\", handler, \"unit\", \"test\");\n    }\n\n    @Test(expected = SQLException.class)\n    public void testNullConnectionQuery() throws Exception {\n        when(dataSource.getConnection()).thenReturn(null);\n\n        runner.query(\"select * from blah where ? = ?\", handler, \"unit\", \"test\");\n    }\n\n    @Test(expected = SQLException.class)\n    public void testNullConnectionUpdate() throws Exception {\n        when(dataSource.getConnection()).thenReturn(null);\n\n        runner.update(\"select * from blah where ? = ?\", \"unit\", \"test\");\n    }\n\n    @Test(expected = SQLException.class)\n    public void testNullHandlerExecute() throws Exception {\n        when(meta.getParameterCount()).thenReturn(2);\n\n        runner.execute(\"{call my_proc(?, ?)}\");\n    }\n\n    @Test(expected = SQLException.class)\n    public void testNullHandlerExecuteWithResultSet() throws Exception {\n        runner.execute(\"{call my_proc(?, ?)}\", (ResultSetHandler) null);\n    }\n\n    @Test(expected = SQLException.class)\n    public void testNullHandlerQuery() throws Exception {\n        runner.query(\"select * from blah where ? = ?\", null);\n    }\n\n    //\n    // Execute with ResultSetHandler\n    //\n\n    @Test(expected = SQLException.class)\n    public void testNullParamsArgBatch() throws Exception {\n        runner.batch(\"select * from blah where ? = ?\", null);\n    }\n\n    @Test\n    public void testNullParamsBatch() throws Exception {\n        final String[][] params = { { null, \"unit\" }, { \"test\", null } };\n\n        callGoodBatch(params);\n    }\n\n    @Test(expected = SQLException.class)\n    public void testNullSqlBatch() throws Exception {\n        final String[][] params = { { \"unit\", \"unit\" }, { \"test\", \"test\" } };\n\n        runner.batch(null, params);\n    }\n\n    @Test(expected = SQLException.class)\n    public void testNullSqlExecute() throws Exception {\n        runner.execute(null);\n    }\n\n    @Test(expected = SQLException.class)\n    public void testNullSqlExecuteWithResultSet() throws Exception {\n        runner.execute(null, handler);\n    }\n\n    @Test(expected = SQLException.class)\n    public void testNullSqlQuery() throws Exception {\n        runner.query(null, handler);\n    }\n\n    @Test(expected = SQLException.class)\n    public void testNullSqlUpdate() throws Exception {\n        runner.update(null);\n    }\n\n    @Test\n    public void testStatementConfiguration() throws Exception {\n        final StatementConfiguration stmtConfig = new StatementConfiguration(1, 2, 3, 4, 5);\n        final QueryRunner queryRunner = new QueryRunner(stmtConfig);\n        queryRunner.prepareStatement(conn, \"select 1\");\n\n        verify(prepStmt).setFetchDirection(eq(1));\n        verify(prepStmt).setFetchSize(eq(2));\n        verify(prepStmt).setMaxFieldSize(eq(3));\n        verify(prepStmt).setMaxRows(eq(4));\n        verify(prepStmt).setQueryTimeout(eq(5));\n    }\n\n    @Test\n    public void testTooFewParamsBatch() throws Exception {\n        final String[][] params = { { \"unit\" }, { \"test\" } };\n\n        callBatchWithException(\"select * from blah where ? = ?\", params);\n    }\n\n    @Test\n    public void testTooFewParamsExecute() throws Exception {\n        callExecuteWithException(\"unit\");\n    }\n\n    @Test\n    public void testTooFewParamsExecuteWithResultSet() throws Exception {\n        callExecuteWithResultSetWithException(\"unit\");\n    }\n\n    @Test\n    public void testTooFewParamsQuery() throws Exception {\n        callQueryWithException(\"unit\");\n    }\n\n    @Test\n    public void testTooFewParamsUpdate() throws Exception {\n        callUpdateWithException(\"unit\");\n    }\n\n    @Test\n    public void testTooManyParamsBatch() throws Exception {\n        final String[][] params = { { \"unit\", \"unit\", \"unit\" }, { \"test\", \"test\", \"test\" } };\n\n        callBatchWithException(\"select * from blah where ? = ?\", params);\n    }\n\n    @Test\n    public void testTooManyParamsExecute() throws Exception {\n        callExecuteWithException(\"unit\", \"test\", \"fail\");\n    }\n\n    @Test\n    public void testTooManyParamsExecuteWithResultSet() throws Exception {\n        callExecuteWithResultSetWithException(\"unit\", \"test\", \"fail\");\n    }\n\n    @Test\n    public void testTooManyParamsQuery() throws Exception {\n        callQueryWithException(\"unit\", \"test\", \"fail\");\n    }\n\n    @Test\n    public void testTooManyParamsUpdate() throws Exception {\n        callUpdateWithException(\"unit\", \"test\", \"fail\");\n    }\n}\n", "file_hash": "895c89b3dae07ba02a2e6aac3a2edf0ef858d09648537bfacab5f4aea521a20b", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils;", "import static org.junit.Assert.fail;", "import static org.mockito.ArgumentMatchers.any;", "import static org.mockito.ArgumentMatchers.eq;", "import static org.mockito.Mockito.doThrow;", "import static org.mockito.Mockito.mock;", "import static org.mockito.Mockito.never;", "import static org.mockito.Mockito.times;", "import static org.mockito.Mockito.verify;", "import static org.mockito.Mockito.when;", "import java.sql.CallableStatement;", "import java.sql.Connection;", "import java.sql.ParameterMetaData;", "import java.sql.PreparedStatement;", "import java.sql.ResultSet;", "import java.sql.ResultSetMetaData;", "import java.sql.SQLException;", "import java.sql.Statement;", "import java.sql.Types;", "import java.util.ArrayList;", "import java.util.List;", "import javax.sql.DataSource;", "import org.apache.commons.dbutils.handlers.ArrayHandler;", "import org.apache.commons.dbutils.handlers.ScalarHandler;", "import org.junit.Assert;", "import org.junit.Before;", "import org.junit.Test;", "import org.junit.runner.RunWith;", "import org.mockito.Mock;", "import org.mockito.invocation.InvocationOnMock;", "import org.mockito.junit.MockitoJUnitRunner;", "import org.mockito.stubbing.Answer;"], "methods": [], "classes": [{"original_string": "@SuppressWarnings(\"boxing\") // test code\n@RunWith(MockitoJUnitRunner.class)\npublic class QueryRunnerTest {\n    //\n    // Random tests\n    //\n    final class MyBean {\n        private int a;\n        private double b;\n        private String c;\n\n        public int getA() {\n            return a;\n        }\n\n        public double getB() {\n            return b;\n        }\n\n        public String getC() {\n            return c;\n        }\n\n        public void setA(final int a) {\n            this.a = a;\n        }\n\n        public void setB(final double b) {\n            this.b = b;\n        }\n\n        public void setC(final String c) {\n            this.c = c;\n        }\n    }\n\n    private QueryRunner runner;\n\n    private ArrayHandler handler;\n\n    @Mock\n    private DataSource dataSource;\n\n    @Mock\n    private Connection conn;\n\n    @Mock\n    private PreparedStatement prepStmt;\n\n    @Mock\n    private Statement stmt;\n\n    @Mock\n    private CallableStatement call;\n\n    @Mock\n    private ParameterMetaData meta;\n\n    @Mock\n    private ResultSet results;\n\n    @Mock\n    private ResultSetMetaData resultsMeta;\n\n    //\n    // Batch test cases\n    //\n\n    // helper method for calling batch when an exception is expected\n    private void callBatchWithException(final String sql, final Object[][] params) throws Exception {\n        when(meta.getParameterCount()).thenReturn(2);\n        boolean caught = false;\n\n        try {\n            runner.batch(sql, params);\n\n            verify(prepStmt, times(1)).getParameterMetaData();\n            verify(prepStmt, times(2)).addBatch();\n            verify(prepStmt, times(1)).executeBatch();\n            verify(prepStmt, times(1)).close();    // make sure the statement is closed\n            verify(conn, times(1)).close();    // make sure the connection is closed\n        } catch (final SQLException e) {\n            System.out.println(\"[TEST] The following exception is expected:\");\n            System.out.println(e);\n            caught = true;\n        }\n\n        if (!caught) {\n            fail(\"Exception never thrown, but expected\");\n        }\n    }\n\n    // helper method for calling execute when an exception is expected\n    private void callExecuteWithException(final Object... params) throws Exception {\n        boolean caught = false;\n\n        try {\n            when(meta.getParameterCount()).thenReturn(2);\n            runner.query(\"{call my_proc(?, ?)}\", handler, params);\n\n        } catch (final SQLException e) {\n            caught = true;\n        }\n\n        if (!caught) {\n            fail(\"Exception never thrown, but expected\");\n        }\n    }\n\n    // helper method for calling execute when an exception is expected\n    private void callExecuteWithResultSetWithException(final Object... params) throws Exception {\n        boolean caught = false;\n\n        try {\n            when(meta.getParameterCount()).thenReturn(2);\n            runner.execute(\"{call my_proc(?, ?)}\", handler, params);\n\n        } catch (final SQLException e) {\n            caught = true;\n        }\n\n        if (!caught) {\n            fail(\"Exception never thrown, but expected\");\n        }\n    }\n\n    private void callGoodBatch(final Connection conn, final Object[][] params) throws Exception {\n        when(meta.getParameterCount()).thenReturn(2);\n        runner.batch(conn, \"select * from blah where ? = ?\", params);\n\n        verify(prepStmt, times(1)).getParameterMetaData();\n        verify(prepStmt, times(2)).addBatch();\n        verify(prepStmt, times(1)).executeBatch();\n        // make sure we closed the statement\n        verify(prepStmt, times(1)).close();\n        // make sure we do not close the connection, since QueryRunner.batch(Connection, String, Object[][]) does not close connections\n        verify(conn, times(0)).close();\n    }\n\n    private void callGoodBatch(final Object[][] params) throws Exception {\n        callGoodBatch(params, true);\n    }\n\n    private void callGoodBatch(final Object[][] params, final boolean pmdCheck) throws Exception {\n        when(meta.getParameterCount()).thenReturn(2);\n        runner.batch(\"select * from blah where ? = ?\", params);\n\n        verify(prepStmt, times(pmdCheck ? 1 : 0)).getParameterMetaData();\n        verify(prepStmt, times(2)).addBatch();\n        verify(prepStmt, times(1)).executeBatch();\n        verify(prepStmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(1)).close();    // make sure we closed the connection\n    }\n\n    private void callGoodExecute() throws Exception {\n        when(call.execute()).thenReturn(false);\n        when(call.getUpdateCount()).thenReturn(3);\n\n        when(meta.getParameterCount()).thenReturn(2);\n        int result = runner.execute(\"{call my_proc(?, ?)}\", \"unit\", \"test\");\n\n        Assert.assertEquals(3, result);\n\n        verify(call, times(1)).execute();\n        verify(call, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(1)).close();    // make sure we do not close the connection\n\n        // call the other variation of query\n        when(meta.getParameterCount()).thenReturn(0);\n        result = runner.execute(\"{call my_proc()}\");\n\n        Assert.assertEquals(3, result);\n\n        verify(call, times(2)).execute();\n        verify(call, times(2)).close();    // make sure we closed the statement\n        verify(conn, times(2)).close();    // make sure we do not close the connection\n\n        // Test single OUT parameter\n        when(meta.getParameterCount()).thenReturn(1);\n        when(call.getObject(1)).thenReturn(42);\n        final OutParameter<Integer> intParam =\n            new OutParameter<>(Types.INTEGER, Integer.class);\n        result = runner.execute(\"{?= call my_proc()}\", intParam);\n\n        Assert.assertEquals(42, intParam.getValue().intValue());\n        Assert.assertEquals(3, result);\n\n        verify(call, times(3)).execute();\n        verify(call, times(3)).close();    // make sure we closed the statement\n        verify(conn, times(3)).close();    // make sure we do not close the connection\n\n        // Test OUT parameters with IN parameters\n        when(meta.getParameterCount()).thenReturn(3);\n        when(call.getObject(1)).thenReturn(4242);\n        intParam.setValue(null);\n        result = runner.execute(\"{?= call my_proc(?, ?)}\", intParam, \"unit\", \"test\");\n\n        Assert.assertEquals(4242, intParam.getValue().intValue());\n        Assert.assertEquals(3, result);\n\n        verify(call, times(4)).execute();\n        verify(call, times(4)).close();    // make sure we closed the statement\n        verify(conn, times(4)).close();    // make sure we do not close the connection\n\n        // Test INOUT parameters\n        when(meta.getParameterCount()).thenReturn(3);\n        when(call.getObject(1)).thenReturn(24);\n        when(call.getObject(3)).thenReturn(\"out\");\n        intParam.setValue(null);\n        final OutParameter<String> stringParam =\n            new OutParameter<>(Types.VARCHAR, String.class, \"in\");\n        result = runner.execute(\"{?= call my_proc(?, ?)}\", intParam, \"test\", stringParam);\n\n        Assert.assertEquals(24, intParam.getValue().intValue());\n        Assert.assertEquals(\"out\", stringParam.getValue());\n        Assert.assertEquals(3, result);\n\n        verify(call, times(5)).execute();\n        verify(call, times(5)).close();    // make sure we closed the statement\n        verify(conn, times(5)).close();    // make sure we do not close the connection\n    }\n\n    //\n    // Execute tests\n    //\n    private void callGoodExecute(final Connection conn) throws Exception {\n        when(call.execute()).thenReturn(false);\n        when(call.getUpdateCount()).thenReturn(3);\n\n        when(meta.getParameterCount()).thenReturn(2);\n        int result = runner.execute(conn, \"{call my_proc(?, ?)}\", \"unit\", \"test\");\n\n        Assert.assertEquals(3, result);\n\n        verify(call, times(1)).execute();\n        verify(call, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we do not close the connection\n\n        // call the other variation of query\n        when(meta.getParameterCount()).thenReturn(0);\n        result = runner.execute(conn, \"{call my_proc()}\");\n\n        Assert.assertEquals(3, result);\n\n        verify(call, times(2)).execute();\n        verify(call, times(2)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we do not close the connection\n\n        // Test single OUT parameter\n        when(meta.getParameterCount()).thenReturn(1);\n        when(call.getObject(1)).thenReturn(42);\n        final OutParameter<Integer> intParam =\n            new OutParameter<>(Types.INTEGER, Integer.class);\n        result = runner.execute(conn, \"{?= call my_proc()}\", intParam);\n\n        Assert.assertEquals(42, intParam.getValue().intValue());\n        Assert.assertEquals(3, result);\n\n        verify(call, times(3)).execute();\n        verify(call, times(3)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we do not close the connection\n\n        // Test OUT parameters with IN parameters\n        when(meta.getParameterCount()).thenReturn(3);\n        when(call.getObject(1)).thenReturn(4242);\n        intParam.setValue(null);\n        result = runner.execute(conn, \"{?= call my_proc(?, ?)}\", intParam, \"unit\", \"test\");\n\n        Assert.assertEquals(4242, intParam.getValue().intValue());\n        Assert.assertEquals(3, result);\n\n        verify(call, times(4)).execute();\n        verify(call, times(4)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we do not close the connection\n\n        // Test INOUT parameters\n        when(meta.getParameterCount()).thenReturn(3);\n        when(call.getObject(1)).thenReturn(24);\n        when(call.getObject(3)).thenReturn(\"out\");\n        intParam.setValue(null);\n        final OutParameter<String> stringParam =\n            new OutParameter<>(Types.VARCHAR, String.class, \"in\");\n        result = runner.execute(conn, \"{?= call my_proc(?, ?)}\", intParam, \"test\", stringParam);\n\n        Assert.assertEquals(24, intParam.getValue().intValue());\n        Assert.assertEquals(\"out\", stringParam.getValue());\n        Assert.assertEquals(3, result);\n\n        verify(call, times(5)).execute();\n        verify(call, times(5)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we do not close the connection\n    }\n\n    private void callGoodExecuteWithResultSet() throws Exception {\n        when(call.execute()).thenReturn(true);\n\n        when(meta.getParameterCount()).thenReturn(2);\n        runner.execute(\"{call my_proc(?, ?)}\", handler, \"unit\", \"test\");\n\n        verify(call, times(1)).execute();\n        verify(results, times(1)).close();\n        verify(call, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(1)).close();    // make sure we do not close the connection\n\n        // call the other variation of query\n        when(meta.getParameterCount()).thenReturn(0);\n        runner.execute(\"{call my_proc()}\", handler);\n\n        verify(call, times(2)).execute();\n        verify(results, times(2)).close();\n        verify(call, times(2)).close();    // make sure we closed the statement\n        verify(conn, times(2)).close();    // make sure we do not close the connection\n\n        // Test single OUT parameter\n        when(meta.getParameterCount()).thenReturn(1);\n        when(call.getObject(1)).thenReturn(42);\n        final OutParameter<Integer> intParam =\n            new OutParameter<>(Types.INTEGER, Integer.class);\n        runner.execute(\"{?= call my_proc()}\", handler, intParam);\n\n        Assert.assertEquals(42, intParam.getValue().intValue());\n\n        verify(call, times(3)).execute();\n        verify(results, times(3)).close();\n        verify(call, times(3)).close();    // make sure we closed the statement\n        verify(conn, times(3)).close();    // make sure we do not close the connection\n\n        // Test OUT parameters with IN parameters\n        when(meta.getParameterCount()).thenReturn(3);\n        when(call.getObject(1)).thenReturn(4242);\n        intParam.setValue(null);\n        runner.execute(\"{?= call my_proc(?, ?)}\", handler, intParam, \"unit\", \"test\");\n\n        Assert.assertEquals(4242, intParam.getValue().intValue());\n\n        verify(call, times(4)).execute();\n        verify(results, times(4)).close();\n        verify(call, times(4)).close();    // make sure we closed the statement\n        verify(conn, times(4)).close();    // make sure we do not close the connection\n\n        // Test INOUT parameters\n        when(meta.getParameterCount()).thenReturn(3);\n        when(call.getObject(1)).thenReturn(24);\n        when(call.getObject(3)).thenReturn(\"out\");\n        intParam.setValue(null);\n        final OutParameter<String> stringParam =\n            new OutParameter<>(Types.VARCHAR, String.class, \"in\");\n        runner.execute(\"{?= call my_proc(?, ?)}\", handler, intParam, \"test\", stringParam);\n\n        Assert.assertEquals(24, intParam.getValue().intValue());\n        Assert.assertEquals(\"out\", stringParam.getValue());\n\n        verify(call, times(5)).execute();\n        verify(results, times(5)).close();\n        verify(call, times(5)).close();    // make sure we closed the statement\n        verify(conn, times(5)).close();    // make sure we do not close the connection\n    }\n\n    private void callGoodExecuteWithResultSet(final Connection conn) throws Exception {\n        when(call.execute()).thenReturn(true);\n\n        when(meta.getParameterCount()).thenReturn(2);\n        runner.execute(conn, \"{call my_proc(?, ?)}\", handler, \"unit\", \"test\");\n\n        verify(call, times(1)).execute();\n        verify(results, times(1)).close();\n        verify(call, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we do not close the connection\n\n        // call the other variation of query\n        when(meta.getParameterCount()).thenReturn(0);\n        runner.execute(conn, \"{call my_proc()}\", handler);\n\n        verify(call, times(2)).execute();\n        verify(results, times(2)).close();\n        verify(call, times(2)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we do not close the connection\n\n        // Test single OUT parameter\n        when(meta.getParameterCount()).thenReturn(1);\n        when(call.getObject(1)).thenReturn(42);\n        final OutParameter<Integer> intParam =\n            new OutParameter<>(Types.INTEGER, Integer.class);\n        runner.execute(conn, \"{?= call my_proc()}\", handler, intParam);\n\n        Assert.assertEquals(42, intParam.getValue().intValue());\n\n        verify(call, times(3)).execute();\n        verify(results, times(3)).close();\n        verify(call, times(3)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we do not close the connection\n\n        // Test OUT parameters with IN parameters\n        when(meta.getParameterCount()).thenReturn(3);\n        when(call.getObject(1)).thenReturn(4242);\n        intParam.setValue(null);\n        runner.execute(conn, \"{?= call my_proc(?, ?)}\", handler, intParam, \"unit\", \"test\");\n\n        Assert.assertEquals(4242, intParam.getValue().intValue());\n\n        verify(call, times(4)).execute();\n        verify(results, times(4)).close();\n        verify(call, times(4)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we do not close the connection\n\n        // Test INOUT parameters\n        when(meta.getParameterCount()).thenReturn(3);\n        when(call.getObject(1)).thenReturn(24);\n        when(call.getObject(3)).thenReturn(\"out\");\n        intParam.setValue(null);\n        final OutParameter<String> stringParam =\n            new OutParameter<>(Types.VARCHAR, String.class, \"in\");\n        runner.execute(conn, \"{?= call my_proc(?, ?)}\", handler, intParam, \"test\", stringParam);\n\n        Assert.assertEquals(24, intParam.getValue().intValue());\n        Assert.assertEquals(\"out\", stringParam.getValue());\n\n        verify(call, times(5)).execute();\n        verify(results, times(5)).close();\n        verify(call, times(5)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we do not close the connection\n    }\n\n    private void callGoodQuery() throws Exception {\n        when(meta.getParameterCount()).thenReturn(2);\n        String sql = \"select * from blah where ? = ?\";\n        runner.query(sql, handler, \"unit\", \"test\");\n\n        verify(prepStmt, times(1)).executeQuery();\n        verify(results, times(1)).close();\n        verify(prepStmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(1)).close();    // make sure we closed the connection\n\n        // call the other variation of query\n        sql = \"select * from blah\";\n        runner.query(sql, handler);\n\n        verify(stmt, times(1)).executeQuery(sql);\n        verify(results, times(2)).close();\n        verify(stmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(2)).close();    // make sure we closed the connection\n    }\n\n    //\n    // Query test cases\n    //\n    private void callGoodQuery(final Connection conn) throws Exception {\n        when(meta.getParameterCount()).thenReturn(2);\n        String sql = \"select * from blah where ? = ?\";\n        runner.query(conn, sql, handler, \"unit\", \"test\");\n\n        verify(prepStmt, times(1)).executeQuery();\n        verify(results, times(1)).close();\n        verify(prepStmt, times(1)).close();    // make sure we closed the statement\n        // make sure we do not close the connection, since QueryRunner.query(Connection, String, ResultSetHandler<T>, Object...) does not close connections\n        verify(conn, times(0)).close();\n        // call the other variation of query\n        sql = \"select * from blah\";\n        runner.query(conn, sql, handler);\n\n        verify(stmt, times(1)).executeQuery(sql);\n        verify(results, times(2)).close();\n        verify(stmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we do not close the connection, see above\n    }\n\n    private void callGoodUpdate() throws Exception {\n        when(meta.getParameterCount()).thenReturn(2);\n        String sql = \"update blah set ? = ?\";\n        runner.update(sql, \"unit\", \"test\");\n\n        verify(prepStmt, times(1)).executeUpdate();\n        verify(prepStmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(1)).close();    // make sure we closed the connection\n\n        // call the other variation\n        when(meta.getParameterCount()).thenReturn(0);\n        sql = \"update blah set unit = test\";\n        runner.update(sql);\n\n        verify(stmt, times(1)).executeUpdate(sql);\n        verify(stmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(2)).close();    // make sure we closed the connection\n\n        // call the other variation\n        when(meta.getParameterCount()).thenReturn(1);\n        sql = \"update blah set unit = ?\";\n        runner.update(sql, \"test\");\n\n        verify(prepStmt, times(2)).executeUpdate();\n        verify(prepStmt, times(2)).close();    // make sure we closed the statement\n        verify(conn, times(3)).close();    // make sure we closed the connection\n    }\n\n    //\n    // Update test cases\n    //\n    private void callGoodUpdate(final Connection conn) throws Exception {\n        when(meta.getParameterCount()).thenReturn(2);\n        runner.update(conn, \"update blah set ? = ?\", \"unit\", \"test\");\n\n        verify(prepStmt, times(1)).executeUpdate();\n        verify(prepStmt, times(1)).close();    // make sure we closed the statement\n        // make sure we do not close the connection, since QueryRunner.update(Connection, String, Object...) does not close connections\n        verify(conn, times(0)).close();\n        // call the other variation\n        when(meta.getParameterCount()).thenReturn(0);\n        final String sql = \"update blah set unit = test\";\n        runner.update(conn, sql);\n\n        verify(stmt, times(1)).executeUpdate(sql);\n        verify(stmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we do not close the connection, see above\n\n        // call the other variation\n        when(meta.getParameterCount()).thenReturn(1);\n        runner.update(conn, \"update blah set unit = ?\", \"test\");\n\n        verify(prepStmt, times(2)).executeUpdate();\n        verify(prepStmt, times(2)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we do not close the connection, see above\n    }\n\n    /** Helper method for calling batch when an exception is expected. */\n    private void callQueryWithException(final Object... params) throws Exception {\n        boolean caught = false;\n\n        try {\n            when(meta.getParameterCount()).thenReturn(2);\n            final String sql = \"select * from blah where ? = ?\";\n            runner.query(sql, handler, params);\n\n            verify(prepStmt, never()).close(); // make sure the statement is still open\n            verify(prepStmt, times(1)).executeQuery();\n            verify(prepStmt, times(1)).close(); // make sure we closed the statement\n            verify(results, times(1)).close();\n            verify(conn, times(1)).close(); // make sure we closed the connection\n        } catch (final SQLException e) {\n            caught = true;\n        }\n\n        if (!caught) {\n            fail(\"Exception never thrown, but expected\");\n        }\n    }\n\n    // helper method for calling batch when an exception is expected\n    private void callUpdateWithException(final Object... params) throws Exception {\n        boolean caught = false;\n\n        try {\n            when(meta.getParameterCount()).thenReturn(2);\n            final String sql = \"select * from blah where ? = ?\";\n            runner.update(sql, params);\n\n            verify(prepStmt, times(1)).executeUpdate();\n            verify(prepStmt, times(1)).close(); // make sure we closed the statement\n            verify(conn, times(1)).close(); // make sure we closed the connection\n        } catch (final SQLException e) {\n            caught = true;\n        }\n\n        if (!caught) {\n            fail(\"Exception never thrown, but expected\");\n        }\n    }\n\n    @Before\n    public void setUp() throws Exception {\n        when(dataSource.getConnection()).thenReturn(conn);\n\n        when(conn.prepareStatement(any(String.class))).thenReturn(prepStmt);\n        when(prepStmt.getParameterMetaData()).thenReturn(meta);\n        when(prepStmt.executeQuery()).thenReturn(results);\n\n        when(conn.createStatement()).thenReturn(stmt);\n        when(stmt.executeQuery(any(String.class))).thenReturn(results);\n\n        when(conn.prepareCall(any(String.class))).thenReturn(call);\n        when(call.getParameterMetaData()).thenReturn(meta);\n        when(call.getResultSet()).thenReturn(results);\n        when(call.getMoreResults()).thenReturn(false);\n\n        when(results.next()).thenReturn(false);\n\n         handler = new ArrayHandler();\n         runner = new QueryRunner(dataSource);\n    }\n\n    @Test\n    public void testAddBatchExceptionOnAdd() throws Exception {\n        final String[][] params = { { \"unit\", \"unit\" }, { \"test\", \"test\" } };\n\n        doThrow(new SQLException()).when(prepStmt).addBatch();\n\n        callBatchWithException(\"select * from blah where ? = ?\", params);\n    }\n\n    @Test(expected = SQLException.class)\n    public void testBadPrepareConnection() throws Exception {\n        runner = new QueryRunner();\n        runner.update(\"update blah set unit = test\");\n    }\n\n    @Test\n    public void testExecuteBatchExceptionOnExec() throws Exception {\n        final String[][] params = { { \"unit\", \"unit\" }, { \"test\", \"test\" } };\n\n        doThrow(new SQLException()).when(prepStmt).executeBatch();\n\n        callBatchWithException(\"select * from blah where ? = ?\", params);\n    }\n\n    @Test\n    public void testExecuteException() throws Exception {\n        callExecuteWithException(handler, \"unit\", \"test\");\n    }\n\n    @Test\n    public void testExecuteQueryException() throws Exception {\n        callQueryWithException(handler, \"unit\", \"test\");\n    }\n\n    @Test\n    public void testExecuteUpdateException() throws Exception {\n        doThrow(new SQLException()).when(prepStmt).executeUpdate();\n\n        callUpdateWithException(\"unit\", \"test\");\n    }\n\n    @Test\n    public void testExecuteWithMultipleResultSets() throws Exception {\n        when(call.execute()).thenReturn(true);\n        when(call.getMoreResults()).thenAnswer(new Answer<Boolean>() {\n            private int count = 1;\n            @Override\n            public Boolean answer(final InvocationOnMock invocation) {\n                return ++count <= 3;\n            }\n        });\n        when(meta.getParameterCount()).thenReturn(0);\n        final List<Object[]> objects = runner.execute(\"{call my_proc()}\", handler);\n\n        Assert.assertEquals(3, objects.size());\n        verify(call, times(1)).execute();\n        verify(results, times(3)).close();\n        verify(call, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(1)).close();    // make sure we close the connection\n\n    }\n\n    @Test\n    public void testExecuteWithResultSetException() throws Exception {\n        callExecuteWithResultSetWithException(handler, \"unit\", \"test\");\n    }\n\n    @Test\n    public void testFillStatementWithBean() throws Exception {\n        final MyBean bean = new MyBean();\n        when(meta.getParameterCount()).thenReturn(3);\n        runner.fillStatementWithBean(prepStmt, bean, \"a\", \"b\", \"c\");\n    }\n\n    @Test(expected = NullPointerException.class)\n    public void testFillStatementWithBeanNullNames() throws Exception {\n        final MyBean bean = new MyBean();\n        runner.fillStatementWithBean(prepStmt, bean, \"a\", \"b\", null);\n    }\n\n    @Test\n    public void testGoodBatch() throws Exception {\n        final String[][] params = { { \"unit\", \"unit\" }, { \"test\", \"test\" } };\n\n        callGoodBatch(params);\n    }\n\n    @Test\n    public void testGoodBatchDefaultConstructor() throws Exception {\n        runner = new QueryRunner();\n        final String[][] params = { { \"unit\", \"unit\" }, { \"test\", \"test\" } };\n\n        callGoodBatch(conn, params);\n    }\n\n    @Test\n    public void testGoodBatchInsert() throws Exception {\n        results = mock(ResultSet.class);\n        resultsMeta = mock(ResultSetMetaData.class);\n\n        when(meta.getParameterCount()).thenReturn(2);\n        when(conn.prepareStatement(any(String.class), eq(Statement.RETURN_GENERATED_KEYS))).thenReturn(prepStmt);\n        when(prepStmt.getGeneratedKeys()).thenReturn(results);\n        when(results.next()).thenReturn(true).thenReturn(true).thenReturn(false);\n\n        final ResultSetHandler<List<Object>> handler = rs -> {\n            final List<Object> objects = new ArrayList<>();\n            while (rs.next()) {\n                objects.add(new Object());\n            }\n            return objects;\n        };\n\n        final Object[][] params = new Object[2][2];\n        params[0][0] = \"Test\";\n        params[0][1] = \"Blah\";\n        params[1][0] = \"Test2\";\n        params[1][1] = \"Blah2\";\n\n        final List<Object> generatedKeys = runner.insertBatch(\"INSERT INTO blah(col1, col2) VALUES(?,?)\", handler, params);\n\n        verify(prepStmt, times(2)).addBatch();\n        verify(prepStmt, times(1)).executeBatch();\n        verify(prepStmt, times(1)).close(); // make sure we closed the statement\n        verify(conn, times(1)).close(); // make sure we closed the connection\n\n        Assert.assertEquals(2, generatedKeys.size());\n    }\n\n    @Test\n    public void testGoodBatchPmdTrue() throws Exception {\n        runner = new QueryRunner(dataSource, true);\n        final String[][] params = { { \"unit\", \"unit\" }, { \"test\", \"test\" } };\n\n        callGoodBatch(params, false);\n    }\n\n    @Test\n    public void testGoodExecute() throws Exception {\n        callGoodExecute();\n    }\n\n    @Test\n    public void testGoodExecuteDefaultConstructor() throws Exception {\n        runner = new QueryRunner();\n        callGoodExecute(conn);\n    }\n\n    @Test\n    public void testGoodExecutePmdTrue() throws Exception {\n        runner = new QueryRunner(true);\n        callGoodExecute(conn);\n    }\n\n    @Test\n    public void testGoodExecuteWithResultSet() throws Exception {\n        callGoodExecuteWithResultSet();\n    }\n\n    @Test\n    public void testGoodExecuteWithResultSetDefaultConstructor() throws Exception {\n        runner = new QueryRunner();\n        callGoodExecuteWithResultSet(conn);\n    }\n\n    @Test\n    public void testGoodExecuteWithResultSetPmdTrue() throws Exception {\n        runner = new QueryRunner(true);\n        callGoodExecuteWithResultSet(conn);\n    }\n\n    @Test\n    public void testGoodInsert() throws Exception {\n        results = mock(ResultSet.class);\n\n        when(meta.getParameterCount()).thenReturn(2);\n        when(conn.prepareStatement(any(String.class), eq(Statement.RETURN_GENERATED_KEYS))).thenReturn(prepStmt);\n        when(prepStmt.getGeneratedKeys()).thenReturn(results);\n        when(results.next()).thenReturn(true).thenReturn(false);\n        when(results.getObject(1)).thenReturn(1L);\n\n        final Long generatedKey = runner.insert(\"INSERT INTO blah(col1, col2) VALUES(?,?)\", new ScalarHandler<>(), \"unit\", \"test\");\n\n        verify(prepStmt, times(1)).executeUpdate();\n        verify(prepStmt, times(1)).close(); // make sure we closed the statement\n        verify(conn, times(1)).close(); // make sure we closed the connection\n\n        Assert.assertEquals(1L, generatedKey.longValue());\n    }\n\n    @Test\n    public void testGoodQuery() throws Exception {\n        callGoodQuery();\n    }\n\n    @Test\n    public void testGoodQueryDefaultConstructor() throws Exception {\n        runner = new QueryRunner();\n        callGoodQuery(conn);\n    }\n\n    @Test\n    public void testGoodQueryPmdTrue() throws Exception {\n        runner = new QueryRunner(true);\n        callGoodQuery(conn);\n    }\n\n    @Test\n    public void testGoodUpdate() throws Exception {\n        callGoodUpdate();\n    }\n\n    @Test\n    public void testGoodUpdateDefaultConstructor() throws Exception {\n        runner = new QueryRunner();\n        callGoodUpdate(conn);\n    }\n\n    @Test\n    public void testGoodUpdatePmdTrue() throws Exception {\n        runner = new QueryRunner(true);\n        callGoodUpdate(conn);\n    }\n\n    @Test\n    public void testNoParamsExecute() throws Exception {\n        callGoodExecute();\n    }\n\n    @Test\n    public void testNoParamsExecuteWithResultSet() throws Exception {\n        callExecuteWithResultSetWithException();\n    }\n\n    @Test\n    public void testNoParamsQuery() throws Exception {\n        callGoodQuery();\n    }\n\n    @Test\n    public void testNoParamsUpdate() throws Exception {\n        callGoodUpdate();\n    }\n\n    @Test(expected = SQLException.class)\n    public void testNullConnectionBatch() throws Exception {\n        final String[][] params = { { \"unit\", \"unit\" }, { \"test\", \"test\" } };\n\n        when(dataSource.getConnection()).thenReturn(null);\n\n        runner.batch(\"select * from blah where ? = ?\", params);\n    }\n\n    @Test(expected = SQLException.class)\n    public void testNullConnectionExecute() throws Exception {\n        when(dataSource.getConnection()).thenReturn(null);\n\n        runner.execute(\"{call my_proc(?, ?)}\", \"unit\", \"test\");\n    }\n\n    @Test(expected = SQLException.class)\n    public void testNullConnectionExecuteWithResultSet() throws Exception {\n        when(dataSource.getConnection()).thenReturn(null);\n\n        runner.execute(\"{call my_proc(?, ?)}\", handler, \"unit\", \"test\");\n    }\n\n    @Test(expected = SQLException.class)\n    public void testNullConnectionQuery() throws Exception {\n        when(dataSource.getConnection()).thenReturn(null);\n\n        runner.query(\"select * from blah where ? = ?\", handler, \"unit\", \"test\");\n    }\n\n    @Test(expected = SQLException.class)\n    public void testNullConnectionUpdate() throws Exception {\n        when(dataSource.getConnection()).thenReturn(null);\n\n        runner.update(\"select * from blah where ? = ?\", \"unit\", \"test\");\n    }\n\n    @Test(expected = SQLException.class)\n    public void testNullHandlerExecute() throws Exception {\n        when(meta.getParameterCount()).thenReturn(2);\n\n        runner.execute(\"{call my_proc(?, ?)}\");\n    }\n\n    @Test(expected = SQLException.class)\n    public void testNullHandlerExecuteWithResultSet() throws Exception {\n        runner.execute(\"{call my_proc(?, ?)}\", (ResultSetHandler) null);\n    }\n\n    @Test(expected = SQLException.class)\n    public void testNullHandlerQuery() throws Exception {\n        runner.query(\"select * from blah where ? = ?\", null);\n    }\n\n    //\n    // Execute with ResultSetHandler\n    //\n\n    @Test(expected = SQLException.class)\n    public void testNullParamsArgBatch() throws Exception {\n        runner.batch(\"select * from blah where ? = ?\", null);\n    }\n\n    @Test\n    public void testNullParamsBatch() throws Exception {\n        final String[][] params = { { null, \"unit\" }, { \"test\", null } };\n\n        callGoodBatch(params);\n    }\n\n    @Test(expected = SQLException.class)\n    public void testNullSqlBatch() throws Exception {\n        final String[][] params = { { \"unit\", \"unit\" }, { \"test\", \"test\" } };\n\n        runner.batch(null, params);\n    }\n\n    @Test(expected = SQLException.class)\n    public void testNullSqlExecute() throws Exception {\n        runner.execute(null);\n    }\n\n    @Test(expected = SQLException.class)\n    public void testNullSqlExecuteWithResultSet() throws Exception {\n        runner.execute(null, handler);\n    }\n\n    @Test(expected = SQLException.class)\n    public void testNullSqlQuery() throws Exception {\n        runner.query(null, handler);\n    }\n\n    @Test(expected = SQLException.class)\n    public void testNullSqlUpdate() throws Exception {\n        runner.update(null);\n    }\n\n    @Test\n    public void testStatementConfiguration() throws Exception {\n        final StatementConfiguration stmtConfig = new StatementConfiguration(1, 2, 3, 4, 5);\n        final QueryRunner queryRunner = new QueryRunner(stmtConfig);\n        queryRunner.prepareStatement(conn, \"select 1\");\n\n        verify(prepStmt).setFetchDirection(eq(1));\n        verify(prepStmt).setFetchSize(eq(2));\n        verify(prepStmt).setMaxFieldSize(eq(3));\n        verify(prepStmt).setMaxRows(eq(4));\n        verify(prepStmt).setQueryTimeout(eq(5));\n    }\n\n    @Test\n    public void testTooFewParamsBatch() throws Exception {\n        final String[][] params = { { \"unit\" }, { \"test\" } };\n\n        callBatchWithException(\"select * from blah where ? = ?\", params);\n    }\n\n    @Test\n    public void testTooFewParamsExecute() throws Exception {\n        callExecuteWithException(\"unit\");\n    }\n\n    @Test\n    public void testTooFewParamsExecuteWithResultSet() throws Exception {\n        callExecuteWithResultSetWithException(\"unit\");\n    }\n\n    @Test\n    public void testTooFewParamsQuery() throws Exception {\n        callQueryWithException(\"unit\");\n    }\n\n    @Test\n    public void testTooFewParamsUpdate() throws Exception {\n        callUpdateWithException(\"unit\");\n    }\n\n    @Test\n    public void testTooManyParamsBatch() throws Exception {\n        final String[][] params = { { \"unit\", \"unit\", \"unit\" }, { \"test\", \"test\", \"test\" } };\n\n        callBatchWithException(\"select * from blah where ? = ?\", params);\n    }\n\n    @Test\n    public void testTooManyParamsExecute() throws Exception {\n        callExecuteWithException(\"unit\", \"test\", \"fail\");\n    }\n\n    @Test\n    public void testTooManyParamsExecuteWithResultSet() throws Exception {\n        callExecuteWithResultSetWithException(\"unit\", \"test\", \"fail\");\n    }\n\n    @Test\n    public void testTooManyParamsQuery() throws Exception {\n        callQueryWithException(\"unit\", \"test\", \"fail\");\n    }\n\n    @Test\n    public void testTooManyParamsUpdate() throws Exception {\n        callUpdateWithException(\"unit\", \"test\", \"fail\");\n    }\n}", "definition": "@SuppressWarnings(\"boxing\") // test code\n@RunWith(MockitoJUnitRunner.class)\npublic class QueryRunnerTest", "class_docstring": "", "name": "QueryRunnerTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "@SuppressWarnings(\"boxing\") // test code\n@RunWith(MockitoJUnitRunner.class)\npublic", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"boxing\")", "@RunWith(MockitoJUnitRunner.class)", "public"], "comments": ["// test code"], "fields": [{"attribute_expression": "private QueryRunner runner;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "QueryRunner", "name": "runner", "syntax_pass": true}, {"attribute_expression": "private ArrayHandler handler;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ArrayHandler", "name": "handler", "syntax_pass": true}, {"attribute_expression": "@Mock\n    private DataSource dataSource;", "docstring": "", "modifiers": "@Mock\n    private", "marker_annotations": ["@Mock"], "non_marker_annotations": ["private"], "comments": [], "type": "DataSource", "name": "dataSource", "syntax_pass": true}, {"attribute_expression": "@Mock\n    private Connection conn;", "docstring": "", "modifiers": "@Mock\n    private", "marker_annotations": ["@Mock"], "non_marker_annotations": ["private"], "comments": [], "type": "Connection", "name": "conn", "syntax_pass": true}, {"attribute_expression": "@Mock\n    private PreparedStatement prepStmt;", "docstring": "", "modifiers": "@Mock\n    private", "marker_annotations": ["@Mock"], "non_marker_annotations": ["private"], "comments": [], "type": "PreparedStatement", "name": "prepStmt", "syntax_pass": true}, {"attribute_expression": "@Mock\n    private Statement stmt;", "docstring": "", "modifiers": "@Mock\n    private", "marker_annotations": ["@Mock"], "non_marker_annotations": ["private"], "comments": [], "type": "Statement", "name": "stmt", "syntax_pass": true}, {"attribute_expression": "@Mock\n    private CallableStatement call;", "docstring": "", "modifiers": "@Mock\n    private", "marker_annotations": ["@Mock"], "non_marker_annotations": ["private"], "comments": [], "type": "CallableStatement", "name": "call", "syntax_pass": true}, {"attribute_expression": "@Mock\n    private ParameterMetaData meta;", "docstring": "", "modifiers": "@Mock\n    private", "marker_annotations": ["@Mock"], "non_marker_annotations": ["private"], "comments": [], "type": "ParameterMetaData", "name": "meta", "syntax_pass": true}, {"attribute_expression": "@Mock\n    private ResultSet results;", "docstring": "", "modifiers": "@Mock\n    private", "marker_annotations": ["@Mock"], "non_marker_annotations": ["private"], "comments": [], "type": "ResultSet", "name": "results", "syntax_pass": true}, {"attribute_expression": "@Mock\n    private ResultSetMetaData resultsMeta;", "docstring": "", "modifiers": "@Mock\n    private", "marker_annotations": ["@Mock"], "non_marker_annotations": ["private"], "comments": [], "type": "ResultSetMetaData", "name": "resultsMeta", "syntax_pass": true}], "classes": [{"original_string": "    final class MyBean {\n        private int a;\n        private double b;\n        private String c;\n\n        public int getA() {\n            return a;\n        }\n\n        public double getB() {\n            return b;\n        }\n\n        public String getC() {\n            return c;\n        }\n\n        public void setA(final int a) {\n            this.a = a;\n        }\n\n        public void setB(final double b) {\n            this.b = b;\n        }\n\n        public void setC(final String c) {\n            this.c = c;\n        }\n    }", "definition": "    final class MyBean", "class_docstring": "", "name": "MyBean", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "fields": [{"attribute_expression": "private int a;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "a", "syntax_pass": true}, {"attribute_expression": "private double b;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "double", "name": "b", "syntax_pass": true}, {"attribute_expression": "private String c;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "c", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public int getA() {\n            return a;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "getA", "params": [], "body": "                          {\n            return a;\n        }", "signature": "public int getA()"}, {"syntax_pass": true, "original_string": "        public double getB() {\n            return b;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "getB", "params": [], "body": "                             {\n            return b;\n        }", "signature": "public double getB()"}, {"syntax_pass": true, "original_string": "        public String getC() {\n            return c;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getC", "params": [], "body": "                             {\n            return c;\n        }", "signature": "public String getC()"}, {"syntax_pass": true, "original_string": "        public void setA(final int a) {\n            this.a = a;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setA", "params": [{"name": "a", "type": "int"}], "body": "                                      {\n            this.a = a;\n        }", "signature": "public void setA(final int a)"}, {"syntax_pass": true, "original_string": "        public void setB(final double b) {\n            this.b = b;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setB", "params": [{"name": "b", "type": "double"}], "body": "                                         {\n            this.b = b;\n        }", "signature": "public void setB(final double b)"}, {"syntax_pass": true, "original_string": "        public void setC(final String c) {\n            this.c = c;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setC", "params": [{"name": "c", "type": "String"}], "body": "                                         {\n            this.c = c;\n        }", "signature": "public void setC(final String c)"}]}]}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    private void callBatchWithException(final String sql, final Object[][] params) throws Exception {\n        when(meta.getParameterCount()).thenReturn(2);\n        boolean caught = false;\n\n        try {\n            runner.batch(sql, params);\n\n            verify(prepStmt, times(1)).getParameterMetaData();\n            verify(prepStmt, times(2)).addBatch();\n            verify(prepStmt, times(1)).executeBatch();\n            verify(prepStmt, times(1)).close();    // make sure the statement is closed\n            verify(conn, times(1)).close();    // make sure the connection is closed\n        } catch (final SQLException e) {\n            System.out.println(\"[TEST] The following exception is expected:\");\n            System.out.println(e);\n            caught = true;\n        }\n\n        if (!caught) {\n            fail(\"Exception never thrown, but expected\");\n        }\n    }", "docstring": " helper method for calling batch when an exception is expected", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "callBatchWithException", "params": [{"name": "sql", "type": "String"}, {"name": "params", "type": "Object[][]"}], "body": "                                                                                                    {\n        when(meta.getParameterCount()).thenReturn(2);\n        boolean caught = false;\n\n        try {\n            runner.batch(sql, params);\n\n            verify(prepStmt, times(1)).getParameterMetaData();\n            verify(prepStmt, times(2)).addBatch();\n            verify(prepStmt, times(1)).executeBatch();\n            verify(prepStmt, times(1)).close();    // make sure the statement is closed\n            verify(conn, times(1)).close();    // make sure the connection is closed\n        } catch (final SQLException e) {\n            System.out.println(\"[TEST] The following exception is expected:\");\n            System.out.println(e);\n            caught = true;\n        }\n\n        if (!caught) {\n            fail(\"Exception never thrown, but expected\");\n        }\n    }", "signature": "private void callBatchWithException(final String sql, final Object[][] params)"}, {"syntax_pass": true, "original_string": "    private void callExecuteWithException(final Object... params) throws Exception {\n        boolean caught = false;\n\n        try {\n            when(meta.getParameterCount()).thenReturn(2);\n            runner.query(\"{call my_proc(?, ?)}\", handler, params);\n\n        } catch (final SQLException e) {\n            caught = true;\n        }\n\n        if (!caught) {\n            fail(\"Exception never thrown, but expected\");\n        }\n    }", "docstring": " helper method for calling execute when an exception is expected", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "callExecuteWithException", "params": [], "body": "                                                                                   {\n        boolean caught = false;\n\n        try {\n            when(meta.getParameterCount()).thenReturn(2);\n            runner.query(\"{call my_proc(?, ?)}\", handler, params);\n\n        } catch (final SQLException e) {\n            caught = true;\n        }\n\n        if (!caught) {\n            fail(\"Exception never thrown, but expected\");\n        }\n    }", "signature": "private void callExecuteWithException(final Object... params)"}, {"syntax_pass": true, "original_string": "    private void callExecuteWithResultSetWithException(final Object... params) throws Exception {\n        boolean caught = false;\n\n        try {\n            when(meta.getParameterCount()).thenReturn(2);\n            runner.execute(\"{call my_proc(?, ?)}\", handler, params);\n\n        } catch (final SQLException e) {\n            caught = true;\n        }\n\n        if (!caught) {\n            fail(\"Exception never thrown, but expected\");\n        }\n    }", "docstring": " helper method for calling execute when an exception is expected", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "callExecuteWithResultSetWithException", "params": [], "body": "                                                                                                {\n        boolean caught = false;\n\n        try {\n            when(meta.getParameterCount()).thenReturn(2);\n            runner.execute(\"{call my_proc(?, ?)}\", handler, params);\n\n        } catch (final SQLException e) {\n            caught = true;\n        }\n\n        if (!caught) {\n            fail(\"Exception never thrown, but expected\");\n        }\n    }", "signature": "private void callExecuteWithResultSetWithException(final Object... params)"}, {"syntax_pass": true, "original_string": "    private void callGoodBatch(final Connection conn, final Object[][] params) throws Exception {\n        when(meta.getParameterCount()).thenReturn(2);\n        runner.batch(conn, \"select * from blah where ? = ?\", params);\n\n        verify(prepStmt, times(1)).getParameterMetaData();\n        verify(prepStmt, times(2)).addBatch();\n        verify(prepStmt, times(1)).executeBatch();\n        // make sure we closed the statement\n        verify(prepStmt, times(1)).close();\n        // make sure we do not close the connection, since QueryRunner.batch(Connection, String, Object[][]) does not close connections\n        verify(conn, times(0)).close();\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "callGoodBatch", "params": [{"name": "conn", "type": "Connection"}, {"name": "params", "type": "Object[][]"}], "body": "                                                                                                {\n        when(meta.getParameterCount()).thenReturn(2);\n        runner.batch(conn, \"select * from blah where ? = ?\", params);\n\n        verify(prepStmt, times(1)).getParameterMetaData();\n        verify(prepStmt, times(2)).addBatch();\n        verify(prepStmt, times(1)).executeBatch();\n        // make sure we closed the statement\n        verify(prepStmt, times(1)).close();\n        // make sure we do not close the connection, since QueryRunner.batch(Connection, String, Object[][]) does not close connections\n        verify(conn, times(0)).close();\n    }", "signature": "private void callGoodBatch(final Connection conn, final Object[][] params)"}, {"syntax_pass": true, "original_string": "    private void callGoodBatch(final Object[][] params) throws Exception {\n        callGoodBatch(params, true);\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "callGoodBatch", "params": [{"name": "params", "type": "Object[][]"}], "body": "                                                                         {\n        callGoodBatch(params, true);\n    }", "signature": "private void callGoodBatch(final Object[][] params)"}, {"syntax_pass": true, "original_string": "    private void callGoodBatch(final Object[][] params, final boolean pmdCheck) throws Exception {\n        when(meta.getParameterCount()).thenReturn(2);\n        runner.batch(\"select * from blah where ? = ?\", params);\n\n        verify(prepStmt, times(pmdCheck ? 1 : 0)).getParameterMetaData();\n        verify(prepStmt, times(2)).addBatch();\n        verify(prepStmt, times(1)).executeBatch();\n        verify(prepStmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(1)).close();    // make sure we closed the connection\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "callGoodBatch", "params": [{"name": "params", "type": "Object[][]"}, {"name": "pmdCheck", "type": "boolean"}], "body": "                                                                                                 {\n        when(meta.getParameterCount()).thenReturn(2);\n        runner.batch(\"select * from blah where ? = ?\", params);\n\n        verify(prepStmt, times(pmdCheck ? 1 : 0)).getParameterMetaData();\n        verify(prepStmt, times(2)).addBatch();\n        verify(prepStmt, times(1)).executeBatch();\n        verify(prepStmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(1)).close();    // make sure we closed the connection\n    }", "signature": "private void callGoodBatch(final Object[][] params, final boolean pmdCheck)"}, {"syntax_pass": true, "original_string": "    private void callGoodExecute() throws Exception {\n        when(call.execute()).thenReturn(false);\n        when(call.getUpdateCount()).thenReturn(3);\n\n        when(meta.getParameterCount()).thenReturn(2);\n        int result = runner.execute(\"{call my_proc(?, ?)}\", \"unit\", \"test\");\n\n        Assert.assertEquals(3, result);\n\n        verify(call, times(1)).execute();\n        verify(call, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(1)).close();    // make sure we do not close the connection\n\n        // call the other variation of query\n        when(meta.getParameterCount()).thenReturn(0);\n        result = runner.execute(\"{call my_proc()}\");\n\n        Assert.assertEquals(3, result);\n\n        verify(call, times(2)).execute();\n        verify(call, times(2)).close();    // make sure we closed the statement\n        verify(conn, times(2)).close();    // make sure we do not close the connection\n\n        // Test single OUT parameter\n        when(meta.getParameterCount()).thenReturn(1);\n        when(call.getObject(1)).thenReturn(42);\n        final OutParameter<Integer> intParam =\n            new OutParameter<>(Types.INTEGER, Integer.class);\n        result = runner.execute(\"{?= call my_proc()}\", intParam);\n\n        Assert.assertEquals(42, intParam.getValue().intValue());\n        Assert.assertEquals(3, result);\n\n        verify(call, times(3)).execute();\n        verify(call, times(3)).close();    // make sure we closed the statement\n        verify(conn, times(3)).close();    // make sure we do not close the connection\n\n        // Test OUT parameters with IN parameters\n        when(meta.getParameterCount()).thenReturn(3);\n        when(call.getObject(1)).thenReturn(4242);\n        intParam.setValue(null);\n        result = runner.execute(\"{?= call my_proc(?, ?)}\", intParam, \"unit\", \"test\");\n\n        Assert.assertEquals(4242, intParam.getValue().intValue());\n        Assert.assertEquals(3, result);\n\n        verify(call, times(4)).execute();\n        verify(call, times(4)).close();    // make sure we closed the statement\n        verify(conn, times(4)).close();    // make sure we do not close the connection\n\n        // Test INOUT parameters\n        when(meta.getParameterCount()).thenReturn(3);\n        when(call.getObject(1)).thenReturn(24);\n        when(call.getObject(3)).thenReturn(\"out\");\n        intParam.setValue(null);\n        final OutParameter<String> stringParam =\n            new OutParameter<>(Types.VARCHAR, String.class, \"in\");\n        result = runner.execute(\"{?= call my_proc(?, ?)}\", intParam, \"test\", stringParam);\n\n        Assert.assertEquals(24, intParam.getValue().intValue());\n        Assert.assertEquals(\"out\", stringParam.getValue());\n        Assert.assertEquals(3, result);\n\n        verify(call, times(5)).execute();\n        verify(call, times(5)).close();    // make sure we closed the statement\n        verify(conn, times(5)).close();    // make sure we do not close the connection\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "callGoodExecute", "params": [], "body": "                                                    {\n        when(call.execute()).thenReturn(false);\n        when(call.getUpdateCount()).thenReturn(3);\n\n        when(meta.getParameterCount()).thenReturn(2);\n        int result = runner.execute(\"{call my_proc(?, ?)}\", \"unit\", \"test\");\n\n        Assert.assertEquals(3, result);\n\n        verify(call, times(1)).execute();\n        verify(call, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(1)).close();    // make sure we do not close the connection\n\n        // call the other variation of query\n        when(meta.getParameterCount()).thenReturn(0);\n        result = runner.execute(\"{call my_proc()}\");\n\n        Assert.assertEquals(3, result);\n\n        verify(call, times(2)).execute();\n        verify(call, times(2)).close();    // make sure we closed the statement\n        verify(conn, times(2)).close();    // make sure we do not close the connection\n\n        // Test single OUT parameter\n        when(meta.getParameterCount()).thenReturn(1);\n        when(call.getObject(1)).thenReturn(42);\n        final OutParameter<Integer> intParam =\n            new OutParameter<>(Types.INTEGER, Integer.class);\n        result = runner.execute(\"{?= call my_proc()}\", intParam);\n\n        Assert.assertEquals(42, intParam.getValue().intValue());\n        Assert.assertEquals(3, result);\n\n        verify(call, times(3)).execute();\n        verify(call, times(3)).close();    // make sure we closed the statement\n        verify(conn, times(3)).close();    // make sure we do not close the connection\n\n        // Test OUT parameters with IN parameters\n        when(meta.getParameterCount()).thenReturn(3);\n        when(call.getObject(1)).thenReturn(4242);\n        intParam.setValue(null);\n        result = runner.execute(\"{?= call my_proc(?, ?)}\", intParam, \"unit\", \"test\");\n\n        Assert.assertEquals(4242, intParam.getValue().intValue());\n        Assert.assertEquals(3, result);\n\n        verify(call, times(4)).execute();\n        verify(call, times(4)).close();    // make sure we closed the statement\n        verify(conn, times(4)).close();    // make sure we do not close the connection\n\n        // Test INOUT parameters\n        when(meta.getParameterCount()).thenReturn(3);\n        when(call.getObject(1)).thenReturn(24);\n        when(call.getObject(3)).thenReturn(\"out\");\n        intParam.setValue(null);\n        final OutParameter<String> stringParam =\n            new OutParameter<>(Types.VARCHAR, String.class, \"in\");\n        result = runner.execute(\"{?= call my_proc(?, ?)}\", intParam, \"test\", stringParam);\n\n        Assert.assertEquals(24, intParam.getValue().intValue());\n        Assert.assertEquals(\"out\", stringParam.getValue());\n        Assert.assertEquals(3, result);\n\n        verify(call, times(5)).execute();\n        verify(call, times(5)).close();    // make sure we closed the statement\n        verify(conn, times(5)).close();    // make sure we do not close the connection\n    }", "signature": "private void callGoodExecute()"}, {"syntax_pass": true, "original_string": "    private void callGoodExecute(final Connection conn) throws Exception {\n        when(call.execute()).thenReturn(false);\n        when(call.getUpdateCount()).thenReturn(3);\n\n        when(meta.getParameterCount()).thenReturn(2);\n        int result = runner.execute(conn, \"{call my_proc(?, ?)}\", \"unit\", \"test\");\n\n        Assert.assertEquals(3, result);\n\n        verify(call, times(1)).execute();\n        verify(call, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we do not close the connection\n\n        // call the other variation of query\n        when(meta.getParameterCount()).thenReturn(0);\n        result = runner.execute(conn, \"{call my_proc()}\");\n\n        Assert.assertEquals(3, result);\n\n        verify(call, times(2)).execute();\n        verify(call, times(2)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we do not close the connection\n\n        // Test single OUT parameter\n        when(meta.getParameterCount()).thenReturn(1);\n        when(call.getObject(1)).thenReturn(42);\n        final OutParameter<Integer> intParam =\n            new OutParameter<>(Types.INTEGER, Integer.class);\n        result = runner.execute(conn, \"{?= call my_proc()}\", intParam);\n\n        Assert.assertEquals(42, intParam.getValue().intValue());\n        Assert.assertEquals(3, result);\n\n        verify(call, times(3)).execute();\n        verify(call, times(3)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we do not close the connection\n\n        // Test OUT parameters with IN parameters\n        when(meta.getParameterCount()).thenReturn(3);\n        when(call.getObject(1)).thenReturn(4242);\n        intParam.setValue(null);\n        result = runner.execute(conn, \"{?= call my_proc(?, ?)}\", intParam, \"unit\", \"test\");\n\n        Assert.assertEquals(4242, intParam.getValue().intValue());\n        Assert.assertEquals(3, result);\n\n        verify(call, times(4)).execute();\n        verify(call, times(4)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we do not close the connection\n\n        // Test INOUT parameters\n        when(meta.getParameterCount()).thenReturn(3);\n        when(call.getObject(1)).thenReturn(24);\n        when(call.getObject(3)).thenReturn(\"out\");\n        intParam.setValue(null);\n        final OutParameter<String> stringParam =\n            new OutParameter<>(Types.VARCHAR, String.class, \"in\");\n        result = runner.execute(conn, \"{?= call my_proc(?, ?)}\", intParam, \"test\", stringParam);\n\n        Assert.assertEquals(24, intParam.getValue().intValue());\n        Assert.assertEquals(\"out\", stringParam.getValue());\n        Assert.assertEquals(3, result);\n\n        verify(call, times(5)).execute();\n        verify(call, times(5)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we do not close the connection\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "callGoodExecute", "params": [{"name": "conn", "type": "Connection"}], "body": "                                                                         {\n        when(call.execute()).thenReturn(false);\n        when(call.getUpdateCount()).thenReturn(3);\n\n        when(meta.getParameterCount()).thenReturn(2);\n        int result = runner.execute(conn, \"{call my_proc(?, ?)}\", \"unit\", \"test\");\n\n        Assert.assertEquals(3, result);\n\n        verify(call, times(1)).execute();\n        verify(call, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we do not close the connection\n\n        // call the other variation of query\n        when(meta.getParameterCount()).thenReturn(0);\n        result = runner.execute(conn, \"{call my_proc()}\");\n\n        Assert.assertEquals(3, result);\n\n        verify(call, times(2)).execute();\n        verify(call, times(2)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we do not close the connection\n\n        // Test single OUT parameter\n        when(meta.getParameterCount()).thenReturn(1);\n        when(call.getObject(1)).thenReturn(42);\n        final OutParameter<Integer> intParam =\n            new OutParameter<>(Types.INTEGER, Integer.class);\n        result = runner.execute(conn, \"{?= call my_proc()}\", intParam);\n\n        Assert.assertEquals(42, intParam.getValue().intValue());\n        Assert.assertEquals(3, result);\n\n        verify(call, times(3)).execute();\n        verify(call, times(3)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we do not close the connection\n\n        // Test OUT parameters with IN parameters\n        when(meta.getParameterCount()).thenReturn(3);\n        when(call.getObject(1)).thenReturn(4242);\n        intParam.setValue(null);\n        result = runner.execute(conn, \"{?= call my_proc(?, ?)}\", intParam, \"unit\", \"test\");\n\n        Assert.assertEquals(4242, intParam.getValue().intValue());\n        Assert.assertEquals(3, result);\n\n        verify(call, times(4)).execute();\n        verify(call, times(4)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we do not close the connection\n\n        // Test INOUT parameters\n        when(meta.getParameterCount()).thenReturn(3);\n        when(call.getObject(1)).thenReturn(24);\n        when(call.getObject(3)).thenReturn(\"out\");\n        intParam.setValue(null);\n        final OutParameter<String> stringParam =\n            new OutParameter<>(Types.VARCHAR, String.class, \"in\");\n        result = runner.execute(conn, \"{?= call my_proc(?, ?)}\", intParam, \"test\", stringParam);\n\n        Assert.assertEquals(24, intParam.getValue().intValue());\n        Assert.assertEquals(\"out\", stringParam.getValue());\n        Assert.assertEquals(3, result);\n\n        verify(call, times(5)).execute();\n        verify(call, times(5)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we do not close the connection\n    }", "signature": "private void callGoodExecute(final Connection conn)"}, {"syntax_pass": true, "original_string": "    private void callGoodExecuteWithResultSet() throws Exception {\n        when(call.execute()).thenReturn(true);\n\n        when(meta.getParameterCount()).thenReturn(2);\n        runner.execute(\"{call my_proc(?, ?)}\", handler, \"unit\", \"test\");\n\n        verify(call, times(1)).execute();\n        verify(results, times(1)).close();\n        verify(call, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(1)).close();    // make sure we do not close the connection\n\n        // call the other variation of query\n        when(meta.getParameterCount()).thenReturn(0);\n        runner.execute(\"{call my_proc()}\", handler);\n\n        verify(call, times(2)).execute();\n        verify(results, times(2)).close();\n        verify(call, times(2)).close();    // make sure we closed the statement\n        verify(conn, times(2)).close();    // make sure we do not close the connection\n\n        // Test single OUT parameter\n        when(meta.getParameterCount()).thenReturn(1);\n        when(call.getObject(1)).thenReturn(42);\n        final OutParameter<Integer> intParam =\n            new OutParameter<>(Types.INTEGER, Integer.class);\n        runner.execute(\"{?= call my_proc()}\", handler, intParam);\n\n        Assert.assertEquals(42, intParam.getValue().intValue());\n\n        verify(call, times(3)).execute();\n        verify(results, times(3)).close();\n        verify(call, times(3)).close();    // make sure we closed the statement\n        verify(conn, times(3)).close();    // make sure we do not close the connection\n\n        // Test OUT parameters with IN parameters\n        when(meta.getParameterCount()).thenReturn(3);\n        when(call.getObject(1)).thenReturn(4242);\n        intParam.setValue(null);\n        runner.execute(\"{?= call my_proc(?, ?)}\", handler, intParam, \"unit\", \"test\");\n\n        Assert.assertEquals(4242, intParam.getValue().intValue());\n\n        verify(call, times(4)).execute();\n        verify(results, times(4)).close();\n        verify(call, times(4)).close();    // make sure we closed the statement\n        verify(conn, times(4)).close();    // make sure we do not close the connection\n\n        // Test INOUT parameters\n        when(meta.getParameterCount()).thenReturn(3);\n        when(call.getObject(1)).thenReturn(24);\n        when(call.getObject(3)).thenReturn(\"out\");\n        intParam.setValue(null);\n        final OutParameter<String> stringParam =\n            new OutParameter<>(Types.VARCHAR, String.class, \"in\");\n        runner.execute(\"{?= call my_proc(?, ?)}\", handler, intParam, \"test\", stringParam);\n\n        Assert.assertEquals(24, intParam.getValue().intValue());\n        Assert.assertEquals(\"out\", stringParam.getValue());\n\n        verify(call, times(5)).execute();\n        verify(results, times(5)).close();\n        verify(call, times(5)).close();    // make sure we closed the statement\n        verify(conn, times(5)).close();    // make sure we do not close the connection\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "callGoodExecuteWithResultSet", "params": [], "body": "                                                                 {\n        when(call.execute()).thenReturn(true);\n\n        when(meta.getParameterCount()).thenReturn(2);\n        runner.execute(\"{call my_proc(?, ?)}\", handler, \"unit\", \"test\");\n\n        verify(call, times(1)).execute();\n        verify(results, times(1)).close();\n        verify(call, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(1)).close();    // make sure we do not close the connection\n\n        // call the other variation of query\n        when(meta.getParameterCount()).thenReturn(0);\n        runner.execute(\"{call my_proc()}\", handler);\n\n        verify(call, times(2)).execute();\n        verify(results, times(2)).close();\n        verify(call, times(2)).close();    // make sure we closed the statement\n        verify(conn, times(2)).close();    // make sure we do not close the connection\n\n        // Test single OUT parameter\n        when(meta.getParameterCount()).thenReturn(1);\n        when(call.getObject(1)).thenReturn(42);\n        final OutParameter<Integer> intParam =\n            new OutParameter<>(Types.INTEGER, Integer.class);\n        runner.execute(\"{?= call my_proc()}\", handler, intParam);\n\n        Assert.assertEquals(42, intParam.getValue().intValue());\n\n        verify(call, times(3)).execute();\n        verify(results, times(3)).close();\n        verify(call, times(3)).close();    // make sure we closed the statement\n        verify(conn, times(3)).close();    // make sure we do not close the connection\n\n        // Test OUT parameters with IN parameters\n        when(meta.getParameterCount()).thenReturn(3);\n        when(call.getObject(1)).thenReturn(4242);\n        intParam.setValue(null);\n        runner.execute(\"{?= call my_proc(?, ?)}\", handler, intParam, \"unit\", \"test\");\n\n        Assert.assertEquals(4242, intParam.getValue().intValue());\n\n        verify(call, times(4)).execute();\n        verify(results, times(4)).close();\n        verify(call, times(4)).close();    // make sure we closed the statement\n        verify(conn, times(4)).close();    // make sure we do not close the connection\n\n        // Test INOUT parameters\n        when(meta.getParameterCount()).thenReturn(3);\n        when(call.getObject(1)).thenReturn(24);\n        when(call.getObject(3)).thenReturn(\"out\");\n        intParam.setValue(null);\n        final OutParameter<String> stringParam =\n            new OutParameter<>(Types.VARCHAR, String.class, \"in\");\n        runner.execute(\"{?= call my_proc(?, ?)}\", handler, intParam, \"test\", stringParam);\n\n        Assert.assertEquals(24, intParam.getValue().intValue());\n        Assert.assertEquals(\"out\", stringParam.getValue());\n\n        verify(call, times(5)).execute();\n        verify(results, times(5)).close();\n        verify(call, times(5)).close();    // make sure we closed the statement\n        verify(conn, times(5)).close();    // make sure we do not close the connection\n    }", "signature": "private void callGoodExecuteWithResultSet()"}, {"syntax_pass": true, "original_string": "    private void callGoodExecuteWithResultSet(final Connection conn) throws Exception {\n        when(call.execute()).thenReturn(true);\n\n        when(meta.getParameterCount()).thenReturn(2);\n        runner.execute(conn, \"{call my_proc(?, ?)}\", handler, \"unit\", \"test\");\n\n        verify(call, times(1)).execute();\n        verify(results, times(1)).close();\n        verify(call, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we do not close the connection\n\n        // call the other variation of query\n        when(meta.getParameterCount()).thenReturn(0);\n        runner.execute(conn, \"{call my_proc()}\", handler);\n\n        verify(call, times(2)).execute();\n        verify(results, times(2)).close();\n        verify(call, times(2)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we do not close the connection\n\n        // Test single OUT parameter\n        when(meta.getParameterCount()).thenReturn(1);\n        when(call.getObject(1)).thenReturn(42);\n        final OutParameter<Integer> intParam =\n            new OutParameter<>(Types.INTEGER, Integer.class);\n        runner.execute(conn, \"{?= call my_proc()}\", handler, intParam);\n\n        Assert.assertEquals(42, intParam.getValue().intValue());\n\n        verify(call, times(3)).execute();\n        verify(results, times(3)).close();\n        verify(call, times(3)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we do not close the connection\n\n        // Test OUT parameters with IN parameters\n        when(meta.getParameterCount()).thenReturn(3);\n        when(call.getObject(1)).thenReturn(4242);\n        intParam.setValue(null);\n        runner.execute(conn, \"{?= call my_proc(?, ?)}\", handler, intParam, \"unit\", \"test\");\n\n        Assert.assertEquals(4242, intParam.getValue().intValue());\n\n        verify(call, times(4)).execute();\n        verify(results, times(4)).close();\n        verify(call, times(4)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we do not close the connection\n\n        // Test INOUT parameters\n        when(meta.getParameterCount()).thenReturn(3);\n        when(call.getObject(1)).thenReturn(24);\n        when(call.getObject(3)).thenReturn(\"out\");\n        intParam.setValue(null);\n        final OutParameter<String> stringParam =\n            new OutParameter<>(Types.VARCHAR, String.class, \"in\");\n        runner.execute(conn, \"{?= call my_proc(?, ?)}\", handler, intParam, \"test\", stringParam);\n\n        Assert.assertEquals(24, intParam.getValue().intValue());\n        Assert.assertEquals(\"out\", stringParam.getValue());\n\n        verify(call, times(5)).execute();\n        verify(results, times(5)).close();\n        verify(call, times(5)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we do not close the connection\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "callGoodExecuteWithResultSet", "params": [{"name": "conn", "type": "Connection"}], "body": "                                                                                      {\n        when(call.execute()).thenReturn(true);\n\n        when(meta.getParameterCount()).thenReturn(2);\n        runner.execute(conn, \"{call my_proc(?, ?)}\", handler, \"unit\", \"test\");\n\n        verify(call, times(1)).execute();\n        verify(results, times(1)).close();\n        verify(call, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we do not close the connection\n\n        // call the other variation of query\n        when(meta.getParameterCount()).thenReturn(0);\n        runner.execute(conn, \"{call my_proc()}\", handler);\n\n        verify(call, times(2)).execute();\n        verify(results, times(2)).close();\n        verify(call, times(2)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we do not close the connection\n\n        // Test single OUT parameter\n        when(meta.getParameterCount()).thenReturn(1);\n        when(call.getObject(1)).thenReturn(42);\n        final OutParameter<Integer> intParam =\n            new OutParameter<>(Types.INTEGER, Integer.class);\n        runner.execute(conn, \"{?= call my_proc()}\", handler, intParam);\n\n        Assert.assertEquals(42, intParam.getValue().intValue());\n\n        verify(call, times(3)).execute();\n        verify(results, times(3)).close();\n        verify(call, times(3)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we do not close the connection\n\n        // Test OUT parameters with IN parameters\n        when(meta.getParameterCount()).thenReturn(3);\n        when(call.getObject(1)).thenReturn(4242);\n        intParam.setValue(null);\n        runner.execute(conn, \"{?= call my_proc(?, ?)}\", handler, intParam, \"unit\", \"test\");\n\n        Assert.assertEquals(4242, intParam.getValue().intValue());\n\n        verify(call, times(4)).execute();\n        verify(results, times(4)).close();\n        verify(call, times(4)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we do not close the connection\n\n        // Test INOUT parameters\n        when(meta.getParameterCount()).thenReturn(3);\n        when(call.getObject(1)).thenReturn(24);\n        when(call.getObject(3)).thenReturn(\"out\");\n        intParam.setValue(null);\n        final OutParameter<String> stringParam =\n            new OutParameter<>(Types.VARCHAR, String.class, \"in\");\n        runner.execute(conn, \"{?= call my_proc(?, ?)}\", handler, intParam, \"test\", stringParam);\n\n        Assert.assertEquals(24, intParam.getValue().intValue());\n        Assert.assertEquals(\"out\", stringParam.getValue());\n\n        verify(call, times(5)).execute();\n        verify(results, times(5)).close();\n        verify(call, times(5)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we do not close the connection\n    }", "signature": "private void callGoodExecuteWithResultSet(final Connection conn)"}, {"syntax_pass": true, "original_string": "    private void callGoodQuery() throws Exception {\n        when(meta.getParameterCount()).thenReturn(2);\n        String sql = \"select * from blah where ? = ?\";\n        runner.query(sql, handler, \"unit\", \"test\");\n\n        verify(prepStmt, times(1)).executeQuery();\n        verify(results, times(1)).close();\n        verify(prepStmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(1)).close();    // make sure we closed the connection\n\n        // call the other variation of query\n        sql = \"select * from blah\";\n        runner.query(sql, handler);\n\n        verify(stmt, times(1)).executeQuery(sql);\n        verify(results, times(2)).close();\n        verify(stmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(2)).close();    // make sure we closed the connection\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "callGoodQuery", "params": [], "body": "                                                  {\n        when(meta.getParameterCount()).thenReturn(2);\n        String sql = \"select * from blah where ? = ?\";\n        runner.query(sql, handler, \"unit\", \"test\");\n\n        verify(prepStmt, times(1)).executeQuery();\n        verify(results, times(1)).close();\n        verify(prepStmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(1)).close();    // make sure we closed the connection\n\n        // call the other variation of query\n        sql = \"select * from blah\";\n        runner.query(sql, handler);\n\n        verify(stmt, times(1)).executeQuery(sql);\n        verify(results, times(2)).close();\n        verify(stmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(2)).close();    // make sure we closed the connection\n    }", "signature": "private void callGoodQuery()"}, {"syntax_pass": true, "original_string": "    private void callGoodQuery(final Connection conn) throws Exception {\n        when(meta.getParameterCount()).thenReturn(2);\n        String sql = \"select * from blah where ? = ?\";\n        runner.query(conn, sql, handler, \"unit\", \"test\");\n\n        verify(prepStmt, times(1)).executeQuery();\n        verify(results, times(1)).close();\n        verify(prepStmt, times(1)).close();    // make sure we closed the statement\n        // make sure we do not close the connection, since QueryRunner.query(Connection, String, ResultSetHandler<T>, Object...) does not close connections\n        verify(conn, times(0)).close();\n        // call the other variation of query\n        sql = \"select * from blah\";\n        runner.query(conn, sql, handler);\n\n        verify(stmt, times(1)).executeQuery(sql);\n        verify(results, times(2)).close();\n        verify(stmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we do not close the connection, see above\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "callGoodQuery", "params": [{"name": "conn", "type": "Connection"}], "body": "                                                                       {\n        when(meta.getParameterCount()).thenReturn(2);\n        String sql = \"select * from blah where ? = ?\";\n        runner.query(conn, sql, handler, \"unit\", \"test\");\n\n        verify(prepStmt, times(1)).executeQuery();\n        verify(results, times(1)).close();\n        verify(prepStmt, times(1)).close();    // make sure we closed the statement\n        // make sure we do not close the connection, since QueryRunner.query(Connection, String, ResultSetHandler<T>, Object...) does not close connections\n        verify(conn, times(0)).close();\n        // call the other variation of query\n        sql = \"select * from blah\";\n        runner.query(conn, sql, handler);\n\n        verify(stmt, times(1)).executeQuery(sql);\n        verify(results, times(2)).close();\n        verify(stmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we do not close the connection, see above\n    }", "signature": "private void callGoodQuery(final Connection conn)"}, {"syntax_pass": true, "original_string": "    private void callGoodUpdate() throws Exception {\n        when(meta.getParameterCount()).thenReturn(2);\n        String sql = \"update blah set ? = ?\";\n        runner.update(sql, \"unit\", \"test\");\n\n        verify(prepStmt, times(1)).executeUpdate();\n        verify(prepStmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(1)).close();    // make sure we closed the connection\n\n        // call the other variation\n        when(meta.getParameterCount()).thenReturn(0);\n        sql = \"update blah set unit = test\";\n        runner.update(sql);\n\n        verify(stmt, times(1)).executeUpdate(sql);\n        verify(stmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(2)).close();    // make sure we closed the connection\n\n        // call the other variation\n        when(meta.getParameterCount()).thenReturn(1);\n        sql = \"update blah set unit = ?\";\n        runner.update(sql, \"test\");\n\n        verify(prepStmt, times(2)).executeUpdate();\n        verify(prepStmt, times(2)).close();    // make sure we closed the statement\n        verify(conn, times(3)).close();    // make sure we closed the connection\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "callGoodUpdate", "params": [], "body": "                                                   {\n        when(meta.getParameterCount()).thenReturn(2);\n        String sql = \"update blah set ? = ?\";\n        runner.update(sql, \"unit\", \"test\");\n\n        verify(prepStmt, times(1)).executeUpdate();\n        verify(prepStmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(1)).close();    // make sure we closed the connection\n\n        // call the other variation\n        when(meta.getParameterCount()).thenReturn(0);\n        sql = \"update blah set unit = test\";\n        runner.update(sql);\n\n        verify(stmt, times(1)).executeUpdate(sql);\n        verify(stmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(2)).close();    // make sure we closed the connection\n\n        // call the other variation\n        when(meta.getParameterCount()).thenReturn(1);\n        sql = \"update blah set unit = ?\";\n        runner.update(sql, \"test\");\n\n        verify(prepStmt, times(2)).executeUpdate();\n        verify(prepStmt, times(2)).close();    // make sure we closed the statement\n        verify(conn, times(3)).close();    // make sure we closed the connection\n    }", "signature": "private void callGoodUpdate()"}, {"syntax_pass": true, "original_string": "    private void callGoodUpdate(final Connection conn) throws Exception {\n        when(meta.getParameterCount()).thenReturn(2);\n        runner.update(conn, \"update blah set ? = ?\", \"unit\", \"test\");\n\n        verify(prepStmt, times(1)).executeUpdate();\n        verify(prepStmt, times(1)).close();    // make sure we closed the statement\n        // make sure we do not close the connection, since QueryRunner.update(Connection, String, Object...) does not close connections\n        verify(conn, times(0)).close();\n        // call the other variation\n        when(meta.getParameterCount()).thenReturn(0);\n        final String sql = \"update blah set unit = test\";\n        runner.update(conn, sql);\n\n        verify(stmt, times(1)).executeUpdate(sql);\n        verify(stmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we do not close the connection, see above\n\n        // call the other variation\n        when(meta.getParameterCount()).thenReturn(1);\n        runner.update(conn, \"update blah set unit = ?\", \"test\");\n\n        verify(prepStmt, times(2)).executeUpdate();\n        verify(prepStmt, times(2)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we do not close the connection, see above\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "callGoodUpdate", "params": [{"name": "conn", "type": "Connection"}], "body": "                                                                        {\n        when(meta.getParameterCount()).thenReturn(2);\n        runner.update(conn, \"update blah set ? = ?\", \"unit\", \"test\");\n\n        verify(prepStmt, times(1)).executeUpdate();\n        verify(prepStmt, times(1)).close();    // make sure we closed the statement\n        // make sure we do not close the connection, since QueryRunner.update(Connection, String, Object...) does not close connections\n        verify(conn, times(0)).close();\n        // call the other variation\n        when(meta.getParameterCount()).thenReturn(0);\n        final String sql = \"update blah set unit = test\";\n        runner.update(conn, sql);\n\n        verify(stmt, times(1)).executeUpdate(sql);\n        verify(stmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we do not close the connection, see above\n\n        // call the other variation\n        when(meta.getParameterCount()).thenReturn(1);\n        runner.update(conn, \"update blah set unit = ?\", \"test\");\n\n        verify(prepStmt, times(2)).executeUpdate();\n        verify(prepStmt, times(2)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we do not close the connection, see above\n    }", "signature": "private void callGoodUpdate(final Connection conn)"}, {"syntax_pass": true, "original_string": "    private void callQueryWithException(final Object... params) throws Exception {\n        boolean caught = false;\n\n        try {\n            when(meta.getParameterCount()).thenReturn(2);\n            final String sql = \"select * from blah where ? = ?\";\n            runner.query(sql, handler, params);\n\n            verify(prepStmt, never()).close(); // make sure the statement is still open\n            verify(prepStmt, times(1)).executeQuery();\n            verify(prepStmt, times(1)).close(); // make sure we closed the statement\n            verify(results, times(1)).close();\n            verify(conn, times(1)).close(); // make sure we closed the connection\n        } catch (final SQLException e) {\n            caught = true;\n        }\n\n        if (!caught) {\n            fail(\"Exception never thrown, but expected\");\n        }\n    }", "docstring": " Helper method for calling batch when an exception is expected.", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "callQueryWithException", "params": [], "body": "                                                                                 {\n        boolean caught = false;\n\n        try {\n            when(meta.getParameterCount()).thenReturn(2);\n            final String sql = \"select * from blah where ? = ?\";\n            runner.query(sql, handler, params);\n\n            verify(prepStmt, never()).close(); // make sure the statement is still open\n            verify(prepStmt, times(1)).executeQuery();\n            verify(prepStmt, times(1)).close(); // make sure we closed the statement\n            verify(results, times(1)).close();\n            verify(conn, times(1)).close(); // make sure we closed the connection\n        } catch (final SQLException e) {\n            caught = true;\n        }\n\n        if (!caught) {\n            fail(\"Exception never thrown, but expected\");\n        }\n    }", "signature": "private void callQueryWithException(final Object... params)"}, {"syntax_pass": true, "original_string": "    private void callUpdateWithException(final Object... params) throws Exception {\n        boolean caught = false;\n\n        try {\n            when(meta.getParameterCount()).thenReturn(2);\n            final String sql = \"select * from blah where ? = ?\";\n            runner.update(sql, params);\n\n            verify(prepStmt, times(1)).executeUpdate();\n            verify(prepStmt, times(1)).close(); // make sure we closed the statement\n            verify(conn, times(1)).close(); // make sure we closed the connection\n        } catch (final SQLException e) {\n            caught = true;\n        }\n\n        if (!caught) {\n            fail(\"Exception never thrown, but expected\");\n        }\n    }", "docstring": " helper method for calling batch when an exception is expected", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "callUpdateWithException", "params": [], "body": "                                                                                  {\n        boolean caught = false;\n\n        try {\n            when(meta.getParameterCount()).thenReturn(2);\n            final String sql = \"select * from blah where ? = ?\";\n            runner.update(sql, params);\n\n            verify(prepStmt, times(1)).executeUpdate();\n            verify(prepStmt, times(1)).close(); // make sure we closed the statement\n            verify(conn, times(1)).close(); // make sure we closed the connection\n        } catch (final SQLException e) {\n            caught = true;\n        }\n\n        if (!caught) {\n            fail(\"Exception never thrown, but expected\");\n        }\n    }", "signature": "private void callUpdateWithException(final Object... params)"}, {"syntax_pass": true, "original_string": "    @Before\n    public void setUp() throws Exception {\n        when(dataSource.getConnection()).thenReturn(conn);\n\n        when(conn.prepareStatement(any(String.class))).thenReturn(prepStmt);\n        when(prepStmt.getParameterMetaData()).thenReturn(meta);\n        when(prepStmt.executeQuery()).thenReturn(results);\n\n        when(conn.createStatement()).thenReturn(stmt);\n        when(stmt.executeQuery(any(String.class))).thenReturn(results);\n\n        when(conn.prepareCall(any(String.class))).thenReturn(call);\n        when(call.getParameterMetaData()).thenReturn(meta);\n        when(call.getResultSet()).thenReturn(results);\n        when(call.getMoreResults()).thenReturn(false);\n\n        when(results.next()).thenReturn(false);\n\n         handler = new ArrayHandler();\n         runner = new QueryRunner(dataSource);\n    }", "docstring": "", "attributes": {"modifiers": "@Before\n    public", "marker_annotations": ["@Before"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setUp", "params": [], "body": "                                         {\n        when(dataSource.getConnection()).thenReturn(conn);\n\n        when(conn.prepareStatement(any(String.class))).thenReturn(prepStmt);\n        when(prepStmt.getParameterMetaData()).thenReturn(meta);\n        when(prepStmt.executeQuery()).thenReturn(results);\n\n        when(conn.createStatement()).thenReturn(stmt);\n        when(stmt.executeQuery(any(String.class))).thenReturn(results);\n\n        when(conn.prepareCall(any(String.class))).thenReturn(call);\n        when(call.getParameterMetaData()).thenReturn(meta);\n        when(call.getResultSet()).thenReturn(results);\n        when(call.getMoreResults()).thenReturn(false);\n\n        when(results.next()).thenReturn(false);\n\n         handler = new ArrayHandler();\n         runner = new QueryRunner(dataSource);\n    }", "signature": "@Before\n    public void setUp()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testAddBatchExceptionOnAdd() throws Exception {\n        final String[][] params = { { \"unit\", \"unit\" }, { \"test\", \"test\" } };\n\n        doThrow(new SQLException()).when(prepStmt).addBatch();\n\n        callBatchWithException(\"select * from blah where ? = ?\", params);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testAddBatchExceptionOnAdd", "params": [], "body": "                                                              {\n        final String[][] params = { { \"unit\", \"unit\" }, { \"test\", \"test\" } };\n\n        doThrow(new SQLException()).when(prepStmt).addBatch();\n\n        callBatchWithException(\"select * from blah where ? = ?\", params);\n    }", "signature": "@Test\n    public void testAddBatchExceptionOnAdd()"}, {"syntax_pass": true, "original_string": "    @Test(expected = SQLException.class)\n    public void testBadPrepareConnection() throws Exception {\n        runner = new QueryRunner();\n        runner.update(\"update blah set unit = test\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test(expected = SQLException.class)\n    public", "marker_annotations": [], "non_marker_annotations": ["@Test(expected = SQLException.class)", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testBadPrepareConnection", "params": [], "body": "                                                            {\n        runner = new QueryRunner();\n        runner.update(\"update blah set unit = test\");\n    }", "signature": "@Test(expected = SQLException.class)\n    public void testBadPrepareConnection()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testExecuteBatchExceptionOnExec() throws Exception {\n        final String[][] params = { { \"unit\", \"unit\" }, { \"test\", \"test\" } };\n\n        doThrow(new SQLException()).when(prepStmt).executeBatch();\n\n        callBatchWithException(\"select * from blah where ? = ?\", params);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testExecuteBatchExceptionOnExec", "params": [], "body": "                                                                   {\n        final String[][] params = { { \"unit\", \"unit\" }, { \"test\", \"test\" } };\n\n        doThrow(new SQLException()).when(prepStmt).executeBatch();\n\n        callBatchWithException(\"select * from blah where ? = ?\", params);\n    }", "signature": "@Test\n    public void testExecuteBatchExceptionOnExec()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testExecuteException() throws Exception {\n        callExecuteWithException(handler, \"unit\", \"test\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testExecuteException", "params": [], "body": "                                                        {\n        callExecuteWithException(handler, \"unit\", \"test\");\n    }", "signature": "@Test\n    public void testExecuteException()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testExecuteQueryException() throws Exception {\n        callQueryWithException(handler, \"unit\", \"test\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testExecuteQueryException", "params": [], "body": "                                                             {\n        callQueryWithException(handler, \"unit\", \"test\");\n    }", "signature": "@Test\n    public void testExecuteQueryException()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testExecuteUpdateException() throws Exception {\n        doThrow(new SQLException()).when(prepStmt).executeUpdate();\n\n        callUpdateWithException(\"unit\", \"test\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testExecuteUpdateException", "params": [], "body": "                                                              {\n        doThrow(new SQLException()).when(prepStmt).executeUpdate();\n\n        callUpdateWithException(\"unit\", \"test\");\n    }", "signature": "@Test\n    public void testExecuteUpdateException()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testExecuteWithMultipleResultSets() throws Exception {\n        when(call.execute()).thenReturn(true);\n        when(call.getMoreResults()).thenAnswer(new Answer<Boolean>() {\n            private int count = 1;\n            @Override\n            public Boolean answer(final InvocationOnMock invocation) {\n                return ++count <= 3;\n            }\n        });\n        when(meta.getParameterCount()).thenReturn(0);\n        final List<Object[]> objects = runner.execute(\"{call my_proc()}\", handler);\n\n        Assert.assertEquals(3, objects.size());\n        verify(call, times(1)).execute();\n        verify(results, times(3)).close();\n        verify(call, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(1)).close();    // make sure we close the connection\n\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testExecuteWithMultipleResultSets", "params": [], "body": "                                                                     {\n        when(call.execute()).thenReturn(true);\n        when(call.getMoreResults()).thenAnswer(new Answer<Boolean>() {\n            private int count = 1;\n            @Override\n            public Boolean answer(final InvocationOnMock invocation) {\n                return ++count <= 3;\n            }\n        });\n        when(meta.getParameterCount()).thenReturn(0);\n        final List<Object[]> objects = runner.execute(\"{call my_proc()}\", handler);\n\n        Assert.assertEquals(3, objects.size());\n        verify(call, times(1)).execute();\n        verify(results, times(3)).close();\n        verify(call, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(1)).close();    // make sure we close the connection\n\n    }", "signature": "@Test\n    public void testExecuteWithMultipleResultSets()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testExecuteWithResultSetException() throws Exception {\n        callExecuteWithResultSetWithException(handler, \"unit\", \"test\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testExecuteWithResultSetException", "params": [], "body": "                                                                     {\n        callExecuteWithResultSetWithException(handler, \"unit\", \"test\");\n    }", "signature": "@Test\n    public void testExecuteWithResultSetException()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testFillStatementWithBean() throws Exception {\n        final MyBean bean = new MyBean();\n        when(meta.getParameterCount()).thenReturn(3);\n        runner.fillStatementWithBean(prepStmt, bean, \"a\", \"b\", \"c\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testFillStatementWithBean", "params": [], "body": "                                                             {\n        final MyBean bean = new MyBean();\n        when(meta.getParameterCount()).thenReturn(3);\n        runner.fillStatementWithBean(prepStmt, bean, \"a\", \"b\", \"c\");\n    }", "signature": "@Test\n    public void testFillStatementWithBean()"}, {"syntax_pass": true, "original_string": "    @Test(expected = NullPointerException.class)\n    public void testFillStatementWithBeanNullNames() throws Exception {\n        final MyBean bean = new MyBean();\n        runner.fillStatementWithBean(prepStmt, bean, \"a\", \"b\", null);\n    }", "docstring": "", "attributes": {"modifiers": "@Test(expected = NullPointerException.class)\n    public", "marker_annotations": [], "non_marker_annotations": ["@Test(expected = NullPointerException.class)", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testFillStatementWithBeanNullNames", "params": [], "body": "                                                                      {\n        final MyBean bean = new MyBean();\n        runner.fillStatementWithBean(prepStmt, bean, \"a\", \"b\", null);\n    }", "signature": "@Test(expected = NullPointerException.class)\n    public void testFillStatementWithBeanNullNames()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testGoodBatch() throws Exception {\n        final String[][] params = { { \"unit\", \"unit\" }, { \"test\", \"test\" } };\n\n        callGoodBatch(params);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGoodBatch", "params": [], "body": "                                                 {\n        final String[][] params = { { \"unit\", \"unit\" }, { \"test\", \"test\" } };\n\n        callGoodBatch(params);\n    }", "signature": "@Test\n    public void testGoodBatch()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testGoodBatchDefaultConstructor() throws Exception {\n        runner = new QueryRunner();\n        final String[][] params = { { \"unit\", \"unit\" }, { \"test\", \"test\" } };\n\n        callGoodBatch(conn, params);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGoodBatchDefaultConstructor", "params": [], "body": "                                                                   {\n        runner = new QueryRunner();\n        final String[][] params = { { \"unit\", \"unit\" }, { \"test\", \"test\" } };\n\n        callGoodBatch(conn, params);\n    }", "signature": "@Test\n    public void testGoodBatchDefaultConstructor()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testGoodBatchInsert() throws Exception {\n        results = mock(ResultSet.class);\n        resultsMeta = mock(ResultSetMetaData.class);\n\n        when(meta.getParameterCount()).thenReturn(2);\n        when(conn.prepareStatement(any(String.class), eq(Statement.RETURN_GENERATED_KEYS))).thenReturn(prepStmt);\n        when(prepStmt.getGeneratedKeys()).thenReturn(results);\n        when(results.next()).thenReturn(true).thenReturn(true).thenReturn(false);\n\n        final ResultSetHandler<List<Object>> handler = rs -> {\n            final List<Object> objects = new ArrayList<>();\n            while (rs.next()) {\n                objects.add(new Object());\n            }\n            return objects;\n        };\n\n        final Object[][] params = new Object[2][2];\n        params[0][0] = \"Test\";\n        params[0][1] = \"Blah\";\n        params[1][0] = \"Test2\";\n        params[1][1] = \"Blah2\";\n\n        final List<Object> generatedKeys = runner.insertBatch(\"INSERT INTO blah(col1, col2) VALUES(?,?)\", handler, params);\n\n        verify(prepStmt, times(2)).addBatch();\n        verify(prepStmt, times(1)).executeBatch();\n        verify(prepStmt, times(1)).close(); // make sure we closed the statement\n        verify(conn, times(1)).close(); // make sure we closed the connection\n\n        Assert.assertEquals(2, generatedKeys.size());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGoodBatchInsert", "params": [], "body": "                                                       {\n        results = mock(ResultSet.class);\n        resultsMeta = mock(ResultSetMetaData.class);\n\n        when(meta.getParameterCount()).thenReturn(2);\n        when(conn.prepareStatement(any(String.class), eq(Statement.RETURN_GENERATED_KEYS))).thenReturn(prepStmt);\n        when(prepStmt.getGeneratedKeys()).thenReturn(results);\n        when(results.next()).thenReturn(true).thenReturn(true).thenReturn(false);\n\n        final ResultSetHandler<List<Object>> handler = rs -> {\n            final List<Object> objects = new ArrayList<>();\n            while (rs.next()) {\n                objects.add(new Object());\n            }\n            return objects;\n        };\n\n        final Object[][] params = new Object[2][2];\n        params[0][0] = \"Test\";\n        params[0][1] = \"Blah\";\n        params[1][0] = \"Test2\";\n        params[1][1] = \"Blah2\";\n\n        final List<Object> generatedKeys = runner.insertBatch(\"INSERT INTO blah(col1, col2) VALUES(?,?)\", handler, params);\n\n        verify(prepStmt, times(2)).addBatch();\n        verify(prepStmt, times(1)).executeBatch();\n        verify(prepStmt, times(1)).close(); // make sure we closed the statement\n        verify(conn, times(1)).close(); // make sure we closed the connection\n\n        Assert.assertEquals(2, generatedKeys.size());\n    }", "signature": "@Test\n    public void testGoodBatchInsert()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testGoodBatchPmdTrue() throws Exception {\n        runner = new QueryRunner(dataSource, true);\n        final String[][] params = { { \"unit\", \"unit\" }, { \"test\", \"test\" } };\n\n        callGoodBatch(params, false);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGoodBatchPmdTrue", "params": [], "body": "                                                        {\n        runner = new QueryRunner(dataSource, true);\n        final String[][] params = { { \"unit\", \"unit\" }, { \"test\", \"test\" } };\n\n        callGoodBatch(params, false);\n    }", "signature": "@Test\n    public void testGoodBatchPmdTrue()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testGoodExecute() throws Exception {\n        callGoodExecute();\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGoodExecute", "params": [], "body": "                                                   {\n        callGoodExecute();\n    }", "signature": "@Test\n    public void testGoodExecute()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testGoodExecuteDefaultConstructor() throws Exception {\n        runner = new QueryRunner();\n        callGoodExecute(conn);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGoodExecuteDefaultConstructor", "params": [], "body": "                                                                     {\n        runner = new QueryRunner();\n        callGoodExecute(conn);\n    }", "signature": "@Test\n    public void testGoodExecuteDefaultConstructor()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testGoodExecutePmdTrue() throws Exception {\n        runner = new QueryRunner(true);\n        callGoodExecute(conn);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGoodExecutePmdTrue", "params": [], "body": "                                                          {\n        runner = new QueryRunner(true);\n        callGoodExecute(conn);\n    }", "signature": "@Test\n    public void testGoodExecutePmdTrue()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testGoodExecuteWithResultSet() throws Exception {\n        callGoodExecuteWithResultSet();\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGoodExecuteWithResultSet", "params": [], "body": "                                                                {\n        callGoodExecuteWithResultSet();\n    }", "signature": "@Test\n    public void testGoodExecuteWithResultSet()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testGoodExecuteWithResultSetDefaultConstructor() throws Exception {\n        runner = new QueryRunner();\n        callGoodExecuteWithResultSet(conn);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGoodExecuteWithResultSetDefaultConstructor", "params": [], "body": "                                                                                  {\n        runner = new QueryRunner();\n        callGoodExecuteWithResultSet(conn);\n    }", "signature": "@Test\n    public void testGoodExecuteWithResultSetDefaultConstructor()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testGoodExecuteWithResultSetPmdTrue() throws Exception {\n        runner = new QueryRunner(true);\n        callGoodExecuteWithResultSet(conn);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGoodExecuteWithResultSetPmdTrue", "params": [], "body": "                                                                       {\n        runner = new QueryRunner(true);\n        callGoodExecuteWithResultSet(conn);\n    }", "signature": "@Test\n    public void testGoodExecuteWithResultSetPmdTrue()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testGoodInsert() throws Exception {\n        results = mock(ResultSet.class);\n\n        when(meta.getParameterCount()).thenReturn(2);\n        when(conn.prepareStatement(any(String.class), eq(Statement.RETURN_GENERATED_KEYS))).thenReturn(prepStmt);\n        when(prepStmt.getGeneratedKeys()).thenReturn(results);\n        when(results.next()).thenReturn(true).thenReturn(false);\n        when(results.getObject(1)).thenReturn(1L);\n\n        final Long generatedKey = runner.insert(\"INSERT INTO blah(col1, col2) VALUES(?,?)\", new ScalarHandler<>(), \"unit\", \"test\");\n\n        verify(prepStmt, times(1)).executeUpdate();\n        verify(prepStmt, times(1)).close(); // make sure we closed the statement\n        verify(conn, times(1)).close(); // make sure we closed the connection\n\n        Assert.assertEquals(1L, generatedKey.longValue());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGoodInsert", "params": [], "body": "                                                  {\n        results = mock(ResultSet.class);\n\n        when(meta.getParameterCount()).thenReturn(2);\n        when(conn.prepareStatement(any(String.class), eq(Statement.RETURN_GENERATED_KEYS))).thenReturn(prepStmt);\n        when(prepStmt.getGeneratedKeys()).thenReturn(results);\n        when(results.next()).thenReturn(true).thenReturn(false);\n        when(results.getObject(1)).thenReturn(1L);\n\n        final Long generatedKey = runner.insert(\"INSERT INTO blah(col1, col2) VALUES(?,?)\", new ScalarHandler<>(), \"unit\", \"test\");\n\n        verify(prepStmt, times(1)).executeUpdate();\n        verify(prepStmt, times(1)).close(); // make sure we closed the statement\n        verify(conn, times(1)).close(); // make sure we closed the connection\n\n        Assert.assertEquals(1L, generatedKey.longValue());\n    }", "signature": "@Test\n    public void testGoodInsert()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testGoodQuery() throws Exception {\n        callGoodQuery();\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGoodQuery", "params": [], "body": "                                                 {\n        callGoodQuery();\n    }", "signature": "@Test\n    public void testGoodQuery()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testGoodQueryDefaultConstructor() throws Exception {\n        runner = new QueryRunner();\n        callGoodQuery(conn);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGoodQueryDefaultConstructor", "params": [], "body": "                                                                   {\n        runner = new QueryRunner();\n        callGoodQuery(conn);\n    }", "signature": "@Test\n    public void testGoodQueryDefaultConstructor()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testGoodQueryPmdTrue() throws Exception {\n        runner = new QueryRunner(true);\n        callGoodQuery(conn);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGoodQueryPmdTrue", "params": [], "body": "                                                        {\n        runner = new QueryRunner(true);\n        callGoodQuery(conn);\n    }", "signature": "@Test\n    public void testGoodQueryPmdTrue()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testGoodUpdate() throws Exception {\n        callGoodUpdate();\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGoodUpdate", "params": [], "body": "                                                  {\n        callGoodUpdate();\n    }", "signature": "@Test\n    public void testGoodUpdate()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testGoodUpdateDefaultConstructor() throws Exception {\n        runner = new QueryRunner();\n        callGoodUpdate(conn);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGoodUpdateDefaultConstructor", "params": [], "body": "                                                                    {\n        runner = new QueryRunner();\n        callGoodUpdate(conn);\n    }", "signature": "@Test\n    public void testGoodUpdateDefaultConstructor()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testGoodUpdatePmdTrue() throws Exception {\n        runner = new QueryRunner(true);\n        callGoodUpdate(conn);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGoodUpdatePmdTrue", "params": [], "body": "                                                         {\n        runner = new QueryRunner(true);\n        callGoodUpdate(conn);\n    }", "signature": "@Test\n    public void testGoodUpdatePmdTrue()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testNoParamsExecute() throws Exception {\n        callGoodExecute();\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testNoParamsExecute", "params": [], "body": "                                                       {\n        callGoodExecute();\n    }", "signature": "@Test\n    public void testNoParamsExecute()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testNoParamsExecuteWithResultSet() throws Exception {\n        callExecuteWithResultSetWithException();\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testNoParamsExecuteWithResultSet", "params": [], "body": "                                                                    {\n        callExecuteWithResultSetWithException();\n    }", "signature": "@Test\n    public void testNoParamsExecuteWithResultSet()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testNoParamsQuery() throws Exception {\n        callGoodQuery();\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testNoParamsQuery", "params": [], "body": "                                                     {\n        callGoodQuery();\n    }", "signature": "@Test\n    public void testNoParamsQuery()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testNoParamsUpdate() throws Exception {\n        callGoodUpdate();\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testNoParamsUpdate", "params": [], "body": "                                                      {\n        callGoodUpdate();\n    }", "signature": "@Test\n    public void testNoParamsUpdate()"}, {"syntax_pass": true, "original_string": "    @Test(expected = SQLException.class)\n    public void testNullConnectionBatch() throws Exception {\n        final String[][] params = { { \"unit\", \"unit\" }, { \"test\", \"test\" } };\n\n        when(dataSource.getConnection()).thenReturn(null);\n\n        runner.batch(\"select * from blah where ? = ?\", params);\n    }", "docstring": "", "attributes": {"modifiers": "@Test(expected = SQLException.class)\n    public", "marker_annotations": [], "non_marker_annotations": ["@Test(expected = SQLException.class)", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testNullConnectionBatch", "params": [], "body": "                                                           {\n        final String[][] params = { { \"unit\", \"unit\" }, { \"test\", \"test\" } };\n\n        when(dataSource.getConnection()).thenReturn(null);\n\n        runner.batch(\"select * from blah where ? = ?\", params);\n    }", "signature": "@Test(expected = SQLException.class)\n    public void testNullConnectionBatch()"}, {"syntax_pass": true, "original_string": "    @Test(expected = SQLException.class)\n    public void testNullConnectionExecute() throws Exception {\n        when(dataSource.getConnection()).thenReturn(null);\n\n        runner.execute(\"{call my_proc(?, ?)}\", \"unit\", \"test\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test(expected = SQLException.class)\n    public", "marker_annotations": [], "non_marker_annotations": ["@Test(expected = SQLException.class)", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testNullConnectionExecute", "params": [], "body": "                                                             {\n        when(dataSource.getConnection()).thenReturn(null);\n\n        runner.execute(\"{call my_proc(?, ?)}\", \"unit\", \"test\");\n    }", "signature": "@Test(expected = SQLException.class)\n    public void testNullConnectionExecute()"}, {"syntax_pass": true, "original_string": "    @Test(expected = SQLException.class)\n    public void testNullConnectionExecuteWithResultSet() throws Exception {\n        when(dataSource.getConnection()).thenReturn(null);\n\n        runner.execute(\"{call my_proc(?, ?)}\", handler, \"unit\", \"test\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test(expected = SQLException.class)\n    public", "marker_annotations": [], "non_marker_annotations": ["@Test(expected = SQLException.class)", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testNullConnectionExecuteWithResultSet", "params": [], "body": "                                                                          {\n        when(dataSource.getConnection()).thenReturn(null);\n\n        runner.execute(\"{call my_proc(?, ?)}\", handler, \"unit\", \"test\");\n    }", "signature": "@Test(expected = SQLException.class)\n    public void testNullConnectionExecuteWithResultSet()"}, {"syntax_pass": true, "original_string": "    @Test(expected = SQLException.class)\n    public void testNullConnectionQuery() throws Exception {\n        when(dataSource.getConnection()).thenReturn(null);\n\n        runner.query(\"select * from blah where ? = ?\", handler, \"unit\", \"test\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test(expected = SQLException.class)\n    public", "marker_annotations": [], "non_marker_annotations": ["@Test(expected = SQLException.class)", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testNullConnectionQuery", "params": [], "body": "                                                           {\n        when(dataSource.getConnection()).thenReturn(null);\n\n        runner.query(\"select * from blah where ? = ?\", handler, \"unit\", \"test\");\n    }", "signature": "@Test(expected = SQLException.class)\n    public void testNullConnectionQuery()"}, {"syntax_pass": true, "original_string": "    @Test(expected = SQLException.class)\n    public void testNullConnectionUpdate() throws Exception {\n        when(dataSource.getConnection()).thenReturn(null);\n\n        runner.update(\"select * from blah where ? = ?\", \"unit\", \"test\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test(expected = SQLException.class)\n    public", "marker_annotations": [], "non_marker_annotations": ["@Test(expected = SQLException.class)", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testNullConnectionUpdate", "params": [], "body": "                                                            {\n        when(dataSource.getConnection()).thenReturn(null);\n\n        runner.update(\"select * from blah where ? = ?\", \"unit\", \"test\");\n    }", "signature": "@Test(expected = SQLException.class)\n    public void testNullConnectionUpdate()"}, {"syntax_pass": true, "original_string": "    @Test(expected = SQLException.class)\n    public void testNullHandlerExecute() throws Exception {\n        when(meta.getParameterCount()).thenReturn(2);\n\n        runner.execute(\"{call my_proc(?, ?)}\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test(expected = SQLException.class)\n    public", "marker_annotations": [], "non_marker_annotations": ["@Test(expected = SQLException.class)", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testNullHandlerExecute", "params": [], "body": "                                                          {\n        when(meta.getParameterCount()).thenReturn(2);\n\n        runner.execute(\"{call my_proc(?, ?)}\");\n    }", "signature": "@Test(expected = SQLException.class)\n    public void testNullHandlerExecute()"}, {"syntax_pass": true, "original_string": "    @Test(expected = SQLException.class)\n    public void testNullHandlerExecuteWithResultSet() throws Exception {\n        runner.execute(\"{call my_proc(?, ?)}\", (ResultSetHandler) null);\n    }", "docstring": "", "attributes": {"modifiers": "@Test(expected = SQLException.class)\n    public", "marker_annotations": [], "non_marker_annotations": ["@Test(expected = SQLException.class)", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testNullHandlerExecuteWithResultSet", "params": [], "body": "                                                                       {\n        runner.execute(\"{call my_proc(?, ?)}\", (ResultSetHandler) null);\n    }", "signature": "@Test(expected = SQLException.class)\n    public void testNullHandlerExecuteWithResultSet()"}, {"syntax_pass": true, "original_string": "    @Test(expected = SQLException.class)\n    public void testNullHandlerQuery() throws Exception {\n        runner.query(\"select * from blah where ? = ?\", null);\n    }", "docstring": "", "attributes": {"modifiers": "@Test(expected = SQLException.class)\n    public", "marker_annotations": [], "non_marker_annotations": ["@Test(expected = SQLException.class)", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testNullHandlerQuery", "params": [], "body": "                                                        {\n        runner.query(\"select * from blah where ? = ?\", null);\n    }", "signature": "@Test(expected = SQLException.class)\n    public void testNullHandlerQuery()"}, {"syntax_pass": true, "original_string": "    @Test(expected = SQLException.class)\n    public void testNullParamsArgBatch() throws Exception {\n        runner.batch(\"select * from blah where ? = ?\", null);\n    }", "docstring": "", "attributes": {"modifiers": "@Test(expected = SQLException.class)\n    public", "marker_annotations": [], "non_marker_annotations": ["@Test(expected = SQLException.class)", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testNullParamsArgBatch", "params": [], "body": "                                                          {\n        runner.batch(\"select * from blah where ? = ?\", null);\n    }", "signature": "@Test(expected = SQLException.class)\n    public void testNullParamsArgBatch()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testNullParamsBatch() throws Exception {\n        final String[][] params = { { null, \"unit\" }, { \"test\", null } };\n\n        callGoodBatch(params);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testNullParamsBatch", "params": [], "body": "                                                       {\n        final String[][] params = { { null, \"unit\" }, { \"test\", null } };\n\n        callGoodBatch(params);\n    }", "signature": "@Test\n    public void testNullParamsBatch()"}, {"syntax_pass": true, "original_string": "    @Test(expected = SQLException.class)\n    public void testNullSqlBatch() throws Exception {\n        final String[][] params = { { \"unit\", \"unit\" }, { \"test\", \"test\" } };\n\n        runner.batch(null, params);\n    }", "docstring": "", "attributes": {"modifiers": "@Test(expected = SQLException.class)\n    public", "marker_annotations": [], "non_marker_annotations": ["@Test(expected = SQLException.class)", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testNullSqlBatch", "params": [], "body": "                                                    {\n        final String[][] params = { { \"unit\", \"unit\" }, { \"test\", \"test\" } };\n\n        runner.batch(null, params);\n    }", "signature": "@Test(expected = SQLException.class)\n    public void testNullSqlBatch()"}, {"syntax_pass": true, "original_string": "    @Test(expected = SQLException.class)\n    public void testNullSqlExecute() throws Exception {\n        runner.execute(null);\n    }", "docstring": "", "attributes": {"modifiers": "@Test(expected = SQLException.class)\n    public", "marker_annotations": [], "non_marker_annotations": ["@Test(expected = SQLException.class)", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testNullSqlExecute", "params": [], "body": "                                                      {\n        runner.execute(null);\n    }", "signature": "@Test(expected = SQLException.class)\n    public void testNullSqlExecute()"}, {"syntax_pass": true, "original_string": "    @Test(expected = SQLException.class)\n    public void testNullSqlExecuteWithResultSet() throws Exception {\n        runner.execute(null, handler);\n    }", "docstring": "", "attributes": {"modifiers": "@Test(expected = SQLException.class)\n    public", "marker_annotations": [], "non_marker_annotations": ["@Test(expected = SQLException.class)", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testNullSqlExecuteWithResultSet", "params": [], "body": "                                                                   {\n        runner.execute(null, handler);\n    }", "signature": "@Test(expected = SQLException.class)\n    public void testNullSqlExecuteWithResultSet()"}, {"syntax_pass": true, "original_string": "    @Test(expected = SQLException.class)\n    public void testNullSqlQuery() throws Exception {\n        runner.query(null, handler);\n    }", "docstring": "", "attributes": {"modifiers": "@Test(expected = SQLException.class)\n    public", "marker_annotations": [], "non_marker_annotations": ["@Test(expected = SQLException.class)", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testNullSqlQuery", "params": [], "body": "                                                    {\n        runner.query(null, handler);\n    }", "signature": "@Test(expected = SQLException.class)\n    public void testNullSqlQuery()"}, {"syntax_pass": true, "original_string": "    @Test(expected = SQLException.class)\n    public void testNullSqlUpdate() throws Exception {\n        runner.update(null);\n    }", "docstring": "", "attributes": {"modifiers": "@Test(expected = SQLException.class)\n    public", "marker_annotations": [], "non_marker_annotations": ["@Test(expected = SQLException.class)", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testNullSqlUpdate", "params": [], "body": "                                                     {\n        runner.update(null);\n    }", "signature": "@Test(expected = SQLException.class)\n    public void testNullSqlUpdate()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testStatementConfiguration() throws Exception {\n        final StatementConfiguration stmtConfig = new StatementConfiguration(1, 2, 3, 4, 5);\n        final QueryRunner queryRunner = new QueryRunner(stmtConfig);\n        queryRunner.prepareStatement(conn, \"select 1\");\n\n        verify(prepStmt).setFetchDirection(eq(1));\n        verify(prepStmt).setFetchSize(eq(2));\n        verify(prepStmt).setMaxFieldSize(eq(3));\n        verify(prepStmt).setMaxRows(eq(4));\n        verify(prepStmt).setQueryTimeout(eq(5));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testStatementConfiguration", "params": [], "body": "                                                              {\n        final StatementConfiguration stmtConfig = new StatementConfiguration(1, 2, 3, 4, 5);\n        final QueryRunner queryRunner = new QueryRunner(stmtConfig);\n        queryRunner.prepareStatement(conn, \"select 1\");\n\n        verify(prepStmt).setFetchDirection(eq(1));\n        verify(prepStmt).setFetchSize(eq(2));\n        verify(prepStmt).setMaxFieldSize(eq(3));\n        verify(prepStmt).setMaxRows(eq(4));\n        verify(prepStmt).setQueryTimeout(eq(5));\n    }", "signature": "@Test\n    public void testStatementConfiguration()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testTooFewParamsBatch() throws Exception {\n        final String[][] params = { { \"unit\" }, { \"test\" } };\n\n        callBatchWithException(\"select * from blah where ? = ?\", params);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testTooFewParamsBatch", "params": [], "body": "                                                         {\n        final String[][] params = { { \"unit\" }, { \"test\" } };\n\n        callBatchWithException(\"select * from blah where ? = ?\", params);\n    }", "signature": "@Test\n    public void testTooFewParamsBatch()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testTooFewParamsExecute() throws Exception {\n        callExecuteWithException(\"unit\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testTooFewParamsExecute", "params": [], "body": "                                                           {\n        callExecuteWithException(\"unit\");\n    }", "signature": "@Test\n    public void testTooFewParamsExecute()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testTooFewParamsExecuteWithResultSet() throws Exception {\n        callExecuteWithResultSetWithException(\"unit\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testTooFewParamsExecuteWithResultSet", "params": [], "body": "                                                                        {\n        callExecuteWithResultSetWithException(\"unit\");\n    }", "signature": "@Test\n    public void testTooFewParamsExecuteWithResultSet()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testTooFewParamsQuery() throws Exception {\n        callQueryWithException(\"unit\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testTooFewParamsQuery", "params": [], "body": "                                                         {\n        callQueryWithException(\"unit\");\n    }", "signature": "@Test\n    public void testTooFewParamsQuery()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testTooFewParamsUpdate() throws Exception {\n        callUpdateWithException(\"unit\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testTooFewParamsUpdate", "params": [], "body": "                                                          {\n        callUpdateWithException(\"unit\");\n    }", "signature": "@Test\n    public void testTooFewParamsUpdate()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testTooManyParamsBatch() throws Exception {\n        final String[][] params = { { \"unit\", \"unit\", \"unit\" }, { \"test\", \"test\", \"test\" } };\n\n        callBatchWithException(\"select * from blah where ? = ?\", params);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testTooManyParamsBatch", "params": [], "body": "                                                          {\n        final String[][] params = { { \"unit\", \"unit\", \"unit\" }, { \"test\", \"test\", \"test\" } };\n\n        callBatchWithException(\"select * from blah where ? = ?\", params);\n    }", "signature": "@Test\n    public void testTooManyParamsBatch()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testTooManyParamsExecute() throws Exception {\n        callExecuteWithException(\"unit\", \"test\", \"fail\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testTooManyParamsExecute", "params": [], "body": "                                                            {\n        callExecuteWithException(\"unit\", \"test\", \"fail\");\n    }", "signature": "@Test\n    public void testTooManyParamsExecute()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testTooManyParamsExecuteWithResultSet() throws Exception {\n        callExecuteWithResultSetWithException(\"unit\", \"test\", \"fail\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testTooManyParamsExecuteWithResultSet", "params": [], "body": "                                                                         {\n        callExecuteWithResultSetWithException(\"unit\", \"test\", \"fail\");\n    }", "signature": "@Test\n    public void testTooManyParamsExecuteWithResultSet()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testTooManyParamsQuery() throws Exception {\n        callQueryWithException(\"unit\", \"test\", \"fail\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testTooManyParamsQuery", "params": [], "body": "                                                          {\n        callQueryWithException(\"unit\", \"test\", \"fail\");\n    }", "signature": "@Test\n    public void testTooManyParamsQuery()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testTooManyParamsUpdate() throws Exception {\n        callUpdateWithException(\"unit\", \"test\", \"fail\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testTooManyParamsUpdate", "params": [], "body": "                                                           {\n        callUpdateWithException(\"unit\", \"test\", \"fail\");\n    }", "signature": "@Test\n    public void testTooManyParamsUpdate()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/dbutils/StatementConfigurationTest.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\n\nimport java.time.Duration;\n\nimport org.junit.Test;\n\npublic class StatementConfigurationTest {\n    /**\n     * Test that a builder with all values set yields like values in the constructed configuration.\n     */\n    @Test\n    public void testBuilder() {\n        final StatementConfiguration.Builder builder = new StatementConfiguration.Builder().fetchDirection(1).fetchSize(2).maxFieldSize(3).maxRows(4)\n                .queryTimeout(5);\n        final StatementConfiguration config = builder.build();\n\n        assertTrue(config.isFetchDirectionSet());\n        assertEquals(Integer.valueOf(1), config.getFetchDirection());\n\n        assertTrue(config.isFetchSizeSet());\n        assertEquals(Integer.valueOf(2), config.getFetchSize());\n\n        assertTrue(config.isMaxFieldSizeSet());\n        assertEquals(Integer.valueOf(3), config.getMaxFieldSize());\n\n        assertTrue(config.isMaxRowsSet());\n        assertEquals(Integer.valueOf(4), config.getMaxRows());\n\n        assertTrue(config.isQueryTimeoutSet());\n        assertEquals(Integer.valueOf(5), config.getQueryTimeout());\n\n        assertTrue(config.isQueryTimeoutSet());\n        assertEquals(Duration.ofSeconds(5), config.getQueryTimeoutDuration());\n\n        final StatementConfiguration config2 = builder.queryTimeout(Duration.ofSeconds(3)).build();\n\n        assertTrue(config2.isQueryTimeoutSet());\n        assertEquals(Integer.valueOf(3), config2.getQueryTimeout());\n\n        assertTrue(config2.isQueryTimeoutSet());\n        assertEquals(Duration.ofSeconds(3), config2.getQueryTimeoutDuration());\n    }\n\n    /**\n     * Test that the constructor of {@code StatementConfiguration} correctly sets all values.\n     */\n    @Test\n    public void testConstructor() {\n        final StatementConfiguration config = new StatementConfiguration(1, 2, 3, 4, 5);\n\n        assertEquals(Integer.valueOf(1), config.getFetchDirection());\n        assertEquals(Integer.valueOf(2), config.getFetchSize());\n        assertEquals(Integer.valueOf(3), config.getMaxFieldSize());\n        assertEquals(Integer.valueOf(4), config.getMaxRows());\n        assertEquals(Integer.valueOf(5), config.getQueryTimeout());\n    }\n\n    /**\n     * Test that an empty builder yields null values for all configuration settings.\n     */\n    @Test\n    public void testEmptyBuilder() {\n        final StatementConfiguration config = new StatementConfiguration.Builder().build();\n\n        assertFalse(config.isFetchDirectionSet());\n        assertFalse(config.isFetchSizeSet());\n        assertFalse(config.isMaxFieldSizeSet());\n        assertFalse(config.isMaxRowsSet());\n        assertFalse(config.isQueryTimeoutSet());\n    }\n}\n", "file_hash": "b6f7d12640a3701418cb88ff363f809217e6c14fafa2a0afd39215758c151714", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils;", "import static org.junit.Assert.assertEquals;", "import static org.junit.Assert.assertFalse;", "import static org.junit.Assert.assertTrue;", "import java.time.Duration;", "import org.junit.Test;"], "methods": [], "classes": [{"original_string": "public class StatementConfigurationTest {\n    /**\n     * Test that a builder with all values set yields like values in the constructed configuration.\n     */\n    @Test\n    public void testBuilder() {\n        final StatementConfiguration.Builder builder = new StatementConfiguration.Builder().fetchDirection(1).fetchSize(2).maxFieldSize(3).maxRows(4)\n                .queryTimeout(5);\n        final StatementConfiguration config = builder.build();\n\n        assertTrue(config.isFetchDirectionSet());\n        assertEquals(Integer.valueOf(1), config.getFetchDirection());\n\n        assertTrue(config.isFetchSizeSet());\n        assertEquals(Integer.valueOf(2), config.getFetchSize());\n\n        assertTrue(config.isMaxFieldSizeSet());\n        assertEquals(Integer.valueOf(3), config.getMaxFieldSize());\n\n        assertTrue(config.isMaxRowsSet());\n        assertEquals(Integer.valueOf(4), config.getMaxRows());\n\n        assertTrue(config.isQueryTimeoutSet());\n        assertEquals(Integer.valueOf(5), config.getQueryTimeout());\n\n        assertTrue(config.isQueryTimeoutSet());\n        assertEquals(Duration.ofSeconds(5), config.getQueryTimeoutDuration());\n\n        final StatementConfiguration config2 = builder.queryTimeout(Duration.ofSeconds(3)).build();\n\n        assertTrue(config2.isQueryTimeoutSet());\n        assertEquals(Integer.valueOf(3), config2.getQueryTimeout());\n\n        assertTrue(config2.isQueryTimeoutSet());\n        assertEquals(Duration.ofSeconds(3), config2.getQueryTimeoutDuration());\n    }\n\n    /**\n     * Test that the constructor of {@code StatementConfiguration} correctly sets all values.\n     */\n    @Test\n    public void testConstructor() {\n        final StatementConfiguration config = new StatementConfiguration(1, 2, 3, 4, 5);\n\n        assertEquals(Integer.valueOf(1), config.getFetchDirection());\n        assertEquals(Integer.valueOf(2), config.getFetchSize());\n        assertEquals(Integer.valueOf(3), config.getMaxFieldSize());\n        assertEquals(Integer.valueOf(4), config.getMaxRows());\n        assertEquals(Integer.valueOf(5), config.getQueryTimeout());\n    }\n\n    /**\n     * Test that an empty builder yields null values for all configuration settings.\n     */\n    @Test\n    public void testEmptyBuilder() {\n        final StatementConfiguration config = new StatementConfiguration.Builder().build();\n\n        assertFalse(config.isFetchDirectionSet());\n        assertFalse(config.isFetchSizeSet());\n        assertFalse(config.isMaxFieldSizeSet());\n        assertFalse(config.isMaxRowsSet());\n        assertFalse(config.isQueryTimeoutSet());\n    }\n}", "definition": "public class StatementConfigurationTest", "class_docstring": "", "name": "StatementConfigurationTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void testBuilder() {\n        final StatementConfiguration.Builder builder = new StatementConfiguration.Builder().fetchDirection(1).fetchSize(2).maxFieldSize(3).maxRows(4)\n                .queryTimeout(5);\n        final StatementConfiguration config = builder.build();\n\n        assertTrue(config.isFetchDirectionSet());\n        assertEquals(Integer.valueOf(1), config.getFetchDirection());\n\n        assertTrue(config.isFetchSizeSet());\n        assertEquals(Integer.valueOf(2), config.getFetchSize());\n\n        assertTrue(config.isMaxFieldSizeSet());\n        assertEquals(Integer.valueOf(3), config.getMaxFieldSize());\n\n        assertTrue(config.isMaxRowsSet());\n        assertEquals(Integer.valueOf(4), config.getMaxRows());\n\n        assertTrue(config.isQueryTimeoutSet());\n        assertEquals(Integer.valueOf(5), config.getQueryTimeout());\n\n        assertTrue(config.isQueryTimeoutSet());\n        assertEquals(Duration.ofSeconds(5), config.getQueryTimeoutDuration());\n\n        final StatementConfiguration config2 = builder.queryTimeout(Duration.ofSeconds(3)).build();\n\n        assertTrue(config2.isQueryTimeoutSet());\n        assertEquals(Integer.valueOf(3), config2.getQueryTimeout());\n\n        assertTrue(config2.isQueryTimeoutSet());\n        assertEquals(Duration.ofSeconds(3), config2.getQueryTimeoutDuration());\n    }", "docstring": "\nTest that a builder with all values set yields like values in the constructed configuration.\n", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testBuilder", "params": [], "body": "                              {\n        final StatementConfiguration.Builder builder = new StatementConfiguration.Builder().fetchDirection(1).fetchSize(2).maxFieldSize(3).maxRows(4)\n                .queryTimeout(5);\n        final StatementConfiguration config = builder.build();\n\n        assertTrue(config.isFetchDirectionSet());\n        assertEquals(Integer.valueOf(1), config.getFetchDirection());\n\n        assertTrue(config.isFetchSizeSet());\n        assertEquals(Integer.valueOf(2), config.getFetchSize());\n\n        assertTrue(config.isMaxFieldSizeSet());\n        assertEquals(Integer.valueOf(3), config.getMaxFieldSize());\n\n        assertTrue(config.isMaxRowsSet());\n        assertEquals(Integer.valueOf(4), config.getMaxRows());\n\n        assertTrue(config.isQueryTimeoutSet());\n        assertEquals(Integer.valueOf(5), config.getQueryTimeout());\n\n        assertTrue(config.isQueryTimeoutSet());\n        assertEquals(Duration.ofSeconds(5), config.getQueryTimeoutDuration());\n\n        final StatementConfiguration config2 = builder.queryTimeout(Duration.ofSeconds(3)).build();\n\n        assertTrue(config2.isQueryTimeoutSet());\n        assertEquals(Integer.valueOf(3), config2.getQueryTimeout());\n\n        assertTrue(config2.isQueryTimeoutSet());\n        assertEquals(Duration.ofSeconds(3), config2.getQueryTimeoutDuration());\n    }", "signature": "@Test\n    public void testBuilder()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testConstructor() {\n        final StatementConfiguration config = new StatementConfiguration(1, 2, 3, 4, 5);\n\n        assertEquals(Integer.valueOf(1), config.getFetchDirection());\n        assertEquals(Integer.valueOf(2), config.getFetchSize());\n        assertEquals(Integer.valueOf(3), config.getMaxFieldSize());\n        assertEquals(Integer.valueOf(4), config.getMaxRows());\n        assertEquals(Integer.valueOf(5), config.getQueryTimeout());\n    }", "docstring": "\nTest that the constructor of {@code StatementConfiguration} correctly sets all values.\n", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testConstructor", "params": [], "body": "                                  {\n        final StatementConfiguration config = new StatementConfiguration(1, 2, 3, 4, 5);\n\n        assertEquals(Integer.valueOf(1), config.getFetchDirection());\n        assertEquals(Integer.valueOf(2), config.getFetchSize());\n        assertEquals(Integer.valueOf(3), config.getMaxFieldSize());\n        assertEquals(Integer.valueOf(4), config.getMaxRows());\n        assertEquals(Integer.valueOf(5), config.getQueryTimeout());\n    }", "signature": "@Test\n    public void testConstructor()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testEmptyBuilder() {\n        final StatementConfiguration config = new StatementConfiguration.Builder().build();\n\n        assertFalse(config.isFetchDirectionSet());\n        assertFalse(config.isFetchSizeSet());\n        assertFalse(config.isMaxFieldSizeSet());\n        assertFalse(config.isMaxRowsSet());\n        assertFalse(config.isQueryTimeoutSet());\n    }", "docstring": "\nTest that an empty builder yields null values for all configuration settings.\n", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testEmptyBuilder", "params": [], "body": "                                   {\n        final StatementConfiguration config = new StatementConfiguration.Builder().build();\n\n        assertFalse(config.isFetchDirectionSet());\n        assertFalse(config.isFetchSizeSet());\n        assertFalse(config.isMaxFieldSizeSet());\n        assertFalse(config.isMaxRowsSet());\n        assertFalse(config.isQueryTimeoutSet());\n    }", "signature": "@Test\n    public void testEmptyBuilder()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/dbutils/ProxyFactoryTest.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils;\n\nimport java.lang.reflect.InvocationHandler;\n\n/**\n * ProxyFactoryTest performs simple type checking on proxy objects returned from a ProxyFactory.\n */\npublic class ProxyFactoryTest extends BaseTestCase {\n\n    private static final InvocationHandler stub = (proxy, method, args) -> null;\n\n    public void testCreateCallableStatement() {\n        assertNotNull(ProxyFactory.instance().createCallableStatement(stub));\n    }\n\n    public void testCreateConnection() {\n        assertNotNull(ProxyFactory.instance().createConnection(stub));\n    }\n\n    public void testCreateDriver() {\n        assertNotNull(ProxyFactory.instance().createDriver(stub));\n    }\n\n    public void testCreatePreparedStatement() {\n        assertNotNull(ProxyFactory.instance().createPreparedStatement(stub));\n    }\n\n    public void testCreateResultSet() {\n        assertNotNull(ProxyFactory.instance().createResultSet(stub));\n    }\n\n    public void testCreateResultSetMetaData() {\n        assertNotNull(ProxyFactory.instance().createResultSetMetaData(stub));\n    }\n\n    public void testCreateStatement() {\n        assertNotNull(ProxyFactory.instance().createStatement(stub));\n    }\n\n}\n", "file_hash": "cbaeba05a9b4fb1d414f8abcd0eb6a5a8f378cb5d082156e04e7179e5b0911b6", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils;", "import java.lang.reflect.InvocationHandler;"], "methods": [], "classes": [{"original_string": "public class ProxyFactoryTest extends BaseTestCase {\n\n    private static final InvocationHandler stub = (proxy, method, args) -> null;\n\n    public void testCreateCallableStatement() {\n        assertNotNull(ProxyFactory.instance().createCallableStatement(stub));\n    }\n\n    public void testCreateConnection() {\n        assertNotNull(ProxyFactory.instance().createConnection(stub));\n    }\n\n    public void testCreateDriver() {\n        assertNotNull(ProxyFactory.instance().createDriver(stub));\n    }\n\n    public void testCreatePreparedStatement() {\n        assertNotNull(ProxyFactory.instance().createPreparedStatement(stub));\n    }\n\n    public void testCreateResultSet() {\n        assertNotNull(ProxyFactory.instance().createResultSet(stub));\n    }\n\n    public void testCreateResultSetMetaData() {\n        assertNotNull(ProxyFactory.instance().createResultSetMetaData(stub));\n    }\n\n    public void testCreateStatement() {\n        assertNotNull(ProxyFactory.instance().createStatement(stub));\n    }\n\n}", "definition": "public class ProxyFactoryTest extends BaseTestCase", "class_docstring": "\nProxyFactoryTest performs simple type checking on proxy objects returned from a ProxyFactory.\n", "name": "ProxyFactoryTest", "super_interfaces": [], "superclasses": "BaseTestCase", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private static final InvocationHandler stub = (proxy, method, args) -> null;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "InvocationHandler", "name": "stub = (proxy, method, args) -> null", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public void testCreateCallableStatement() {\n        assertNotNull(ProxyFactory.instance().createCallableStatement(stub));\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testCreateCallableStatement", "params": [], "body": "                                              {\n        assertNotNull(ProxyFactory.instance().createCallableStatement(stub));\n    }", "signature": "public void testCreateCallableStatement()"}, {"syntax_pass": true, "original_string": "    public void testCreateConnection() {\n        assertNotNull(ProxyFactory.instance().createConnection(stub));\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testCreateConnection", "params": [], "body": "                                       {\n        assertNotNull(ProxyFactory.instance().createConnection(stub));\n    }", "signature": "public void testCreateConnection()"}, {"syntax_pass": true, "original_string": "    public void testCreateDriver() {\n        assertNotNull(ProxyFactory.instance().createDriver(stub));\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testCreateDriver", "params": [], "body": "                                   {\n        assertNotNull(ProxyFactory.instance().createDriver(stub));\n    }", "signature": "public void testCreateDriver()"}, {"syntax_pass": true, "original_string": "    public void testCreatePreparedStatement() {\n        assertNotNull(ProxyFactory.instance().createPreparedStatement(stub));\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testCreatePreparedStatement", "params": [], "body": "                                              {\n        assertNotNull(ProxyFactory.instance().createPreparedStatement(stub));\n    }", "signature": "public void testCreatePreparedStatement()"}, {"syntax_pass": true, "original_string": "    public void testCreateResultSet() {\n        assertNotNull(ProxyFactory.instance().createResultSet(stub));\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testCreateResultSet", "params": [], "body": "                                      {\n        assertNotNull(ProxyFactory.instance().createResultSet(stub));\n    }", "signature": "public void testCreateResultSet()"}, {"syntax_pass": true, "original_string": "    public void testCreateResultSetMetaData() {\n        assertNotNull(ProxyFactory.instance().createResultSetMetaData(stub));\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testCreateResultSetMetaData", "params": [], "body": "                                              {\n        assertNotNull(ProxyFactory.instance().createResultSetMetaData(stub));\n    }", "signature": "public void testCreateResultSetMetaData()"}, {"syntax_pass": true, "original_string": "    public void testCreateStatement() {\n        assertNotNull(ProxyFactory.instance().createStatement(stub));\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testCreateStatement", "params": [], "body": "                                      {\n        assertNotNull(ProxyFactory.instance().createStatement(stub));\n    }", "signature": "public void testCreateStatement()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/dbutils/BaseTestCase.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils;\n\nimport java.math.BigInteger;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.Timestamp;\nimport java.util.Date;\n\nimport junit.framework.TestCase;\n\n/**\n * BaseTestCase is the base class for all test cases as well as the \"all tests\" runner.\n */\npublic class BaseTestCase extends TestCase {\n\n    private static final String[] columnNames = { \"one\", \"two\", \"three\", \"notInBean\", \"intTest\", \"integerTest\", \"nullObjectTest\", \"nullPrimitiveTest\",\n            \"notDate\", \"columnProcessorDoubleTest\", null };\n\n    /**\n     * The number of columns in the MockResultSet.\n     */\n    protected static final int COLS = columnNames.length;\n\n    protected static final ResultSetMetaData metaData = MockResultSetMetaData.create(columnNames);\n\n    /**\n     * A Timestamp for test purposes having 9 decimals\n     */\n    static final Timestamp ts789456123;\n\n    static {\n        ts789456123 = new Timestamp(new Date().getTime());\n        ts789456123.setNanos(789456123);\n    }\n\n    private static final Object[] row1 = { \"1\", \"2\", \"THREE\", \"  notInBean  \", Integer.valueOf(1), Integer.valueOf(2), null, null, new Date(),\n            BigInteger.valueOf(13), null };\n\n    private static final Object[] row2 = { \"4\", \"5\", \"SIX\", \"  notInBean  \", Integer.valueOf(3), Integer.valueOf(4), null, null, ts789456123,\n            BigInteger.valueOf(13), null };\n\n    private static final Object[][] rows = { row1, row2 };\n\n    /**\n     * The number of rows in the MockResultSet.\n     */\n    protected static final int ROWS = rows.length;\n\n    /**\n     * The ResultSet all test methods will use.\n     */\n    private ResultSet rs;\n\n    /**\n     * A ResultSet with 0 rows.\n     */\n    private ResultSet emptyResultSet;\n\n    /**\n     * Creates a freshly initialized ResultSet.\n     */\n    protected ResultSet createMockResultSet() {\n        return MockResultSet.create(metaData, rows);\n    }\n\n    public ResultSet getEmptyResultSet() {\n        return this.emptyResultSet;\n    }\n\n    public ResultSet getResultSet() {\n        return this.rs;\n    }\n\n    public void setResultSet(final ResultSet resultSet) {\n        this.rs = resultSet;\n    }\n\n    /**\n     * This is called before each test method so ResultSet will be fresh each time.\n     *\n     * @see junit.framework.TestCase#setUp()\n     */\n    @Override\n    protected void setUp() throws Exception {\n        super.setUp();\n\n        rs = createMockResultSet();\n        emptyResultSet = MockResultSet.create(metaData, null);\n    }\n\n    // Test which allows Eclipse to be run on full project (avoids no tests found)\n    // check that the rows are valid for the column definition\n    public void testCheckDataSizes() {\n        assertEquals(\"Row 1 must contain correct number of columns\", columnNames.length, row1.length);\n        assertEquals(\"Row 1 must contain correct number of columns\", columnNames.length, row2.length);\n    }\n\n    public void testResultSets() throws Exception {\n        assertFalse(\"emptyResultSet should be empty\", emptyResultSet.next());\n        // fails in SqlNullCheckedResultSetTest assertTrue(\"rs should not be empty\", rs.next());\n    }\n}\n", "file_hash": "1158f604a139c920583950e1c970e8dcd8ff95a845b3466c3256715cfc821f2f", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils;", "import java.math.BigInteger;", "import java.sql.ResultSet;", "import java.sql.ResultSetMetaData;", "import java.sql.Timestamp;", "import java.util.Date;", "import junit.framework.TestCase;"], "methods": [], "classes": [{"original_string": "public class BaseTestCase extends TestCase {\n\n    private static final String[] columnNames = { \"one\", \"two\", \"three\", \"notInBean\", \"intTest\", \"integerTest\", \"nullObjectTest\", \"nullPrimitiveTest\",\n            \"notDate\", \"columnProcessorDoubleTest\", null };\n\n    /**\n     * The number of columns in the MockResultSet.\n     */\n    protected static final int COLS = columnNames.length;\n\n    protected static final ResultSetMetaData metaData = MockResultSetMetaData.create(columnNames);\n\n    /**\n     * A Timestamp for test purposes having 9 decimals\n     */\n    static final Timestamp ts789456123;\n\n    static {\n        ts789456123 = new Timestamp(new Date().getTime());\n        ts789456123.setNanos(789456123);\n    }\n\n    private static final Object[] row1 = { \"1\", \"2\", \"THREE\", \"  notInBean  \", Integer.valueOf(1), Integer.valueOf(2), null, null, new Date(),\n            BigInteger.valueOf(13), null };\n\n    private static final Object[] row2 = { \"4\", \"5\", \"SIX\", \"  notInBean  \", Integer.valueOf(3), Integer.valueOf(4), null, null, ts789456123,\n            BigInteger.valueOf(13), null };\n\n    private static final Object[][] rows = { row1, row2 };\n\n    /**\n     * The number of rows in the MockResultSet.\n     */\n    protected static final int ROWS = rows.length;\n\n    /**\n     * The ResultSet all test methods will use.\n     */\n    private ResultSet rs;\n\n    /**\n     * A ResultSet with 0 rows.\n     */\n    private ResultSet emptyResultSet;\n\n    /**\n     * Creates a freshly initialized ResultSet.\n     */\n    protected ResultSet createMockResultSet() {\n        return MockResultSet.create(metaData, rows);\n    }\n\n    public ResultSet getEmptyResultSet() {\n        return this.emptyResultSet;\n    }\n\n    public ResultSet getResultSet() {\n        return this.rs;\n    }\n\n    public void setResultSet(final ResultSet resultSet) {\n        this.rs = resultSet;\n    }\n\n    /**\n     * This is called before each test method so ResultSet will be fresh each time.\n     *\n     * @see junit.framework.TestCase#setUp()\n     */\n    @Override\n    protected void setUp() throws Exception {\n        super.setUp();\n\n        rs = createMockResultSet();\n        emptyResultSet = MockResultSet.create(metaData, null);\n    }\n\n    // Test which allows Eclipse to be run on full project (avoids no tests found)\n    // check that the rows are valid for the column definition\n    public void testCheckDataSizes() {\n        assertEquals(\"Row 1 must contain correct number of columns\", columnNames.length, row1.length);\n        assertEquals(\"Row 1 must contain correct number of columns\", columnNames.length, row2.length);\n    }\n\n    public void testResultSets() throws Exception {\n        assertFalse(\"emptyResultSet should be empty\", emptyResultSet.next());\n        // fails in SqlNullCheckedResultSetTest assertTrue(\"rs should not be empty\", rs.next());\n    }\n}", "definition": "public class BaseTestCase extends TestCase", "class_docstring": "\nBaseTestCase is the base class for all test cases as well as the \"all tests\" runner.\n", "name": "BaseTestCase", "super_interfaces": [], "superclasses": "TestCase", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private static final String[] columnNames = { \"one\", \"two\", \"three\", \"notInBean\", \"intTest\", \"integerTest\", \"nullObjectTest\", \"nullPrimitiveTest\",\n            \"notDate\", \"columnProcessorDoubleTest\", null };", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String[]", "name": "columnNames = { \"one\", \"two\", \"three\", \"notInBean\", \"intTest\", \"integerTest\", \"nullObjectTest\", \"nullPrimitiveTest\",\n            \"notDate\", \"columnProcessorDoubleTest\", null }", "syntax_pass": true}, {"attribute_expression": "protected static final int COLS = columnNames.length;", "docstring": "\nThe number of columns in the MockResultSet.\n", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "int", "name": "COLS = columnNames.length", "syntax_pass": true}, {"attribute_expression": "protected static final ResultSetMetaData metaData = MockResultSetMetaData.create(columnNames);", "docstring": "", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "ResultSetMetaData", "name": "metaData = MockResultSetMetaData.create(columnNames)", "syntax_pass": true}, {"attribute_expression": "static final Timestamp ts789456123;", "docstring": "\nA Timestamp for test purposes having 9 decimals\n", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "Timestamp", "name": "ts789456123", "syntax_pass": true}, {"attribute_expression": "private static final Object[] row1 = { \"1\", \"2\", \"THREE\", \"  notInBean  \", Integer.valueOf(1), Integer.valueOf(2), null, null, new Date(),\n            BigInteger.valueOf(13), null };", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Object[]", "name": "row1 = { \"1\", \"2\", \"THREE\", \"  notInBean  \", Integer.valueOf(1), Integer.valueOf(2), null, null, new Date(),\n            BigInteger.valueOf(13), null }", "syntax_pass": true}, {"attribute_expression": "private static final Object[] row2 = { \"4\", \"5\", \"SIX\", \"  notInBean  \", Integer.valueOf(3), Integer.valueOf(4), null, null, ts789456123,\n            BigInteger.valueOf(13), null };", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Object[]", "name": "row2 = { \"4\", \"5\", \"SIX\", \"  notInBean  \", Integer.valueOf(3), Integer.valueOf(4), null, null, ts789456123,\n            BigInteger.valueOf(13), null }", "syntax_pass": true}, {"attribute_expression": "private static final Object[][] rows = { row1, row2 };", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Object[][]", "name": "rows = { row1, row2 }", "syntax_pass": true}, {"attribute_expression": "protected static final int ROWS = rows.length;", "docstring": "\nThe number of rows in the MockResultSet.\n", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "int", "name": "ROWS = rows.length", "syntax_pass": true}, {"attribute_expression": "private ResultSet rs;", "docstring": "\nThe ResultSet all test methods will use.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ResultSet", "name": "rs", "syntax_pass": true}, {"attribute_expression": "private ResultSet emptyResultSet;", "docstring": "\nA ResultSet with 0 rows.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ResultSet", "name": "emptyResultSet", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    protected ResultSet createMockResultSet() {\n        return MockResultSet.create(metaData, rows);\n    }", "docstring": "\nCreates a freshly initialized ResultSet.\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "ResultSet", "classes": []}, "name": "createMockResultSet", "params": [], "body": "                                              {\n        return MockResultSet.create(metaData, rows);\n    }", "signature": "protected ResultSet createMockResultSet()"}, {"syntax_pass": true, "original_string": "    public ResultSet getEmptyResultSet() {\n        return this.emptyResultSet;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ResultSet", "classes": []}, "name": "getEmptyResultSet", "params": [], "body": "                                         {\n        return this.emptyResultSet;\n    }", "signature": "public ResultSet getEmptyResultSet()"}, {"syntax_pass": true, "original_string": "    public ResultSet getResultSet() {\n        return this.rs;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ResultSet", "classes": []}, "name": "getResultSet", "params": [], "body": "                                    {\n        return this.rs;\n    }", "signature": "public ResultSet getResultSet()"}, {"syntax_pass": true, "original_string": "    public void setResultSet(final ResultSet resultSet) {\n        this.rs = resultSet;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setResultSet", "params": [{"name": "resultSet", "type": "ResultSet"}], "body": "                                                        {\n        this.rs = resultSet;\n    }", "signature": "public void setResultSet(final ResultSet resultSet)"}, {"syntax_pass": true, "original_string": "    @Override\n    protected void setUp() throws Exception {\n        super.setUp();\n\n        rs = createMockResultSet();\n        emptyResultSet = MockResultSet.create(metaData, null);\n    }", "docstring": "\nThis is called before each test method so ResultSet will be fresh each time.\n\n@see junit.framework.TestCase#setUp()\n", "attributes": {"modifiers": "@Override\n    protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "name": "setUp", "params": [], "body": "                                            {\n        super.setUp();\n\n        rs = createMockResultSet();\n        emptyResultSet = MockResultSet.create(metaData, null);\n    }", "signature": "@Override\n    protected void setUp()"}, {"syntax_pass": true, "original_string": "    public void testCheckDataSizes() {\n        assertEquals(\"Row 1 must contain correct number of columns\", columnNames.length, row1.length);\n        assertEquals(\"Row 1 must contain correct number of columns\", columnNames.length, row2.length);\n    }", "docstring": " check that the rows are valid for the column definition", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testCheckDataSizes", "params": [], "body": "                                     {\n        assertEquals(\"Row 1 must contain correct number of columns\", columnNames.length, row1.length);\n        assertEquals(\"Row 1 must contain correct number of columns\", columnNames.length, row2.length);\n    }", "signature": "public void testCheckDataSizes()"}, {"syntax_pass": true, "original_string": "    public void testResultSets() throws Exception {\n        assertFalse(\"emptyResultSet should be empty\", emptyResultSet.next());\n        // fails in SqlNullCheckedResultSetTest assertTrue(\"rs should not be empty\", rs.next());\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testResultSets", "params": [], "body": "                                                  {\n        assertFalse(\"emptyResultSet should be empty\", emptyResultSet.next());\n        // fails in SqlNullCheckedResultSetTest assertTrue(\"rs should not be empty\", rs.next());\n    }", "signature": "public void testResultSets()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/dbutils/BasicRowProcessorTest.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils;\n\nimport java.sql.SQLException;\nimport java.text.DateFormat;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\n\n/**\n * Test the BasicRowProcessor class.\n */\npublic class BasicRowProcessorTest extends BaseTestCase {\n\n    private static final RowProcessor processor = new BasicRowProcessor();\n\n    /**\n     * Format that matches Date.toString(). Sun Mar 14 15:19:15 MST 2004\n     */\n    private static final DateFormat datef = new SimpleDateFormat(\"EEE MMM dd HH:mm:ss zzz yyyy\", Locale.US);\n\n    public void testPutAllContainsKeyAndRemove() throws Exception {\n        final Map<String, Object> test = new HashMap<>(3);\n        test.put(\"fiRst\", \"thing\");\n        test.put(\"seCond\", \"another\");\n        test.put(\"thIrd\", \"more\");\n        final Map<String, Object> brpMap = BasicRowProcessor.createCaseInsensitiveHashMap(3);\n        brpMap.putAll(test);\n\n        assertEquals(test, brpMap);\n        assertTrue(brpMap.containsKey(\"fiRst\"));\n        assertTrue(brpMap.containsKey(\"first\"));\n\n        brpMap.remove(\"first\");\n        assertFalse(brpMap.containsKey(\"first\"));\n    }\n\n    public void testToArray() throws SQLException {\n\n        Object[] a;\n        assertTrue(getResultSet().next());\n        a = processor.toArray(getResultSet());\n        assertEquals(COLS, a.length);\n        assertEquals(\"1\", a[0]);\n        assertEquals(\"2\", a[1]);\n        assertEquals(\"THREE\", a[2]);\n\n        assertTrue(getResultSet().next());\n        a = processor.toArray(getResultSet());\n        assertEquals(COLS, a.length);\n\n        assertEquals(\"4\", a[0]);\n        assertEquals(\"5\", a[1]);\n        assertEquals(\"SIX\", a[2]);\n\n        assertFalse(getResultSet().next());\n    }\n\n    public void testToBean() throws SQLException, ParseException {\n\n        assertTrue(getResultSet().next());\n        TestBean row = processor.toBean(getResultSet(), TestBean.class);\n        assertEquals(\"1\", row.getOne());\n        assertEquals(\"2\", row.getTwo());\n        assertEquals(TestBean.Ordinal.THREE, row.getThree());\n        assertEquals(\"not set\", row.getDoNotSet());\n\n        assertTrue(getResultSet().next());\n        row = processor.toBean(getResultSet(), TestBean.class);\n\n        assertEquals(\"4\", row.getOne());\n        assertEquals(\"5\", row.getTwo());\n        assertEquals(TestBean.Ordinal.SIX, row.getThree());\n        assertEquals(\"not set\", row.getDoNotSet());\n        assertEquals(3, row.getIntTest());\n        assertEquals(Integer.valueOf(4), row.getIntegerTest());\n        assertNull(row.getNullObjectTest());\n        assertEquals(0, row.getNullPrimitiveTest());\n        // test date -> string handling\n        assertNotNull(row.getNotDate());\n        assertTrue(!\"not a date\".equals(row.getNotDate()));\n        assertTrue(row.getNotDate().endsWith(\"789456123\"));\n\n        assertFalse(getResultSet().next());\n\n    }\n\n    public void testToBeanList() throws SQLException, ParseException {\n\n        final List<TestBean> list = processor.toBeanList(getResultSet(), TestBean.class);\n        assertNotNull(list);\n        assertEquals(ROWS, list.size());\n\n        TestBean b = list.get(0);\n        assertEquals(\"1\", b.getOne());\n        assertEquals(\"2\", b.getTwo());\n        assertEquals(TestBean.Ordinal.THREE, b.getThree());\n        assertEquals(\"not set\", b.getDoNotSet());\n        datef.parse(b.getNotDate());\n\n        b = list.get(1);\n        assertEquals(\"4\", b.getOne());\n        assertEquals(\"5\", b.getTwo());\n        assertEquals(TestBean.Ordinal.SIX, b.getThree());\n        assertEquals(\"not set\", b.getDoNotSet());\n        assertEquals(3, b.getIntTest());\n        assertEquals(Integer.valueOf(4), b.getIntegerTest());\n        assertNull(b.getNullObjectTest());\n        assertEquals(0, b.getNullPrimitiveTest());\n        // test date -> string handling\n        assertNotNull(b.getNotDate());\n        assertTrue(!\"not a date\".equals(b.getNotDate()));\n        assertTrue(b.getNotDate().endsWith(\"789456123\"));\n    }\n\n    public void testToMap() throws SQLException {\n\n        assertTrue(getResultSet().next());\n        Map<String, Object> m = processor.toMap(getResultSet());\n        assertEquals(COLS, m.size());\n        assertEquals(\"1\", m.get(\"one\"));\n        assertEquals(\"2\", m.get(\"TWO\"));\n        assertEquals(\"THREE\", m.get(\"Three\"));\n\n        assertTrue(getResultSet().next());\n        m = processor.toMap(getResultSet());\n        assertEquals(COLS, m.size());\n\n        assertEquals(\"4\", m.get(\"One\")); // case shouldn't matter\n        assertEquals(\"5\", m.get(\"two\"));\n        assertEquals(\"SIX\", m.get(\"THREE\"));\n\n        assertFalse(getResultSet().next());\n    }\n\n    public void testToMapOrdering() throws SQLException {\n\n        assertTrue(getResultSet().next());\n        final Map<String, Object> m = processor.toMap(getResultSet());\n\n        final Iterator<String> itr = m.keySet().iterator();\n        assertEquals(\"one\", itr.next());\n        assertEquals(\"two\", itr.next());\n        assertEquals(\"three\", itr.next());\n        assertEquals(\"notInBean\", itr.next());\n        assertEquals(\"intTest\", itr.next());\n        assertEquals(\"integerTest\", itr.next());\n        assertEquals(\"nullObjectTest\", itr.next());\n        assertEquals(\"nullPrimitiveTest\", itr.next());\n        assertEquals(\"notDate\", itr.next());\n        assertEquals(\"columnProcessorDoubleTest\", itr.next());\n        assertEquals(\"11\", itr.next());\n\n        assertFalse(itr.hasNext());\n    }\n}\n", "file_hash": "566b10566978cccab84f6f88246f4cb76074a481dc5753082eabe53153b00d50", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils;", "import java.sql.SQLException;", "import java.text.DateFormat;", "import java.text.ParseException;", "import java.text.SimpleDateFormat;", "import java.util.HashMap;", "import java.util.Iterator;", "import java.util.List;", "import java.util.Locale;", "import java.util.Map;"], "methods": [], "classes": [{"original_string": "public class BasicRowProcessorTest extends BaseTestCase {\n\n    private static final RowProcessor processor = new BasicRowProcessor();\n\n    /**\n     * Format that matches Date.toString(). Sun Mar 14 15:19:15 MST 2004\n     */\n    private static final DateFormat datef = new SimpleDateFormat(\"EEE MMM dd HH:mm:ss zzz yyyy\", Locale.US);\n\n    public void testPutAllContainsKeyAndRemove() throws Exception {\n        final Map<String, Object> test = new HashMap<>(3);\n        test.put(\"fiRst\", \"thing\");\n        test.put(\"seCond\", \"another\");\n        test.put(\"thIrd\", \"more\");\n        final Map<String, Object> brpMap = BasicRowProcessor.createCaseInsensitiveHashMap(3);\n        brpMap.putAll(test);\n\n        assertEquals(test, brpMap);\n        assertTrue(brpMap.containsKey(\"fiRst\"));\n        assertTrue(brpMap.containsKey(\"first\"));\n\n        brpMap.remove(\"first\");\n        assertFalse(brpMap.containsKey(\"first\"));\n    }\n\n    public void testToArray() throws SQLException {\n\n        Object[] a;\n        assertTrue(getResultSet().next());\n        a = processor.toArray(getResultSet());\n        assertEquals(COLS, a.length);\n        assertEquals(\"1\", a[0]);\n        assertEquals(\"2\", a[1]);\n        assertEquals(\"THREE\", a[2]);\n\n        assertTrue(getResultSet().next());\n        a = processor.toArray(getResultSet());\n        assertEquals(COLS, a.length);\n\n        assertEquals(\"4\", a[0]);\n        assertEquals(\"5\", a[1]);\n        assertEquals(\"SIX\", a[2]);\n\n        assertFalse(getResultSet().next());\n    }\n\n    public void testToBean() throws SQLException, ParseException {\n\n        assertTrue(getResultSet().next());\n        TestBean row = processor.toBean(getResultSet(), TestBean.class);\n        assertEquals(\"1\", row.getOne());\n        assertEquals(\"2\", row.getTwo());\n        assertEquals(TestBean.Ordinal.THREE, row.getThree());\n        assertEquals(\"not set\", row.getDoNotSet());\n\n        assertTrue(getResultSet().next());\n        row = processor.toBean(getResultSet(), TestBean.class);\n\n        assertEquals(\"4\", row.getOne());\n        assertEquals(\"5\", row.getTwo());\n        assertEquals(TestBean.Ordinal.SIX, row.getThree());\n        assertEquals(\"not set\", row.getDoNotSet());\n        assertEquals(3, row.getIntTest());\n        assertEquals(Integer.valueOf(4), row.getIntegerTest());\n        assertNull(row.getNullObjectTest());\n        assertEquals(0, row.getNullPrimitiveTest());\n        // test date -> string handling\n        assertNotNull(row.getNotDate());\n        assertTrue(!\"not a date\".equals(row.getNotDate()));\n        assertTrue(row.getNotDate().endsWith(\"789456123\"));\n\n        assertFalse(getResultSet().next());\n\n    }\n\n    public void testToBeanList() throws SQLException, ParseException {\n\n        final List<TestBean> list = processor.toBeanList(getResultSet(), TestBean.class);\n        assertNotNull(list);\n        assertEquals(ROWS, list.size());\n\n        TestBean b = list.get(0);\n        assertEquals(\"1\", b.getOne());\n        assertEquals(\"2\", b.getTwo());\n        assertEquals(TestBean.Ordinal.THREE, b.getThree());\n        assertEquals(\"not set\", b.getDoNotSet());\n        datef.parse(b.getNotDate());\n\n        b = list.get(1);\n        assertEquals(\"4\", b.getOne());\n        assertEquals(\"5\", b.getTwo());\n        assertEquals(TestBean.Ordinal.SIX, b.getThree());\n        assertEquals(\"not set\", b.getDoNotSet());\n        assertEquals(3, b.getIntTest());\n        assertEquals(Integer.valueOf(4), b.getIntegerTest());\n        assertNull(b.getNullObjectTest());\n        assertEquals(0, b.getNullPrimitiveTest());\n        // test date -> string handling\n        assertNotNull(b.getNotDate());\n        assertTrue(!\"not a date\".equals(b.getNotDate()));\n        assertTrue(b.getNotDate().endsWith(\"789456123\"));\n    }\n\n    public void testToMap() throws SQLException {\n\n        assertTrue(getResultSet().next());\n        Map<String, Object> m = processor.toMap(getResultSet());\n        assertEquals(COLS, m.size());\n        assertEquals(\"1\", m.get(\"one\"));\n        assertEquals(\"2\", m.get(\"TWO\"));\n        assertEquals(\"THREE\", m.get(\"Three\"));\n\n        assertTrue(getResultSet().next());\n        m = processor.toMap(getResultSet());\n        assertEquals(COLS, m.size());\n\n        assertEquals(\"4\", m.get(\"One\")); // case shouldn't matter\n        assertEquals(\"5\", m.get(\"two\"));\n        assertEquals(\"SIX\", m.get(\"THREE\"));\n\n        assertFalse(getResultSet().next());\n    }\n\n    public void testToMapOrdering() throws SQLException {\n\n        assertTrue(getResultSet().next());\n        final Map<String, Object> m = processor.toMap(getResultSet());\n\n        final Iterator<String> itr = m.keySet().iterator();\n        assertEquals(\"one\", itr.next());\n        assertEquals(\"two\", itr.next());\n        assertEquals(\"three\", itr.next());\n        assertEquals(\"notInBean\", itr.next());\n        assertEquals(\"intTest\", itr.next());\n        assertEquals(\"integerTest\", itr.next());\n        assertEquals(\"nullObjectTest\", itr.next());\n        assertEquals(\"nullPrimitiveTest\", itr.next());\n        assertEquals(\"notDate\", itr.next());\n        assertEquals(\"columnProcessorDoubleTest\", itr.next());\n        assertEquals(\"11\", itr.next());\n\n        assertFalse(itr.hasNext());\n    }\n}", "definition": "public class BasicRowProcessorTest extends BaseTestCase", "class_docstring": "\nTest the BasicRowProcessor class.\n", "name": "BasicRowProcessorTest", "super_interfaces": [], "superclasses": "BaseTestCase", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private static final RowProcessor processor = new BasicRowProcessor();", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "RowProcessor", "name": "processor = new BasicRowProcessor()", "syntax_pass": true}, {"attribute_expression": "private static final DateFormat datef = new SimpleDateFormat(\"EEE MMM dd HH:mm:ss zzz yyyy\", Locale.US);", "docstring": "\nFormat that matches Date.toString(). Sun Mar 14 15:19:15 MST 2004\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "DateFormat", "name": "datef = new SimpleDateFormat(\"EEE MMM dd HH:mm:ss zzz yyyy\", Locale.US)", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public void testPutAllContainsKeyAndRemove() throws Exception {\n        final Map<String, Object> test = new HashMap<>(3);\n        test.put(\"fiRst\", \"thing\");\n        test.put(\"seCond\", \"another\");\n        test.put(\"thIrd\", \"more\");\n        final Map<String, Object> brpMap = BasicRowProcessor.createCaseInsensitiveHashMap(3);\n        brpMap.putAll(test);\n\n        assertEquals(test, brpMap);\n        assertTrue(brpMap.containsKey(\"fiRst\"));\n        assertTrue(brpMap.containsKey(\"first\"));\n\n        brpMap.remove(\"first\");\n        assertFalse(brpMap.containsKey(\"first\"));\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testPutAllContainsKeyAndRemove", "params": [], "body": "                                                                  {\n        final Map<String, Object> test = new HashMap<>(3);\n        test.put(\"fiRst\", \"thing\");\n        test.put(\"seCond\", \"another\");\n        test.put(\"thIrd\", \"more\");\n        final Map<String, Object> brpMap = BasicRowProcessor.createCaseInsensitiveHashMap(3);\n        brpMap.putAll(test);\n\n        assertEquals(test, brpMap);\n        assertTrue(brpMap.containsKey(\"fiRst\"));\n        assertTrue(brpMap.containsKey(\"first\"));\n\n        brpMap.remove(\"first\");\n        assertFalse(brpMap.containsKey(\"first\"));\n    }", "signature": "public void testPutAllContainsKeyAndRemove()"}, {"syntax_pass": true, "original_string": "    public void testToArray() throws SQLException {\n\n        Object[] a;\n        assertTrue(getResultSet().next());\n        a = processor.toArray(getResultSet());\n        assertEquals(COLS, a.length);\n        assertEquals(\"1\", a[0]);\n        assertEquals(\"2\", a[1]);\n        assertEquals(\"THREE\", a[2]);\n\n        assertTrue(getResultSet().next());\n        a = processor.toArray(getResultSet());\n        assertEquals(COLS, a.length);\n\n        assertEquals(\"4\", a[0]);\n        assertEquals(\"5\", a[1]);\n        assertEquals(\"SIX\", a[2]);\n\n        assertFalse(getResultSet().next());\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testToArray", "params": [], "body": "                                                  {\n\n        Object[] a;\n        assertTrue(getResultSet().next());\n        a = processor.toArray(getResultSet());\n        assertEquals(COLS, a.length);\n        assertEquals(\"1\", a[0]);\n        assertEquals(\"2\", a[1]);\n        assertEquals(\"THREE\", a[2]);\n\n        assertTrue(getResultSet().next());\n        a = processor.toArray(getResultSet());\n        assertEquals(COLS, a.length);\n\n        assertEquals(\"4\", a[0]);\n        assertEquals(\"5\", a[1]);\n        assertEquals(\"SIX\", a[2]);\n\n        assertFalse(getResultSet().next());\n    }", "signature": "public void testToArray()"}, {"syntax_pass": true, "original_string": "    public void testToBean() throws SQLException, ParseException {\n\n        assertTrue(getResultSet().next());\n        TestBean row = processor.toBean(getResultSet(), TestBean.class);\n        assertEquals(\"1\", row.getOne());\n        assertEquals(\"2\", row.getTwo());\n        assertEquals(TestBean.Ordinal.THREE, row.getThree());\n        assertEquals(\"not set\", row.getDoNotSet());\n\n        assertTrue(getResultSet().next());\n        row = processor.toBean(getResultSet(), TestBean.class);\n\n        assertEquals(\"4\", row.getOne());\n        assertEquals(\"5\", row.getTwo());\n        assertEquals(TestBean.Ordinal.SIX, row.getThree());\n        assertEquals(\"not set\", row.getDoNotSet());\n        assertEquals(3, row.getIntTest());\n        assertEquals(Integer.valueOf(4), row.getIntegerTest());\n        assertNull(row.getNullObjectTest());\n        assertEquals(0, row.getNullPrimitiveTest());\n        // test date -> string handling\n        assertNotNull(row.getNotDate());\n        assertTrue(!\"not a date\".equals(row.getNotDate()));\n        assertTrue(row.getNotDate().endsWith(\"789456123\"));\n\n        assertFalse(getResultSet().next());\n\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testToBean", "params": [], "body": "                                                                 {\n\n        assertTrue(getResultSet().next());\n        TestBean row = processor.toBean(getResultSet(), TestBean.class);\n        assertEquals(\"1\", row.getOne());\n        assertEquals(\"2\", row.getTwo());\n        assertEquals(TestBean.Ordinal.THREE, row.getThree());\n        assertEquals(\"not set\", row.getDoNotSet());\n\n        assertTrue(getResultSet().next());\n        row = processor.toBean(getResultSet(), TestBean.class);\n\n        assertEquals(\"4\", row.getOne());\n        assertEquals(\"5\", row.getTwo());\n        assertEquals(TestBean.Ordinal.SIX, row.getThree());\n        assertEquals(\"not set\", row.getDoNotSet());\n        assertEquals(3, row.getIntTest());\n        assertEquals(Integer.valueOf(4), row.getIntegerTest());\n        assertNull(row.getNullObjectTest());\n        assertEquals(0, row.getNullPrimitiveTest());\n        // test date -> string handling\n        assertNotNull(row.getNotDate());\n        assertTrue(!\"not a date\".equals(row.getNotDate()));\n        assertTrue(row.getNotDate().endsWith(\"789456123\"));\n\n        assertFalse(getResultSet().next());\n\n    }", "signature": "public void testToBean()"}, {"syntax_pass": true, "original_string": "    public void testToBeanList() throws SQLException, ParseException {\n\n        final List<TestBean> list = processor.toBeanList(getResultSet(), TestBean.class);\n        assertNotNull(list);\n        assertEquals(ROWS, list.size());\n\n        TestBean b = list.get(0);\n        assertEquals(\"1\", b.getOne());\n        assertEquals(\"2\", b.getTwo());\n        assertEquals(TestBean.Ordinal.THREE, b.getThree());\n        assertEquals(\"not set\", b.getDoNotSet());\n        datef.parse(b.getNotDate());\n\n        b = list.get(1);\n        assertEquals(\"4\", b.getOne());\n        assertEquals(\"5\", b.getTwo());\n        assertEquals(TestBean.Ordinal.SIX, b.getThree());\n        assertEquals(\"not set\", b.getDoNotSet());\n        assertEquals(3, b.getIntTest());\n        assertEquals(Integer.valueOf(4), b.getIntegerTest());\n        assertNull(b.getNullObjectTest());\n        assertEquals(0, b.getNullPrimitiveTest());\n        // test date -> string handling\n        assertNotNull(b.getNotDate());\n        assertTrue(!\"not a date\".equals(b.getNotDate()));\n        assertTrue(b.getNotDate().endsWith(\"789456123\"));\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testToBeanList", "params": [], "body": "                                                                     {\n\n        final List<TestBean> list = processor.toBeanList(getResultSet(), TestBean.class);\n        assertNotNull(list);\n        assertEquals(ROWS, list.size());\n\n        TestBean b = list.get(0);\n        assertEquals(\"1\", b.getOne());\n        assertEquals(\"2\", b.getTwo());\n        assertEquals(TestBean.Ordinal.THREE, b.getThree());\n        assertEquals(\"not set\", b.getDoNotSet());\n        datef.parse(b.getNotDate());\n\n        b = list.get(1);\n        assertEquals(\"4\", b.getOne());\n        assertEquals(\"5\", b.getTwo());\n        assertEquals(TestBean.Ordinal.SIX, b.getThree());\n        assertEquals(\"not set\", b.getDoNotSet());\n        assertEquals(3, b.getIntTest());\n        assertEquals(Integer.valueOf(4), b.getIntegerTest());\n        assertNull(b.getNullObjectTest());\n        assertEquals(0, b.getNullPrimitiveTest());\n        // test date -> string handling\n        assertNotNull(b.getNotDate());\n        assertTrue(!\"not a date\".equals(b.getNotDate()));\n        assertTrue(b.getNotDate().endsWith(\"789456123\"));\n    }", "signature": "public void testToBeanList()"}, {"syntax_pass": true, "original_string": "    public void testToMap() throws SQLException {\n\n        assertTrue(getResultSet().next());\n        Map<String, Object> m = processor.toMap(getResultSet());\n        assertEquals(COLS, m.size());\n        assertEquals(\"1\", m.get(\"one\"));\n        assertEquals(\"2\", m.get(\"TWO\"));\n        assertEquals(\"THREE\", m.get(\"Three\"));\n\n        assertTrue(getResultSet().next());\n        m = processor.toMap(getResultSet());\n        assertEquals(COLS, m.size());\n\n        assertEquals(\"4\", m.get(\"One\")); // case shouldn't matter\n        assertEquals(\"5\", m.get(\"two\"));\n        assertEquals(\"SIX\", m.get(\"THREE\"));\n\n        assertFalse(getResultSet().next());\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testToMap", "params": [], "body": "                                                {\n\n        assertTrue(getResultSet().next());\n        Map<String, Object> m = processor.toMap(getResultSet());\n        assertEquals(COLS, m.size());\n        assertEquals(\"1\", m.get(\"one\"));\n        assertEquals(\"2\", m.get(\"TWO\"));\n        assertEquals(\"THREE\", m.get(\"Three\"));\n\n        assertTrue(getResultSet().next());\n        m = processor.toMap(getResultSet());\n        assertEquals(COLS, m.size());\n\n        assertEquals(\"4\", m.get(\"One\")); // case shouldn't matter\n        assertEquals(\"5\", m.get(\"two\"));\n        assertEquals(\"SIX\", m.get(\"THREE\"));\n\n        assertFalse(getResultSet().next());\n    }", "signature": "public void testToMap()"}, {"syntax_pass": true, "original_string": "    public void testToMapOrdering() throws SQLException {\n\n        assertTrue(getResultSet().next());\n        final Map<String, Object> m = processor.toMap(getResultSet());\n\n        final Iterator<String> itr = m.keySet().iterator();\n        assertEquals(\"one\", itr.next());\n        assertEquals(\"two\", itr.next());\n        assertEquals(\"three\", itr.next());\n        assertEquals(\"notInBean\", itr.next());\n        assertEquals(\"intTest\", itr.next());\n        assertEquals(\"integerTest\", itr.next());\n        assertEquals(\"nullObjectTest\", itr.next());\n        assertEquals(\"nullPrimitiveTest\", itr.next());\n        assertEquals(\"notDate\", itr.next());\n        assertEquals(\"columnProcessorDoubleTest\", itr.next());\n        assertEquals(\"11\", itr.next());\n\n        assertFalse(itr.hasNext());\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testToMapOrdering", "params": [], "body": "                                                        {\n\n        assertTrue(getResultSet().next());\n        final Map<String, Object> m = processor.toMap(getResultSet());\n\n        final Iterator<String> itr = m.keySet().iterator();\n        assertEquals(\"one\", itr.next());\n        assertEquals(\"two\", itr.next());\n        assertEquals(\"three\", itr.next());\n        assertEquals(\"notInBean\", itr.next());\n        assertEquals(\"intTest\", itr.next());\n        assertEquals(\"integerTest\", itr.next());\n        assertEquals(\"nullObjectTest\", itr.next());\n        assertEquals(\"nullPrimitiveTest\", itr.next());\n        assertEquals(\"notDate\", itr.next());\n        assertEquals(\"columnProcessorDoubleTest\", itr.next());\n        assertEquals(\"11\", itr.next());\n\n        assertFalse(itr.hasNext());\n    }", "signature": "public void testToMapOrdering()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/dbutils/ResultSetIteratorTest.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils;\n\nimport static org.mockito.Mockito.mock;\n\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Iterator;\n\nimport org.junit.Test;\n\n/**\n * ResultSetIteratorTest\n */\npublic class ResultSetIteratorTest extends BaseTestCase {\n\n    @Test\n    public void testCreatesResultSetIteratorTakingThreeArgumentsAndCallsRemove() {\n\n        final ResultSet resultSet = mock(ResultSet.class);\n        final ResultSetIterator resultSetIterator = new ResultSetIterator(resultSet, null);\n        resultSetIterator.remove();\n\n    }\n\n    public void testNext() {\n\n        final Iterator<Object[]> iter = new ResultSetIterator(getResultSet());\n\n        assertTrue(iter.hasNext());\n        Object[] row = iter.next();\n        assertEquals(COLS, row.length);\n        assertEquals(\"1\", row[0]);\n        assertEquals(\"2\", row[1]);\n        assertEquals(\"THREE\", row[2]);\n\n        assertTrue(iter.hasNext());\n        row = iter.next();\n        assertEquals(COLS, row.length);\n\n        assertEquals(\"4\", row[0]);\n        assertEquals(\"5\", row[1]);\n        assertEquals(\"SIX\", row[2]);\n\n        assertFalse(iter.hasNext());\n        assertTrue(iter.next().length == 0);\n    }\n\n    @Test\n    public void testRethrowThrowsRuntimeException() {\n\n        final ResultSetIterator resultSetIterator = new ResultSetIterator((ResultSet) null);\n        final Throwable throwable = new Throwable();\n        final SQLException sqlException = new SQLException(throwable);\n\n        try {\n            resultSetIterator.rethrow(sqlException);\n            fail(\"Expecting exception: RuntimeException\");\n        } catch (final RuntimeException e) {\n            assertEquals(ResultSetIterator.class.getName(), e.getStackTrace()[0].getClassName());\n        }\n\n    }\n\n}\n", "file_hash": "a532f3f12b0e5e4826cff33406dee8b27b76e6f53440649d957e618b52c4d789", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils;", "import static org.mockito.Mockito.mock;", "import java.sql.ResultSet;", "import java.sql.SQLException;", "import java.util.Iterator;", "import org.junit.Test;"], "methods": [], "classes": [{"original_string": "public class ResultSetIteratorTest extends BaseTestCase {\n\n    @Test\n    public void testCreatesResultSetIteratorTakingThreeArgumentsAndCallsRemove() {\n\n        final ResultSet resultSet = mock(ResultSet.class);\n        final ResultSetIterator resultSetIterator = new ResultSetIterator(resultSet, null);\n        resultSetIterator.remove();\n\n    }\n\n    public void testNext() {\n\n        final Iterator<Object[]> iter = new ResultSetIterator(getResultSet());\n\n        assertTrue(iter.hasNext());\n        Object[] row = iter.next();\n        assertEquals(COLS, row.length);\n        assertEquals(\"1\", row[0]);\n        assertEquals(\"2\", row[1]);\n        assertEquals(\"THREE\", row[2]);\n\n        assertTrue(iter.hasNext());\n        row = iter.next();\n        assertEquals(COLS, row.length);\n\n        assertEquals(\"4\", row[0]);\n        assertEquals(\"5\", row[1]);\n        assertEquals(\"SIX\", row[2]);\n\n        assertFalse(iter.hasNext());\n        assertTrue(iter.next().length == 0);\n    }\n\n    @Test\n    public void testRethrowThrowsRuntimeException() {\n\n        final ResultSetIterator resultSetIterator = new ResultSetIterator((ResultSet) null);\n        final Throwable throwable = new Throwable();\n        final SQLException sqlException = new SQLException(throwable);\n\n        try {\n            resultSetIterator.rethrow(sqlException);\n            fail(\"Expecting exception: RuntimeException\");\n        } catch (final RuntimeException e) {\n            assertEquals(ResultSetIterator.class.getName(), e.getStackTrace()[0].getClassName());\n        }\n\n    }\n\n}", "definition": "public class ResultSetIteratorTest extends BaseTestCase", "class_docstring": "\nResultSetIteratorTest\n", "name": "ResultSetIteratorTest", "super_interfaces": [], "superclasses": "BaseTestCase", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void testCreatesResultSetIteratorTakingThreeArgumentsAndCallsRemove() {\n\n        final ResultSet resultSet = mock(ResultSet.class);\n        final ResultSetIterator resultSetIterator = new ResultSetIterator(resultSet, null);\n        resultSetIterator.remove();\n\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testCreatesResultSetIteratorTakingThreeArgumentsAndCallsRemove", "params": [], "body": "                                                                                 {\n\n        final ResultSet resultSet = mock(ResultSet.class);\n        final ResultSetIterator resultSetIterator = new ResultSetIterator(resultSet, null);\n        resultSetIterator.remove();\n\n    }", "signature": "@Test\n    public void testCreatesResultSetIteratorTakingThreeArgumentsAndCallsRemove()"}, {"syntax_pass": true, "original_string": "    public void testNext() {\n\n        final Iterator<Object[]> iter = new ResultSetIterator(getResultSet());\n\n        assertTrue(iter.hasNext());\n        Object[] row = iter.next();\n        assertEquals(COLS, row.length);\n        assertEquals(\"1\", row[0]);\n        assertEquals(\"2\", row[1]);\n        assertEquals(\"THREE\", row[2]);\n\n        assertTrue(iter.hasNext());\n        row = iter.next();\n        assertEquals(COLS, row.length);\n\n        assertEquals(\"4\", row[0]);\n        assertEquals(\"5\", row[1]);\n        assertEquals(\"SIX\", row[2]);\n\n        assertFalse(iter.hasNext());\n        assertTrue(iter.next().length == 0);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testNext", "params": [], "body": "                           {\n\n        final Iterator<Object[]> iter = new ResultSetIterator(getResultSet());\n\n        assertTrue(iter.hasNext());\n        Object[] row = iter.next();\n        assertEquals(COLS, row.length);\n        assertEquals(\"1\", row[0]);\n        assertEquals(\"2\", row[1]);\n        assertEquals(\"THREE\", row[2]);\n\n        assertTrue(iter.hasNext());\n        row = iter.next();\n        assertEquals(COLS, row.length);\n\n        assertEquals(\"4\", row[0]);\n        assertEquals(\"5\", row[1]);\n        assertEquals(\"SIX\", row[2]);\n\n        assertFalse(iter.hasNext());\n        assertTrue(iter.next().length == 0);\n    }", "signature": "public void testNext()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testRethrowThrowsRuntimeException() {\n\n        final ResultSetIterator resultSetIterator = new ResultSetIterator((ResultSet) null);\n        final Throwable throwable = new Throwable();\n        final SQLException sqlException = new SQLException(throwable);\n\n        try {\n            resultSetIterator.rethrow(sqlException);\n            fail(\"Expecting exception: RuntimeException\");\n        } catch (final RuntimeException e) {\n            assertEquals(ResultSetIterator.class.getName(), e.getStackTrace()[0].getClassName());\n        }\n\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testRethrowThrowsRuntimeException", "params": [], "body": "                                                    {\n\n        final ResultSetIterator resultSetIterator = new ResultSetIterator((ResultSet) null);\n        final Throwable throwable = new Throwable();\n        final SQLException sqlException = new SQLException(throwable);\n\n        try {\n            resultSetIterator.rethrow(sqlException);\n            fail(\"Expecting exception: RuntimeException\");\n        } catch (final RuntimeException e) {\n            assertEquals(ResultSetIterator.class.getName(), e.getStackTrace()[0].getClassName());\n        }\n\n    }", "signature": "@Test\n    public void testRethrowThrowsRuntimeException()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/dbutils/QueryLoaderTest.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils;\n\nimport java.io.IOException;\nimport java.util.Map;\n\n/**\n * QueryLoaderTest\n */\npublic class QueryLoaderTest extends BaseTestCase {\n\n    private static final String QUERIES = \"/org/apache/commons/dbutils/TestQueries.properties\";\n\n    public void testLoad() throws IOException {\n        final QueryLoader loader = QueryLoader.instance();\n        final Map<String, String> q = loader.load(QUERIES);\n        final Map<String, String> q2 = loader.load(QUERIES);\n        assertSame(q, q2); // pointer comparison should return true\n        assertEquals(\"SELECT * FROM SomeTable\", q.get(\"test.query\"));\n\n        loader.unload(QUERIES);\n        final Map<String, String> q3 = loader.load(QUERIES);\n        assertTrue(q != q3); // pointer comparison should return false\n    }\n\n    public void testLoadThrowsIllegalArgumentException() throws IOException {\n\n        final QueryLoader queryLoader = QueryLoader.instance();\n\n        try {\n            queryLoader.load(\"e\");\n            fail(\"Expecting exception: IllegalArgumentException\");\n        } catch (final IllegalArgumentException e) {\n            assertEquals(\"e not found.\", e.getMessage());\n            assertEquals(QueryLoader.class.getName(), e.getStackTrace()[0].getClassName());\n        }\n\n    }\n\n}\n", "file_hash": "2b1ac41719fc50a6288cda779da71921f50a1a14f21c7c64b1a6ab0e4bb70d17", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils;", "import java.io.IOException;", "import java.util.Map;"], "methods": [], "classes": [{"original_string": "public class QueryLoaderTest extends BaseTestCase {\n\n    private static final String QUERIES = \"/org/apache/commons/dbutils/TestQueries.properties\";\n\n    public void testLoad() throws IOException {\n        final QueryLoader loader = QueryLoader.instance();\n        final Map<String, String> q = loader.load(QUERIES);\n        final Map<String, String> q2 = loader.load(QUERIES);\n        assertSame(q, q2); // pointer comparison should return true\n        assertEquals(\"SELECT * FROM SomeTable\", q.get(\"test.query\"));\n\n        loader.unload(QUERIES);\n        final Map<String, String> q3 = loader.load(QUERIES);\n        assertTrue(q != q3); // pointer comparison should return false\n    }\n\n    public void testLoadThrowsIllegalArgumentException() throws IOException {\n\n        final QueryLoader queryLoader = QueryLoader.instance();\n\n        try {\n            queryLoader.load(\"e\");\n            fail(\"Expecting exception: IllegalArgumentException\");\n        } catch (final IllegalArgumentException e) {\n            assertEquals(\"e not found.\", e.getMessage());\n            assertEquals(QueryLoader.class.getName(), e.getStackTrace()[0].getClassName());\n        }\n\n    }\n\n}", "definition": "public class QueryLoaderTest extends BaseTestCase", "class_docstring": "\nQueryLoaderTest\n", "name": "QueryLoaderTest", "super_interfaces": [], "superclasses": "BaseTestCase", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private static final String QUERIES = \"/org/apache/commons/dbutils/TestQueries.properties\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "QUERIES = \"/org/apache/commons/dbutils/TestQueries.properties\"", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public void testLoad() throws IOException {\n        final QueryLoader loader = QueryLoader.instance();\n        final Map<String, String> q = loader.load(QUERIES);\n        final Map<String, String> q2 = loader.load(QUERIES);\n        assertSame(q, q2); // pointer comparison should return true\n        assertEquals(\"SELECT * FROM SomeTable\", q.get(\"test.query\"));\n\n        loader.unload(QUERIES);\n        final Map<String, String> q3 = loader.load(QUERIES);\n        assertTrue(q != q3); // pointer comparison should return false\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testLoad", "params": [], "body": "                                              {\n        final QueryLoader loader = QueryLoader.instance();\n        final Map<String, String> q = loader.load(QUERIES);\n        final Map<String, String> q2 = loader.load(QUERIES);\n        assertSame(q, q2); // pointer comparison should return true\n        assertEquals(\"SELECT * FROM SomeTable\", q.get(\"test.query\"));\n\n        loader.unload(QUERIES);\n        final Map<String, String> q3 = loader.load(QUERIES);\n        assertTrue(q != q3); // pointer comparison should return false\n    }", "signature": "public void testLoad()"}, {"syntax_pass": true, "original_string": "    public void testLoadThrowsIllegalArgumentException() throws IOException {\n\n        final QueryLoader queryLoader = QueryLoader.instance();\n\n        try {\n            queryLoader.load(\"e\");\n            fail(\"Expecting exception: IllegalArgumentException\");\n        } catch (final IllegalArgumentException e) {\n            assertEquals(\"e not found.\", e.getMessage());\n            assertEquals(QueryLoader.class.getName(), e.getStackTrace()[0].getClassName());\n        }\n\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testLoadThrowsIllegalArgumentException", "params": [], "body": "                                                                            {\n\n        final QueryLoader queryLoader = QueryLoader.instance();\n\n        try {\n            queryLoader.load(\"e\");\n            fail(\"Expecting exception: IllegalArgumentException\");\n        } catch (final IllegalArgumentException e) {\n            assertEquals(\"e not found.\", e.getMessage());\n            assertEquals(QueryLoader.class.getName(), e.getStackTrace()[0].getClassName());\n        }\n\n    }", "signature": "public void testLoadThrowsIllegalArgumentException()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/dbutils/DbUtilsTest.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils;\n\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.fail;\nimport static org.mockito.Mockito.doThrow;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.reset;\nimport static org.mockito.Mockito.verify;\n\nimport java.sql.Connection;\nimport java.sql.Driver;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\nimport java.util.Properties;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\n\npublic class DbUtilsTest {\n\n    public static class DriverProxyTest {\n        private static final Driver mockedDriver = mock(Driver.class);\n        private DbUtils.DriverProxy proxy;\n\n        @Before\n        public void setUp() {\n            proxy = new DbUtils.DriverProxy(mockedDriver);\n        }\n\n        @After\n        public void tearDown() {\n            reset(mockedDriver);\n        }\n\n        @Test\n        public void testProxiedMethods() throws Exception {\n            proxy.getMajorVersion();\n            verify(mockedDriver).getMajorVersion();\n            proxy.getMinorVersion();\n            verify(mockedDriver).getMinorVersion();\n            proxy.jdbcCompliant();\n            verify(mockedDriver).jdbcCompliant();\n\n            final String url = \"testUrl\";\n            proxy.acceptsURL(url);\n            verify(mockedDriver).acceptsURL(url);\n\n            final Properties props = new Properties();\n            props.setProperty(\"test\", \"true\");\n            proxy.connect(url, props);\n            verify(mockedDriver).connect(url, props);\n            proxy.getPropertyInfo(url, props);\n            verify(mockedDriver).getPropertyInfo(url, props);\n        }\n    }\n\n    @Test\n    public void testCloseConnection() throws Exception {\n        final Connection mockCon = mock(Connection.class);\n        DbUtils.close(mockCon);\n        verify(mockCon).close();\n    }\n\n    @Test\n    public void testCloseNullConnection() throws Exception {\n        DbUtils.close((Connection) null);\n    }\n\n    @Test\n    public void testCloseNullResultSet() throws Exception {\n        DbUtils.close((ResultSet) null);\n    }\n\n    @Test\n    public void testCloseNullStatement() throws Exception {\n        DbUtils.close((Statement) null);\n    }\n\n    @Test\n    public void testCloseQuietlyConnection() throws Exception {\n        final Connection mockConnection = mock(Connection.class);\n        DbUtils.closeQuietly(mockConnection);\n        verify(mockConnection).close();\n    }\n\n    @Test\n    public void testCloseQuietlyConnectionResultSetStatement() throws Exception {\n        final Connection mockConnection = mock(Connection.class);\n        final ResultSet mockResultSet = mock(ResultSet.class);\n        final Statement mockStatement = mock(Statement.class);\n        DbUtils.closeQuietly(mockConnection, mockStatement, mockResultSet);\n        verify(mockConnection).close();\n        verify(mockResultSet).close();\n        verify(mockStatement).close();\n    }\n\n    @Test\n    public void testCloseQuietlyConnectionResultSetStatementThrowingException() throws Exception {\n        final Connection mockConnection = mock(Connection.class);\n        final ResultSet mockResultSet = mock(ResultSet.class);\n        final Statement mockStatement = mock(Statement.class);\n        doThrow(SQLException.class).when(mockStatement).close();\n        DbUtils.closeQuietly(mockConnection, mockStatement, mockResultSet);\n        verify(mockConnection).close();\n        verify(mockResultSet).close();\n        verify(mockStatement).close();\n    }\n\n    @Test\n    public void testCloseQuietlyConnectionResultSetThrowingExceptionStatement() throws Exception {\n        final Connection mockConnection = mock(Connection.class);\n        final ResultSet mockResultSet = mock(ResultSet.class);\n        doThrow(SQLException.class).when(mockResultSet).close();\n        final Statement mockStatement = mock(Statement.class);\n        DbUtils.closeQuietly(mockConnection, mockStatement, mockResultSet);\n        verify(mockConnection).close();\n        verify(mockResultSet).close();\n        verify(mockStatement).close();\n    }\n\n    @Test\n    public void testCloseQuietlyConnectionThrowingException() throws Exception {\n        final Connection mockConnection = mock(Connection.class);\n        doThrow(SQLException.class).when(mockConnection).close();\n        DbUtils.closeQuietly(mockConnection);\n    }\n\n    @Test\n    public void testCloseQuietlyConnectionThrowingExceptionResultSetStatement() throws Exception {\n        final Connection mockConnection = mock(Connection.class);\n        doThrow(SQLException.class).when(mockConnection).close();\n        final ResultSet mockResultSet = mock(ResultSet.class);\n        final Statement mockStatement = mock(Statement.class);\n        DbUtils.closeQuietly(mockConnection, mockStatement, mockResultSet);\n        verify(mockConnection).close();\n        verify(mockResultSet).close();\n        verify(mockStatement).close();\n    }\n\n    @Test\n    public void testCloseQuietlyNullConnection() throws Exception {\n        DbUtils.closeQuietly((Connection) null);\n    }\n\n    @Test\n    public void testCloseQuietlyNullResultSet() throws Exception {\n        DbUtils.closeQuietly((ResultSet) null);\n    }\n\n    @Test\n    public void testCloseQuietlyNullStatement() throws Exception {\n        DbUtils.closeQuietly((Statement) null);\n    }\n\n    @Test\n    public void testCloseQuietlyResultSet() throws Exception {\n        final ResultSet mockResultSet = mock(ResultSet.class);\n        DbUtils.closeQuietly(mockResultSet);\n        verify(mockResultSet).close();\n    }\n\n    @Test\n    public void testCloseQuietlyResultSetThrowingException() throws Exception {\n        final ResultSet mockResultSet = mock(ResultSet.class);\n        doThrow(SQLException.class).when(mockResultSet).close();\n        DbUtils.closeQuietly(mockResultSet);\n    }\n\n    @Test\n    public void testCloseQuietlyStatement() throws Exception {\n        final Statement mockStatement = mock(Statement.class);\n        DbUtils.closeQuietly(mockStatement);\n        verify(mockStatement).close();\n    }\n\n    @Test\n    public void testCloseQuietlyStatementThrowingException() throws Exception {\n        final Statement mockStatement = mock(Statement.class);\n        doThrow(SQLException.class).when(mockStatement).close();\n        DbUtils.closeQuietly(mockStatement);\n    }\n\n    @Test\n    public void testCloseResultSet() throws Exception {\n        final ResultSet mockResultSet = mock(ResultSet.class);\n        DbUtils.close(mockResultSet);\n        verify(mockResultSet).close();\n    }\n\n    @Test\n    public void testCloseStatement() throws Exception {\n        final Statement mockStatement = mock(Statement.class);\n        DbUtils.close(mockStatement);\n        verify(mockStatement).close();\n    }\n\n    @Test\n    public void testCommitAndClose() throws Exception {\n        final Connection mockConnection = mock(Connection.class);\n        DbUtils.commitAndClose(mockConnection);\n        verify(mockConnection).commit();\n        verify(mockConnection).close();\n    }\n\n    @Test\n    public void testCommitAndCloseQuietly() throws Exception {\n        final Connection mockConnection = mock(Connection.class);\n        DbUtils.commitAndClose(mockConnection);\n        verify(mockConnection).commit();\n        verify(mockConnection).close();\n    }\n\n    @Test\n    public void testCommitAndCloseQuietlyWithException() throws Exception {\n        final Connection mockConnection = mock(Connection.class);\n        doThrow(SQLException.class).when(mockConnection).close();\n        DbUtils.commitAndCloseQuietly(mockConnection);\n        verify(mockConnection).commit();\n        verify(mockConnection).close();\n    }\n\n    @Test\n    public void testCommitAndCloseQuietlyWithNullDoesNotThrowAnSQLException() {\n\n        DbUtils.commitAndCloseQuietly(null);\n\n    }\n\n    @Test\n    public void testCommitAndCloseWithException() throws Exception {\n        final Connection mockConnection = mock(Connection.class);\n        doThrow(SQLException.class).when(mockConnection).commit();\n        try {\n            DbUtils.commitAndClose(mockConnection);\n            fail(\"DbUtils.commitAndClose() swallowed SQLEception!\");\n        } catch (final SQLException e) {\n            // we expect this exception\n        }\n        verify(mockConnection).close();\n    }\n\n    @Test\n    public void testLoadDriverReturnsFalse() {\n\n        assertFalse(DbUtils.loadDriver(\"\"));\n\n    }\n\n    @Test\n    public void testRollback() throws Exception {\n        final Connection mockConnection = mock(Connection.class);\n        DbUtils.rollback(mockConnection);\n        verify(mockConnection).rollback();\n    }\n\n    @Test\n    public void testRollbackAndClose() throws Exception {\n        final Connection mockConnection = mock(Connection.class);\n        DbUtils.rollbackAndClose(mockConnection);\n        verify(mockConnection).rollback();\n        verify(mockConnection).close();\n    }\n\n    @Test\n    public void testRollbackAndCloseNull() throws Exception {\n        DbUtils.rollbackAndClose(null);\n    }\n\n    @Test\n    public void testRollbackAndCloseQuietly() throws Exception {\n        final Connection mockConnection = mock(Connection.class);\n        DbUtils.rollbackAndCloseQuietly(mockConnection);\n        verify(mockConnection).rollback();\n        verify(mockConnection).close();\n    }\n\n    @Test\n    public void testRollbackAndCloseQuietlyNull() throws Exception {\n        DbUtils.rollbackAndCloseQuietly(null);\n    }\n\n    @Test\n    public void testRollbackAndCloseQuietlyWithException() throws Exception {\n        final Connection mockConnection = mock(Connection.class);\n        doThrow(SQLException.class).when(mockConnection).rollback();\n        DbUtils.rollbackAndCloseQuietly(mockConnection);\n        verify(mockConnection).rollback();\n        verify(mockConnection).close();\n    }\n\n    @Test\n    public void testRollbackAndCloseWithException() throws Exception {\n        final Connection mockConnection = mock(Connection.class);\n        doThrow(SQLException.class).when(mockConnection).rollback();\n        try {\n            DbUtils.rollbackAndClose(mockConnection);\n            fail(\"DbUtils.rollbackAndClose() swallowed SQLException!\");\n        } catch (final SQLException e) {\n            // we expect this exception\n        }\n        verify(mockConnection).rollback();\n        verify(mockConnection).close();\n    }\n\n    @Test\n    public void testRollbackNull() throws Exception {\n        DbUtils.rollback(null);\n    }\n\n    @Test\n    public void testRollbackQuietly() throws Exception {\n        final Connection mockConnection = mock(Connection.class);\n        DbUtils.rollbackQuietly(mockConnection);\n        verify(mockConnection).rollback();\n    }\n\n    @Test\n    public void testRollbackQuietlyNull() throws Exception {\n        DbUtils.rollbackQuietly(null);\n    }\n\n    @Test\n    public void testRollbackQuietlyWithException() throws Exception {\n        final Connection mockConnection = mock(Connection.class);\n        doThrow(SQLException.class).when(mockConnection).rollback();\n        DbUtils.rollbackQuietly(mockConnection);\n        verify(mockConnection).rollback();\n    }\n}\n", "file_hash": "4904085934b93f9cc424c6e647ad4ae3435586d029362881a064b2c29f2bf2d4", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils;", "import static org.junit.Assert.assertFalse;", "import static org.junit.Assert.fail;", "import static org.mockito.Mockito.doThrow;", "import static org.mockito.Mockito.mock;", "import static org.mockito.Mockito.reset;", "import static org.mockito.Mockito.verify;", "import java.sql.Connection;", "import java.sql.Driver;", "import java.sql.ResultSet;", "import java.sql.SQLException;", "import java.sql.Statement;", "import java.util.Properties;", "import org.junit.After;", "import org.junit.Before;", "import org.junit.Test;"], "methods": [], "classes": [{"original_string": "public class DbUtilsTest {\n\n    public static class DriverProxyTest {\n        private static final Driver mockedDriver = mock(Driver.class);\n        private DbUtils.DriverProxy proxy;\n\n        @Before\n        public void setUp() {\n            proxy = new DbUtils.DriverProxy(mockedDriver);\n        }\n\n        @After\n        public void tearDown() {\n            reset(mockedDriver);\n        }\n\n        @Test\n        public void testProxiedMethods() throws Exception {\n            proxy.getMajorVersion();\n            verify(mockedDriver).getMajorVersion();\n            proxy.getMinorVersion();\n            verify(mockedDriver).getMinorVersion();\n            proxy.jdbcCompliant();\n            verify(mockedDriver).jdbcCompliant();\n\n            final String url = \"testUrl\";\n            proxy.acceptsURL(url);\n            verify(mockedDriver).acceptsURL(url);\n\n            final Properties props = new Properties();\n            props.setProperty(\"test\", \"true\");\n            proxy.connect(url, props);\n            verify(mockedDriver).connect(url, props);\n            proxy.getPropertyInfo(url, props);\n            verify(mockedDriver).getPropertyInfo(url, props);\n        }\n    }\n\n    @Test\n    public void testCloseConnection() throws Exception {\n        final Connection mockCon = mock(Connection.class);\n        DbUtils.close(mockCon);\n        verify(mockCon).close();\n    }\n\n    @Test\n    public void testCloseNullConnection() throws Exception {\n        DbUtils.close((Connection) null);\n    }\n\n    @Test\n    public void testCloseNullResultSet() throws Exception {\n        DbUtils.close((ResultSet) null);\n    }\n\n    @Test\n    public void testCloseNullStatement() throws Exception {\n        DbUtils.close((Statement) null);\n    }\n\n    @Test\n    public void testCloseQuietlyConnection() throws Exception {\n        final Connection mockConnection = mock(Connection.class);\n        DbUtils.closeQuietly(mockConnection);\n        verify(mockConnection).close();\n    }\n\n    @Test\n    public void testCloseQuietlyConnectionResultSetStatement() throws Exception {\n        final Connection mockConnection = mock(Connection.class);\n        final ResultSet mockResultSet = mock(ResultSet.class);\n        final Statement mockStatement = mock(Statement.class);\n        DbUtils.closeQuietly(mockConnection, mockStatement, mockResultSet);\n        verify(mockConnection).close();\n        verify(mockResultSet).close();\n        verify(mockStatement).close();\n    }\n\n    @Test\n    public void testCloseQuietlyConnectionResultSetStatementThrowingException() throws Exception {\n        final Connection mockConnection = mock(Connection.class);\n        final ResultSet mockResultSet = mock(ResultSet.class);\n        final Statement mockStatement = mock(Statement.class);\n        doThrow(SQLException.class).when(mockStatement).close();\n        DbUtils.closeQuietly(mockConnection, mockStatement, mockResultSet);\n        verify(mockConnection).close();\n        verify(mockResultSet).close();\n        verify(mockStatement).close();\n    }\n\n    @Test\n    public void testCloseQuietlyConnectionResultSetThrowingExceptionStatement() throws Exception {\n        final Connection mockConnection = mock(Connection.class);\n        final ResultSet mockResultSet = mock(ResultSet.class);\n        doThrow(SQLException.class).when(mockResultSet).close();\n        final Statement mockStatement = mock(Statement.class);\n        DbUtils.closeQuietly(mockConnection, mockStatement, mockResultSet);\n        verify(mockConnection).close();\n        verify(mockResultSet).close();\n        verify(mockStatement).close();\n    }\n\n    @Test\n    public void testCloseQuietlyConnectionThrowingException() throws Exception {\n        final Connection mockConnection = mock(Connection.class);\n        doThrow(SQLException.class).when(mockConnection).close();\n        DbUtils.closeQuietly(mockConnection);\n    }\n\n    @Test\n    public void testCloseQuietlyConnectionThrowingExceptionResultSetStatement() throws Exception {\n        final Connection mockConnection = mock(Connection.class);\n        doThrow(SQLException.class).when(mockConnection).close();\n        final ResultSet mockResultSet = mock(ResultSet.class);\n        final Statement mockStatement = mock(Statement.class);\n        DbUtils.closeQuietly(mockConnection, mockStatement, mockResultSet);\n        verify(mockConnection).close();\n        verify(mockResultSet).close();\n        verify(mockStatement).close();\n    }\n\n    @Test\n    public void testCloseQuietlyNullConnection() throws Exception {\n        DbUtils.closeQuietly((Connection) null);\n    }\n\n    @Test\n    public void testCloseQuietlyNullResultSet() throws Exception {\n        DbUtils.closeQuietly((ResultSet) null);\n    }\n\n    @Test\n    public void testCloseQuietlyNullStatement() throws Exception {\n        DbUtils.closeQuietly((Statement) null);\n    }\n\n    @Test\n    public void testCloseQuietlyResultSet() throws Exception {\n        final ResultSet mockResultSet = mock(ResultSet.class);\n        DbUtils.closeQuietly(mockResultSet);\n        verify(mockResultSet).close();\n    }\n\n    @Test\n    public void testCloseQuietlyResultSetThrowingException() throws Exception {\n        final ResultSet mockResultSet = mock(ResultSet.class);\n        doThrow(SQLException.class).when(mockResultSet).close();\n        DbUtils.closeQuietly(mockResultSet);\n    }\n\n    @Test\n    public void testCloseQuietlyStatement() throws Exception {\n        final Statement mockStatement = mock(Statement.class);\n        DbUtils.closeQuietly(mockStatement);\n        verify(mockStatement).close();\n    }\n\n    @Test\n    public void testCloseQuietlyStatementThrowingException() throws Exception {\n        final Statement mockStatement = mock(Statement.class);\n        doThrow(SQLException.class).when(mockStatement).close();\n        DbUtils.closeQuietly(mockStatement);\n    }\n\n    @Test\n    public void testCloseResultSet() throws Exception {\n        final ResultSet mockResultSet = mock(ResultSet.class);\n        DbUtils.close(mockResultSet);\n        verify(mockResultSet).close();\n    }\n\n    @Test\n    public void testCloseStatement() throws Exception {\n        final Statement mockStatement = mock(Statement.class);\n        DbUtils.close(mockStatement);\n        verify(mockStatement).close();\n    }\n\n    @Test\n    public void testCommitAndClose() throws Exception {\n        final Connection mockConnection = mock(Connection.class);\n        DbUtils.commitAndClose(mockConnection);\n        verify(mockConnection).commit();\n        verify(mockConnection).close();\n    }\n\n    @Test\n    public void testCommitAndCloseQuietly() throws Exception {\n        final Connection mockConnection = mock(Connection.class);\n        DbUtils.commitAndClose(mockConnection);\n        verify(mockConnection).commit();\n        verify(mockConnection).close();\n    }\n\n    @Test\n    public void testCommitAndCloseQuietlyWithException() throws Exception {\n        final Connection mockConnection = mock(Connection.class);\n        doThrow(SQLException.class).when(mockConnection).close();\n        DbUtils.commitAndCloseQuietly(mockConnection);\n        verify(mockConnection).commit();\n        verify(mockConnection).close();\n    }\n\n    @Test\n    public void testCommitAndCloseQuietlyWithNullDoesNotThrowAnSQLException() {\n\n        DbUtils.commitAndCloseQuietly(null);\n\n    }\n\n    @Test\n    public void testCommitAndCloseWithException() throws Exception {\n        final Connection mockConnection = mock(Connection.class);\n        doThrow(SQLException.class).when(mockConnection).commit();\n        try {\n            DbUtils.commitAndClose(mockConnection);\n            fail(\"DbUtils.commitAndClose() swallowed SQLEception!\");\n        } catch (final SQLException e) {\n            // we expect this exception\n        }\n        verify(mockConnection).close();\n    }\n\n    @Test\n    public void testLoadDriverReturnsFalse() {\n\n        assertFalse(DbUtils.loadDriver(\"\"));\n\n    }\n\n    @Test\n    public void testRollback() throws Exception {\n        final Connection mockConnection = mock(Connection.class);\n        DbUtils.rollback(mockConnection);\n        verify(mockConnection).rollback();\n    }\n\n    @Test\n    public void testRollbackAndClose() throws Exception {\n        final Connection mockConnection = mock(Connection.class);\n        DbUtils.rollbackAndClose(mockConnection);\n        verify(mockConnection).rollback();\n        verify(mockConnection).close();\n    }\n\n    @Test\n    public void testRollbackAndCloseNull() throws Exception {\n        DbUtils.rollbackAndClose(null);\n    }\n\n    @Test\n    public void testRollbackAndCloseQuietly() throws Exception {\n        final Connection mockConnection = mock(Connection.class);\n        DbUtils.rollbackAndCloseQuietly(mockConnection);\n        verify(mockConnection).rollback();\n        verify(mockConnection).close();\n    }\n\n    @Test\n    public void testRollbackAndCloseQuietlyNull() throws Exception {\n        DbUtils.rollbackAndCloseQuietly(null);\n    }\n\n    @Test\n    public void testRollbackAndCloseQuietlyWithException() throws Exception {\n        final Connection mockConnection = mock(Connection.class);\n        doThrow(SQLException.class).when(mockConnection).rollback();\n        DbUtils.rollbackAndCloseQuietly(mockConnection);\n        verify(mockConnection).rollback();\n        verify(mockConnection).close();\n    }\n\n    @Test\n    public void testRollbackAndCloseWithException() throws Exception {\n        final Connection mockConnection = mock(Connection.class);\n        doThrow(SQLException.class).when(mockConnection).rollback();\n        try {\n            DbUtils.rollbackAndClose(mockConnection);\n            fail(\"DbUtils.rollbackAndClose() swallowed SQLException!\");\n        } catch (final SQLException e) {\n            // we expect this exception\n        }\n        verify(mockConnection).rollback();\n        verify(mockConnection).close();\n    }\n\n    @Test\n    public void testRollbackNull() throws Exception {\n        DbUtils.rollback(null);\n    }\n\n    @Test\n    public void testRollbackQuietly() throws Exception {\n        final Connection mockConnection = mock(Connection.class);\n        DbUtils.rollbackQuietly(mockConnection);\n        verify(mockConnection).rollback();\n    }\n\n    @Test\n    public void testRollbackQuietlyNull() throws Exception {\n        DbUtils.rollbackQuietly(null);\n    }\n\n    @Test\n    public void testRollbackQuietlyWithException() throws Exception {\n        final Connection mockConnection = mock(Connection.class);\n        doThrow(SQLException.class).when(mockConnection).rollback();\n        DbUtils.rollbackQuietly(mockConnection);\n        verify(mockConnection).rollback();\n    }\n}", "definition": "public class DbUtilsTest", "class_docstring": "", "name": "DbUtilsTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": [{"original_string": "    public static class DriverProxyTest {\n        private static final Driver mockedDriver = mock(Driver.class);\n        private DbUtils.DriverProxy proxy;\n\n        @Before\n        public void setUp() {\n            proxy = new DbUtils.DriverProxy(mockedDriver);\n        }\n\n        @After\n        public void tearDown() {\n            reset(mockedDriver);\n        }\n\n        @Test\n        public void testProxiedMethods() throws Exception {\n            proxy.getMajorVersion();\n            verify(mockedDriver).getMajorVersion();\n            proxy.getMinorVersion();\n            verify(mockedDriver).getMinorVersion();\n            proxy.jdbcCompliant();\n            verify(mockedDriver).jdbcCompliant();\n\n            final String url = \"testUrl\";\n            proxy.acceptsURL(url);\n            verify(mockedDriver).acceptsURL(url);\n\n            final Properties props = new Properties();\n            props.setProperty(\"test\", \"true\");\n            proxy.connect(url, props);\n            verify(mockedDriver).connect(url, props);\n            proxy.getPropertyInfo(url, props);\n            verify(mockedDriver).getPropertyInfo(url, props);\n        }\n    }", "definition": "    public static class DriverProxyTest", "class_docstring": "", "name": "DriverProxyTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "private static final Driver mockedDriver = mock(Driver.class);", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Driver", "name": "mockedDriver = mock(Driver.class)", "syntax_pass": true}, {"attribute_expression": "private DbUtils.DriverProxy proxy;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "DbUtils.DriverProxy", "name": "proxy", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @Before\n        public void setUp() {\n            proxy = new DbUtils.DriverProxy(mockedDriver);\n        }", "docstring": "", "attributes": {"modifiers": "@Before\n        public", "marker_annotations": ["@Before"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setUp", "params": [], "body": "                            {\n            proxy = new DbUtils.DriverProxy(mockedDriver);\n        }", "signature": "@Before\n        public void setUp()"}, {"syntax_pass": true, "original_string": "        @After\n        public void tearDown() {\n            reset(mockedDriver);\n        }", "docstring": "", "attributes": {"modifiers": "@After\n        public", "marker_annotations": ["@After"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "tearDown", "params": [], "body": "                               {\n            reset(mockedDriver);\n        }", "signature": "@After\n        public void tearDown()"}, {"syntax_pass": true, "original_string": "        @Test\n        public void testProxiedMethods() throws Exception {\n            proxy.getMajorVersion();\n            verify(mockedDriver).getMajorVersion();\n            proxy.getMinorVersion();\n            verify(mockedDriver).getMinorVersion();\n            proxy.jdbcCompliant();\n            verify(mockedDriver).jdbcCompliant();\n\n            final String url = \"testUrl\";\n            proxy.acceptsURL(url);\n            verify(mockedDriver).acceptsURL(url);\n\n            final Properties props = new Properties();\n            props.setProperty(\"test\", \"true\");\n            proxy.connect(url, props);\n            verify(mockedDriver).connect(url, props);\n            proxy.getPropertyInfo(url, props);\n            verify(mockedDriver).getPropertyInfo(url, props);\n        }", "docstring": "", "attributes": {"modifiers": "@Test\n        public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testProxiedMethods", "params": [], "body": "                                                          {\n            proxy.getMajorVersion();\n            verify(mockedDriver).getMajorVersion();\n            proxy.getMinorVersion();\n            verify(mockedDriver).getMinorVersion();\n            proxy.jdbcCompliant();\n            verify(mockedDriver).jdbcCompliant();\n\n            final String url = \"testUrl\";\n            proxy.acceptsURL(url);\n            verify(mockedDriver).acceptsURL(url);\n\n            final Properties props = new Properties();\n            props.setProperty(\"test\", \"true\");\n            proxy.connect(url, props);\n            verify(mockedDriver).connect(url, props);\n            proxy.getPropertyInfo(url, props);\n            verify(mockedDriver).getPropertyInfo(url, props);\n        }", "signature": "@Test\n        public void testProxiedMethods()"}]}]}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Test\n    public void testCloseConnection() throws Exception {\n        final Connection mockCon = mock(Connection.class);\n        DbUtils.close(mockCon);\n        verify(mockCon).close();\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testCloseConnection", "params": [], "body": "                                                       {\n        final Connection mockCon = mock(Connection.class);\n        DbUtils.close(mockCon);\n        verify(mockCon).close();\n    }", "signature": "@Test\n    public void testCloseConnection()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testCloseNullConnection() throws Exception {\n        DbUtils.close((Connection) null);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testCloseNullConnection", "params": [], "body": "                                                           {\n        DbUtils.close((Connection) null);\n    }", "signature": "@Test\n    public void testCloseNullConnection()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testCloseNullResultSet() throws Exception {\n        DbUtils.close((ResultSet) null);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testCloseNullResultSet", "params": [], "body": "                                                          {\n        DbUtils.close((ResultSet) null);\n    }", "signature": "@Test\n    public void testCloseNullResultSet()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testCloseNullStatement() throws Exception {\n        DbUtils.close((Statement) null);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testCloseNullStatement", "params": [], "body": "                                                          {\n        DbUtils.close((Statement) null);\n    }", "signature": "@Test\n    public void testCloseNullStatement()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testCloseQuietlyConnection() throws Exception {\n        final Connection mockConnection = mock(Connection.class);\n        DbUtils.closeQuietly(mockConnection);\n        verify(mockConnection).close();\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testCloseQuietlyConnection", "params": [], "body": "                                                              {\n        final Connection mockConnection = mock(Connection.class);\n        DbUtils.closeQuietly(mockConnection);\n        verify(mockConnection).close();\n    }", "signature": "@Test\n    public void testCloseQuietlyConnection()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testCloseQuietlyConnectionResultSetStatement() throws Exception {\n        final Connection mockConnection = mock(Connection.class);\n        final ResultSet mockResultSet = mock(ResultSet.class);\n        final Statement mockStatement = mock(Statement.class);\n        DbUtils.closeQuietly(mockConnection, mockStatement, mockResultSet);\n        verify(mockConnection).close();\n        verify(mockResultSet).close();\n        verify(mockStatement).close();\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testCloseQuietlyConnectionResultSetStatement", "params": [], "body": "                                                                                {\n        final Connection mockConnection = mock(Connection.class);\n        final ResultSet mockResultSet = mock(ResultSet.class);\n        final Statement mockStatement = mock(Statement.class);\n        DbUtils.closeQuietly(mockConnection, mockStatement, mockResultSet);\n        verify(mockConnection).close();\n        verify(mockResultSet).close();\n        verify(mockStatement).close();\n    }", "signature": "@Test\n    public void testCloseQuietlyConnectionResultSetStatement()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testCloseQuietlyConnectionResultSetStatementThrowingException() throws Exception {\n        final Connection mockConnection = mock(Connection.class);\n        final ResultSet mockResultSet = mock(ResultSet.class);\n        final Statement mockStatement = mock(Statement.class);\n        doThrow(SQLException.class).when(mockStatement).close();\n        DbUtils.closeQuietly(mockConnection, mockStatement, mockResultSet);\n        verify(mockConnection).close();\n        verify(mockResultSet).close();\n        verify(mockStatement).close();\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testCloseQuietlyConnectionResultSetStatementThrowingException", "params": [], "body": "                                                                                                 {\n        final Connection mockConnection = mock(Connection.class);\n        final ResultSet mockResultSet = mock(ResultSet.class);\n        final Statement mockStatement = mock(Statement.class);\n        doThrow(SQLException.class).when(mockStatement).close();\n        DbUtils.closeQuietly(mockConnection, mockStatement, mockResultSet);\n        verify(mockConnection).close();\n        verify(mockResultSet).close();\n        verify(mockStatement).close();\n    }", "signature": "@Test\n    public void testCloseQuietlyConnectionResultSetStatementThrowingException()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testCloseQuietlyConnectionResultSetThrowingExceptionStatement() throws Exception {\n        final Connection mockConnection = mock(Connection.class);\n        final ResultSet mockResultSet = mock(ResultSet.class);\n        doThrow(SQLException.class).when(mockResultSet).close();\n        final Statement mockStatement = mock(Statement.class);\n        DbUtils.closeQuietly(mockConnection, mockStatement, mockResultSet);\n        verify(mockConnection).close();\n        verify(mockResultSet).close();\n        verify(mockStatement).close();\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testCloseQuietlyConnectionResultSetThrowingExceptionStatement", "params": [], "body": "                                                                                                 {\n        final Connection mockConnection = mock(Connection.class);\n        final ResultSet mockResultSet = mock(ResultSet.class);\n        doThrow(SQLException.class).when(mockResultSet).close();\n        final Statement mockStatement = mock(Statement.class);\n        DbUtils.closeQuietly(mockConnection, mockStatement, mockResultSet);\n        verify(mockConnection).close();\n        verify(mockResultSet).close();\n        verify(mockStatement).close();\n    }", "signature": "@Test\n    public void testCloseQuietlyConnectionResultSetThrowingExceptionStatement()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testCloseQuietlyConnectionThrowingException() throws Exception {\n        final Connection mockConnection = mock(Connection.class);\n        doThrow(SQLException.class).when(mockConnection).close();\n        DbUtils.closeQuietly(mockConnection);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testCloseQuietlyConnectionThrowingException", "params": [], "body": "                                                                               {\n        final Connection mockConnection = mock(Connection.class);\n        doThrow(SQLException.class).when(mockConnection).close();\n        DbUtils.closeQuietly(mockConnection);\n    }", "signature": "@Test\n    public void testCloseQuietlyConnectionThrowingException()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testCloseQuietlyConnectionThrowingExceptionResultSetStatement() throws Exception {\n        final Connection mockConnection = mock(Connection.class);\n        doThrow(SQLException.class).when(mockConnection).close();\n        final ResultSet mockResultSet = mock(ResultSet.class);\n        final Statement mockStatement = mock(Statement.class);\n        DbUtils.closeQuietly(mockConnection, mockStatement, mockResultSet);\n        verify(mockConnection).close();\n        verify(mockResultSet).close();\n        verify(mockStatement).close();\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testCloseQuietlyConnectionThrowingExceptionResultSetStatement", "params": [], "body": "                                                                                                 {\n        final Connection mockConnection = mock(Connection.class);\n        doThrow(SQLException.class).when(mockConnection).close();\n        final ResultSet mockResultSet = mock(ResultSet.class);\n        final Statement mockStatement = mock(Statement.class);\n        DbUtils.closeQuietly(mockConnection, mockStatement, mockResultSet);\n        verify(mockConnection).close();\n        verify(mockResultSet).close();\n        verify(mockStatement).close();\n    }", "signature": "@Test\n    public void testCloseQuietlyConnectionThrowingExceptionResultSetStatement()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testCloseQuietlyNullConnection() throws Exception {\n        DbUtils.closeQuietly((Connection) null);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testCloseQuietlyNullConnection", "params": [], "body": "                                                                  {\n        DbUtils.closeQuietly((Connection) null);\n    }", "signature": "@Test\n    public void testCloseQuietlyNullConnection()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testCloseQuietlyNullResultSet() throws Exception {\n        DbUtils.closeQuietly((ResultSet) null);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testCloseQuietlyNullResultSet", "params": [], "body": "                                                                 {\n        DbUtils.closeQuietly((ResultSet) null);\n    }", "signature": "@Test\n    public void testCloseQuietlyNullResultSet()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testCloseQuietlyNullStatement() throws Exception {\n        DbUtils.closeQuietly((Statement) null);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testCloseQuietlyNullStatement", "params": [], "body": "                                                                 {\n        DbUtils.closeQuietly((Statement) null);\n    }", "signature": "@Test\n    public void testCloseQuietlyNullStatement()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testCloseQuietlyResultSet() throws Exception {\n        final ResultSet mockResultSet = mock(ResultSet.class);\n        DbUtils.closeQuietly(mockResultSet);\n        verify(mockResultSet).close();\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testCloseQuietlyResultSet", "params": [], "body": "                                                             {\n        final ResultSet mockResultSet = mock(ResultSet.class);\n        DbUtils.closeQuietly(mockResultSet);\n        verify(mockResultSet).close();\n    }", "signature": "@Test\n    public void testCloseQuietlyResultSet()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testCloseQuietlyResultSetThrowingException() throws Exception {\n        final ResultSet mockResultSet = mock(ResultSet.class);\n        doThrow(SQLException.class).when(mockResultSet).close();\n        DbUtils.closeQuietly(mockResultSet);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testCloseQuietlyResultSetThrowingException", "params": [], "body": "                                                                              {\n        final ResultSet mockResultSet = mock(ResultSet.class);\n        doThrow(SQLException.class).when(mockResultSet).close();\n        DbUtils.closeQuietly(mockResultSet);\n    }", "signature": "@Test\n    public void testCloseQuietlyResultSetThrowingException()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testCloseQuietlyStatement() throws Exception {\n        final Statement mockStatement = mock(Statement.class);\n        DbUtils.closeQuietly(mockStatement);\n        verify(mockStatement).close();\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testCloseQuietlyStatement", "params": [], "body": "                                                             {\n        final Statement mockStatement = mock(Statement.class);\n        DbUtils.closeQuietly(mockStatement);\n        verify(mockStatement).close();\n    }", "signature": "@Test\n    public void testCloseQuietlyStatement()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testCloseQuietlyStatementThrowingException() throws Exception {\n        final Statement mockStatement = mock(Statement.class);\n        doThrow(SQLException.class).when(mockStatement).close();\n        DbUtils.closeQuietly(mockStatement);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testCloseQuietlyStatementThrowingException", "params": [], "body": "                                                                              {\n        final Statement mockStatement = mock(Statement.class);\n        doThrow(SQLException.class).when(mockStatement).close();\n        DbUtils.closeQuietly(mockStatement);\n    }", "signature": "@Test\n    public void testCloseQuietlyStatementThrowingException()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testCloseResultSet() throws Exception {\n        final ResultSet mockResultSet = mock(ResultSet.class);\n        DbUtils.close(mockResultSet);\n        verify(mockResultSet).close();\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testCloseResultSet", "params": [], "body": "                                                      {\n        final ResultSet mockResultSet = mock(ResultSet.class);\n        DbUtils.close(mockResultSet);\n        verify(mockResultSet).close();\n    }", "signature": "@Test\n    public void testCloseResultSet()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testCloseStatement() throws Exception {\n        final Statement mockStatement = mock(Statement.class);\n        DbUtils.close(mockStatement);\n        verify(mockStatement).close();\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testCloseStatement", "params": [], "body": "                                                      {\n        final Statement mockStatement = mock(Statement.class);\n        DbUtils.close(mockStatement);\n        verify(mockStatement).close();\n    }", "signature": "@Test\n    public void testCloseStatement()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testCommitAndClose() throws Exception {\n        final Connection mockConnection = mock(Connection.class);\n        DbUtils.commitAndClose(mockConnection);\n        verify(mockConnection).commit();\n        verify(mockConnection).close();\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testCommitAndClose", "params": [], "body": "                                                      {\n        final Connection mockConnection = mock(Connection.class);\n        DbUtils.commitAndClose(mockConnection);\n        verify(mockConnection).commit();\n        verify(mockConnection).close();\n    }", "signature": "@Test\n    public void testCommitAndClose()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testCommitAndCloseQuietly() throws Exception {\n        final Connection mockConnection = mock(Connection.class);\n        DbUtils.commitAndClose(mockConnection);\n        verify(mockConnection).commit();\n        verify(mockConnection).close();\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testCommitAndCloseQuietly", "params": [], "body": "                                                             {\n        final Connection mockConnection = mock(Connection.class);\n        DbUtils.commitAndClose(mockConnection);\n        verify(mockConnection).commit();\n        verify(mockConnection).close();\n    }", "signature": "@Test\n    public void testCommitAndCloseQuietly()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testCommitAndCloseQuietlyWithException() throws Exception {\n        final Connection mockConnection = mock(Connection.class);\n        doThrow(SQLException.class).when(mockConnection).close();\n        DbUtils.commitAndCloseQuietly(mockConnection);\n        verify(mockConnection).commit();\n        verify(mockConnection).close();\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testCommitAndCloseQuietlyWithException", "params": [], "body": "                                                                          {\n        final Connection mockConnection = mock(Connection.class);\n        doThrow(SQLException.class).when(mockConnection).close();\n        DbUtils.commitAndCloseQuietly(mockConnection);\n        verify(mockConnection).commit();\n        verify(mockConnection).close();\n    }", "signature": "@Test\n    public void testCommitAndCloseQuietlyWithException()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testCommitAndCloseQuietlyWithNullDoesNotThrowAnSQLException() {\n\n        DbUtils.commitAndCloseQuietly(null);\n\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testCommitAndCloseQuietlyWithNullDoesNotThrowAnSQLException", "params": [], "body": "                                                                              {\n\n        DbUtils.commitAndCloseQuietly(null);\n\n    }", "signature": "@Test\n    public void testCommitAndCloseQuietlyWithNullDoesNotThrowAnSQLException()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testCommitAndCloseWithException() throws Exception {\n        final Connection mockConnection = mock(Connection.class);\n        doThrow(SQLException.class).when(mockConnection).commit();\n        try {\n            DbUtils.commitAndClose(mockConnection);\n            fail(\"DbUtils.commitAndClose() swallowed SQLEception!\");\n        } catch (final SQLException e) {\n            // we expect this exception\n        }\n        verify(mockConnection).close();\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testCommitAndCloseWithException", "params": [], "body": "                                                                   {\n        final Connection mockConnection = mock(Connection.class);\n        doThrow(SQLException.class).when(mockConnection).commit();\n        try {\n            DbUtils.commitAndClose(mockConnection);\n            fail(\"DbUtils.commitAndClose() swallowed SQLEception!\");\n        } catch (final SQLException e) {\n            // we expect this exception\n        }\n        verify(mockConnection).close();\n    }", "signature": "@Test\n    public void testCommitAndCloseWithException()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testLoadDriverReturnsFalse() {\n\n        assertFalse(DbUtils.loadDriver(\"\"));\n\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testLoadDriverReturnsFalse", "params": [], "body": "                                             {\n\n        assertFalse(DbUtils.loadDriver(\"\"));\n\n    }", "signature": "@Test\n    public void testLoadDriverReturnsFalse()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testRollback() throws Exception {\n        final Connection mockConnection = mock(Connection.class);\n        DbUtils.rollback(mockConnection);\n        verify(mockConnection).rollback();\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testRollback", "params": [], "body": "                                                {\n        final Connection mockConnection = mock(Connection.class);\n        DbUtils.rollback(mockConnection);\n        verify(mockConnection).rollback();\n    }", "signature": "@Test\n    public void testRollback()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testRollbackAndClose() throws Exception {\n        final Connection mockConnection = mock(Connection.class);\n        DbUtils.rollbackAndClose(mockConnection);\n        verify(mockConnection).rollback();\n        verify(mockConnection).close();\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testRollbackAndClose", "params": [], "body": "                                                        {\n        final Connection mockConnection = mock(Connection.class);\n        DbUtils.rollbackAndClose(mockConnection);\n        verify(mockConnection).rollback();\n        verify(mockConnection).close();\n    }", "signature": "@Test\n    public void testRollbackAndClose()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testRollbackAndCloseNull() throws Exception {\n        DbUtils.rollbackAndClose(null);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testRollbackAndCloseNull", "params": [], "body": "                                                            {\n        DbUtils.rollbackAndClose(null);\n    }", "signature": "@Test\n    public void testRollbackAndCloseNull()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testRollbackAndCloseQuietly() throws Exception {\n        final Connection mockConnection = mock(Connection.class);\n        DbUtils.rollbackAndCloseQuietly(mockConnection);\n        verify(mockConnection).rollback();\n        verify(mockConnection).close();\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testRollbackAndCloseQuietly", "params": [], "body": "                                                               {\n        final Connection mockConnection = mock(Connection.class);\n        DbUtils.rollbackAndCloseQuietly(mockConnection);\n        verify(mockConnection).rollback();\n        verify(mockConnection).close();\n    }", "signature": "@Test\n    public void testRollbackAndCloseQuietly()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testRollbackAndCloseQuietlyNull() throws Exception {\n        DbUtils.rollbackAndCloseQuietly(null);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testRollbackAndCloseQuietlyNull", "params": [], "body": "                                                                   {\n        DbUtils.rollbackAndCloseQuietly(null);\n    }", "signature": "@Test\n    public void testRollbackAndCloseQuietlyNull()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testRollbackAndCloseQuietlyWithException() throws Exception {\n        final Connection mockConnection = mock(Connection.class);\n        doThrow(SQLException.class).when(mockConnection).rollback();\n        DbUtils.rollbackAndCloseQuietly(mockConnection);\n        verify(mockConnection).rollback();\n        verify(mockConnection).close();\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testRollbackAndCloseQuietlyWithException", "params": [], "body": "                                                                            {\n        final Connection mockConnection = mock(Connection.class);\n        doThrow(SQLException.class).when(mockConnection).rollback();\n        DbUtils.rollbackAndCloseQuietly(mockConnection);\n        verify(mockConnection).rollback();\n        verify(mockConnection).close();\n    }", "signature": "@Test\n    public void testRollbackAndCloseQuietlyWithException()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testRollbackAndCloseWithException() throws Exception {\n        final Connection mockConnection = mock(Connection.class);\n        doThrow(SQLException.class).when(mockConnection).rollback();\n        try {\n            DbUtils.rollbackAndClose(mockConnection);\n            fail(\"DbUtils.rollbackAndClose() swallowed SQLException!\");\n        } catch (final SQLException e) {\n            // we expect this exception\n        }\n        verify(mockConnection).rollback();\n        verify(mockConnection).close();\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testRollbackAndCloseWithException", "params": [], "body": "                                                                     {\n        final Connection mockConnection = mock(Connection.class);\n        doThrow(SQLException.class).when(mockConnection).rollback();\n        try {\n            DbUtils.rollbackAndClose(mockConnection);\n            fail(\"DbUtils.rollbackAndClose() swallowed SQLException!\");\n        } catch (final SQLException e) {\n            // we expect this exception\n        }\n        verify(mockConnection).rollback();\n        verify(mockConnection).close();\n    }", "signature": "@Test\n    public void testRollbackAndCloseWithException()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testRollbackNull() throws Exception {\n        DbUtils.rollback(null);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testRollbackNull", "params": [], "body": "                                                    {\n        DbUtils.rollback(null);\n    }", "signature": "@Test\n    public void testRollbackNull()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testRollbackQuietly() throws Exception {\n        final Connection mockConnection = mock(Connection.class);\n        DbUtils.rollbackQuietly(mockConnection);\n        verify(mockConnection).rollback();\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testRollbackQuietly", "params": [], "body": "                                                       {\n        final Connection mockConnection = mock(Connection.class);\n        DbUtils.rollbackQuietly(mockConnection);\n        verify(mockConnection).rollback();\n    }", "signature": "@Test\n    public void testRollbackQuietly()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testRollbackQuietlyNull() throws Exception {\n        DbUtils.rollbackQuietly(null);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testRollbackQuietlyNull", "params": [], "body": "                                                           {\n        DbUtils.rollbackQuietly(null);\n    }", "signature": "@Test\n    public void testRollbackQuietlyNull()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testRollbackQuietlyWithException() throws Exception {\n        final Connection mockConnection = mock(Connection.class);\n        doThrow(SQLException.class).when(mockConnection).rollback();\n        DbUtils.rollbackQuietly(mockConnection);\n        verify(mockConnection).rollback();\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testRollbackQuietlyWithException", "params": [], "body": "                                                                    {\n        final Connection mockConnection = mock(Connection.class);\n        doThrow(SQLException.class).when(mockConnection).rollback();\n        DbUtils.rollbackQuietly(mockConnection);\n        verify(mockConnection).rollback();\n    }", "signature": "@Test\n    public void testRollbackQuietlyWithException()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/dbutils/OutParameterTest.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.dbutils;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.ArgumentMatchers.eq;\nimport static org.mockito.Mockito.times;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\nimport java.sql.CallableStatement;\nimport java.sql.Types;\n\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.Mock;\nimport org.mockito.junit.MockitoJUnitRunner;\n\n@RunWith(MockitoJUnitRunner.class)\npublic class OutParameterTest {\n    private static final int INDEX = 2;\n    private static final int VALUE = 42;\n\n    @Mock\n    private CallableStatement stmt;\n\n    private OutParameter<Number> parameter;\n\n    @Before\n    public void setUp() throws Exception {\n        parameter = new OutParameter<>(Types.INTEGER, Number.class);\n    }\n\n    @Test\n    public void testRegister() throws Exception {\n        parameter.register(stmt, INDEX);\n        verify(stmt, times(1)).registerOutParameter(INDEX, Types.INTEGER);\n        verify(stmt, times(0)).setObject(eq(INDEX), any(Number.class));\n\n        parameter.setValue(VALUE);\n        parameter.register(stmt, INDEX);\n        verify(stmt, times(2)).registerOutParameter(INDEX, Types.INTEGER);\n        verify(stmt, times(1)).setObject(INDEX, VALUE);\n    }\n\n    @Test\n    public void testRegisterAlternateConstructor() throws Exception {\n        parameter = new OutParameter<>(Types.INTEGER, Number.class, VALUE);\n        parameter.register(stmt, INDEX);\n        verify(stmt, times(1)).registerOutParameter(INDEX, Types.INTEGER);\n        verify(stmt, times(1)).setObject(INDEX, VALUE);\n    }\n\n    @Test\n    public void testSetValue() throws Exception {\n        when(stmt.getObject(INDEX)).thenReturn(VALUE);\n\n        parameter.setValue(stmt, INDEX);\n\n        assertEquals(VALUE, parameter.getValue());\n    }\n\n}\n", "file_hash": "1798fd595eca1e1e51c97efd622fa932859829b40a00156d5cb315e0d466e0c4", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils;", "import static org.junit.Assert.assertEquals;", "import static org.mockito.ArgumentMatchers.any;", "import static org.mockito.ArgumentMatchers.eq;", "import static org.mockito.Mockito.times;", "import static org.mockito.Mockito.verify;", "import static org.mockito.Mockito.when;", "import java.sql.CallableStatement;", "import java.sql.Types;", "import org.junit.Before;", "import org.junit.Test;", "import org.junit.runner.RunWith;", "import org.mockito.Mock;", "import org.mockito.junit.MockitoJUnitRunner;"], "methods": [], "classes": [{"original_string": "@RunWith(MockitoJUnitRunner.class)\npublic class OutParameterTest {\n    private static final int INDEX = 2;\n    private static final int VALUE = 42;\n\n    @Mock\n    private CallableStatement stmt;\n\n    private OutParameter<Number> parameter;\n\n    @Before\n    public void setUp() throws Exception {\n        parameter = new OutParameter<>(Types.INTEGER, Number.class);\n    }\n\n    @Test\n    public void testRegister() throws Exception {\n        parameter.register(stmt, INDEX);\n        verify(stmt, times(1)).registerOutParameter(INDEX, Types.INTEGER);\n        verify(stmt, times(0)).setObject(eq(INDEX), any(Number.class));\n\n        parameter.setValue(VALUE);\n        parameter.register(stmt, INDEX);\n        verify(stmt, times(2)).registerOutParameter(INDEX, Types.INTEGER);\n        verify(stmt, times(1)).setObject(INDEX, VALUE);\n    }\n\n    @Test\n    public void testRegisterAlternateConstructor() throws Exception {\n        parameter = new OutParameter<>(Types.INTEGER, Number.class, VALUE);\n        parameter.register(stmt, INDEX);\n        verify(stmt, times(1)).registerOutParameter(INDEX, Types.INTEGER);\n        verify(stmt, times(1)).setObject(INDEX, VALUE);\n    }\n\n    @Test\n    public void testSetValue() throws Exception {\n        when(stmt.getObject(INDEX)).thenReturn(VALUE);\n\n        parameter.setValue(stmt, INDEX);\n\n        assertEquals(VALUE, parameter.getValue());\n    }\n\n}", "definition": "@RunWith(MockitoJUnitRunner.class)\npublic class OutParameterTest", "class_docstring": "", "name": "OutParameterTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "@RunWith(MockitoJUnitRunner.class)\npublic", "marker_annotations": [], "non_marker_annotations": ["@RunWith(MockitoJUnitRunner.class)", "public"], "comments": [], "fields": [{"attribute_expression": "private static final int INDEX = 2;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "int", "name": "INDEX = 2", "syntax_pass": true}, {"attribute_expression": "private static final int VALUE = 42;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "int", "name": "VALUE = 42", "syntax_pass": true}, {"attribute_expression": "@Mock\n    private CallableStatement stmt;", "docstring": "", "modifiers": "@Mock\n    private", "marker_annotations": ["@Mock"], "non_marker_annotations": ["private"], "comments": [], "type": "CallableStatement", "name": "stmt", "syntax_pass": true}, {"attribute_expression": "private OutParameter<Number> parameter;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "OutParameter<Number>", "name": "parameter", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Before\n    public void setUp() throws Exception {\n        parameter = new OutParameter<>(Types.INTEGER, Number.class);\n    }", "docstring": "", "attributes": {"modifiers": "@Before\n    public", "marker_annotations": ["@Before"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setUp", "params": [], "body": "                                         {\n        parameter = new OutParameter<>(Types.INTEGER, Number.class);\n    }", "signature": "@Before\n    public void setUp()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testRegister() throws Exception {\n        parameter.register(stmt, INDEX);\n        verify(stmt, times(1)).registerOutParameter(INDEX, Types.INTEGER);\n        verify(stmt, times(0)).setObject(eq(INDEX), any(Number.class));\n\n        parameter.setValue(VALUE);\n        parameter.register(stmt, INDEX);\n        verify(stmt, times(2)).registerOutParameter(INDEX, Types.INTEGER);\n        verify(stmt, times(1)).setObject(INDEX, VALUE);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testRegister", "params": [], "body": "                                                {\n        parameter.register(stmt, INDEX);\n        verify(stmt, times(1)).registerOutParameter(INDEX, Types.INTEGER);\n        verify(stmt, times(0)).setObject(eq(INDEX), any(Number.class));\n\n        parameter.setValue(VALUE);\n        parameter.register(stmt, INDEX);\n        verify(stmt, times(2)).registerOutParameter(INDEX, Types.INTEGER);\n        verify(stmt, times(1)).setObject(INDEX, VALUE);\n    }", "signature": "@Test\n    public void testRegister()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testRegisterAlternateConstructor() throws Exception {\n        parameter = new OutParameter<>(Types.INTEGER, Number.class, VALUE);\n        parameter.register(stmt, INDEX);\n        verify(stmt, times(1)).registerOutParameter(INDEX, Types.INTEGER);\n        verify(stmt, times(1)).setObject(INDEX, VALUE);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testRegisterAlternateConstructor", "params": [], "body": "                                                                    {\n        parameter = new OutParameter<>(Types.INTEGER, Number.class, VALUE);\n        parameter.register(stmt, INDEX);\n        verify(stmt, times(1)).registerOutParameter(INDEX, Types.INTEGER);\n        verify(stmt, times(1)).setObject(INDEX, VALUE);\n    }", "signature": "@Test\n    public void testRegisterAlternateConstructor()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testSetValue() throws Exception {\n        when(stmt.getObject(INDEX)).thenReturn(VALUE);\n\n        parameter.setValue(stmt, INDEX);\n\n        assertEquals(VALUE, parameter.getValue());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSetValue", "params": [], "body": "                                                {\n        when(stmt.getObject(INDEX)).thenReturn(VALUE);\n\n        parameter.setValue(stmt, INDEX);\n\n        assertEquals(VALUE, parameter.getValue());\n    }", "signature": "@Test\n    public void testSetValue()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/dbutils/OutParameter_toStringTest.java", "original_string": "\npackage org.apache.commons.dbutils;\n\nimport static org.junit.Assert.assertEquals;\nimport org.junit.Before;\nimport org.junit.Test;\n\npublic class OutParameter_toStringTest {\n    private OutParameter<Number> parameter;\n\n    @Before\n    public void setUp() {\n        parameter = new OutParameter<>(java.sql.Types.INTEGER, Number.class, 42);\n    }\n\n    @Test\n    public void testToStringWithInitialValue() {\n        String expected = \"OutParameter{sqlType=4, javaType=class java.lang.Number, value=42}\";\n        assertEquals(expected, parameter.toString());\n    }\n\n    @Test\n    public void testToStringAfterSetValue() {\n        parameter.setValue(100);\n        String expected = \"OutParameter{sqlType=4, javaType=class java.lang.Number, value=100}\";\n        assertEquals(expected, parameter.toString());\n    }\n\n    @Test\n    public void testToStringWithNullValue() {\n        parameter.setValue(null);\n        String expected = \"OutParameter{sqlType=4, javaType=class java.lang.Number, value=null}\";\n        assertEquals(expected, parameter.toString());\n    }\n}\n", "file_hash": "1dce93dfc6feee8bd90e3d5303e33bbba187bf49b2f01734b1a448de328ad869", "file_docstring": "", "contexts": ["package org.apache.commons.dbutils;", "import static org.junit.Assert.assertEquals;", "import org.junit.Before;", "import org.junit.Test;"], "methods": [], "classes": [{"original_string": "public class OutParameter_toStringTest {\n    private OutParameter<Number> parameter;\n\n    @Before\n    public void setUp() {\n        parameter = new OutParameter<>(java.sql.Types.INTEGER, Number.class, 42);\n    }\n\n    @Test\n    public void testToStringWithInitialValue() {\n        String expected = \"OutParameter{sqlType=4, javaType=class java.lang.Number, value=42}\";\n        assertEquals(expected, parameter.toString());\n    }\n\n    @Test\n    public void testToStringAfterSetValue() {\n        parameter.setValue(100);\n        String expected = \"OutParameter{sqlType=4, javaType=class java.lang.Number, value=100}\";\n        assertEquals(expected, parameter.toString());\n    }\n\n    @Test\n    public void testToStringWithNullValue() {\n        parameter.setValue(null);\n        String expected = \"OutParameter{sqlType=4, javaType=class java.lang.Number, value=null}\";\n        assertEquals(expected, parameter.toString());\n    }\n}", "definition": "public class OutParameter_toStringTest", "class_docstring": "", "name": "OutParameter_toStringTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private OutParameter<Number> parameter;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "OutParameter<Number>", "name": "parameter", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Before\n    public void setUp() {\n        parameter = new OutParameter<>(java.sql.Types.INTEGER, Number.class, 42);\n    }", "docstring": "", "attributes": {"modifiers": "@Before\n    public", "marker_annotations": ["@Before"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setUp", "params": [], "body": "                        {\n        parameter = new OutParameter<>(java.sql.Types.INTEGER, Number.class, 42);\n    }", "signature": "@Before\n    public void setUp()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testToStringWithInitialValue() {\n        String expected = \"OutParameter{sqlType=4, javaType=class java.lang.Number, value=42}\";\n        assertEquals(expected, parameter.toString());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testToStringWithInitialValue", "params": [], "body": "                                               {\n        String expected = \"OutParameter{sqlType=4, javaType=class java.lang.Number, value=42}\";\n        assertEquals(expected, parameter.toString());\n    }", "signature": "@Test\n    public void testToStringWithInitialValue()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testToStringAfterSetValue() {\n        parameter.setValue(100);\n        String expected = \"OutParameter{sqlType=4, javaType=class java.lang.Number, value=100}\";\n        assertEquals(expected, parameter.toString());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testToStringAfterSetValue", "params": [], "body": "                                            {\n        parameter.setValue(100);\n        String expected = \"OutParameter{sqlType=4, javaType=class java.lang.Number, value=100}\";\n        assertEquals(expected, parameter.toString());\n    }", "signature": "@Test\n    public void testToStringAfterSetValue()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testToStringWithNullValue() {\n        parameter.setValue(null);\n        String expected = \"OutParameter{sqlType=4, javaType=class java.lang.Number, value=null}\";\n        assertEquals(expected, parameter.toString());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testToStringWithNullValue", "params": [], "body": "                                            {\n        parameter.setValue(null);\n        String expected = \"OutParameter{sqlType=4, javaType=class java.lang.Number, value=null}\";\n        assertEquals(expected, parameter.toString());\n    }", "signature": "@Test\n    public void testToStringWithNullValue()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/dbutils/GenerousBeanProcessorTest.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNotNull;\nimport static org.mockito.Mockito.when;\n\nimport java.beans.PropertyDescriptor;\nimport java.sql.ResultSetMetaData;\n\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.Mock;\nimport org.mockito.junit.MockitoJUnitRunner;\n\n@RunWith(MockitoJUnitRunner.class)\npublic class GenerousBeanProcessorTest {\n\n    static class TestBean {\n        private String one;\n        private int two;\n        private long three;\n\n        public String getOne() {\n            return one;\n        }\n\n        public long getThree() {\n            return three;\n        }\n\n        public int getTwo() {\n            return two;\n        }\n\n        public void setOne(final String one) {\n            this.one = one;\n        }\n\n        public void setThree(final long three) {\n            this.three = three;\n        }\n\n        public void setTwo(final int two) {\n            this.two = two;\n        }\n    }\n\n    private final GenerousBeanProcessor processor = new GenerousBeanProcessor();\n    @Mock\n    private ResultSetMetaData metaData;\n\n    private PropertyDescriptor[] propDescriptors;\n\n    @Before\n    public void setUp() throws Exception {\n        propDescriptors = new PropertyDescriptor[3];\n\n        propDescriptors[0] = new PropertyDescriptor(\"one\", TestBean.class);\n        propDescriptors[1] = new PropertyDescriptor(\"two\", TestBean.class);\n        propDescriptors[2] = new PropertyDescriptor(\"three\", TestBean.class);\n    }\n\n    @SuppressWarnings(\"boxing\") // test code\n    @Test\n    public void testMapColumnsToPropertiesColumnLabelIsNull() throws Exception {\n        when(metaData.getColumnCount()).thenReturn(1);\n        when(metaData.getColumnName(1)).thenReturn(\"juhu\");\n        when(metaData.getColumnLabel(1)).thenReturn(null);\n\n        final int[] ret = processor.mapColumnsToProperties(metaData, propDescriptors);\n\n        assertNotNull(ret);\n        assertEquals(2, ret.length);\n        assertEquals(-1, ret[0]);\n        assertEquals(-1, ret[1]);\n    }\n\n    @SuppressWarnings(\"boxing\") // test code\n    @Test\n    public void testMapColumnsToPropertiesMixedCase() throws Exception {\n        when(metaData.getColumnCount()).thenReturn(3);\n\n        when(metaData.getColumnLabel(1)).thenReturn(\"tHree\");\n        when(metaData.getColumnLabel(2)).thenReturn(\"One\");\n        when(metaData.getColumnLabel(3)).thenReturn(\"tWO\");\n\n        final int[] ret = processor.mapColumnsToProperties(metaData, propDescriptors);\n\n        assertNotNull(ret);\n        assertEquals(4, ret.length);\n        assertEquals(-1, ret[0]);\n        assertEquals(2, ret[1]);\n        assertEquals(0, ret[2]);\n        assertEquals(1, ret[3]);\n    }\n\n    @SuppressWarnings(\"boxing\") // test code\n    @Test\n    public void testMapColumnsToPropertiesWithOutUnderscores() throws Exception {\n        when(metaData.getColumnCount()).thenReturn(3);\n\n        when(metaData.getColumnLabel(1)).thenReturn(\"three\");\n        when(metaData.getColumnLabel(2)).thenReturn(\"one\");\n        when(metaData.getColumnLabel(3)).thenReturn(\"two\");\n\n        final int[] ret = processor.mapColumnsToProperties(metaData, propDescriptors);\n\n        assertNotNull(ret);\n        assertEquals(4, ret.length);\n        assertEquals(-1, ret[0]);\n        assertEquals(2, ret[1]);\n        assertEquals(0, ret[2]);\n        assertEquals(1, ret[3]);\n    }\n\n    @SuppressWarnings(\"boxing\") // test code\n    @Test\n    public void testMapColumnsToPropertiesWithSpaces() throws Exception {\n        when(metaData.getColumnCount()).thenReturn(3);\n\n        when(metaData.getColumnLabel(1)).thenReturn(\"th ree\");\n        when(metaData.getColumnLabel(2)).thenReturn(\"o n e\");\n        when(metaData.getColumnLabel(3)).thenReturn(\"t wo\");\n\n        final int[] ret = processor.mapColumnsToProperties(metaData, propDescriptors);\n\n        assertNotNull(ret);\n        assertEquals(4, ret.length);\n        assertEquals(-1, ret[0]);\n        assertEquals(2, ret[1]);\n        assertEquals(0, ret[2]);\n        assertEquals(1, ret[3]);\n    }\n\n    @SuppressWarnings(\"boxing\") // test code\n    @Test\n    public void testMapColumnsToPropertiesWithUnderscores() throws Exception {\n        when(metaData.getColumnCount()).thenReturn(3);\n\n        when(metaData.getColumnLabel(1)).thenReturn(\"t_h_r_e_e\");\n        when(metaData.getColumnLabel(2)).thenReturn(\"o_n_e\");\n        when(metaData.getColumnLabel(3)).thenReturn(\"t_w_o\");\n\n        final int[] ret = processor.mapColumnsToProperties(metaData, propDescriptors);\n\n        assertNotNull(ret);\n        assertEquals(4, ret.length);\n        assertEquals(-1, ret[0]);\n        assertEquals(2, ret[1]);\n        assertEquals(0, ret[2]);\n        assertEquals(1, ret[3]);\n    }\n\n}\n", "file_hash": "651fd82cb758224b416f1867f509c00798481a895e1bdb1525e8cc5e8d4cb73d", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils;", "import static org.junit.Assert.assertEquals;", "import static org.junit.Assert.assertNotNull;", "import static org.mockito.Mockito.when;", "import java.beans.PropertyDescriptor;", "import java.sql.ResultSetMetaData;", "import org.junit.Before;", "import org.junit.Test;", "import org.junit.runner.RunWith;", "import org.mockito.Mock;", "import org.mockito.junit.MockitoJUnitRunner;"], "methods": [], "classes": [{"original_string": "@RunWith(MockitoJUnitRunner.class)\npublic class GenerousBeanProcessorTest {\n\n    static class TestBean {\n        private String one;\n        private int two;\n        private long three;\n\n        public String getOne() {\n            return one;\n        }\n\n        public long getThree() {\n            return three;\n        }\n\n        public int getTwo() {\n            return two;\n        }\n\n        public void setOne(final String one) {\n            this.one = one;\n        }\n\n        public void setThree(final long three) {\n            this.three = three;\n        }\n\n        public void setTwo(final int two) {\n            this.two = two;\n        }\n    }\n\n    private final GenerousBeanProcessor processor = new GenerousBeanProcessor();\n    @Mock\n    private ResultSetMetaData metaData;\n\n    private PropertyDescriptor[] propDescriptors;\n\n    @Before\n    public void setUp() throws Exception {\n        propDescriptors = new PropertyDescriptor[3];\n\n        propDescriptors[0] = new PropertyDescriptor(\"one\", TestBean.class);\n        propDescriptors[1] = new PropertyDescriptor(\"two\", TestBean.class);\n        propDescriptors[2] = new PropertyDescriptor(\"three\", TestBean.class);\n    }\n\n    @SuppressWarnings(\"boxing\") // test code\n    @Test\n    public void testMapColumnsToPropertiesColumnLabelIsNull() throws Exception {\n        when(metaData.getColumnCount()).thenReturn(1);\n        when(metaData.getColumnName(1)).thenReturn(\"juhu\");\n        when(metaData.getColumnLabel(1)).thenReturn(null);\n\n        final int[] ret = processor.mapColumnsToProperties(metaData, propDescriptors);\n\n        assertNotNull(ret);\n        assertEquals(2, ret.length);\n        assertEquals(-1, ret[0]);\n        assertEquals(-1, ret[1]);\n    }\n\n    @SuppressWarnings(\"boxing\") // test code\n    @Test\n    public void testMapColumnsToPropertiesMixedCase() throws Exception {\n        when(metaData.getColumnCount()).thenReturn(3);\n\n        when(metaData.getColumnLabel(1)).thenReturn(\"tHree\");\n        when(metaData.getColumnLabel(2)).thenReturn(\"One\");\n        when(metaData.getColumnLabel(3)).thenReturn(\"tWO\");\n\n        final int[] ret = processor.mapColumnsToProperties(metaData, propDescriptors);\n\n        assertNotNull(ret);\n        assertEquals(4, ret.length);\n        assertEquals(-1, ret[0]);\n        assertEquals(2, ret[1]);\n        assertEquals(0, ret[2]);\n        assertEquals(1, ret[3]);\n    }\n\n    @SuppressWarnings(\"boxing\") // test code\n    @Test\n    public void testMapColumnsToPropertiesWithOutUnderscores() throws Exception {\n        when(metaData.getColumnCount()).thenReturn(3);\n\n        when(metaData.getColumnLabel(1)).thenReturn(\"three\");\n        when(metaData.getColumnLabel(2)).thenReturn(\"one\");\n        when(metaData.getColumnLabel(3)).thenReturn(\"two\");\n\n        final int[] ret = processor.mapColumnsToProperties(metaData, propDescriptors);\n\n        assertNotNull(ret);\n        assertEquals(4, ret.length);\n        assertEquals(-1, ret[0]);\n        assertEquals(2, ret[1]);\n        assertEquals(0, ret[2]);\n        assertEquals(1, ret[3]);\n    }\n\n    @SuppressWarnings(\"boxing\") // test code\n    @Test\n    public void testMapColumnsToPropertiesWithSpaces() throws Exception {\n        when(metaData.getColumnCount()).thenReturn(3);\n\n        when(metaData.getColumnLabel(1)).thenReturn(\"th ree\");\n        when(metaData.getColumnLabel(2)).thenReturn(\"o n e\");\n        when(metaData.getColumnLabel(3)).thenReturn(\"t wo\");\n\n        final int[] ret = processor.mapColumnsToProperties(metaData, propDescriptors);\n\n        assertNotNull(ret);\n        assertEquals(4, ret.length);\n        assertEquals(-1, ret[0]);\n        assertEquals(2, ret[1]);\n        assertEquals(0, ret[2]);\n        assertEquals(1, ret[3]);\n    }\n\n    @SuppressWarnings(\"boxing\") // test code\n    @Test\n    public void testMapColumnsToPropertiesWithUnderscores() throws Exception {\n        when(metaData.getColumnCount()).thenReturn(3);\n\n        when(metaData.getColumnLabel(1)).thenReturn(\"t_h_r_e_e\");\n        when(metaData.getColumnLabel(2)).thenReturn(\"o_n_e\");\n        when(metaData.getColumnLabel(3)).thenReturn(\"t_w_o\");\n\n        final int[] ret = processor.mapColumnsToProperties(metaData, propDescriptors);\n\n        assertNotNull(ret);\n        assertEquals(4, ret.length);\n        assertEquals(-1, ret[0]);\n        assertEquals(2, ret[1]);\n        assertEquals(0, ret[2]);\n        assertEquals(1, ret[3]);\n    }\n\n}", "definition": "@RunWith(MockitoJUnitRunner.class)\npublic class GenerousBeanProcessorTest", "class_docstring": "", "name": "GenerousBeanProcessorTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "@RunWith(MockitoJUnitRunner.class)\npublic", "marker_annotations": [], "non_marker_annotations": ["@RunWith(MockitoJUnitRunner.class)", "public"], "comments": [], "fields": [{"attribute_expression": "private final GenerousBeanProcessor processor = new GenerousBeanProcessor();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "GenerousBeanProcessor", "name": "processor = new GenerousBeanProcessor()", "syntax_pass": true}, {"attribute_expression": "@Mock\n    private ResultSetMetaData metaData;", "docstring": "", "modifiers": "@Mock\n    private", "marker_annotations": ["@Mock"], "non_marker_annotations": ["private"], "comments": [], "type": "ResultSetMetaData", "name": "metaData", "syntax_pass": true}, {"attribute_expression": "private PropertyDescriptor[] propDescriptors;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "PropertyDescriptor[]", "name": "propDescriptors", "syntax_pass": true}], "classes": [{"original_string": "    static class TestBean {\n        private String one;\n        private int two;\n        private long three;\n\n        public String getOne() {\n            return one;\n        }\n\n        public long getThree() {\n            return three;\n        }\n\n        public int getTwo() {\n            return two;\n        }\n\n        public void setOne(final String one) {\n            this.one = one;\n        }\n\n        public void setThree(final long three) {\n            this.three = three;\n        }\n\n        public void setTwo(final int two) {\n            this.two = two;\n        }\n    }", "definition": "    static class TestBean", "class_docstring": "", "name": "TestBean", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "private String one;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "one", "syntax_pass": true}, {"attribute_expression": "private int two;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "two", "syntax_pass": true}, {"attribute_expression": "private long three;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "long", "name": "three", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public String getOne() {\n            return one;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getOne", "params": [], "body": "                               {\n            return one;\n        }", "signature": "public String getOne()"}, {"syntax_pass": true, "original_string": "        public long getThree() {\n            return three;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "long", "classes": []}, "name": "getThree", "params": [], "body": "                               {\n            return three;\n        }", "signature": "public long getThree()"}, {"syntax_pass": true, "original_string": "        public int getTwo() {\n            return two;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "getTwo", "params": [], "body": "                            {\n            return two;\n        }", "signature": "public int getTwo()"}, {"syntax_pass": true, "original_string": "        public void setOne(final String one) {\n            this.one = one;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setOne", "params": [{"name": "one", "type": "String"}], "body": "                                             {\n            this.one = one;\n        }", "signature": "public void setOne(final String one)"}, {"syntax_pass": true, "original_string": "        public void setThree(final long three) {\n            this.three = three;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setThree", "params": [{"name": "three", "type": "long"}], "body": "                                               {\n            this.three = three;\n        }", "signature": "public void setThree(final long three)"}, {"syntax_pass": true, "original_string": "        public void setTwo(final int two) {\n            this.two = two;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setTwo", "params": [{"name": "two", "type": "int"}], "body": "                                          {\n            this.two = two;\n        }", "signature": "public void setTwo(final int two)"}]}]}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Before\n    public void setUp() throws Exception {\n        propDescriptors = new PropertyDescriptor[3];\n\n        propDescriptors[0] = new PropertyDescriptor(\"one\", TestBean.class);\n        propDescriptors[1] = new PropertyDescriptor(\"two\", TestBean.class);\n        propDescriptors[2] = new PropertyDescriptor(\"three\", TestBean.class);\n    }", "docstring": "", "attributes": {"modifiers": "@Before\n    public", "marker_annotations": ["@Before"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setUp", "params": [], "body": "                                         {\n        propDescriptors = new PropertyDescriptor[3];\n\n        propDescriptors[0] = new PropertyDescriptor(\"one\", TestBean.class);\n        propDescriptors[1] = new PropertyDescriptor(\"two\", TestBean.class);\n        propDescriptors[2] = new PropertyDescriptor(\"three\", TestBean.class);\n    }", "signature": "@Before\n    public void setUp()"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"boxing\") // test code\n    @Test\n    public void testMapColumnsToPropertiesColumnLabelIsNull() throws Exception {\n        when(metaData.getColumnCount()).thenReturn(1);\n        when(metaData.getColumnName(1)).thenReturn(\"juhu\");\n        when(metaData.getColumnLabel(1)).thenReturn(null);\n\n        final int[] ret = processor.mapColumnsToProperties(metaData, propDescriptors);\n\n        assertNotNull(ret);\n        assertEquals(2, ret.length);\n        assertEquals(-1, ret[0]);\n        assertEquals(-1, ret[1]);\n    }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"boxing\") // test code\n    @Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["@SuppressWarnings(\"boxing\")", "public"], "comments": ["// test code"], "return_type": "void", "classes": []}, "name": "testMapColumnsToPropertiesColumnLabelIsNull", "params": [], "body": "                                                                               {\n        when(metaData.getColumnCount()).thenReturn(1);\n        when(metaData.getColumnName(1)).thenReturn(\"juhu\");\n        when(metaData.getColumnLabel(1)).thenReturn(null);\n\n        final int[] ret = processor.mapColumnsToProperties(metaData, propDescriptors);\n\n        assertNotNull(ret);\n        assertEquals(2, ret.length);\n        assertEquals(-1, ret[0]);\n        assertEquals(-1, ret[1]);\n    }", "signature": "@SuppressWarnings(\"boxing\") // test code\n    @Test\n    public void testMapColumnsToPropertiesColumnLabelIsNull()"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"boxing\") // test code\n    @Test\n    public void testMapColumnsToPropertiesMixedCase() throws Exception {\n        when(metaData.getColumnCount()).thenReturn(3);\n\n        when(metaData.getColumnLabel(1)).thenReturn(\"tHree\");\n        when(metaData.getColumnLabel(2)).thenReturn(\"One\");\n        when(metaData.getColumnLabel(3)).thenReturn(\"tWO\");\n\n        final int[] ret = processor.mapColumnsToProperties(metaData, propDescriptors);\n\n        assertNotNull(ret);\n        assertEquals(4, ret.length);\n        assertEquals(-1, ret[0]);\n        assertEquals(2, ret[1]);\n        assertEquals(0, ret[2]);\n        assertEquals(1, ret[3]);\n    }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"boxing\") // test code\n    @Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["@SuppressWarnings(\"boxing\")", "public"], "comments": ["// test code"], "return_type": "void", "classes": []}, "name": "testMapColumnsToPropertiesMixedCase", "params": [], "body": "                                                                       {\n        when(metaData.getColumnCount()).thenReturn(3);\n\n        when(metaData.getColumnLabel(1)).thenReturn(\"tHree\");\n        when(metaData.getColumnLabel(2)).thenReturn(\"One\");\n        when(metaData.getColumnLabel(3)).thenReturn(\"tWO\");\n\n        final int[] ret = processor.mapColumnsToProperties(metaData, propDescriptors);\n\n        assertNotNull(ret);\n        assertEquals(4, ret.length);\n        assertEquals(-1, ret[0]);\n        assertEquals(2, ret[1]);\n        assertEquals(0, ret[2]);\n        assertEquals(1, ret[3]);\n    }", "signature": "@SuppressWarnings(\"boxing\") // test code\n    @Test\n    public void testMapColumnsToPropertiesMixedCase()"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"boxing\") // test code\n    @Test\n    public void testMapColumnsToPropertiesWithOutUnderscores() throws Exception {\n        when(metaData.getColumnCount()).thenReturn(3);\n\n        when(metaData.getColumnLabel(1)).thenReturn(\"three\");\n        when(metaData.getColumnLabel(2)).thenReturn(\"one\");\n        when(metaData.getColumnLabel(3)).thenReturn(\"two\");\n\n        final int[] ret = processor.mapColumnsToProperties(metaData, propDescriptors);\n\n        assertNotNull(ret);\n        assertEquals(4, ret.length);\n        assertEquals(-1, ret[0]);\n        assertEquals(2, ret[1]);\n        assertEquals(0, ret[2]);\n        assertEquals(1, ret[3]);\n    }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"boxing\") // test code\n    @Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["@SuppressWarnings(\"boxing\")", "public"], "comments": ["// test code"], "return_type": "void", "classes": []}, "name": "testMapColumnsToPropertiesWithOutUnderscores", "params": [], "body": "                                                                                {\n        when(metaData.getColumnCount()).thenReturn(3);\n\n        when(metaData.getColumnLabel(1)).thenReturn(\"three\");\n        when(metaData.getColumnLabel(2)).thenReturn(\"one\");\n        when(metaData.getColumnLabel(3)).thenReturn(\"two\");\n\n        final int[] ret = processor.mapColumnsToProperties(metaData, propDescriptors);\n\n        assertNotNull(ret);\n        assertEquals(4, ret.length);\n        assertEquals(-1, ret[0]);\n        assertEquals(2, ret[1]);\n        assertEquals(0, ret[2]);\n        assertEquals(1, ret[3]);\n    }", "signature": "@SuppressWarnings(\"boxing\") // test code\n    @Test\n    public void testMapColumnsToPropertiesWithOutUnderscores()"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"boxing\") // test code\n    @Test\n    public void testMapColumnsToPropertiesWithSpaces() throws Exception {\n        when(metaData.getColumnCount()).thenReturn(3);\n\n        when(metaData.getColumnLabel(1)).thenReturn(\"th ree\");\n        when(metaData.getColumnLabel(2)).thenReturn(\"o n e\");\n        when(metaData.getColumnLabel(3)).thenReturn(\"t wo\");\n\n        final int[] ret = processor.mapColumnsToProperties(metaData, propDescriptors);\n\n        assertNotNull(ret);\n        assertEquals(4, ret.length);\n        assertEquals(-1, ret[0]);\n        assertEquals(2, ret[1]);\n        assertEquals(0, ret[2]);\n        assertEquals(1, ret[3]);\n    }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"boxing\") // test code\n    @Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["@SuppressWarnings(\"boxing\")", "public"], "comments": ["// test code"], "return_type": "void", "classes": []}, "name": "testMapColumnsToPropertiesWithSpaces", "params": [], "body": "                                                                        {\n        when(metaData.getColumnCount()).thenReturn(3);\n\n        when(metaData.getColumnLabel(1)).thenReturn(\"th ree\");\n        when(metaData.getColumnLabel(2)).thenReturn(\"o n e\");\n        when(metaData.getColumnLabel(3)).thenReturn(\"t wo\");\n\n        final int[] ret = processor.mapColumnsToProperties(metaData, propDescriptors);\n\n        assertNotNull(ret);\n        assertEquals(4, ret.length);\n        assertEquals(-1, ret[0]);\n        assertEquals(2, ret[1]);\n        assertEquals(0, ret[2]);\n        assertEquals(1, ret[3]);\n    }", "signature": "@SuppressWarnings(\"boxing\") // test code\n    @Test\n    public void testMapColumnsToPropertiesWithSpaces()"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"boxing\") // test code\n    @Test\n    public void testMapColumnsToPropertiesWithUnderscores() throws Exception {\n        when(metaData.getColumnCount()).thenReturn(3);\n\n        when(metaData.getColumnLabel(1)).thenReturn(\"t_h_r_e_e\");\n        when(metaData.getColumnLabel(2)).thenReturn(\"o_n_e\");\n        when(metaData.getColumnLabel(3)).thenReturn(\"t_w_o\");\n\n        final int[] ret = processor.mapColumnsToProperties(metaData, propDescriptors);\n\n        assertNotNull(ret);\n        assertEquals(4, ret.length);\n        assertEquals(-1, ret[0]);\n        assertEquals(2, ret[1]);\n        assertEquals(0, ret[2]);\n        assertEquals(1, ret[3]);\n    }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"boxing\") // test code\n    @Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["@SuppressWarnings(\"boxing\")", "public"], "comments": ["// test code"], "return_type": "void", "classes": []}, "name": "testMapColumnsToPropertiesWithUnderscores", "params": [], "body": "                                                                             {\n        when(metaData.getColumnCount()).thenReturn(3);\n\n        when(metaData.getColumnLabel(1)).thenReturn(\"t_h_r_e_e\");\n        when(metaData.getColumnLabel(2)).thenReturn(\"o_n_e\");\n        when(metaData.getColumnLabel(3)).thenReturn(\"t_w_o\");\n\n        final int[] ret = processor.mapColumnsToProperties(metaData, propDescriptors);\n\n        assertNotNull(ret);\n        assertEquals(4, ret.length);\n        assertEquals(-1, ret[0]);\n        assertEquals(2, ret[1]);\n        assertEquals(0, ret[2]);\n        assertEquals(1, ret[3]);\n    }", "signature": "@SuppressWarnings(\"boxing\") // test code\n    @Test\n    public void testMapColumnsToPropertiesWithUnderscores()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/dbutils/MockResultSetMetaData.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils;\n\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.sql.ResultSetMetaData;\n\n/**\n * MockResultSetMetaData dynamically implements the ResultSetMetaData interface.\n */\npublic class MockResultSetMetaData implements InvocationHandler {\n\n    /**\n     * Create a {@code MockResultSetMetaData} proxy object. This is equivalent to:\n     *\n     * <pre>\n     * ProxyFactory.instance().createResultSetMetaData(new MockResultSetMetaData(columnNames));\n     * </pre>\n     *\n     * @param columnNames\n     * @return the proxy object\n     */\n    public static ResultSetMetaData create(final String[] columnNames) {\n        return ProxyFactory.instance().createResultSetMetaData(new MockResultSetMetaData(columnNames));\n    }\n\n    private final String[] columnNames;\n\n    private final String[] columnLabels;\n\n    public MockResultSetMetaData(final String[] columnNames) {\n        this.columnNames = columnNames;\n        this.columnLabels = new String[columnNames.length];\n\n    }\n\n    public MockResultSetMetaData(final String[] columnNames, final String[] columnLabels) {\n        this.columnNames = columnNames;\n        this.columnLabels = columnLabels;\n    }\n\n    @Override\n    public Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable {\n        final String methodName = method.getName();\n        switch (methodName) {\n        case \"getColumnCount\":\n            return Integer.valueOf(this.columnNames.length);\n        case \"getColumnName\":\n            final int col1 = ((Integer) args[0]).intValue() - 1;\n            return this.columnNames[col1];\n        case \"getColumnLabel\":\n            final int col2 = ((Integer) args[0]).intValue() - 1;\n            return this.columnLabels[col2];\n        case \"hashCode\":\n            return Integer.valueOf(System.identityHashCode(proxy));\n        case \"toString\":\n            return \"MockResultSetMetaData \" + System.identityHashCode(proxy);\n        case \"equals\":\n            return Boolean.valueOf(proxy == args[0]);\n        default:\n            break;\n        }\n        throw new UnsupportedOperationException(\"Unsupported method: \" + methodName);\n    }\n}\n", "file_hash": "5beb63a9f3a67c344bbfcb19ce271e261281ae31b9eb8d0d07f9ee113550b43a", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils;", "import java.lang.reflect.InvocationHandler;", "import java.lang.reflect.Method;", "import java.sql.ResultSetMetaData;"], "methods": [], "classes": [{"original_string": "public class MockResultSetMetaData implements InvocationHandler {\n\n    /**\n     * Create a {@code MockResultSetMetaData} proxy object. This is equivalent to:\n     *\n     * <pre>\n     * ProxyFactory.instance().createResultSetMetaData(new MockResultSetMetaData(columnNames));\n     * </pre>\n     *\n     * @param columnNames\n     * @return the proxy object\n     */\n    public static ResultSetMetaData create(final String[] columnNames) {\n        return ProxyFactory.instance().createResultSetMetaData(new MockResultSetMetaData(columnNames));\n    }\n\n    private final String[] columnNames;\n\n    private final String[] columnLabels;\n\n    public MockResultSetMetaData(final String[] columnNames) {\n        this.columnNames = columnNames;\n        this.columnLabels = new String[columnNames.length];\n\n    }\n\n    public MockResultSetMetaData(final String[] columnNames, final String[] columnLabels) {\n        this.columnNames = columnNames;\n        this.columnLabels = columnLabels;\n    }\n\n    @Override\n    public Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable {\n        final String methodName = method.getName();\n        switch (methodName) {\n        case \"getColumnCount\":\n            return Integer.valueOf(this.columnNames.length);\n        case \"getColumnName\":\n            final int col1 = ((Integer) args[0]).intValue() - 1;\n            return this.columnNames[col1];\n        case \"getColumnLabel\":\n            final int col2 = ((Integer) args[0]).intValue() - 1;\n            return this.columnLabels[col2];\n        case \"hashCode\":\n            return Integer.valueOf(System.identityHashCode(proxy));\n        case \"toString\":\n            return \"MockResultSetMetaData \" + System.identityHashCode(proxy);\n        case \"equals\":\n            return Boolean.valueOf(proxy == args[0]);\n        default:\n            break;\n        }\n        throw new UnsupportedOperationException(\"Unsupported method: \" + methodName);\n    }\n}", "definition": "public class MockResultSetMetaData implements InvocationHandler", "class_docstring": "\nMockResultSetMetaData dynamically implements the ResultSetMetaData interface.\n", "name": "MockResultSetMetaData", "super_interfaces": ["InvocationHandler"], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final String[] columnNames;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String[]", "name": "columnNames", "syntax_pass": true}, {"attribute_expression": "private final String[] columnLabels;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String[]", "name": "columnLabels", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public static ResultSetMetaData create(final String[] columnNames) {\n        return ProxyFactory.instance().createResultSetMetaData(new MockResultSetMetaData(columnNames));\n    }", "docstring": "\nCreate a {@code MockResultSetMetaData} proxy object. This is equivalent to:\n\n<pre>\nProxyFactory.instance().createResultSetMetaData(new MockResultSetMetaData(columnNames));\n</pre>\n\n@param columnNames\n@return the proxy object\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "ResultSetMetaData", "classes": []}, "name": "create", "params": [{"name": "columnNames", "type": "String[]"}], "body": "                                                                       {\n        return ProxyFactory.instance().createResultSetMetaData(new MockResultSetMetaData(columnNames));\n    }", "signature": "public static ResultSetMetaData create(final String[] columnNames)"}, {"syntax_pass": true, "original_string": "    public MockResultSetMetaData(final String[] columnNames) {\n        this.columnNames = columnNames;\n        this.columnLabels = new String[columnNames.length];\n\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "MockResultSetMetaData", "params": [{"name": "columnNames", "type": "String[]"}], "body": "                                                             {\n        this.columnNames = columnNames;\n        this.columnLabels = new String[columnNames.length];\n\n    }", "signature": "public MockResultSetMetaData(final String[] columnNames)"}, {"syntax_pass": true, "original_string": "    public MockResultSetMetaData(final String[] columnNames, final String[] columnLabels) {\n        this.columnNames = columnNames;\n        this.columnLabels = columnLabels;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "MockResultSetMetaData", "params": [{"name": "columnNames", "type": "String[]"}, {"name": "columnLabels", "type": "String[]"}], "body": "                                                                                          {\n        this.columnNames = columnNames;\n        this.columnLabels = columnLabels;\n    }", "signature": "public MockResultSetMetaData(final String[] columnNames, final String[] columnLabels)"}, {"syntax_pass": true, "original_string": "    @Override\n    public Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable {\n        final String methodName = method.getName();\n        switch (methodName) {\n        case \"getColumnCount\":\n            return Integer.valueOf(this.columnNames.length);\n        case \"getColumnName\":\n            final int col1 = ((Integer) args[0]).intValue() - 1;\n            return this.columnNames[col1];\n        case \"getColumnLabel\":\n            final int col2 = ((Integer) args[0]).intValue() - 1;\n            return this.columnLabels[col2];\n        case \"hashCode\":\n            return Integer.valueOf(System.identityHashCode(proxy));\n        case \"toString\":\n            return \"MockResultSetMetaData \" + System.identityHashCode(proxy);\n        case \"equals\":\n            return Boolean.valueOf(proxy == args[0]);\n        default:\n            break;\n        }\n        throw new UnsupportedOperationException(\"Unsupported method: \" + methodName);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object", "classes": []}, "name": "invoke", "params": [{"name": "proxy", "type": "Object"}, {"name": "method", "type": "Method"}, {"name": "args", "type": "Object[]"}], "body": "                                                                                                        {\n        final String methodName = method.getName();\n        switch (methodName) {\n        case \"getColumnCount\":\n            return Integer.valueOf(this.columnNames.length);\n        case \"getColumnName\":\n            final int col1 = ((Integer) args[0]).intValue() - 1;\n            return this.columnNames[col1];\n        case \"getColumnLabel\":\n            final int col2 = ((Integer) args[0]).intValue() - 1;\n            return this.columnLabels[col2];\n        case \"hashCode\":\n            return Integer.valueOf(System.identityHashCode(proxy));\n        case \"toString\":\n            return \"MockResultSetMetaData \" + System.identityHashCode(proxy);\n        case \"equals\":\n            return Boolean.valueOf(proxy == args[0]);\n        default:\n            break;\n        }\n        throw new UnsupportedOperationException(\"Unsupported method: \" + methodName);\n    }", "signature": "@Override\n    public Object invoke(final Object proxy, final Method method, final Object[] args)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/dbutils/AsyncQueryRunnerTest.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils;\n\nimport static org.junit.Assert.fail;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.Mockito.doThrow;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.times;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\nimport java.sql.Connection;\nimport java.sql.ParameterMetaData;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\n\nimport javax.sql.DataSource;\n\nimport org.apache.commons.dbutils.handlers.ArrayHandler;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.Mock;\nimport org.mockito.junit.MockitoJUnitRunner;\n\n@SuppressWarnings(\"boxing\") // test code\n@RunWith(MockitoJUnitRunner.class)\npublic class AsyncQueryRunnerTest {\n    private AsyncQueryRunner runner;\n    private ArrayHandler handler;\n\n    @Mock\n    private DataSource dataSource;\n    @Mock\n    private Connection conn;\n    @Mock\n    private PreparedStatement prepStmt;\n    @Mock\n    private Statement stmt;\n    @Mock\n    private ParameterMetaData meta;\n    @Mock\n    private ResultSet results;\n\n    // helper method for calling batch when an exception is expected\n    private void callBatchWithException(final String sql, final Object[][] params) throws Exception {\n        Future<int[]> future = null;\n        boolean caught = false;\n\n        try {\n            future = runner.batch(sql, params);\n\n            future.get();\n\n            verify(prepStmt, times(2)).addBatch();\n            verify(prepStmt, times(1)).executeBatch();\n            verify(prepStmt, times(1)).close(); // make sure the statement is closed\n            verify(conn, times(1)).close(); // make sure the connection is closed\n        } catch (final Exception e) {\n            caught = true;\n        }\n\n        if (!caught) {\n            fail(\"Exception never thrown, but expected\");\n        }\n    }\n\n    //\n    // Batch test cases\n    //\n    private void callGoodBatch(final Connection conn, final Object[][] params) throws Exception {\n        when(meta.getParameterCount()).thenReturn(2);\n        final Future<int[]> future = runner.batch(conn, \"select * from blah where ? = ?\", params);\n\n        future.get();\n\n        verify(prepStmt, times(2)).addBatch();\n        verify(prepStmt, times(1)).executeBatch();\n        verify(prepStmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we closed the connection\n    }\n\n    private void callGoodBatch(final Object[][] params) throws Exception {\n        when(meta.getParameterCount()).thenReturn(2);\n        final Future<int[]> future = runner.batch(\"select * from blah where ? = ?\", params);\n\n        future.get();\n\n        verify(prepStmt, times(2)).addBatch();\n        verify(prepStmt, times(1)).executeBatch();\n        verify(prepStmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(1)).close();    // make sure we closed the connection\n    }\n\n    private void callGoodQuery() throws Exception {\n        when(meta.getParameterCount()).thenReturn(2);\n        String sql = \"select * from blah where ? = ?\";\n        runner.query(sql, handler, \"unit\", \"test\").get();\n\n        verify(prepStmt, times(1)).executeQuery();\n        verify(results, times(1)).close();\n        verify(prepStmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(1)).close();    // make sure we closed the connection\n\n        // call the other variation of query\n        sql = \"select * from blah\";\n        runner.query(sql, handler).get();\n\n        verify(stmt, times(1)).executeQuery(sql);\n        verify(results, times(2)).close();\n        verify(stmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(2)).close();    // make sure we closed the connection\n    }\n\n    //\n    // Query test cases\n    //\n    private void callGoodQuery(final Connection conn) throws Exception {\n        when(meta.getParameterCount()).thenReturn(2);\n        String sql = \"select * from blah where ? = ?\";\n        runner.query(conn, sql, handler, \"unit\", \"test\").get();\n\n        verify(prepStmt, times(1)).executeQuery();\n        verify(results, times(1)).close();\n        verify(prepStmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we closed the connection\n\n        // call the other variation of query\n        sql = \"select * from blah\";\n        runner.query(conn, sql, handler).get();\n\n        verify(stmt, times(1)).executeQuery(sql);\n        verify(results, times(2)).close();\n        verify(stmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we closed the connection\n    }\n\n    private void callGoodUpdate() throws Exception {\n        when(meta.getParameterCount()).thenReturn(2);\n        String sql = \"update blah set ? = ?\";\n        runner.update(sql, \"unit\", \"test\").get();\n\n        verify(prepStmt, times(1)).executeUpdate();\n        verify(prepStmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(1)).close();    // make sure we closed the connection\n\n        // call the other variation\n        when(meta.getParameterCount()).thenReturn(0);\n        sql = \"update blah set unit = test\";\n        runner.update(sql).get();\n\n        verify(stmt, times(1)).executeUpdate(sql);\n        verify(stmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(2)).close();    // make sure we closed the connection\n\n        // call the other variation\n        when(meta.getParameterCount()).thenReturn(1);\n        runner.update(\"update blah set unit = ?\", \"test\").get();\n\n        verify(prepStmt, times(2)).executeUpdate();\n        verify(prepStmt, times(2)).close();    // make sure we closed the statement\n        verify(conn, times(3)).close();    // make sure we closed the connection\n    }\n\n    //\n    // Update test cases\n    //\n    private void callGoodUpdate(final Connection conn) throws Exception {\n        when(meta.getParameterCount()).thenReturn(2);\n        String sql = \"update blah set ? = ?\";\n        runner.update(conn, sql, \"unit\", \"test\").get();\n\n        verify(prepStmt, times(1)).executeUpdate();\n        verify(prepStmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we closed the connection\n\n        // call the other variation\n        when(meta.getParameterCount()).thenReturn(0);\n        sql = \"update blah set unit = test\";\n        runner.update(conn, sql).get();\n\n        verify(stmt, times(1)).executeUpdate(sql);\n        verify(stmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we closed the connection\n\n        // call the other variation\n        when(meta.getParameterCount()).thenReturn(1);\n        sql = \"update blah set unit = ?\";\n        runner.update(conn, sql, \"test\").get();\n\n        verify(prepStmt, times(2)).executeUpdate();\n        verify(prepStmt, times(2)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we closed the connection\n    }\n\n    // helper method for calling batch when an exception is expected\n    private void callQueryWithException(final Object... params) throws Exception {\n        boolean caught = false;\n\n        try {\n            when(meta.getParameterCount()).thenReturn(2);\n            runner.query(\"select * from blah where ? = ?\", handler, params).get();\n\n            verify(prepStmt, times(1)).executeQuery();\n            verify(results, times(1)).close();\n            verify(prepStmt, times(1)).close(); // make sure we closed the statement\n            verify(conn, times(1)).close(); // make sure we closed the connection\n        } catch (final Exception e) {\n            caught = true;\n        }\n\n        if (!caught) {\n            fail(\"Exception never thrown, but expected\");\n        }\n    }\n\n    // helper method for calling batch when an exception is expected\n    private void callUpdateWithException(final Object... params) throws Exception {\n        boolean caught = false;\n\n        try {\n            when(meta.getParameterCount()).thenReturn(2);\n            runner.update(\"select * from blah where ? = ?\", params).get();\n\n            verify(prepStmt, times(1)).executeUpdate();\n            verify(prepStmt, times(1)).close(); // make sure we closed the statement\n            verify(conn, times(1)).close(); // make sure we closed the connection\n        } catch (final Exception e) {\n            caught = true;\n        }\n\n        if (!caught) {\n            fail(\"Exception never thrown, but expected\");\n        }\n    }\n\n    @Before\n    public void setUp() throws Exception {\n        when(dataSource.getConnection()).thenReturn(conn);\n\n        when(conn.prepareStatement(any(String.class))).thenReturn(prepStmt);\n        when(prepStmt.getParameterMetaData()).thenReturn(meta);\n        when(prepStmt.executeQuery()).thenReturn(results);\n\n        when(conn.createStatement()).thenReturn(stmt);\n        when(stmt.executeQuery(any(String.class))).thenReturn(results);\n\n        when(results.next()).thenReturn(false);\n\n         handler = new ArrayHandler();\n         runner = new AsyncQueryRunner(Executors.newFixedThreadPool(1), new QueryRunner(dataSource));\n    }\n\n    @Test\n    public void testAddBatchException() throws Exception {\n        final String[][] params = { { \"unit\", \"unit\" }, { \"test\", \"test\" } };\n\n        callBatchWithException(\"select * from blah where ? = ?\", params);\n    }\n\n    //\n    // Random tests\n    //\n    @Test(expected = ExecutionException.class)\n    public void testBadPrepareConnection() throws Exception {\n        runner = new AsyncQueryRunner(Executors.newFixedThreadPool(1));\n        runner.update(\"update blah set unit = test\").get();\n    }\n\n    @Test\n    public void testExecuteBatchException() throws Exception {\n        final String[][] params = { { \"unit\", \"unit\" }, { \"test\", \"test\" } };\n\n        callBatchWithException(\"select * from blah where ? = ?\", params);\n    }\n\n    @Test\n    public void testExecuteQueryException() throws Exception {\n        callQueryWithException(handler, \"unit\", \"test\");\n    }\n\n    @Test\n    public void testExecuteUpdateException() throws Exception {\n        doThrow(new SQLException()).when(prepStmt).executeUpdate();\n\n        callUpdateWithException(\"unit\", \"test\");\n    }\n\n    @Test\n    public void testGoodBatch() throws Exception {\n        final String[][] params = { { \"unit\", \"unit\" }, { \"test\", \"test\" } };\n\n        callGoodBatch(params);\n    }\n\n    @Test\n    public void testGoodBatchDefaultConstructor() throws Exception {\n        runner = new AsyncQueryRunner(Executors.newFixedThreadPool(1));\n        final String[][] params = { { \"unit\", \"unit\" }, { \"test\", \"test\" } };\n\n        callGoodBatch(conn, params);\n    }\n\n    @SuppressWarnings(\"deprecation\") // deliberate test of deprecated code\n    @Test\n    public void testGoodBatchPmdTrue() throws Exception {\n        runner = new AsyncQueryRunner(dataSource, true, Executors.newFixedThreadPool(1));\n        final String[][] params = { { \"unit\", \"unit\" }, { \"test\", \"test\" } };\n\n        callGoodBatch(params);\n    }\n\n    @Test\n    public void testGoodQuery() throws Exception {\n        callGoodQuery();\n    }\n\n    @Test\n    public void testGoodQueryDefaultConstructor() throws Exception {\n        runner = new AsyncQueryRunner(Executors.newFixedThreadPool(1));\n        callGoodQuery(conn);\n    }\n\n    @SuppressWarnings(\"deprecation\") // deliberate test of deprecated code\n    @Test\n    public void testGoodQueryPmdTrue() throws Exception {\n        runner = new AsyncQueryRunner(true, Executors.newFixedThreadPool(1));\n        callGoodQuery(conn);\n    }\n\n    @Test\n    public void testGoodUpdate() throws Exception {\n        callGoodUpdate();\n    }\n\n    @Test\n    public void testGoodUpdateDefaultConstructor() throws Exception {\n        runner = new AsyncQueryRunner(Executors.newFixedThreadPool(1));\n        callGoodUpdate(conn);\n    }\n\n    @SuppressWarnings(\"deprecation\") // deliberate test of deprecated code\n    @Test\n    public void testGoodUpdatePmdTrue() throws Exception {\n        runner = new AsyncQueryRunner(true, Executors.newFixedThreadPool(1));\n        callGoodUpdate(conn);\n    }\n\n    @Test\n    public void testInsertUsesGivenQueryRunner() throws Exception {\n        final QueryRunner mockQueryRunner = mock(QueryRunner.class, org.mockito.Mockito.withSettings().verboseLogging() // debug for Continuum\n        );\n        runner = new AsyncQueryRunner(Executors.newSingleThreadExecutor(), mockQueryRunner);\n\n        runner.insert(\"1\", handler);\n        runner.insert(\"2\", handler, \"param1\");\n        runner.insert(conn, \"3\", handler);\n        runner.insert(conn, \"4\", handler, \"param1\");\n\n        // give the Executor time to submit all insert statements. Otherwise the following verify statements will fail from time to time.\n        TimeUnit.MILLISECONDS.sleep(50);\n\n        verify(mockQueryRunner).insert(\"1\", handler);\n        verify(mockQueryRunner).insert(\"2\", handler, \"param1\");\n        verify(mockQueryRunner).insert(conn, \"3\", handler);\n        verify(mockQueryRunner).insert(conn, \"4\", handler, \"param1\");\n    }\n\n    @Test\n    public void testNoParamsQuery() throws Exception {\n        callGoodQuery();\n    }\n\n    @Test\n    public void testNoParamsUpdate() throws Exception {\n        callGoodUpdate();\n    }\n\n    @Test(expected = ExecutionException.class)\n    public void testNullConnectionBatch() throws Exception {\n        final String[][] params = { { \"unit\", \"unit\" }, { \"test\", \"test\" } };\n\n        when(dataSource.getConnection()).thenReturn(null);\n\n        runner.batch(\"select * from blah where ? = ?\", params).get();\n    }\n\n    @Test(expected = ExecutionException.class)\n    public void testNullConnectionQuery() throws Exception {\n        when(dataSource.getConnection()).thenReturn(null);\n\n        runner.query(\"select * from blah where ? = ?\", handler, \"unit\", \"test\").get();\n    }\n\n    @Test(expected = ExecutionException.class)\n    public void testNullConnectionUpdate() throws Exception {\n        when(dataSource.getConnection()).thenReturn(null);\n\n        runner.update(\"select * from blah where ? = ?\", \"unit\", \"test\").get();\n    }\n\n    @Test(expected = ExecutionException.class)\n    public void testNullHandlerQuery() throws Exception {\n        runner.query(\"select * from blah where ? = ?\", null).get();\n    }\n\n    @Test(expected = ExecutionException.class)\n    public void testNullParamsArgBatch() throws Exception {\n        runner.batch(\"select * from blah where ? = ?\", null).get();\n    }\n\n    @Test\n    public void testNullParamsBatch() throws Exception {\n        final String[][] params = { { null, \"unit\" }, { \"test\", null } };\n\n        callGoodBatch(params);\n    }\n\n    @Test(expected = ExecutionException.class)\n    public void testNullSqlBatch() throws Exception {\n        final String[][] params = { { \"unit\", \"unit\" }, { \"test\", \"test\" } };\n\n        runner.batch(null, params).get();\n    }\n\n    @Test(expected = ExecutionException.class)\n    public void testNullSqlQuery() throws Exception {\n        runner.query(null, handler).get();\n    }\n\n    @Test(expected = ExecutionException.class)\n    public void testNullSqlUpdate() throws Exception {\n        runner.update(null).get();\n    }\n\n    @Test\n    public void testTooFewParamsBatch() throws Exception {\n        final String[][] params = { { \"unit\" }, { \"test\" } };\n\n        callBatchWithException(\"select * from blah where ? = ?\", params);\n    }\n\n    @Test\n    public void testTooFewParamsQuery() throws Exception {\n        callQueryWithException(\"unit\");\n    }\n\n    @Test\n    public void testTooFewParamsUpdate() throws Exception {\n        callUpdateWithException(\"unit\");\n    }\n\n    @Test\n    public void testTooManyParamsBatch() throws Exception {\n        final String[][] params = { { \"unit\", \"unit\", \"unit\" }, { \"test\", \"test\", \"test\" } };\n\n        callBatchWithException(\"select * from blah where ? = ?\", params);\n    }\n\n    @Test\n    public void testTooManyParamsQuery() throws Exception {\n        callQueryWithException(\"unit\", \"test\", \"fail\");\n    }\n\n    @Test\n    public void testTooManyParamsUpdate() throws Exception {\n        callUpdateWithException(\"unit\", \"test\", \"fail\");\n    }\n}\n", "file_hash": "7674fbb1848e4bb0a33d36b66d6a0f62e48b070dcafb0c823d7752ef3eff91e4", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils;", "import static org.junit.Assert.fail;", "import static org.mockito.ArgumentMatchers.any;", "import static org.mockito.Mockito.doThrow;", "import static org.mockito.Mockito.mock;", "import static org.mockito.Mockito.times;", "import static org.mockito.Mockito.verify;", "import static org.mockito.Mockito.when;", "import java.sql.Connection;", "import java.sql.ParameterMetaData;", "import java.sql.PreparedStatement;", "import java.sql.ResultSet;", "import java.sql.SQLException;", "import java.sql.Statement;", "import java.util.concurrent.ExecutionException;", "import java.util.concurrent.Executors;", "import java.util.concurrent.Future;", "import java.util.concurrent.TimeUnit;", "import javax.sql.DataSource;", "import org.apache.commons.dbutils.handlers.ArrayHandler;", "import org.junit.Before;", "import org.junit.Test;", "import org.junit.runner.RunWith;", "import org.mockito.Mock;", "import org.mockito.junit.MockitoJUnitRunner;"], "methods": [], "classes": [{"original_string": "@SuppressWarnings(\"boxing\") // test code\n@RunWith(MockitoJUnitRunner.class)\npublic class AsyncQueryRunnerTest {\n    private AsyncQueryRunner runner;\n    private ArrayHandler handler;\n\n    @Mock\n    private DataSource dataSource;\n    @Mock\n    private Connection conn;\n    @Mock\n    private PreparedStatement prepStmt;\n    @Mock\n    private Statement stmt;\n    @Mock\n    private ParameterMetaData meta;\n    @Mock\n    private ResultSet results;\n\n    // helper method for calling batch when an exception is expected\n    private void callBatchWithException(final String sql, final Object[][] params) throws Exception {\n        Future<int[]> future = null;\n        boolean caught = false;\n\n        try {\n            future = runner.batch(sql, params);\n\n            future.get();\n\n            verify(prepStmt, times(2)).addBatch();\n            verify(prepStmt, times(1)).executeBatch();\n            verify(prepStmt, times(1)).close(); // make sure the statement is closed\n            verify(conn, times(1)).close(); // make sure the connection is closed\n        } catch (final Exception e) {\n            caught = true;\n        }\n\n        if (!caught) {\n            fail(\"Exception never thrown, but expected\");\n        }\n    }\n\n    //\n    // Batch test cases\n    //\n    private void callGoodBatch(final Connection conn, final Object[][] params) throws Exception {\n        when(meta.getParameterCount()).thenReturn(2);\n        final Future<int[]> future = runner.batch(conn, \"select * from blah where ? = ?\", params);\n\n        future.get();\n\n        verify(prepStmt, times(2)).addBatch();\n        verify(prepStmt, times(1)).executeBatch();\n        verify(prepStmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we closed the connection\n    }\n\n    private void callGoodBatch(final Object[][] params) throws Exception {\n        when(meta.getParameterCount()).thenReturn(2);\n        final Future<int[]> future = runner.batch(\"select * from blah where ? = ?\", params);\n\n        future.get();\n\n        verify(prepStmt, times(2)).addBatch();\n        verify(prepStmt, times(1)).executeBatch();\n        verify(prepStmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(1)).close();    // make sure we closed the connection\n    }\n\n    private void callGoodQuery() throws Exception {\n        when(meta.getParameterCount()).thenReturn(2);\n        String sql = \"select * from blah where ? = ?\";\n        runner.query(sql, handler, \"unit\", \"test\").get();\n\n        verify(prepStmt, times(1)).executeQuery();\n        verify(results, times(1)).close();\n        verify(prepStmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(1)).close();    // make sure we closed the connection\n\n        // call the other variation of query\n        sql = \"select * from blah\";\n        runner.query(sql, handler).get();\n\n        verify(stmt, times(1)).executeQuery(sql);\n        verify(results, times(2)).close();\n        verify(stmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(2)).close();    // make sure we closed the connection\n    }\n\n    //\n    // Query test cases\n    //\n    private void callGoodQuery(final Connection conn) throws Exception {\n        when(meta.getParameterCount()).thenReturn(2);\n        String sql = \"select * from blah where ? = ?\";\n        runner.query(conn, sql, handler, \"unit\", \"test\").get();\n\n        verify(prepStmt, times(1)).executeQuery();\n        verify(results, times(1)).close();\n        verify(prepStmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we closed the connection\n\n        // call the other variation of query\n        sql = \"select * from blah\";\n        runner.query(conn, sql, handler).get();\n\n        verify(stmt, times(1)).executeQuery(sql);\n        verify(results, times(2)).close();\n        verify(stmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we closed the connection\n    }\n\n    private void callGoodUpdate() throws Exception {\n        when(meta.getParameterCount()).thenReturn(2);\n        String sql = \"update blah set ? = ?\";\n        runner.update(sql, \"unit\", \"test\").get();\n\n        verify(prepStmt, times(1)).executeUpdate();\n        verify(prepStmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(1)).close();    // make sure we closed the connection\n\n        // call the other variation\n        when(meta.getParameterCount()).thenReturn(0);\n        sql = \"update blah set unit = test\";\n        runner.update(sql).get();\n\n        verify(stmt, times(1)).executeUpdate(sql);\n        verify(stmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(2)).close();    // make sure we closed the connection\n\n        // call the other variation\n        when(meta.getParameterCount()).thenReturn(1);\n        runner.update(\"update blah set unit = ?\", \"test\").get();\n\n        verify(prepStmt, times(2)).executeUpdate();\n        verify(prepStmt, times(2)).close();    // make sure we closed the statement\n        verify(conn, times(3)).close();    // make sure we closed the connection\n    }\n\n    //\n    // Update test cases\n    //\n    private void callGoodUpdate(final Connection conn) throws Exception {\n        when(meta.getParameterCount()).thenReturn(2);\n        String sql = \"update blah set ? = ?\";\n        runner.update(conn, sql, \"unit\", \"test\").get();\n\n        verify(prepStmt, times(1)).executeUpdate();\n        verify(prepStmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we closed the connection\n\n        // call the other variation\n        when(meta.getParameterCount()).thenReturn(0);\n        sql = \"update blah set unit = test\";\n        runner.update(conn, sql).get();\n\n        verify(stmt, times(1)).executeUpdate(sql);\n        verify(stmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we closed the connection\n\n        // call the other variation\n        when(meta.getParameterCount()).thenReturn(1);\n        sql = \"update blah set unit = ?\";\n        runner.update(conn, sql, \"test\").get();\n\n        verify(prepStmt, times(2)).executeUpdate();\n        verify(prepStmt, times(2)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we closed the connection\n    }\n\n    // helper method for calling batch when an exception is expected\n    private void callQueryWithException(final Object... params) throws Exception {\n        boolean caught = false;\n\n        try {\n            when(meta.getParameterCount()).thenReturn(2);\n            runner.query(\"select * from blah where ? = ?\", handler, params).get();\n\n            verify(prepStmt, times(1)).executeQuery();\n            verify(results, times(1)).close();\n            verify(prepStmt, times(1)).close(); // make sure we closed the statement\n            verify(conn, times(1)).close(); // make sure we closed the connection\n        } catch (final Exception e) {\n            caught = true;\n        }\n\n        if (!caught) {\n            fail(\"Exception never thrown, but expected\");\n        }\n    }\n\n    // helper method for calling batch when an exception is expected\n    private void callUpdateWithException(final Object... params) throws Exception {\n        boolean caught = false;\n\n        try {\n            when(meta.getParameterCount()).thenReturn(2);\n            runner.update(\"select * from blah where ? = ?\", params).get();\n\n            verify(prepStmt, times(1)).executeUpdate();\n            verify(prepStmt, times(1)).close(); // make sure we closed the statement\n            verify(conn, times(1)).close(); // make sure we closed the connection\n        } catch (final Exception e) {\n            caught = true;\n        }\n\n        if (!caught) {\n            fail(\"Exception never thrown, but expected\");\n        }\n    }\n\n    @Before\n    public void setUp() throws Exception {\n        when(dataSource.getConnection()).thenReturn(conn);\n\n        when(conn.prepareStatement(any(String.class))).thenReturn(prepStmt);\n        when(prepStmt.getParameterMetaData()).thenReturn(meta);\n        when(prepStmt.executeQuery()).thenReturn(results);\n\n        when(conn.createStatement()).thenReturn(stmt);\n        when(stmt.executeQuery(any(String.class))).thenReturn(results);\n\n        when(results.next()).thenReturn(false);\n\n         handler = new ArrayHandler();\n         runner = new AsyncQueryRunner(Executors.newFixedThreadPool(1), new QueryRunner(dataSource));\n    }\n\n    @Test\n    public void testAddBatchException() throws Exception {\n        final String[][] params = { { \"unit\", \"unit\" }, { \"test\", \"test\" } };\n\n        callBatchWithException(\"select * from blah where ? = ?\", params);\n    }\n\n    //\n    // Random tests\n    //\n    @Test(expected = ExecutionException.class)\n    public void testBadPrepareConnection() throws Exception {\n        runner = new AsyncQueryRunner(Executors.newFixedThreadPool(1));\n        runner.update(\"update blah set unit = test\").get();\n    }\n\n    @Test\n    public void testExecuteBatchException() throws Exception {\n        final String[][] params = { { \"unit\", \"unit\" }, { \"test\", \"test\" } };\n\n        callBatchWithException(\"select * from blah where ? = ?\", params);\n    }\n\n    @Test\n    public void testExecuteQueryException() throws Exception {\n        callQueryWithException(handler, \"unit\", \"test\");\n    }\n\n    @Test\n    public void testExecuteUpdateException() throws Exception {\n        doThrow(new SQLException()).when(prepStmt).executeUpdate();\n\n        callUpdateWithException(\"unit\", \"test\");\n    }\n\n    @Test\n    public void testGoodBatch() throws Exception {\n        final String[][] params = { { \"unit\", \"unit\" }, { \"test\", \"test\" } };\n\n        callGoodBatch(params);\n    }\n\n    @Test\n    public void testGoodBatchDefaultConstructor() throws Exception {\n        runner = new AsyncQueryRunner(Executors.newFixedThreadPool(1));\n        final String[][] params = { { \"unit\", \"unit\" }, { \"test\", \"test\" } };\n\n        callGoodBatch(conn, params);\n    }\n\n    @SuppressWarnings(\"deprecation\") // deliberate test of deprecated code\n    @Test\n    public void testGoodBatchPmdTrue() throws Exception {\n        runner = new AsyncQueryRunner(dataSource, true, Executors.newFixedThreadPool(1));\n        final String[][] params = { { \"unit\", \"unit\" }, { \"test\", \"test\" } };\n\n        callGoodBatch(params);\n    }\n\n    @Test\n    public void testGoodQuery() throws Exception {\n        callGoodQuery();\n    }\n\n    @Test\n    public void testGoodQueryDefaultConstructor() throws Exception {\n        runner = new AsyncQueryRunner(Executors.newFixedThreadPool(1));\n        callGoodQuery(conn);\n    }\n\n    @SuppressWarnings(\"deprecation\") // deliberate test of deprecated code\n    @Test\n    public void testGoodQueryPmdTrue() throws Exception {\n        runner = new AsyncQueryRunner(true, Executors.newFixedThreadPool(1));\n        callGoodQuery(conn);\n    }\n\n    @Test\n    public void testGoodUpdate() throws Exception {\n        callGoodUpdate();\n    }\n\n    @Test\n    public void testGoodUpdateDefaultConstructor() throws Exception {\n        runner = new AsyncQueryRunner(Executors.newFixedThreadPool(1));\n        callGoodUpdate(conn);\n    }\n\n    @SuppressWarnings(\"deprecation\") // deliberate test of deprecated code\n    @Test\n    public void testGoodUpdatePmdTrue() throws Exception {\n        runner = new AsyncQueryRunner(true, Executors.newFixedThreadPool(1));\n        callGoodUpdate(conn);\n    }\n\n    @Test\n    public void testInsertUsesGivenQueryRunner() throws Exception {\n        final QueryRunner mockQueryRunner = mock(QueryRunner.class, org.mockito.Mockito.withSettings().verboseLogging() // debug for Continuum\n        );\n        runner = new AsyncQueryRunner(Executors.newSingleThreadExecutor(), mockQueryRunner);\n\n        runner.insert(\"1\", handler);\n        runner.insert(\"2\", handler, \"param1\");\n        runner.insert(conn, \"3\", handler);\n        runner.insert(conn, \"4\", handler, \"param1\");\n\n        // give the Executor time to submit all insert statements. Otherwise the following verify statements will fail from time to time.\n        TimeUnit.MILLISECONDS.sleep(50);\n\n        verify(mockQueryRunner).insert(\"1\", handler);\n        verify(mockQueryRunner).insert(\"2\", handler, \"param1\");\n        verify(mockQueryRunner).insert(conn, \"3\", handler);\n        verify(mockQueryRunner).insert(conn, \"4\", handler, \"param1\");\n    }\n\n    @Test\n    public void testNoParamsQuery() throws Exception {\n        callGoodQuery();\n    }\n\n    @Test\n    public void testNoParamsUpdate() throws Exception {\n        callGoodUpdate();\n    }\n\n    @Test(expected = ExecutionException.class)\n    public void testNullConnectionBatch() throws Exception {\n        final String[][] params = { { \"unit\", \"unit\" }, { \"test\", \"test\" } };\n\n        when(dataSource.getConnection()).thenReturn(null);\n\n        runner.batch(\"select * from blah where ? = ?\", params).get();\n    }\n\n    @Test(expected = ExecutionException.class)\n    public void testNullConnectionQuery() throws Exception {\n        when(dataSource.getConnection()).thenReturn(null);\n\n        runner.query(\"select * from blah where ? = ?\", handler, \"unit\", \"test\").get();\n    }\n\n    @Test(expected = ExecutionException.class)\n    public void testNullConnectionUpdate() throws Exception {\n        when(dataSource.getConnection()).thenReturn(null);\n\n        runner.update(\"select * from blah where ? = ?\", \"unit\", \"test\").get();\n    }\n\n    @Test(expected = ExecutionException.class)\n    public void testNullHandlerQuery() throws Exception {\n        runner.query(\"select * from blah where ? = ?\", null).get();\n    }\n\n    @Test(expected = ExecutionException.class)\n    public void testNullParamsArgBatch() throws Exception {\n        runner.batch(\"select * from blah where ? = ?\", null).get();\n    }\n\n    @Test\n    public void testNullParamsBatch() throws Exception {\n        final String[][] params = { { null, \"unit\" }, { \"test\", null } };\n\n        callGoodBatch(params);\n    }\n\n    @Test(expected = ExecutionException.class)\n    public void testNullSqlBatch() throws Exception {\n        final String[][] params = { { \"unit\", \"unit\" }, { \"test\", \"test\" } };\n\n        runner.batch(null, params).get();\n    }\n\n    @Test(expected = ExecutionException.class)\n    public void testNullSqlQuery() throws Exception {\n        runner.query(null, handler).get();\n    }\n\n    @Test(expected = ExecutionException.class)\n    public void testNullSqlUpdate() throws Exception {\n        runner.update(null).get();\n    }\n\n    @Test\n    public void testTooFewParamsBatch() throws Exception {\n        final String[][] params = { { \"unit\" }, { \"test\" } };\n\n        callBatchWithException(\"select * from blah where ? = ?\", params);\n    }\n\n    @Test\n    public void testTooFewParamsQuery() throws Exception {\n        callQueryWithException(\"unit\");\n    }\n\n    @Test\n    public void testTooFewParamsUpdate() throws Exception {\n        callUpdateWithException(\"unit\");\n    }\n\n    @Test\n    public void testTooManyParamsBatch() throws Exception {\n        final String[][] params = { { \"unit\", \"unit\", \"unit\" }, { \"test\", \"test\", \"test\" } };\n\n        callBatchWithException(\"select * from blah where ? = ?\", params);\n    }\n\n    @Test\n    public void testTooManyParamsQuery() throws Exception {\n        callQueryWithException(\"unit\", \"test\", \"fail\");\n    }\n\n    @Test\n    public void testTooManyParamsUpdate() throws Exception {\n        callUpdateWithException(\"unit\", \"test\", \"fail\");\n    }\n}", "definition": "@SuppressWarnings(\"boxing\") // test code\n@RunWith(MockitoJUnitRunner.class)\npublic class AsyncQueryRunnerTest", "class_docstring": "", "name": "AsyncQueryRunnerTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "@SuppressWarnings(\"boxing\") // test code\n@RunWith(MockitoJUnitRunner.class)\npublic", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"boxing\")", "@RunWith(MockitoJUnitRunner.class)", "public"], "comments": ["// test code"], "fields": [{"attribute_expression": "private AsyncQueryRunner runner;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "AsyncQueryRunner", "name": "runner", "syntax_pass": true}, {"attribute_expression": "private ArrayHandler handler;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ArrayHandler", "name": "handler", "syntax_pass": true}, {"attribute_expression": "@Mock\n    private DataSource dataSource;", "docstring": "", "modifiers": "@Mock\n    private", "marker_annotations": ["@Mock"], "non_marker_annotations": ["private"], "comments": [], "type": "DataSource", "name": "dataSource", "syntax_pass": true}, {"attribute_expression": "@Mock\n    private Connection conn;", "docstring": "", "modifiers": "@Mock\n    private", "marker_annotations": ["@Mock"], "non_marker_annotations": ["private"], "comments": [], "type": "Connection", "name": "conn", "syntax_pass": true}, {"attribute_expression": "@Mock\n    private PreparedStatement prepStmt;", "docstring": "", "modifiers": "@Mock\n    private", "marker_annotations": ["@Mock"], "non_marker_annotations": ["private"], "comments": [], "type": "PreparedStatement", "name": "prepStmt", "syntax_pass": true}, {"attribute_expression": "@Mock\n    private Statement stmt;", "docstring": "", "modifiers": "@Mock\n    private", "marker_annotations": ["@Mock"], "non_marker_annotations": ["private"], "comments": [], "type": "Statement", "name": "stmt", "syntax_pass": true}, {"attribute_expression": "@Mock\n    private ParameterMetaData meta;", "docstring": "", "modifiers": "@Mock\n    private", "marker_annotations": ["@Mock"], "non_marker_annotations": ["private"], "comments": [], "type": "ParameterMetaData", "name": "meta", "syntax_pass": true}, {"attribute_expression": "@Mock\n    private ResultSet results;", "docstring": "", "modifiers": "@Mock\n    private", "marker_annotations": ["@Mock"], "non_marker_annotations": ["private"], "comments": [], "type": "ResultSet", "name": "results", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    private void callBatchWithException(final String sql, final Object[][] params) throws Exception {\n        Future<int[]> future = null;\n        boolean caught = false;\n\n        try {\n            future = runner.batch(sql, params);\n\n            future.get();\n\n            verify(prepStmt, times(2)).addBatch();\n            verify(prepStmt, times(1)).executeBatch();\n            verify(prepStmt, times(1)).close(); // make sure the statement is closed\n            verify(conn, times(1)).close(); // make sure the connection is closed\n        } catch (final Exception e) {\n            caught = true;\n        }\n\n        if (!caught) {\n            fail(\"Exception never thrown, but expected\");\n        }\n    }", "docstring": " helper method for calling batch when an exception is expected", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "callBatchWithException", "params": [{"name": "sql", "type": "String"}, {"name": "params", "type": "Object[][]"}], "body": "                                                                                                    {\n        Future<int[]> future = null;\n        boolean caught = false;\n\n        try {\n            future = runner.batch(sql, params);\n\n            future.get();\n\n            verify(prepStmt, times(2)).addBatch();\n            verify(prepStmt, times(1)).executeBatch();\n            verify(prepStmt, times(1)).close(); // make sure the statement is closed\n            verify(conn, times(1)).close(); // make sure the connection is closed\n        } catch (final Exception e) {\n            caught = true;\n        }\n\n        if (!caught) {\n            fail(\"Exception never thrown, but expected\");\n        }\n    }", "signature": "private void callBatchWithException(final String sql, final Object[][] params)"}, {"syntax_pass": true, "original_string": "    private void callGoodBatch(final Connection conn, final Object[][] params) throws Exception {\n        when(meta.getParameterCount()).thenReturn(2);\n        final Future<int[]> future = runner.batch(conn, \"select * from blah where ? = ?\", params);\n\n        future.get();\n\n        verify(prepStmt, times(2)).addBatch();\n        verify(prepStmt, times(1)).executeBatch();\n        verify(prepStmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we closed the connection\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "callGoodBatch", "params": [{"name": "conn", "type": "Connection"}, {"name": "params", "type": "Object[][]"}], "body": "                                                                                                {\n        when(meta.getParameterCount()).thenReturn(2);\n        final Future<int[]> future = runner.batch(conn, \"select * from blah where ? = ?\", params);\n\n        future.get();\n\n        verify(prepStmt, times(2)).addBatch();\n        verify(prepStmt, times(1)).executeBatch();\n        verify(prepStmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we closed the connection\n    }", "signature": "private void callGoodBatch(final Connection conn, final Object[][] params)"}, {"syntax_pass": true, "original_string": "    private void callGoodBatch(final Object[][] params) throws Exception {\n        when(meta.getParameterCount()).thenReturn(2);\n        final Future<int[]> future = runner.batch(\"select * from blah where ? = ?\", params);\n\n        future.get();\n\n        verify(prepStmt, times(2)).addBatch();\n        verify(prepStmt, times(1)).executeBatch();\n        verify(prepStmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(1)).close();    // make sure we closed the connection\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "callGoodBatch", "params": [{"name": "params", "type": "Object[][]"}], "body": "                                                                         {\n        when(meta.getParameterCount()).thenReturn(2);\n        final Future<int[]> future = runner.batch(\"select * from blah where ? = ?\", params);\n\n        future.get();\n\n        verify(prepStmt, times(2)).addBatch();\n        verify(prepStmt, times(1)).executeBatch();\n        verify(prepStmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(1)).close();    // make sure we closed the connection\n    }", "signature": "private void callGoodBatch(final Object[][] params)"}, {"syntax_pass": true, "original_string": "    private void callGoodQuery() throws Exception {\n        when(meta.getParameterCount()).thenReturn(2);\n        String sql = \"select * from blah where ? = ?\";\n        runner.query(sql, handler, \"unit\", \"test\").get();\n\n        verify(prepStmt, times(1)).executeQuery();\n        verify(results, times(1)).close();\n        verify(prepStmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(1)).close();    // make sure we closed the connection\n\n        // call the other variation of query\n        sql = \"select * from blah\";\n        runner.query(sql, handler).get();\n\n        verify(stmt, times(1)).executeQuery(sql);\n        verify(results, times(2)).close();\n        verify(stmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(2)).close();    // make sure we closed the connection\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "callGoodQuery", "params": [], "body": "                                                  {\n        when(meta.getParameterCount()).thenReturn(2);\n        String sql = \"select * from blah where ? = ?\";\n        runner.query(sql, handler, \"unit\", \"test\").get();\n\n        verify(prepStmt, times(1)).executeQuery();\n        verify(results, times(1)).close();\n        verify(prepStmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(1)).close();    // make sure we closed the connection\n\n        // call the other variation of query\n        sql = \"select * from blah\";\n        runner.query(sql, handler).get();\n\n        verify(stmt, times(1)).executeQuery(sql);\n        verify(results, times(2)).close();\n        verify(stmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(2)).close();    // make sure we closed the connection\n    }", "signature": "private void callGoodQuery()"}, {"syntax_pass": true, "original_string": "    private void callGoodQuery(final Connection conn) throws Exception {\n        when(meta.getParameterCount()).thenReturn(2);\n        String sql = \"select * from blah where ? = ?\";\n        runner.query(conn, sql, handler, \"unit\", \"test\").get();\n\n        verify(prepStmt, times(1)).executeQuery();\n        verify(results, times(1)).close();\n        verify(prepStmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we closed the connection\n\n        // call the other variation of query\n        sql = \"select * from blah\";\n        runner.query(conn, sql, handler).get();\n\n        verify(stmt, times(1)).executeQuery(sql);\n        verify(results, times(2)).close();\n        verify(stmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we closed the connection\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "callGoodQuery", "params": [{"name": "conn", "type": "Connection"}], "body": "                                                                       {\n        when(meta.getParameterCount()).thenReturn(2);\n        String sql = \"select * from blah where ? = ?\";\n        runner.query(conn, sql, handler, \"unit\", \"test\").get();\n\n        verify(prepStmt, times(1)).executeQuery();\n        verify(results, times(1)).close();\n        verify(prepStmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we closed the connection\n\n        // call the other variation of query\n        sql = \"select * from blah\";\n        runner.query(conn, sql, handler).get();\n\n        verify(stmt, times(1)).executeQuery(sql);\n        verify(results, times(2)).close();\n        verify(stmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we closed the connection\n    }", "signature": "private void callGoodQuery(final Connection conn)"}, {"syntax_pass": true, "original_string": "    private void callGoodUpdate() throws Exception {\n        when(meta.getParameterCount()).thenReturn(2);\n        String sql = \"update blah set ? = ?\";\n        runner.update(sql, \"unit\", \"test\").get();\n\n        verify(prepStmt, times(1)).executeUpdate();\n        verify(prepStmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(1)).close();    // make sure we closed the connection\n\n        // call the other variation\n        when(meta.getParameterCount()).thenReturn(0);\n        sql = \"update blah set unit = test\";\n        runner.update(sql).get();\n\n        verify(stmt, times(1)).executeUpdate(sql);\n        verify(stmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(2)).close();    // make sure we closed the connection\n\n        // call the other variation\n        when(meta.getParameterCount()).thenReturn(1);\n        runner.update(\"update blah set unit = ?\", \"test\").get();\n\n        verify(prepStmt, times(2)).executeUpdate();\n        verify(prepStmt, times(2)).close();    // make sure we closed the statement\n        verify(conn, times(3)).close();    // make sure we closed the connection\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "callGoodUpdate", "params": [], "body": "                                                   {\n        when(meta.getParameterCount()).thenReturn(2);\n        String sql = \"update blah set ? = ?\";\n        runner.update(sql, \"unit\", \"test\").get();\n\n        verify(prepStmt, times(1)).executeUpdate();\n        verify(prepStmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(1)).close();    // make sure we closed the connection\n\n        // call the other variation\n        when(meta.getParameterCount()).thenReturn(0);\n        sql = \"update blah set unit = test\";\n        runner.update(sql).get();\n\n        verify(stmt, times(1)).executeUpdate(sql);\n        verify(stmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(2)).close();    // make sure we closed the connection\n\n        // call the other variation\n        when(meta.getParameterCount()).thenReturn(1);\n        runner.update(\"update blah set unit = ?\", \"test\").get();\n\n        verify(prepStmt, times(2)).executeUpdate();\n        verify(prepStmt, times(2)).close();    // make sure we closed the statement\n        verify(conn, times(3)).close();    // make sure we closed the connection\n    }", "signature": "private void callGoodUpdate()"}, {"syntax_pass": true, "original_string": "    private void callGoodUpdate(final Connection conn) throws Exception {\n        when(meta.getParameterCount()).thenReturn(2);\n        String sql = \"update blah set ? = ?\";\n        runner.update(conn, sql, \"unit\", \"test\").get();\n\n        verify(prepStmt, times(1)).executeUpdate();\n        verify(prepStmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we closed the connection\n\n        // call the other variation\n        when(meta.getParameterCount()).thenReturn(0);\n        sql = \"update blah set unit = test\";\n        runner.update(conn, sql).get();\n\n        verify(stmt, times(1)).executeUpdate(sql);\n        verify(stmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we closed the connection\n\n        // call the other variation\n        when(meta.getParameterCount()).thenReturn(1);\n        sql = \"update blah set unit = ?\";\n        runner.update(conn, sql, \"test\").get();\n\n        verify(prepStmt, times(2)).executeUpdate();\n        verify(prepStmt, times(2)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we closed the connection\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "callGoodUpdate", "params": [{"name": "conn", "type": "Connection"}], "body": "                                                                        {\n        when(meta.getParameterCount()).thenReturn(2);\n        String sql = \"update blah set ? = ?\";\n        runner.update(conn, sql, \"unit\", \"test\").get();\n\n        verify(prepStmt, times(1)).executeUpdate();\n        verify(prepStmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we closed the connection\n\n        // call the other variation\n        when(meta.getParameterCount()).thenReturn(0);\n        sql = \"update blah set unit = test\";\n        runner.update(conn, sql).get();\n\n        verify(stmt, times(1)).executeUpdate(sql);\n        verify(stmt, times(1)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we closed the connection\n\n        // call the other variation\n        when(meta.getParameterCount()).thenReturn(1);\n        sql = \"update blah set unit = ?\";\n        runner.update(conn, sql, \"test\").get();\n\n        verify(prepStmt, times(2)).executeUpdate();\n        verify(prepStmt, times(2)).close();    // make sure we closed the statement\n        verify(conn, times(0)).close();    // make sure we closed the connection\n    }", "signature": "private void callGoodUpdate(final Connection conn)"}, {"syntax_pass": true, "original_string": "    private void callQueryWithException(final Object... params) throws Exception {\n        boolean caught = false;\n\n        try {\n            when(meta.getParameterCount()).thenReturn(2);\n            runner.query(\"select * from blah where ? = ?\", handler, params).get();\n\n            verify(prepStmt, times(1)).executeQuery();\n            verify(results, times(1)).close();\n            verify(prepStmt, times(1)).close(); // make sure we closed the statement\n            verify(conn, times(1)).close(); // make sure we closed the connection\n        } catch (final Exception e) {\n            caught = true;\n        }\n\n        if (!caught) {\n            fail(\"Exception never thrown, but expected\");\n        }\n    }", "docstring": " helper method for calling batch when an exception is expected", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "callQueryWithException", "params": [], "body": "                                                                                 {\n        boolean caught = false;\n\n        try {\n            when(meta.getParameterCount()).thenReturn(2);\n            runner.query(\"select * from blah where ? = ?\", handler, params).get();\n\n            verify(prepStmt, times(1)).executeQuery();\n            verify(results, times(1)).close();\n            verify(prepStmt, times(1)).close(); // make sure we closed the statement\n            verify(conn, times(1)).close(); // make sure we closed the connection\n        } catch (final Exception e) {\n            caught = true;\n        }\n\n        if (!caught) {\n            fail(\"Exception never thrown, but expected\");\n        }\n    }", "signature": "private void callQueryWithException(final Object... params)"}, {"syntax_pass": true, "original_string": "    private void callUpdateWithException(final Object... params) throws Exception {\n        boolean caught = false;\n\n        try {\n            when(meta.getParameterCount()).thenReturn(2);\n            runner.update(\"select * from blah where ? = ?\", params).get();\n\n            verify(prepStmt, times(1)).executeUpdate();\n            verify(prepStmt, times(1)).close(); // make sure we closed the statement\n            verify(conn, times(1)).close(); // make sure we closed the connection\n        } catch (final Exception e) {\n            caught = true;\n        }\n\n        if (!caught) {\n            fail(\"Exception never thrown, but expected\");\n        }\n    }", "docstring": " helper method for calling batch when an exception is expected", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "callUpdateWithException", "params": [], "body": "                                                                                  {\n        boolean caught = false;\n\n        try {\n            when(meta.getParameterCount()).thenReturn(2);\n            runner.update(\"select * from blah where ? = ?\", params).get();\n\n            verify(prepStmt, times(1)).executeUpdate();\n            verify(prepStmt, times(1)).close(); // make sure we closed the statement\n            verify(conn, times(1)).close(); // make sure we closed the connection\n        } catch (final Exception e) {\n            caught = true;\n        }\n\n        if (!caught) {\n            fail(\"Exception never thrown, but expected\");\n        }\n    }", "signature": "private void callUpdateWithException(final Object... params)"}, {"syntax_pass": true, "original_string": "    @Before\n    public void setUp() throws Exception {\n        when(dataSource.getConnection()).thenReturn(conn);\n\n        when(conn.prepareStatement(any(String.class))).thenReturn(prepStmt);\n        when(prepStmt.getParameterMetaData()).thenReturn(meta);\n        when(prepStmt.executeQuery()).thenReturn(results);\n\n        when(conn.createStatement()).thenReturn(stmt);\n        when(stmt.executeQuery(any(String.class))).thenReturn(results);\n\n        when(results.next()).thenReturn(false);\n\n         handler = new ArrayHandler();\n         runner = new AsyncQueryRunner(Executors.newFixedThreadPool(1), new QueryRunner(dataSource));\n    }", "docstring": "", "attributes": {"modifiers": "@Before\n    public", "marker_annotations": ["@Before"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setUp", "params": [], "body": "                                         {\n        when(dataSource.getConnection()).thenReturn(conn);\n\n        when(conn.prepareStatement(any(String.class))).thenReturn(prepStmt);\n        when(prepStmt.getParameterMetaData()).thenReturn(meta);\n        when(prepStmt.executeQuery()).thenReturn(results);\n\n        when(conn.createStatement()).thenReturn(stmt);\n        when(stmt.executeQuery(any(String.class))).thenReturn(results);\n\n        when(results.next()).thenReturn(false);\n\n         handler = new ArrayHandler();\n         runner = new AsyncQueryRunner(Executors.newFixedThreadPool(1), new QueryRunner(dataSource));\n    }", "signature": "@Before\n    public void setUp()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testAddBatchException() throws Exception {\n        final String[][] params = { { \"unit\", \"unit\" }, { \"test\", \"test\" } };\n\n        callBatchWithException(\"select * from blah where ? = ?\", params);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testAddBatchException", "params": [], "body": "                                                         {\n        final String[][] params = { { \"unit\", \"unit\" }, { \"test\", \"test\" } };\n\n        callBatchWithException(\"select * from blah where ? = ?\", params);\n    }", "signature": "@Test\n    public void testAddBatchException()"}, {"syntax_pass": true, "original_string": "    @Test(expected = ExecutionException.class)\n    public void testBadPrepareConnection() throws Exception {\n        runner = new AsyncQueryRunner(Executors.newFixedThreadPool(1));\n        runner.update(\"update blah set unit = test\").get();\n    }", "docstring": "", "attributes": {"modifiers": "@Test(expected = ExecutionException.class)\n    public", "marker_annotations": [], "non_marker_annotations": ["@Test(expected = ExecutionException.class)", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testBadPrepareConnection", "params": [], "body": "                                                            {\n        runner = new AsyncQueryRunner(Executors.newFixedThreadPool(1));\n        runner.update(\"update blah set unit = test\").get();\n    }", "signature": "@Test(expected = ExecutionException.class)\n    public void testBadPrepareConnection()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testExecuteBatchException() throws Exception {\n        final String[][] params = { { \"unit\", \"unit\" }, { \"test\", \"test\" } };\n\n        callBatchWithException(\"select * from blah where ? = ?\", params);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testExecuteBatchException", "params": [], "body": "                                                             {\n        final String[][] params = { { \"unit\", \"unit\" }, { \"test\", \"test\" } };\n\n        callBatchWithException(\"select * from blah where ? = ?\", params);\n    }", "signature": "@Test\n    public void testExecuteBatchException()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testExecuteQueryException() throws Exception {\n        callQueryWithException(handler, \"unit\", \"test\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testExecuteQueryException", "params": [], "body": "                                                             {\n        callQueryWithException(handler, \"unit\", \"test\");\n    }", "signature": "@Test\n    public void testExecuteQueryException()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testExecuteUpdateException() throws Exception {\n        doThrow(new SQLException()).when(prepStmt).executeUpdate();\n\n        callUpdateWithException(\"unit\", \"test\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testExecuteUpdateException", "params": [], "body": "                                                              {\n        doThrow(new SQLException()).when(prepStmt).executeUpdate();\n\n        callUpdateWithException(\"unit\", \"test\");\n    }", "signature": "@Test\n    public void testExecuteUpdateException()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testGoodBatch() throws Exception {\n        final String[][] params = { { \"unit\", \"unit\" }, { \"test\", \"test\" } };\n\n        callGoodBatch(params);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGoodBatch", "params": [], "body": "                                                 {\n        final String[][] params = { { \"unit\", \"unit\" }, { \"test\", \"test\" } };\n\n        callGoodBatch(params);\n    }", "signature": "@Test\n    public void testGoodBatch()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testGoodBatchDefaultConstructor() throws Exception {\n        runner = new AsyncQueryRunner(Executors.newFixedThreadPool(1));\n        final String[][] params = { { \"unit\", \"unit\" }, { \"test\", \"test\" } };\n\n        callGoodBatch(conn, params);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGoodBatchDefaultConstructor", "params": [], "body": "                                                                   {\n        runner = new AsyncQueryRunner(Executors.newFixedThreadPool(1));\n        final String[][] params = { { \"unit\", \"unit\" }, { \"test\", \"test\" } };\n\n        callGoodBatch(conn, params);\n    }", "signature": "@Test\n    public void testGoodBatchDefaultConstructor()"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"deprecation\") // deliberate test of deprecated code\n    @Test\n    public void testGoodBatchPmdTrue() throws Exception {\n        runner = new AsyncQueryRunner(dataSource, true, Executors.newFixedThreadPool(1));\n        final String[][] params = { { \"unit\", \"unit\" }, { \"test\", \"test\" } };\n\n        callGoodBatch(params);\n    }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"deprecation\") // deliberate test of deprecated code\n    @Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["@SuppressWarnings(\"deprecation\")", "public"], "comments": ["// deliberate test of deprecated code"], "return_type": "void", "classes": []}, "name": "testGoodBatchPmdTrue", "params": [], "body": "                                                        {\n        runner = new AsyncQueryRunner(dataSource, true, Executors.newFixedThreadPool(1));\n        final String[][] params = { { \"unit\", \"unit\" }, { \"test\", \"test\" } };\n\n        callGoodBatch(params);\n    }", "signature": "@SuppressWarnings(\"deprecation\") // deliberate test of deprecated code\n    @Test\n    public void testGoodBatchPmdTrue()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testGoodQuery() throws Exception {\n        callGoodQuery();\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGoodQuery", "params": [], "body": "                                                 {\n        callGoodQuery();\n    }", "signature": "@Test\n    public void testGoodQuery()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testGoodQueryDefaultConstructor() throws Exception {\n        runner = new AsyncQueryRunner(Executors.newFixedThreadPool(1));\n        callGoodQuery(conn);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGoodQueryDefaultConstructor", "params": [], "body": "                                                                   {\n        runner = new AsyncQueryRunner(Executors.newFixedThreadPool(1));\n        callGoodQuery(conn);\n    }", "signature": "@Test\n    public void testGoodQueryDefaultConstructor()"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"deprecation\") // deliberate test of deprecated code\n    @Test\n    public void testGoodQueryPmdTrue() throws Exception {\n        runner = new AsyncQueryRunner(true, Executors.newFixedThreadPool(1));\n        callGoodQuery(conn);\n    }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"deprecation\") // deliberate test of deprecated code\n    @Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["@SuppressWarnings(\"deprecation\")", "public"], "comments": ["// deliberate test of deprecated code"], "return_type": "void", "classes": []}, "name": "testGoodQueryPmdTrue", "params": [], "body": "                                                        {\n        runner = new AsyncQueryRunner(true, Executors.newFixedThreadPool(1));\n        callGoodQuery(conn);\n    }", "signature": "@SuppressWarnings(\"deprecation\") // deliberate test of deprecated code\n    @Test\n    public void testGoodQueryPmdTrue()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testGoodUpdate() throws Exception {\n        callGoodUpdate();\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGoodUpdate", "params": [], "body": "                                                  {\n        callGoodUpdate();\n    }", "signature": "@Test\n    public void testGoodUpdate()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testGoodUpdateDefaultConstructor() throws Exception {\n        runner = new AsyncQueryRunner(Executors.newFixedThreadPool(1));\n        callGoodUpdate(conn);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGoodUpdateDefaultConstructor", "params": [], "body": "                                                                    {\n        runner = new AsyncQueryRunner(Executors.newFixedThreadPool(1));\n        callGoodUpdate(conn);\n    }", "signature": "@Test\n    public void testGoodUpdateDefaultConstructor()"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"deprecation\") // deliberate test of deprecated code\n    @Test\n    public void testGoodUpdatePmdTrue() throws Exception {\n        runner = new AsyncQueryRunner(true, Executors.newFixedThreadPool(1));\n        callGoodUpdate(conn);\n    }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"deprecation\") // deliberate test of deprecated code\n    @Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["@SuppressWarnings(\"deprecation\")", "public"], "comments": ["// deliberate test of deprecated code"], "return_type": "void", "classes": []}, "name": "testGoodUpdatePmdTrue", "params": [], "body": "                                                         {\n        runner = new AsyncQueryRunner(true, Executors.newFixedThreadPool(1));\n        callGoodUpdate(conn);\n    }", "signature": "@SuppressWarnings(\"deprecation\") // deliberate test of deprecated code\n    @Test\n    public void testGoodUpdatePmdTrue()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testInsertUsesGivenQueryRunner() throws Exception {\n        final QueryRunner mockQueryRunner = mock(QueryRunner.class, org.mockito.Mockito.withSettings().verboseLogging() // debug for Continuum\n        );\n        runner = new AsyncQueryRunner(Executors.newSingleThreadExecutor(), mockQueryRunner);\n\n        runner.insert(\"1\", handler);\n        runner.insert(\"2\", handler, \"param1\");\n        runner.insert(conn, \"3\", handler);\n        runner.insert(conn, \"4\", handler, \"param1\");\n\n        // give the Executor time to submit all insert statements. Otherwise the following verify statements will fail from time to time.\n        TimeUnit.MILLISECONDS.sleep(50);\n\n        verify(mockQueryRunner).insert(\"1\", handler);\n        verify(mockQueryRunner).insert(\"2\", handler, \"param1\");\n        verify(mockQueryRunner).insert(conn, \"3\", handler);\n        verify(mockQueryRunner).insert(conn, \"4\", handler, \"param1\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testInsertUsesGivenQueryRunner", "params": [], "body": "                                                                  {\n        final QueryRunner mockQueryRunner = mock(QueryRunner.class, org.mockito.Mockito.withSettings().verboseLogging() // debug for Continuum\n        );\n        runner = new AsyncQueryRunner(Executors.newSingleThreadExecutor(), mockQueryRunner);\n\n        runner.insert(\"1\", handler);\n        runner.insert(\"2\", handler, \"param1\");\n        runner.insert(conn, \"3\", handler);\n        runner.insert(conn, \"4\", handler, \"param1\");\n\n        // give the Executor time to submit all insert statements. Otherwise the following verify statements will fail from time to time.\n        TimeUnit.MILLISECONDS.sleep(50);\n\n        verify(mockQueryRunner).insert(\"1\", handler);\n        verify(mockQueryRunner).insert(\"2\", handler, \"param1\");\n        verify(mockQueryRunner).insert(conn, \"3\", handler);\n        verify(mockQueryRunner).insert(conn, \"4\", handler, \"param1\");\n    }", "signature": "@Test\n    public void testInsertUsesGivenQueryRunner()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testNoParamsQuery() throws Exception {\n        callGoodQuery();\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testNoParamsQuery", "params": [], "body": "                                                     {\n        callGoodQuery();\n    }", "signature": "@Test\n    public void testNoParamsQuery()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testNoParamsUpdate() throws Exception {\n        callGoodUpdate();\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testNoParamsUpdate", "params": [], "body": "                                                      {\n        callGoodUpdate();\n    }", "signature": "@Test\n    public void testNoParamsUpdate()"}, {"syntax_pass": true, "original_string": "    @Test(expected = ExecutionException.class)\n    public void testNullConnectionBatch() throws Exception {\n        final String[][] params = { { \"unit\", \"unit\" }, { \"test\", \"test\" } };\n\n        when(dataSource.getConnection()).thenReturn(null);\n\n        runner.batch(\"select * from blah where ? = ?\", params).get();\n    }", "docstring": "", "attributes": {"modifiers": "@Test(expected = ExecutionException.class)\n    public", "marker_annotations": [], "non_marker_annotations": ["@Test(expected = ExecutionException.class)", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testNullConnectionBatch", "params": [], "body": "                                                           {\n        final String[][] params = { { \"unit\", \"unit\" }, { \"test\", \"test\" } };\n\n        when(dataSource.getConnection()).thenReturn(null);\n\n        runner.batch(\"select * from blah where ? = ?\", params).get();\n    }", "signature": "@Test(expected = ExecutionException.class)\n    public void testNullConnectionBatch()"}, {"syntax_pass": true, "original_string": "    @Test(expected = ExecutionException.class)\n    public void testNullConnectionQuery() throws Exception {\n        when(dataSource.getConnection()).thenReturn(null);\n\n        runner.query(\"select * from blah where ? = ?\", handler, \"unit\", \"test\").get();\n    }", "docstring": "", "attributes": {"modifiers": "@Test(expected = ExecutionException.class)\n    public", "marker_annotations": [], "non_marker_annotations": ["@Test(expected = ExecutionException.class)", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testNullConnectionQuery", "params": [], "body": "                                                           {\n        when(dataSource.getConnection()).thenReturn(null);\n\n        runner.query(\"select * from blah where ? = ?\", handler, \"unit\", \"test\").get();\n    }", "signature": "@Test(expected = ExecutionException.class)\n    public void testNullConnectionQuery()"}, {"syntax_pass": true, "original_string": "    @Test(expected = ExecutionException.class)\n    public void testNullConnectionUpdate() throws Exception {\n        when(dataSource.getConnection()).thenReturn(null);\n\n        runner.update(\"select * from blah where ? = ?\", \"unit\", \"test\").get();\n    }", "docstring": "", "attributes": {"modifiers": "@Test(expected = ExecutionException.class)\n    public", "marker_annotations": [], "non_marker_annotations": ["@Test(expected = ExecutionException.class)", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testNullConnectionUpdate", "params": [], "body": "                                                            {\n        when(dataSource.getConnection()).thenReturn(null);\n\n        runner.update(\"select * from blah where ? = ?\", \"unit\", \"test\").get();\n    }", "signature": "@Test(expected = ExecutionException.class)\n    public void testNullConnectionUpdate()"}, {"syntax_pass": true, "original_string": "    @Test(expected = ExecutionException.class)\n    public void testNullHandlerQuery() throws Exception {\n        runner.query(\"select * from blah where ? = ?\", null).get();\n    }", "docstring": "", "attributes": {"modifiers": "@Test(expected = ExecutionException.class)\n    public", "marker_annotations": [], "non_marker_annotations": ["@Test(expected = ExecutionException.class)", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testNullHandlerQuery", "params": [], "body": "                                                        {\n        runner.query(\"select * from blah where ? = ?\", null).get();\n    }", "signature": "@Test(expected = ExecutionException.class)\n    public void testNullHandlerQuery()"}, {"syntax_pass": true, "original_string": "    @Test(expected = ExecutionException.class)\n    public void testNullParamsArgBatch() throws Exception {\n        runner.batch(\"select * from blah where ? = ?\", null).get();\n    }", "docstring": "", "attributes": {"modifiers": "@Test(expected = ExecutionException.class)\n    public", "marker_annotations": [], "non_marker_annotations": ["@Test(expected = ExecutionException.class)", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testNullParamsArgBatch", "params": [], "body": "                                                          {\n        runner.batch(\"select * from blah where ? = ?\", null).get();\n    }", "signature": "@Test(expected = ExecutionException.class)\n    public void testNullParamsArgBatch()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testNullParamsBatch() throws Exception {\n        final String[][] params = { { null, \"unit\" }, { \"test\", null } };\n\n        callGoodBatch(params);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testNullParamsBatch", "params": [], "body": "                                                       {\n        final String[][] params = { { null, \"unit\" }, { \"test\", null } };\n\n        callGoodBatch(params);\n    }", "signature": "@Test\n    public void testNullParamsBatch()"}, {"syntax_pass": true, "original_string": "    @Test(expected = ExecutionException.class)\n    public void testNullSqlBatch() throws Exception {\n        final String[][] params = { { \"unit\", \"unit\" }, { \"test\", \"test\" } };\n\n        runner.batch(null, params).get();\n    }", "docstring": "", "attributes": {"modifiers": "@Test(expected = ExecutionException.class)\n    public", "marker_annotations": [], "non_marker_annotations": ["@Test(expected = ExecutionException.class)", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testNullSqlBatch", "params": [], "body": "                                                    {\n        final String[][] params = { { \"unit\", \"unit\" }, { \"test\", \"test\" } };\n\n        runner.batch(null, params).get();\n    }", "signature": "@Test(expected = ExecutionException.class)\n    public void testNullSqlBatch()"}, {"syntax_pass": true, "original_string": "    @Test(expected = ExecutionException.class)\n    public void testNullSqlQuery() throws Exception {\n        runner.query(null, handler).get();\n    }", "docstring": "", "attributes": {"modifiers": "@Test(expected = ExecutionException.class)\n    public", "marker_annotations": [], "non_marker_annotations": ["@Test(expected = ExecutionException.class)", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testNullSqlQuery", "params": [], "body": "                                                    {\n        runner.query(null, handler).get();\n    }", "signature": "@Test(expected = ExecutionException.class)\n    public void testNullSqlQuery()"}, {"syntax_pass": true, "original_string": "    @Test(expected = ExecutionException.class)\n    public void testNullSqlUpdate() throws Exception {\n        runner.update(null).get();\n    }", "docstring": "", "attributes": {"modifiers": "@Test(expected = ExecutionException.class)\n    public", "marker_annotations": [], "non_marker_annotations": ["@Test(expected = ExecutionException.class)", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testNullSqlUpdate", "params": [], "body": "                                                     {\n        runner.update(null).get();\n    }", "signature": "@Test(expected = ExecutionException.class)\n    public void testNullSqlUpdate()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testTooFewParamsBatch() throws Exception {\n        final String[][] params = { { \"unit\" }, { \"test\" } };\n\n        callBatchWithException(\"select * from blah where ? = ?\", params);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testTooFewParamsBatch", "params": [], "body": "                                                         {\n        final String[][] params = { { \"unit\" }, { \"test\" } };\n\n        callBatchWithException(\"select * from blah where ? = ?\", params);\n    }", "signature": "@Test\n    public void testTooFewParamsBatch()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testTooFewParamsQuery() throws Exception {\n        callQueryWithException(\"unit\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testTooFewParamsQuery", "params": [], "body": "                                                         {\n        callQueryWithException(\"unit\");\n    }", "signature": "@Test\n    public void testTooFewParamsQuery()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testTooFewParamsUpdate() throws Exception {\n        callUpdateWithException(\"unit\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testTooFewParamsUpdate", "params": [], "body": "                                                          {\n        callUpdateWithException(\"unit\");\n    }", "signature": "@Test\n    public void testTooFewParamsUpdate()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testTooManyParamsBatch() throws Exception {\n        final String[][] params = { { \"unit\", \"unit\", \"unit\" }, { \"test\", \"test\", \"test\" } };\n\n        callBatchWithException(\"select * from blah where ? = ?\", params);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testTooManyParamsBatch", "params": [], "body": "                                                          {\n        final String[][] params = { { \"unit\", \"unit\", \"unit\" }, { \"test\", \"test\", \"test\" } };\n\n        callBatchWithException(\"select * from blah where ? = ?\", params);\n    }", "signature": "@Test\n    public void testTooManyParamsBatch()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testTooManyParamsQuery() throws Exception {\n        callQueryWithException(\"unit\", \"test\", \"fail\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testTooManyParamsQuery", "params": [], "body": "                                                          {\n        callQueryWithException(\"unit\", \"test\", \"fail\");\n    }", "signature": "@Test\n    public void testTooManyParamsQuery()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testTooManyParamsUpdate() throws Exception {\n        callUpdateWithException(\"unit\", \"test\", \"fail\");\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testTooManyParamsUpdate", "params": [], "body": "                                                           {\n        callUpdateWithException(\"unit\", \"test\", \"fail\");\n    }", "signature": "@Test\n    public void testTooManyParamsUpdate()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/dbutils/ServiceLoaderTest.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils;\n\nimport static org.junit.Assert.assertTrue;\n\nimport java.util.ServiceLoader;\n\nimport org.apache.commons.dbutils.handlers.columns.TestColumnHandler;\nimport org.apache.commons.dbutils.handlers.properties.TestPropertyHandler;\nimport org.junit.Before;\nimport org.junit.Test;\n\npublic class ServiceLoaderTest {\n    private ServiceLoader<ColumnHandler> columns;\n    private ServiceLoader<PropertyHandler> properties;\n\n    @Before\n    public void setUp() {\n        columns = ServiceLoader.load(ColumnHandler.class);\n        properties = ServiceLoader.load(PropertyHandler.class);\n    }\n\n    /**\n     * Verifying 'more than 1' shows that we found more than we loaded locally which assumes the core handlers were loaded, too.\n     */\n    @Test\n    public void testFindMoreThanLocalColumns() {\n        int count = 0;\n        for (final ColumnHandler<?> handler : columns) {\n            count++;\n        }\n\n        assertTrue(count > 1);\n    }\n\n    /**\n     * Verifying 'more than 1' shows that we found more than we loaded locally which assumes the core handlers were loaded, too.\n     */\n    @Test\n    public void testFindMoreThanLocalProperties() {\n        int count = 0;\n        for (final PropertyHandler handler : properties) {\n            count++;\n        }\n\n        assertTrue(count > 1);\n    }\n\n    @Test\n    public void testFindsLocalColumnHandler() {\n        boolean found = false;\n        for (final ColumnHandler<?> handler : columns) {\n            // this class is defined outside of the main classes in dbutils\n            if (handler instanceof TestColumnHandler) {\n                found = true;\n            }\n        }\n\n        assertTrue(found);\n    }\n\n    @Test\n    public void testFindsLocalPropertyHandler() {\n        boolean found = false;\n        for (final PropertyHandler handler : properties) {\n            // this class is defined outside of the main classes in dbutils\n            if (handler instanceof TestPropertyHandler) {\n                found = true;\n            }\n        }\n\n        assertTrue(found);\n    }\n\n}\n", "file_hash": "68a582ee8796e2669534c7bb638170b8e402e0ad6a926c11b3ad079b809bf9d3", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils;", "import static org.junit.Assert.assertTrue;", "import java.util.ServiceLoader;", "import org.apache.commons.dbutils.handlers.columns.TestColumnHandler;", "import org.apache.commons.dbutils.handlers.properties.TestPropertyHandler;", "import org.junit.Before;", "import org.junit.Test;"], "methods": [], "classes": [{"original_string": "public class ServiceLoaderTest {\n    private ServiceLoader<ColumnHandler> columns;\n    private ServiceLoader<PropertyHandler> properties;\n\n    @Before\n    public void setUp() {\n        columns = ServiceLoader.load(ColumnHandler.class);\n        properties = ServiceLoader.load(PropertyHandler.class);\n    }\n\n    /**\n     * Verifying 'more than 1' shows that we found more than we loaded locally which assumes the core handlers were loaded, too.\n     */\n    @Test\n    public void testFindMoreThanLocalColumns() {\n        int count = 0;\n        for (final ColumnHandler<?> handler : columns) {\n            count++;\n        }\n\n        assertTrue(count > 1);\n    }\n\n    /**\n     * Verifying 'more than 1' shows that we found more than we loaded locally which assumes the core handlers were loaded, too.\n     */\n    @Test\n    public void testFindMoreThanLocalProperties() {\n        int count = 0;\n        for (final PropertyHandler handler : properties) {\n            count++;\n        }\n\n        assertTrue(count > 1);\n    }\n\n    @Test\n    public void testFindsLocalColumnHandler() {\n        boolean found = false;\n        for (final ColumnHandler<?> handler : columns) {\n            // this class is defined outside of the main classes in dbutils\n            if (handler instanceof TestColumnHandler) {\n                found = true;\n            }\n        }\n\n        assertTrue(found);\n    }\n\n    @Test\n    public void testFindsLocalPropertyHandler() {\n        boolean found = false;\n        for (final PropertyHandler handler : properties) {\n            // this class is defined outside of the main classes in dbutils\n            if (handler instanceof TestPropertyHandler) {\n                found = true;\n            }\n        }\n\n        assertTrue(found);\n    }\n\n}", "definition": "public class ServiceLoaderTest", "class_docstring": "", "name": "ServiceLoaderTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private ServiceLoader<ColumnHandler> columns;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ServiceLoader<ColumnHandler>", "name": "columns", "syntax_pass": true}, {"attribute_expression": "private ServiceLoader<PropertyHandler> properties;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ServiceLoader<PropertyHandler>", "name": "properties", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Before\n    public void setUp() {\n        columns = ServiceLoader.load(ColumnHandler.class);\n        properties = ServiceLoader.load(PropertyHandler.class);\n    }", "docstring": "", "attributes": {"modifiers": "@Before\n    public", "marker_annotations": ["@Before"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setUp", "params": [], "body": "                        {\n        columns = ServiceLoader.load(ColumnHandler.class);\n        properties = ServiceLoader.load(PropertyHandler.class);\n    }", "signature": "@Before\n    public void setUp()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testFindMoreThanLocalColumns() {\n        int count = 0;\n        for (final ColumnHandler<?> handler : columns) {\n            count++;\n        }\n\n        assertTrue(count > 1);\n    }", "docstring": "\nVerifying 'more than 1' shows that we found more than we loaded locally which assumes the core handlers were loaded, too.\n", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testFindMoreThanLocalColumns", "params": [], "body": "                                               {\n        int count = 0;\n        for (final ColumnHandler<?> handler : columns) {\n            count++;\n        }\n\n        assertTrue(count > 1);\n    }", "signature": "@Test\n    public void testFindMoreThanLocalColumns()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testFindMoreThanLocalProperties() {\n        int count = 0;\n        for (final PropertyHandler handler : properties) {\n            count++;\n        }\n\n        assertTrue(count > 1);\n    }", "docstring": "\nVerifying 'more than 1' shows that we found more than we loaded locally which assumes the core handlers were loaded, too.\n", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testFindMoreThanLocalProperties", "params": [], "body": "                                                  {\n        int count = 0;\n        for (final PropertyHandler handler : properties) {\n            count++;\n        }\n\n        assertTrue(count > 1);\n    }", "signature": "@Test\n    public void testFindMoreThanLocalProperties()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testFindsLocalColumnHandler() {\n        boolean found = false;\n        for (final ColumnHandler<?> handler : columns) {\n            // this class is defined outside of the main classes in dbutils\n            if (handler instanceof TestColumnHandler) {\n                found = true;\n            }\n        }\n\n        assertTrue(found);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testFindsLocalColumnHandler", "params": [], "body": "                                              {\n        boolean found = false;\n        for (final ColumnHandler<?> handler : columns) {\n            // this class is defined outside of the main classes in dbutils\n            if (handler instanceof TestColumnHandler) {\n                found = true;\n            }\n        }\n\n        assertTrue(found);\n    }", "signature": "@Test\n    public void testFindsLocalColumnHandler()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testFindsLocalPropertyHandler() {\n        boolean found = false;\n        for (final PropertyHandler handler : properties) {\n            // this class is defined outside of the main classes in dbutils\n            if (handler instanceof TestPropertyHandler) {\n                found = true;\n            }\n        }\n\n        assertTrue(found);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testFindsLocalPropertyHandler", "params": [], "body": "                                                {\n        boolean found = false;\n        for (final PropertyHandler handler : properties) {\n            // this class is defined outside of the main classes in dbutils\n            if (handler instanceof TestPropertyHandler) {\n                found = true;\n            }\n        }\n\n        assertTrue(found);\n    }", "signature": "@Test\n    public void testFindsLocalPropertyHandler()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/dbutils/TestBean.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils;\n\n/**\n * A bean to use in testing toBean() and toBeanList().\n */\npublic class TestBean {\n\n    public enum Ordinal {\n\n        THREE, SIX;\n\n    }\n\n    private String one;\n\n    private String two;\n\n    private Ordinal three;\n\n    private int intTest;\n\n    private Integer integerTest = Integer.valueOf(0);\n\n    // UNUSED private Timestamp timestamp;\n\n    private String doNotSet = \"not set\";\n\n    /**\n     * toBean() should set primitive fields to their defaults (ie. 0) when null is returned from the ResultSet.\n     */\n    private int nullPrimitiveTest = 7;\n\n    /**\n     * toBean() should set Object fields to null when null is returned from the ResultSet\n     */\n    private Object nullObjectTest = \"overwrite\";\n\n    /**\n     * A Date will be returned from the ResultSet but the property is a String. BeanProcessor should create a String from the Date and set this property.\n     */\n    private String notDate = \"not a date\";\n\n    /**\n     * The ResultSet will have a BigDecimal in this column and the BasicColumnProcessor should convert that to a double and store the value in this property.\n     */\n    private double columnProcessorDoubleTest = -1;\n\n    /**\n     * Constructor for TestBean.\n     */\n    public TestBean() {\n    }\n\n    public double getColumnProcessorDoubleTest() {\n        return columnProcessorDoubleTest;\n    }\n\n    public String getDoNotSet() {\n        return doNotSet;\n    }\n\n    public Integer getIntegerTest() {\n        return integerTest;\n    }\n\n    public int getIntTest() {\n        return intTest;\n    }\n\n    public String getNotDate() {\n        return notDate;\n    }\n\n    public Object getNullObjectTest() {\n        return nullObjectTest;\n    }\n\n    public int getNullPrimitiveTest() {\n        return nullPrimitiveTest;\n    }\n\n    public String getOne() {\n        return one;\n    }\n\n    public Ordinal getThree() {\n        return three;\n    }\n\n    public String getTwo() {\n        return two;\n    }\n\n    public void setColumnProcessorDoubleTest(final double d) {\n        columnProcessorDoubleTest = d;\n    }\n\n    public void setDoNotSet(final String string) {\n        doNotSet = string;\n    }\n\n    public void setIntegerTest(final Integer integer) {\n        integerTest = integer;\n    }\n\n    public void setIntTest(final int i) {\n        intTest = i;\n    }\n\n    public void setNotDate(final String string) {\n        notDate = string;\n    }\n\n    public void setNullObjectTest(final Object object) {\n        nullObjectTest = object;\n    }\n\n    public void setNullPrimitiveTest(final int i) {\n        nullPrimitiveTest = i;\n    }\n\n    public void setOne(final String string) {\n        one = string;\n    }\n\n    public void setThree(final Ordinal ordinal) {\n        three = ordinal;\n    }\n\n    public void setTwo(final String string) {\n        two = string;\n    }\n\n}\n", "file_hash": "32f2085a8288b2d16d0a980a5efe22fd4b18c8415fc29609ad0bffd0f1d57745", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils;"], "methods": [], "classes": [{"original_string": "public class TestBean {\n\n    public enum Ordinal {\n\n        THREE, SIX;\n\n    }\n\n    private String one;\n\n    private String two;\n\n    private Ordinal three;\n\n    private int intTest;\n\n    private Integer integerTest = Integer.valueOf(0);\n\n    // UNUSED private Timestamp timestamp;\n\n    private String doNotSet = \"not set\";\n\n    /**\n     * toBean() should set primitive fields to their defaults (ie. 0) when null is returned from the ResultSet.\n     */\n    private int nullPrimitiveTest = 7;\n\n    /**\n     * toBean() should set Object fields to null when null is returned from the ResultSet\n     */\n    private Object nullObjectTest = \"overwrite\";\n\n    /**\n     * A Date will be returned from the ResultSet but the property is a String. BeanProcessor should create a String from the Date and set this property.\n     */\n    private String notDate = \"not a date\";\n\n    /**\n     * The ResultSet will have a BigDecimal in this column and the BasicColumnProcessor should convert that to a double and store the value in this property.\n     */\n    private double columnProcessorDoubleTest = -1;\n\n    /**\n     * Constructor for TestBean.\n     */\n    public TestBean() {\n    }\n\n    public double getColumnProcessorDoubleTest() {\n        return columnProcessorDoubleTest;\n    }\n\n    public String getDoNotSet() {\n        return doNotSet;\n    }\n\n    public Integer getIntegerTest() {\n        return integerTest;\n    }\n\n    public int getIntTest() {\n        return intTest;\n    }\n\n    public String getNotDate() {\n        return notDate;\n    }\n\n    public Object getNullObjectTest() {\n        return nullObjectTest;\n    }\n\n    public int getNullPrimitiveTest() {\n        return nullPrimitiveTest;\n    }\n\n    public String getOne() {\n        return one;\n    }\n\n    public Ordinal getThree() {\n        return three;\n    }\n\n    public String getTwo() {\n        return two;\n    }\n\n    public void setColumnProcessorDoubleTest(final double d) {\n        columnProcessorDoubleTest = d;\n    }\n\n    public void setDoNotSet(final String string) {\n        doNotSet = string;\n    }\n\n    public void setIntegerTest(final Integer integer) {\n        integerTest = integer;\n    }\n\n    public void setIntTest(final int i) {\n        intTest = i;\n    }\n\n    public void setNotDate(final String string) {\n        notDate = string;\n    }\n\n    public void setNullObjectTest(final Object object) {\n        nullObjectTest = object;\n    }\n\n    public void setNullPrimitiveTest(final int i) {\n        nullPrimitiveTest = i;\n    }\n\n    public void setOne(final String string) {\n        one = string;\n    }\n\n    public void setThree(final Ordinal ordinal) {\n        three = ordinal;\n    }\n\n    public void setTwo(final String string) {\n        two = string;\n    }\n\n}", "definition": "public class TestBean", "class_docstring": "\nA bean to use in testing toBean() and toBeanList().\n", "name": "TestBean", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private String one;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "one", "syntax_pass": true}, {"attribute_expression": "private String two;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "two", "syntax_pass": true}, {"attribute_expression": "private Ordinal three;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Ordinal", "name": "three", "syntax_pass": true}, {"attribute_expression": "private int intTest;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "intTest", "syntax_pass": true}, {"attribute_expression": "private Integer integerTest = Integer.valueOf(0);", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Integer", "name": "integerTest = Integer.valueOf(0)", "syntax_pass": true}, {"attribute_expression": "private String doNotSet = \"not set\";", "docstring": " UNUSED private Timestamp timestamp;", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "doNotSet = \"not set\"", "syntax_pass": true}, {"attribute_expression": "private int nullPrimitiveTest = 7;", "docstring": "\ntoBean() should set primitive fields to their defaults (ie. 0) when null is returned from the ResultSet.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "nullPrimitiveTest = 7", "syntax_pass": true}, {"attribute_expression": "private Object nullObjectTest = \"overwrite\";", "docstring": "\ntoBean() should set Object fields to null when null is returned from the ResultSet\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Object", "name": "nullObjectTest = \"overwrite\"", "syntax_pass": true}, {"attribute_expression": "private String notDate = \"not a date\";", "docstring": "\nA Date will be returned from the ResultSet but the property is a String. BeanProcessor should create a String from the Date and set this property.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "notDate = \"not a date\"", "syntax_pass": true}, {"attribute_expression": "private double columnProcessorDoubleTest = -1;", "docstring": "\nThe ResultSet will have a BigDecimal in this column and the BasicColumnProcessor should convert that to a double and store the value in this property.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "double", "name": "columnProcessorDoubleTest = -1", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public TestBean() {\n    }", "docstring": "\nConstructor for TestBean.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "TestBean", "params": [], "body": "                      {\n    }", "signature": "public TestBean()"}, {"syntax_pass": true, "original_string": "    public double getColumnProcessorDoubleTest() {\n        return columnProcessorDoubleTest;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "getColumnProcessorDoubleTest", "params": [], "body": "                                                 {\n        return columnProcessorDoubleTest;\n    }", "signature": "public double getColumnProcessorDoubleTest()"}, {"syntax_pass": true, "original_string": "    public String getDoNotSet() {\n        return doNotSet;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getDoNotSet", "params": [], "body": "                                {\n        return doNotSet;\n    }", "signature": "public String getDoNotSet()"}, {"syntax_pass": true, "original_string": "    public Integer getIntegerTest() {\n        return integerTest;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Integer", "classes": []}, "name": "getIntegerTest", "params": [], "body": "                                    {\n        return integerTest;\n    }", "signature": "public Integer getIntegerTest()"}, {"syntax_pass": true, "original_string": "    public int getIntTest() {\n        return intTest;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "getIntTest", "params": [], "body": "                            {\n        return intTest;\n    }", "signature": "public int getIntTest()"}, {"syntax_pass": true, "original_string": "    public String getNotDate() {\n        return notDate;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getNotDate", "params": [], "body": "                               {\n        return notDate;\n    }", "signature": "public String getNotDate()"}, {"syntax_pass": true, "original_string": "    public Object getNullObjectTest() {\n        return nullObjectTest;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object", "classes": []}, "name": "getNullObjectTest", "params": [], "body": "                                      {\n        return nullObjectTest;\n    }", "signature": "public Object getNullObjectTest()"}, {"syntax_pass": true, "original_string": "    public int getNullPrimitiveTest() {\n        return nullPrimitiveTest;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "getNullPrimitiveTest", "params": [], "body": "                                      {\n        return nullPrimitiveTest;\n    }", "signature": "public int getNullPrimitiveTest()"}, {"syntax_pass": true, "original_string": "    public String getOne() {\n        return one;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getOne", "params": [], "body": "                           {\n        return one;\n    }", "signature": "public String getOne()"}, {"syntax_pass": true, "original_string": "    public Ordinal getThree() {\n        return three;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Ordinal", "classes": []}, "name": "getThree", "params": [], "body": "                              {\n        return three;\n    }", "signature": "public Ordinal getThree()"}, {"syntax_pass": true, "original_string": "    public String getTwo() {\n        return two;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getTwo", "params": [], "body": "                           {\n        return two;\n    }", "signature": "public String getTwo()"}, {"syntax_pass": true, "original_string": "    public void setColumnProcessorDoubleTest(final double d) {\n        columnProcessorDoubleTest = d;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setColumnProcessorDoubleTest", "params": [{"name": "d", "type": "double"}], "body": "                                                             {\n        columnProcessorDoubleTest = d;\n    }", "signature": "public void setColumnProcessorDoubleTest(final double d)"}, {"syntax_pass": true, "original_string": "    public void setDoNotSet(final String string) {\n        doNotSet = string;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setDoNotSet", "params": [{"name": "string", "type": "String"}], "body": "                                                 {\n        doNotSet = string;\n    }", "signature": "public void setDoNotSet(final String string)"}, {"syntax_pass": true, "original_string": "    public void setIntegerTest(final Integer integer) {\n        integerTest = integer;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setIntegerTest", "params": [{"name": "integer", "type": "Integer"}], "body": "                                                      {\n        integerTest = integer;\n    }", "signature": "public void setIntegerTest(final Integer integer)"}, {"syntax_pass": true, "original_string": "    public void setIntTest(final int i) {\n        intTest = i;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setIntTest", "params": [{"name": "i", "type": "int"}], "body": "                                        {\n        intTest = i;\n    }", "signature": "public void setIntTest(final int i)"}, {"syntax_pass": true, "original_string": "    public void setNotDate(final String string) {\n        notDate = string;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setNotDate", "params": [{"name": "string", "type": "String"}], "body": "                                                {\n        notDate = string;\n    }", "signature": "public void setNotDate(final String string)"}, {"syntax_pass": true, "original_string": "    public void setNullObjectTest(final Object object) {\n        nullObjectTest = object;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setNullObjectTest", "params": [{"name": "object", "type": "Object"}], "body": "                                                       {\n        nullObjectTest = object;\n    }", "signature": "public void setNullObjectTest(final Object object)"}, {"syntax_pass": true, "original_string": "    public void setNullPrimitiveTest(final int i) {\n        nullPrimitiveTest = i;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setNullPrimitiveTest", "params": [{"name": "i", "type": "int"}], "body": "                                                  {\n        nullPrimitiveTest = i;\n    }", "signature": "public void setNullPrimitiveTest(final int i)"}, {"syntax_pass": true, "original_string": "    public void setOne(final String string) {\n        one = string;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setOne", "params": [{"name": "string", "type": "String"}], "body": "                                            {\n        one = string;\n    }", "signature": "public void setOne(final String string)"}, {"syntax_pass": true, "original_string": "    public void setThree(final Ordinal ordinal) {\n        three = ordinal;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setThree", "params": [{"name": "ordinal", "type": "Ordinal"}], "body": "                                                {\n        three = ordinal;\n    }", "signature": "public void setThree(final Ordinal ordinal)"}, {"syntax_pass": true, "original_string": "    public void setTwo(final String string) {\n        two = string;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setTwo", "params": [{"name": "string", "type": "String"}], "body": "                                            {\n        two = string;\n    }", "signature": "public void setTwo(final String string)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/dbutils/ResultSetIterator_hasNextTest.java", "original_string": "\npackage org.apache.commons.dbutils;\n\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.mockito.Mockito;\n\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\n\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\nimport static org.mockito.Mockito.when;\n\npublic class ResultSetIterator_hasNextTest {\n\n    private ResultSet mockResultSet;\n    private ResultSetIterator resultSetIterator;\n\n    @Before\n    public void setUp() {\n        mockResultSet = Mockito.mock(ResultSet.class);\n        resultSetIterator = new ResultSetIterator(mockResultSet);\n    }\n\n    @Test\n    public void testHasNext_ReturnsTrue_WhenNotLast() throws SQLException {\n        when(mockResultSet.isLast()).thenReturn(false);\n        assertTrue(resultSetIterator.hasNext());\n    }\n\n    @Test\n    public void testHasNext_ReturnsFalse_WhenLast() throws SQLException {\n        when(mockResultSet.isLast()).thenReturn(true);\n        assertFalse(resultSetIterator.hasNext());\n    }\n\n    @Test(expected = RuntimeException.class)\n    public void testHasNext_ThrowsRuntimeException_OnSQLException() throws SQLException {\n        when(mockResultSet.isLast()).thenThrow(new SQLException(\"Mocked SQL Exception\"));\n        resultSetIterator.hasNext();\n    }\n}\n", "file_hash": "f8447fd6a4c32d6e35aaa02e672966e3c6d5e87b553e320abcce07475a82823c", "file_docstring": "", "contexts": ["package org.apache.commons.dbutils;", "import org.junit.Before;", "import org.junit.Test;", "import org.mockito.Mockito;", "import java.sql.ResultSet;", "import java.sql.SQLException;", "import static org.junit.Assert.assertFalse;", "import static org.junit.Assert.assertTrue;", "import static org.mockito.Mockito.when;"], "methods": [], "classes": [{"original_string": "public class ResultSetIterator_hasNextTest {\n\n    private ResultSet mockResultSet;\n    private ResultSetIterator resultSetIterator;\n\n    @Before\n    public void setUp() {\n        mockResultSet = Mockito.mock(ResultSet.class);\n        resultSetIterator = new ResultSetIterator(mockResultSet);\n    }\n\n    @Test\n    public void testHasNext_ReturnsTrue_WhenNotLast() throws SQLException {\n        when(mockResultSet.isLast()).thenReturn(false);\n        assertTrue(resultSetIterator.hasNext());\n    }\n\n    @Test\n    public void testHasNext_ReturnsFalse_WhenLast() throws SQLException {\n        when(mockResultSet.isLast()).thenReturn(true);\n        assertFalse(resultSetIterator.hasNext());\n    }\n\n    @Test(expected = RuntimeException.class)\n    public void testHasNext_ThrowsRuntimeException_OnSQLException() throws SQLException {\n        when(mockResultSet.isLast()).thenThrow(new SQLException(\"Mocked SQL Exception\"));\n        resultSetIterator.hasNext();\n    }\n}", "definition": "public class ResultSetIterator_hasNextTest", "class_docstring": "", "name": "ResultSetIterator_hasNextTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private ResultSet mockResultSet;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ResultSet", "name": "mockResultSet", "syntax_pass": true}, {"attribute_expression": "private ResultSetIterator resultSetIterator;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ResultSetIterator", "name": "resultSetIterator", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Before\n    public void setUp() {\n        mockResultSet = Mockito.mock(ResultSet.class);\n        resultSetIterator = new ResultSetIterator(mockResultSet);\n    }", "docstring": "", "attributes": {"modifiers": "@Before\n    public", "marker_annotations": ["@Before"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setUp", "params": [], "body": "                        {\n        mockResultSet = Mockito.mock(ResultSet.class);\n        resultSetIterator = new ResultSetIterator(mockResultSet);\n    }", "signature": "@Before\n    public void setUp()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testHasNext_ReturnsTrue_WhenNotLast() throws SQLException {\n        when(mockResultSet.isLast()).thenReturn(false);\n        assertTrue(resultSetIterator.hasNext());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testHasNext_ReturnsTrue_WhenNotLast", "params": [], "body": "                                                                          {\n        when(mockResultSet.isLast()).thenReturn(false);\n        assertTrue(resultSetIterator.hasNext());\n    }", "signature": "@Test\n    public void testHasNext_ReturnsTrue_WhenNotLast()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testHasNext_ReturnsFalse_WhenLast() throws SQLException {\n        when(mockResultSet.isLast()).thenReturn(true);\n        assertFalse(resultSetIterator.hasNext());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testHasNext_ReturnsFalse_WhenLast", "params": [], "body": "                                                                        {\n        when(mockResultSet.isLast()).thenReturn(true);\n        assertFalse(resultSetIterator.hasNext());\n    }", "signature": "@Test\n    public void testHasNext_ReturnsFalse_WhenLast()"}, {"syntax_pass": true, "original_string": "    @Test(expected = RuntimeException.class)\n    public void testHasNext_ThrowsRuntimeException_OnSQLException() throws SQLException {\n        when(mockResultSet.isLast()).thenThrow(new SQLException(\"Mocked SQL Exception\"));\n        resultSetIterator.hasNext();\n    }", "docstring": "", "attributes": {"modifiers": "@Test(expected = RuntimeException.class)\n    public", "marker_annotations": [], "non_marker_annotations": ["@Test(expected = RuntimeException.class)", "public"], "comments": [], "return_type": "void", "classes": []}, "name": "testHasNext_ThrowsRuntimeException_OnSQLException", "params": [], "body": "                                                                                        {\n        when(mockResultSet.isLast()).thenThrow(new SQLException(\"Mocked SQL Exception\"));\n        resultSetIterator.hasNext();\n    }", "signature": "@Test(expected = RuntimeException.class)\n    public void testHasNext_ThrowsRuntimeException_OnSQLException()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/dbutils/handlers/ArrayHandlerTest.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils.handlers;\n\nimport java.sql.SQLException;\n\nimport org.apache.commons.dbutils.BaseTestCase;\nimport org.apache.commons.dbutils.ResultSetHandler;\n\n/**\n * ArrayHandlerTest\n */\npublic class ArrayHandlerTest extends BaseTestCase {\n\n    public void testEmptyResultSetHandle() throws SQLException {\n        final ResultSetHandler<Object[]> h = new ArrayHandler();\n        final Object[] results = h.handle(getEmptyResultSet());\n\n        assertEquals(0, results.length);\n    }\n\n    public void testHandle() throws SQLException {\n        final ResultSetHandler<Object[]> h = new ArrayHandler();\n        final Object[] results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(COLS, results.length);\n        assertEquals(\"1\", results[0]);\n        assertEquals(\"2\", results[1]);\n        assertEquals(\"THREE\", results[2]);\n    }\n\n}\n", "file_hash": "2e2dbd71fb6c27cbcebcca543acc78467562ac40ac4be4bf0eda3af52e54dc6e", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils.handlers;", "import java.sql.SQLException;", "import org.apache.commons.dbutils.BaseTestCase;", "import org.apache.commons.dbutils.ResultSetHandler;"], "methods": [], "classes": [{"original_string": "public class ArrayHandlerTest extends BaseTestCase {\n\n    public void testEmptyResultSetHandle() throws SQLException {\n        final ResultSetHandler<Object[]> h = new ArrayHandler();\n        final Object[] results = h.handle(getEmptyResultSet());\n\n        assertEquals(0, results.length);\n    }\n\n    public void testHandle() throws SQLException {\n        final ResultSetHandler<Object[]> h = new ArrayHandler();\n        final Object[] results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(COLS, results.length);\n        assertEquals(\"1\", results[0]);\n        assertEquals(\"2\", results[1]);\n        assertEquals(\"THREE\", results[2]);\n    }\n\n}", "definition": "public class ArrayHandlerTest extends BaseTestCase", "class_docstring": "\nArrayHandlerTest\n", "name": "ArrayHandlerTest", "super_interfaces": [], "superclasses": "BaseTestCase", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public void testEmptyResultSetHandle() throws SQLException {\n        final ResultSetHandler<Object[]> h = new ArrayHandler();\n        final Object[] results = h.handle(getEmptyResultSet());\n\n        assertEquals(0, results.length);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testEmptyResultSetHandle", "params": [], "body": "                                                               {\n        final ResultSetHandler<Object[]> h = new ArrayHandler();\n        final Object[] results = h.handle(getEmptyResultSet());\n\n        assertEquals(0, results.length);\n    }", "signature": "public void testEmptyResultSetHandle()"}, {"syntax_pass": true, "original_string": "    public void testHandle() throws SQLException {\n        final ResultSetHandler<Object[]> h = new ArrayHandler();\n        final Object[] results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(COLS, results.length);\n        assertEquals(\"1\", results[0]);\n        assertEquals(\"2\", results[1]);\n        assertEquals(\"THREE\", results[2]);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testHandle", "params": [], "body": "                                                 {\n        final ResultSetHandler<Object[]> h = new ArrayHandler();\n        final Object[] results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(COLS, results.length);\n        assertEquals(\"1\", results[0]);\n        assertEquals(\"2\", results[1]);\n        assertEquals(\"THREE\", results[2]);\n    }", "signature": "public void testHandle()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/dbutils/handlers/BeanHandlerTest.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils.handlers;\n\nimport java.sql.SQLException;\n\nimport org.apache.commons.dbutils.BaseTestCase;\nimport org.apache.commons.dbutils.ResultSetHandler;\nimport org.apache.commons.dbutils.TestBean;\n\n/**\n * BeanHandlerTest\n */\npublic class BeanHandlerTest extends BaseTestCase {\n\n    public static class SubTestBean extends TestBean implements SubTestBeanInterface {\n    }\n\n    public interface SubTestBeanInterface {\n        String getDoNotSet();\n\n        String getOne();\n\n        TestBean.Ordinal getThree();\n\n        String getTwo();\n    }\n\n    public void testEmptyResultSetHandle() throws SQLException {\n        final ResultSetHandler<TestBean> h = new BeanHandler<>(TestBean.class);\n        final TestBean results = h.handle(getEmptyResultSet());\n\n        assertNull(results);\n    }\n\n    public void testHandle() throws SQLException {\n        final ResultSetHandler<TestBean> h = new BeanHandler<>(TestBean.class);\n        final TestBean results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(\"1\", results.getOne());\n        assertEquals(\"2\", results.getTwo());\n        assertEquals(TestBean.Ordinal.THREE, results.getThree());\n        assertEquals(\"not set\", results.getDoNotSet());\n    }\n\n    public void testHandleToInterface() throws SQLException {\n        final ResultSetHandler<SubTestBeanInterface> h = new BeanHandler<>(SubTestBean.class);\n        final SubTestBeanInterface results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(\"1\", results.getOne());\n        assertEquals(\"2\", results.getTwo());\n        assertEquals(TestBean.Ordinal.THREE, results.getThree());\n        assertEquals(\"not set\", results.getDoNotSet());\n    }\n\n    public void testHandleToSuperClass() throws SQLException {\n        final ResultSetHandler<TestBean> h = new BeanHandler<>(SubTestBean.class);\n        final TestBean results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(\"1\", results.getOne());\n        assertEquals(\"2\", results.getTwo());\n        assertEquals(TestBean.Ordinal.THREE, results.getThree());\n        assertEquals(\"not set\", results.getDoNotSet());\n    }\n}\n", "file_hash": "5af0a483a191714fe7b7037c38b31489741dc01fe75f607d8693a009880a981b", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils.handlers;", "import java.sql.SQLException;", "import org.apache.commons.dbutils.BaseTestCase;", "import org.apache.commons.dbutils.ResultSetHandler;", "import org.apache.commons.dbutils.TestBean;"], "methods": [], "classes": [{"original_string": "public class BeanHandlerTest extends BaseTestCase {\n\n    public static class SubTestBean extends TestBean implements SubTestBeanInterface {\n    }\n\n    public interface SubTestBeanInterface {\n        String getDoNotSet();\n\n        String getOne();\n\n        TestBean.Ordinal getThree();\n\n        String getTwo();\n    }\n\n    public void testEmptyResultSetHandle() throws SQLException {\n        final ResultSetHandler<TestBean> h = new BeanHandler<>(TestBean.class);\n        final TestBean results = h.handle(getEmptyResultSet());\n\n        assertNull(results);\n    }\n\n    public void testHandle() throws SQLException {\n        final ResultSetHandler<TestBean> h = new BeanHandler<>(TestBean.class);\n        final TestBean results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(\"1\", results.getOne());\n        assertEquals(\"2\", results.getTwo());\n        assertEquals(TestBean.Ordinal.THREE, results.getThree());\n        assertEquals(\"not set\", results.getDoNotSet());\n    }\n\n    public void testHandleToInterface() throws SQLException {\n        final ResultSetHandler<SubTestBeanInterface> h = new BeanHandler<>(SubTestBean.class);\n        final SubTestBeanInterface results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(\"1\", results.getOne());\n        assertEquals(\"2\", results.getTwo());\n        assertEquals(TestBean.Ordinal.THREE, results.getThree());\n        assertEquals(\"not set\", results.getDoNotSet());\n    }\n\n    public void testHandleToSuperClass() throws SQLException {\n        final ResultSetHandler<TestBean> h = new BeanHandler<>(SubTestBean.class);\n        final TestBean results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(\"1\", results.getOne());\n        assertEquals(\"2\", results.getTwo());\n        assertEquals(TestBean.Ordinal.THREE, results.getThree());\n        assertEquals(\"not set\", results.getDoNotSet());\n    }\n}", "definition": "public class BeanHandlerTest extends BaseTestCase", "class_docstring": "\nBeanHandlerTest\n", "name": "BeanHandlerTest", "super_interfaces": [], "superclasses": "BaseTestCase", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": [{"original_string": "    public static class SubTestBean extends TestBean implements SubTestBeanInterface {\n    }", "definition": "    public static class SubTestBean extends TestBean implements SubTestBeanInterface", "class_docstring": "", "name": "SubTestBean", "super_interfaces": ["SubTestBeanInterface"], "superclasses": "TestBean", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": []}]}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public void testEmptyResultSetHandle() throws SQLException {\n        final ResultSetHandler<TestBean> h = new BeanHandler<>(TestBean.class);\n        final TestBean results = h.handle(getEmptyResultSet());\n\n        assertNull(results);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testEmptyResultSetHandle", "params": [], "body": "                                                               {\n        final ResultSetHandler<TestBean> h = new BeanHandler<>(TestBean.class);\n        final TestBean results = h.handle(getEmptyResultSet());\n\n        assertNull(results);\n    }", "signature": "public void testEmptyResultSetHandle()"}, {"syntax_pass": true, "original_string": "    public void testHandle() throws SQLException {\n        final ResultSetHandler<TestBean> h = new BeanHandler<>(TestBean.class);\n        final TestBean results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(\"1\", results.getOne());\n        assertEquals(\"2\", results.getTwo());\n        assertEquals(TestBean.Ordinal.THREE, results.getThree());\n        assertEquals(\"not set\", results.getDoNotSet());\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testHandle", "params": [], "body": "                                                 {\n        final ResultSetHandler<TestBean> h = new BeanHandler<>(TestBean.class);\n        final TestBean results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(\"1\", results.getOne());\n        assertEquals(\"2\", results.getTwo());\n        assertEquals(TestBean.Ordinal.THREE, results.getThree());\n        assertEquals(\"not set\", results.getDoNotSet());\n    }", "signature": "public void testHandle()"}, {"syntax_pass": true, "original_string": "    public void testHandleToInterface() throws SQLException {\n        final ResultSetHandler<SubTestBeanInterface> h = new BeanHandler<>(SubTestBean.class);\n        final SubTestBeanInterface results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(\"1\", results.getOne());\n        assertEquals(\"2\", results.getTwo());\n        assertEquals(TestBean.Ordinal.THREE, results.getThree());\n        assertEquals(\"not set\", results.getDoNotSet());\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testHandleToInterface", "params": [], "body": "                                                            {\n        final ResultSetHandler<SubTestBeanInterface> h = new BeanHandler<>(SubTestBean.class);\n        final SubTestBeanInterface results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(\"1\", results.getOne());\n        assertEquals(\"2\", results.getTwo());\n        assertEquals(TestBean.Ordinal.THREE, results.getThree());\n        assertEquals(\"not set\", results.getDoNotSet());\n    }", "signature": "public void testHandleToInterface()"}, {"syntax_pass": true, "original_string": "    public void testHandleToSuperClass() throws SQLException {\n        final ResultSetHandler<TestBean> h = new BeanHandler<>(SubTestBean.class);\n        final TestBean results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(\"1\", results.getOne());\n        assertEquals(\"2\", results.getTwo());\n        assertEquals(TestBean.Ordinal.THREE, results.getThree());\n        assertEquals(\"not set\", results.getDoNotSet());\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testHandleToSuperClass", "params": [], "body": "                                                             {\n        final ResultSetHandler<TestBean> h = new BeanHandler<>(SubTestBean.class);\n        final TestBean results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(\"1\", results.getOne());\n        assertEquals(\"2\", results.getTwo());\n        assertEquals(TestBean.Ordinal.THREE, results.getThree());\n        assertEquals(\"not set\", results.getDoNotSet());\n    }", "signature": "public void testHandleToSuperClass()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/dbutils/handlers/MapHandlerTest.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils.handlers;\n\nimport java.sql.SQLException;\nimport java.util.Map;\n\nimport org.apache.commons.dbutils.BaseTestCase;\nimport org.apache.commons.dbutils.ResultSetHandler;\n\n/**\n * MapHandlerTest\n */\npublic class MapHandlerTest extends BaseTestCase {\n\n    public void testEmptyResultSetHandle() throws SQLException {\n        final ResultSetHandler<Map<String, Object>> h = new MapHandler();\n        final Map<String, Object> results = h.handle(getEmptyResultSet());\n\n        assertNull(results);\n    }\n\n    public void testHandle() throws SQLException {\n        final ResultSetHandler<Map<String, Object>> h = new MapHandler();\n        final Map<String, Object> results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(COLS, results.size());\n        assertEquals(\"1\", results.get(\"ONE\"));\n        assertEquals(\"2\", results.get(\"two\"));\n        assertEquals(\"THREE\", results.get(\"Three\"));\n    }\n\n}\n", "file_hash": "2a85ee7eae2556d62a780aa378f7ee8d0f98c9f7d6307ad170352faedcb495f0", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils.handlers;", "import java.sql.SQLException;", "import java.util.Map;", "import org.apache.commons.dbutils.BaseTestCase;", "import org.apache.commons.dbutils.ResultSetHandler;"], "methods": [], "classes": [{"original_string": "public class MapHandlerTest extends BaseTestCase {\n\n    public void testEmptyResultSetHandle() throws SQLException {\n        final ResultSetHandler<Map<String, Object>> h = new MapHandler();\n        final Map<String, Object> results = h.handle(getEmptyResultSet());\n\n        assertNull(results);\n    }\n\n    public void testHandle() throws SQLException {\n        final ResultSetHandler<Map<String, Object>> h = new MapHandler();\n        final Map<String, Object> results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(COLS, results.size());\n        assertEquals(\"1\", results.get(\"ONE\"));\n        assertEquals(\"2\", results.get(\"two\"));\n        assertEquals(\"THREE\", results.get(\"Three\"));\n    }\n\n}", "definition": "public class MapHandlerTest extends BaseTestCase", "class_docstring": "\nMapHandlerTest\n", "name": "MapHandlerTest", "super_interfaces": [], "superclasses": "BaseTestCase", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public void testEmptyResultSetHandle() throws SQLException {\n        final ResultSetHandler<Map<String, Object>> h = new MapHandler();\n        final Map<String, Object> results = h.handle(getEmptyResultSet());\n\n        assertNull(results);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testEmptyResultSetHandle", "params": [], "body": "                                                               {\n        final ResultSetHandler<Map<String, Object>> h = new MapHandler();\n        final Map<String, Object> results = h.handle(getEmptyResultSet());\n\n        assertNull(results);\n    }", "signature": "public void testEmptyResultSetHandle()"}, {"syntax_pass": true, "original_string": "    public void testHandle() throws SQLException {\n        final ResultSetHandler<Map<String, Object>> h = new MapHandler();\n        final Map<String, Object> results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(COLS, results.size());\n        assertEquals(\"1\", results.get(\"ONE\"));\n        assertEquals(\"2\", results.get(\"two\"));\n        assertEquals(\"THREE\", results.get(\"Three\"));\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testHandle", "params": [], "body": "                                                 {\n        final ResultSetHandler<Map<String, Object>> h = new MapHandler();\n        final Map<String, Object> results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(COLS, results.size());\n        assertEquals(\"1\", results.get(\"ONE\"));\n        assertEquals(\"2\", results.get(\"two\"));\n        assertEquals(\"THREE\", results.get(\"Three\"));\n    }", "signature": "public void testHandle()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/dbutils/handlers/BeanMapHandlerTest.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils.handlers;\n\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertNull;\nimport static org.mockito.Mockito.when;\n\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.util.Map;\n\nimport org.apache.commons.dbutils.RowProcessor;\nimport org.apache.commons.dbutils.TestBean;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.Mock;\nimport org.mockito.junit.MockitoJUnitRunner;\n\n@RunWith(MockitoJUnitRunner.class)\npublic class BeanMapHandlerTest {\n\n    private BeanMapHandler<Long, TestBean> bmh;\n    private Map<Long, TestBean> res;\n    @Mock\n    private ResultSet rs;\n    @Mock\n    private ResultSetMetaData rsmd;\n    @Mock\n    private RowProcessor rp;\n\n    private void handle() throws Exception {\n        res = bmh.handle(rs);\n        assertNotNull(res.get(Long.valueOf(23L)));\n    }\n\n    @Before\n    public void setUp() throws Exception {\n        when(Boolean.valueOf(rs.next())).thenReturn(Boolean.TRUE, Boolean.FALSE);\n        when(rs.getObject(1)).thenReturn(Long.valueOf(23L));\n        when(rs.getObject(2)).thenReturn(Long.valueOf(23L));\n        when(rs.getObject(\"id\")).thenReturn(Long.valueOf(23L));\n        when(rs.getMetaData()).thenReturn(rsmd);\n        when(rp.toBean(rs, TestBean.class)).thenReturn(new TestBean());\n    }\n\n    @Test\n    public void testBeanMapHandlerClassOfV() throws Exception {\n        bmh = new BeanMapHandler<>(TestBean.class);\n        handle();\n    }\n\n    @Test\n    public void testBeanMapHandlerClassOfVInt() throws Exception {\n        bmh = new BeanMapHandler<>(TestBean.class, 2);\n        handle();\n    }\n\n    @Test\n    public void testBeanMapHandlerClassOfVRowProcessor() throws Exception {\n        bmh = new BeanMapHandler<>(TestBean.class, rp);\n        handle();\n    }\n\n    @Test\n    public void testBeanMapHandlerClassOfVString() throws Exception {\n        bmh = new BeanMapHandler<>(TestBean.class, \"id\");\n        handle();\n    }\n\n    @Test\n    public void testEmptyResultSet() throws Exception {\n        when(Boolean.valueOf(rs.next())).thenReturn(Boolean.FALSE);\n        bmh = new BeanMapHandler<>(TestBean.class);\n        res = bmh.handle(rs);\n        assertNull(res.get(Long.valueOf(23L)));\n    }\n\n}\n", "file_hash": "fb686756be4446f6481fbb2f2ea43b27e9b4fb1af0d4d394fe916168c199b1ba", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils.handlers;", "import static org.junit.Assert.assertNotNull;", "import static org.junit.Assert.assertNull;", "import static org.mockito.Mockito.when;", "import java.sql.ResultSet;", "import java.sql.ResultSetMetaData;", "import java.util.Map;", "import org.apache.commons.dbutils.RowProcessor;", "import org.apache.commons.dbutils.TestBean;", "import org.junit.Before;", "import org.junit.Test;", "import org.junit.runner.RunWith;", "import org.mockito.Mock;", "import org.mockito.junit.MockitoJUnitRunner;"], "methods": [], "classes": [{"original_string": "@RunWith(MockitoJUnitRunner.class)\npublic class BeanMapHandlerTest {\n\n    private BeanMapHandler<Long, TestBean> bmh;\n    private Map<Long, TestBean> res;\n    @Mock\n    private ResultSet rs;\n    @Mock\n    private ResultSetMetaData rsmd;\n    @Mock\n    private RowProcessor rp;\n\n    private void handle() throws Exception {\n        res = bmh.handle(rs);\n        assertNotNull(res.get(Long.valueOf(23L)));\n    }\n\n    @Before\n    public void setUp() throws Exception {\n        when(Boolean.valueOf(rs.next())).thenReturn(Boolean.TRUE, Boolean.FALSE);\n        when(rs.getObject(1)).thenReturn(Long.valueOf(23L));\n        when(rs.getObject(2)).thenReturn(Long.valueOf(23L));\n        when(rs.getObject(\"id\")).thenReturn(Long.valueOf(23L));\n        when(rs.getMetaData()).thenReturn(rsmd);\n        when(rp.toBean(rs, TestBean.class)).thenReturn(new TestBean());\n    }\n\n    @Test\n    public void testBeanMapHandlerClassOfV() throws Exception {\n        bmh = new BeanMapHandler<>(TestBean.class);\n        handle();\n    }\n\n    @Test\n    public void testBeanMapHandlerClassOfVInt() throws Exception {\n        bmh = new BeanMapHandler<>(TestBean.class, 2);\n        handle();\n    }\n\n    @Test\n    public void testBeanMapHandlerClassOfVRowProcessor() throws Exception {\n        bmh = new BeanMapHandler<>(TestBean.class, rp);\n        handle();\n    }\n\n    @Test\n    public void testBeanMapHandlerClassOfVString() throws Exception {\n        bmh = new BeanMapHandler<>(TestBean.class, \"id\");\n        handle();\n    }\n\n    @Test\n    public void testEmptyResultSet() throws Exception {\n        when(Boolean.valueOf(rs.next())).thenReturn(Boolean.FALSE);\n        bmh = new BeanMapHandler<>(TestBean.class);\n        res = bmh.handle(rs);\n        assertNull(res.get(Long.valueOf(23L)));\n    }\n\n}", "definition": "@RunWith(MockitoJUnitRunner.class)\npublic class BeanMapHandlerTest", "class_docstring": "", "name": "BeanMapHandlerTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "@RunWith(MockitoJUnitRunner.class)\npublic", "marker_annotations": [], "non_marker_annotations": ["@RunWith(MockitoJUnitRunner.class)", "public"], "comments": [], "fields": [{"attribute_expression": "private BeanMapHandler<Long, TestBean> bmh;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "BeanMapHandler<Long, TestBean>", "name": "bmh", "syntax_pass": true}, {"attribute_expression": "private Map<Long, TestBean> res;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Map<Long, TestBean>", "name": "res", "syntax_pass": true}, {"attribute_expression": "@Mock\n    private ResultSet rs;", "docstring": "", "modifiers": "@Mock\n    private", "marker_annotations": ["@Mock"], "non_marker_annotations": ["private"], "comments": [], "type": "ResultSet", "name": "rs", "syntax_pass": true}, {"attribute_expression": "@Mock\n    private ResultSetMetaData rsmd;", "docstring": "", "modifiers": "@Mock\n    private", "marker_annotations": ["@Mock"], "non_marker_annotations": ["private"], "comments": [], "type": "ResultSetMetaData", "name": "rsmd", "syntax_pass": true}, {"attribute_expression": "@Mock\n    private RowProcessor rp;", "docstring": "", "modifiers": "@Mock\n    private", "marker_annotations": ["@Mock"], "non_marker_annotations": ["private"], "comments": [], "type": "RowProcessor", "name": "rp", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    private void handle() throws Exception {\n        res = bmh.handle(rs);\n        assertNotNull(res.get(Long.valueOf(23L)));\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "handle", "params": [], "body": "                                           {\n        res = bmh.handle(rs);\n        assertNotNull(res.get(Long.valueOf(23L)));\n    }", "signature": "private void handle()"}, {"syntax_pass": true, "original_string": "    @Before\n    public void setUp() throws Exception {\n        when(Boolean.valueOf(rs.next())).thenReturn(Boolean.TRUE, Boolean.FALSE);\n        when(rs.getObject(1)).thenReturn(Long.valueOf(23L));\n        when(rs.getObject(2)).thenReturn(Long.valueOf(23L));\n        when(rs.getObject(\"id\")).thenReturn(Long.valueOf(23L));\n        when(rs.getMetaData()).thenReturn(rsmd);\n        when(rp.toBean(rs, TestBean.class)).thenReturn(new TestBean());\n    }", "docstring": "", "attributes": {"modifiers": "@Before\n    public", "marker_annotations": ["@Before"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setUp", "params": [], "body": "                                         {\n        when(Boolean.valueOf(rs.next())).thenReturn(Boolean.TRUE, Boolean.FALSE);\n        when(rs.getObject(1)).thenReturn(Long.valueOf(23L));\n        when(rs.getObject(2)).thenReturn(Long.valueOf(23L));\n        when(rs.getObject(\"id\")).thenReturn(Long.valueOf(23L));\n        when(rs.getMetaData()).thenReturn(rsmd);\n        when(rp.toBean(rs, TestBean.class)).thenReturn(new TestBean());\n    }", "signature": "@Before\n    public void setUp()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testBeanMapHandlerClassOfV() throws Exception {\n        bmh = new BeanMapHandler<>(TestBean.class);\n        handle();\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testBeanMapHandlerClassOfV", "params": [], "body": "                                                              {\n        bmh = new BeanMapHandler<>(TestBean.class);\n        handle();\n    }", "signature": "@Test\n    public void testBeanMapHandlerClassOfV()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testBeanMapHandlerClassOfVInt() throws Exception {\n        bmh = new BeanMapHandler<>(TestBean.class, 2);\n        handle();\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testBeanMapHandlerClassOfVInt", "params": [], "body": "                                                                 {\n        bmh = new BeanMapHandler<>(TestBean.class, 2);\n        handle();\n    }", "signature": "@Test\n    public void testBeanMapHandlerClassOfVInt()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testBeanMapHandlerClassOfVRowProcessor() throws Exception {\n        bmh = new BeanMapHandler<>(TestBean.class, rp);\n        handle();\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testBeanMapHandlerClassOfVRowProcessor", "params": [], "body": "                                                                          {\n        bmh = new BeanMapHandler<>(TestBean.class, rp);\n        handle();\n    }", "signature": "@Test\n    public void testBeanMapHandlerClassOfVRowProcessor()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testBeanMapHandlerClassOfVString() throws Exception {\n        bmh = new BeanMapHandler<>(TestBean.class, \"id\");\n        handle();\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testBeanMapHandlerClassOfVString", "params": [], "body": "                                                                    {\n        bmh = new BeanMapHandler<>(TestBean.class, \"id\");\n        handle();\n    }", "signature": "@Test\n    public void testBeanMapHandlerClassOfVString()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testEmptyResultSet() throws Exception {\n        when(Boolean.valueOf(rs.next())).thenReturn(Boolean.FALSE);\n        bmh = new BeanMapHandler<>(TestBean.class);\n        res = bmh.handle(rs);\n        assertNull(res.get(Long.valueOf(23L)));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testEmptyResultSet", "params": [], "body": "                                                      {\n        when(Boolean.valueOf(rs.next())).thenReturn(Boolean.FALSE);\n        bmh = new BeanMapHandler<>(TestBean.class);\n        res = bmh.handle(rs);\n        assertNull(res.get(Long.valueOf(23L)));\n    }", "signature": "@Test\n    public void testEmptyResultSet()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/dbutils/handlers/KeyedHandlerTest.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils.handlers;\n\nimport static org.mockito.Mockito.mock;\n\nimport java.sql.SQLException;\nimport java.util.Map;\nimport java.util.Map.Entry;\n\nimport org.apache.commons.dbutils.BaseTestCase;\nimport org.apache.commons.dbutils.ResultSetHandler;\nimport org.apache.commons.dbutils.RowProcessor;\n\npublic class KeyedHandlerTest extends BaseTestCase {\n\n    public void testColumnIndexHandle() throws SQLException {\n        final ResultSetHandler<Map<String, Map<String, Object>>> h = new KeyedHandler<>(2);\n        final Map<String, Map<String, Object>> results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(ROWS, results.size());\n\n        Map<String, Object> row = null;\n        for (final Entry<String, Map<String, Object>> entry : results.entrySet()) {\n            final Object key = entry.getKey();\n            assertNotNull(key);\n            row = entry.getValue();\n            assertNotNull(row);\n            assertEquals(COLS, row.size());\n        }\n        row = results.get(\"5\");\n        assertEquals(\"4\", row.get(\"one\"));\n        assertEquals(\"5\", row.get(\"TWO\"));\n        assertEquals(\"SIX\", row.get(\"Three\"));\n    }\n\n    public void testColumnNameHandle() throws SQLException {\n        final ResultSetHandler<Map<Integer, Map<String, Object>>> h = new KeyedHandler<>(\"intTest\");\n        final Map<Integer, Map<String, Object>> results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(ROWS, results.size());\n\n        Map<String, Object> row = null;\n        for (final Entry<Integer, Map<String, Object>> entry : results.entrySet()) {\n            final Object key = entry.getKey();\n            assertNotNull(key);\n            row = entry.getValue();\n            assertNotNull(row);\n            assertEquals(COLS, row.size());\n        }\n        row = results.get(Integer.valueOf(3));\n        assertEquals(\"4\", row.get(\"one\"));\n        assertEquals(\"5\", row.get(\"TWO\"));\n        assertEquals(\"SIX\", row.get(\"Three\"));\n    }\n\n    public void testEmptyResultSetHandle() throws SQLException {\n        final ResultSetHandler<Map<String, Map<String, Object>>> h = new KeyedHandler<>();\n        final Map<String, Map<String, Object>> results = h.handle(getEmptyResultSet());\n        assertNotNull(results);\n        assertTrue(results.isEmpty());\n    }\n\n    public void testHandle() throws SQLException {\n        final ResultSetHandler<Map<String, Map<String, Object>>> h = new KeyedHandler<>();\n\n        final Map<String, Map<String, Object>> results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(ROWS, results.size());\n\n        Map<String, Object> row = null;\n        for (final Entry<String, Map<String, Object>> entry : results.entrySet()) {\n            final Object key = entry.getKey();\n            assertNotNull(key);\n            row = entry.getValue();\n            assertNotNull(row);\n            assertEquals(COLS, row.size());\n        }\n        row = results.get(\"1\");\n        assertEquals(\"1\", row.get(\"one\"));\n        assertEquals(\"2\", row.get(\"TWO\"));\n        assertEquals(\"THREE\", row.get(\"Three\"));\n    }\n\n    public void testInjectedRowProcess() throws Exception {\n        final RowProcessor mockProc = mock(RowProcessor.class);\n        final ResultSetHandler<Map<String, Map<String, Object>>> h = new KeyedHandler<>(mockProc);\n        final Map<String, Map<String, Object>> results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(ROWS, results.size());\n\n        Map<String, Object> row = null;\n        for (final Entry<String, Map<String, Object>> entry : results.entrySet()) {\n            row = entry.getValue();\n            assertNotNull(row);\n            assertTrue(row.isEmpty());\n            assertEquals(0, row.size());\n        }\n    }\n}\n", "file_hash": "e0ebc957336a8681166e21675606a9eaf8cfcfc5b88cde7d14afdc3bf84e1800", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils.handlers;", "import static org.mockito.Mockito.mock;", "import java.sql.SQLException;", "import java.util.Map;", "import java.util.Map.Entry;", "import org.apache.commons.dbutils.BaseTestCase;", "import org.apache.commons.dbutils.ResultSetHandler;", "import org.apache.commons.dbutils.RowProcessor;"], "methods": [], "classes": [{"original_string": "public class KeyedHandlerTest extends BaseTestCase {\n\n    public void testColumnIndexHandle() throws SQLException {\n        final ResultSetHandler<Map<String, Map<String, Object>>> h = new KeyedHandler<>(2);\n        final Map<String, Map<String, Object>> results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(ROWS, results.size());\n\n        Map<String, Object> row = null;\n        for (final Entry<String, Map<String, Object>> entry : results.entrySet()) {\n            final Object key = entry.getKey();\n            assertNotNull(key);\n            row = entry.getValue();\n            assertNotNull(row);\n            assertEquals(COLS, row.size());\n        }\n        row = results.get(\"5\");\n        assertEquals(\"4\", row.get(\"one\"));\n        assertEquals(\"5\", row.get(\"TWO\"));\n        assertEquals(\"SIX\", row.get(\"Three\"));\n    }\n\n    public void testColumnNameHandle() throws SQLException {\n        final ResultSetHandler<Map<Integer, Map<String, Object>>> h = new KeyedHandler<>(\"intTest\");\n        final Map<Integer, Map<String, Object>> results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(ROWS, results.size());\n\n        Map<String, Object> row = null;\n        for (final Entry<Integer, Map<String, Object>> entry : results.entrySet()) {\n            final Object key = entry.getKey();\n            assertNotNull(key);\n            row = entry.getValue();\n            assertNotNull(row);\n            assertEquals(COLS, row.size());\n        }\n        row = results.get(Integer.valueOf(3));\n        assertEquals(\"4\", row.get(\"one\"));\n        assertEquals(\"5\", row.get(\"TWO\"));\n        assertEquals(\"SIX\", row.get(\"Three\"));\n    }\n\n    public void testEmptyResultSetHandle() throws SQLException {\n        final ResultSetHandler<Map<String, Map<String, Object>>> h = new KeyedHandler<>();\n        final Map<String, Map<String, Object>> results = h.handle(getEmptyResultSet());\n        assertNotNull(results);\n        assertTrue(results.isEmpty());\n    }\n\n    public void testHandle() throws SQLException {\n        final ResultSetHandler<Map<String, Map<String, Object>>> h = new KeyedHandler<>();\n\n        final Map<String, Map<String, Object>> results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(ROWS, results.size());\n\n        Map<String, Object> row = null;\n        for (final Entry<String, Map<String, Object>> entry : results.entrySet()) {\n            final Object key = entry.getKey();\n            assertNotNull(key);\n            row = entry.getValue();\n            assertNotNull(row);\n            assertEquals(COLS, row.size());\n        }\n        row = results.get(\"1\");\n        assertEquals(\"1\", row.get(\"one\"));\n        assertEquals(\"2\", row.get(\"TWO\"));\n        assertEquals(\"THREE\", row.get(\"Three\"));\n    }\n\n    public void testInjectedRowProcess() throws Exception {\n        final RowProcessor mockProc = mock(RowProcessor.class);\n        final ResultSetHandler<Map<String, Map<String, Object>>> h = new KeyedHandler<>(mockProc);\n        final Map<String, Map<String, Object>> results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(ROWS, results.size());\n\n        Map<String, Object> row = null;\n        for (final Entry<String, Map<String, Object>> entry : results.entrySet()) {\n            row = entry.getValue();\n            assertNotNull(row);\n            assertTrue(row.isEmpty());\n            assertEquals(0, row.size());\n        }\n    }\n}", "definition": "public class KeyedHandlerTest extends BaseTestCase", "class_docstring": "", "name": "KeyedHandlerTest", "super_interfaces": [], "superclasses": "BaseTestCase", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public void testColumnIndexHandle() throws SQLException {\n        final ResultSetHandler<Map<String, Map<String, Object>>> h = new KeyedHandler<>(2);\n        final Map<String, Map<String, Object>> results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(ROWS, results.size());\n\n        Map<String, Object> row = null;\n        for (final Entry<String, Map<String, Object>> entry : results.entrySet()) {\n            final Object key = entry.getKey();\n            assertNotNull(key);\n            row = entry.getValue();\n            assertNotNull(row);\n            assertEquals(COLS, row.size());\n        }\n        row = results.get(\"5\");\n        assertEquals(\"4\", row.get(\"one\"));\n        assertEquals(\"5\", row.get(\"TWO\"));\n        assertEquals(\"SIX\", row.get(\"Three\"));\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testColumnIndexHandle", "params": [], "body": "                                                            {\n        final ResultSetHandler<Map<String, Map<String, Object>>> h = new KeyedHandler<>(2);\n        final Map<String, Map<String, Object>> results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(ROWS, results.size());\n\n        Map<String, Object> row = null;\n        for (final Entry<String, Map<String, Object>> entry : results.entrySet()) {\n            final Object key = entry.getKey();\n            assertNotNull(key);\n            row = entry.getValue();\n            assertNotNull(row);\n            assertEquals(COLS, row.size());\n        }\n        row = results.get(\"5\");\n        assertEquals(\"4\", row.get(\"one\"));\n        assertEquals(\"5\", row.get(\"TWO\"));\n        assertEquals(\"SIX\", row.get(\"Three\"));\n    }", "signature": "public void testColumnIndexHandle()"}, {"syntax_pass": true, "original_string": "    public void testColumnNameHandle() throws SQLException {\n        final ResultSetHandler<Map<Integer, Map<String, Object>>> h = new KeyedHandler<>(\"intTest\");\n        final Map<Integer, Map<String, Object>> results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(ROWS, results.size());\n\n        Map<String, Object> row = null;\n        for (final Entry<Integer, Map<String, Object>> entry : results.entrySet()) {\n            final Object key = entry.getKey();\n            assertNotNull(key);\n            row = entry.getValue();\n            assertNotNull(row);\n            assertEquals(COLS, row.size());\n        }\n        row = results.get(Integer.valueOf(3));\n        assertEquals(\"4\", row.get(\"one\"));\n        assertEquals(\"5\", row.get(\"TWO\"));\n        assertEquals(\"SIX\", row.get(\"Three\"));\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testColumnNameHandle", "params": [], "body": "                                                           {\n        final ResultSetHandler<Map<Integer, Map<String, Object>>> h = new KeyedHandler<>(\"intTest\");\n        final Map<Integer, Map<String, Object>> results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(ROWS, results.size());\n\n        Map<String, Object> row = null;\n        for (final Entry<Integer, Map<String, Object>> entry : results.entrySet()) {\n            final Object key = entry.getKey();\n            assertNotNull(key);\n            row = entry.getValue();\n            assertNotNull(row);\n            assertEquals(COLS, row.size());\n        }\n        row = results.get(Integer.valueOf(3));\n        assertEquals(\"4\", row.get(\"one\"));\n        assertEquals(\"5\", row.get(\"TWO\"));\n        assertEquals(\"SIX\", row.get(\"Three\"));\n    }", "signature": "public void testColumnNameHandle()"}, {"syntax_pass": true, "original_string": "    public void testEmptyResultSetHandle() throws SQLException {\n        final ResultSetHandler<Map<String, Map<String, Object>>> h = new KeyedHandler<>();\n        final Map<String, Map<String, Object>> results = h.handle(getEmptyResultSet());\n        assertNotNull(results);\n        assertTrue(results.isEmpty());\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testEmptyResultSetHandle", "params": [], "body": "                                                               {\n        final ResultSetHandler<Map<String, Map<String, Object>>> h = new KeyedHandler<>();\n        final Map<String, Map<String, Object>> results = h.handle(getEmptyResultSet());\n        assertNotNull(results);\n        assertTrue(results.isEmpty());\n    }", "signature": "public void testEmptyResultSetHandle()"}, {"syntax_pass": true, "original_string": "    public void testHandle() throws SQLException {\n        final ResultSetHandler<Map<String, Map<String, Object>>> h = new KeyedHandler<>();\n\n        final Map<String, Map<String, Object>> results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(ROWS, results.size());\n\n        Map<String, Object> row = null;\n        for (final Entry<String, Map<String, Object>> entry : results.entrySet()) {\n            final Object key = entry.getKey();\n            assertNotNull(key);\n            row = entry.getValue();\n            assertNotNull(row);\n            assertEquals(COLS, row.size());\n        }\n        row = results.get(\"1\");\n        assertEquals(\"1\", row.get(\"one\"));\n        assertEquals(\"2\", row.get(\"TWO\"));\n        assertEquals(\"THREE\", row.get(\"Three\"));\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testHandle", "params": [], "body": "                                                 {\n        final ResultSetHandler<Map<String, Map<String, Object>>> h = new KeyedHandler<>();\n\n        final Map<String, Map<String, Object>> results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(ROWS, results.size());\n\n        Map<String, Object> row = null;\n        for (final Entry<String, Map<String, Object>> entry : results.entrySet()) {\n            final Object key = entry.getKey();\n            assertNotNull(key);\n            row = entry.getValue();\n            assertNotNull(row);\n            assertEquals(COLS, row.size());\n        }\n        row = results.get(\"1\");\n        assertEquals(\"1\", row.get(\"one\"));\n        assertEquals(\"2\", row.get(\"TWO\"));\n        assertEquals(\"THREE\", row.get(\"Three\"));\n    }", "signature": "public void testHandle()"}, {"syntax_pass": true, "original_string": "    public void testInjectedRowProcess() throws Exception {\n        final RowProcessor mockProc = mock(RowProcessor.class);\n        final ResultSetHandler<Map<String, Map<String, Object>>> h = new KeyedHandler<>(mockProc);\n        final Map<String, Map<String, Object>> results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(ROWS, results.size());\n\n        Map<String, Object> row = null;\n        for (final Entry<String, Map<String, Object>> entry : results.entrySet()) {\n            row = entry.getValue();\n            assertNotNull(row);\n            assertTrue(row.isEmpty());\n            assertEquals(0, row.size());\n        }\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testInjectedRowProcess", "params": [], "body": "                                                          {\n        final RowProcessor mockProc = mock(RowProcessor.class);\n        final ResultSetHandler<Map<String, Map<String, Object>>> h = new KeyedHandler<>(mockProc);\n        final Map<String, Map<String, Object>> results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(ROWS, results.size());\n\n        Map<String, Object> row = null;\n        for (final Entry<String, Map<String, Object>> entry : results.entrySet()) {\n            row = entry.getValue();\n            assertNotNull(row);\n            assertTrue(row.isEmpty());\n            assertEquals(0, row.size());\n        }\n    }", "signature": "public void testInjectedRowProcess()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/dbutils/handlers/ArrayListHandlerTest.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils.handlers;\n\nimport java.sql.SQLException;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport org.apache.commons.dbutils.BaseTestCase;\nimport org.apache.commons.dbutils.ResultSetHandler;\n\n/**\n * ArrayListHandlerTest\n */\npublic class ArrayListHandlerTest extends BaseTestCase {\n\n    public void testEmptyResultSetHandle() throws SQLException {\n        final ResultSetHandler<List<Object[]>> h = new ArrayListHandler();\n        final List<Object[]> results = h.handle(getEmptyResultSet());\n\n        assertNotNull(results);\n        assertTrue(results.isEmpty());\n    }\n\n    public void testHandle() throws SQLException {\n        final ResultSetHandler<List<Object[]>> h = new ArrayListHandler();\n        final List<Object[]> results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(ROWS, results.size());\n\n        final Iterator<Object[]> iter = results.iterator();\n        assertTrue(iter.hasNext());\n        Object[] row = iter.next();\n        assertEquals(COLS, row.length);\n        assertEquals(\"1\", row[0]);\n        assertEquals(\"2\", row[1]);\n        assertEquals(\"THREE\", row[2]);\n\n        assertTrue(iter.hasNext());\n        row = iter.next();\n        assertEquals(COLS, row.length);\n\n        assertEquals(\"4\", row[0]);\n        assertEquals(\"5\", row[1]);\n        assertEquals(\"SIX\", row[2]);\n\n        assertFalse(iter.hasNext());\n    }\n\n}\n", "file_hash": "85e325ea9b1db99d721cb415dfc8cdd33cccca3e77475bd561dfda8cc607b0ed", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils.handlers;", "import java.sql.SQLException;", "import java.util.Iterator;", "import java.util.List;", "import org.apache.commons.dbutils.BaseTestCase;", "import org.apache.commons.dbutils.ResultSetHandler;"], "methods": [], "classes": [{"original_string": "public class ArrayListHandlerTest extends BaseTestCase {\n\n    public void testEmptyResultSetHandle() throws SQLException {\n        final ResultSetHandler<List<Object[]>> h = new ArrayListHandler();\n        final List<Object[]> results = h.handle(getEmptyResultSet());\n\n        assertNotNull(results);\n        assertTrue(results.isEmpty());\n    }\n\n    public void testHandle() throws SQLException {\n        final ResultSetHandler<List<Object[]>> h = new ArrayListHandler();\n        final List<Object[]> results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(ROWS, results.size());\n\n        final Iterator<Object[]> iter = results.iterator();\n        assertTrue(iter.hasNext());\n        Object[] row = iter.next();\n        assertEquals(COLS, row.length);\n        assertEquals(\"1\", row[0]);\n        assertEquals(\"2\", row[1]);\n        assertEquals(\"THREE\", row[2]);\n\n        assertTrue(iter.hasNext());\n        row = iter.next();\n        assertEquals(COLS, row.length);\n\n        assertEquals(\"4\", row[0]);\n        assertEquals(\"5\", row[1]);\n        assertEquals(\"SIX\", row[2]);\n\n        assertFalse(iter.hasNext());\n    }\n\n}", "definition": "public class ArrayListHandlerTest extends BaseTestCase", "class_docstring": "\nArrayListHandlerTest\n", "name": "ArrayListHandlerTest", "super_interfaces": [], "superclasses": "BaseTestCase", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public void testEmptyResultSetHandle() throws SQLException {\n        final ResultSetHandler<List<Object[]>> h = new ArrayListHandler();\n        final List<Object[]> results = h.handle(getEmptyResultSet());\n\n        assertNotNull(results);\n        assertTrue(results.isEmpty());\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testEmptyResultSetHandle", "params": [], "body": "                                                               {\n        final ResultSetHandler<List<Object[]>> h = new ArrayListHandler();\n        final List<Object[]> results = h.handle(getEmptyResultSet());\n\n        assertNotNull(results);\n        assertTrue(results.isEmpty());\n    }", "signature": "public void testEmptyResultSetHandle()"}, {"syntax_pass": true, "original_string": "    public void testHandle() throws SQLException {\n        final ResultSetHandler<List<Object[]>> h = new ArrayListHandler();\n        final List<Object[]> results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(ROWS, results.size());\n\n        final Iterator<Object[]> iter = results.iterator();\n        assertTrue(iter.hasNext());\n        Object[] row = iter.next();\n        assertEquals(COLS, row.length);\n        assertEquals(\"1\", row[0]);\n        assertEquals(\"2\", row[1]);\n        assertEquals(\"THREE\", row[2]);\n\n        assertTrue(iter.hasNext());\n        row = iter.next();\n        assertEquals(COLS, row.length);\n\n        assertEquals(\"4\", row[0]);\n        assertEquals(\"5\", row[1]);\n        assertEquals(\"SIX\", row[2]);\n\n        assertFalse(iter.hasNext());\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testHandle", "params": [], "body": "                                                 {\n        final ResultSetHandler<List<Object[]>> h = new ArrayListHandler();\n        final List<Object[]> results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(ROWS, results.size());\n\n        final Iterator<Object[]> iter = results.iterator();\n        assertTrue(iter.hasNext());\n        Object[] row = iter.next();\n        assertEquals(COLS, row.length);\n        assertEquals(\"1\", row[0]);\n        assertEquals(\"2\", row[1]);\n        assertEquals(\"THREE\", row[2]);\n\n        assertTrue(iter.hasNext());\n        row = iter.next();\n        assertEquals(COLS, row.length);\n\n        assertEquals(\"4\", row[0]);\n        assertEquals(\"5\", row[1]);\n        assertEquals(\"SIX\", row[2]);\n\n        assertFalse(iter.hasNext());\n    }", "signature": "public void testHandle()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/dbutils/handlers/ColumnListHandlerTest.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils.handlers;\n\nimport java.sql.SQLException;\nimport java.util.List;\n\nimport org.apache.commons.dbutils.BaseTestCase;\nimport org.apache.commons.dbutils.ResultSetHandler;\n\n/**\n * ColumnListHandlerTest\n */\npublic class ColumnListHandlerTest extends BaseTestCase {\n\n    public void testColumnIndexHandle() throws SQLException {\n        final ResultSetHandler<List<String>> h = new ColumnListHandler<>(2);\n        final List<String> results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(ROWS, results.size());\n\n        assertEquals(\"2\", results.get(0));\n        assertEquals(\"5\", results.get(1));\n    }\n\n    public void testColumnNameHandle() throws SQLException {\n        final ResultSetHandler<List<Integer>> h = new ColumnListHandler<>(\"intTest\");\n        final List<Integer> results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(ROWS, results.size());\n\n        assertEquals(Integer.valueOf(1), results.get(0));\n        assertEquals(Integer.valueOf(3), results.get(1));\n    }\n\n    public void testEmptyResultSetHandle() throws SQLException {\n        final ResultSetHandler<List<String>> h = new ColumnListHandler<>();\n        final List<String> results = h.handle(getEmptyResultSet());\n\n        assertNotNull(results);\n        assertTrue(results.isEmpty());\n    }\n\n    public void testHandle() throws SQLException {\n        final ResultSetHandler<List<String>> h = new ColumnListHandler<>();\n        final List<String> results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(ROWS, results.size());\n\n        assertEquals(\"1\", results.get(0));\n        assertEquals(\"4\", results.get(1));\n    }\n\n}\n", "file_hash": "82041f2e283dbb2668ab80a04f623585041cbec8ca6d4831443219866f2f203d", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils.handlers;", "import java.sql.SQLException;", "import java.util.List;", "import org.apache.commons.dbutils.BaseTestCase;", "import org.apache.commons.dbutils.ResultSetHandler;"], "methods": [], "classes": [{"original_string": "public class ColumnListHandlerTest extends BaseTestCase {\n\n    public void testColumnIndexHandle() throws SQLException {\n        final ResultSetHandler<List<String>> h = new ColumnListHandler<>(2);\n        final List<String> results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(ROWS, results.size());\n\n        assertEquals(\"2\", results.get(0));\n        assertEquals(\"5\", results.get(1));\n    }\n\n    public void testColumnNameHandle() throws SQLException {\n        final ResultSetHandler<List<Integer>> h = new ColumnListHandler<>(\"intTest\");\n        final List<Integer> results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(ROWS, results.size());\n\n        assertEquals(Integer.valueOf(1), results.get(0));\n        assertEquals(Integer.valueOf(3), results.get(1));\n    }\n\n    public void testEmptyResultSetHandle() throws SQLException {\n        final ResultSetHandler<List<String>> h = new ColumnListHandler<>();\n        final List<String> results = h.handle(getEmptyResultSet());\n\n        assertNotNull(results);\n        assertTrue(results.isEmpty());\n    }\n\n    public void testHandle() throws SQLException {\n        final ResultSetHandler<List<String>> h = new ColumnListHandler<>();\n        final List<String> results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(ROWS, results.size());\n\n        assertEquals(\"1\", results.get(0));\n        assertEquals(\"4\", results.get(1));\n    }\n\n}", "definition": "public class ColumnListHandlerTest extends BaseTestCase", "class_docstring": "\nColumnListHandlerTest\n", "name": "ColumnListHandlerTest", "super_interfaces": [], "superclasses": "BaseTestCase", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public void testColumnIndexHandle() throws SQLException {\n        final ResultSetHandler<List<String>> h = new ColumnListHandler<>(2);\n        final List<String> results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(ROWS, results.size());\n\n        assertEquals(\"2\", results.get(0));\n        assertEquals(\"5\", results.get(1));\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testColumnIndexHandle", "params": [], "body": "                                                            {\n        final ResultSetHandler<List<String>> h = new ColumnListHandler<>(2);\n        final List<String> results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(ROWS, results.size());\n\n        assertEquals(\"2\", results.get(0));\n        assertEquals(\"5\", results.get(1));\n    }", "signature": "public void testColumnIndexHandle()"}, {"syntax_pass": true, "original_string": "    public void testColumnNameHandle() throws SQLException {\n        final ResultSetHandler<List<Integer>> h = new ColumnListHandler<>(\"intTest\");\n        final List<Integer> results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(ROWS, results.size());\n\n        assertEquals(Integer.valueOf(1), results.get(0));\n        assertEquals(Integer.valueOf(3), results.get(1));\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testColumnNameHandle", "params": [], "body": "                                                           {\n        final ResultSetHandler<List<Integer>> h = new ColumnListHandler<>(\"intTest\");\n        final List<Integer> results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(ROWS, results.size());\n\n        assertEquals(Integer.valueOf(1), results.get(0));\n        assertEquals(Integer.valueOf(3), results.get(1));\n    }", "signature": "public void testColumnNameHandle()"}, {"syntax_pass": true, "original_string": "    public void testEmptyResultSetHandle() throws SQLException {\n        final ResultSetHandler<List<String>> h = new ColumnListHandler<>();\n        final List<String> results = h.handle(getEmptyResultSet());\n\n        assertNotNull(results);\n        assertTrue(results.isEmpty());\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testEmptyResultSetHandle", "params": [], "body": "                                                               {\n        final ResultSetHandler<List<String>> h = new ColumnListHandler<>();\n        final List<String> results = h.handle(getEmptyResultSet());\n\n        assertNotNull(results);\n        assertTrue(results.isEmpty());\n    }", "signature": "public void testEmptyResultSetHandle()"}, {"syntax_pass": true, "original_string": "    public void testHandle() throws SQLException {\n        final ResultSetHandler<List<String>> h = new ColumnListHandler<>();\n        final List<String> results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(ROWS, results.size());\n\n        assertEquals(\"1\", results.get(0));\n        assertEquals(\"4\", results.get(1));\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testHandle", "params": [], "body": "                                                 {\n        final ResultSetHandler<List<String>> h = new ColumnListHandler<>();\n        final List<String> results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(ROWS, results.size());\n\n        assertEquals(\"1\", results.get(0));\n        assertEquals(\"4\", results.get(1));\n    }", "signature": "public void testHandle()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/dbutils/handlers/ScalarHandlerTest.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils.handlers;\n\nimport java.sql.SQLException;\n\nimport org.apache.commons.dbutils.BaseTestCase;\nimport org.apache.commons.dbutils.ResultSetHandler;\n\npublic class ScalarHandlerTest extends BaseTestCase {\n\n    public void testColumnIndexHandle() throws SQLException {\n        final ResultSetHandler<String> h = new ScalarHandler<>(2);\n        final Object results = h.handle(getResultSet());\n        assertNotNull(results);\n        assertEquals(\"2\", results);\n    }\n\n    public void testColumnNameHandle() throws SQLException {\n        final ResultSetHandler<Integer> h = new ScalarHandler<>(\"intTest\");\n        final Object results = h.handle(getResultSet());\n        assertNotNull(results);\n        assertEquals(Integer.valueOf(1), results);\n    }\n\n    public void testEmptyResultSetHandle() throws SQLException {\n        final ResultSetHandler<String> h = new ScalarHandler<>();\n        final Object results = h.handle(getEmptyResultSet());\n        assertNull(results);\n    }\n\n    public void testHandle() throws SQLException {\n        final ResultSetHandler<String> h = new ScalarHandler<>();\n        final Object results = h.handle(getResultSet());\n        assertNotNull(results);\n        assertEquals(\"1\", results);\n    }\n\n}\n", "file_hash": "2a39b0ac1b9f7e45adcecad08f1595b1ee2ed3a923f0d7f2f398a90a516db64e", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils.handlers;", "import java.sql.SQLException;", "import org.apache.commons.dbutils.BaseTestCase;", "import org.apache.commons.dbutils.ResultSetHandler;"], "methods": [], "classes": [{"original_string": "public class ScalarHandlerTest extends BaseTestCase {\n\n    public void testColumnIndexHandle() throws SQLException {\n        final ResultSetHandler<String> h = new ScalarHandler<>(2);\n        final Object results = h.handle(getResultSet());\n        assertNotNull(results);\n        assertEquals(\"2\", results);\n    }\n\n    public void testColumnNameHandle() throws SQLException {\n        final ResultSetHandler<Integer> h = new ScalarHandler<>(\"intTest\");\n        final Object results = h.handle(getResultSet());\n        assertNotNull(results);\n        assertEquals(Integer.valueOf(1), results);\n    }\n\n    public void testEmptyResultSetHandle() throws SQLException {\n        final ResultSetHandler<String> h = new ScalarHandler<>();\n        final Object results = h.handle(getEmptyResultSet());\n        assertNull(results);\n    }\n\n    public void testHandle() throws SQLException {\n        final ResultSetHandler<String> h = new ScalarHandler<>();\n        final Object results = h.handle(getResultSet());\n        assertNotNull(results);\n        assertEquals(\"1\", results);\n    }\n\n}", "definition": "public class ScalarHandlerTest extends BaseTestCase", "class_docstring": "", "name": "ScalarHandlerTest", "super_interfaces": [], "superclasses": "BaseTestCase", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public void testColumnIndexHandle() throws SQLException {\n        final ResultSetHandler<String> h = new ScalarHandler<>(2);\n        final Object results = h.handle(getResultSet());\n        assertNotNull(results);\n        assertEquals(\"2\", results);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testColumnIndexHandle", "params": [], "body": "                                                            {\n        final ResultSetHandler<String> h = new ScalarHandler<>(2);\n        final Object results = h.handle(getResultSet());\n        assertNotNull(results);\n        assertEquals(\"2\", results);\n    }", "signature": "public void testColumnIndexHandle()"}, {"syntax_pass": true, "original_string": "    public void testColumnNameHandle() throws SQLException {\n        final ResultSetHandler<Integer> h = new ScalarHandler<>(\"intTest\");\n        final Object results = h.handle(getResultSet());\n        assertNotNull(results);\n        assertEquals(Integer.valueOf(1), results);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testColumnNameHandle", "params": [], "body": "                                                           {\n        final ResultSetHandler<Integer> h = new ScalarHandler<>(\"intTest\");\n        final Object results = h.handle(getResultSet());\n        assertNotNull(results);\n        assertEquals(Integer.valueOf(1), results);\n    }", "signature": "public void testColumnNameHandle()"}, {"syntax_pass": true, "original_string": "    public void testEmptyResultSetHandle() throws SQLException {\n        final ResultSetHandler<String> h = new ScalarHandler<>();\n        final Object results = h.handle(getEmptyResultSet());\n        assertNull(results);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testEmptyResultSetHandle", "params": [], "body": "                                                               {\n        final ResultSetHandler<String> h = new ScalarHandler<>();\n        final Object results = h.handle(getEmptyResultSet());\n        assertNull(results);\n    }", "signature": "public void testEmptyResultSetHandle()"}, {"syntax_pass": true, "original_string": "    public void testHandle() throws SQLException {\n        final ResultSetHandler<String> h = new ScalarHandler<>();\n        final Object results = h.handle(getResultSet());\n        assertNotNull(results);\n        assertEquals(\"1\", results);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testHandle", "params": [], "body": "                                                 {\n        final ResultSetHandler<String> h = new ScalarHandler<>();\n        final Object results = h.handle(getResultSet());\n        assertNotNull(results);\n        assertEquals(\"1\", results);\n    }", "signature": "public void testHandle()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/dbutils/handlers/BeanListHandlerTest.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils.handlers;\n\nimport java.sql.SQLException;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport org.apache.commons.dbutils.BaseTestCase;\nimport org.apache.commons.dbutils.ResultSetHandler;\nimport org.apache.commons.dbutils.TestBean;\n\n/**\n * BeanListHandlerTest\n */\npublic class BeanListHandlerTest extends BaseTestCase {\n\n    public static class SubTestBean extends TestBean implements SubTestBeanInterface {\n    }\n\n    public interface SubTestBeanInterface {\n        String getDoNotSet();\n\n        String getOne();\n\n        TestBean.Ordinal getThree();\n\n        String getTwo();\n    }\n\n    public void testEmptyResultSetHandle() throws SQLException {\n        final ResultSetHandler<List<TestBean>> h = new BeanListHandler<>(TestBean.class);\n        final List<TestBean> results = h.handle(getEmptyResultSet());\n\n        assertNotNull(results);\n        assertTrue(results.isEmpty());\n    }\n\n    public void testHandle() throws SQLException {\n        final ResultSetHandler<List<TestBean>> h = new BeanListHandler<>(TestBean.class);\n        final List<TestBean> results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(ROWS, results.size());\n\n        final Iterator<TestBean> iter = results.iterator();\n        TestBean row;\n        assertTrue(iter.hasNext());\n        row = iter.next();\n        assertEquals(\"1\", row.getOne());\n        assertEquals(\"2\", row.getTwo());\n        assertEquals(TestBean.Ordinal.THREE, row.getThree());\n        assertEquals(\"not set\", row.getDoNotSet());\n\n        assertTrue(iter.hasNext());\n        row = iter.next();\n\n        assertEquals(\"4\", row.getOne());\n        assertEquals(\"5\", row.getTwo());\n        assertEquals(TestBean.Ordinal.SIX, row.getThree());\n        assertEquals(\"not set\", row.getDoNotSet());\n\n        assertFalse(iter.hasNext());\n    }\n\n    public void testHandleToInterface() throws SQLException {\n        final ResultSetHandler<List<SubTestBeanInterface>> h = new BeanListHandler<>(SubTestBean.class);\n        final List<SubTestBeanInterface> results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(ROWS, results.size());\n\n        final Iterator<SubTestBeanInterface> iter = results.iterator();\n        SubTestBeanInterface row;\n        assertTrue(iter.hasNext());\n        row = iter.next();\n        assertSame(SubTestBean.class, row.getClass());\n\n        assertEquals(\"1\", row.getOne());\n        assertEquals(\"2\", row.getTwo());\n        assertEquals(TestBean.Ordinal.THREE, row.getThree());\n        assertEquals(\"not set\", row.getDoNotSet());\n\n        assertTrue(iter.hasNext());\n        row = iter.next();\n        assertSame(SubTestBean.class, row.getClass());\n\n        assertEquals(\"4\", row.getOne());\n        assertEquals(\"5\", row.getTwo());\n        assertEquals(TestBean.Ordinal.SIX, row.getThree());\n        assertEquals(\"not set\", row.getDoNotSet());\n\n        assertFalse(iter.hasNext());\n    }\n\n    public void testHandleToSuperClass() throws SQLException {\n        final ResultSetHandler<List<TestBean>> h = new BeanListHandler<>(SubTestBean.class);\n        final List<TestBean> results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(ROWS, results.size());\n\n        final Iterator<TestBean> iter = results.iterator();\n        assertTrue(iter.hasNext());\n        TestBean row = iter.next();\n        assertSame(SubTestBean.class, row.getClass());\n\n        assertEquals(\"1\", row.getOne());\n        assertEquals(\"2\", row.getTwo());\n        assertEquals(TestBean.Ordinal.THREE, row.getThree());\n        assertEquals(\"not set\", row.getDoNotSet());\n\n        assertTrue(iter.hasNext());\n        row = iter.next();\n        assertSame(SubTestBean.class, row.getClass());\n\n        assertEquals(\"4\", row.getOne());\n        assertEquals(\"5\", row.getTwo());\n        assertEquals(TestBean.Ordinal.SIX, row.getThree());\n        assertEquals(\"not set\", row.getDoNotSet());\n\n        assertFalse(iter.hasNext());\n    }\n}\n", "file_hash": "316283461fc8dda0a1fb964d5f73332a247b5e505d228f6d5aa210381d3ec7f6", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils.handlers;", "import java.sql.SQLException;", "import java.util.Iterator;", "import java.util.List;", "import org.apache.commons.dbutils.BaseTestCase;", "import org.apache.commons.dbutils.ResultSetHandler;", "import org.apache.commons.dbutils.TestBean;"], "methods": [], "classes": [{"original_string": "public class BeanListHandlerTest extends BaseTestCase {\n\n    public static class SubTestBean extends TestBean implements SubTestBeanInterface {\n    }\n\n    public interface SubTestBeanInterface {\n        String getDoNotSet();\n\n        String getOne();\n\n        TestBean.Ordinal getThree();\n\n        String getTwo();\n    }\n\n    public void testEmptyResultSetHandle() throws SQLException {\n        final ResultSetHandler<List<TestBean>> h = new BeanListHandler<>(TestBean.class);\n        final List<TestBean> results = h.handle(getEmptyResultSet());\n\n        assertNotNull(results);\n        assertTrue(results.isEmpty());\n    }\n\n    public void testHandle() throws SQLException {\n        final ResultSetHandler<List<TestBean>> h = new BeanListHandler<>(TestBean.class);\n        final List<TestBean> results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(ROWS, results.size());\n\n        final Iterator<TestBean> iter = results.iterator();\n        TestBean row;\n        assertTrue(iter.hasNext());\n        row = iter.next();\n        assertEquals(\"1\", row.getOne());\n        assertEquals(\"2\", row.getTwo());\n        assertEquals(TestBean.Ordinal.THREE, row.getThree());\n        assertEquals(\"not set\", row.getDoNotSet());\n\n        assertTrue(iter.hasNext());\n        row = iter.next();\n\n        assertEquals(\"4\", row.getOne());\n        assertEquals(\"5\", row.getTwo());\n        assertEquals(TestBean.Ordinal.SIX, row.getThree());\n        assertEquals(\"not set\", row.getDoNotSet());\n\n        assertFalse(iter.hasNext());\n    }\n\n    public void testHandleToInterface() throws SQLException {\n        final ResultSetHandler<List<SubTestBeanInterface>> h = new BeanListHandler<>(SubTestBean.class);\n        final List<SubTestBeanInterface> results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(ROWS, results.size());\n\n        final Iterator<SubTestBeanInterface> iter = results.iterator();\n        SubTestBeanInterface row;\n        assertTrue(iter.hasNext());\n        row = iter.next();\n        assertSame(SubTestBean.class, row.getClass());\n\n        assertEquals(\"1\", row.getOne());\n        assertEquals(\"2\", row.getTwo());\n        assertEquals(TestBean.Ordinal.THREE, row.getThree());\n        assertEquals(\"not set\", row.getDoNotSet());\n\n        assertTrue(iter.hasNext());\n        row = iter.next();\n        assertSame(SubTestBean.class, row.getClass());\n\n        assertEquals(\"4\", row.getOne());\n        assertEquals(\"5\", row.getTwo());\n        assertEquals(TestBean.Ordinal.SIX, row.getThree());\n        assertEquals(\"not set\", row.getDoNotSet());\n\n        assertFalse(iter.hasNext());\n    }\n\n    public void testHandleToSuperClass() throws SQLException {\n        final ResultSetHandler<List<TestBean>> h = new BeanListHandler<>(SubTestBean.class);\n        final List<TestBean> results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(ROWS, results.size());\n\n        final Iterator<TestBean> iter = results.iterator();\n        assertTrue(iter.hasNext());\n        TestBean row = iter.next();\n        assertSame(SubTestBean.class, row.getClass());\n\n        assertEquals(\"1\", row.getOne());\n        assertEquals(\"2\", row.getTwo());\n        assertEquals(TestBean.Ordinal.THREE, row.getThree());\n        assertEquals(\"not set\", row.getDoNotSet());\n\n        assertTrue(iter.hasNext());\n        row = iter.next();\n        assertSame(SubTestBean.class, row.getClass());\n\n        assertEquals(\"4\", row.getOne());\n        assertEquals(\"5\", row.getTwo());\n        assertEquals(TestBean.Ordinal.SIX, row.getThree());\n        assertEquals(\"not set\", row.getDoNotSet());\n\n        assertFalse(iter.hasNext());\n    }\n}", "definition": "public class BeanListHandlerTest extends BaseTestCase", "class_docstring": "\nBeanListHandlerTest\n", "name": "BeanListHandlerTest", "super_interfaces": [], "superclasses": "BaseTestCase", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": [{"original_string": "    public static class SubTestBean extends TestBean implements SubTestBeanInterface {\n    }", "definition": "    public static class SubTestBean extends TestBean implements SubTestBeanInterface", "class_docstring": "", "name": "SubTestBean", "super_interfaces": ["SubTestBeanInterface"], "superclasses": "TestBean", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": []}]}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public void testEmptyResultSetHandle() throws SQLException {\n        final ResultSetHandler<List<TestBean>> h = new BeanListHandler<>(TestBean.class);\n        final List<TestBean> results = h.handle(getEmptyResultSet());\n\n        assertNotNull(results);\n        assertTrue(results.isEmpty());\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testEmptyResultSetHandle", "params": [], "body": "                                                               {\n        final ResultSetHandler<List<TestBean>> h = new BeanListHandler<>(TestBean.class);\n        final List<TestBean> results = h.handle(getEmptyResultSet());\n\n        assertNotNull(results);\n        assertTrue(results.isEmpty());\n    }", "signature": "public void testEmptyResultSetHandle()"}, {"syntax_pass": true, "original_string": "    public void testHandle() throws SQLException {\n        final ResultSetHandler<List<TestBean>> h = new BeanListHandler<>(TestBean.class);\n        final List<TestBean> results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(ROWS, results.size());\n\n        final Iterator<TestBean> iter = results.iterator();\n        TestBean row;\n        assertTrue(iter.hasNext());\n        row = iter.next();\n        assertEquals(\"1\", row.getOne());\n        assertEquals(\"2\", row.getTwo());\n        assertEquals(TestBean.Ordinal.THREE, row.getThree());\n        assertEquals(\"not set\", row.getDoNotSet());\n\n        assertTrue(iter.hasNext());\n        row = iter.next();\n\n        assertEquals(\"4\", row.getOne());\n        assertEquals(\"5\", row.getTwo());\n        assertEquals(TestBean.Ordinal.SIX, row.getThree());\n        assertEquals(\"not set\", row.getDoNotSet());\n\n        assertFalse(iter.hasNext());\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testHandle", "params": [], "body": "                                                 {\n        final ResultSetHandler<List<TestBean>> h = new BeanListHandler<>(TestBean.class);\n        final List<TestBean> results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(ROWS, results.size());\n\n        final Iterator<TestBean> iter = results.iterator();\n        TestBean row;\n        assertTrue(iter.hasNext());\n        row = iter.next();\n        assertEquals(\"1\", row.getOne());\n        assertEquals(\"2\", row.getTwo());\n        assertEquals(TestBean.Ordinal.THREE, row.getThree());\n        assertEquals(\"not set\", row.getDoNotSet());\n\n        assertTrue(iter.hasNext());\n        row = iter.next();\n\n        assertEquals(\"4\", row.getOne());\n        assertEquals(\"5\", row.getTwo());\n        assertEquals(TestBean.Ordinal.SIX, row.getThree());\n        assertEquals(\"not set\", row.getDoNotSet());\n\n        assertFalse(iter.hasNext());\n    }", "signature": "public void testHandle()"}, {"syntax_pass": true, "original_string": "    public void testHandleToInterface() throws SQLException {\n        final ResultSetHandler<List<SubTestBeanInterface>> h = new BeanListHandler<>(SubTestBean.class);\n        final List<SubTestBeanInterface> results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(ROWS, results.size());\n\n        final Iterator<SubTestBeanInterface> iter = results.iterator();\n        SubTestBeanInterface row;\n        assertTrue(iter.hasNext());\n        row = iter.next();\n        assertSame(SubTestBean.class, row.getClass());\n\n        assertEquals(\"1\", row.getOne());\n        assertEquals(\"2\", row.getTwo());\n        assertEquals(TestBean.Ordinal.THREE, row.getThree());\n        assertEquals(\"not set\", row.getDoNotSet());\n\n        assertTrue(iter.hasNext());\n        row = iter.next();\n        assertSame(SubTestBean.class, row.getClass());\n\n        assertEquals(\"4\", row.getOne());\n        assertEquals(\"5\", row.getTwo());\n        assertEquals(TestBean.Ordinal.SIX, row.getThree());\n        assertEquals(\"not set\", row.getDoNotSet());\n\n        assertFalse(iter.hasNext());\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testHandleToInterface", "params": [], "body": "                                                            {\n        final ResultSetHandler<List<SubTestBeanInterface>> h = new BeanListHandler<>(SubTestBean.class);\n        final List<SubTestBeanInterface> results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(ROWS, results.size());\n\n        final Iterator<SubTestBeanInterface> iter = results.iterator();\n        SubTestBeanInterface row;\n        assertTrue(iter.hasNext());\n        row = iter.next();\n        assertSame(SubTestBean.class, row.getClass());\n\n        assertEquals(\"1\", row.getOne());\n        assertEquals(\"2\", row.getTwo());\n        assertEquals(TestBean.Ordinal.THREE, row.getThree());\n        assertEquals(\"not set\", row.getDoNotSet());\n\n        assertTrue(iter.hasNext());\n        row = iter.next();\n        assertSame(SubTestBean.class, row.getClass());\n\n        assertEquals(\"4\", row.getOne());\n        assertEquals(\"5\", row.getTwo());\n        assertEquals(TestBean.Ordinal.SIX, row.getThree());\n        assertEquals(\"not set\", row.getDoNotSet());\n\n        assertFalse(iter.hasNext());\n    }", "signature": "public void testHandleToInterface()"}, {"syntax_pass": true, "original_string": "    public void testHandleToSuperClass() throws SQLException {\n        final ResultSetHandler<List<TestBean>> h = new BeanListHandler<>(SubTestBean.class);\n        final List<TestBean> results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(ROWS, results.size());\n\n        final Iterator<TestBean> iter = results.iterator();\n        assertTrue(iter.hasNext());\n        TestBean row = iter.next();\n        assertSame(SubTestBean.class, row.getClass());\n\n        assertEquals(\"1\", row.getOne());\n        assertEquals(\"2\", row.getTwo());\n        assertEquals(TestBean.Ordinal.THREE, row.getThree());\n        assertEquals(\"not set\", row.getDoNotSet());\n\n        assertTrue(iter.hasNext());\n        row = iter.next();\n        assertSame(SubTestBean.class, row.getClass());\n\n        assertEquals(\"4\", row.getOne());\n        assertEquals(\"5\", row.getTwo());\n        assertEquals(TestBean.Ordinal.SIX, row.getThree());\n        assertEquals(\"not set\", row.getDoNotSet());\n\n        assertFalse(iter.hasNext());\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testHandleToSuperClass", "params": [], "body": "                                                             {\n        final ResultSetHandler<List<TestBean>> h = new BeanListHandler<>(SubTestBean.class);\n        final List<TestBean> results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(ROWS, results.size());\n\n        final Iterator<TestBean> iter = results.iterator();\n        assertTrue(iter.hasNext());\n        TestBean row = iter.next();\n        assertSame(SubTestBean.class, row.getClass());\n\n        assertEquals(\"1\", row.getOne());\n        assertEquals(\"2\", row.getTwo());\n        assertEquals(TestBean.Ordinal.THREE, row.getThree());\n        assertEquals(\"not set\", row.getDoNotSet());\n\n        assertTrue(iter.hasNext());\n        row = iter.next();\n        assertSame(SubTestBean.class, row.getClass());\n\n        assertEquals(\"4\", row.getOne());\n        assertEquals(\"5\", row.getTwo());\n        assertEquals(TestBean.Ordinal.SIX, row.getThree());\n        assertEquals(\"not set\", row.getDoNotSet());\n\n        assertFalse(iter.hasNext());\n    }", "signature": "public void testHandleToSuperClass()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/dbutils/handlers/MapListHandlerTest.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils.handlers;\n\nimport java.sql.SQLException;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.apache.commons.dbutils.BaseTestCase;\nimport org.apache.commons.dbutils.ResultSetHandler;\n\n/**\n * MapListHandlerTest\n */\npublic class MapListHandlerTest extends BaseTestCase {\n\n    public void testEmptyResultSetHandle() throws SQLException {\n        final ResultSetHandler<List<Map<String, Object>>> h = new MapListHandler();\n        final List<Map<String, Object>> results = h.handle(getEmptyResultSet());\n\n        assertNotNull(results);\n        assertTrue(results.isEmpty());\n    }\n\n    public void testHandle() throws SQLException {\n        final ResultSetHandler<List<Map<String, Object>>> h = new MapListHandler();\n        final List<Map<String, Object>> results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(ROWS, results.size());\n\n        final Iterator<Map<String, Object>> iter = results.iterator();\n        assertTrue(iter.hasNext());\n        Map<String, Object> row = iter.next();\n        assertEquals(COLS, row.size());\n        assertEquals(\"1\", row.get(\"one\"));\n        assertEquals(\"2\", row.get(\"TWO\"));\n        assertEquals(\"THREE\", row.get(\"Three\"));\n\n        assertTrue(iter.hasNext());\n        row = iter.next();\n        assertEquals(COLS, row.size());\n\n        assertEquals(\"4\", row.get(\"one\"));\n        assertEquals(\"5\", row.get(\"TWO\"));\n        assertEquals(\"SIX\", row.get(\"Three\"));\n\n        assertFalse(iter.hasNext());\n    }\n\n}\n", "file_hash": "5f3ea7c18bfdaca2bb630a53c7fe148a5788dab6219098f978d9c476a2d373fc", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils.handlers;", "import java.sql.SQLException;", "import java.util.Iterator;", "import java.util.List;", "import java.util.Map;", "import org.apache.commons.dbutils.BaseTestCase;", "import org.apache.commons.dbutils.ResultSetHandler;"], "methods": [], "classes": [{"original_string": "public class MapListHandlerTest extends BaseTestCase {\n\n    public void testEmptyResultSetHandle() throws SQLException {\n        final ResultSetHandler<List<Map<String, Object>>> h = new MapListHandler();\n        final List<Map<String, Object>> results = h.handle(getEmptyResultSet());\n\n        assertNotNull(results);\n        assertTrue(results.isEmpty());\n    }\n\n    public void testHandle() throws SQLException {\n        final ResultSetHandler<List<Map<String, Object>>> h = new MapListHandler();\n        final List<Map<String, Object>> results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(ROWS, results.size());\n\n        final Iterator<Map<String, Object>> iter = results.iterator();\n        assertTrue(iter.hasNext());\n        Map<String, Object> row = iter.next();\n        assertEquals(COLS, row.size());\n        assertEquals(\"1\", row.get(\"one\"));\n        assertEquals(\"2\", row.get(\"TWO\"));\n        assertEquals(\"THREE\", row.get(\"Three\"));\n\n        assertTrue(iter.hasNext());\n        row = iter.next();\n        assertEquals(COLS, row.size());\n\n        assertEquals(\"4\", row.get(\"one\"));\n        assertEquals(\"5\", row.get(\"TWO\"));\n        assertEquals(\"SIX\", row.get(\"Three\"));\n\n        assertFalse(iter.hasNext());\n    }\n\n}", "definition": "public class MapListHandlerTest extends BaseTestCase", "class_docstring": "\nMapListHandlerTest\n", "name": "MapListHandlerTest", "super_interfaces": [], "superclasses": "BaseTestCase", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public void testEmptyResultSetHandle() throws SQLException {\n        final ResultSetHandler<List<Map<String, Object>>> h = new MapListHandler();\n        final List<Map<String, Object>> results = h.handle(getEmptyResultSet());\n\n        assertNotNull(results);\n        assertTrue(results.isEmpty());\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testEmptyResultSetHandle", "params": [], "body": "                                                               {\n        final ResultSetHandler<List<Map<String, Object>>> h = new MapListHandler();\n        final List<Map<String, Object>> results = h.handle(getEmptyResultSet());\n\n        assertNotNull(results);\n        assertTrue(results.isEmpty());\n    }", "signature": "public void testEmptyResultSetHandle()"}, {"syntax_pass": true, "original_string": "    public void testHandle() throws SQLException {\n        final ResultSetHandler<List<Map<String, Object>>> h = new MapListHandler();\n        final List<Map<String, Object>> results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(ROWS, results.size());\n\n        final Iterator<Map<String, Object>> iter = results.iterator();\n        assertTrue(iter.hasNext());\n        Map<String, Object> row = iter.next();\n        assertEquals(COLS, row.size());\n        assertEquals(\"1\", row.get(\"one\"));\n        assertEquals(\"2\", row.get(\"TWO\"));\n        assertEquals(\"THREE\", row.get(\"Three\"));\n\n        assertTrue(iter.hasNext());\n        row = iter.next();\n        assertEquals(COLS, row.size());\n\n        assertEquals(\"4\", row.get(\"one\"));\n        assertEquals(\"5\", row.get(\"TWO\"));\n        assertEquals(\"SIX\", row.get(\"Three\"));\n\n        assertFalse(iter.hasNext());\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testHandle", "params": [], "body": "                                                 {\n        final ResultSetHandler<List<Map<String, Object>>> h = new MapListHandler();\n        final List<Map<String, Object>> results = h.handle(getResultSet());\n\n        assertNotNull(results);\n        assertEquals(ROWS, results.size());\n\n        final Iterator<Map<String, Object>> iter = results.iterator();\n        assertTrue(iter.hasNext());\n        Map<String, Object> row = iter.next();\n        assertEquals(COLS, row.size());\n        assertEquals(\"1\", row.get(\"one\"));\n        assertEquals(\"2\", row.get(\"TWO\"));\n        assertEquals(\"THREE\", row.get(\"Three\"));\n\n        assertTrue(iter.hasNext());\n        row = iter.next();\n        assertEquals(COLS, row.size());\n\n        assertEquals(\"4\", row.get(\"one\"));\n        assertEquals(\"5\", row.get(\"TWO\"));\n        assertEquals(\"SIX\", row.get(\"Three\"));\n\n        assertFalse(iter.hasNext());\n    }", "signature": "public void testHandle()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/dbutils/handlers/columns/StringColumnHandlerTest.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils.handlers.columns;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.mockito.Mockito.when;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.junit.MockitoJUnitRunner;\n\n@RunWith(MockitoJUnitRunner.class)\npublic class StringColumnHandlerTest extends AbstractTestColumnHandler<String> {\n\n    public StringColumnHandlerTest() {\n        super(new StringColumnHandler(), String.class);\n    }\n\n    @Override\n    @Test\n    public void testApplyType() throws Exception {\n        when(getResultSet().getString(1)).thenReturn(\"tester\");\n        assertEquals(String.class, getColumnHandler().apply(getResultSet(), 1).getClass());\n    }\n}\n", "file_hash": "381ce0fba840d4a34f2b287ca8e6b69940e172941589b735f614d533475c90d5", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils.handlers.columns;", "import static org.junit.Assert.assertEquals;", "import static org.mockito.Mockito.when;", "import org.junit.Test;", "import org.junit.runner.RunWith;", "import org.mockito.junit.MockitoJUnitRunner;"], "methods": [], "classes": [{"original_string": "@RunWith(MockitoJUnitRunner.class)\npublic class StringColumnHandlerTest extends AbstractTestColumnHandler<String> {\n\n    public StringColumnHandlerTest() {\n        super(new StringColumnHandler(), String.class);\n    }\n\n    @Override\n    @Test\n    public void testApplyType() throws Exception {\n        when(getResultSet().getString(1)).thenReturn(\"tester\");\n        assertEquals(String.class, getColumnHandler().apply(getResultSet(), 1).getClass());\n    }\n}", "definition": "@RunWith(MockitoJUnitRunner.class)\npublic class StringColumnHandlerTest extends AbstractTestColumnHandler<String>", "class_docstring": "", "name": "StringColumnHandlerTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "@RunWith(MockitoJUnitRunner.class)\npublic", "marker_annotations": [], "non_marker_annotations": ["@RunWith(MockitoJUnitRunner.class)", "public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public StringColumnHandlerTest() {\n        super(new StringColumnHandler(), String.class);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "StringColumnHandlerTest", "params": [], "body": "                                     {\n        super(new StringColumnHandler(), String.class);\n    }", "signature": "public StringColumnHandlerTest()"}, {"syntax_pass": true, "original_string": "    @Override\n    @Test\n    public void testApplyType() throws Exception {\n        when(getResultSet().getString(1)).thenReturn(\"tester\");\n        assertEquals(String.class, getColumnHandler().apply(getResultSet(), 1).getClass());\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @Test\n    public", "marker_annotations": ["@Override", "@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testApplyType", "params": [], "body": "                                                 {\n        when(getResultSet().getString(1)).thenReturn(\"tester\");\n        assertEquals(String.class, getColumnHandler().apply(getResultSet(), 1).getClass());\n    }", "signature": "@Override\n    @Test\n    public void testApplyType()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/dbutils/handlers/columns/ShortColumnHandlerTest.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils.handlers.columns;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.mockito.Mockito.when;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.junit.MockitoJUnitRunner;\n\n@RunWith(MockitoJUnitRunner.class)\npublic class ShortColumnHandlerTest extends AbstractTestColumnHandler<Short> {\n\n    public ShortColumnHandlerTest() {\n        super(new ShortColumnHandler(), Short.class);\n    }\n\n    @Override\n    @Test\n    public void testApplyType() throws Exception {\n        when(getResultSet().getShort(1)).thenReturn(Short.MIN_VALUE);\n        assertEquals(Short.class, getColumnHandler().apply(getResultSet(), 1).getClass());\n    }\n}\n", "file_hash": "835d1c029872fd2a5ad40e56691ce02ff4043a21b0f8e58c09181dcc31ff20f0", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils.handlers.columns;", "import static org.junit.Assert.assertEquals;", "import static org.mockito.Mockito.when;", "import org.junit.Test;", "import org.junit.runner.RunWith;", "import org.mockito.junit.MockitoJUnitRunner;"], "methods": [], "classes": [{"original_string": "@RunWith(MockitoJUnitRunner.class)\npublic class ShortColumnHandlerTest extends AbstractTestColumnHandler<Short> {\n\n    public ShortColumnHandlerTest() {\n        super(new ShortColumnHandler(), Short.class);\n    }\n\n    @Override\n    @Test\n    public void testApplyType() throws Exception {\n        when(getResultSet().getShort(1)).thenReturn(Short.MIN_VALUE);\n        assertEquals(Short.class, getColumnHandler().apply(getResultSet(), 1).getClass());\n    }\n}", "definition": "@RunWith(MockitoJUnitRunner.class)\npublic class ShortColumnHandlerTest extends AbstractTestColumnHandler<Short>", "class_docstring": "", "name": "ShortColumnHandlerTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "@RunWith(MockitoJUnitRunner.class)\npublic", "marker_annotations": [], "non_marker_annotations": ["@RunWith(MockitoJUnitRunner.class)", "public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public ShortColumnHandlerTest() {\n        super(new ShortColumnHandler(), Short.class);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ShortColumnHandlerTest", "params": [], "body": "                                    {\n        super(new ShortColumnHandler(), Short.class);\n    }", "signature": "public ShortColumnHandlerTest()"}, {"syntax_pass": true, "original_string": "    @Override\n    @Test\n    public void testApplyType() throws Exception {\n        when(getResultSet().getShort(1)).thenReturn(Short.MIN_VALUE);\n        assertEquals(Short.class, getColumnHandler().apply(getResultSet(), 1).getClass());\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @Test\n    public", "marker_annotations": ["@Override", "@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testApplyType", "params": [], "body": "                                                 {\n        when(getResultSet().getShort(1)).thenReturn(Short.MIN_VALUE);\n        assertEquals(Short.class, getColumnHandler().apply(getResultSet(), 1).getClass());\n    }", "signature": "@Override\n    @Test\n    public void testApplyType()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/dbutils/handlers/columns/TestColumnHandler.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils.handlers.columns;\n\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\n\nimport org.apache.commons.dbutils.ColumnHandler;\n\npublic class TestColumnHandler implements ColumnHandler<Object> {\n\n    @Override\n    public Object apply(final ResultSet rs, final int columnIndex) throws SQLException {\n        return null;\n    }\n\n    @Override\n    public boolean match(final Class<?> propType) {\n        return false;\n    }\n}\n", "file_hash": "e0dc53b58ed10053e25e22f55b60eb18eeca3bfc2e7efe7f887835975acab00f", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils.handlers.columns;", "import java.sql.ResultSet;", "import java.sql.SQLException;", "import org.apache.commons.dbutils.ColumnHandler;"], "methods": [], "classes": [{"original_string": "public class TestColumnHandler implements ColumnHandler<Object> {\n\n    @Override\n    public Object apply(final ResultSet rs, final int columnIndex) throws SQLException {\n        return null;\n    }\n\n    @Override\n    public boolean match(final Class<?> propType) {\n        return false;\n    }\n}", "definition": "public class TestColumnHandler implements ColumnHandler<Object>", "class_docstring": "", "name": "TestColumnHandler", "super_interfaces": ["ColumnHandler<Object>"], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Override\n    public Object apply(final ResultSet rs, final int columnIndex) throws SQLException {\n        return null;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object", "classes": []}, "name": "apply", "params": [{"name": "rs", "type": "ResultSet"}, {"name": "columnIndex", "type": "int"}], "body": "                                                                                       {\n        return null;\n    }", "signature": "@Override\n    public Object apply(final ResultSet rs, final int columnIndex)"}, {"syntax_pass": true, "original_string": "    @Override\n    public boolean match(final Class<?> propType) {\n        return false;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "match", "params": [{"name": "propType", "type": "Class<?>"}], "body": "                                                  {\n        return false;\n    }", "signature": "@Override\n    public boolean match(final Class<?> propType)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/dbutils/handlers/columns/TimestampColumnHandlerTest.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils.handlers.columns;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.mockito.Mockito.when;\n\nimport java.sql.Timestamp;\nimport java.util.Date;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.junit.MockitoJUnitRunner;\n\n@RunWith(MockitoJUnitRunner.class)\npublic class TimestampColumnHandlerTest extends AbstractTestColumnHandler<Timestamp> {\n\n    public TimestampColumnHandlerTest() {\n        super(new TimestampColumnHandler(), Timestamp.class);\n    }\n\n    @Override\n    @Test\n    public void testApplyType() throws Exception {\n        when(getResultSet().getTimestamp(1)).thenReturn(new Timestamp(new Date().getTime()));\n        assertEquals(Timestamp.class, getColumnHandler().apply(getResultSet(), 1).getClass());\n    }\n}\n", "file_hash": "f8de5e191288332dea0be6c0f817083064bb42d540846f42c799e6c84e311614", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils.handlers.columns;", "import static org.junit.Assert.assertEquals;", "import static org.mockito.Mockito.when;", "import java.sql.Timestamp;", "import java.util.Date;", "import org.junit.Test;", "import org.junit.runner.RunWith;", "import org.mockito.junit.MockitoJUnitRunner;"], "methods": [], "classes": [{"original_string": "@RunWith(MockitoJUnitRunner.class)\npublic class TimestampColumnHandlerTest extends AbstractTestColumnHandler<Timestamp> {\n\n    public TimestampColumnHandlerTest() {\n        super(new TimestampColumnHandler(), Timestamp.class);\n    }\n\n    @Override\n    @Test\n    public void testApplyType() throws Exception {\n        when(getResultSet().getTimestamp(1)).thenReturn(new Timestamp(new Date().getTime()));\n        assertEquals(Timestamp.class, getColumnHandler().apply(getResultSet(), 1).getClass());\n    }\n}", "definition": "@RunWith(MockitoJUnitRunner.class)\npublic class TimestampColumnHandlerTest extends AbstractTestColumnHandler<Timestamp>", "class_docstring": "", "name": "TimestampColumnHandlerTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "@RunWith(MockitoJUnitRunner.class)\npublic", "marker_annotations": [], "non_marker_annotations": ["@RunWith(MockitoJUnitRunner.class)", "public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public TimestampColumnHandlerTest() {\n        super(new TimestampColumnHandler(), Timestamp.class);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "TimestampColumnHandlerTest", "params": [], "body": "                                        {\n        super(new TimestampColumnHandler(), Timestamp.class);\n    }", "signature": "public TimestampColumnHandlerTest()"}, {"syntax_pass": true, "original_string": "    @Override\n    @Test\n    public void testApplyType() throws Exception {\n        when(getResultSet().getTimestamp(1)).thenReturn(new Timestamp(new Date().getTime()));\n        assertEquals(Timestamp.class, getColumnHandler().apply(getResultSet(), 1).getClass());\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @Test\n    public", "marker_annotations": ["@Override", "@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testApplyType", "params": [], "body": "                                                 {\n        when(getResultSet().getTimestamp(1)).thenReturn(new Timestamp(new Date().getTime()));\n        assertEquals(Timestamp.class, getColumnHandler().apply(getResultSet(), 1).getClass());\n    }", "signature": "@Override\n    @Test\n    public void testApplyType()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/dbutils/handlers/columns/BooleanColumnHandlerTest.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils.handlers.columns;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.mockito.Mockito.when;\n\nimport java.sql.ResultSet;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.junit.MockitoJUnitRunner;\n\n@RunWith(MockitoJUnitRunner.class)\npublic class BooleanColumnHandlerTest extends AbstractTestColumnHandler<Boolean> {\n\n    public BooleanColumnHandlerTest() {\n        super(new BooleanColumnHandler(), Boolean.class);\n    }\n\n    @Override\n    @Test\n    public void testApplyType() throws Exception {\n        final ResultSet rs = getResultSet();\n        when(rs.getBoolean(1)).thenReturn(Boolean.TRUE);\n        assertEquals(Boolean.class, getColumnHandler().apply(rs, 1).getClass());\n    }\n}\n", "file_hash": "b0329e8ce8e9dfce10f40fa4fc42b910807fb17433526780835f8c0f426ac59a", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils.handlers.columns;", "import static org.junit.Assert.assertEquals;", "import static org.mockito.Mockito.when;", "import java.sql.ResultSet;", "import org.junit.Test;", "import org.junit.runner.RunWith;", "import org.mockito.junit.MockitoJUnitRunner;"], "methods": [], "classes": [{"original_string": "@RunWith(MockitoJUnitRunner.class)\npublic class BooleanColumnHandlerTest extends AbstractTestColumnHandler<Boolean> {\n\n    public BooleanColumnHandlerTest() {\n        super(new BooleanColumnHandler(), Boolean.class);\n    }\n\n    @Override\n    @Test\n    public void testApplyType() throws Exception {\n        final ResultSet rs = getResultSet();\n        when(rs.getBoolean(1)).thenReturn(Boolean.TRUE);\n        assertEquals(Boolean.class, getColumnHandler().apply(rs, 1).getClass());\n    }\n}", "definition": "@RunWith(MockitoJUnitRunner.class)\npublic class BooleanColumnHandlerTest extends AbstractTestColumnHandler<Boolean>", "class_docstring": "", "name": "BooleanColumnHandlerTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "@RunWith(MockitoJUnitRunner.class)\npublic", "marker_annotations": [], "non_marker_annotations": ["@RunWith(MockitoJUnitRunner.class)", "public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public BooleanColumnHandlerTest() {\n        super(new BooleanColumnHandler(), Boolean.class);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "BooleanColumnHandlerTest", "params": [], "body": "                                      {\n        super(new BooleanColumnHandler(), Boolean.class);\n    }", "signature": "public BooleanColumnHandlerTest()"}, {"syntax_pass": true, "original_string": "    @Override\n    @Test\n    public void testApplyType() throws Exception {\n        final ResultSet rs = getResultSet();\n        when(rs.getBoolean(1)).thenReturn(Boolean.TRUE);\n        assertEquals(Boolean.class, getColumnHandler().apply(rs, 1).getClass());\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @Test\n    public", "marker_annotations": ["@Override", "@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testApplyType", "params": [], "body": "                                                 {\n        final ResultSet rs = getResultSet();\n        when(rs.getBoolean(1)).thenReturn(Boolean.TRUE);\n        assertEquals(Boolean.class, getColumnHandler().apply(rs, 1).getClass());\n    }", "signature": "@Override\n    @Test\n    public void testApplyType()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/dbutils/handlers/columns/AbstractTestColumnHandler.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils.handlers.columns;\n\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\n\nimport java.sql.ResultSet;\n\nimport org.apache.commons.dbutils.ColumnHandler;\nimport org.junit.Test;\nimport org.mockito.Mock;\n\npublic abstract class AbstractTestColumnHandler<T> {\n\n    @Mock\n    private ResultSet rs;\n    private final ColumnHandler<T> handler;\n    private final Class<?> matchingType;\n\n    public AbstractTestColumnHandler(final ColumnHandler<T> handler, final Class<?> matchingType) {\n        this.handler = handler;\n        this.matchingType = matchingType;\n    }\n\n    public ColumnHandler<T> getColumnHandler() {\n        return this.handler;\n    }\n\n    public Class<?> getMatchingType() {\n        return this.matchingType;\n    }\n\n    public ResultSet getResultSet() {\n        return this.rs;\n    }\n\n    @Test\n    public abstract void testApplyType() throws Exception;\n\n    @Test\n    public void testMatch() {\n        assertTrue(handler.match(matchingType));\n    }\n\n    @Test\n    public void testMatchNegative() {\n        assertFalse(handler.match(Integer.class));\n    }\n}\n", "file_hash": "dd72ec194c6fe43ce3c2f089f7c66e0bf067df7ed69469dea45fd81110f877fa", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils.handlers.columns;", "import static org.junit.Assert.assertFalse;", "import static org.junit.Assert.assertTrue;", "import java.sql.ResultSet;", "import org.apache.commons.dbutils.ColumnHandler;", "import org.junit.Test;", "import org.mockito.Mock;"], "methods": [], "classes": [{"original_string": "public abstract class AbstractTestColumnHandler<T> {\n\n    @Mock\n    private ResultSet rs;\n    private final ColumnHandler<T> handler;\n    private final Class<?> matchingType;\n\n    public AbstractTestColumnHandler(final ColumnHandler<T> handler, final Class<?> matchingType) {\n        this.handler = handler;\n        this.matchingType = matchingType;\n    }\n\n    public ColumnHandler<T> getColumnHandler() {\n        return this.handler;\n    }\n\n    public Class<?> getMatchingType() {\n        return this.matchingType;\n    }\n\n    public ResultSet getResultSet() {\n        return this.rs;\n    }\n\n    @Test\n    public abstract void testApplyType() throws Exception;\n\n    @Test\n    public void testMatch() {\n        assertTrue(handler.match(matchingType));\n    }\n\n    @Test\n    public void testMatchNegative() {\n        assertFalse(handler.match(Integer.class));\n    }\n}", "definition": "public abstract class AbstractTestColumnHandler<T>", "class_docstring": "", "name": "AbstractTestColumnHandler", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public abstract", "marker_annotations": [], "non_marker_annotations": ["public", "abstract"], "comments": [], "fields": [{"attribute_expression": "@Mock\n    private ResultSet rs;", "docstring": "", "modifiers": "@Mock\n    private", "marker_annotations": ["@Mock"], "non_marker_annotations": ["private"], "comments": [], "type": "ResultSet", "name": "rs", "syntax_pass": true}, {"attribute_expression": "private final ColumnHandler<T> handler;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ColumnHandler<T>", "name": "handler", "syntax_pass": true}, {"attribute_expression": "private final Class<?> matchingType;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Class<?>", "name": "matchingType", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public AbstractTestColumnHandler(final ColumnHandler<T> handler, final Class<?> matchingType) {\n        this.handler = handler;\n        this.matchingType = matchingType;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "AbstractTestColumnHandler", "params": [{"name": "handler", "type": "ColumnHandler<T>"}, {"name": "matchingType", "type": "Class<?>"}], "body": "                                                                                                  {\n        this.handler = handler;\n        this.matchingType = matchingType;\n    }", "signature": "public AbstractTestColumnHandler(final ColumnHandler<T> handler, final Class<?> matchingType)"}, {"syntax_pass": true, "original_string": "    public ColumnHandler<T> getColumnHandler() {\n        return this.handler;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ColumnHandler<T>", "classes": []}, "name": "getColumnHandler", "params": [], "body": "                                               {\n        return this.handler;\n    }", "signature": "public ColumnHandler<T> getColumnHandler()"}, {"syntax_pass": true, "original_string": "    public Class<?> getMatchingType() {\n        return this.matchingType;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Class<?>", "classes": []}, "name": "getMatchingType", "params": [], "body": "                                      {\n        return this.matchingType;\n    }", "signature": "public Class<?> getMatchingType()"}, {"syntax_pass": true, "original_string": "    public ResultSet getResultSet() {\n        return this.rs;\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ResultSet", "classes": []}, "name": "getResultSet", "params": [], "body": "                                    {\n        return this.rs;\n    }", "signature": "public ResultSet getResultSet()"}, {"syntax_pass": true, "original_string": "    @Test\n    public abstract void testApplyType() throws Exception;", "docstring": "", "attributes": {"modifiers": "@Test\n    public abstract", "marker_annotations": ["@Test"], "non_marker_annotations": ["public", "abstract"], "comments": [], "return_type": "void", "classes": []}, "name": "testApplyType", "params": [], "body": "", "signature": "@Test\n    public abstract void testApplyType()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testMatch() {\n        assertTrue(handler.match(matchingType));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testMatch", "params": [], "body": "                            {\n        assertTrue(handler.match(matchingType));\n    }", "signature": "@Test\n    public void testMatch()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testMatchNegative() {\n        assertFalse(handler.match(Integer.class));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testMatchNegative", "params": [], "body": "                                    {\n        assertFalse(handler.match(Integer.class));\n    }", "signature": "@Test\n    public void testMatchNegative()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/dbutils/handlers/columns/DoubleColumnHandlerTest.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils.handlers.columns;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.mockito.Mockito.when;\n\nimport java.sql.ResultSet;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.junit.MockitoJUnitRunner;\n\n@RunWith(MockitoJUnitRunner.class)\npublic class DoubleColumnHandlerTest extends AbstractTestColumnHandler<Double> {\n\n    public DoubleColumnHandlerTest() {\n        super(new DoubleColumnHandler(), Double.class);\n    }\n\n    @Override\n    @Test\n    public void testApplyType() throws Exception {\n        final ResultSet rs = getResultSet();\n        when(rs.getDouble(1)).thenReturn(Double.MIN_VALUE);\n        assertEquals(Double.class, getColumnHandler().apply(rs, 1).getClass());\n    }\n}\n", "file_hash": "e99db6bb064f2b5da0831b8589318e45c8f17d1a8d61a53ca295bc9528230679", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils.handlers.columns;", "import static org.junit.Assert.assertEquals;", "import static org.mockito.Mockito.when;", "import java.sql.ResultSet;", "import org.junit.Test;", "import org.junit.runner.RunWith;", "import org.mockito.junit.MockitoJUnitRunner;"], "methods": [], "classes": [{"original_string": "@RunWith(MockitoJUnitRunner.class)\npublic class DoubleColumnHandlerTest extends AbstractTestColumnHandler<Double> {\n\n    public DoubleColumnHandlerTest() {\n        super(new DoubleColumnHandler(), Double.class);\n    }\n\n    @Override\n    @Test\n    public void testApplyType() throws Exception {\n        final ResultSet rs = getResultSet();\n        when(rs.getDouble(1)).thenReturn(Double.MIN_VALUE);\n        assertEquals(Double.class, getColumnHandler().apply(rs, 1).getClass());\n    }\n}", "definition": "@RunWith(MockitoJUnitRunner.class)\npublic class DoubleColumnHandlerTest extends AbstractTestColumnHandler<Double>", "class_docstring": "", "name": "DoubleColumnHandlerTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "@RunWith(MockitoJUnitRunner.class)\npublic", "marker_annotations": [], "non_marker_annotations": ["@RunWith(MockitoJUnitRunner.class)", "public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public DoubleColumnHandlerTest() {\n        super(new DoubleColumnHandler(), Double.class);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "DoubleColumnHandlerTest", "params": [], "body": "                                     {\n        super(new DoubleColumnHandler(), Double.class);\n    }", "signature": "public DoubleColumnHandlerTest()"}, {"syntax_pass": true, "original_string": "    @Override\n    @Test\n    public void testApplyType() throws Exception {\n        final ResultSet rs = getResultSet();\n        when(rs.getDouble(1)).thenReturn(Double.MIN_VALUE);\n        assertEquals(Double.class, getColumnHandler().apply(rs, 1).getClass());\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @Test\n    public", "marker_annotations": ["@Override", "@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testApplyType", "params": [], "body": "                                                 {\n        final ResultSet rs = getResultSet();\n        when(rs.getDouble(1)).thenReturn(Double.MIN_VALUE);\n        assertEquals(Double.class, getColumnHandler().apply(rs, 1).getClass());\n    }", "signature": "@Override\n    @Test\n    public void testApplyType()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/dbutils/handlers/columns/LongColumnHandlerTest.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils.handlers.columns;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.mockito.Mockito.when;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.junit.MockitoJUnitRunner;\n\n@RunWith(MockitoJUnitRunner.class)\npublic class LongColumnHandlerTest extends AbstractTestColumnHandler<Long> {\n\n    public LongColumnHandlerTest() {\n        super(new LongColumnHandler(), Long.class);\n    }\n\n    @Override\n    @Test\n    public void testApplyType() throws Exception {\n        when(getResultSet().getLong(1)).thenReturn(Long.MIN_VALUE);\n        assertEquals(Long.class, getColumnHandler().apply(getResultSet(), 1).getClass());\n    }\n}\n", "file_hash": "3c3ebea95421950384095c10d2ac9a16a7b86f5e2f74202af14aa7dcd7d4a377", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils.handlers.columns;", "import static org.junit.Assert.assertEquals;", "import static org.mockito.Mockito.when;", "import org.junit.Test;", "import org.junit.runner.RunWith;", "import org.mockito.junit.MockitoJUnitRunner;"], "methods": [], "classes": [{"original_string": "@RunWith(MockitoJUnitRunner.class)\npublic class LongColumnHandlerTest extends AbstractTestColumnHandler<Long> {\n\n    public LongColumnHandlerTest() {\n        super(new LongColumnHandler(), Long.class);\n    }\n\n    @Override\n    @Test\n    public void testApplyType() throws Exception {\n        when(getResultSet().getLong(1)).thenReturn(Long.MIN_VALUE);\n        assertEquals(Long.class, getColumnHandler().apply(getResultSet(), 1).getClass());\n    }\n}", "definition": "@RunWith(MockitoJUnitRunner.class)\npublic class LongColumnHandlerTest extends AbstractTestColumnHandler<Long>", "class_docstring": "", "name": "LongColumnHandlerTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "@RunWith(MockitoJUnitRunner.class)\npublic", "marker_annotations": [], "non_marker_annotations": ["@RunWith(MockitoJUnitRunner.class)", "public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public LongColumnHandlerTest() {\n        super(new LongColumnHandler(), Long.class);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "LongColumnHandlerTest", "params": [], "body": "                                   {\n        super(new LongColumnHandler(), Long.class);\n    }", "signature": "public LongColumnHandlerTest()"}, {"syntax_pass": true, "original_string": "    @Override\n    @Test\n    public void testApplyType() throws Exception {\n        when(getResultSet().getLong(1)).thenReturn(Long.MIN_VALUE);\n        assertEquals(Long.class, getColumnHandler().apply(getResultSet(), 1).getClass());\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @Test\n    public", "marker_annotations": ["@Override", "@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testApplyType", "params": [], "body": "                                                 {\n        when(getResultSet().getLong(1)).thenReturn(Long.MIN_VALUE);\n        assertEquals(Long.class, getColumnHandler().apply(getResultSet(), 1).getClass());\n    }", "signature": "@Override\n    @Test\n    public void testApplyType()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/dbutils/handlers/columns/SQLXMLColumnHandlerTest.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils.handlers.columns;\n\nimport static org.junit.Assert.assertTrue;\nimport static org.mockito.Mockito.when;\n\nimport java.sql.SQLXML;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.Mock;\nimport org.mockito.junit.MockitoJUnitRunner;\n\n@RunWith(MockitoJUnitRunner.class)\npublic class SQLXMLColumnHandlerTest extends AbstractTestColumnHandler<SQLXML> {\n\n    @Mock\n    private SQLXML sqlxml;\n\n    public SQLXMLColumnHandlerTest() {\n        super(new SQLXMLColumnHandler(), SQLXML.class);\n    }\n\n    @Override\n    @Test\n    public void testApplyType() throws Exception {\n        when(getResultSet().getSQLXML(1)).thenReturn(sqlxml);\n        assertTrue(SQLXML.class.isAssignableFrom(getColumnHandler().apply(getResultSet(), 1).getClass()));\n    }\n}\n", "file_hash": "99816f6e899e462c1361806a819e81647692ee088cbe354f4ad9f89024b4790f", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils.handlers.columns;", "import static org.junit.Assert.assertTrue;", "import static org.mockito.Mockito.when;", "import java.sql.SQLXML;", "import org.junit.Test;", "import org.junit.runner.RunWith;", "import org.mockito.Mock;", "import org.mockito.junit.MockitoJUnitRunner;"], "methods": [], "classes": [{"original_string": "@RunWith(MockitoJUnitRunner.class)\npublic class SQLXMLColumnHandlerTest extends AbstractTestColumnHandler<SQLXML> {\n\n    @Mock\n    private SQLXML sqlxml;\n\n    public SQLXMLColumnHandlerTest() {\n        super(new SQLXMLColumnHandler(), SQLXML.class);\n    }\n\n    @Override\n    @Test\n    public void testApplyType() throws Exception {\n        when(getResultSet().getSQLXML(1)).thenReturn(sqlxml);\n        assertTrue(SQLXML.class.isAssignableFrom(getColumnHandler().apply(getResultSet(), 1).getClass()));\n    }\n}", "definition": "@RunWith(MockitoJUnitRunner.class)\npublic class SQLXMLColumnHandlerTest extends AbstractTestColumnHandler<SQLXML>", "class_docstring": "", "name": "SQLXMLColumnHandlerTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "@RunWith(MockitoJUnitRunner.class)\npublic", "marker_annotations": [], "non_marker_annotations": ["@RunWith(MockitoJUnitRunner.class)", "public"], "comments": [], "fields": [{"attribute_expression": "@Mock\n    private SQLXML sqlxml;", "docstring": "", "modifiers": "@Mock\n    private", "marker_annotations": ["@Mock"], "non_marker_annotations": ["private"], "comments": [], "type": "SQLXML", "name": "sqlxml", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public SQLXMLColumnHandlerTest() {\n        super(new SQLXMLColumnHandler(), SQLXML.class);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "SQLXMLColumnHandlerTest", "params": [], "body": "                                     {\n        super(new SQLXMLColumnHandler(), SQLXML.class);\n    }", "signature": "public SQLXMLColumnHandlerTest()"}, {"syntax_pass": true, "original_string": "    @Override\n    @Test\n    public void testApplyType() throws Exception {\n        when(getResultSet().getSQLXML(1)).thenReturn(sqlxml);\n        assertTrue(SQLXML.class.isAssignableFrom(getColumnHandler().apply(getResultSet(), 1).getClass()));\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @Test\n    public", "marker_annotations": ["@Override", "@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testApplyType", "params": [], "body": "                                                 {\n        when(getResultSet().getSQLXML(1)).thenReturn(sqlxml);\n        assertTrue(SQLXML.class.isAssignableFrom(getColumnHandler().apply(getResultSet(), 1).getClass()));\n    }", "signature": "@Override\n    @Test\n    public void testApplyType()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/dbutils/handlers/columns/ByteColumnHandlerTest.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils.handlers.columns;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.mockito.Mockito.when;\n\nimport java.sql.ResultSet;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.junit.MockitoJUnitRunner;\n\n@RunWith(MockitoJUnitRunner.class)\npublic class ByteColumnHandlerTest extends AbstractTestColumnHandler<Byte> {\n\n    public ByteColumnHandlerTest() {\n        super(new ByteColumnHandler(), Byte.class);\n    }\n\n    @Override\n    @Test\n    public void testApplyType() throws Exception {\n        final ResultSet rs = getResultSet();\n        when(rs.getByte(1)).thenReturn(Byte.MIN_VALUE);\n        assertEquals(Byte.class, getColumnHandler().apply(rs, 1).getClass());\n    }\n}\n", "file_hash": "54c89a3756df7f530a0949e9f13c17c075ca16be2783b8fd77c8a70ba92dd9d5", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils.handlers.columns;", "import static org.junit.Assert.assertEquals;", "import static org.mockito.Mockito.when;", "import java.sql.ResultSet;", "import org.junit.Test;", "import org.junit.runner.RunWith;", "import org.mockito.junit.MockitoJUnitRunner;"], "methods": [], "classes": [{"original_string": "@RunWith(MockitoJUnitRunner.class)\npublic class ByteColumnHandlerTest extends AbstractTestColumnHandler<Byte> {\n\n    public ByteColumnHandlerTest() {\n        super(new ByteColumnHandler(), Byte.class);\n    }\n\n    @Override\n    @Test\n    public void testApplyType() throws Exception {\n        final ResultSet rs = getResultSet();\n        when(rs.getByte(1)).thenReturn(Byte.MIN_VALUE);\n        assertEquals(Byte.class, getColumnHandler().apply(rs, 1).getClass());\n    }\n}", "definition": "@RunWith(MockitoJUnitRunner.class)\npublic class ByteColumnHandlerTest extends AbstractTestColumnHandler<Byte>", "class_docstring": "", "name": "ByteColumnHandlerTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "@RunWith(MockitoJUnitRunner.class)\npublic", "marker_annotations": [], "non_marker_annotations": ["@RunWith(MockitoJUnitRunner.class)", "public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public ByteColumnHandlerTest() {\n        super(new ByteColumnHandler(), Byte.class);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ByteColumnHandlerTest", "params": [], "body": "                                   {\n        super(new ByteColumnHandler(), Byte.class);\n    }", "signature": "public ByteColumnHandlerTest()"}, {"syntax_pass": true, "original_string": "    @Override\n    @Test\n    public void testApplyType() throws Exception {\n        final ResultSet rs = getResultSet();\n        when(rs.getByte(1)).thenReturn(Byte.MIN_VALUE);\n        assertEquals(Byte.class, getColumnHandler().apply(rs, 1).getClass());\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @Test\n    public", "marker_annotations": ["@Override", "@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testApplyType", "params": [], "body": "                                                 {\n        final ResultSet rs = getResultSet();\n        when(rs.getByte(1)).thenReturn(Byte.MIN_VALUE);\n        assertEquals(Byte.class, getColumnHandler().apply(rs, 1).getClass());\n    }", "signature": "@Override\n    @Test\n    public void testApplyType()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/dbutils/handlers/columns/IntegerColumnHandlerTest.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils.handlers.columns;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.mockito.Mockito.when;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.junit.MockitoJUnitRunner;\n\n@RunWith(MockitoJUnitRunner.class)\npublic class IntegerColumnHandlerTest extends AbstractTestColumnHandler<Integer> {\n\n    public IntegerColumnHandlerTest() {\n        super(new IntegerColumnHandler(), Integer.class);\n    }\n\n    @Override\n    @Test\n    public void testApplyType() throws Exception {\n        when(getResultSet().getInt(1)).thenReturn(Integer.MIN_VALUE);\n        assertEquals(Integer.class, getColumnHandler().apply(getResultSet(), 1).getClass());\n    }\n\n    @Override\n    @Test\n    public void testMatchNegative() {\n        assertFalse(getColumnHandler().match(Float.class));\n    }\n}\n", "file_hash": "0e08352830418cd44d98dd05d052ddca97639267740786d52fcae40212893837", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils.handlers.columns;", "import static org.junit.Assert.assertEquals;", "import static org.junit.Assert.assertFalse;", "import static org.mockito.Mockito.when;", "import org.junit.Test;", "import org.junit.runner.RunWith;", "import org.mockito.junit.MockitoJUnitRunner;"], "methods": [], "classes": [{"original_string": "@RunWith(MockitoJUnitRunner.class)\npublic class IntegerColumnHandlerTest extends AbstractTestColumnHandler<Integer> {\n\n    public IntegerColumnHandlerTest() {\n        super(new IntegerColumnHandler(), Integer.class);\n    }\n\n    @Override\n    @Test\n    public void testApplyType() throws Exception {\n        when(getResultSet().getInt(1)).thenReturn(Integer.MIN_VALUE);\n        assertEquals(Integer.class, getColumnHandler().apply(getResultSet(), 1).getClass());\n    }\n\n    @Override\n    @Test\n    public void testMatchNegative() {\n        assertFalse(getColumnHandler().match(Float.class));\n    }\n}", "definition": "@RunWith(MockitoJUnitRunner.class)\npublic class IntegerColumnHandlerTest extends AbstractTestColumnHandler<Integer>", "class_docstring": "", "name": "IntegerColumnHandlerTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "@RunWith(MockitoJUnitRunner.class)\npublic", "marker_annotations": [], "non_marker_annotations": ["@RunWith(MockitoJUnitRunner.class)", "public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public IntegerColumnHandlerTest() {\n        super(new IntegerColumnHandler(), Integer.class);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "IntegerColumnHandlerTest", "params": [], "body": "                                      {\n        super(new IntegerColumnHandler(), Integer.class);\n    }", "signature": "public IntegerColumnHandlerTest()"}, {"syntax_pass": true, "original_string": "    @Override\n    @Test\n    public void testApplyType() throws Exception {\n        when(getResultSet().getInt(1)).thenReturn(Integer.MIN_VALUE);\n        assertEquals(Integer.class, getColumnHandler().apply(getResultSet(), 1).getClass());\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @Test\n    public", "marker_annotations": ["@Override", "@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testApplyType", "params": [], "body": "                                                 {\n        when(getResultSet().getInt(1)).thenReturn(Integer.MIN_VALUE);\n        assertEquals(Integer.class, getColumnHandler().apply(getResultSet(), 1).getClass());\n    }", "signature": "@Override\n    @Test\n    public void testApplyType()"}, {"syntax_pass": true, "original_string": "    @Override\n    @Test\n    public void testMatchNegative() {\n        assertFalse(getColumnHandler().match(Float.class));\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @Test\n    public", "marker_annotations": ["@Override", "@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testMatchNegative", "params": [], "body": "                                    {\n        assertFalse(getColumnHandler().match(Float.class));\n    }", "signature": "@Override\n    @Test\n    public void testMatchNegative()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/dbutils/handlers/columns/FloatColumnHandlerTest.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils.handlers.columns;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.mockito.Mockito.when;\n\nimport java.sql.ResultSet;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.junit.MockitoJUnitRunner;\n\n@RunWith(MockitoJUnitRunner.class)\npublic class FloatColumnHandlerTest extends AbstractTestColumnHandler<Float> {\n\n    public FloatColumnHandlerTest() {\n        super(new FloatColumnHandler(), Float.class);\n    }\n\n    @Override\n    @Test\n    public void testApplyType() throws Exception {\n        final ResultSet rs = getResultSet();\n        when(rs.getFloat(1)).thenReturn(Float.MIN_VALUE);\n        assertEquals(Float.class, getColumnHandler().apply(rs, 1).getClass());\n    }\n}\n", "file_hash": "7353b9d791e9f639bd7592c1fff4bdc686d164a67b17d78e0e260f38990ca1d0", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils.handlers.columns;", "import static org.junit.Assert.assertEquals;", "import static org.mockito.Mockito.when;", "import java.sql.ResultSet;", "import org.junit.Test;", "import org.junit.runner.RunWith;", "import org.mockito.junit.MockitoJUnitRunner;"], "methods": [], "classes": [{"original_string": "@RunWith(MockitoJUnitRunner.class)\npublic class FloatColumnHandlerTest extends AbstractTestColumnHandler<Float> {\n\n    public FloatColumnHandlerTest() {\n        super(new FloatColumnHandler(), Float.class);\n    }\n\n    @Override\n    @Test\n    public void testApplyType() throws Exception {\n        final ResultSet rs = getResultSet();\n        when(rs.getFloat(1)).thenReturn(Float.MIN_VALUE);\n        assertEquals(Float.class, getColumnHandler().apply(rs, 1).getClass());\n    }\n}", "definition": "@RunWith(MockitoJUnitRunner.class)\npublic class FloatColumnHandlerTest extends AbstractTestColumnHandler<Float>", "class_docstring": "", "name": "FloatColumnHandlerTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "@RunWith(MockitoJUnitRunner.class)\npublic", "marker_annotations": [], "non_marker_annotations": ["@RunWith(MockitoJUnitRunner.class)", "public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public FloatColumnHandlerTest() {\n        super(new FloatColumnHandler(), Float.class);\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "FloatColumnHandlerTest", "params": [], "body": "                                    {\n        super(new FloatColumnHandler(), Float.class);\n    }", "signature": "public FloatColumnHandlerTest()"}, {"syntax_pass": true, "original_string": "    @Override\n    @Test\n    public void testApplyType() throws Exception {\n        final ResultSet rs = getResultSet();\n        when(rs.getFloat(1)).thenReturn(Float.MIN_VALUE);\n        assertEquals(Float.class, getColumnHandler().apply(rs, 1).getClass());\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @Test\n    public", "marker_annotations": ["@Override", "@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testApplyType", "params": [], "body": "                                                 {\n        final ResultSet rs = getResultSet();\n        when(rs.getFloat(1)).thenReturn(Float.MIN_VALUE);\n        assertEquals(Float.class, getColumnHandler().apply(rs, 1).getClass());\n    }", "signature": "@Override\n    @Test\n    public void testApplyType()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/dbutils/handlers/properties/PropertyHandlerTest.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils.handlers.properties;\n\nimport static org.junit.Assert.assertTrue;\n\nimport java.util.ServiceLoader;\n\nimport org.apache.commons.dbutils.PropertyHandler;\nimport org.junit.Before;\nimport org.junit.Test;\n\npublic class PropertyHandlerTest {\n    private ServiceLoader<PropertyHandler> loader;\n\n    @Before\n    public void setUp() {\n        loader = ServiceLoader.load(PropertyHandler.class);\n    }\n\n    /**\n     * Verifying 'more than 1' shows that we found more than we loaded locally which assumes the core handlers were loaded, too.\n     */\n    @Test\n    public void testFoundMoreThanLocal() {\n        int count = 0;\n        for (final PropertyHandler handler : loader) {\n            count++;\n        }\n\n        assertTrue(count > 1);\n    }\n\n    @Test\n    public void testServiceLoaderFindsMultipleRegistries() {\n        boolean found = false;\n        for (final PropertyHandler handler : loader) {\n            // this class is defined outside of the main classes of dbutils\n            if (handler instanceof TestPropertyHandler) {\n                found = true;\n            }\n        }\n\n        assertTrue(found);\n    }\n\n}\n", "file_hash": "2ed253d1b5b29a6049dfe8fdc9cc49f5629ddf2a84439e662b21b9ba2a4aa313", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils.handlers.properties;", "import static org.junit.Assert.assertTrue;", "import java.util.ServiceLoader;", "import org.apache.commons.dbutils.PropertyHandler;", "import org.junit.Before;", "import org.junit.Test;"], "methods": [], "classes": [{"original_string": "public class PropertyHandlerTest {\n    private ServiceLoader<PropertyHandler> loader;\n\n    @Before\n    public void setUp() {\n        loader = ServiceLoader.load(PropertyHandler.class);\n    }\n\n    /**\n     * Verifying 'more than 1' shows that we found more than we loaded locally which assumes the core handlers were loaded, too.\n     */\n    @Test\n    public void testFoundMoreThanLocal() {\n        int count = 0;\n        for (final PropertyHandler handler : loader) {\n            count++;\n        }\n\n        assertTrue(count > 1);\n    }\n\n    @Test\n    public void testServiceLoaderFindsMultipleRegistries() {\n        boolean found = false;\n        for (final PropertyHandler handler : loader) {\n            // this class is defined outside of the main classes of dbutils\n            if (handler instanceof TestPropertyHandler) {\n                found = true;\n            }\n        }\n\n        assertTrue(found);\n    }\n\n}", "definition": "public class PropertyHandlerTest", "class_docstring": "", "name": "PropertyHandlerTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private ServiceLoader<PropertyHandler> loader;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ServiceLoader<PropertyHandler>", "name": "loader", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Before\n    public void setUp() {\n        loader = ServiceLoader.load(PropertyHandler.class);\n    }", "docstring": "", "attributes": {"modifiers": "@Before\n    public", "marker_annotations": ["@Before"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setUp", "params": [], "body": "                        {\n        loader = ServiceLoader.load(PropertyHandler.class);\n    }", "signature": "@Before\n    public void setUp()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testFoundMoreThanLocal() {\n        int count = 0;\n        for (final PropertyHandler handler : loader) {\n            count++;\n        }\n\n        assertTrue(count > 1);\n    }", "docstring": "\nVerifying 'more than 1' shows that we found more than we loaded locally which assumes the core handlers were loaded, too.\n", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testFoundMoreThanLocal", "params": [], "body": "                                         {\n        int count = 0;\n        for (final PropertyHandler handler : loader) {\n            count++;\n        }\n\n        assertTrue(count > 1);\n    }", "signature": "@Test\n    public void testFoundMoreThanLocal()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testServiceLoaderFindsMultipleRegistries() {\n        boolean found = false;\n        for (final PropertyHandler handler : loader) {\n            // this class is defined outside of the main classes of dbutils\n            if (handler instanceof TestPropertyHandler) {\n                found = true;\n            }\n        }\n\n        assertTrue(found);\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testServiceLoaderFindsMultipleRegistries", "params": [], "body": "                                                           {\n        boolean found = false;\n        for (final PropertyHandler handler : loader) {\n            // this class is defined outside of the main classes of dbutils\n            if (handler instanceof TestPropertyHandler) {\n                found = true;\n            }\n        }\n\n        assertTrue(found);\n    }", "signature": "@Test\n    public void testServiceLoaderFindsMultipleRegistries()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/dbutils/handlers/properties/TestEnum.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils.handlers.properties;\n\npublic enum TestEnum {\n    TESTER\n}\n", "file_hash": "992d4a7b3905ea12fb9e8327a86596611fd3a083d0e1fbed10ed2ab5ef425f64", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils.handlers.properties;"], "methods": [], "classes": [], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/dbutils/handlers/properties/StringEnumPropertyHandlerTest.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils.handlers.properties;\n\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\npublic class StringEnumPropertyHandlerTest {\n    private StringEnumPropertyHandler handler;\n\n    @Before\n    public void setUp() {\n        this.handler = new StringEnumPropertyHandler();\n    }\n\n    @Test\n    public void testMatch() {\n        assertTrue(handler.match(TestEnum.class, \"test\"));\n    }\n\n    @Test\n    public void testMatchNegative() {\n        assertFalse(handler.match(TestEnum.class, Double.valueOf(1)));\n\n        assertFalse(handler.match(Integer.class, \"\"));\n    }\n}\n", "file_hash": "fe05e78af3005f807cacfe562c9c19d618138728838b318bbc1ca1139cda5be5", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils.handlers.properties;", "import static org.junit.Assert.assertFalse;", "import static org.junit.Assert.assertTrue;", "import org.junit.Before;", "import org.junit.Test;"], "methods": [], "classes": [{"original_string": "public class StringEnumPropertyHandlerTest {\n    private StringEnumPropertyHandler handler;\n\n    @Before\n    public void setUp() {\n        this.handler = new StringEnumPropertyHandler();\n    }\n\n    @Test\n    public void testMatch() {\n        assertTrue(handler.match(TestEnum.class, \"test\"));\n    }\n\n    @Test\n    public void testMatchNegative() {\n        assertFalse(handler.match(TestEnum.class, Double.valueOf(1)));\n\n        assertFalse(handler.match(Integer.class, \"\"));\n    }\n}", "definition": "public class StringEnumPropertyHandlerTest", "class_docstring": "", "name": "StringEnumPropertyHandlerTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private StringEnumPropertyHandler handler;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "StringEnumPropertyHandler", "name": "handler", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Before\n    public void setUp() {\n        this.handler = new StringEnumPropertyHandler();\n    }", "docstring": "", "attributes": {"modifiers": "@Before\n    public", "marker_annotations": ["@Before"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setUp", "params": [], "body": "                        {\n        this.handler = new StringEnumPropertyHandler();\n    }", "signature": "@Before\n    public void setUp()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testMatch() {\n        assertTrue(handler.match(TestEnum.class, \"test\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testMatch", "params": [], "body": "                            {\n        assertTrue(handler.match(TestEnum.class, \"test\"));\n    }", "signature": "@Test\n    public void testMatch()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testMatchNegative() {\n        assertFalse(handler.match(TestEnum.class, Double.valueOf(1)));\n\n        assertFalse(handler.match(Integer.class, \"\"));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testMatchNegative", "params": [], "body": "                                    {\n        assertFalse(handler.match(TestEnum.class, Double.valueOf(1)));\n\n        assertFalse(handler.match(Integer.class, \"\"));\n    }", "signature": "@Test\n    public void testMatchNegative()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/dbutils/handlers/properties/TestPropertyHandler.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils.handlers.properties;\n\nimport org.apache.commons.dbutils.PropertyHandler;\n\npublic class TestPropertyHandler implements PropertyHandler {\n\n    @Override\n    public Object apply(final Class<?> parameter, final Object value) {\n        return null;\n    }\n\n    @Override\n    public boolean match(final Class<?> parameter, final Object value) {\n        return false;\n    }\n}\n", "file_hash": "08d9669d23d1b824372552e698e34d503b538f8641774bd40850af9bc5d7fa68", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils.handlers.properties;", "import org.apache.commons.dbutils.PropertyHandler;"], "methods": [], "classes": [{"original_string": "public class TestPropertyHandler implements PropertyHandler {\n\n    @Override\n    public Object apply(final Class<?> parameter, final Object value) {\n        return null;\n    }\n\n    @Override\n    public boolean match(final Class<?> parameter, final Object value) {\n        return false;\n    }\n}", "definition": "public class TestPropertyHandler implements PropertyHandler", "class_docstring": "", "name": "TestPropertyHandler", "super_interfaces": ["PropertyHandler"], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Override\n    public Object apply(final Class<?> parameter, final Object value) {\n        return null;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object", "classes": []}, "name": "apply", "params": [{"name": "parameter", "type": "Class<?>"}, {"name": "value", "type": "Object"}], "body": "                                                                      {\n        return null;\n    }", "signature": "@Override\n    public Object apply(final Class<?> parameter, final Object value)"}, {"syntax_pass": true, "original_string": "    @Override\n    public boolean match(final Class<?> parameter, final Object value) {\n        return false;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "match", "params": [{"name": "parameter", "type": "Class<?>"}, {"name": "value", "type": "Object"}], "body": "                                                                       {\n        return false;\n    }", "signature": "@Override\n    public boolean match(final Class<?> parameter, final Object value)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/dbutils/handlers/properties/DatePropertyHandlerTest.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils.handlers.properties;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\n\nimport java.sql.Time;\nimport java.sql.Timestamp;\nimport java.util.Date;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\npublic class DatePropertyHandlerTest {\n    private DatePropertyHandler handler;\n    private Date testValue;\n\n    @Before\n    public void setUp() {\n        this.handler = new DatePropertyHandler();\n        this.testValue = new Date();\n    }\n\n    @Test\n    public void testApplyTypeOfDate() throws Exception {\n        assertEquals(java.sql.Date.class, handler.apply(java.sql.Date.class, testValue).getClass());\n    }\n\n    @Test\n    public void testApplyTypeOfTime() throws Exception {\n        assertEquals(Time.class, handler.apply(java.sql.Time.class, testValue).getClass());\n    }\n\n    @Test\n    public void testApplyTypeOfTimestamp() throws Exception {\n        assertEquals(Timestamp.class, handler.apply(java.sql.Timestamp.class, testValue).getClass());\n    }\n\n    @Test\n    public void testMatch() {\n        assertTrue(handler.match(java.sql.Date.class, testValue));\n        assertTrue(handler.match(java.sql.Time.class, testValue));\n        assertTrue(handler.match(java.sql.Timestamp.class, testValue));\n    }\n\n    @Test\n    public void testMatchNegative() {\n        assertFalse(handler.match(Float.class, null));\n        assertFalse(handler.match(Float.class, testValue));\n    }\n\n    @Test\n    public void testNotMatch() {\n        final Timestamp ts = new Timestamp(testValue.getTime());\n        assertFalse(handler.match(java.sql.Timestamp.class, ts));\n    }\n}\n", "file_hash": "0e68acb696e155eaf3b5eb9f925a1e8035a8e54b8173afd40ea5eb58da32de6d", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils.handlers.properties;", "import static org.junit.Assert.assertEquals;", "import static org.junit.Assert.assertFalse;", "import static org.junit.Assert.assertTrue;", "import java.sql.Time;", "import java.sql.Timestamp;", "import java.util.Date;", "import org.junit.Before;", "import org.junit.Test;"], "methods": [], "classes": [{"original_string": "public class DatePropertyHandlerTest {\n    private DatePropertyHandler handler;\n    private Date testValue;\n\n    @Before\n    public void setUp() {\n        this.handler = new DatePropertyHandler();\n        this.testValue = new Date();\n    }\n\n    @Test\n    public void testApplyTypeOfDate() throws Exception {\n        assertEquals(java.sql.Date.class, handler.apply(java.sql.Date.class, testValue).getClass());\n    }\n\n    @Test\n    public void testApplyTypeOfTime() throws Exception {\n        assertEquals(Time.class, handler.apply(java.sql.Time.class, testValue).getClass());\n    }\n\n    @Test\n    public void testApplyTypeOfTimestamp() throws Exception {\n        assertEquals(Timestamp.class, handler.apply(java.sql.Timestamp.class, testValue).getClass());\n    }\n\n    @Test\n    public void testMatch() {\n        assertTrue(handler.match(java.sql.Date.class, testValue));\n        assertTrue(handler.match(java.sql.Time.class, testValue));\n        assertTrue(handler.match(java.sql.Timestamp.class, testValue));\n    }\n\n    @Test\n    public void testMatchNegative() {\n        assertFalse(handler.match(Float.class, null));\n        assertFalse(handler.match(Float.class, testValue));\n    }\n\n    @Test\n    public void testNotMatch() {\n        final Timestamp ts = new Timestamp(testValue.getTime());\n        assertFalse(handler.match(java.sql.Timestamp.class, ts));\n    }\n}", "definition": "public class DatePropertyHandlerTest", "class_docstring": "", "name": "DatePropertyHandlerTest", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private DatePropertyHandler handler;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "DatePropertyHandler", "name": "handler", "syntax_pass": true}, {"attribute_expression": "private Date testValue;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Date", "name": "testValue", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Before\n    public void setUp() {\n        this.handler = new DatePropertyHandler();\n        this.testValue = new Date();\n    }", "docstring": "", "attributes": {"modifiers": "@Before\n    public", "marker_annotations": ["@Before"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setUp", "params": [], "body": "                        {\n        this.handler = new DatePropertyHandler();\n        this.testValue = new Date();\n    }", "signature": "@Before\n    public void setUp()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testApplyTypeOfDate() throws Exception {\n        assertEquals(java.sql.Date.class, handler.apply(java.sql.Date.class, testValue).getClass());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testApplyTypeOfDate", "params": [], "body": "                                                       {\n        assertEquals(java.sql.Date.class, handler.apply(java.sql.Date.class, testValue).getClass());\n    }", "signature": "@Test\n    public void testApplyTypeOfDate()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testApplyTypeOfTime() throws Exception {\n        assertEquals(Time.class, handler.apply(java.sql.Time.class, testValue).getClass());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testApplyTypeOfTime", "params": [], "body": "                                                       {\n        assertEquals(Time.class, handler.apply(java.sql.Time.class, testValue).getClass());\n    }", "signature": "@Test\n    public void testApplyTypeOfTime()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testApplyTypeOfTimestamp() throws Exception {\n        assertEquals(Timestamp.class, handler.apply(java.sql.Timestamp.class, testValue).getClass());\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testApplyTypeOfTimestamp", "params": [], "body": "                                                            {\n        assertEquals(Timestamp.class, handler.apply(java.sql.Timestamp.class, testValue).getClass());\n    }", "signature": "@Test\n    public void testApplyTypeOfTimestamp()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testMatch() {\n        assertTrue(handler.match(java.sql.Date.class, testValue));\n        assertTrue(handler.match(java.sql.Time.class, testValue));\n        assertTrue(handler.match(java.sql.Timestamp.class, testValue));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testMatch", "params": [], "body": "                            {\n        assertTrue(handler.match(java.sql.Date.class, testValue));\n        assertTrue(handler.match(java.sql.Time.class, testValue));\n        assertTrue(handler.match(java.sql.Timestamp.class, testValue));\n    }", "signature": "@Test\n    public void testMatch()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testMatchNegative() {\n        assertFalse(handler.match(Float.class, null));\n        assertFalse(handler.match(Float.class, testValue));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testMatchNegative", "params": [], "body": "                                    {\n        assertFalse(handler.match(Float.class, null));\n        assertFalse(handler.match(Float.class, testValue));\n    }", "signature": "@Test\n    public void testMatchNegative()"}, {"syntax_pass": true, "original_string": "    @Test\n    public void testNotMatch() {\n        final Timestamp ts = new Timestamp(testValue.getTime());\n        assertFalse(handler.match(java.sql.Timestamp.class, ts));\n    }", "docstring": "", "attributes": {"modifiers": "@Test\n    public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testNotMatch", "params": [], "body": "                               {\n        final Timestamp ts = new Timestamp(testValue.getTime());\n        assertFalse(handler.match(java.sql.Timestamp.class, ts));\n    }", "signature": "@Test\n    public void testNotMatch()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSetTest.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils.wrappers;\n\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.verify;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.CharArrayReader;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.Reader;\nimport java.io.Writer;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.math.BigDecimal;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.sql.Blob;\nimport java.sql.Clob;\nimport java.sql.Ref;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Time;\nimport java.sql.Timestamp;\nimport java.util.Arrays;\nimport java.util.Calendar;\nimport java.util.Map;\n\nimport org.apache.commons.dbutils.BaseTestCase;\nimport org.apache.commons.dbutils.ProxyFactory;\n\nfinal class SqlNullCheckedResultSetMockBlob implements Blob {\n\n    /**\n     * @throws SQLException\n     */\n    @Override\n    public void free() throws SQLException {\n\n    }\n\n    @Override\n    public InputStream getBinaryStream() throws SQLException {\n        return new ByteArrayInputStream(new byte[0]);\n    }\n\n    /**\n     * @throws SQLException\n     */\n    @Override\n    public InputStream getBinaryStream(final long pos, final long length) throws SQLException {\n        return null;\n    }\n\n    @Override\n    public byte[] getBytes(final long param, final int param1) throws SQLException {\n        return new byte[0];\n    }\n\n    @Override\n    public long length() throws SQLException {\n        return 0;\n    }\n\n    @Override\n    public long position(final Blob blob, final long param) throws SQLException {\n        return 0;\n    }\n\n    @Override\n    public long position(final byte[] values, final long param) throws SQLException {\n        return 0;\n    }\n\n    @Override\n    public OutputStream setBinaryStream(final long pos) throws SQLException {\n        return null;\n    }\n\n    @Override\n    public int setBytes(final long pos, final byte[] bytes) throws SQLException {\n        return 0;\n    }\n\n    @Override\n    public int setBytes(final long pos, final byte[] bytes, final int offset, final int len) throws SQLException {\n        return 0;\n    }\n\n    @Override\n    public void truncate(final long len) throws SQLException {\n\n    }\n\n}\n\nfinal class SqlNullCheckedResultSetMockClob implements Clob {\n\n    /**\n     * @throws SQLException\n     */\n    @Override\n    public void free() throws SQLException {\n\n    }\n\n    @Override\n    public InputStream getAsciiStream() throws SQLException {\n        return null;\n    }\n\n    @Override\n    public Reader getCharacterStream() throws SQLException {\n        return null;\n    }\n\n    /**\n     * @throws SQLException\n     */\n    @Override\n    public Reader getCharacterStream(final long pos, final long length) throws SQLException {\n        return null;\n    }\n\n    @Override\n    public String getSubString(final long param, final int param1) throws SQLException {\n        return \"\";\n    }\n\n    @Override\n    public long length() throws SQLException {\n        return 0;\n    }\n\n    @Override\n    public long position(final Clob clob, final long param) throws SQLException {\n        return 0;\n    }\n\n    @Override\n    public long position(final String str, final long param) throws SQLException {\n        return 0;\n    }\n\n    @Override\n    public OutputStream setAsciiStream(final long pos) throws SQLException {\n        return null;\n    }\n\n    @Override\n    public Writer setCharacterStream(final long pos) throws SQLException {\n        return null;\n    }\n\n    @Override\n    public int setString(final long pos, final String str) throws SQLException {\n        return 0;\n    }\n\n    @Override\n    public int setString(final long pos, final String str, final int offset, final int len) throws SQLException {\n        return 0;\n    }\n\n    @Override\n    public void truncate(final long len) throws SQLException {\n\n    }\n\n}\n\nfinal class SqlNullCheckedResultSetMockRef implements Ref {\n\n    @Override\n    public String getBaseTypeName() throws SQLException {\n        return \"\";\n    }\n\n    @Override\n    public Object getObject() throws SQLException {\n        return null;\n    }\n\n    @Override\n    public Object getObject(final Map<String, Class<?>> map) throws SQLException {\n        return null;\n    }\n\n    @Override\n    public void setObject(final Object value) throws SQLException {\n        // no-op\n    }\n\n}\n\n/**\n * Test cases for {@code SqlNullCheckedResultSet} class.\n */\npublic class SqlNullCheckedResultSetTest extends BaseTestCase {\n\n    private static ResultSet rs;\n\n    private static void assertArrayEquals(final byte[] expected, final byte[] actual) {\n        if (expected == actual) {\n            return;\n        }\n        if (expected.length != actual.length) {\n            failNotEquals(null, Arrays.toString(expected), Arrays.toString(actual));\n        }\n        for (int i = 0; i < expected.length; i++) {\n            final byte expectedItem = expected[i];\n            final byte actualItem = actual[i];\n            assertEquals(\"Array not equal at index \" + i, expectedItem, actualItem);\n        }\n    }\n    private SqlNullCheckedResultSet rs2;\n\n    /**\n     * Sets up instance variables required by this test case.\n     */\n    @Override\n    public void setUp() throws Exception {\n        super.setUp();\n\n        rs2 = new SqlNullCheckedResultSet(ProxyFactory.instance().createResultSet(new SqlNullUncheckedMockResultSet()));\n\n        setResultSet(ProxyFactory.instance().createResultSet(rs2)); // Override superclass field\n        rs = getResultSet();\n    }\n\n    /**\n     * Tests the getAsciiStream implementation.\n     */\n    public void testGetAsciiStream() throws SQLException {\n\n        assertNull(rs.getAsciiStream(1));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getAsciiStream(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final InputStream stream = new ByteArrayInputStream(new byte[0]);\n        rs2.setNullAsciiStream(stream);\n        assertNotNull(rs.getAsciiStream(1));\n        assertEquals(stream, rs.getAsciiStream(1));\n        assertNotNull(rs.getAsciiStream(\"column\"));\n        assertEquals(stream, rs.getAsciiStream(\"column\"));\n\n    }\n\n    /**\n     * Tests the getBigDecimal implementation.\n     */\n    public void testGetBigDecimal() throws SQLException {\n\n        assertNull(rs.getBigDecimal(1));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getBigDecimal(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final BigDecimal bd = new BigDecimal(5.0);\n        rs2.setNullBigDecimal(bd);\n        assertNotNull(rs.getBigDecimal(1));\n        assertEquals(bd, rs.getBigDecimal(1));\n        assertNotNull(rs.getBigDecimal(\"column\"));\n        assertEquals(bd, rs.getBigDecimal(\"column\"));\n\n    }\n\n    /**\n     * Tests the getBinaryStream implementation.\n     */\n    public void testGetBinaryStream() throws SQLException {\n\n        assertNull(rs.getBinaryStream(1));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getBinaryStream(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final InputStream stream = new ByteArrayInputStream(new byte[0]);\n        rs2.setNullBinaryStream(stream);\n        assertNotNull(rs.getBinaryStream(1));\n        assertEquals(stream, rs.getBinaryStream(1));\n        assertNotNull(rs.getBinaryStream(\"column\"));\n        assertEquals(stream, rs.getBinaryStream(\"column\"));\n\n    }\n\n    /**\n     * Tests the getBlob implementation.\n     */\n    public void testGetBlob() throws SQLException {\n\n        assertNull(rs.getBlob(1));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getBlob(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final Blob blob = new SqlNullCheckedResultSetMockBlob();\n        rs2.setNullBlob(blob);\n        assertNotNull(rs.getBlob(1));\n        assertEquals(blob, rs.getBlob(1));\n        assertNotNull(rs.getBlob(\"column\"));\n        assertEquals(blob, rs.getBlob(\"column\"));\n\n    }\n\n    /**\n     * Tests the getBoolean implementation.\n     */\n    public void testGetBoolean() throws SQLException {\n\n        assertFalse(rs.getBoolean(1));\n        assertTrue(rs.wasNull());\n        assertFalse(rs.getBoolean(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        rs2.setNullBoolean(true);\n        assertTrue( rs.getBoolean(1));\n        assertTrue( rs.getBoolean(\"column\"));\n\n    }\n\n    /**\n     * Tests the getByte implementation.\n     */\n    public void testGetByte() throws SQLException {\n\n        assertEquals((byte) 0, rs.getByte(1));\n        assertTrue(rs.wasNull());\n        assertEquals((byte) 0, rs.getByte(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final byte b = (byte) 10;\n        rs2.setNullByte(b);\n        assertEquals(b, rs.getByte(1));\n        assertEquals(b, rs.getByte(\"column\"));\n\n    }\n\n    /**\n     * Tests the getByte implementation.\n     */\n    public void testGetBytes() throws SQLException {\n\n        assertNull(rs.getBytes(1));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getBytes(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final byte[] b = new byte[5];\n        for (int i = 0; i < 5; i++) {\n            b[0] = (byte) i;\n        }\n        rs2.setNullBytes(b);\n        assertNotNull(rs.getBytes(1));\n        assertArrayEquals(b, rs.getBytes(1));\n        assertNotNull(rs.getBytes(\"column\"));\n        assertArrayEquals(b, rs.getBytes(\"column\"));\n\n    }\n\n    /**\n     * Tests the getCharacterStream implementation.\n     */\n    public void testGetCharacterStream() throws SQLException {\n\n        assertNull(rs.getCharacterStream(1));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getCharacterStream(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final Reader reader = new CharArrayReader(\"this is a string\".toCharArray());\n        rs2.setNullCharacterStream(reader);\n        assertNotNull(rs.getCharacterStream(1));\n        assertEquals(reader, rs.getCharacterStream(1));\n        assertNotNull(rs.getCharacterStream(\"column\"));\n        assertEquals(reader, rs.getCharacterStream(\"column\"));\n\n    }\n\n    /**\n     * Tests the getClob implementation.\n     */\n    public void testGetClob() throws SQLException {\n\n        assertNull(rs.getClob(1));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getClob(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final Clob clob = new SqlNullCheckedResultSetMockClob();\n        rs2.setNullClob(clob);\n        assertNotNull(rs.getClob(1));\n        assertEquals(clob, rs.getClob(1));\n        assertNotNull(rs.getClob(\"column\"));\n        assertEquals(clob, rs.getClob(\"column\"));\n\n    }\n\n    /**\n     * Tests the getDate implementation.\n     */\n    public void testGetDate() throws SQLException {\n\n        assertNull(rs.getDate(1));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getDate(\"column\"));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getDate(1, Calendar.getInstance()));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getDate(\"column\", Calendar.getInstance()));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final java.sql.Date date = new java.sql.Date(new java.util.Date().getTime());\n        rs2.setNullDate(date);\n        assertNotNull(rs.getDate(1));\n        assertEquals(date, rs.getDate(1));\n        assertNotNull(rs.getDate(\"column\"));\n        assertEquals(date, rs.getDate(\"column\"));\n        assertNotNull(rs.getDate(1, Calendar.getInstance()));\n        assertEquals(date, rs.getDate(1, Calendar.getInstance()));\n        assertNotNull(rs.getDate(\"column\", Calendar.getInstance()));\n        assertEquals(date, rs.getDate(\"column\", Calendar.getInstance()));\n\n    }\n\n    /**\n     * Tests the getDouble implementation.\n     */\n    public void testGetDouble() throws SQLException {\n\n        assertEquals(0.0, rs.getDouble(1), 0.0);\n        assertTrue(rs.wasNull());\n        assertEquals(0.0, rs.getDouble(\"column\"), 0.0);\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final double d = 10.0;\n        rs2.setNullDouble(d);\n        assertEquals(d, rs.getDouble(1), 0.0);\n        assertEquals(d, rs.getDouble(\"column\"), 0.0);\n\n    }\n\n    /**\n     * Tests the getFloat implementation.\n     */\n    public void testGetFloat() throws SQLException {\n        assertEquals(0, rs.getFloat(1), 0.0);\n        assertTrue(rs.wasNull());\n        assertEquals(0, rs.getFloat(\"column\"), 0.0);\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final float f = 10;\n        rs2.setNullFloat(f);\n        assertEquals(f, rs.getFloat(1), 0.0);\n        assertEquals(f, rs.getFloat(\"column\"), 0.0);\n    }\n\n    /**\n     * Tests the getInt implementation.\n     */\n    public void testGetInt() throws SQLException {\n        assertEquals(0, rs.getInt(1));\n        assertTrue(rs.wasNull());\n        assertEquals(0, rs.getInt(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final int i = 10;\n        rs2.setNullInt(i);\n        assertEquals(i, rs.getInt(1));\n        assertEquals(i, rs.getInt(\"column\"));\n    }\n\n    /**\n     * Tests the getLong implementation.\n     */\n    public void testGetLong() throws SQLException {\n        assertEquals(0, rs.getLong(1));\n        assertTrue(rs.wasNull());\n        assertEquals(0, rs.getLong(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final long l = 10;\n        rs2.setNullLong(l);\n        assertEquals(l, rs.getLong(1));\n        assertEquals(l, rs.getLong(\"column\"));\n    }\n\n    /**\n     * Tests the getObject implementation.\n     */\n    public void testGetObject() throws SQLException {\n\n        assertNull(rs.getObject(1));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getObject(\"column\"));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getObject(1, (Map<String, Class<?>>) null));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getObject(\"column\", (Map<String, Class<?>>) null));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final Object o = new Object();\n        rs2.setNullObject(o);\n        assertNotNull(rs.getObject(1));\n        assertEquals(o, rs.getObject(1));\n        assertNotNull(rs.getObject(\"column\"));\n        assertEquals(o, rs.getObject(\"column\"));\n        assertNotNull(rs.getObject(1, (Map<String, Class<?>>) null));\n        assertEquals(o, rs.getObject(1, (Map<String, Class<?>>) null));\n        assertNotNull(rs.getObject(\"column\", (Map<String, Class<?>>) null));\n        assertEquals(o, rs.getObject(\"column\", (Map<String, Class<?>>) null));\n\n    }\n\n    /**\n     * Tests the getRef implementation.\n     */\n    public void testGetRef() throws SQLException {\n\n        assertNull(rs.getRef(1));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getRef(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final Ref ref = new SqlNullCheckedResultSetMockRef();\n        rs2.setNullRef(ref);\n        assertNotNull(rs.getRef(1));\n        assertEquals(ref, rs.getRef(1));\n        assertNotNull(rs.getRef(\"column\"));\n        assertEquals(ref, rs.getRef(\"column\"));\n\n    }\n\n    /**\n     * Tests the getShort implementation.\n     */\n    public void testGetShort() throws SQLException {\n\n        assertEquals((short) 0, rs.getShort(1));\n        assertTrue(rs.wasNull());\n        assertEquals((short) 0, rs.getShort(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final short s = (short) 10;\n        rs2.setNullShort(s);\n        assertEquals(s, rs.getShort(1));\n        assertEquals(s, rs.getShort(\"column\"));\n    }\n\n    /**\n     * Tests the getString implementation.\n     */\n    public void testGetString() throws SQLException {\n        assertNull(rs.getString(1));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getString(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final String s = \"hello, world\";\n        rs2.setNullString(s);\n        assertEquals(s, rs.getString(1));\n        assertEquals(s, rs.getString(\"column\"));\n    }\n\n    /**\n     * Tests the getTime implementation.\n     */\n    public void testGetTime() throws SQLException {\n\n        assertNull(rs.getTime(1));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getTime(\"column\"));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getTime(1, Calendar.getInstance()));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getTime(\"column\", Calendar.getInstance()));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final Time time = new Time(new java.util.Date().getTime());\n        rs2.setNullTime(time);\n        assertNotNull(rs.getTime(1));\n        assertEquals(time, rs.getTime(1));\n        assertNotNull(rs.getTime(\"column\"));\n        assertEquals(time, rs.getTime(\"column\"));\n        assertNotNull(rs.getTime(1, Calendar.getInstance()));\n        assertEquals(time, rs.getTime(1, Calendar.getInstance()));\n        assertNotNull(rs.getTime(\"column\", Calendar.getInstance()));\n        assertEquals(time, rs.getTime(\"column\", Calendar.getInstance()));\n\n    }\n\n    /**\n     * Tests the getTimestamp implementation.\n     */\n    public void testGetTimestamp() throws SQLException {\n\n        assertNull(rs.getTimestamp(1));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getTimestamp(\"column\"));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getTimestamp(1, Calendar.getInstance()));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getTimestamp(\"column\", Calendar.getInstance()));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final Timestamp ts = new Timestamp(new java.util.Date().getTime());\n        rs2.setNullTimestamp(ts);\n        assertNotNull(rs.getTimestamp(1));\n        assertEquals(ts, rs.getTimestamp(1));\n        assertNotNull(rs.getTimestamp(\"column\"));\n        assertEquals(ts, rs.getTimestamp(\"column\"));\n        assertNotNull(rs.getTimestamp(1, Calendar.getInstance()));\n        assertEquals(ts, rs.getTimestamp(1, Calendar.getInstance()));\n        assertNotNull(rs.getTimestamp(\"column\", Calendar.getInstance()));\n        assertEquals(ts, rs.getTimestamp(\"column\", Calendar.getInstance()));\n    }\n\n    /**\n     * Tests the setNullAsciiStream implementation.\n     */\n    public void testSetNullAsciiStream() throws SQLException {\n\n        assertNull(rs2.getNullAsciiStream());\n        // Set what gets returned to something other than the default\n        final InputStream stream = new ByteArrayInputStream(new byte[0]);\n        rs2.setNullAsciiStream(stream);\n        assertNotNull(rs.getAsciiStream(1));\n        assertEquals(stream, rs.getAsciiStream(1));\n        assertNotNull(rs.getAsciiStream(\"column\"));\n        assertEquals(stream, rs.getAsciiStream(\"column\"));\n\n    }\n\n    /**\n     * Tests the setNullBigDecimal implementation.\n     */\n    public void testSetNullBigDecimal() throws SQLException {\n\n        assertNull(rs2.getNullBigDecimal());\n        // Set what gets returned to something other than the default\n        final BigDecimal bd = new BigDecimal(5.0);\n        rs2.setNullBigDecimal(bd);\n        assertNotNull(rs.getBigDecimal(1));\n        assertEquals(bd, rs.getBigDecimal(1));\n        assertNotNull(rs.getBigDecimal(\"column\"));\n        assertEquals(bd, rs.getBigDecimal(\"column\"));\n\n    }\n\n    /**\n     * Tests the setNullBinaryStream implementation.\n     */\n    public void testSetNullBinaryStream() throws SQLException {\n\n        assertNull(rs2.getNullBinaryStream());\n        // Set what gets returned to something other than the default\n        final InputStream stream = new ByteArrayInputStream(new byte[0]);\n        rs2.setNullBinaryStream(stream);\n        assertNotNull(rs.getBinaryStream(1));\n        assertEquals(stream, rs.getBinaryStream(1));\n        assertNotNull(rs.getBinaryStream(\"column\"));\n        assertEquals(stream, rs.getBinaryStream(\"column\"));\n\n    }\n\n    /**\n     * Tests the setNullBlob implementation.\n     */\n    public void testSetNullBlob() throws SQLException {\n\n        assertNull(rs2.getNullBlob());\n        // Set what gets returned to something other than the default\n        final Blob blob = new SqlNullCheckedResultSetMockBlob();\n        rs2.setNullBlob(blob);\n        assertNotNull(rs.getBlob(1));\n        assertEquals(blob, rs.getBlob(1));\n        assertNotNull(rs.getBlob(\"column\"));\n        assertEquals(blob, rs.getBlob(\"column\"));\n\n    }\n\n    /**\n     * Tests the setNullBoolean implementation.\n     */\n    public void testSetNullBoolean() throws SQLException {\n\n        assertFalse(rs2.getNullBoolean());\n        // Set what gets returned to something other than the default\n        rs2.setNullBoolean(true);\n        assertTrue( rs.getBoolean(1));\n        assertTrue( rs.getBoolean(\"column\"));\n\n    }\n\n    /**\n     * Tests the setNullByte implementation.\n     */\n    public void testSetNullByte() throws SQLException {\n\n        assertEquals((byte) 0, rs2.getNullByte());\n        // Set what gets returned to something other than the default\n        final byte b = (byte) 10;\n        rs2.setNullByte(b);\n        assertEquals(b, rs.getByte(1));\n        assertEquals(b, rs.getByte(\"column\"));\n\n    }\n\n    /**\n     * Tests the setNullByte implementation.\n     */\n    public void testSetNullBytes() throws SQLException {\n        // test the default, unset value\n        assertNull(rs2.getNullBytes());\n\n        // test that setting null is safe\n        rs2.setNullBytes(null);\n        assertNull(rs2.getNullBytes());\n\n        // Set what gets returned to something other than the default\n        final byte[] b = new byte[5];\n        for (int i = 0; i < 5; i++) {\n            b[0] = (byte) i;\n        }\n        rs2.setNullBytes(b);\n        assertNotNull(rs.getBytes(1));\n        assertArrayEquals(b, rs.getBytes(1));\n        assertNotNull(rs.getBytes(\"column\"));\n        assertArrayEquals(b, rs.getBytes(\"column\"));\n\n    }\n\n    /**\n     * Tests the setNullCharacterStream implementation.\n     */\n    public void testSetNullCharacterStream() throws SQLException {\n\n        assertNull(rs2.getNullCharacterStream());\n        // Set what gets returned to something other than the default\n        final Reader reader = new CharArrayReader(\"this is a string\".toCharArray());\n        rs2.setNullCharacterStream(reader);\n        assertNotNull(rs.getCharacterStream(1));\n        assertEquals(reader, rs.getCharacterStream(1));\n        assertNotNull(rs.getCharacterStream(\"column\"));\n        assertEquals(reader, rs.getCharacterStream(\"column\"));\n\n    }\n\n    /**\n     * Tests the setNullClob implementation.\n     */\n    public void testSetNullClob() throws SQLException {\n\n        assertNull(rs2.getNullClob());\n        // Set what gets returned to something other than the default\n        final Clob clob = new SqlNullCheckedResultSetMockClob();\n        rs2.setNullClob(clob);\n        assertNotNull(rs.getClob(1));\n        assertEquals(clob, rs.getClob(1));\n        assertNotNull(rs.getClob(\"column\"));\n        assertEquals(clob, rs.getClob(\"column\"));\n\n    }\n\n    /**\n     * Tests the setNullDate implementation.\n     */\n    public void testSetNullDate() throws SQLException {\n        // test the default, unset value\n        assertNull(rs2.getNullDate());\n\n        // test that setting null is safe\n        rs2.setNullDate(null);\n        assertNull(rs2.getNullDate());\n\n        // Set what gets returned to something other than the default\n        final java.sql.Date date = new java.sql.Date(new java.util.Date().getTime());\n        rs2.setNullDate(date);\n        assertNotNull(rs.getDate(1));\n        assertEquals(date, rs.getDate(1));\n        assertNotNull(rs.getDate(\"column\"));\n        assertEquals(date, rs.getDate(\"column\"));\n        assertNotNull(rs.getDate(1, Calendar.getInstance()));\n        assertEquals(date, rs.getDate(1, Calendar.getInstance()));\n        assertNotNull(rs.getDate(\"column\", Calendar.getInstance()));\n        assertEquals(date, rs.getDate(\"column\", Calendar.getInstance()));\n\n    }\n\n    /**\n     * Tests the setNullDouble implementation.\n     */\n    public void testSetNullDouble() throws SQLException {\n        assertEquals(0.0, rs2.getNullDouble(), 0.0);\n        // Set what gets returned to something other than the default\n        final double d = 10.0;\n        rs2.setNullDouble(d);\n        assertEquals(d, rs.getDouble(1), 0.0);\n        assertEquals(d, rs.getDouble(\"column\"), 0.0);\n    }\n\n    /**\n     * Tests the setNullFloat implementation.\n     */\n    public void testSetNullFloat() throws SQLException {\n        assertEquals((float) 0.0, rs2.getNullFloat(), 0.0);\n        // Set what gets returned to something other than the default\n        final float f = (float) 10.0;\n        rs2.setNullFloat(f);\n        assertEquals(f, rs.getFloat(1), 0.0);\n        assertEquals(f, rs.getFloat(\"column\"), 0.0);\n    }\n\n    /**\n     * Tests the setNullInt implementation.\n     */\n    public void testSetNullInt() throws SQLException {\n        assertEquals(0, rs2.getNullInt());\n        assertEquals(0, rs.getInt(1));\n        assertTrue(rs.wasNull());\n        assertEquals(0, rs.getInt(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final int i = 10;\n        rs2.setNullInt(i);\n        assertEquals(i, rs.getInt(1));\n        assertEquals(i, rs.getInt(\"column\"));\n    }\n\n    /**\n     * Tests the setNullLong implementation.\n     */\n    public void testSetNullLong() throws SQLException {\n        assertEquals(0, rs2.getNullLong());\n        // Set what gets returned to something other than the default\n        final long l = 10;\n        rs2.setNullLong(l);\n        assertEquals(l, rs.getLong(1));\n        assertEquals(l, rs.getLong(\"column\"));\n    }\n\n    /**\n     * Tests the setNullObject implementation.\n     */\n    public void testSetNullObject() throws SQLException {\n        assertNull(rs2.getNullObject());\n        // Set what gets returned to something other than the default\n        final Object o = new Object();\n        rs2.setNullObject(o);\n        assertNotNull(rs.getObject(1));\n        assertEquals(o, rs.getObject(1));\n        assertNotNull(rs.getObject(\"column\"));\n        assertEquals(o, rs.getObject(\"column\"));\n        assertNotNull(rs.getObject(1, (Map<String, Class<?>>) null));\n        assertEquals(o, rs.getObject(1, (Map<String, Class<?>>) null));\n        assertNotNull(rs.getObject(\"column\", (Map<String, Class<?>>) null));\n        assertEquals(o, rs.getObject(\"column\", (Map<String, Class<?>>) null));\n    }\n\n    /**\n     * Tests the setNullRef implementation.\n     */\n    public void testSetNullRef() throws SQLException {\n        assertNull(rs2.getNullRef());\n        // Set what gets returned to something other than the default\n        final Ref ref = new SqlNullCheckedResultSetMockRef();\n        rs2.setNullRef(ref);\n        assertNotNull(rs.getRef(1));\n        assertEquals(ref, rs.getRef(1));\n        assertNotNull(rs.getRef(\"column\"));\n        assertEquals(ref, rs.getRef(\"column\"));\n    }\n\n    /**\n     * Tests the setNullShort implementation.\n     */\n    public void testSetNullShort() throws SQLException {\n\n        assertEquals((short) 0, rs2.getNullShort());\n        // Set what gets returned to something other than the default\n        final short s = (short) 10;\n        rs2.setNullShort(s);\n        assertEquals(s, rs.getShort(1));\n        assertEquals(s, rs.getShort(\"column\"));\n\n    }\n\n    /**\n     * Tests the setNullString implementation.\n     */\n    public void testSetNullString() throws SQLException {\n        assertNull(rs2.getNullString());\n        // Set what gets returned to something other than the default\n        final String s = \"hello, world\";\n        rs2.setNullString(s);\n        assertEquals(s, rs.getString(1));\n        assertEquals(s, rs.getString(\"column\"));\n    }\n\n    /**\n     * Tests the setNullTime implementation.\n     */\n    public void testSetNullTime() throws SQLException {\n        // test the default, unset value\n        assertNull(rs2.getNullTime());\n\n        // test that setting null is safe\n        rs2.setNullTime(null);\n        assertNull(rs2.getNullTime());\n\n        // Set what gets returned to something other than the default\n        final Time time = new Time(new java.util.Date().getTime());\n        rs2.setNullTime(time);\n        assertNotNull(rs.getTime(1));\n        assertEquals(time, rs.getTime(1));\n        assertNotNull(rs.getTime(\"column\"));\n        assertEquals(time, rs.getTime(\"column\"));\n        assertNotNull(rs.getTime(1, Calendar.getInstance()));\n        assertEquals(time, rs.getTime(1, Calendar.getInstance()));\n        assertNotNull(rs.getTime(\"column\", Calendar.getInstance()));\n        assertEquals(time, rs.getTime(\"column\", Calendar.getInstance()));\n    }\n\n    /**\n     * Tests the setNullTimestamp implementation.\n     */\n    public void testSetNullTimestamp() throws SQLException {\n        // test the default, unset value\n        assertNull(rs2.getNullTimestamp());\n\n        // test that setting null is safe\n        rs2.setNullTimestamp(null);\n        assertNull(rs2.getNullTimestamp());\n\n        // Set what gets returned to something other than the default\n        final Timestamp ts = new Timestamp(new java.util.Date().getTime());\n        rs2.setNullTimestamp(ts);\n        assertNotNull(rs.getTimestamp(1));\n        assertEquals(ts, rs.getTimestamp(1));\n        assertNotNull(rs.getTimestamp(\"column\"));\n        assertEquals(ts, rs.getTimestamp(\"column\"));\n        assertNotNull(rs.getTimestamp(1, Calendar.getInstance()));\n        assertEquals(ts, rs.getTimestamp(1, Calendar.getInstance()));\n        assertNotNull(rs.getTimestamp(\"column\", Calendar.getInstance()));\n        assertEquals(ts, rs.getTimestamp(\"column\", Calendar.getInstance()));\n    }\n\n    /**\n     * Tests the getURL and setNullURL implementations.\n     */\n    public void testURL() throws SQLException, MalformedURLException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {\n        assertNull(rs.getURL(1));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getURL(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final URL u = new URL(\"http://www.apache.org\");\n        rs2.setNullURL(u);\n        assertEquals(u, rs.getURL(1));\n        assertEquals(u, rs.getURL(\"column\"));\n    }\n\n    public void testWrapResultSet() throws SQLException {\n        final ResultSet wrappedRs = mock(ResultSet.class);\n        final ResultSet rs = SqlNullCheckedResultSet.wrap(wrappedRs);\n        rs.beforeFirst();\n        verify(wrappedRs).beforeFirst();\n        rs.next();\n        verify(wrappedRs).next();\n    }\n}\n\nfinal class SqlNullUncheckedMockResultSet implements InvocationHandler {\n\n    /**\n     * Always return false for booleans, 0 for numerics, and null for Objects.\n     *\n     * @see java.lang.reflect.InvocationHandler#invoke(Object, java.lang.reflect.Method, Object[])\n     */\n    @Override\n    public Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable {\n\n        final Class<?> returnType = method.getReturnType();\n\n        if (method.getName().equals(\"wasNull\")) {\n            return Boolean.TRUE;\n\n        }\n        if (returnType.equals(Boolean.TYPE)) {\n            return Boolean.FALSE;\n\n        }\n        if (returnType.equals(Integer.TYPE)) {\n            return Integer.valueOf(0);\n\n        }\n        if (returnType.equals(Short.TYPE)) {\n            return Short.valueOf((short) 0);\n\n        }\n        if (returnType.equals(Double.TYPE)) {\n            return Double.valueOf(0);\n\n        }\n        if (returnType.equals(Long.TYPE)) {\n            return Long.valueOf(0);\n\n        }\n        if (returnType.equals(Byte.TYPE)) {\n            return Byte.valueOf((byte) 0);\n\n        }\n        if (returnType.equals(Float.TYPE)) {\n            return Float.valueOf(0);\n\n        }\n        return null;\n    }\n}\n", "file_hash": "c7728904a5d7f0f1d8321c109938b964102e7eeab676d462563b628b163c0fdc", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils.wrappers;", "import static org.mockito.Mockito.mock;", "import static org.mockito.Mockito.verify;", "import java.io.ByteArrayInputStream;", "import java.io.CharArrayReader;", "import java.io.InputStream;", "import java.io.OutputStream;", "import java.io.Reader;", "import java.io.Writer;", "import java.lang.reflect.InvocationHandler;", "import java.lang.reflect.InvocationTargetException;", "import java.lang.reflect.Method;", "import java.math.BigDecimal;", "import java.net.MalformedURLException;", "import java.net.URL;", "import java.sql.Blob;", "import java.sql.Clob;", "import java.sql.Ref;", "import java.sql.ResultSet;", "import java.sql.SQLException;", "import java.sql.Time;", "import java.sql.Timestamp;", "import java.util.Arrays;", "import java.util.Calendar;", "import java.util.Map;", "import org.apache.commons.dbutils.BaseTestCase;", "import org.apache.commons.dbutils.ProxyFactory;"], "methods": [], "classes": [{"original_string": "final class SqlNullCheckedResultSetMockBlob implements Blob {\n\n    /**\n     * @throws SQLException\n     */\n    @Override\n    public void free() throws SQLException {\n\n    }\n\n    @Override\n    public InputStream getBinaryStream() throws SQLException {\n        return new ByteArrayInputStream(new byte[0]);\n    }\n\n    /**\n     * @throws SQLException\n     */\n    @Override\n    public InputStream getBinaryStream(final long pos, final long length) throws SQLException {\n        return null;\n    }\n\n    @Override\n    public byte[] getBytes(final long param, final int param1) throws SQLException {\n        return new byte[0];\n    }\n\n    @Override\n    public long length() throws SQLException {\n        return 0;\n    }\n\n    @Override\n    public long position(final Blob blob, final long param) throws SQLException {\n        return 0;\n    }\n\n    @Override\n    public long position(final byte[] values, final long param) throws SQLException {\n        return 0;\n    }\n\n    @Override\n    public OutputStream setBinaryStream(final long pos) throws SQLException {\n        return null;\n    }\n\n    @Override\n    public int setBytes(final long pos, final byte[] bytes) throws SQLException {\n        return 0;\n    }\n\n    @Override\n    public int setBytes(final long pos, final byte[] bytes, final int offset, final int len) throws SQLException {\n        return 0;\n    }\n\n    @Override\n    public void truncate(final long len) throws SQLException {\n\n    }\n\n}", "definition": "final class SqlNullCheckedResultSetMockBlob implements Blob", "class_docstring": "", "name": "SqlNullCheckedResultSetMockBlob", "super_interfaces": ["Blob"], "superclasses": "", "attributes": {"modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Override\n    public void free() throws SQLException {\n\n    }", "docstring": "\n@throws SQLException\n", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "free", "params": [], "body": "                                           {\n\n    }", "signature": "@Override\n    public void free()"}, {"syntax_pass": true, "original_string": "    @Override\n    public InputStream getBinaryStream() throws SQLException {\n        return new ByteArrayInputStream(new byte[0]);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "InputStream", "classes": []}, "name": "getBinaryStream", "params": [], "body": "                                                             {\n        return new ByteArrayInputStream(new byte[0]);\n    }", "signature": "@Override\n    public InputStream getBinaryStream()"}, {"syntax_pass": true, "original_string": "    @Override\n    public InputStream getBinaryStream(final long pos, final long length) throws SQLException {\n        return null;\n    }", "docstring": "\n@throws SQLException\n", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "InputStream", "classes": []}, "name": "getBinaryStream", "params": [{"name": "pos", "type": "long"}, {"name": "length", "type": "long"}], "body": "                                                                                              {\n        return null;\n    }", "signature": "@Override\n    public InputStream getBinaryStream(final long pos, final long length)"}, {"syntax_pass": true, "original_string": "    @Override\n    public byte[] getBytes(final long param, final int param1) throws SQLException {\n        return new byte[0];\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "byte[]", "classes": []}, "name": "getBytes", "params": [{"name": "param", "type": "long"}, {"name": "param1", "type": "int"}], "body": "                                                                                   {\n        return new byte[0];\n    }", "signature": "@Override\n    public byte[] getBytes(final long param, final int param1)"}, {"syntax_pass": true, "original_string": "    @Override\n    public long length() throws SQLException {\n        return 0;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "long", "classes": []}, "name": "length", "params": [], "body": "                                             {\n        return 0;\n    }", "signature": "@Override\n    public long length()"}, {"syntax_pass": true, "original_string": "    @Override\n    public long position(final Blob blob, final long param) throws SQLException {\n        return 0;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "long", "classes": []}, "name": "position", "params": [{"name": "blob", "type": "Blob"}, {"name": "param", "type": "long"}], "body": "                                                                                {\n        return 0;\n    }", "signature": "@Override\n    public long position(final Blob blob, final long param)"}, {"syntax_pass": true, "original_string": "    @Override\n    public long position(final byte[] values, final long param) throws SQLException {\n        return 0;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "long", "classes": []}, "name": "position", "params": [{"name": "values", "type": "byte[]"}, {"name": "param", "type": "long"}], "body": "                                                                                    {\n        return 0;\n    }", "signature": "@Override\n    public long position(final byte[] values, final long param)"}, {"syntax_pass": true, "original_string": "    @Override\n    public OutputStream setBinaryStream(final long pos) throws SQLException {\n        return null;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "OutputStream", "classes": []}, "name": "setBinaryStream", "params": [{"name": "pos", "type": "long"}], "body": "                                                                            {\n        return null;\n    }", "signature": "@Override\n    public OutputStream setBinaryStream(final long pos)"}, {"syntax_pass": true, "original_string": "    @Override\n    public int setBytes(final long pos, final byte[] bytes) throws SQLException {\n        return 0;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "setBytes", "params": [{"name": "pos", "type": "long"}, {"name": "bytes", "type": "byte[]"}], "body": "                                                                                {\n        return 0;\n    }", "signature": "@Override\n    public int setBytes(final long pos, final byte[] bytes)"}, {"syntax_pass": true, "original_string": "    @Override\n    public int setBytes(final long pos, final byte[] bytes, final int offset, final int len) throws SQLException {\n        return 0;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "setBytes", "params": [{"name": "pos", "type": "long"}, {"name": "bytes", "type": "byte[]"}, {"name": "offset", "type": "int"}, {"name": "len", "type": "int"}], "body": "                                                                                                                 {\n        return 0;\n    }", "signature": "@Override\n    public int setBytes(final long pos, final byte[] bytes, final int offset, final int len)"}, {"syntax_pass": true, "original_string": "    @Override\n    public void truncate(final long len) throws SQLException {\n\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "truncate", "params": [{"name": "len", "type": "long"}], "body": "                                                             {\n\n    }", "signature": "@Override\n    public void truncate(final long len)"}]}, {"original_string": "final class SqlNullCheckedResultSetMockClob implements Clob {\n\n    /**\n     * @throws SQLException\n     */\n    @Override\n    public void free() throws SQLException {\n\n    }\n\n    @Override\n    public InputStream getAsciiStream() throws SQLException {\n        return null;\n    }\n\n    @Override\n    public Reader getCharacterStream() throws SQLException {\n        return null;\n    }\n\n    /**\n     * @throws SQLException\n     */\n    @Override\n    public Reader getCharacterStream(final long pos, final long length) throws SQLException {\n        return null;\n    }\n\n    @Override\n    public String getSubString(final long param, final int param1) throws SQLException {\n        return \"\";\n    }\n\n    @Override\n    public long length() throws SQLException {\n        return 0;\n    }\n\n    @Override\n    public long position(final Clob clob, final long param) throws SQLException {\n        return 0;\n    }\n\n    @Override\n    public long position(final String str, final long param) throws SQLException {\n        return 0;\n    }\n\n    @Override\n    public OutputStream setAsciiStream(final long pos) throws SQLException {\n        return null;\n    }\n\n    @Override\n    public Writer setCharacterStream(final long pos) throws SQLException {\n        return null;\n    }\n\n    @Override\n    public int setString(final long pos, final String str) throws SQLException {\n        return 0;\n    }\n\n    @Override\n    public int setString(final long pos, final String str, final int offset, final int len) throws SQLException {\n        return 0;\n    }\n\n    @Override\n    public void truncate(final long len) throws SQLException {\n\n    }\n\n}", "definition": "final class SqlNullCheckedResultSetMockClob implements Clob", "class_docstring": "", "name": "SqlNullCheckedResultSetMockClob", "super_interfaces": ["Clob"], "superclasses": "", "attributes": {"modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Override\n    public void free() throws SQLException {\n\n    }", "docstring": "\n@throws SQLException\n", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "free", "params": [], "body": "                                           {\n\n    }", "signature": "@Override\n    public void free()"}, {"syntax_pass": true, "original_string": "    @Override\n    public InputStream getAsciiStream() throws SQLException {\n        return null;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "InputStream", "classes": []}, "name": "getAsciiStream", "params": [], "body": "                                                            {\n        return null;\n    }", "signature": "@Override\n    public InputStream getAsciiStream()"}, {"syntax_pass": true, "original_string": "    @Override\n    public Reader getCharacterStream() throws SQLException {\n        return null;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Reader", "classes": []}, "name": "getCharacterStream", "params": [], "body": "                                                           {\n        return null;\n    }", "signature": "@Override\n    public Reader getCharacterStream()"}, {"syntax_pass": true, "original_string": "    @Override\n    public Reader getCharacterStream(final long pos, final long length) throws SQLException {\n        return null;\n    }", "docstring": "\n@throws SQLException\n", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Reader", "classes": []}, "name": "getCharacterStream", "params": [{"name": "pos", "type": "long"}, {"name": "length", "type": "long"}], "body": "                                                                                            {\n        return null;\n    }", "signature": "@Override\n    public Reader getCharacterStream(final long pos, final long length)"}, {"syntax_pass": true, "original_string": "    @Override\n    public String getSubString(final long param, final int param1) throws SQLException {\n        return \"\";\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getSubString", "params": [{"name": "param", "type": "long"}, {"name": "param1", "type": "int"}], "body": "                                                                                       {\n        return \"\";\n    }", "signature": "@Override\n    public String getSubString(final long param, final int param1)"}, {"syntax_pass": true, "original_string": "    @Override\n    public long length() throws SQLException {\n        return 0;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "long", "classes": []}, "name": "length", "params": [], "body": "                                             {\n        return 0;\n    }", "signature": "@Override\n    public long length()"}, {"syntax_pass": true, "original_string": "    @Override\n    public long position(final Clob clob, final long param) throws SQLException {\n        return 0;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "long", "classes": []}, "name": "position", "params": [{"name": "clob", "type": "Clob"}, {"name": "param", "type": "long"}], "body": "                                                                                {\n        return 0;\n    }", "signature": "@Override\n    public long position(final Clob clob, final long param)"}, {"syntax_pass": true, "original_string": "    @Override\n    public long position(final String str, final long param) throws SQLException {\n        return 0;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "long", "classes": []}, "name": "position", "params": [{"name": "str", "type": "String"}, {"name": "param", "type": "long"}], "body": "                                                                                 {\n        return 0;\n    }", "signature": "@Override\n    public long position(final String str, final long param)"}, {"syntax_pass": true, "original_string": "    @Override\n    public OutputStream setAsciiStream(final long pos) throws SQLException {\n        return null;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "OutputStream", "classes": []}, "name": "setAsciiStream", "params": [{"name": "pos", "type": "long"}], "body": "                                                                           {\n        return null;\n    }", "signature": "@Override\n    public OutputStream setAsciiStream(final long pos)"}, {"syntax_pass": true, "original_string": "    @Override\n    public Writer setCharacterStream(final long pos) throws SQLException {\n        return null;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Writer", "classes": []}, "name": "setCharacterStream", "params": [{"name": "pos", "type": "long"}], "body": "                                                                         {\n        return null;\n    }", "signature": "@Override\n    public Writer setCharacterStream(final long pos)"}, {"syntax_pass": true, "original_string": "    @Override\n    public int setString(final long pos, final String str) throws SQLException {\n        return 0;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "setString", "params": [{"name": "pos", "type": "long"}, {"name": "str", "type": "String"}], "body": "                                                                               {\n        return 0;\n    }", "signature": "@Override\n    public int setString(final long pos, final String str)"}, {"syntax_pass": true, "original_string": "    @Override\n    public int setString(final long pos, final String str, final int offset, final int len) throws SQLException {\n        return 0;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "setString", "params": [{"name": "pos", "type": "long"}, {"name": "str", "type": "String"}, {"name": "offset", "type": "int"}, {"name": "len", "type": "int"}], "body": "                                                                                                                {\n        return 0;\n    }", "signature": "@Override\n    public int setString(final long pos, final String str, final int offset, final int len)"}, {"syntax_pass": true, "original_string": "    @Override\n    public void truncate(final long len) throws SQLException {\n\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "truncate", "params": [{"name": "len", "type": "long"}], "body": "                                                             {\n\n    }", "signature": "@Override\n    public void truncate(final long len)"}]}, {"original_string": "final class SqlNullCheckedResultSetMockRef implements Ref {\n\n    @Override\n    public String getBaseTypeName() throws SQLException {\n        return \"\";\n    }\n\n    @Override\n    public Object getObject() throws SQLException {\n        return null;\n    }\n\n    @Override\n    public Object getObject(final Map<String, Class<?>> map) throws SQLException {\n        return null;\n    }\n\n    @Override\n    public void setObject(final Object value) throws SQLException {\n        // no-op\n    }\n\n}", "definition": "final class SqlNullCheckedResultSetMockRef implements Ref", "class_docstring": "", "name": "SqlNullCheckedResultSetMockRef", "super_interfaces": ["Ref"], "superclasses": "", "attributes": {"modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Override\n    public String getBaseTypeName() throws SQLException {\n        return \"\";\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getBaseTypeName", "params": [], "body": "                                                        {\n        return \"\";\n    }", "signature": "@Override\n    public String getBaseTypeName()"}, {"syntax_pass": true, "original_string": "    @Override\n    public Object getObject() throws SQLException {\n        return null;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object", "classes": []}, "name": "getObject", "params": [], "body": "                                                  {\n        return null;\n    }", "signature": "@Override\n    public Object getObject()"}, {"syntax_pass": true, "original_string": "    @Override\n    public Object getObject(final Map<String, Class<?>> map) throws SQLException {\n        return null;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object", "classes": []}, "name": "getObject", "params": [{"name": "map", "type": "Map<String, Class<?>>"}], "body": "                                                                                 {\n        return null;\n    }", "signature": "@Override\n    public Object getObject(final Map<String, Class<?>> map)"}, {"syntax_pass": true, "original_string": "    @Override\n    public void setObject(final Object value) throws SQLException {\n        // no-op\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setObject", "params": [{"name": "value", "type": "Object"}], "body": "                                                                  {\n        // no-op\n    }", "signature": "@Override\n    public void setObject(final Object value)"}]}, {"original_string": "public class SqlNullCheckedResultSetTest extends BaseTestCase {\n\n    private static ResultSet rs;\n\n    private static void assertArrayEquals(final byte[] expected, final byte[] actual) {\n        if (expected == actual) {\n            return;\n        }\n        if (expected.length != actual.length) {\n            failNotEquals(null, Arrays.toString(expected), Arrays.toString(actual));\n        }\n        for (int i = 0; i < expected.length; i++) {\n            final byte expectedItem = expected[i];\n            final byte actualItem = actual[i];\n            assertEquals(\"Array not equal at index \" + i, expectedItem, actualItem);\n        }\n    }\n    private SqlNullCheckedResultSet rs2;\n\n    /**\n     * Sets up instance variables required by this test case.\n     */\n    @Override\n    public void setUp() throws Exception {\n        super.setUp();\n\n        rs2 = new SqlNullCheckedResultSet(ProxyFactory.instance().createResultSet(new SqlNullUncheckedMockResultSet()));\n\n        setResultSet(ProxyFactory.instance().createResultSet(rs2)); // Override superclass field\n        rs = getResultSet();\n    }\n\n    /**\n     * Tests the getAsciiStream implementation.\n     */\n    public void testGetAsciiStream() throws SQLException {\n\n        assertNull(rs.getAsciiStream(1));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getAsciiStream(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final InputStream stream = new ByteArrayInputStream(new byte[0]);\n        rs2.setNullAsciiStream(stream);\n        assertNotNull(rs.getAsciiStream(1));\n        assertEquals(stream, rs.getAsciiStream(1));\n        assertNotNull(rs.getAsciiStream(\"column\"));\n        assertEquals(stream, rs.getAsciiStream(\"column\"));\n\n    }\n\n    /**\n     * Tests the getBigDecimal implementation.\n     */\n    public void testGetBigDecimal() throws SQLException {\n\n        assertNull(rs.getBigDecimal(1));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getBigDecimal(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final BigDecimal bd = new BigDecimal(5.0);\n        rs2.setNullBigDecimal(bd);\n        assertNotNull(rs.getBigDecimal(1));\n        assertEquals(bd, rs.getBigDecimal(1));\n        assertNotNull(rs.getBigDecimal(\"column\"));\n        assertEquals(bd, rs.getBigDecimal(\"column\"));\n\n    }\n\n    /**\n     * Tests the getBinaryStream implementation.\n     */\n    public void testGetBinaryStream() throws SQLException {\n\n        assertNull(rs.getBinaryStream(1));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getBinaryStream(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final InputStream stream = new ByteArrayInputStream(new byte[0]);\n        rs2.setNullBinaryStream(stream);\n        assertNotNull(rs.getBinaryStream(1));\n        assertEquals(stream, rs.getBinaryStream(1));\n        assertNotNull(rs.getBinaryStream(\"column\"));\n        assertEquals(stream, rs.getBinaryStream(\"column\"));\n\n    }\n\n    /**\n     * Tests the getBlob implementation.\n     */\n    public void testGetBlob() throws SQLException {\n\n        assertNull(rs.getBlob(1));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getBlob(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final Blob blob = new SqlNullCheckedResultSetMockBlob();\n        rs2.setNullBlob(blob);\n        assertNotNull(rs.getBlob(1));\n        assertEquals(blob, rs.getBlob(1));\n        assertNotNull(rs.getBlob(\"column\"));\n        assertEquals(blob, rs.getBlob(\"column\"));\n\n    }\n\n    /**\n     * Tests the getBoolean implementation.\n     */\n    public void testGetBoolean() throws SQLException {\n\n        assertFalse(rs.getBoolean(1));\n        assertTrue(rs.wasNull());\n        assertFalse(rs.getBoolean(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        rs2.setNullBoolean(true);\n        assertTrue( rs.getBoolean(1));\n        assertTrue( rs.getBoolean(\"column\"));\n\n    }\n\n    /**\n     * Tests the getByte implementation.\n     */\n    public void testGetByte() throws SQLException {\n\n        assertEquals((byte) 0, rs.getByte(1));\n        assertTrue(rs.wasNull());\n        assertEquals((byte) 0, rs.getByte(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final byte b = (byte) 10;\n        rs2.setNullByte(b);\n        assertEquals(b, rs.getByte(1));\n        assertEquals(b, rs.getByte(\"column\"));\n\n    }\n\n    /**\n     * Tests the getByte implementation.\n     */\n    public void testGetBytes() throws SQLException {\n\n        assertNull(rs.getBytes(1));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getBytes(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final byte[] b = new byte[5];\n        for (int i = 0; i < 5; i++) {\n            b[0] = (byte) i;\n        }\n        rs2.setNullBytes(b);\n        assertNotNull(rs.getBytes(1));\n        assertArrayEquals(b, rs.getBytes(1));\n        assertNotNull(rs.getBytes(\"column\"));\n        assertArrayEquals(b, rs.getBytes(\"column\"));\n\n    }\n\n    /**\n     * Tests the getCharacterStream implementation.\n     */\n    public void testGetCharacterStream() throws SQLException {\n\n        assertNull(rs.getCharacterStream(1));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getCharacterStream(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final Reader reader = new CharArrayReader(\"this is a string\".toCharArray());\n        rs2.setNullCharacterStream(reader);\n        assertNotNull(rs.getCharacterStream(1));\n        assertEquals(reader, rs.getCharacterStream(1));\n        assertNotNull(rs.getCharacterStream(\"column\"));\n        assertEquals(reader, rs.getCharacterStream(\"column\"));\n\n    }\n\n    /**\n     * Tests the getClob implementation.\n     */\n    public void testGetClob() throws SQLException {\n\n        assertNull(rs.getClob(1));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getClob(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final Clob clob = new SqlNullCheckedResultSetMockClob();\n        rs2.setNullClob(clob);\n        assertNotNull(rs.getClob(1));\n        assertEquals(clob, rs.getClob(1));\n        assertNotNull(rs.getClob(\"column\"));\n        assertEquals(clob, rs.getClob(\"column\"));\n\n    }\n\n    /**\n     * Tests the getDate implementation.\n     */\n    public void testGetDate() throws SQLException {\n\n        assertNull(rs.getDate(1));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getDate(\"column\"));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getDate(1, Calendar.getInstance()));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getDate(\"column\", Calendar.getInstance()));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final java.sql.Date date = new java.sql.Date(new java.util.Date().getTime());\n        rs2.setNullDate(date);\n        assertNotNull(rs.getDate(1));\n        assertEquals(date, rs.getDate(1));\n        assertNotNull(rs.getDate(\"column\"));\n        assertEquals(date, rs.getDate(\"column\"));\n        assertNotNull(rs.getDate(1, Calendar.getInstance()));\n        assertEquals(date, rs.getDate(1, Calendar.getInstance()));\n        assertNotNull(rs.getDate(\"column\", Calendar.getInstance()));\n        assertEquals(date, rs.getDate(\"column\", Calendar.getInstance()));\n\n    }\n\n    /**\n     * Tests the getDouble implementation.\n     */\n    public void testGetDouble() throws SQLException {\n\n        assertEquals(0.0, rs.getDouble(1), 0.0);\n        assertTrue(rs.wasNull());\n        assertEquals(0.0, rs.getDouble(\"column\"), 0.0);\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final double d = 10.0;\n        rs2.setNullDouble(d);\n        assertEquals(d, rs.getDouble(1), 0.0);\n        assertEquals(d, rs.getDouble(\"column\"), 0.0);\n\n    }\n\n    /**\n     * Tests the getFloat implementation.\n     */\n    public void testGetFloat() throws SQLException {\n        assertEquals(0, rs.getFloat(1), 0.0);\n        assertTrue(rs.wasNull());\n        assertEquals(0, rs.getFloat(\"column\"), 0.0);\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final float f = 10;\n        rs2.setNullFloat(f);\n        assertEquals(f, rs.getFloat(1), 0.0);\n        assertEquals(f, rs.getFloat(\"column\"), 0.0);\n    }\n\n    /**\n     * Tests the getInt implementation.\n     */\n    public void testGetInt() throws SQLException {\n        assertEquals(0, rs.getInt(1));\n        assertTrue(rs.wasNull());\n        assertEquals(0, rs.getInt(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final int i = 10;\n        rs2.setNullInt(i);\n        assertEquals(i, rs.getInt(1));\n        assertEquals(i, rs.getInt(\"column\"));\n    }\n\n    /**\n     * Tests the getLong implementation.\n     */\n    public void testGetLong() throws SQLException {\n        assertEquals(0, rs.getLong(1));\n        assertTrue(rs.wasNull());\n        assertEquals(0, rs.getLong(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final long l = 10;\n        rs2.setNullLong(l);\n        assertEquals(l, rs.getLong(1));\n        assertEquals(l, rs.getLong(\"column\"));\n    }\n\n    /**\n     * Tests the getObject implementation.\n     */\n    public void testGetObject() throws SQLException {\n\n        assertNull(rs.getObject(1));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getObject(\"column\"));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getObject(1, (Map<String, Class<?>>) null));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getObject(\"column\", (Map<String, Class<?>>) null));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final Object o = new Object();\n        rs2.setNullObject(o);\n        assertNotNull(rs.getObject(1));\n        assertEquals(o, rs.getObject(1));\n        assertNotNull(rs.getObject(\"column\"));\n        assertEquals(o, rs.getObject(\"column\"));\n        assertNotNull(rs.getObject(1, (Map<String, Class<?>>) null));\n        assertEquals(o, rs.getObject(1, (Map<String, Class<?>>) null));\n        assertNotNull(rs.getObject(\"column\", (Map<String, Class<?>>) null));\n        assertEquals(o, rs.getObject(\"column\", (Map<String, Class<?>>) null));\n\n    }\n\n    /**\n     * Tests the getRef implementation.\n     */\n    public void testGetRef() throws SQLException {\n\n        assertNull(rs.getRef(1));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getRef(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final Ref ref = new SqlNullCheckedResultSetMockRef();\n        rs2.setNullRef(ref);\n        assertNotNull(rs.getRef(1));\n        assertEquals(ref, rs.getRef(1));\n        assertNotNull(rs.getRef(\"column\"));\n        assertEquals(ref, rs.getRef(\"column\"));\n\n    }\n\n    /**\n     * Tests the getShort implementation.\n     */\n    public void testGetShort() throws SQLException {\n\n        assertEquals((short) 0, rs.getShort(1));\n        assertTrue(rs.wasNull());\n        assertEquals((short) 0, rs.getShort(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final short s = (short) 10;\n        rs2.setNullShort(s);\n        assertEquals(s, rs.getShort(1));\n        assertEquals(s, rs.getShort(\"column\"));\n    }\n\n    /**\n     * Tests the getString implementation.\n     */\n    public void testGetString() throws SQLException {\n        assertNull(rs.getString(1));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getString(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final String s = \"hello, world\";\n        rs2.setNullString(s);\n        assertEquals(s, rs.getString(1));\n        assertEquals(s, rs.getString(\"column\"));\n    }\n\n    /**\n     * Tests the getTime implementation.\n     */\n    public void testGetTime() throws SQLException {\n\n        assertNull(rs.getTime(1));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getTime(\"column\"));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getTime(1, Calendar.getInstance()));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getTime(\"column\", Calendar.getInstance()));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final Time time = new Time(new java.util.Date().getTime());\n        rs2.setNullTime(time);\n        assertNotNull(rs.getTime(1));\n        assertEquals(time, rs.getTime(1));\n        assertNotNull(rs.getTime(\"column\"));\n        assertEquals(time, rs.getTime(\"column\"));\n        assertNotNull(rs.getTime(1, Calendar.getInstance()));\n        assertEquals(time, rs.getTime(1, Calendar.getInstance()));\n        assertNotNull(rs.getTime(\"column\", Calendar.getInstance()));\n        assertEquals(time, rs.getTime(\"column\", Calendar.getInstance()));\n\n    }\n\n    /**\n     * Tests the getTimestamp implementation.\n     */\n    public void testGetTimestamp() throws SQLException {\n\n        assertNull(rs.getTimestamp(1));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getTimestamp(\"column\"));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getTimestamp(1, Calendar.getInstance()));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getTimestamp(\"column\", Calendar.getInstance()));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final Timestamp ts = new Timestamp(new java.util.Date().getTime());\n        rs2.setNullTimestamp(ts);\n        assertNotNull(rs.getTimestamp(1));\n        assertEquals(ts, rs.getTimestamp(1));\n        assertNotNull(rs.getTimestamp(\"column\"));\n        assertEquals(ts, rs.getTimestamp(\"column\"));\n        assertNotNull(rs.getTimestamp(1, Calendar.getInstance()));\n        assertEquals(ts, rs.getTimestamp(1, Calendar.getInstance()));\n        assertNotNull(rs.getTimestamp(\"column\", Calendar.getInstance()));\n        assertEquals(ts, rs.getTimestamp(\"column\", Calendar.getInstance()));\n    }\n\n    /**\n     * Tests the setNullAsciiStream implementation.\n     */\n    public void testSetNullAsciiStream() throws SQLException {\n\n        assertNull(rs2.getNullAsciiStream());\n        // Set what gets returned to something other than the default\n        final InputStream stream = new ByteArrayInputStream(new byte[0]);\n        rs2.setNullAsciiStream(stream);\n        assertNotNull(rs.getAsciiStream(1));\n        assertEquals(stream, rs.getAsciiStream(1));\n        assertNotNull(rs.getAsciiStream(\"column\"));\n        assertEquals(stream, rs.getAsciiStream(\"column\"));\n\n    }\n\n    /**\n     * Tests the setNullBigDecimal implementation.\n     */\n    public void testSetNullBigDecimal() throws SQLException {\n\n        assertNull(rs2.getNullBigDecimal());\n        // Set what gets returned to something other than the default\n        final BigDecimal bd = new BigDecimal(5.0);\n        rs2.setNullBigDecimal(bd);\n        assertNotNull(rs.getBigDecimal(1));\n        assertEquals(bd, rs.getBigDecimal(1));\n        assertNotNull(rs.getBigDecimal(\"column\"));\n        assertEquals(bd, rs.getBigDecimal(\"column\"));\n\n    }\n\n    /**\n     * Tests the setNullBinaryStream implementation.\n     */\n    public void testSetNullBinaryStream() throws SQLException {\n\n        assertNull(rs2.getNullBinaryStream());\n        // Set what gets returned to something other than the default\n        final InputStream stream = new ByteArrayInputStream(new byte[0]);\n        rs2.setNullBinaryStream(stream);\n        assertNotNull(rs.getBinaryStream(1));\n        assertEquals(stream, rs.getBinaryStream(1));\n        assertNotNull(rs.getBinaryStream(\"column\"));\n        assertEquals(stream, rs.getBinaryStream(\"column\"));\n\n    }\n\n    /**\n     * Tests the setNullBlob implementation.\n     */\n    public void testSetNullBlob() throws SQLException {\n\n        assertNull(rs2.getNullBlob());\n        // Set what gets returned to something other than the default\n        final Blob blob = new SqlNullCheckedResultSetMockBlob();\n        rs2.setNullBlob(blob);\n        assertNotNull(rs.getBlob(1));\n        assertEquals(blob, rs.getBlob(1));\n        assertNotNull(rs.getBlob(\"column\"));\n        assertEquals(blob, rs.getBlob(\"column\"));\n\n    }\n\n    /**\n     * Tests the setNullBoolean implementation.\n     */\n    public void testSetNullBoolean() throws SQLException {\n\n        assertFalse(rs2.getNullBoolean());\n        // Set what gets returned to something other than the default\n        rs2.setNullBoolean(true);\n        assertTrue( rs.getBoolean(1));\n        assertTrue( rs.getBoolean(\"column\"));\n\n    }\n\n    /**\n     * Tests the setNullByte implementation.\n     */\n    public void testSetNullByte() throws SQLException {\n\n        assertEquals((byte) 0, rs2.getNullByte());\n        // Set what gets returned to something other than the default\n        final byte b = (byte) 10;\n        rs2.setNullByte(b);\n        assertEquals(b, rs.getByte(1));\n        assertEquals(b, rs.getByte(\"column\"));\n\n    }\n\n    /**\n     * Tests the setNullByte implementation.\n     */\n    public void testSetNullBytes() throws SQLException {\n        // test the default, unset value\n        assertNull(rs2.getNullBytes());\n\n        // test that setting null is safe\n        rs2.setNullBytes(null);\n        assertNull(rs2.getNullBytes());\n\n        // Set what gets returned to something other than the default\n        final byte[] b = new byte[5];\n        for (int i = 0; i < 5; i++) {\n            b[0] = (byte) i;\n        }\n        rs2.setNullBytes(b);\n        assertNotNull(rs.getBytes(1));\n        assertArrayEquals(b, rs.getBytes(1));\n        assertNotNull(rs.getBytes(\"column\"));\n        assertArrayEquals(b, rs.getBytes(\"column\"));\n\n    }\n\n    /**\n     * Tests the setNullCharacterStream implementation.\n     */\n    public void testSetNullCharacterStream() throws SQLException {\n\n        assertNull(rs2.getNullCharacterStream());\n        // Set what gets returned to something other than the default\n        final Reader reader = new CharArrayReader(\"this is a string\".toCharArray());\n        rs2.setNullCharacterStream(reader);\n        assertNotNull(rs.getCharacterStream(1));\n        assertEquals(reader, rs.getCharacterStream(1));\n        assertNotNull(rs.getCharacterStream(\"column\"));\n        assertEquals(reader, rs.getCharacterStream(\"column\"));\n\n    }\n\n    /**\n     * Tests the setNullClob implementation.\n     */\n    public void testSetNullClob() throws SQLException {\n\n        assertNull(rs2.getNullClob());\n        // Set what gets returned to something other than the default\n        final Clob clob = new SqlNullCheckedResultSetMockClob();\n        rs2.setNullClob(clob);\n        assertNotNull(rs.getClob(1));\n        assertEquals(clob, rs.getClob(1));\n        assertNotNull(rs.getClob(\"column\"));\n        assertEquals(clob, rs.getClob(\"column\"));\n\n    }\n\n    /**\n     * Tests the setNullDate implementation.\n     */\n    public void testSetNullDate() throws SQLException {\n        // test the default, unset value\n        assertNull(rs2.getNullDate());\n\n        // test that setting null is safe\n        rs2.setNullDate(null);\n        assertNull(rs2.getNullDate());\n\n        // Set what gets returned to something other than the default\n        final java.sql.Date date = new java.sql.Date(new java.util.Date().getTime());\n        rs2.setNullDate(date);\n        assertNotNull(rs.getDate(1));\n        assertEquals(date, rs.getDate(1));\n        assertNotNull(rs.getDate(\"column\"));\n        assertEquals(date, rs.getDate(\"column\"));\n        assertNotNull(rs.getDate(1, Calendar.getInstance()));\n        assertEquals(date, rs.getDate(1, Calendar.getInstance()));\n        assertNotNull(rs.getDate(\"column\", Calendar.getInstance()));\n        assertEquals(date, rs.getDate(\"column\", Calendar.getInstance()));\n\n    }\n\n    /**\n     * Tests the setNullDouble implementation.\n     */\n    public void testSetNullDouble() throws SQLException {\n        assertEquals(0.0, rs2.getNullDouble(), 0.0);\n        // Set what gets returned to something other than the default\n        final double d = 10.0;\n        rs2.setNullDouble(d);\n        assertEquals(d, rs.getDouble(1), 0.0);\n        assertEquals(d, rs.getDouble(\"column\"), 0.0);\n    }\n\n    /**\n     * Tests the setNullFloat implementation.\n     */\n    public void testSetNullFloat() throws SQLException {\n        assertEquals((float) 0.0, rs2.getNullFloat(), 0.0);\n        // Set what gets returned to something other than the default\n        final float f = (float) 10.0;\n        rs2.setNullFloat(f);\n        assertEquals(f, rs.getFloat(1), 0.0);\n        assertEquals(f, rs.getFloat(\"column\"), 0.0);\n    }\n\n    /**\n     * Tests the setNullInt implementation.\n     */\n    public void testSetNullInt() throws SQLException {\n        assertEquals(0, rs2.getNullInt());\n        assertEquals(0, rs.getInt(1));\n        assertTrue(rs.wasNull());\n        assertEquals(0, rs.getInt(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final int i = 10;\n        rs2.setNullInt(i);\n        assertEquals(i, rs.getInt(1));\n        assertEquals(i, rs.getInt(\"column\"));\n    }\n\n    /**\n     * Tests the setNullLong implementation.\n     */\n    public void testSetNullLong() throws SQLException {\n        assertEquals(0, rs2.getNullLong());\n        // Set what gets returned to something other than the default\n        final long l = 10;\n        rs2.setNullLong(l);\n        assertEquals(l, rs.getLong(1));\n        assertEquals(l, rs.getLong(\"column\"));\n    }\n\n    /**\n     * Tests the setNullObject implementation.\n     */\n    public void testSetNullObject() throws SQLException {\n        assertNull(rs2.getNullObject());\n        // Set what gets returned to something other than the default\n        final Object o = new Object();\n        rs2.setNullObject(o);\n        assertNotNull(rs.getObject(1));\n        assertEquals(o, rs.getObject(1));\n        assertNotNull(rs.getObject(\"column\"));\n        assertEquals(o, rs.getObject(\"column\"));\n        assertNotNull(rs.getObject(1, (Map<String, Class<?>>) null));\n        assertEquals(o, rs.getObject(1, (Map<String, Class<?>>) null));\n        assertNotNull(rs.getObject(\"column\", (Map<String, Class<?>>) null));\n        assertEquals(o, rs.getObject(\"column\", (Map<String, Class<?>>) null));\n    }\n\n    /**\n     * Tests the setNullRef implementation.\n     */\n    public void testSetNullRef() throws SQLException {\n        assertNull(rs2.getNullRef());\n        // Set what gets returned to something other than the default\n        final Ref ref = new SqlNullCheckedResultSetMockRef();\n        rs2.setNullRef(ref);\n        assertNotNull(rs.getRef(1));\n        assertEquals(ref, rs.getRef(1));\n        assertNotNull(rs.getRef(\"column\"));\n        assertEquals(ref, rs.getRef(\"column\"));\n    }\n\n    /**\n     * Tests the setNullShort implementation.\n     */\n    public void testSetNullShort() throws SQLException {\n\n        assertEquals((short) 0, rs2.getNullShort());\n        // Set what gets returned to something other than the default\n        final short s = (short) 10;\n        rs2.setNullShort(s);\n        assertEquals(s, rs.getShort(1));\n        assertEquals(s, rs.getShort(\"column\"));\n\n    }\n\n    /**\n     * Tests the setNullString implementation.\n     */\n    public void testSetNullString() throws SQLException {\n        assertNull(rs2.getNullString());\n        // Set what gets returned to something other than the default\n        final String s = \"hello, world\";\n        rs2.setNullString(s);\n        assertEquals(s, rs.getString(1));\n        assertEquals(s, rs.getString(\"column\"));\n    }\n\n    /**\n     * Tests the setNullTime implementation.\n     */\n    public void testSetNullTime() throws SQLException {\n        // test the default, unset value\n        assertNull(rs2.getNullTime());\n\n        // test that setting null is safe\n        rs2.setNullTime(null);\n        assertNull(rs2.getNullTime());\n\n        // Set what gets returned to something other than the default\n        final Time time = new Time(new java.util.Date().getTime());\n        rs2.setNullTime(time);\n        assertNotNull(rs.getTime(1));\n        assertEquals(time, rs.getTime(1));\n        assertNotNull(rs.getTime(\"column\"));\n        assertEquals(time, rs.getTime(\"column\"));\n        assertNotNull(rs.getTime(1, Calendar.getInstance()));\n        assertEquals(time, rs.getTime(1, Calendar.getInstance()));\n        assertNotNull(rs.getTime(\"column\", Calendar.getInstance()));\n        assertEquals(time, rs.getTime(\"column\", Calendar.getInstance()));\n    }\n\n    /**\n     * Tests the setNullTimestamp implementation.\n     */\n    public void testSetNullTimestamp() throws SQLException {\n        // test the default, unset value\n        assertNull(rs2.getNullTimestamp());\n\n        // test that setting null is safe\n        rs2.setNullTimestamp(null);\n        assertNull(rs2.getNullTimestamp());\n\n        // Set what gets returned to something other than the default\n        final Timestamp ts = new Timestamp(new java.util.Date().getTime());\n        rs2.setNullTimestamp(ts);\n        assertNotNull(rs.getTimestamp(1));\n        assertEquals(ts, rs.getTimestamp(1));\n        assertNotNull(rs.getTimestamp(\"column\"));\n        assertEquals(ts, rs.getTimestamp(\"column\"));\n        assertNotNull(rs.getTimestamp(1, Calendar.getInstance()));\n        assertEquals(ts, rs.getTimestamp(1, Calendar.getInstance()));\n        assertNotNull(rs.getTimestamp(\"column\", Calendar.getInstance()));\n        assertEquals(ts, rs.getTimestamp(\"column\", Calendar.getInstance()));\n    }\n\n    /**\n     * Tests the getURL and setNullURL implementations.\n     */\n    public void testURL() throws SQLException, MalformedURLException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {\n        assertNull(rs.getURL(1));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getURL(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final URL u = new URL(\"http://www.apache.org\");\n        rs2.setNullURL(u);\n        assertEquals(u, rs.getURL(1));\n        assertEquals(u, rs.getURL(\"column\"));\n    }\n\n    public void testWrapResultSet() throws SQLException {\n        final ResultSet wrappedRs = mock(ResultSet.class);\n        final ResultSet rs = SqlNullCheckedResultSet.wrap(wrappedRs);\n        rs.beforeFirst();\n        verify(wrappedRs).beforeFirst();\n        rs.next();\n        verify(wrappedRs).next();\n    }\n}", "definition": "public class SqlNullCheckedResultSetTest extends BaseTestCase", "class_docstring": "\nTest cases for {@code SqlNullCheckedResultSet} class.\n", "name": "SqlNullCheckedResultSetTest", "super_interfaces": [], "superclasses": "BaseTestCase", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private static ResultSet rs;", "docstring": "", "modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "type": "ResultSet", "name": "rs", "syntax_pass": true}, {"attribute_expression": "private SqlNullCheckedResultSet rs2;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "SqlNullCheckedResultSet", "name": "rs2", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    private static void assertArrayEquals(final byte[] expected, final byte[] actual) {\n        if (expected == actual) {\n            return;\n        }\n        if (expected.length != actual.length) {\n            failNotEquals(null, Arrays.toString(expected), Arrays.toString(actual));\n        }\n        for (int i = 0; i < expected.length; i++) {\n            final byte expectedItem = expected[i];\n            final byte actualItem = actual[i];\n            assertEquals(\"Array not equal at index \" + i, expectedItem, actualItem);\n        }\n    }", "docstring": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "assertArrayEquals", "params": [{"name": "expected", "type": "byte[]"}, {"name": "actual", "type": "byte[]"}], "body": "                                                                                      {\n        if (expected == actual) {\n            return;\n        }\n        if (expected.length != actual.length) {\n            failNotEquals(null, Arrays.toString(expected), Arrays.toString(actual));\n        }\n        for (int i = 0; i < expected.length; i++) {\n            final byte expectedItem = expected[i];\n            final byte actualItem = actual[i];\n            assertEquals(\"Array not equal at index \" + i, expectedItem, actualItem);\n        }\n    }", "signature": "private static void assertArrayEquals(final byte[] expected, final byte[] actual)"}, {"syntax_pass": true, "original_string": "    @Override\n    public void setUp() throws Exception {\n        super.setUp();\n\n        rs2 = new SqlNullCheckedResultSet(ProxyFactory.instance().createResultSet(new SqlNullUncheckedMockResultSet()));\n\n        setResultSet(ProxyFactory.instance().createResultSet(rs2)); // Override superclass field\n        rs = getResultSet();\n    }", "docstring": "\nSets up instance variables required by this test case.\n", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setUp", "params": [], "body": "                                         {\n        super.setUp();\n\n        rs2 = new SqlNullCheckedResultSet(ProxyFactory.instance().createResultSet(new SqlNullUncheckedMockResultSet()));\n\n        setResultSet(ProxyFactory.instance().createResultSet(rs2)); // Override superclass field\n        rs = getResultSet();\n    }", "signature": "@Override\n    public void setUp()"}, {"syntax_pass": true, "original_string": "    public void testGetAsciiStream() throws SQLException {\n\n        assertNull(rs.getAsciiStream(1));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getAsciiStream(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final InputStream stream = new ByteArrayInputStream(new byte[0]);\n        rs2.setNullAsciiStream(stream);\n        assertNotNull(rs.getAsciiStream(1));\n        assertEquals(stream, rs.getAsciiStream(1));\n        assertNotNull(rs.getAsciiStream(\"column\"));\n        assertEquals(stream, rs.getAsciiStream(\"column\"));\n\n    }", "docstring": "\nTests the getAsciiStream implementation.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGetAsciiStream", "params": [], "body": "                                                         {\n\n        assertNull(rs.getAsciiStream(1));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getAsciiStream(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final InputStream stream = new ByteArrayInputStream(new byte[0]);\n        rs2.setNullAsciiStream(stream);\n        assertNotNull(rs.getAsciiStream(1));\n        assertEquals(stream, rs.getAsciiStream(1));\n        assertNotNull(rs.getAsciiStream(\"column\"));\n        assertEquals(stream, rs.getAsciiStream(\"column\"));\n\n    }", "signature": "public void testGetAsciiStream()"}, {"syntax_pass": true, "original_string": "    public void testGetBigDecimal() throws SQLException {\n\n        assertNull(rs.getBigDecimal(1));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getBigDecimal(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final BigDecimal bd = new BigDecimal(5.0);\n        rs2.setNullBigDecimal(bd);\n        assertNotNull(rs.getBigDecimal(1));\n        assertEquals(bd, rs.getBigDecimal(1));\n        assertNotNull(rs.getBigDecimal(\"column\"));\n        assertEquals(bd, rs.getBigDecimal(\"column\"));\n\n    }", "docstring": "\nTests the getBigDecimal implementation.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGetBigDecimal", "params": [], "body": "                                                        {\n\n        assertNull(rs.getBigDecimal(1));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getBigDecimal(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final BigDecimal bd = new BigDecimal(5.0);\n        rs2.setNullBigDecimal(bd);\n        assertNotNull(rs.getBigDecimal(1));\n        assertEquals(bd, rs.getBigDecimal(1));\n        assertNotNull(rs.getBigDecimal(\"column\"));\n        assertEquals(bd, rs.getBigDecimal(\"column\"));\n\n    }", "signature": "public void testGetBigDecimal()"}, {"syntax_pass": true, "original_string": "    public void testGetBinaryStream() throws SQLException {\n\n        assertNull(rs.getBinaryStream(1));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getBinaryStream(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final InputStream stream = new ByteArrayInputStream(new byte[0]);\n        rs2.setNullBinaryStream(stream);\n        assertNotNull(rs.getBinaryStream(1));\n        assertEquals(stream, rs.getBinaryStream(1));\n        assertNotNull(rs.getBinaryStream(\"column\"));\n        assertEquals(stream, rs.getBinaryStream(\"column\"));\n\n    }", "docstring": "\nTests the getBinaryStream implementation.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGetBinaryStream", "params": [], "body": "                                                          {\n\n        assertNull(rs.getBinaryStream(1));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getBinaryStream(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final InputStream stream = new ByteArrayInputStream(new byte[0]);\n        rs2.setNullBinaryStream(stream);\n        assertNotNull(rs.getBinaryStream(1));\n        assertEquals(stream, rs.getBinaryStream(1));\n        assertNotNull(rs.getBinaryStream(\"column\"));\n        assertEquals(stream, rs.getBinaryStream(\"column\"));\n\n    }", "signature": "public void testGetBinaryStream()"}, {"syntax_pass": true, "original_string": "    public void testGetBlob() throws SQLException {\n\n        assertNull(rs.getBlob(1));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getBlob(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final Blob blob = new SqlNullCheckedResultSetMockBlob();\n        rs2.setNullBlob(blob);\n        assertNotNull(rs.getBlob(1));\n        assertEquals(blob, rs.getBlob(1));\n        assertNotNull(rs.getBlob(\"column\"));\n        assertEquals(blob, rs.getBlob(\"column\"));\n\n    }", "docstring": "\nTests the getBlob implementation.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGetBlob", "params": [], "body": "                                                  {\n\n        assertNull(rs.getBlob(1));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getBlob(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final Blob blob = new SqlNullCheckedResultSetMockBlob();\n        rs2.setNullBlob(blob);\n        assertNotNull(rs.getBlob(1));\n        assertEquals(blob, rs.getBlob(1));\n        assertNotNull(rs.getBlob(\"column\"));\n        assertEquals(blob, rs.getBlob(\"column\"));\n\n    }", "signature": "public void testGetBlob()"}, {"syntax_pass": true, "original_string": "    public void testGetBoolean() throws SQLException {\n\n        assertFalse(rs.getBoolean(1));\n        assertTrue(rs.wasNull());\n        assertFalse(rs.getBoolean(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        rs2.setNullBoolean(true);\n        assertTrue( rs.getBoolean(1));\n        assertTrue( rs.getBoolean(\"column\"));\n\n    }", "docstring": "\nTests the getBoolean implementation.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGetBoolean", "params": [], "body": "                                                     {\n\n        assertFalse(rs.getBoolean(1));\n        assertTrue(rs.wasNull());\n        assertFalse(rs.getBoolean(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        rs2.setNullBoolean(true);\n        assertTrue( rs.getBoolean(1));\n        assertTrue( rs.getBoolean(\"column\"));\n\n    }", "signature": "public void testGetBoolean()"}, {"syntax_pass": true, "original_string": "    public void testGetByte() throws SQLException {\n\n        assertEquals((byte) 0, rs.getByte(1));\n        assertTrue(rs.wasNull());\n        assertEquals((byte) 0, rs.getByte(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final byte b = (byte) 10;\n        rs2.setNullByte(b);\n        assertEquals(b, rs.getByte(1));\n        assertEquals(b, rs.getByte(\"column\"));\n\n    }", "docstring": "\nTests the getByte implementation.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGetByte", "params": [], "body": "                                                  {\n\n        assertEquals((byte) 0, rs.getByte(1));\n        assertTrue(rs.wasNull());\n        assertEquals((byte) 0, rs.getByte(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final byte b = (byte) 10;\n        rs2.setNullByte(b);\n        assertEquals(b, rs.getByte(1));\n        assertEquals(b, rs.getByte(\"column\"));\n\n    }", "signature": "public void testGetByte()"}, {"syntax_pass": true, "original_string": "    public void testGetBytes() throws SQLException {\n\n        assertNull(rs.getBytes(1));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getBytes(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final byte[] b = new byte[5];\n        for (int i = 0; i < 5; i++) {\n            b[0] = (byte) i;\n        }\n        rs2.setNullBytes(b);\n        assertNotNull(rs.getBytes(1));\n        assertArrayEquals(b, rs.getBytes(1));\n        assertNotNull(rs.getBytes(\"column\"));\n        assertArrayEquals(b, rs.getBytes(\"column\"));\n\n    }", "docstring": "\nTests the getByte implementation.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGetBytes", "params": [], "body": "                                                   {\n\n        assertNull(rs.getBytes(1));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getBytes(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final byte[] b = new byte[5];\n        for (int i = 0; i < 5; i++) {\n            b[0] = (byte) i;\n        }\n        rs2.setNullBytes(b);\n        assertNotNull(rs.getBytes(1));\n        assertArrayEquals(b, rs.getBytes(1));\n        assertNotNull(rs.getBytes(\"column\"));\n        assertArrayEquals(b, rs.getBytes(\"column\"));\n\n    }", "signature": "public void testGetBytes()"}, {"syntax_pass": true, "original_string": "    public void testGetCharacterStream() throws SQLException {\n\n        assertNull(rs.getCharacterStream(1));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getCharacterStream(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final Reader reader = new CharArrayReader(\"this is a string\".toCharArray());\n        rs2.setNullCharacterStream(reader);\n        assertNotNull(rs.getCharacterStream(1));\n        assertEquals(reader, rs.getCharacterStream(1));\n        assertNotNull(rs.getCharacterStream(\"column\"));\n        assertEquals(reader, rs.getCharacterStream(\"column\"));\n\n    }", "docstring": "\nTests the getCharacterStream implementation.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGetCharacterStream", "params": [], "body": "                                                             {\n\n        assertNull(rs.getCharacterStream(1));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getCharacterStream(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final Reader reader = new CharArrayReader(\"this is a string\".toCharArray());\n        rs2.setNullCharacterStream(reader);\n        assertNotNull(rs.getCharacterStream(1));\n        assertEquals(reader, rs.getCharacterStream(1));\n        assertNotNull(rs.getCharacterStream(\"column\"));\n        assertEquals(reader, rs.getCharacterStream(\"column\"));\n\n    }", "signature": "public void testGetCharacterStream()"}, {"syntax_pass": true, "original_string": "    public void testGetClob() throws SQLException {\n\n        assertNull(rs.getClob(1));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getClob(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final Clob clob = new SqlNullCheckedResultSetMockClob();\n        rs2.setNullClob(clob);\n        assertNotNull(rs.getClob(1));\n        assertEquals(clob, rs.getClob(1));\n        assertNotNull(rs.getClob(\"column\"));\n        assertEquals(clob, rs.getClob(\"column\"));\n\n    }", "docstring": "\nTests the getClob implementation.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGetClob", "params": [], "body": "                                                  {\n\n        assertNull(rs.getClob(1));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getClob(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final Clob clob = new SqlNullCheckedResultSetMockClob();\n        rs2.setNullClob(clob);\n        assertNotNull(rs.getClob(1));\n        assertEquals(clob, rs.getClob(1));\n        assertNotNull(rs.getClob(\"column\"));\n        assertEquals(clob, rs.getClob(\"column\"));\n\n    }", "signature": "public void testGetClob()"}, {"syntax_pass": true, "original_string": "    public void testGetDate() throws SQLException {\n\n        assertNull(rs.getDate(1));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getDate(\"column\"));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getDate(1, Calendar.getInstance()));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getDate(\"column\", Calendar.getInstance()));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final java.sql.Date date = new java.sql.Date(new java.util.Date().getTime());\n        rs2.setNullDate(date);\n        assertNotNull(rs.getDate(1));\n        assertEquals(date, rs.getDate(1));\n        assertNotNull(rs.getDate(\"column\"));\n        assertEquals(date, rs.getDate(\"column\"));\n        assertNotNull(rs.getDate(1, Calendar.getInstance()));\n        assertEquals(date, rs.getDate(1, Calendar.getInstance()));\n        assertNotNull(rs.getDate(\"column\", Calendar.getInstance()));\n        assertEquals(date, rs.getDate(\"column\", Calendar.getInstance()));\n\n    }", "docstring": "\nTests the getDate implementation.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGetDate", "params": [], "body": "                                                  {\n\n        assertNull(rs.getDate(1));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getDate(\"column\"));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getDate(1, Calendar.getInstance()));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getDate(\"column\", Calendar.getInstance()));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final java.sql.Date date = new java.sql.Date(new java.util.Date().getTime());\n        rs2.setNullDate(date);\n        assertNotNull(rs.getDate(1));\n        assertEquals(date, rs.getDate(1));\n        assertNotNull(rs.getDate(\"column\"));\n        assertEquals(date, rs.getDate(\"column\"));\n        assertNotNull(rs.getDate(1, Calendar.getInstance()));\n        assertEquals(date, rs.getDate(1, Calendar.getInstance()));\n        assertNotNull(rs.getDate(\"column\", Calendar.getInstance()));\n        assertEquals(date, rs.getDate(\"column\", Calendar.getInstance()));\n\n    }", "signature": "public void testGetDate()"}, {"syntax_pass": true, "original_string": "    public void testGetDouble() throws SQLException {\n\n        assertEquals(0.0, rs.getDouble(1), 0.0);\n        assertTrue(rs.wasNull());\n        assertEquals(0.0, rs.getDouble(\"column\"), 0.0);\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final double d = 10.0;\n        rs2.setNullDouble(d);\n        assertEquals(d, rs.getDouble(1), 0.0);\n        assertEquals(d, rs.getDouble(\"column\"), 0.0);\n\n    }", "docstring": "\nTests the getDouble implementation.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGetDouble", "params": [], "body": "                                                    {\n\n        assertEquals(0.0, rs.getDouble(1), 0.0);\n        assertTrue(rs.wasNull());\n        assertEquals(0.0, rs.getDouble(\"column\"), 0.0);\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final double d = 10.0;\n        rs2.setNullDouble(d);\n        assertEquals(d, rs.getDouble(1), 0.0);\n        assertEquals(d, rs.getDouble(\"column\"), 0.0);\n\n    }", "signature": "public void testGetDouble()"}, {"syntax_pass": true, "original_string": "    public void testGetFloat() throws SQLException {\n        assertEquals(0, rs.getFloat(1), 0.0);\n        assertTrue(rs.wasNull());\n        assertEquals(0, rs.getFloat(\"column\"), 0.0);\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final float f = 10;\n        rs2.setNullFloat(f);\n        assertEquals(f, rs.getFloat(1), 0.0);\n        assertEquals(f, rs.getFloat(\"column\"), 0.0);\n    }", "docstring": "\nTests the getFloat implementation.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGetFloat", "params": [], "body": "                                                   {\n        assertEquals(0, rs.getFloat(1), 0.0);\n        assertTrue(rs.wasNull());\n        assertEquals(0, rs.getFloat(\"column\"), 0.0);\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final float f = 10;\n        rs2.setNullFloat(f);\n        assertEquals(f, rs.getFloat(1), 0.0);\n        assertEquals(f, rs.getFloat(\"column\"), 0.0);\n    }", "signature": "public void testGetFloat()"}, {"syntax_pass": true, "original_string": "    public void testGetInt() throws SQLException {\n        assertEquals(0, rs.getInt(1));\n        assertTrue(rs.wasNull());\n        assertEquals(0, rs.getInt(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final int i = 10;\n        rs2.setNullInt(i);\n        assertEquals(i, rs.getInt(1));\n        assertEquals(i, rs.getInt(\"column\"));\n    }", "docstring": "\nTests the getInt implementation.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGetInt", "params": [], "body": "                                                 {\n        assertEquals(0, rs.getInt(1));\n        assertTrue(rs.wasNull());\n        assertEquals(0, rs.getInt(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final int i = 10;\n        rs2.setNullInt(i);\n        assertEquals(i, rs.getInt(1));\n        assertEquals(i, rs.getInt(\"column\"));\n    }", "signature": "public void testGetInt()"}, {"syntax_pass": true, "original_string": "    public void testGetLong() throws SQLException {\n        assertEquals(0, rs.getLong(1));\n        assertTrue(rs.wasNull());\n        assertEquals(0, rs.getLong(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final long l = 10;\n        rs2.setNullLong(l);\n        assertEquals(l, rs.getLong(1));\n        assertEquals(l, rs.getLong(\"column\"));\n    }", "docstring": "\nTests the getLong implementation.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGetLong", "params": [], "body": "                                                  {\n        assertEquals(0, rs.getLong(1));\n        assertTrue(rs.wasNull());\n        assertEquals(0, rs.getLong(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final long l = 10;\n        rs2.setNullLong(l);\n        assertEquals(l, rs.getLong(1));\n        assertEquals(l, rs.getLong(\"column\"));\n    }", "signature": "public void testGetLong()"}, {"syntax_pass": true, "original_string": "    public void testGetObject() throws SQLException {\n\n        assertNull(rs.getObject(1));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getObject(\"column\"));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getObject(1, (Map<String, Class<?>>) null));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getObject(\"column\", (Map<String, Class<?>>) null));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final Object o = new Object();\n        rs2.setNullObject(o);\n        assertNotNull(rs.getObject(1));\n        assertEquals(o, rs.getObject(1));\n        assertNotNull(rs.getObject(\"column\"));\n        assertEquals(o, rs.getObject(\"column\"));\n        assertNotNull(rs.getObject(1, (Map<String, Class<?>>) null));\n        assertEquals(o, rs.getObject(1, (Map<String, Class<?>>) null));\n        assertNotNull(rs.getObject(\"column\", (Map<String, Class<?>>) null));\n        assertEquals(o, rs.getObject(\"column\", (Map<String, Class<?>>) null));\n\n    }", "docstring": "\nTests the getObject implementation.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGetObject", "params": [], "body": "                                                    {\n\n        assertNull(rs.getObject(1));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getObject(\"column\"));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getObject(1, (Map<String, Class<?>>) null));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getObject(\"column\", (Map<String, Class<?>>) null));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final Object o = new Object();\n        rs2.setNullObject(o);\n        assertNotNull(rs.getObject(1));\n        assertEquals(o, rs.getObject(1));\n        assertNotNull(rs.getObject(\"column\"));\n        assertEquals(o, rs.getObject(\"column\"));\n        assertNotNull(rs.getObject(1, (Map<String, Class<?>>) null));\n        assertEquals(o, rs.getObject(1, (Map<String, Class<?>>) null));\n        assertNotNull(rs.getObject(\"column\", (Map<String, Class<?>>) null));\n        assertEquals(o, rs.getObject(\"column\", (Map<String, Class<?>>) null));\n\n    }", "signature": "public void testGetObject()"}, {"syntax_pass": true, "original_string": "    public void testGetRef() throws SQLException {\n\n        assertNull(rs.getRef(1));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getRef(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final Ref ref = new SqlNullCheckedResultSetMockRef();\n        rs2.setNullRef(ref);\n        assertNotNull(rs.getRef(1));\n        assertEquals(ref, rs.getRef(1));\n        assertNotNull(rs.getRef(\"column\"));\n        assertEquals(ref, rs.getRef(\"column\"));\n\n    }", "docstring": "\nTests the getRef implementation.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGetRef", "params": [], "body": "                                                 {\n\n        assertNull(rs.getRef(1));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getRef(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final Ref ref = new SqlNullCheckedResultSetMockRef();\n        rs2.setNullRef(ref);\n        assertNotNull(rs.getRef(1));\n        assertEquals(ref, rs.getRef(1));\n        assertNotNull(rs.getRef(\"column\"));\n        assertEquals(ref, rs.getRef(\"column\"));\n\n    }", "signature": "public void testGetRef()"}, {"syntax_pass": true, "original_string": "    public void testGetShort() throws SQLException {\n\n        assertEquals((short) 0, rs.getShort(1));\n        assertTrue(rs.wasNull());\n        assertEquals((short) 0, rs.getShort(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final short s = (short) 10;\n        rs2.setNullShort(s);\n        assertEquals(s, rs.getShort(1));\n        assertEquals(s, rs.getShort(\"column\"));\n    }", "docstring": "\nTests the getShort implementation.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGetShort", "params": [], "body": "                                                   {\n\n        assertEquals((short) 0, rs.getShort(1));\n        assertTrue(rs.wasNull());\n        assertEquals((short) 0, rs.getShort(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final short s = (short) 10;\n        rs2.setNullShort(s);\n        assertEquals(s, rs.getShort(1));\n        assertEquals(s, rs.getShort(\"column\"));\n    }", "signature": "public void testGetShort()"}, {"syntax_pass": true, "original_string": "    public void testGetString() throws SQLException {\n        assertNull(rs.getString(1));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getString(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final String s = \"hello, world\";\n        rs2.setNullString(s);\n        assertEquals(s, rs.getString(1));\n        assertEquals(s, rs.getString(\"column\"));\n    }", "docstring": "\nTests the getString implementation.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGetString", "params": [], "body": "                                                    {\n        assertNull(rs.getString(1));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getString(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final String s = \"hello, world\";\n        rs2.setNullString(s);\n        assertEquals(s, rs.getString(1));\n        assertEquals(s, rs.getString(\"column\"));\n    }", "signature": "public void testGetString()"}, {"syntax_pass": true, "original_string": "    public void testGetTime() throws SQLException {\n\n        assertNull(rs.getTime(1));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getTime(\"column\"));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getTime(1, Calendar.getInstance()));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getTime(\"column\", Calendar.getInstance()));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final Time time = new Time(new java.util.Date().getTime());\n        rs2.setNullTime(time);\n        assertNotNull(rs.getTime(1));\n        assertEquals(time, rs.getTime(1));\n        assertNotNull(rs.getTime(\"column\"));\n        assertEquals(time, rs.getTime(\"column\"));\n        assertNotNull(rs.getTime(1, Calendar.getInstance()));\n        assertEquals(time, rs.getTime(1, Calendar.getInstance()));\n        assertNotNull(rs.getTime(\"column\", Calendar.getInstance()));\n        assertEquals(time, rs.getTime(\"column\", Calendar.getInstance()));\n\n    }", "docstring": "\nTests the getTime implementation.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGetTime", "params": [], "body": "                                                  {\n\n        assertNull(rs.getTime(1));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getTime(\"column\"));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getTime(1, Calendar.getInstance()));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getTime(\"column\", Calendar.getInstance()));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final Time time = new Time(new java.util.Date().getTime());\n        rs2.setNullTime(time);\n        assertNotNull(rs.getTime(1));\n        assertEquals(time, rs.getTime(1));\n        assertNotNull(rs.getTime(\"column\"));\n        assertEquals(time, rs.getTime(\"column\"));\n        assertNotNull(rs.getTime(1, Calendar.getInstance()));\n        assertEquals(time, rs.getTime(1, Calendar.getInstance()));\n        assertNotNull(rs.getTime(\"column\", Calendar.getInstance()));\n        assertEquals(time, rs.getTime(\"column\", Calendar.getInstance()));\n\n    }", "signature": "public void testGetTime()"}, {"syntax_pass": true, "original_string": "    public void testGetTimestamp() throws SQLException {\n\n        assertNull(rs.getTimestamp(1));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getTimestamp(\"column\"));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getTimestamp(1, Calendar.getInstance()));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getTimestamp(\"column\", Calendar.getInstance()));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final Timestamp ts = new Timestamp(new java.util.Date().getTime());\n        rs2.setNullTimestamp(ts);\n        assertNotNull(rs.getTimestamp(1));\n        assertEquals(ts, rs.getTimestamp(1));\n        assertNotNull(rs.getTimestamp(\"column\"));\n        assertEquals(ts, rs.getTimestamp(\"column\"));\n        assertNotNull(rs.getTimestamp(1, Calendar.getInstance()));\n        assertEquals(ts, rs.getTimestamp(1, Calendar.getInstance()));\n        assertNotNull(rs.getTimestamp(\"column\", Calendar.getInstance()));\n        assertEquals(ts, rs.getTimestamp(\"column\", Calendar.getInstance()));\n    }", "docstring": "\nTests the getTimestamp implementation.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGetTimestamp", "params": [], "body": "                                                       {\n\n        assertNull(rs.getTimestamp(1));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getTimestamp(\"column\"));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getTimestamp(1, Calendar.getInstance()));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getTimestamp(\"column\", Calendar.getInstance()));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final Timestamp ts = new Timestamp(new java.util.Date().getTime());\n        rs2.setNullTimestamp(ts);\n        assertNotNull(rs.getTimestamp(1));\n        assertEquals(ts, rs.getTimestamp(1));\n        assertNotNull(rs.getTimestamp(\"column\"));\n        assertEquals(ts, rs.getTimestamp(\"column\"));\n        assertNotNull(rs.getTimestamp(1, Calendar.getInstance()));\n        assertEquals(ts, rs.getTimestamp(1, Calendar.getInstance()));\n        assertNotNull(rs.getTimestamp(\"column\", Calendar.getInstance()));\n        assertEquals(ts, rs.getTimestamp(\"column\", Calendar.getInstance()));\n    }", "signature": "public void testGetTimestamp()"}, {"syntax_pass": true, "original_string": "    public void testSetNullAsciiStream() throws SQLException {\n\n        assertNull(rs2.getNullAsciiStream());\n        // Set what gets returned to something other than the default\n        final InputStream stream = new ByteArrayInputStream(new byte[0]);\n        rs2.setNullAsciiStream(stream);\n        assertNotNull(rs.getAsciiStream(1));\n        assertEquals(stream, rs.getAsciiStream(1));\n        assertNotNull(rs.getAsciiStream(\"column\"));\n        assertEquals(stream, rs.getAsciiStream(\"column\"));\n\n    }", "docstring": "\nTests the setNullAsciiStream implementation.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSetNullAsciiStream", "params": [], "body": "                                                             {\n\n        assertNull(rs2.getNullAsciiStream());\n        // Set what gets returned to something other than the default\n        final InputStream stream = new ByteArrayInputStream(new byte[0]);\n        rs2.setNullAsciiStream(stream);\n        assertNotNull(rs.getAsciiStream(1));\n        assertEquals(stream, rs.getAsciiStream(1));\n        assertNotNull(rs.getAsciiStream(\"column\"));\n        assertEquals(stream, rs.getAsciiStream(\"column\"));\n\n    }", "signature": "public void testSetNullAsciiStream()"}, {"syntax_pass": true, "original_string": "    public void testSetNullBigDecimal() throws SQLException {\n\n        assertNull(rs2.getNullBigDecimal());\n        // Set what gets returned to something other than the default\n        final BigDecimal bd = new BigDecimal(5.0);\n        rs2.setNullBigDecimal(bd);\n        assertNotNull(rs.getBigDecimal(1));\n        assertEquals(bd, rs.getBigDecimal(1));\n        assertNotNull(rs.getBigDecimal(\"column\"));\n        assertEquals(bd, rs.getBigDecimal(\"column\"));\n\n    }", "docstring": "\nTests the setNullBigDecimal implementation.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSetNullBigDecimal", "params": [], "body": "                                                            {\n\n        assertNull(rs2.getNullBigDecimal());\n        // Set what gets returned to something other than the default\n        final BigDecimal bd = new BigDecimal(5.0);\n        rs2.setNullBigDecimal(bd);\n        assertNotNull(rs.getBigDecimal(1));\n        assertEquals(bd, rs.getBigDecimal(1));\n        assertNotNull(rs.getBigDecimal(\"column\"));\n        assertEquals(bd, rs.getBigDecimal(\"column\"));\n\n    }", "signature": "public void testSetNullBigDecimal()"}, {"syntax_pass": true, "original_string": "    public void testSetNullBinaryStream() throws SQLException {\n\n        assertNull(rs2.getNullBinaryStream());\n        // Set what gets returned to something other than the default\n        final InputStream stream = new ByteArrayInputStream(new byte[0]);\n        rs2.setNullBinaryStream(stream);\n        assertNotNull(rs.getBinaryStream(1));\n        assertEquals(stream, rs.getBinaryStream(1));\n        assertNotNull(rs.getBinaryStream(\"column\"));\n        assertEquals(stream, rs.getBinaryStream(\"column\"));\n\n    }", "docstring": "\nTests the setNullBinaryStream implementation.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSetNullBinaryStream", "params": [], "body": "                                                              {\n\n        assertNull(rs2.getNullBinaryStream());\n        // Set what gets returned to something other than the default\n        final InputStream stream = new ByteArrayInputStream(new byte[0]);\n        rs2.setNullBinaryStream(stream);\n        assertNotNull(rs.getBinaryStream(1));\n        assertEquals(stream, rs.getBinaryStream(1));\n        assertNotNull(rs.getBinaryStream(\"column\"));\n        assertEquals(stream, rs.getBinaryStream(\"column\"));\n\n    }", "signature": "public void testSetNullBinaryStream()"}, {"syntax_pass": true, "original_string": "    public void testSetNullBlob() throws SQLException {\n\n        assertNull(rs2.getNullBlob());\n        // Set what gets returned to something other than the default\n        final Blob blob = new SqlNullCheckedResultSetMockBlob();\n        rs2.setNullBlob(blob);\n        assertNotNull(rs.getBlob(1));\n        assertEquals(blob, rs.getBlob(1));\n        assertNotNull(rs.getBlob(\"column\"));\n        assertEquals(blob, rs.getBlob(\"column\"));\n\n    }", "docstring": "\nTests the setNullBlob implementation.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSetNullBlob", "params": [], "body": "                                                      {\n\n        assertNull(rs2.getNullBlob());\n        // Set what gets returned to something other than the default\n        final Blob blob = new SqlNullCheckedResultSetMockBlob();\n        rs2.setNullBlob(blob);\n        assertNotNull(rs.getBlob(1));\n        assertEquals(blob, rs.getBlob(1));\n        assertNotNull(rs.getBlob(\"column\"));\n        assertEquals(blob, rs.getBlob(\"column\"));\n\n    }", "signature": "public void testSetNullBlob()"}, {"syntax_pass": true, "original_string": "    public void testSetNullBoolean() throws SQLException {\n\n        assertFalse(rs2.getNullBoolean());\n        // Set what gets returned to something other than the default\n        rs2.setNullBoolean(true);\n        assertTrue( rs.getBoolean(1));\n        assertTrue( rs.getBoolean(\"column\"));\n\n    }", "docstring": "\nTests the setNullBoolean implementation.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSetNullBoolean", "params": [], "body": "                                                         {\n\n        assertFalse(rs2.getNullBoolean());\n        // Set what gets returned to something other than the default\n        rs2.setNullBoolean(true);\n        assertTrue( rs.getBoolean(1));\n        assertTrue( rs.getBoolean(\"column\"));\n\n    }", "signature": "public void testSetNullBoolean()"}, {"syntax_pass": true, "original_string": "    public void testSetNullByte() throws SQLException {\n\n        assertEquals((byte) 0, rs2.getNullByte());\n        // Set what gets returned to something other than the default\n        final byte b = (byte) 10;\n        rs2.setNullByte(b);\n        assertEquals(b, rs.getByte(1));\n        assertEquals(b, rs.getByte(\"column\"));\n\n    }", "docstring": "\nTests the setNullByte implementation.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSetNullByte", "params": [], "body": "                                                      {\n\n        assertEquals((byte) 0, rs2.getNullByte());\n        // Set what gets returned to something other than the default\n        final byte b = (byte) 10;\n        rs2.setNullByte(b);\n        assertEquals(b, rs.getByte(1));\n        assertEquals(b, rs.getByte(\"column\"));\n\n    }", "signature": "public void testSetNullByte()"}, {"syntax_pass": true, "original_string": "    public void testSetNullBytes() throws SQLException {\n        // test the default, unset value\n        assertNull(rs2.getNullBytes());\n\n        // test that setting null is safe\n        rs2.setNullBytes(null);\n        assertNull(rs2.getNullBytes());\n\n        // Set what gets returned to something other than the default\n        final byte[] b = new byte[5];\n        for (int i = 0; i < 5; i++) {\n            b[0] = (byte) i;\n        }\n        rs2.setNullBytes(b);\n        assertNotNull(rs.getBytes(1));\n        assertArrayEquals(b, rs.getBytes(1));\n        assertNotNull(rs.getBytes(\"column\"));\n        assertArrayEquals(b, rs.getBytes(\"column\"));\n\n    }", "docstring": "\nTests the setNullByte implementation.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSetNullBytes", "params": [], "body": "                                                       {\n        // test the default, unset value\n        assertNull(rs2.getNullBytes());\n\n        // test that setting null is safe\n        rs2.setNullBytes(null);\n        assertNull(rs2.getNullBytes());\n\n        // Set what gets returned to something other than the default\n        final byte[] b = new byte[5];\n        for (int i = 0; i < 5; i++) {\n            b[0] = (byte) i;\n        }\n        rs2.setNullBytes(b);\n        assertNotNull(rs.getBytes(1));\n        assertArrayEquals(b, rs.getBytes(1));\n        assertNotNull(rs.getBytes(\"column\"));\n        assertArrayEquals(b, rs.getBytes(\"column\"));\n\n    }", "signature": "public void testSetNullBytes()"}, {"syntax_pass": true, "original_string": "    public void testSetNullCharacterStream() throws SQLException {\n\n        assertNull(rs2.getNullCharacterStream());\n        // Set what gets returned to something other than the default\n        final Reader reader = new CharArrayReader(\"this is a string\".toCharArray());\n        rs2.setNullCharacterStream(reader);\n        assertNotNull(rs.getCharacterStream(1));\n        assertEquals(reader, rs.getCharacterStream(1));\n        assertNotNull(rs.getCharacterStream(\"column\"));\n        assertEquals(reader, rs.getCharacterStream(\"column\"));\n\n    }", "docstring": "\nTests the setNullCharacterStream implementation.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSetNullCharacterStream", "params": [], "body": "                                                                 {\n\n        assertNull(rs2.getNullCharacterStream());\n        // Set what gets returned to something other than the default\n        final Reader reader = new CharArrayReader(\"this is a string\".toCharArray());\n        rs2.setNullCharacterStream(reader);\n        assertNotNull(rs.getCharacterStream(1));\n        assertEquals(reader, rs.getCharacterStream(1));\n        assertNotNull(rs.getCharacterStream(\"column\"));\n        assertEquals(reader, rs.getCharacterStream(\"column\"));\n\n    }", "signature": "public void testSetNullCharacterStream()"}, {"syntax_pass": true, "original_string": "    public void testSetNullClob() throws SQLException {\n\n        assertNull(rs2.getNullClob());\n        // Set what gets returned to something other than the default\n        final Clob clob = new SqlNullCheckedResultSetMockClob();\n        rs2.setNullClob(clob);\n        assertNotNull(rs.getClob(1));\n        assertEquals(clob, rs.getClob(1));\n        assertNotNull(rs.getClob(\"column\"));\n        assertEquals(clob, rs.getClob(\"column\"));\n\n    }", "docstring": "\nTests the setNullClob implementation.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSetNullClob", "params": [], "body": "                                                      {\n\n        assertNull(rs2.getNullClob());\n        // Set what gets returned to something other than the default\n        final Clob clob = new SqlNullCheckedResultSetMockClob();\n        rs2.setNullClob(clob);\n        assertNotNull(rs.getClob(1));\n        assertEquals(clob, rs.getClob(1));\n        assertNotNull(rs.getClob(\"column\"));\n        assertEquals(clob, rs.getClob(\"column\"));\n\n    }", "signature": "public void testSetNullClob()"}, {"syntax_pass": true, "original_string": "    public void testSetNullDate() throws SQLException {\n        // test the default, unset value\n        assertNull(rs2.getNullDate());\n\n        // test that setting null is safe\n        rs2.setNullDate(null);\n        assertNull(rs2.getNullDate());\n\n        // Set what gets returned to something other than the default\n        final java.sql.Date date = new java.sql.Date(new java.util.Date().getTime());\n        rs2.setNullDate(date);\n        assertNotNull(rs.getDate(1));\n        assertEquals(date, rs.getDate(1));\n        assertNotNull(rs.getDate(\"column\"));\n        assertEquals(date, rs.getDate(\"column\"));\n        assertNotNull(rs.getDate(1, Calendar.getInstance()));\n        assertEquals(date, rs.getDate(1, Calendar.getInstance()));\n        assertNotNull(rs.getDate(\"column\", Calendar.getInstance()));\n        assertEquals(date, rs.getDate(\"column\", Calendar.getInstance()));\n\n    }", "docstring": "\nTests the setNullDate implementation.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSetNullDate", "params": [], "body": "                                                      {\n        // test the default, unset value\n        assertNull(rs2.getNullDate());\n\n        // test that setting null is safe\n        rs2.setNullDate(null);\n        assertNull(rs2.getNullDate());\n\n        // Set what gets returned to something other than the default\n        final java.sql.Date date = new java.sql.Date(new java.util.Date().getTime());\n        rs2.setNullDate(date);\n        assertNotNull(rs.getDate(1));\n        assertEquals(date, rs.getDate(1));\n        assertNotNull(rs.getDate(\"column\"));\n        assertEquals(date, rs.getDate(\"column\"));\n        assertNotNull(rs.getDate(1, Calendar.getInstance()));\n        assertEquals(date, rs.getDate(1, Calendar.getInstance()));\n        assertNotNull(rs.getDate(\"column\", Calendar.getInstance()));\n        assertEquals(date, rs.getDate(\"column\", Calendar.getInstance()));\n\n    }", "signature": "public void testSetNullDate()"}, {"syntax_pass": true, "original_string": "    public void testSetNullDouble() throws SQLException {\n        assertEquals(0.0, rs2.getNullDouble(), 0.0);\n        // Set what gets returned to something other than the default\n        final double d = 10.0;\n        rs2.setNullDouble(d);\n        assertEquals(d, rs.getDouble(1), 0.0);\n        assertEquals(d, rs.getDouble(\"column\"), 0.0);\n    }", "docstring": "\nTests the setNullDouble implementation.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSetNullDouble", "params": [], "body": "                                                        {\n        assertEquals(0.0, rs2.getNullDouble(), 0.0);\n        // Set what gets returned to something other than the default\n        final double d = 10.0;\n        rs2.setNullDouble(d);\n        assertEquals(d, rs.getDouble(1), 0.0);\n        assertEquals(d, rs.getDouble(\"column\"), 0.0);\n    }", "signature": "public void testSetNullDouble()"}, {"syntax_pass": true, "original_string": "    public void testSetNullFloat() throws SQLException {\n        assertEquals((float) 0.0, rs2.getNullFloat(), 0.0);\n        // Set what gets returned to something other than the default\n        final float f = (float) 10.0;\n        rs2.setNullFloat(f);\n        assertEquals(f, rs.getFloat(1), 0.0);\n        assertEquals(f, rs.getFloat(\"column\"), 0.0);\n    }", "docstring": "\nTests the setNullFloat implementation.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSetNullFloat", "params": [], "body": "                                                       {\n        assertEquals((float) 0.0, rs2.getNullFloat(), 0.0);\n        // Set what gets returned to something other than the default\n        final float f = (float) 10.0;\n        rs2.setNullFloat(f);\n        assertEquals(f, rs.getFloat(1), 0.0);\n        assertEquals(f, rs.getFloat(\"column\"), 0.0);\n    }", "signature": "public void testSetNullFloat()"}, {"syntax_pass": true, "original_string": "    public void testSetNullInt() throws SQLException {\n        assertEquals(0, rs2.getNullInt());\n        assertEquals(0, rs.getInt(1));\n        assertTrue(rs.wasNull());\n        assertEquals(0, rs.getInt(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final int i = 10;\n        rs2.setNullInt(i);\n        assertEquals(i, rs.getInt(1));\n        assertEquals(i, rs.getInt(\"column\"));\n    }", "docstring": "\nTests the setNullInt implementation.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSetNullInt", "params": [], "body": "                                                     {\n        assertEquals(0, rs2.getNullInt());\n        assertEquals(0, rs.getInt(1));\n        assertTrue(rs.wasNull());\n        assertEquals(0, rs.getInt(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final int i = 10;\n        rs2.setNullInt(i);\n        assertEquals(i, rs.getInt(1));\n        assertEquals(i, rs.getInt(\"column\"));\n    }", "signature": "public void testSetNullInt()"}, {"syntax_pass": true, "original_string": "    public void testSetNullLong() throws SQLException {\n        assertEquals(0, rs2.getNullLong());\n        // Set what gets returned to something other than the default\n        final long l = 10;\n        rs2.setNullLong(l);\n        assertEquals(l, rs.getLong(1));\n        assertEquals(l, rs.getLong(\"column\"));\n    }", "docstring": "\nTests the setNullLong implementation.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSetNullLong", "params": [], "body": "                                                      {\n        assertEquals(0, rs2.getNullLong());\n        // Set what gets returned to something other than the default\n        final long l = 10;\n        rs2.setNullLong(l);\n        assertEquals(l, rs.getLong(1));\n        assertEquals(l, rs.getLong(\"column\"));\n    }", "signature": "public void testSetNullLong()"}, {"syntax_pass": true, "original_string": "    public void testSetNullObject() throws SQLException {\n        assertNull(rs2.getNullObject());\n        // Set what gets returned to something other than the default\n        final Object o = new Object();\n        rs2.setNullObject(o);\n        assertNotNull(rs.getObject(1));\n        assertEquals(o, rs.getObject(1));\n        assertNotNull(rs.getObject(\"column\"));\n        assertEquals(o, rs.getObject(\"column\"));\n        assertNotNull(rs.getObject(1, (Map<String, Class<?>>) null));\n        assertEquals(o, rs.getObject(1, (Map<String, Class<?>>) null));\n        assertNotNull(rs.getObject(\"column\", (Map<String, Class<?>>) null));\n        assertEquals(o, rs.getObject(\"column\", (Map<String, Class<?>>) null));\n    }", "docstring": "\nTests the setNullObject implementation.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSetNullObject", "params": [], "body": "                                                        {\n        assertNull(rs2.getNullObject());\n        // Set what gets returned to something other than the default\n        final Object o = new Object();\n        rs2.setNullObject(o);\n        assertNotNull(rs.getObject(1));\n        assertEquals(o, rs.getObject(1));\n        assertNotNull(rs.getObject(\"column\"));\n        assertEquals(o, rs.getObject(\"column\"));\n        assertNotNull(rs.getObject(1, (Map<String, Class<?>>) null));\n        assertEquals(o, rs.getObject(1, (Map<String, Class<?>>) null));\n        assertNotNull(rs.getObject(\"column\", (Map<String, Class<?>>) null));\n        assertEquals(o, rs.getObject(\"column\", (Map<String, Class<?>>) null));\n    }", "signature": "public void testSetNullObject()"}, {"syntax_pass": true, "original_string": "    public void testSetNullRef() throws SQLException {\n        assertNull(rs2.getNullRef());\n        // Set what gets returned to something other than the default\n        final Ref ref = new SqlNullCheckedResultSetMockRef();\n        rs2.setNullRef(ref);\n        assertNotNull(rs.getRef(1));\n        assertEquals(ref, rs.getRef(1));\n        assertNotNull(rs.getRef(\"column\"));\n        assertEquals(ref, rs.getRef(\"column\"));\n    }", "docstring": "\nTests the setNullRef implementation.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSetNullRef", "params": [], "body": "                                                     {\n        assertNull(rs2.getNullRef());\n        // Set what gets returned to something other than the default\n        final Ref ref = new SqlNullCheckedResultSetMockRef();\n        rs2.setNullRef(ref);\n        assertNotNull(rs.getRef(1));\n        assertEquals(ref, rs.getRef(1));\n        assertNotNull(rs.getRef(\"column\"));\n        assertEquals(ref, rs.getRef(\"column\"));\n    }", "signature": "public void testSetNullRef()"}, {"syntax_pass": true, "original_string": "    public void testSetNullShort() throws SQLException {\n\n        assertEquals((short) 0, rs2.getNullShort());\n        // Set what gets returned to something other than the default\n        final short s = (short) 10;\n        rs2.setNullShort(s);\n        assertEquals(s, rs.getShort(1));\n        assertEquals(s, rs.getShort(\"column\"));\n\n    }", "docstring": "\nTests the setNullShort implementation.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSetNullShort", "params": [], "body": "                                                       {\n\n        assertEquals((short) 0, rs2.getNullShort());\n        // Set what gets returned to something other than the default\n        final short s = (short) 10;\n        rs2.setNullShort(s);\n        assertEquals(s, rs.getShort(1));\n        assertEquals(s, rs.getShort(\"column\"));\n\n    }", "signature": "public void testSetNullShort()"}, {"syntax_pass": true, "original_string": "    public void testSetNullString() throws SQLException {\n        assertNull(rs2.getNullString());\n        // Set what gets returned to something other than the default\n        final String s = \"hello, world\";\n        rs2.setNullString(s);\n        assertEquals(s, rs.getString(1));\n        assertEquals(s, rs.getString(\"column\"));\n    }", "docstring": "\nTests the setNullString implementation.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSetNullString", "params": [], "body": "                                                        {\n        assertNull(rs2.getNullString());\n        // Set what gets returned to something other than the default\n        final String s = \"hello, world\";\n        rs2.setNullString(s);\n        assertEquals(s, rs.getString(1));\n        assertEquals(s, rs.getString(\"column\"));\n    }", "signature": "public void testSetNullString()"}, {"syntax_pass": true, "original_string": "    public void testSetNullTime() throws SQLException {\n        // test the default, unset value\n        assertNull(rs2.getNullTime());\n\n        // test that setting null is safe\n        rs2.setNullTime(null);\n        assertNull(rs2.getNullTime());\n\n        // Set what gets returned to something other than the default\n        final Time time = new Time(new java.util.Date().getTime());\n        rs2.setNullTime(time);\n        assertNotNull(rs.getTime(1));\n        assertEquals(time, rs.getTime(1));\n        assertNotNull(rs.getTime(\"column\"));\n        assertEquals(time, rs.getTime(\"column\"));\n        assertNotNull(rs.getTime(1, Calendar.getInstance()));\n        assertEquals(time, rs.getTime(1, Calendar.getInstance()));\n        assertNotNull(rs.getTime(\"column\", Calendar.getInstance()));\n        assertEquals(time, rs.getTime(\"column\", Calendar.getInstance()));\n    }", "docstring": "\nTests the setNullTime implementation.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSetNullTime", "params": [], "body": "                                                      {\n        // test the default, unset value\n        assertNull(rs2.getNullTime());\n\n        // test that setting null is safe\n        rs2.setNullTime(null);\n        assertNull(rs2.getNullTime());\n\n        // Set what gets returned to something other than the default\n        final Time time = new Time(new java.util.Date().getTime());\n        rs2.setNullTime(time);\n        assertNotNull(rs.getTime(1));\n        assertEquals(time, rs.getTime(1));\n        assertNotNull(rs.getTime(\"column\"));\n        assertEquals(time, rs.getTime(\"column\"));\n        assertNotNull(rs.getTime(1, Calendar.getInstance()));\n        assertEquals(time, rs.getTime(1, Calendar.getInstance()));\n        assertNotNull(rs.getTime(\"column\", Calendar.getInstance()));\n        assertEquals(time, rs.getTime(\"column\", Calendar.getInstance()));\n    }", "signature": "public void testSetNullTime()"}, {"syntax_pass": true, "original_string": "    public void testSetNullTimestamp() throws SQLException {\n        // test the default, unset value\n        assertNull(rs2.getNullTimestamp());\n\n        // test that setting null is safe\n        rs2.setNullTimestamp(null);\n        assertNull(rs2.getNullTimestamp());\n\n        // Set what gets returned to something other than the default\n        final Timestamp ts = new Timestamp(new java.util.Date().getTime());\n        rs2.setNullTimestamp(ts);\n        assertNotNull(rs.getTimestamp(1));\n        assertEquals(ts, rs.getTimestamp(1));\n        assertNotNull(rs.getTimestamp(\"column\"));\n        assertEquals(ts, rs.getTimestamp(\"column\"));\n        assertNotNull(rs.getTimestamp(1, Calendar.getInstance()));\n        assertEquals(ts, rs.getTimestamp(1, Calendar.getInstance()));\n        assertNotNull(rs.getTimestamp(\"column\", Calendar.getInstance()));\n        assertEquals(ts, rs.getTimestamp(\"column\", Calendar.getInstance()));\n    }", "docstring": "\nTests the setNullTimestamp implementation.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSetNullTimestamp", "params": [], "body": "                                                           {\n        // test the default, unset value\n        assertNull(rs2.getNullTimestamp());\n\n        // test that setting null is safe\n        rs2.setNullTimestamp(null);\n        assertNull(rs2.getNullTimestamp());\n\n        // Set what gets returned to something other than the default\n        final Timestamp ts = new Timestamp(new java.util.Date().getTime());\n        rs2.setNullTimestamp(ts);\n        assertNotNull(rs.getTimestamp(1));\n        assertEquals(ts, rs.getTimestamp(1));\n        assertNotNull(rs.getTimestamp(\"column\"));\n        assertEquals(ts, rs.getTimestamp(\"column\"));\n        assertNotNull(rs.getTimestamp(1, Calendar.getInstance()));\n        assertEquals(ts, rs.getTimestamp(1, Calendar.getInstance()));\n        assertNotNull(rs.getTimestamp(\"column\", Calendar.getInstance()));\n        assertEquals(ts, rs.getTimestamp(\"column\", Calendar.getInstance()));\n    }", "signature": "public void testSetNullTimestamp()"}, {"syntax_pass": true, "original_string": "    public void testURL() throws SQLException, MalformedURLException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {\n        assertNull(rs.getURL(1));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getURL(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final URL u = new URL(\"http://www.apache.org\");\n        rs2.setNullURL(u);\n        assertEquals(u, rs.getURL(1));\n        assertEquals(u, rs.getURL(\"column\"));\n    }", "docstring": "\nTests the getURL and setNullURL implementations.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testURL", "params": [], "body": "                                                                                                                                                  {\n        assertNull(rs.getURL(1));\n        assertTrue(rs.wasNull());\n        assertNull(rs.getURL(\"column\"));\n        assertTrue(rs.wasNull());\n        // Set what gets returned to something other than the default\n        final URL u = new URL(\"http://www.apache.org\");\n        rs2.setNullURL(u);\n        assertEquals(u, rs.getURL(1));\n        assertEquals(u, rs.getURL(\"column\"));\n    }", "signature": "public void testURL()"}, {"syntax_pass": true, "original_string": "    public void testWrapResultSet() throws SQLException {\n        final ResultSet wrappedRs = mock(ResultSet.class);\n        final ResultSet rs = SqlNullCheckedResultSet.wrap(wrappedRs);\n        rs.beforeFirst();\n        verify(wrappedRs).beforeFirst();\n        rs.next();\n        verify(wrappedRs).next();\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testWrapResultSet", "params": [], "body": "                                                        {\n        final ResultSet wrappedRs = mock(ResultSet.class);\n        final ResultSet rs = SqlNullCheckedResultSet.wrap(wrappedRs);\n        rs.beforeFirst();\n        verify(wrappedRs).beforeFirst();\n        rs.next();\n        verify(wrappedRs).next();\n    }", "signature": "public void testWrapResultSet()"}]}, {"original_string": "final class SqlNullUncheckedMockResultSet implements InvocationHandler {\n\n    /**\n     * Always return false for booleans, 0 for numerics, and null for Objects.\n     *\n     * @see java.lang.reflect.InvocationHandler#invoke(Object, java.lang.reflect.Method, Object[])\n     */\n    @Override\n    public Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable {\n\n        final Class<?> returnType = method.getReturnType();\n\n        if (method.getName().equals(\"wasNull\")) {\n            return Boolean.TRUE;\n\n        }\n        if (returnType.equals(Boolean.TYPE)) {\n            return Boolean.FALSE;\n\n        }\n        if (returnType.equals(Integer.TYPE)) {\n            return Integer.valueOf(0);\n\n        }\n        if (returnType.equals(Short.TYPE)) {\n            return Short.valueOf((short) 0);\n\n        }\n        if (returnType.equals(Double.TYPE)) {\n            return Double.valueOf(0);\n\n        }\n        if (returnType.equals(Long.TYPE)) {\n            return Long.valueOf(0);\n\n        }\n        if (returnType.equals(Byte.TYPE)) {\n            return Byte.valueOf((byte) 0);\n\n        }\n        if (returnType.equals(Float.TYPE)) {\n            return Float.valueOf(0);\n\n        }\n        return null;\n    }\n}", "definition": "final class SqlNullUncheckedMockResultSet implements InvocationHandler", "class_docstring": "", "name": "SqlNullUncheckedMockResultSet", "super_interfaces": ["InvocationHandler"], "superclasses": "", "attributes": {"modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Override\n    public Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable {\n\n        final Class<?> returnType = method.getReturnType();\n\n        if (method.getName().equals(\"wasNull\")) {\n            return Boolean.TRUE;\n\n        }\n        if (returnType.equals(Boolean.TYPE)) {\n            return Boolean.FALSE;\n\n        }\n        if (returnType.equals(Integer.TYPE)) {\n            return Integer.valueOf(0);\n\n        }\n        if (returnType.equals(Short.TYPE)) {\n            return Short.valueOf((short) 0);\n\n        }\n        if (returnType.equals(Double.TYPE)) {\n            return Double.valueOf(0);\n\n        }\n        if (returnType.equals(Long.TYPE)) {\n            return Long.valueOf(0);\n\n        }\n        if (returnType.equals(Byte.TYPE)) {\n            return Byte.valueOf((byte) 0);\n\n        }\n        if (returnType.equals(Float.TYPE)) {\n            return Float.valueOf(0);\n\n        }\n        return null;\n    }", "docstring": "\nAlways return false for booleans, 0 for numerics, and null for Objects.\n\n@see java.lang.reflect.InvocationHandler#invoke(Object, java.lang.reflect.Method, Object[])\n", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object", "classes": []}, "name": "invoke", "params": [{"name": "proxy", "type": "Object"}, {"name": "method", "type": "Method"}, {"name": "args", "type": "Object[]"}], "body": "                                                                                                        {\n\n        final Class<?> returnType = method.getReturnType();\n\n        if (method.getName().equals(\"wasNull\")) {\n            return Boolean.TRUE;\n\n        }\n        if (returnType.equals(Boolean.TYPE)) {\n            return Boolean.FALSE;\n\n        }\n        if (returnType.equals(Integer.TYPE)) {\n            return Integer.valueOf(0);\n\n        }\n        if (returnType.equals(Short.TYPE)) {\n            return Short.valueOf((short) 0);\n\n        }\n        if (returnType.equals(Double.TYPE)) {\n            return Double.valueOf(0);\n\n        }\n        if (returnType.equals(Long.TYPE)) {\n            return Long.valueOf(0);\n\n        }\n        if (returnType.equals(Byte.TYPE)) {\n            return Byte.valueOf((byte) 0);\n\n        }\n        if (returnType.equals(Float.TYPE)) {\n            return Float.valueOf(0);\n\n        }\n        return null;\n    }", "signature": "@Override\n    public Object invoke(final Object proxy, final Method method, final Object[] args)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/test/java/org/apache/commons/dbutils/wrappers/StringTrimmedResultSetTest.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils.wrappers;\n\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\n\nimport org.apache.commons.dbutils.BaseTestCase;\nimport org.apache.commons.dbutils.MockResultSet;\nimport org.apache.commons.dbutils.ProxyFactory;\n\n/**\n * StringTrimmedResultSetTest\n */\npublic class StringTrimmedResultSetTest extends BaseTestCase {\n\n    @Override\n    public void setUp() throws Exception {\n        super.setUp();\n        setResultSet(StringTrimmedResultSet.wrap(getResultSet()));\n    }\n\n    public void testGetObject() throws SQLException {\n        getResultSet().next();\n        assertEquals(\"notInBean\", getResultSet().getObject(4));\n    }\n\n    public void testGetString() throws SQLException {\n        getResultSet().next();\n        assertEquals(\"notInBean\", getResultSet().getString(4));\n    }\n\n    /**\n     * Make sure 2 wrappers work together.\n     *\n     * @throws SQLException if a database access error occurs\n     */\n    public void testMultipleWrappers() throws Exception {\n        // Create a ResultSet with data\n        final Object[][] rows = { { null } };\n        ResultSet rs = MockResultSet.create(metaData, rows);\n\n        // Wrap the ResultSet with a null checked version\n        final SqlNullCheckedResultSet ncrs = new SqlNullCheckedResultSet(rs);\n        ncrs.setNullString(\"   trim this   \");\n        rs = ProxyFactory.instance().createResultSet(ncrs);\n\n        // Wrap the wrapper with a string trimmed version\n        rs = StringTrimmedResultSet.wrap(rs);\n\n        rs.next();\n        assertEquals(\"trim this\", rs.getString(1));\n    }\n\n}\n", "file_hash": "c08fc5f1f48c91785e422f6bbd771103e18114c78571da93fb1ed7dac4d5ffdf", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils.wrappers;", "import java.sql.ResultSet;", "import java.sql.SQLException;", "import org.apache.commons.dbutils.BaseTestCase;", "import org.apache.commons.dbutils.MockResultSet;", "import org.apache.commons.dbutils.ProxyFactory;"], "methods": [], "classes": [{"original_string": "public class StringTrimmedResultSetTest extends BaseTestCase {\n\n    @Override\n    public void setUp() throws Exception {\n        super.setUp();\n        setResultSet(StringTrimmedResultSet.wrap(getResultSet()));\n    }\n\n    public void testGetObject() throws SQLException {\n        getResultSet().next();\n        assertEquals(\"notInBean\", getResultSet().getObject(4));\n    }\n\n    public void testGetString() throws SQLException {\n        getResultSet().next();\n        assertEquals(\"notInBean\", getResultSet().getString(4));\n    }\n\n    /**\n     * Make sure 2 wrappers work together.\n     *\n     * @throws SQLException if a database access error occurs\n     */\n    public void testMultipleWrappers() throws Exception {\n        // Create a ResultSet with data\n        final Object[][] rows = { { null } };\n        ResultSet rs = MockResultSet.create(metaData, rows);\n\n        // Wrap the ResultSet with a null checked version\n        final SqlNullCheckedResultSet ncrs = new SqlNullCheckedResultSet(rs);\n        ncrs.setNullString(\"   trim this   \");\n        rs = ProxyFactory.instance().createResultSet(ncrs);\n\n        // Wrap the wrapper with a string trimmed version\n        rs = StringTrimmedResultSet.wrap(rs);\n\n        rs.next();\n        assertEquals(\"trim this\", rs.getString(1));\n    }\n\n}", "definition": "public class StringTrimmedResultSetTest extends BaseTestCase", "class_docstring": "\nStringTrimmedResultSetTest\n", "name": "StringTrimmedResultSetTest", "super_interfaces": [], "superclasses": "BaseTestCase", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Override\n    public void setUp() throws Exception {\n        super.setUp();\n        setResultSet(StringTrimmedResultSet.wrap(getResultSet()));\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setUp", "params": [], "body": "                                         {\n        super.setUp();\n        setResultSet(StringTrimmedResultSet.wrap(getResultSet()));\n    }", "signature": "@Override\n    public void setUp()"}, {"syntax_pass": true, "original_string": "    public void testGetObject() throws SQLException {\n        getResultSet().next();\n        assertEquals(\"notInBean\", getResultSet().getObject(4));\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGetObject", "params": [], "body": "                                                    {\n        getResultSet().next();\n        assertEquals(\"notInBean\", getResultSet().getObject(4));\n    }", "signature": "public void testGetObject()"}, {"syntax_pass": true, "original_string": "    public void testGetString() throws SQLException {\n        getResultSet().next();\n        assertEquals(\"notInBean\", getResultSet().getString(4));\n    }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testGetString", "params": [], "body": "                                                    {\n        getResultSet().next();\n        assertEquals(\"notInBean\", getResultSet().getString(4));\n    }", "signature": "public void testGetString()"}, {"syntax_pass": true, "original_string": "    public void testMultipleWrappers() throws Exception {\n        // Create a ResultSet with data\n        final Object[][] rows = { { null } };\n        ResultSet rs = MockResultSet.create(metaData, rows);\n\n        // Wrap the ResultSet with a null checked version\n        final SqlNullCheckedResultSet ncrs = new SqlNullCheckedResultSet(rs);\n        ncrs.setNullString(\"   trim this   \");\n        rs = ProxyFactory.instance().createResultSet(ncrs);\n\n        // Wrap the wrapper with a string trimmed version\n        rs = StringTrimmedResultSet.wrap(rs);\n\n        rs.next();\n        assertEquals(\"trim this\", rs.getString(1));\n    }", "docstring": "\nMake sure 2 wrappers work together.\n\n@throws SQLException if a database access error occurs\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testMultipleWrappers", "params": [], "body": "                                                        {\n        // Create a ResultSet with data\n        final Object[][] rows = { { null } };\n        ResultSet rs = MockResultSet.create(metaData, rows);\n\n        // Wrap the ResultSet with a null checked version\n        final SqlNullCheckedResultSet ncrs = new SqlNullCheckedResultSet(rs);\n        ncrs.setNullString(\"   trim this   \");\n        rs = ProxyFactory.instance().createResultSet(ncrs);\n\n        // Wrap the wrapper with a string trimmed version\n        rs = StringTrimmedResultSet.wrap(rs);\n\n        rs.next();\n        assertEquals(\"trim this\", rs.getString(1));\n    }", "signature": "public void testMultipleWrappers()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/apache/commons/dbutils/Column.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n/**\n * Annotation for BeanProcessor to receive hints of the field name rather than dissecting the method name.\n *\n * @since 1.8.0\n */\n@Target({ ElementType.METHOD})\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Column {\n\n    String name() default \"\";\n}\n", "file_hash": "c6c08ea7f1f3ba610b9c74f4a4cf618aec0b1dde28246506ff19de6fb19b5f11", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils;", "import java.lang.annotation.ElementType;", "import java.lang.annotation.Retention;", "import java.lang.annotation.RetentionPolicy;", "import java.lang.annotation.Target;"], "methods": [], "classes": [], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/apache/commons/dbutils/StatementConfiguration.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils;\n\nimport java.time.Duration;\n\n/**\n * Configuration options for a {@link java.sql.Statement} when preparing statements in {@code QueryRunner}.\n */\npublic class StatementConfiguration {\n    /**\n     * Builder class for {@code StatementConfiguration} for more flexible construction.\n     */\n    public static final class Builder {\n        private Integer fetchDirection;\n        private Integer fetchSize;\n        private Integer maxRows;\n        private Duration queryTimeout;\n        private Integer maxFieldSize;\n\n        /**\n         * @return A new and configured {@link StatementConfiguration}.\n         */\n        public StatementConfiguration build() {\n            return new StatementConfiguration(fetchDirection, fetchSize, maxFieldSize, maxRows, queryTimeout);\n        }\n\n        /**\n         * @param fetchDirection The direction for fetching rows from database tables.\n         * @return This builder for chaining.\n         * @see StatementConfiguration#getFetchDirection()\n         */\n        public Builder fetchDirection(final Integer fetchDirection) {\n            this.fetchDirection = fetchDirection;\n            return this;\n        }\n\n        /**\n         * @param fetchSize The number of rows that should be fetched from the database when more rows are needed.\n         * @return This builder for chaining.\n         * @see StatementConfiguration#getFetchSize()\n         */\n        public Builder fetchSize(final Integer fetchSize) {\n            this.fetchSize = fetchSize;\n            return this;\n        }\n\n        /**\n         * @param maxFieldSize The maximum number of bytes that can be returned for character and binary column values.\n         * @return This builder for chaining.\n         * @see StatementConfiguration#getMaxFieldSize()\n         */\n        public Builder maxFieldSize(final Integer maxFieldSize) {\n            this.maxFieldSize = maxFieldSize;\n            return this;\n        }\n\n        /**\n         * @param maxRows The maximum number of rows that a {@code ResultSet} can produce.\n         * @return This builder for chaining.\n         * @see StatementConfiguration#getMaxRows()\n         */\n        public Builder maxRows(final Integer maxRows) {\n            this.maxRows = maxRows;\n            return this;\n        }\n\n        /**\n         * @param queryTimeout The number of seconds the driver will wait for execution.\n         * @return This builder for chaining.\n         * @see StatementConfiguration#getQueryTimeoutDuration()\n         * @since 1.8.0\n         */\n        public Builder queryTimeout(final Duration queryTimeout) {\n            this.queryTimeout = queryTimeout;\n            return this;\n        }\n\n        /**\n         * @param queryTimeout The number of seconds the driver will wait for execution.\n         * @return This builder for chaining.\n         * @see StatementConfiguration#getQueryTimeout()\n         * @deprecated Use {@link #queryTimeout(Duration)}.\n         */\n        @Deprecated\n        public Builder queryTimeout(final Integer queryTimeout) {\n            this.queryTimeout = queryTimeout != null ? Duration.ofSeconds(queryTimeout) : null;\n            return this;\n        }\n    }\n\n    private final Integer fetchDirection;\n    private final Integer fetchSize;\n    private final Integer maxFieldSize;\n    private final Integer maxRows;\n    private final Duration queryTimeout;\n\n    /**\n     * Constructor for {@code StatementConfiguration}.  For more flexibility, use {@link Builder}.\n     *\n     * @param fetchDirection The direction for fetching rows from database tables.\n     * @param fetchSize The number of rows that should be fetched from the database when more rows are needed.\n     * @param maxFieldSize The maximum number of bytes that can be returned for character and binary column values.\n     * @param maxRows The maximum number of rows that a {@code ResultSet} can produce.\n     * @param queryTimeout The number of seconds the driver will wait for execution.\n     * @since 1.8.0\n     */\n    public StatementConfiguration(final Integer fetchDirection, final Integer fetchSize,\n                                  final Integer maxFieldSize, final Integer maxRows,\n                                  final Duration queryTimeout) {\n        this.fetchDirection = fetchDirection;\n        this.fetchSize = fetchSize;\n        this.maxFieldSize = maxFieldSize;\n        this.maxRows = maxRows;\n        if (queryTimeout != null && queryTimeout.getSeconds() > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(String.format(\"queryTimeout overflow: %d > %,d\", queryTimeout.getSeconds(), Integer.MAX_VALUE));\n        }\n        this.queryTimeout = queryTimeout;\n    }\n\n    /**\n     * Constructor for {@code StatementConfiguration}.  For more flexibility, use {@link Builder}.\n     *\n     * @param fetchDirection The direction for fetching rows from database tables.\n     * @param fetchSize The number of rows that should be fetched from the database when more rows are needed.\n     * @param maxFieldSize The maximum number of bytes that can be returned for character and binary column values.\n     * @param maxRows The maximum number of rows that a {@code ResultSet} can produce.\n     * @param queryTimeout The number of seconds the driver will wait for execution.\n     * @deprecated Use {@link StatementConfiguration#StatementConfiguration(Integer, Integer, Integer, Integer, Duration)}.\n     */\n    @Deprecated\n    public StatementConfiguration(final Integer fetchDirection, final Integer fetchSize,\n                                  final Integer maxFieldSize, final Integer maxRows,\n                                  final Integer queryTimeout) {\n        this(fetchDirection, fetchSize, maxFieldSize, maxRows, Duration.ofSeconds(queryTimeout));\n    }\n\n    /** Does nothing. */\n    @Override\n    protected final void finalize() {\n        // SpotBugs CT_CONSTRUCTOR_THROW\n    }\n\n    /**\n     * Gets the fetch direction.\n     *\n     * @return The direction to fetch or null if not set.\n     */\n    public Integer getFetchDirection() {\n        return fetchDirection;\n    }\n\n    /**\n     * Gets the fetch size.\n     *\n     * @return The fetch size or null if not set.\n     */\n    public Integer getFetchSize() {\n        return fetchSize;\n    }\n\n    /**\n     * Gets the max field size.\n     *\n     * @return The max field size or null if not set.\n     */\n    public Integer getMaxFieldSize() {\n        return maxFieldSize;\n    }\n\n    /**\n     * Gets the max rows.\n     *\n     * @return The max rows or null if not set.\n     */\n    public Integer getMaxRows() {\n        return maxRows;\n    }\n\n    /**\n     * Gets the query timeout.\n     *\n     * @return The query timeout or null if not set.\n     * @deprecated Use {@link #getQueryTimeoutDuration()}.\n     */\n    @Deprecated\n    public Integer getQueryTimeout() {\n        return queryTimeout != null ? (int) queryTimeout.getSeconds() : null;\n    }\n\n    /**\n     * Gets the query timeout.\n     *\n     * @return The query timeout or null if not set.\n     * @since 1.8.0\n     */\n    public Duration getQueryTimeoutDuration() {\n        return queryTimeout;\n    }\n\n    /**\n     * Whether fetch direction is set.\n     *\n     * @return true if set, false otherwise.\n     */\n    public boolean isFetchDirectionSet() {\n        return fetchDirection != null;\n    }\n\n    /**\n     * Whether fetch size is set.\n     *\n     * @return true if set, false otherwise.\n     */\n    public boolean isFetchSizeSet() {\n        return fetchSize != null;\n    }\n\n    /**\n     * Whether max field size is set.\n     *\n     * @return true if set, false otherwise.\n     */\n    public boolean isMaxFieldSizeSet() {\n        return maxFieldSize != null;\n    }\n\n    /**\n     * Whether max rows is set.\n     *\n     * @return true if set, false otherwise.\n     */\n    public boolean isMaxRowsSet() {\n        return maxRows != null;\n    }\n\n    /**\n     * Whether query timeout is set.\n     *\n     * @return true if set, false otherwise.\n     */\n    public boolean isQueryTimeoutSet() {\n        return queryTimeout != null;\n    }\n}\n", "file_hash": "f23e261419114f82f24f8b9ad4b2c8fb3f3bc7335fbb5860b2fae86338c0e0db", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils;", "import java.time.Duration;"], "methods": [], "classes": [{"original_string": "public class StatementConfiguration {\n    /**\n     * Builder class for {@code StatementConfiguration} for more flexible construction.\n     */\n    public static final class Builder {\n        private Integer fetchDirection;\n        private Integer fetchSize;\n        private Integer maxRows;\n        private Duration queryTimeout;\n        private Integer maxFieldSize;\n\n        /**\n         * @return A new and configured {@link StatementConfiguration}.\n         */\n        public StatementConfiguration build() {\n            return new StatementConfiguration(fetchDirection, fetchSize, maxFieldSize, maxRows, queryTimeout);\n        }\n\n        /**\n         * @param fetchDirection The direction for fetching rows from database tables.\n         * @return This builder for chaining.\n         * @see StatementConfiguration#getFetchDirection()\n         */\n        public Builder fetchDirection(final Integer fetchDirection) {\n            this.fetchDirection = fetchDirection;\n            return this;\n        }\n\n        /**\n         * @param fetchSize The number of rows that should be fetched from the database when more rows are needed.\n         * @return This builder for chaining.\n         * @see StatementConfiguration#getFetchSize()\n         */\n        public Builder fetchSize(final Integer fetchSize) {\n            this.fetchSize = fetchSize;\n            return this;\n        }\n\n        /**\n         * @param maxFieldSize The maximum number of bytes that can be returned for character and binary column values.\n         * @return This builder for chaining.\n         * @see StatementConfiguration#getMaxFieldSize()\n         */\n        public Builder maxFieldSize(final Integer maxFieldSize) {\n            this.maxFieldSize = maxFieldSize;\n            return this;\n        }\n\n        /**\n         * @param maxRows The maximum number of rows that a {@code ResultSet} can produce.\n         * @return This builder for chaining.\n         * @see StatementConfiguration#getMaxRows()\n         */\n        public Builder maxRows(final Integer maxRows) {\n            this.maxRows = maxRows;\n            return this;\n        }\n\n        /**\n         * @param queryTimeout The number of seconds the driver will wait for execution.\n         * @return This builder for chaining.\n         * @see StatementConfiguration#getQueryTimeoutDuration()\n         * @since 1.8.0\n         */\n        public Builder queryTimeout(final Duration queryTimeout) {\n            this.queryTimeout = queryTimeout;\n            return this;\n        }\n\n        /**\n         * @param queryTimeout The number of seconds the driver will wait for execution.\n         * @return This builder for chaining.\n         * @see StatementConfiguration#getQueryTimeout()\n         * @deprecated Use {@link #queryTimeout(Duration)}.\n         */\n        @Deprecated\n        public Builder queryTimeout(final Integer queryTimeout) {\n            this.queryTimeout = queryTimeout != null ? Duration.ofSeconds(queryTimeout) : null;\n            return this;\n        }\n    }\n\n    private final Integer fetchDirection;\n    private final Integer fetchSize;\n    private final Integer maxFieldSize;\n    private final Integer maxRows;\n    private final Duration queryTimeout;\n\n    /**\n     * Constructor for {@code StatementConfiguration}.  For more flexibility, use {@link Builder}.\n     *\n     * @param fetchDirection The direction for fetching rows from database tables.\n     * @param fetchSize The number of rows that should be fetched from the database when more rows are needed.\n     * @param maxFieldSize The maximum number of bytes that can be returned for character and binary column values.\n     * @param maxRows The maximum number of rows that a {@code ResultSet} can produce.\n     * @param queryTimeout The number of seconds the driver will wait for execution.\n     * @since 1.8.0\n     */\n    public StatementConfiguration(final Integer fetchDirection, final Integer fetchSize,\n                                  final Integer maxFieldSize, final Integer maxRows,\n                                  final Duration queryTimeout) {\n        this.fetchDirection = fetchDirection;\n        this.fetchSize = fetchSize;\n        this.maxFieldSize = maxFieldSize;\n        this.maxRows = maxRows;\n        if (queryTimeout != null && queryTimeout.getSeconds() > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(String.format(\"queryTimeout overflow: %d > %,d\", queryTimeout.getSeconds(), Integer.MAX_VALUE));\n        }\n        this.queryTimeout = queryTimeout;\n    }\n\n    /**\n     * Constructor for {@code StatementConfiguration}.  For more flexibility, use {@link Builder}.\n     *\n     * @param fetchDirection The direction for fetching rows from database tables.\n     * @param fetchSize The number of rows that should be fetched from the database when more rows are needed.\n     * @param maxFieldSize The maximum number of bytes that can be returned for character and binary column values.\n     * @param maxRows The maximum number of rows that a {@code ResultSet} can produce.\n     * @param queryTimeout The number of seconds the driver will wait for execution.\n     * @deprecated Use {@link StatementConfiguration#StatementConfiguration(Integer, Integer, Integer, Integer, Duration)}.\n     */\n    @Deprecated\n    public StatementConfiguration(final Integer fetchDirection, final Integer fetchSize,\n                                  final Integer maxFieldSize, final Integer maxRows,\n                                  final Integer queryTimeout) {\n        this(fetchDirection, fetchSize, maxFieldSize, maxRows, Duration.ofSeconds(queryTimeout));\n    }\n\n    /** Does nothing. */\n    @Override\n    protected final void finalize() {\n        // SpotBugs CT_CONSTRUCTOR_THROW\n    }\n\n    /**\n     * Gets the fetch direction.\n     *\n     * @return The direction to fetch or null if not set.\n     */\n    public Integer getFetchDirection() {\n        return fetchDirection;\n    }\n\n    /**\n     * Gets the fetch size.\n     *\n     * @return The fetch size or null if not set.\n     */\n    public Integer getFetchSize() {\n        return fetchSize;\n    }\n\n    /**\n     * Gets the max field size.\n     *\n     * @return The max field size or null if not set.\n     */\n    public Integer getMaxFieldSize() {\n        return maxFieldSize;\n    }\n\n    /**\n     * Gets the max rows.\n     *\n     * @return The max rows or null if not set.\n     */\n    public Integer getMaxRows() {\n        return maxRows;\n    }\n\n    /**\n     * Gets the query timeout.\n     *\n     * @return The query timeout or null if not set.\n     * @deprecated Use {@link #getQueryTimeoutDuration()}.\n     */\n    @Deprecated\n    public Integer getQueryTimeout() {\n        return queryTimeout != null ? (int) queryTimeout.getSeconds() : null;\n    }\n\n    /**\n     * Gets the query timeout.\n     *\n     * @return The query timeout or null if not set.\n     * @since 1.8.0\n     */\n    public Duration getQueryTimeoutDuration() {\n        return queryTimeout;\n    }\n\n    /**\n     * Whether fetch direction is set.\n     *\n     * @return true if set, false otherwise.\n     */\n    public boolean isFetchDirectionSet() {\n        return fetchDirection != null;\n    }\n\n    /**\n     * Whether fetch size is set.\n     *\n     * @return true if set, false otherwise.\n     */\n    public boolean isFetchSizeSet() {\n        return fetchSize != null;\n    }\n\n    /**\n     * Whether max field size is set.\n     *\n     * @return true if set, false otherwise.\n     */\n    public boolean isMaxFieldSizeSet() {\n        return maxFieldSize != null;\n    }\n\n    /**\n     * Whether max rows is set.\n     *\n     * @return true if set, false otherwise.\n     */\n    public boolean isMaxRowsSet() {\n        return maxRows != null;\n    }\n\n    /**\n     * Whether query timeout is set.\n     *\n     * @return true if set, false otherwise.\n     */\n    public boolean isQueryTimeoutSet() {\n        return queryTimeout != null;\n    }\n}", "definition": "public class StatementConfiguration", "class_docstring": "\nConfiguration options for a {@link java.sql.Statement} when preparing statements in {@code QueryRunner}.\n", "name": "StatementConfiguration", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final Integer fetchDirection;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Integer", "name": "fetchDirection", "syntax_pass": true}, {"attribute_expression": "private final Integer fetchSize;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Integer", "name": "fetchSize", "syntax_pass": true}, {"attribute_expression": "private final Integer maxFieldSize;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Integer", "name": "maxFieldSize", "syntax_pass": true}, {"attribute_expression": "private final Integer maxRows;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Integer", "name": "maxRows", "syntax_pass": true}, {"attribute_expression": "private final Duration queryTimeout;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Duration", "name": "queryTimeout", "syntax_pass": true}], "classes": [{"original_string": "    public static final class Builder {\n        private Integer fetchDirection;\n        private Integer fetchSize;\n        private Integer maxRows;\n        private Duration queryTimeout;\n        private Integer maxFieldSize;\n\n        /**\n         * @return A new and configured {@link StatementConfiguration}.\n         */\n        public StatementConfiguration build() {\n            return new StatementConfiguration(fetchDirection, fetchSize, maxFieldSize, maxRows, queryTimeout);\n        }\n\n        /**\n         * @param fetchDirection The direction for fetching rows from database tables.\n         * @return This builder for chaining.\n         * @see StatementConfiguration#getFetchDirection()\n         */\n        public Builder fetchDirection(final Integer fetchDirection) {\n            this.fetchDirection = fetchDirection;\n            return this;\n        }\n\n        /**\n         * @param fetchSize The number of rows that should be fetched from the database when more rows are needed.\n         * @return This builder for chaining.\n         * @see StatementConfiguration#getFetchSize()\n         */\n        public Builder fetchSize(final Integer fetchSize) {\n            this.fetchSize = fetchSize;\n            return this;\n        }\n\n        /**\n         * @param maxFieldSize The maximum number of bytes that can be returned for character and binary column values.\n         * @return This builder for chaining.\n         * @see StatementConfiguration#getMaxFieldSize()\n         */\n        public Builder maxFieldSize(final Integer maxFieldSize) {\n            this.maxFieldSize = maxFieldSize;\n            return this;\n        }\n\n        /**\n         * @param maxRows The maximum number of rows that a {@code ResultSet} can produce.\n         * @return This builder for chaining.\n         * @see StatementConfiguration#getMaxRows()\n         */\n        public Builder maxRows(final Integer maxRows) {\n            this.maxRows = maxRows;\n            return this;\n        }\n\n        /**\n         * @param queryTimeout The number of seconds the driver will wait for execution.\n         * @return This builder for chaining.\n         * @see StatementConfiguration#getQueryTimeoutDuration()\n         * @since 1.8.0\n         */\n        public Builder queryTimeout(final Duration queryTimeout) {\n            this.queryTimeout = queryTimeout;\n            return this;\n        }\n\n        /**\n         * @param queryTimeout The number of seconds the driver will wait for execution.\n         * @return This builder for chaining.\n         * @see StatementConfiguration#getQueryTimeout()\n         * @deprecated Use {@link #queryTimeout(Duration)}.\n         */\n        @Deprecated\n        public Builder queryTimeout(final Integer queryTimeout) {\n            this.queryTimeout = queryTimeout != null ? Duration.ofSeconds(queryTimeout) : null;\n            return this;\n        }\n    }", "definition": "    public static final class Builder", "class_docstring": "\nBuilder class for {@code StatementConfiguration} for more flexible construction.\n", "name": "Builder", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [{"attribute_expression": "private Integer fetchDirection;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Integer", "name": "fetchDirection", "syntax_pass": true}, {"attribute_expression": "private Integer fetchSize;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Integer", "name": "fetchSize", "syntax_pass": true}, {"attribute_expression": "private Integer maxRows;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Integer", "name": "maxRows", "syntax_pass": true}, {"attribute_expression": "private Duration queryTimeout;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Duration", "name": "queryTimeout", "syntax_pass": true}, {"attribute_expression": "private Integer maxFieldSize;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Integer", "name": "maxFieldSize", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public StatementConfiguration build() {\n            return new StatementConfiguration(fetchDirection, fetchSize, maxFieldSize, maxRows, queryTimeout);\n        }", "docstring": "\n@return A new and configured {@link StatementConfiguration}.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "StatementConfiguration", "classes": []}, "name": "build", "params": [], "body": "                                              {\n            return new StatementConfiguration(fetchDirection, fetchSize, maxFieldSize, maxRows, queryTimeout);\n        }", "signature": "public StatementConfiguration build()"}, {"syntax_pass": true, "original_string": "        public Builder fetchDirection(final Integer fetchDirection) {\n            this.fetchDirection = fetchDirection;\n            return this;\n        }", "docstring": "\n@param fetchDirection The direction for fetching rows from database tables.\n@return This builder for chaining.\n@see StatementConfiguration#getFetchDirection()\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "fetchDirection", "params": [{"name": "fetchDirection", "type": "Integer"}], "body": "                                                                    {\n            this.fetchDirection = fetchDirection;\n            return this;\n        }", "signature": "public Builder fetchDirection(final Integer fetchDirection)"}, {"syntax_pass": true, "original_string": "        public Builder fetchSize(final Integer fetchSize) {\n            this.fetchSize = fetchSize;\n            return this;\n        }", "docstring": "\n@param fetchSize The number of rows that should be fetched from the database when more rows are needed.\n@return This builder for chaining.\n@see StatementConfiguration#getFetchSize()\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "fetchSize", "params": [{"name": "fetchSize", "type": "Integer"}], "body": "                                                          {\n            this.fetchSize = fetchSize;\n            return this;\n        }", "signature": "public Builder fetchSize(final Integer fetchSize)"}, {"syntax_pass": true, "original_string": "        public Builder maxFieldSize(final Integer maxFieldSize) {\n            this.maxFieldSize = maxFieldSize;\n            return this;\n        }", "docstring": "\n@param maxFieldSize The maximum number of bytes that can be returned for character and binary column values.\n@return This builder for chaining.\n@see StatementConfiguration#getMaxFieldSize()\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "maxFieldSize", "params": [{"name": "maxFieldSize", "type": "Integer"}], "body": "                                                                {\n            this.maxFieldSize = maxFieldSize;\n            return this;\n        }", "signature": "public Builder maxFieldSize(final Integer maxFieldSize)"}, {"syntax_pass": true, "original_string": "        public Builder maxRows(final Integer maxRows) {\n            this.maxRows = maxRows;\n            return this;\n        }", "docstring": "\n@param maxRows The maximum number of rows that a {@code ResultSet} can produce.\n@return This builder for chaining.\n@see StatementConfiguration#getMaxRows()\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "maxRows", "params": [{"name": "maxRows", "type": "Integer"}], "body": "                                                      {\n            this.maxRows = maxRows;\n            return this;\n        }", "signature": "public Builder maxRows(final Integer maxRows)"}, {"syntax_pass": true, "original_string": "        public Builder queryTimeout(final Duration queryTimeout) {\n            this.queryTimeout = queryTimeout;\n            return this;\n        }", "docstring": "\n@param queryTimeout The number of seconds the driver will wait for execution.\n@return This builder for chaining.\n@see StatementConfiguration#getQueryTimeoutDuration()\n@since 1.8.0\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "queryTimeout", "params": [{"name": "queryTimeout", "type": "Duration"}], "body": "                                                                 {\n            this.queryTimeout = queryTimeout;\n            return this;\n        }", "signature": "public Builder queryTimeout(final Duration queryTimeout)"}, {"syntax_pass": true, "original_string": "        @Deprecated\n        public Builder queryTimeout(final Integer queryTimeout) {\n            this.queryTimeout = queryTimeout != null ? Duration.ofSeconds(queryTimeout) : null;\n            return this;\n        }", "docstring": "\n@param queryTimeout The number of seconds the driver will wait for execution.\n@return This builder for chaining.\n@see StatementConfiguration#getQueryTimeout()\n@deprecated Use {@link #queryTimeout(Duration)}.\n", "attributes": {"modifiers": "@Deprecated\n        public", "marker_annotations": ["@Deprecated"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Builder", "classes": []}, "name": "queryTimeout", "params": [{"name": "queryTimeout", "type": "Integer"}], "body": "                                                                {\n            this.queryTimeout = queryTimeout != null ? Duration.ofSeconds(queryTimeout) : null;\n            return this;\n        }", "signature": "@Deprecated\n        public Builder queryTimeout(final Integer queryTimeout)"}]}]}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public StatementConfiguration(final Integer fetchDirection, final Integer fetchSize,\n                                  final Integer maxFieldSize, final Integer maxRows,\n                                  final Duration queryTimeout) {\n        this.fetchDirection = fetchDirection;\n        this.fetchSize = fetchSize;\n        this.maxFieldSize = maxFieldSize;\n        this.maxRows = maxRows;\n        if (queryTimeout != null && queryTimeout.getSeconds() > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(String.format(\"queryTimeout overflow: %d > %,d\", queryTimeout.getSeconds(), Integer.MAX_VALUE));\n        }\n        this.queryTimeout = queryTimeout;\n    }", "docstring": "\nConstructor for {@code StatementConfiguration}.  For more flexibility, use {@link Builder}.\n\n@param fetchDirection The direction for fetching rows from database tables.\n@param fetchSize The number of rows that should be fetched from the database when more rows are needed.\n@param maxFieldSize The maximum number of bytes that can be returned for character and binary column values.\n@param maxRows The maximum number of rows that a {@code ResultSet} can produce.\n@param queryTimeout The number of seconds the driver will wait for execution.\n@since 1.8.0\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "StatementConfiguration", "params": [{"name": "fetchDirection", "type": "Integer"}, {"name": "fetchSize", "type": "Integer"}, {"name": "maxFieldSize", "type": "Integer"}, {"name": "maxRows", "type": "Integer"}, {"name": "queryTimeout", "type": "Duration"}], "body": "                                                               {\n        this.fetchDirection = fetchDirection;\n        this.fetchSize = fetchSize;\n        this.maxFieldSize = maxFieldSize;\n        this.maxRows = maxRows;\n        if (queryTimeout != null && queryTimeout.getSeconds() > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(String.format(\"queryTimeout overflow: %d > %,d\", queryTimeout.getSeconds(), Integer.MAX_VALUE));\n        }\n        this.queryTimeout = queryTimeout;\n    }", "signature": "public StatementConfiguration(final Integer fetchDirection, final Integer fetchSize,\n                                  final Integer maxFieldSize, final Integer maxRows,\n                                  final Duration queryTimeout)"}, {"syntax_pass": true, "original_string": "    @Deprecated\n    public StatementConfiguration(final Integer fetchDirection, final Integer fetchSize,\n                                  final Integer maxFieldSize, final Integer maxRows,\n                                  final Integer queryTimeout) {\n        this(fetchDirection, fetchSize, maxFieldSize, maxRows, Duration.ofSeconds(queryTimeout));\n    }", "docstring": "\nConstructor for {@code StatementConfiguration}.  For more flexibility, use {@link Builder}.\n\n@param fetchDirection The direction for fetching rows from database tables.\n@param fetchSize The number of rows that should be fetched from the database when more rows are needed.\n@param maxFieldSize The maximum number of bytes that can be returned for character and binary column values.\n@param maxRows The maximum number of rows that a {@code ResultSet} can produce.\n@param queryTimeout The number of seconds the driver will wait for execution.\n@deprecated Use {@link StatementConfiguration#StatementConfiguration(Integer, Integer, Integer, Integer, Duration)}.\n", "attributes": {"modifiers": "@Deprecated\n    public", "marker_annotations": ["@Deprecated"], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "StatementConfiguration", "params": [{"name": "fetchDirection", "type": "Integer"}, {"name": "fetchSize", "type": "Integer"}, {"name": "maxFieldSize", "type": "Integer"}, {"name": "maxRows", "type": "Integer"}, {"name": "queryTimeout", "type": "Integer"}], "body": "                                                              {\n        this(fetchDirection, fetchSize, maxFieldSize, maxRows, Duration.ofSeconds(queryTimeout));\n    }", "signature": "@Deprecated\n    public StatementConfiguration(final Integer fetchDirection, final Integer fetchSize,\n                                  final Integer maxFieldSize, final Integer maxRows,\n                                  final Integer queryTimeout)"}, {"syntax_pass": true, "original_string": "    @Override\n    protected final void finalize() {\n        // SpotBugs CT_CONSTRUCTOR_THROW\n    }", "docstring": " Does nothing.", "attributes": {"modifiers": "@Override\n    protected final", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "finalize", "params": [], "body": "                                    {\n        // SpotBugs CT_CONSTRUCTOR_THROW\n    }", "signature": "@Override\n    protected final void finalize()"}, {"syntax_pass": true, "original_string": "    public Integer getFetchDirection() {\n        return fetchDirection;\n    }", "docstring": "\nGets the fetch direction.\n\n@return The direction to fetch or null if not set.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Integer", "classes": []}, "name": "getFetchDirection", "params": [], "body": "                                       {\n        return fetchDirection;\n    }", "signature": "public Integer getFetchDirection()"}, {"syntax_pass": true, "original_string": "    public Integer getFetchSize() {\n        return fetchSize;\n    }", "docstring": "\nGets the fetch size.\n\n@return The fetch size or null if not set.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Integer", "classes": []}, "name": "getFetchSize", "params": [], "body": "                                  {\n        return fetchSize;\n    }", "signature": "public Integer getFetchSize()"}, {"syntax_pass": true, "original_string": "    public Integer getMaxFieldSize() {\n        return maxFieldSize;\n    }", "docstring": "\nGets the max field size.\n\n@return The max field size or null if not set.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Integer", "classes": []}, "name": "getMaxFieldSize", "params": [], "body": "                                     {\n        return maxFieldSize;\n    }", "signature": "public Integer getMaxFieldSize()"}, {"syntax_pass": true, "original_string": "    public Integer getMaxRows() {\n        return maxRows;\n    }", "docstring": "\nGets the max rows.\n\n@return The max rows or null if not set.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Integer", "classes": []}, "name": "getMaxRows", "params": [], "body": "                                {\n        return maxRows;\n    }", "signature": "public Integer getMaxRows()"}, {"syntax_pass": true, "original_string": "    @Deprecated\n    public Integer getQueryTimeout() {\n        return queryTimeout != null ? (int) queryTimeout.getSeconds() : null;\n    }", "docstring": "\nGets the query timeout.\n\n@return The query timeout or null if not set.\n@deprecated Use {@link #getQueryTimeoutDuration()}.\n", "attributes": {"modifiers": "@Deprecated\n    public", "marker_annotations": ["@Deprecated"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Integer", "classes": []}, "name": "getQueryTimeout", "params": [], "body": "                                     {\n        return queryTimeout != null ? (int) queryTimeout.getSeconds() : null;\n    }", "signature": "@Deprecated\n    public Integer getQueryTimeout()"}, {"syntax_pass": true, "original_string": "    public Duration getQueryTimeoutDuration() {\n        return queryTimeout;\n    }", "docstring": "\nGets the query timeout.\n\n@return The query timeout or null if not set.\n@since 1.8.0\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Duration", "classes": []}, "name": "getQueryTimeoutDuration", "params": [], "body": "                                              {\n        return queryTimeout;\n    }", "signature": "public Duration getQueryTimeoutDuration()"}, {"syntax_pass": true, "original_string": "    public boolean isFetchDirectionSet() {\n        return fetchDirection != null;\n    }", "docstring": "\nWhether fetch direction is set.\n\n@return true if set, false otherwise.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isFetchDirectionSet", "params": [], "body": "                                         {\n        return fetchDirection != null;\n    }", "signature": "public boolean isFetchDirectionSet()"}, {"syntax_pass": true, "original_string": "    public boolean isFetchSizeSet() {\n        return fetchSize != null;\n    }", "docstring": "\nWhether fetch size is set.\n\n@return true if set, false otherwise.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isFetchSizeSet", "params": [], "body": "                                    {\n        return fetchSize != null;\n    }", "signature": "public boolean isFetchSizeSet()"}, {"syntax_pass": true, "original_string": "    public boolean isMaxFieldSizeSet() {\n        return maxFieldSize != null;\n    }", "docstring": "\nWhether max field size is set.\n\n@return true if set, false otherwise.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isMaxFieldSizeSet", "params": [], "body": "                                       {\n        return maxFieldSize != null;\n    }", "signature": "public boolean isMaxFieldSizeSet()"}, {"syntax_pass": true, "original_string": "    public boolean isMaxRowsSet() {\n        return maxRows != null;\n    }", "docstring": "\nWhether max rows is set.\n\n@return true if set, false otherwise.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isMaxRowsSet", "params": [], "body": "                                  {\n        return maxRows != null;\n    }", "signature": "public boolean isMaxRowsSet()"}, {"syntax_pass": true, "original_string": "    public boolean isQueryTimeoutSet() {\n        return queryTimeout != null;\n    }", "docstring": "\nWhether query timeout is set.\n\n@return true if set, false otherwise.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isQueryTimeoutSet", "params": [], "body": "                                       {\n        return queryTimeout != null;\n    }", "signature": "public boolean isQueryTimeoutSet()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/apache/commons/dbutils/ColumnHandler.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils;\n\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\n\n/**\n * Defines how to process columns when constructing a bean from a {@link ResultSet}. Instances do the work of retrieving data from a {@code ResultSet}.\n *\n * @param <T> The return type.\n */\npublic interface ColumnHandler<T> {\n\n    /**\n     * Retrieves the current row's column value from a {@link ResultSet} and stores it into an instance of {@code propType}. This method is only called if\n     * {@link #match(Class)} returns true.\n     *\n     * @param resultSet   The source result set. This must be on the correct row.\n     * @param columnIndex The position of the column to retrieve, a 1-based index.\n     * @return The converted value or the original value if something doesn't work out.\n     * @throws SQLException if the columnIndex is not valid; if a database access error occurs or this method is called on a closed result set\n     */\n    T apply(ResultSet resultSet, int columnIndex) throws SQLException;\n\n    /**\n     * Tests whether to handle a column targeted for a value type matching {@code propType}.\n     *\n     * @param propType The type of the target parameter.\n     * @return true is this property handler handles this {@code propType}; false otherwise.\n     */\n    boolean match(Class<?> propType);\n}\n", "file_hash": "61ee38fb0e843911def86f5143b6f07e2941a73322cc6cd918d1dc99a3f67501", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils;", "import java.sql.ResultSet;", "import java.sql.SQLException;"], "methods": [], "classes": [], "interfaces": [{"original_string": "public interface ColumnHandler<T> {\n\n    /**\n     * Retrieves the current row's column value from a {@link ResultSet} and stores it into an instance of {@code propType}. This method is only called if\n     * {@link #match(Class)} returns true.\n     *\n     * @param resultSet   The source result set. This must be on the correct row.\n     * @param columnIndex The position of the column to retrieve, a 1-based index.\n     * @return The converted value or the original value if something doesn't work out.\n     * @throws SQLException if the columnIndex is not valid; if a database access error occurs or this method is called on a closed result set\n     */\n    T apply(ResultSet resultSet, int columnIndex) throws SQLException;\n\n    /**\n     * Tests whether to handle a column targeted for a value type matching {@code propType}.\n     *\n     * @param propType The type of the target parameter.\n     * @return true is this property handler handles this {@code propType}; false otherwise.\n     */\n    boolean match(Class<?> propType);\n}", "definition": "public interface ColumnHandler<T>", "interface_docstring": "\nDefines how to process columns when constructing a bean from a {@link ResultSet}. Instances do the work of retrieving data from a {@code ResultSet}.\n\n@param <T> The return type.\n", "name": "ColumnHandler", "extends_interfaces": [], "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    T apply(ResultSet resultSet, int columnIndex) throws SQLException;", "docstring": "\nRetrieves the current row's column value from a {@link ResultSet} and stores it into an instance of {@code propType}. This method is only called if\n{@link #match(Class)} returns true.\n\n@param resultSet   The source result set. This must be on the correct row.\n@param columnIndex The position of the column to retrieve, a 1-based index.\n@return The converted value or the original value if something doesn't work out.\n@throws SQLException if the columnIndex is not valid; if a database access error occurs or this method is called on a closed result set\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "T", "classes": []}, "name": "apply", "params": [{"name": "resultSet", "type": "ResultSet"}, {"name": "columnIndex", "type": "int"}], "body": "", "signature": "T apply(ResultSet resultSet, int columnIndex)"}, {"syntax_pass": true, "original_string": "    boolean match(Class<?> propType);", "docstring": "\nTests whether to handle a column targeted for a value type matching {@code propType}.\n\n@param propType The type of the target parameter.\n@return true is this property handler handles this {@code propType}; false otherwise.\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "boolean", "classes": []}, "name": "match", "params": [{"name": "propType", "type": "Class<?>"}], "body": "", "signature": "boolean match(Class<?> propType)"}]}], "records": []}, {"relative_path": "src/main/java/org/apache/commons/dbutils/ResultSetIterator.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils;\n\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Iterator;\n\n/**\n * <p>\n * Wraps a {@code ResultSet} in an {@code Iterator&lt;Object[]&gt;}.  This is useful\n * when you want to present a non-database application layer with domain\n * neutral data.\n * </p>\n *\n * <p>\n * This implementation requires the {@code ResultSet.isLast()} method\n * to be implemented.\n * </p>\n */\npublic class ResultSetIterator implements Iterator<Object[]> {\n\n    /**\n     * Generates an {@code Iterable}, suitable for use in for-each loops.\n     *\n     * @param resultSet Wrap this {@code ResultSet} in an {@code Iterator}.\n     * @return an {@code Iterable}, suitable for use in for-each loops.\n     */\n    public static Iterable<Object[]> iterable(final ResultSet resultSet) {\n        return () -> new ResultSetIterator(resultSet);\n    }\n\n    /**\n     * The wrapped {@code ResultSet}.\n     */\n    private final ResultSet resultSet;\n\n    /**\n     * The processor to use when converting a row into an Object[].\n     */\n    private final RowProcessor convert;\n\n    /**\n     * Constructor for ResultSetIterator.\n     * @param resultSet Wrap this {@code ResultSet} in an {@code Iterator}.\n     */\n    public ResultSetIterator(final ResultSet resultSet) {\n        this(resultSet, new BasicRowProcessor());\n    }\n\n    /**\n     * Constructor for ResultSetIterator.\n     * @param resultSet Wrap this {@code ResultSet} in an {@code Iterator}.\n     * @param convert The processor to use when converting a row into an\n     * {@code Object[]}.  Defaults to a\n     * {@code BasicRowProcessor}.\n     */\n    public ResultSetIterator(final ResultSet resultSet, final RowProcessor convert) {\n        this.resultSet = resultSet;\n        this.convert = convert;\n    }\n\n    /**\n     * Returns true if there are more rows in the ResultSet.\n     * @return boolean {@code true} if there are more rows\n     * @throws RuntimeException if an SQLException occurs.\n     */\n    @Override\n    public boolean hasNext() {\n        try {\n            return !resultSet.isLast();\n        } catch (final SQLException e) {\n            rethrow(e);\n            return false;\n        }\n    }\n\n    /**\n     * Returns the next row as an {@code Object[]}.\n     * @return An {@code Object[]} with the same number of elements as\n     * columns in the {@code ResultSet}.\n     * @see java.util.Iterator#next()\n     * @throws RuntimeException if an SQLException occurs.\n     */\n    @Override\n    public Object[] next() {\n        try {\n            return resultSet.next() ? this.convert.toArray(resultSet) : new Object[0];\n        } catch (final SQLException e) {\n            rethrow(e);\n            return null;\n        }\n    }\n\n    /**\n     * Deletes the current row from the {@code ResultSet}.\n     * @see java.util.Iterator#remove()\n     * @throws RuntimeException if an SQLException occurs.\n     */\n    @Override\n    public void remove() {\n        try {\n            this.resultSet.deleteRow();\n        } catch (final SQLException e) {\n            rethrow(e);\n        }\n    }\n\n    /**\n     * Rethrow the SQLException as a RuntimeException.  This implementation\n     * creates a new RuntimeException with the SQLException's error message.\n     * @param e SQLException to rethrow\n     * @since 1.1\n     */\n    protected void rethrow(final SQLException e) {\n        throw new RuntimeException(e.getMessage());\n    }\n\n}\n", "file_hash": "4c6f933369e4cd8ed49ad1f862352744c39340889780eaedc7d5bab4faaf0183", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils;", "import java.sql.ResultSet;", "import java.sql.SQLException;", "import java.util.Iterator;"], "methods": [], "classes": [{"original_string": "public class ResultSetIterator implements Iterator<Object[]> {\n\n    /**\n     * Generates an {@code Iterable}, suitable for use in for-each loops.\n     *\n     * @param resultSet Wrap this {@code ResultSet} in an {@code Iterator}.\n     * @return an {@code Iterable}, suitable for use in for-each loops.\n     */\n    public static Iterable<Object[]> iterable(final ResultSet resultSet) {\n        return () -> new ResultSetIterator(resultSet);\n    }\n\n    /**\n     * The wrapped {@code ResultSet}.\n     */\n    private final ResultSet resultSet;\n\n    /**\n     * The processor to use when converting a row into an Object[].\n     */\n    private final RowProcessor convert;\n\n    /**\n     * Constructor for ResultSetIterator.\n     * @param resultSet Wrap this {@code ResultSet} in an {@code Iterator}.\n     */\n    public ResultSetIterator(final ResultSet resultSet) {\n        this(resultSet, new BasicRowProcessor());\n    }\n\n    /**\n     * Constructor for ResultSetIterator.\n     * @param resultSet Wrap this {@code ResultSet} in an {@code Iterator}.\n     * @param convert The processor to use when converting a row into an\n     * {@code Object[]}.  Defaults to a\n     * {@code BasicRowProcessor}.\n     */\n    public ResultSetIterator(final ResultSet resultSet, final RowProcessor convert) {\n        this.resultSet = resultSet;\n        this.convert = convert;\n    }\n\n    /**\n     * Returns true if there are more rows in the ResultSet.\n     * @return boolean {@code true} if there are more rows\n     * @throws RuntimeException if an SQLException occurs.\n     */\n    @Override\n    public boolean hasNext() {\n        try {\n            return !resultSet.isLast();\n        } catch (final SQLException e) {\n            rethrow(e);\n            return false;\n        }\n    }\n\n    /**\n     * Returns the next row as an {@code Object[]}.\n     * @return An {@code Object[]} with the same number of elements as\n     * columns in the {@code ResultSet}.\n     * @see java.util.Iterator#next()\n     * @throws RuntimeException if an SQLException occurs.\n     */\n    @Override\n    public Object[] next() {\n        try {\n            return resultSet.next() ? this.convert.toArray(resultSet) : new Object[0];\n        } catch (final SQLException e) {\n            rethrow(e);\n            return null;\n        }\n    }\n\n    /**\n     * Deletes the current row from the {@code ResultSet}.\n     * @see java.util.Iterator#remove()\n     * @throws RuntimeException if an SQLException occurs.\n     */\n    @Override\n    public void remove() {\n        try {\n            this.resultSet.deleteRow();\n        } catch (final SQLException e) {\n            rethrow(e);\n        }\n    }\n\n    /**\n     * Rethrow the SQLException as a RuntimeException.  This implementation\n     * creates a new RuntimeException with the SQLException's error message.\n     * @param e SQLException to rethrow\n     * @since 1.1\n     */\n    protected void rethrow(final SQLException e) {\n        throw new RuntimeException(e.getMessage());\n    }\n\n}", "definition": "public class ResultSetIterator implements Iterator<Object[]>", "class_docstring": "\n<p>\nWraps a {@code ResultSet} in an {@code Iterator&lt;Object[]&gt;}.  This is useful\nwhen you want to present a non-database application layer with domain\nneutral data.\n</p>\n\n<p>\nThis implementation requires the {@code ResultSet.isLast()} method\nto be implemented.\n</p>\n", "name": "ResultSetIterator", "super_interfaces": ["Iterator<Object[]>"], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final ResultSet resultSet;", "docstring": "\nThe wrapped {@code ResultSet}.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ResultSet", "name": "resultSet", "syntax_pass": true}, {"attribute_expression": "private final RowProcessor convert;", "docstring": "\nThe processor to use when converting a row into an Object[].\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "RowProcessor", "name": "convert", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public static Iterable<Object[]> iterable(final ResultSet resultSet) {\n        return () -> new ResultSetIterator(resultSet);\n    }", "docstring": "\nGenerates an {@code Iterable}, suitable for use in for-each loops.\n\n@param resultSet Wrap this {@code ResultSet} in an {@code Iterator}.\n@return an {@code Iterable}, suitable for use in for-each loops.\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "Iterable<Object[]>", "classes": []}, "name": "iterable", "params": [{"name": "resultSet", "type": "ResultSet"}], "body": "                                                                         {\n        return () -> new ResultSetIterator(resultSet);\n    }", "signature": "public static Iterable<Object[]> iterable(final ResultSet resultSet)"}, {"syntax_pass": true, "original_string": "    public ResultSetIterator(final ResultSet resultSet) {\n        this(resultSet, new BasicRowProcessor());\n    }", "docstring": "\nConstructor for ResultSetIterator.\n@param resultSet Wrap this {@code ResultSet} in an {@code Iterator}.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ResultSetIterator", "params": [{"name": "resultSet", "type": "ResultSet"}], "body": "                                                        {\n        this(resultSet, new BasicRowProcessor());\n    }", "signature": "public ResultSetIterator(final ResultSet resultSet)"}, {"syntax_pass": true, "original_string": "    public ResultSetIterator(final ResultSet resultSet, final RowProcessor convert) {\n        this.resultSet = resultSet;\n        this.convert = convert;\n    }", "docstring": "\nConstructor for ResultSetIterator.\n@param resultSet Wrap this {@code ResultSet} in an {@code Iterator}.\n@param convert The processor to use when converting a row into an\n{@code Object[]}.  Defaults to a\n{@code BasicRowProcessor}.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ResultSetIterator", "params": [{"name": "resultSet", "type": "ResultSet"}, {"name": "convert", "type": "RowProcessor"}], "body": "                                                                                    {\n        this.resultSet = resultSet;\n        this.convert = convert;\n    }", "signature": "public ResultSetIterator(final ResultSet resultSet, final RowProcessor convert)"}, {"syntax_pass": true, "original_string": "    @Override\n    public boolean hasNext() {\n        try {\n            return !resultSet.isLast();\n        } catch (final SQLException e) {\n            rethrow(e);\n            return false;\n        }\n    }", "docstring": "\nReturns true if there are more rows in the ResultSet.\n@return boolean {@code true} if there are more rows\n@throws RuntimeException if an SQLException occurs.\n", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasNext", "params": [], "body": "                             {\n        try {\n            return !resultSet.isLast();\n        } catch (final SQLException e) {\n            rethrow(e);\n            return false;\n        }\n    }", "signature": "@Override\n    public boolean hasNext()"}, {"syntax_pass": true, "original_string": "    @Override\n    public Object[] next() {\n        try {\n            return resultSet.next() ? this.convert.toArray(resultSet) : new Object[0];\n        } catch (final SQLException e) {\n            rethrow(e);\n            return null;\n        }\n    }", "docstring": "\nReturns the next row as an {@code Object[]}.\n@return An {@code Object[]} with the same number of elements as\ncolumns in the {@code ResultSet}.\n@see java.util.Iterator#next()\n@throws RuntimeException if an SQLException occurs.\n", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object[]", "classes": []}, "name": "next", "params": [], "body": "                           {\n        try {\n            return resultSet.next() ? this.convert.toArray(resultSet) : new Object[0];\n        } catch (final SQLException e) {\n            rethrow(e);\n            return null;\n        }\n    }", "signature": "@Override\n    public Object[] next()"}, {"syntax_pass": true, "original_string": "    @Override\n    public void remove() {\n        try {\n            this.resultSet.deleteRow();\n        } catch (final SQLException e) {\n            rethrow(e);\n        }\n    }", "docstring": "\nDeletes the current row from the {@code ResultSet}.\n@see java.util.Iterator#remove()\n@throws RuntimeException if an SQLException occurs.\n", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "remove", "params": [], "body": "                         {\n        try {\n            this.resultSet.deleteRow();\n        } catch (final SQLException e) {\n            rethrow(e);\n        }\n    }", "signature": "@Override\n    public void remove()"}, {"syntax_pass": true, "original_string": "    protected void rethrow(final SQLException e) {\n        throw new RuntimeException(e.getMessage());\n    }", "docstring": "\nRethrow the SQLException as a RuntimeException.  This implementation\ncreates a new RuntimeException with the SQLException's error message.\n@param e SQLException to rethrow\n@since 1.1\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "name": "rethrow", "params": [{"name": "e", "type": "SQLException"}], "body": "                                                 {\n        throw new RuntimeException(e.getMessage());\n    }", "signature": "protected void rethrow(final SQLException e)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/apache/commons/dbutils/ProxyFactory.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils;\n\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Proxy;\nimport java.sql.CallableStatement;\nimport java.sql.Connection;\nimport java.sql.Driver;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.Statement;\n\n/**\n * Creates proxy implementations of JDBC interfaces.  This avoids\n * incompatibilities between the JDBC 2 and JDBC 3 interfaces.  This class is\n * thread safe.\n *\n * @see java.lang.reflect.Proxy\n * @see java.lang.reflect.InvocationHandler\n */\npublic class ProxyFactory {\n\n    /**\n     * The Singleton instance of this class.\n     */\n    private static final ProxyFactory INSTANCE = new ProxyFactory();\n\n    /**\n     * Returns the Singleton instance of this class.\n     *\n     * @return singleton instance\n     */\n    public static ProxyFactory instance() {\n        return INSTANCE;\n    }\n\n    /**\n     * Protected constructor for ProxyFactory subclasses to use.\n     */\n    protected ProxyFactory() {\n    }\n\n    /**\n     * Creates a new proxy {@code CallableStatement} object.\n     * @param handler The handler that intercepts/overrides method calls.\n     * @return proxied CallableStatement\n     */\n    public CallableStatement createCallableStatement(final InvocationHandler handler) {\n        return newProxyInstance(CallableStatement.class, handler);\n    }\n\n    /**\n     * Creates a new proxy {@code Connection} object.\n     * @param handler The handler that intercepts/overrides method calls.\n     * @return proxied Connection\n     */\n    public Connection createConnection(final InvocationHandler handler) {\n        return newProxyInstance(Connection.class, handler);\n    }\n\n    /**\n     * Creates a new proxy {@code Driver} object.\n     * @param handler The handler that intercepts/overrides method calls.\n     * @return proxied Driver\n     */\n    public Driver createDriver(final InvocationHandler handler) {\n        return newProxyInstance(Driver.class, handler);\n    }\n\n    /**\n     * Creates a new proxy {@code PreparedStatement} object.\n     * @param handler The handler that intercepts/overrides method calls.\n     * @return proxied PreparedStatement\n     */\n    public PreparedStatement createPreparedStatement(final InvocationHandler handler) {\n        return newProxyInstance(PreparedStatement.class, handler);\n    }\n\n    /**\n     * Creates a new proxy {@code ResultSet} object.\n     * @param handler The handler that intercepts/overrides method calls.\n     * @return proxied ResultSet\n     */\n    public ResultSet createResultSet(final InvocationHandler handler) {\n        return newProxyInstance(ResultSet.class, handler);\n    }\n\n    /**\n     * Creates a new proxy {@code ResultSetMetaData} object.\n     * @param handler The handler that intercepts/overrides method calls.\n     * @return proxied ResultSetMetaData\n     */\n    public ResultSetMetaData createResultSetMetaData(final InvocationHandler handler) {\n        return newProxyInstance(ResultSetMetaData.class, handler);\n    }\n\n    /**\n     * Creates a new proxy {@code Statement} object.\n     * @param handler The handler that intercepts/overrides method calls.\n     * @return proxied Statement\n     */\n    public Statement createStatement(final InvocationHandler handler) {\n        return newProxyInstance(Statement.class, handler);\n    }\n\n    /**\n     * Convenience method to generate a single-interface proxy using the handler's classloader\n     *\n     * @param <T> The type of object to proxy\n     * @param type The type of object to proxy\n     * @param handler The handler that intercepts/overrides method calls.\n     * @return proxied object\n     */\n    public <T> T newProxyInstance(final Class<T> type, final InvocationHandler handler) {\n        return type.cast(Proxy.newProxyInstance(handler.getClass().getClassLoader(), new Class<?>[] {type}, handler));\n    }\n\n}\n", "file_hash": "d706d0e413805cb6e7b06a917b54c0773ba315339d50467bb792fdd61262f603", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils;", "import java.lang.reflect.InvocationHandler;", "import java.lang.reflect.Proxy;", "import java.sql.CallableStatement;", "import java.sql.Connection;", "import java.sql.Driver;", "import java.sql.PreparedStatement;", "import java.sql.ResultSet;", "import java.sql.ResultSetMetaData;", "import java.sql.Statement;"], "methods": [], "classes": [{"original_string": "public class ProxyFactory {\n\n    /**\n     * The Singleton instance of this class.\n     */\n    private static final ProxyFactory INSTANCE = new ProxyFactory();\n\n    /**\n     * Returns the Singleton instance of this class.\n     *\n     * @return singleton instance\n     */\n    public static ProxyFactory instance() {\n        return INSTANCE;\n    }\n\n    /**\n     * Protected constructor for ProxyFactory subclasses to use.\n     */\n    protected ProxyFactory() {\n    }\n\n    /**\n     * Creates a new proxy {@code CallableStatement} object.\n     * @param handler The handler that intercepts/overrides method calls.\n     * @return proxied CallableStatement\n     */\n    public CallableStatement createCallableStatement(final InvocationHandler handler) {\n        return newProxyInstance(CallableStatement.class, handler);\n    }\n\n    /**\n     * Creates a new proxy {@code Connection} object.\n     * @param handler The handler that intercepts/overrides method calls.\n     * @return proxied Connection\n     */\n    public Connection createConnection(final InvocationHandler handler) {\n        return newProxyInstance(Connection.class, handler);\n    }\n\n    /**\n     * Creates a new proxy {@code Driver} object.\n     * @param handler The handler that intercepts/overrides method calls.\n     * @return proxied Driver\n     */\n    public Driver createDriver(final InvocationHandler handler) {\n        return newProxyInstance(Driver.class, handler);\n    }\n\n    /**\n     * Creates a new proxy {@code PreparedStatement} object.\n     * @param handler The handler that intercepts/overrides method calls.\n     * @return proxied PreparedStatement\n     */\n    public PreparedStatement createPreparedStatement(final InvocationHandler handler) {\n        return newProxyInstance(PreparedStatement.class, handler);\n    }\n\n    /**\n     * Creates a new proxy {@code ResultSet} object.\n     * @param handler The handler that intercepts/overrides method calls.\n     * @return proxied ResultSet\n     */\n    public ResultSet createResultSet(final InvocationHandler handler) {\n        return newProxyInstance(ResultSet.class, handler);\n    }\n\n    /**\n     * Creates a new proxy {@code ResultSetMetaData} object.\n     * @param handler The handler that intercepts/overrides method calls.\n     * @return proxied ResultSetMetaData\n     */\n    public ResultSetMetaData createResultSetMetaData(final InvocationHandler handler) {\n        return newProxyInstance(ResultSetMetaData.class, handler);\n    }\n\n    /**\n     * Creates a new proxy {@code Statement} object.\n     * @param handler The handler that intercepts/overrides method calls.\n     * @return proxied Statement\n     */\n    public Statement createStatement(final InvocationHandler handler) {\n        return newProxyInstance(Statement.class, handler);\n    }\n\n    /**\n     * Convenience method to generate a single-interface proxy using the handler's classloader\n     *\n     * @param <T> The type of object to proxy\n     * @param type The type of object to proxy\n     * @param handler The handler that intercepts/overrides method calls.\n     * @return proxied object\n     */\n    public <T> T newProxyInstance(final Class<T> type, final InvocationHandler handler) {\n        return type.cast(Proxy.newProxyInstance(handler.getClass().getClassLoader(), new Class<?>[] {type}, handler));\n    }\n\n}", "definition": "public class ProxyFactory", "class_docstring": "\nCreates proxy implementations of JDBC interfaces.  This avoids\nincompatibilities between the JDBC 2 and JDBC 3 interfaces.  This class is\nthread safe.\n\n@see java.lang.reflect.Proxy\n@see java.lang.reflect.InvocationHandler\n", "name": "ProxyFactory", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private static final ProxyFactory INSTANCE = new ProxyFactory();", "docstring": "\nThe Singleton instance of this class.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "ProxyFactory", "name": "INSTANCE = new ProxyFactory()", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public static ProxyFactory instance() {\n        return INSTANCE;\n    }", "docstring": "\nReturns the Singleton instance of this class.\n\n@return singleton instance\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "ProxyFactory", "classes": []}, "name": "instance", "params": [], "body": "                                          {\n        return INSTANCE;\n    }", "signature": "public static ProxyFactory instance()"}, {"syntax_pass": true, "original_string": "    protected ProxyFactory() {\n    }", "docstring": "\nProtected constructor for ProxyFactory subclasses to use.\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "name": "ProxyFactory", "params": [], "body": "                             {\n    }", "signature": "protected ProxyFactory()"}, {"syntax_pass": true, "original_string": "    public CallableStatement createCallableStatement(final InvocationHandler handler) {\n        return newProxyInstance(CallableStatement.class, handler);\n    }", "docstring": "\nCreates a new proxy {@code CallableStatement} object.\n@param handler The handler that intercepts/overrides method calls.\n@return proxied CallableStatement\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "CallableStatement", "classes": []}, "name": "createCallableStatement", "params": [{"name": "handler", "type": "InvocationHandler"}], "body": "                                                                                      {\n        return newProxyInstance(CallableStatement.class, handler);\n    }", "signature": "public CallableStatement createCallableStatement(final InvocationHandler handler)"}, {"syntax_pass": true, "original_string": "    public Connection createConnection(final InvocationHandler handler) {\n        return newProxyInstance(Connection.class, handler);\n    }", "docstring": "\nCreates a new proxy {@code Connection} object.\n@param handler The handler that intercepts/overrides method calls.\n@return proxied Connection\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Connection", "classes": []}, "name": "createConnection", "params": [{"name": "handler", "type": "InvocationHandler"}], "body": "                                                                        {\n        return newProxyInstance(Connection.class, handler);\n    }", "signature": "public Connection createConnection(final InvocationHandler handler)"}, {"syntax_pass": true, "original_string": "    public Driver createDriver(final InvocationHandler handler) {\n        return newProxyInstance(Driver.class, handler);\n    }", "docstring": "\nCreates a new proxy {@code Driver} object.\n@param handler The handler that intercepts/overrides method calls.\n@return proxied Driver\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Driver", "classes": []}, "name": "createDriver", "params": [{"name": "handler", "type": "InvocationHandler"}], "body": "                                                                {\n        return newProxyInstance(Driver.class, handler);\n    }", "signature": "public Driver createDriver(final InvocationHandler handler)"}, {"syntax_pass": true, "original_string": "    public PreparedStatement createPreparedStatement(final InvocationHandler handler) {\n        return newProxyInstance(PreparedStatement.class, handler);\n    }", "docstring": "\nCreates a new proxy {@code PreparedStatement} object.\n@param handler The handler that intercepts/overrides method calls.\n@return proxied PreparedStatement\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "PreparedStatement", "classes": []}, "name": "createPreparedStatement", "params": [{"name": "handler", "type": "InvocationHandler"}], "body": "                                                                                      {\n        return newProxyInstance(PreparedStatement.class, handler);\n    }", "signature": "public PreparedStatement createPreparedStatement(final InvocationHandler handler)"}, {"syntax_pass": true, "original_string": "    public ResultSet createResultSet(final InvocationHandler handler) {\n        return newProxyInstance(ResultSet.class, handler);\n    }", "docstring": "\nCreates a new proxy {@code ResultSet} object.\n@param handler The handler that intercepts/overrides method calls.\n@return proxied ResultSet\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ResultSet", "classes": []}, "name": "createResultSet", "params": [{"name": "handler", "type": "InvocationHandler"}], "body": "                                                                      {\n        return newProxyInstance(ResultSet.class, handler);\n    }", "signature": "public ResultSet createResultSet(final InvocationHandler handler)"}, {"syntax_pass": true, "original_string": "    public ResultSetMetaData createResultSetMetaData(final InvocationHandler handler) {\n        return newProxyInstance(ResultSetMetaData.class, handler);\n    }", "docstring": "\nCreates a new proxy {@code ResultSetMetaData} object.\n@param handler The handler that intercepts/overrides method calls.\n@return proxied ResultSetMetaData\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ResultSetMetaData", "classes": []}, "name": "createResultSetMetaData", "params": [{"name": "handler", "type": "InvocationHandler"}], "body": "                                                                                      {\n        return newProxyInstance(ResultSetMetaData.class, handler);\n    }", "signature": "public ResultSetMetaData createResultSetMetaData(final InvocationHandler handler)"}, {"syntax_pass": true, "original_string": "    public Statement createStatement(final InvocationHandler handler) {\n        return newProxyInstance(Statement.class, handler);\n    }", "docstring": "\nCreates a new proxy {@code Statement} object.\n@param handler The handler that intercepts/overrides method calls.\n@return proxied Statement\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Statement", "classes": []}, "name": "createStatement", "params": [{"name": "handler", "type": "InvocationHandler"}], "body": "                                                                      {\n        return newProxyInstance(Statement.class, handler);\n    }", "signature": "public Statement createStatement(final InvocationHandler handler)"}, {"syntax_pass": true, "original_string": "    public <T> T newProxyInstance(final Class<T> type, final InvocationHandler handler) {\n        return type.cast(Proxy.newProxyInstance(handler.getClass().getClassLoader(), new Class<?>[] {type}, handler));\n    }", "docstring": "\nConvenience method to generate a single-interface proxy using the handler's classloader\n\n@param <T> The type of object to proxy\n@param type The type of object to proxy\n@param handler The handler that intercepts/overrides method calls.\n@return proxied object\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "T", "classes": []}, "name": "newProxyInstance", "params": [{"name": "type", "type": "Class<T>"}, {"name": "handler", "type": "InvocationHandler"}], "body": "                                                                                        {\n        return type.cast(Proxy.newProxyInstance(handler.getClass().getClassLoader(), new Class<?>[] {type}, handler));\n    }", "signature": "public <T> T newProxyInstance(final Class<T> type, final InvocationHandler handler)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/apache/commons/dbutils/QueryRunner.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils;\n\nimport java.sql.CallableStatement;\nimport java.sql.Connection;\nimport java.sql.ParameterMetaData;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\nimport java.util.LinkedList;\nimport java.util.List;\n\nimport javax.sql.DataSource;\n\n/**\n * Executes SQL queries with pluggable strategies for handling\n * {@code ResultSet}s.  This class is thread safe.\n *\n * @see ResultSetHandler\n */\npublic class QueryRunner extends AbstractQueryRunner {\n\n    /**\n     * Constructor for QueryRunner.\n     */\n    public QueryRunner() {\n    }\n\n    /**\n     * Constructor for QueryRunner that controls the use of {@code ParameterMetaData}.\n     *\n     * @param pmdKnownBroken Some drivers don't support {@link java.sql.ParameterMetaData#getParameterType(int) };\n     * if {@code pmdKnownBroken} is set to true, we won't even try it; if false, we'll try it,\n     * and if it breaks, we'll remember not to use it again.\n     */\n    public QueryRunner(final boolean pmdKnownBroken) {\n        super(pmdKnownBroken);\n    }\n\n    /**\n     * Constructor for QueryRunner that takes a {@code DataSource} to use.\n     *\n     * Methods that do not take a {@code Connection} parameter will retrieve connections from this\n     * {@code DataSource}.\n     *\n     * @param ds The {@code DataSource} to retrieve connections from.\n     */\n    public QueryRunner(final DataSource ds) {\n        super(ds);\n    }\n\n    /**\n     * Constructor for QueryRunner that takes a {@code DataSource} and controls the use of {@code ParameterMetaData}.\n     * Methods that do not take a {@code Connection} parameter will retrieve connections from this\n     * {@code DataSource}.\n     *\n     * @param ds The {@code DataSource} to retrieve connections from.\n     * @param pmdKnownBroken Some drivers don't support {@link java.sql.ParameterMetaData#getParameterType(int) };\n     * if {@code pmdKnownBroken} is set to true, we won't even try it; if false, we'll try it,\n     * and if it breaks, we'll remember not to use it again.\n     */\n    public QueryRunner(final DataSource ds, final boolean pmdKnownBroken) {\n        super(ds, pmdKnownBroken);\n    }\n\n    /**\n     * Constructor for QueryRunner that takes a {@code DataSource}, a {@code StatementConfiguration}, and\n     * controls the use of {@code ParameterMetaData}.  Methods that do not take a {@code Connection} parameter\n     * will retrieve connections from this {@code DataSource}.\n     *\n     * @param ds The {@code DataSource} to retrieve connections from.\n     * @param pmdKnownBroken Some drivers don't support {@link java.sql.ParameterMetaData#getParameterType(int) };\n     * if {@code pmdKnownBroken} is set to true, we won't even try it; if false, we'll try it,\n     * and if it breaks, we'll remember not to use it again.\n     * @param stmtConfig The configuration to apply to statements when they are prepared.\n     */\n    public QueryRunner(final DataSource ds, final boolean pmdKnownBroken, final StatementConfiguration stmtConfig) {\n        super(ds, pmdKnownBroken, stmtConfig);\n    }\n\n    /**\n     * Constructor for QueryRunner that takes a {@code DataSource} to use and a {@code StatementConfiguration}.\n     *\n     * Methods that do not take a {@code Connection} parameter will retrieve connections from this\n     * {@code DataSource}.\n     *\n     * @param ds The {@code DataSource} to retrieve connections from.\n     * @param stmtConfig The configuration to apply to statements when they are prepared.\n     */\n    public QueryRunner(final DataSource ds, final StatementConfiguration stmtConfig) {\n        super(ds, stmtConfig);\n    }\n\n    /**\n     * Constructor for QueryRunner that takes a {@code StatementConfiguration} to configure statements when\n     * preparing them.\n     *\n     * @param stmtConfig The configuration to apply to statements when they are prepared.\n     */\n    public QueryRunner(final StatementConfiguration stmtConfig) {\n        super(stmtConfig);\n    }\n\n    /**\n     * Execute a batch of SQL INSERT, UPDATE, or DELETE queries.\n     *\n     * @param conn The Connection to use to run the query.  The caller is\n     * responsible for closing this Connection.\n     * @param sql The SQL to execute.\n     * @param params An array of query replacement parameters.  Each row in\n     * this array is one set of batch replacement values.\n     * @return The number of rows updated per statement.\n     * @throws SQLException if a database access error occurs\n     * @since 1.1\n     */\n    public int[] batch(final Connection conn, final String sql, final Object[][] params) throws SQLException {\n        if (conn == null) {\n            throw new SQLException(\"Null connection\");\n        }\n\n        if (sql == null) {\n            throw new SQLException(\"Null SQL statement\");\n        }\n\n        if (params == null) {\n            throw new SQLException(\"Null parameters. If parameters aren't need, pass an empty array.\");\n        }\n\n        PreparedStatement stmt = null;\n        ParameterMetaData pmd = null;\n        int[] rows = null;\n        try {\n            stmt = this.prepareStatement(conn, sql);\n            // When the batch size is large, prefetching parameter metadata before filling\n            // the statement can reduce lots of JDBC communications.\n            pmd = getParameterMetaData(stmt);\n\n            for (final Object[] param : params) {\n                this.fillStatement(stmt, pmd, param);\n                stmt.addBatch();\n            }\n            rows = stmt.executeBatch();\n\n        } catch (final SQLException e) {\n            rethrow(e, sql, (Object[])params);\n        } finally {\n            close(stmt);\n        }\n\n        return rows;\n    }\n\n    /**\n     * Execute a batch of SQL INSERT, UPDATE, or DELETE queries.  The\n     * {@code Connection} is retrieved from the {@code DataSource}\n     * set in the constructor.  This {@code Connection} must be in\n     * auto-commit mode or the update will not be saved.\n     *\n     * @param sql The SQL to execute.\n     * @param params An array of query replacement parameters.  Each row in\n     * this array is one set of batch replacement values.\n     * @return The number of rows updated per statement.\n     * @throws SQLException if a database access error occurs\n     * @since 1.1\n     */\n    public int[] batch(final String sql, final Object[][] params) throws SQLException {\n        try (Connection conn = prepareConnection()) {\n            return this.batch(conn, sql, params);\n        }\n    }\n\n    /**\n     * Execute an SQL statement, including a stored procedure call, which does\n     * not return any result sets.\n     * Any parameters which are instances of {@link OutParameter} will be\n     * registered as OUT parameters.\n     * <p>\n     * Use this method when invoking a stored procedure with OUT parameters\n     * that does not return any result sets.  If you are not invoking a stored\n     * procedure, or the stored procedure has no OUT parameters, consider using\n     * {@link #update(java.sql.Connection, String, Object...) }.\n     * If the stored procedure returns result sets, use\n     * {@link #execute(java.sql.Connection, String, org.apache.commons.dbutils.ResultSetHandler, Object...) }.\n     *\n     * @param conn The connection to use to run the query.\n     * @param sql The SQL to execute.\n     * @param params The query replacement parameters.\n     * @return The number of rows updated.\n     * @throws SQLException if a database access error occurs\n     */\n    public int execute(final Connection conn, final String sql, final Object... params) throws SQLException {\n        if (conn == null) {\n            throw new SQLException(\"Null connection\");\n        }\n\n        if (sql == null) {\n            throw new SQLException(\"Null SQL statement\");\n        }\n\n        CallableStatement stmt = null;\n        int rows = 0;\n\n        try {\n            stmt = prepareCall(conn, sql);\n            this.fillStatement(stmt, params);\n            stmt.execute();\n            rows = stmt.getUpdateCount();\n            retrieveOutParameters(stmt, params);\n\n        } catch (final SQLException e) {\n            rethrow(e, sql, params);\n\n        } finally {\n            close(stmt);\n        }\n\n        return rows;\n    }\n\n    /**\n     * Execute an SQL statement, including a stored procedure call, which\n     * returns one or more result sets.\n     * Any parameters which are instances of {@link OutParameter} will be\n     * registered as OUT parameters.\n     * <p>\n     * Use this method when: a) running SQL statements that return multiple\n     * result sets; b) invoking a stored procedure that return result\n     * sets and OUT parameters.  Otherwise you may wish to use\n     * {@link #query(java.sql.Connection, String, org.apache.commons.dbutils.ResultSetHandler, Object...) }\n     * (if there are no OUT parameters) or\n     * {@link #execute(java.sql.Connection, String, Object...) }\n     * (if there are no result sets).\n     *\n     * @param <T> The type of object that the handler returns\n     * @param conn The connection to use to run the query.\n     * @param sql The SQL to execute.\n     * @param rsh The result set handler\n     * @param params The query replacement parameters.\n     * @return A list of objects generated by the handler\n     * @throws SQLException if a database access error occurs\n     */\n    public <T> List<T> execute(final Connection conn, final String sql, final ResultSetHandler<T> rsh, final Object... params) throws SQLException {\n        if (conn == null) {\n            throw new SQLException(\"Null connection\");\n        }\n\n        if (sql == null) {\n            throw new SQLException(\"Null SQL statement\");\n        }\n\n        if (rsh == null) {\n            throw new SQLException(\"Null ResultSetHandler\");\n        }\n\n        CallableStatement stmt = null;\n        final List<T> results = new LinkedList<>();\n\n        try {\n            stmt = prepareCall(conn, sql);\n            this.fillStatement(stmt, params);\n            boolean moreResultSets = stmt.execute();\n            // Handle multiple result sets by passing them through the handler\n            // retaining the final result\n            while (moreResultSets) {\n                try (@SuppressWarnings(\"resource\")\n                // assume the ResultSet wrapper properly closes\n                ResultSet resultSet = wrap(stmt.getResultSet())) {\n                    results.add(rsh.handle(resultSet));\n                    moreResultSets = stmt.getMoreResults();\n                }\n            }\n            retrieveOutParameters(stmt, params);\n\n        } catch (final SQLException e) {\n            rethrow(e, sql, params);\n\n        } finally {\n            close(stmt);\n        }\n\n        return results;\n    }\n\n    /**\n     * Execute an SQL statement, including a stored procedure call, which does\n     * not return any result sets.\n     * Any parameters which are instances of {@link OutParameter} will be\n     * registered as OUT parameters.\n     * <p>\n     * Use this method when invoking a stored procedure with OUT parameters\n     * that does not return any result sets.  If you are not invoking a stored\n     * procedure, or the stored procedure has no OUT parameters, consider using\n     * {@link #update(String, Object...) }.\n     * If the stored procedure returns result sets, use\n     * {@link #execute(String, org.apache.commons.dbutils.ResultSetHandler, Object...) }.\n     * <p>\n     * The {@code Connection} is retrieved from the {@code DataSource}\n     * set in the constructor.  This {@code Connection} must be in\n     * auto-commit mode or the update will not be saved.\n     *\n     * @param sql The SQL statement to execute.\n     * @param params Initializes the CallableStatement's parameters (i.e. '?').\n     * @throws SQLException if a database access error occurs\n     * @return The number of rows updated.\n     */\n    public int execute(final String sql, final Object... params) throws SQLException {\n        try (Connection conn = prepareConnection()) {\n            return this.execute(conn, sql, params);\n        }\n    }\n\n    /**\n     * Execute an SQL statement, including a stored procedure call, which\n     * returns one or more result sets.\n     * Any parameters which are instances of {@link OutParameter} will be\n     * registered as OUT parameters.\n     * <p>\n     * Use this method when: a) running SQL statements that return multiple\n     * result sets; b) invoking a stored procedure that return result\n     * sets and OUT parameters.  Otherwise you may wish to use\n     * {@link #query(String, org.apache.commons.dbutils.ResultSetHandler, Object...) }\n     * (if there are no OUT parameters) or\n     * {@link #execute(String, Object...) }\n     * (if there are no result sets).\n     *\n     * @param <T> The type of object that the handler returns\n     * @param sql The SQL to execute.\n     * @param rsh The result set handler\n     * @param params The query replacement parameters.\n     * @return A list of objects generated by the handler\n     * @throws SQLException if a database access error occurs\n     */\n    public <T> List<T> execute(final String sql, final ResultSetHandler<T> rsh, final Object... params) throws SQLException {\n        try (Connection conn = prepareConnection()) {\n            return this.execute(conn, sql, rsh, params);\n        }\n    }\n\n    /**\n     * Execute an SQL INSERT query without replacement parameters.\n     * @param <T> The type of object that the handler returns\n     * @param conn The connection to use to run the query.\n     * @param sql The SQL to execute.\n     * @param rsh The handler used to create the result object from\n     * the {@code ResultSet} of auto-generated keys.\n     * @return An object generated by the handler.\n     * @throws SQLException if a database access error occurs\n     * @since 1.6\n     */\n    public <T> T insert(final Connection conn, final String sql, final ResultSetHandler<T> rsh) throws SQLException {\n        return insert(conn, sql, rsh, (Object[]) null);\n    }\n\n    /**\n     * Execute an SQL INSERT query.\n     * @param <T> The type of object that the handler returns\n     * @param conn The connection to use to run the query.\n     * @param sql The SQL to execute.\n     * @param rsh The handler used to create the result object from\n     * the {@code ResultSet} of auto-generated keys.\n     * @param params The query replacement parameters.\n     * @return An object generated by the handler.\n     * @throws SQLException if a database access error occurs\n     * @since 1.6\n     */\n    public <T> T insert(final Connection conn, final String sql, final ResultSetHandler<T> rsh, final Object... params) throws SQLException {\n        if (conn == null) {\n            throw new SQLException(\"Null connection\");\n        }\n\n        if (sql == null) {\n            throw new SQLException(\"Null SQL statement\");\n        }\n\n        if (rsh == null) {\n            throw new SQLException(\"Null ResultSetHandler\");\n        }\n\n        Statement stmt = null;\n        T generatedKeys = null;\n\n        try {\n            if (params != null && params.length > 0) {\n                final PreparedStatement ps = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);\n                stmt = ps;\n                this.fillStatement(ps, params);\n                ps.executeUpdate();\n            } else {\n                stmt = conn.createStatement();\n                stmt.executeUpdate(sql, Statement.RETURN_GENERATED_KEYS);\n            }\n            try (ResultSet resultSet = stmt.getGeneratedKeys()) {\n                generatedKeys = rsh.handle(resultSet);\n            }\n        } catch (final SQLException e) {\n            rethrow(e, sql, params);\n        } finally {\n            close(stmt);\n        }\n\n        return generatedKeys;\n    }\n\n    /**\n     * Executes the given INSERT SQL without any replacement parameters.\n     * The {@code Connection} is retrieved from the\n     * {@code DataSource} set in the constructor.\n     * @param <T> The type of object that the handler returns\n     * @param sql The SQL statement to execute.\n     * @param rsh The handler used to create the result object from\n     * the {@code ResultSet} of auto-generated keys.\n     * @return An object generated by the handler.\n     * @throws SQLException if a database access error occurs\n     * @since 1.6\n     */\n    public <T> T insert(final String sql, final ResultSetHandler<T> rsh) throws SQLException {\n        try (Connection conn = prepareConnection()) {\n            return insert(conn, sql, rsh, (Object[]) null);\n        }\n    }\n\n    /**\n     * Executes the given INSERT SQL statement. The\n     * {@code Connection} is retrieved from the {@code DataSource}\n     * set in the constructor.  This {@code Connection} must be in\n     * auto-commit mode or the insert will not be saved.\n     * @param <T> The type of object that the handler returns\n     * @param sql The SQL statement to execute.\n     * @param rsh The handler used to create the result object from\n     * the {@code ResultSet} of auto-generated keys.\n     * @param params Initializes the PreparedStatement's IN (i.e. '?')\n     * @return An object generated by the handler.\n     * @throws SQLException if a database access error occurs\n     * @since 1.6\n     */\n    public <T> T insert(final String sql, final ResultSetHandler<T> rsh, final Object... params) throws SQLException {\n        try (Connection conn = prepareConnection()) {\n            return insert(conn, sql, rsh, params);\n        }\n    }\n\n    /**\n     * Executes the given batch of INSERT SQL statements.\n     * @param <T> The type of object that the handler returns\n     * @param conn The connection to use to run the query.\n     * @param sql The SQL to execute.\n     * @param rsh The handler used to create the result object from\n     * the {@code ResultSet} of auto-generated keys.\n     * @param params The query replacement parameters.\n     * @return The result generated by the handler.\n     * @throws SQLException if a database access error occurs\n     * @since 1.6\n     */\n    public <T> T insertBatch(final Connection conn, final String sql, final ResultSetHandler<T> rsh, final Object[][] params) throws SQLException {\n        if (conn == null) {\n            throw new SQLException(\"Null connection\");\n        }\n\n        if (sql == null) {\n            throw new SQLException(\"Null SQL statement\");\n        }\n\n        if (params == null) {\n            throw new SQLException(\"Null parameters. If parameters aren't need, pass an empty array.\");\n        }\n\n        PreparedStatement stmt = null;\n        T generatedKeys = null;\n        try {\n            stmt = this.prepareStatement(conn, sql, Statement.RETURN_GENERATED_KEYS);\n\n            for (final Object[] param : params) {\n                this.fillStatement(stmt, param);\n                stmt.addBatch();\n            }\n            stmt.executeBatch();\n            try (ResultSet resultSet = stmt.getGeneratedKeys()) {\n                generatedKeys = rsh.handle(resultSet);\n            }\n        } catch (final SQLException e) {\n            rethrow(e, sql, (Object[])params);\n        } finally {\n            close(stmt);\n        }\n\n        return generatedKeys;\n    }\n\n    /**\n     * Executes the given batch of INSERT SQL statements. The\n     * {@code Connection} is retrieved from the {@code DataSource}\n     * set in the constructor.  This {@code Connection} must be in\n     * auto-commit mode or the insert will not be saved.\n     * @param <T> The type of object that the handler returns\n     * @param sql The SQL statement to execute.\n     * @param rsh The handler used to create the result object from\n     * the {@code ResultSet} of auto-generated keys.\n     * @param params Initializes the PreparedStatement's IN (i.e. '?')\n     * @return The result generated by the handler.\n     * @throws SQLException if a database access error occurs\n     * @since 1.6\n     */\n    public <T> T insertBatch(final String sql, final ResultSetHandler<T> rsh, final Object[][] params) throws SQLException {\n        try (Connection conn = prepareConnection()) {\n            return insertBatch(conn, sql, rsh, params);\n        }\n    }\n\n    /**\n     * Execute an SQL SELECT query with a single replacement parameter. The\n     * caller is responsible for closing the connection.\n     * @param <T> The type of object that the handler returns\n     * @param conn The connection to execute the query in.\n     * @param sql The query to execute.\n     * @param param The replacement parameter.\n     * @param rsh The handler that converts the results into an object.\n     * @return The object returned by the handler.\n     * @throws SQLException if a database access error occurs\n     * @deprecated Use {@link #query(Connection, String, ResultSetHandler, Object...)}\n     */\n    @Deprecated\n    public <T> T query(final Connection conn, final String sql, final Object param, final ResultSetHandler<T> rsh) throws SQLException {\n        return this.<T>query(conn, sql, rsh, param);\n    }\n\n    /**\n     * Execute an SQL SELECT query with replacement parameters.  The\n     * caller is responsible for closing the connection.\n     * @param <T> The type of object that the handler returns\n     * @param conn The connection to execute the query in.\n     * @param sql The query to execute.\n     * @param params The replacement parameters.\n     * @param rsh The handler that converts the results into an object.\n     * @return The object returned by the handler.\n     * @throws SQLException if a database access error occurs\n     * @deprecated Use {@link #query(Connection,String,ResultSetHandler,Object...)} instead\n     */\n    @Deprecated\n    public <T> T query(final Connection conn, final String sql, final Object[] params, final ResultSetHandler<T> rsh) throws SQLException {\n        return this.<T>query(conn, sql, rsh, params);\n    }\n\n    /**\n     * Execute an SQL SELECT query without any replacement parameters.  The\n     * caller is responsible for closing the connection.\n     * @param <T> The type of object that the handler returns\n     * @param conn The connection to execute the query in.\n     * @param sql The query to execute.\n     * @param rsh The handler that converts the results into an object.\n     * @return The object returned by the handler.\n     * @throws SQLException if a database access error occurs\n     */\n    public <T> T query(final Connection conn, final String sql, final ResultSetHandler<T> rsh) throws SQLException {\n        return this.<T>query(conn, sql, rsh, (Object[]) null);\n    }\n\n    /**\n     * Execute an SQL SELECT query with replacement parameters.  The\n     * caller is responsible for closing the connection.\n     * @param <T> The type of object that the handler returns\n     * @param conn The connection to execute the query in.\n     * @param sql The query to execute.\n     * @param rsh The handler that converts the results into an object.\n     * @param params The replacement parameters.\n     * @return The object returned by the handler.\n     * @throws SQLException if a database access error occurs\n     */\n    public <T> T query(final Connection conn, final String sql, final ResultSetHandler<T> rsh, final Object... params) throws SQLException {\n        if (conn == null) {\n            throw new SQLException(\"Null connection\");\n        }\n\n        if (sql == null) {\n            throw new SQLException(\"Null SQL statement\");\n        }\n\n        if (rsh == null) {\n            throw new SQLException(\"Null ResultSetHandler\");\n        }\n\n        Statement stmt = null;\n        ResultSet resultSet = null;\n        T result = null;\n\n        try {\n            if (params != null && params.length > 0) {\n                final PreparedStatement ps = this.prepareStatement(conn, sql);\n                stmt = ps;\n                this.fillStatement(ps, params);\n                resultSet = wrap(ps.executeQuery());\n            } else {\n                stmt = conn.createStatement();\n                resultSet = wrap(stmt.executeQuery(sql));\n            }\n            result = rsh.handle(resultSet);\n\n        } catch (final SQLException e) {\n            rethrow(e, sql, params);\n\n        } finally {\n            closeQuietly(resultSet);\n            closeQuietly(stmt);\n        }\n\n        return result;\n    }\n\n    /**\n     * Executes the given SELECT SQL with a single replacement parameter.\n     * The {@code Connection} is retrieved from the\n     * {@code DataSource} set in the constructor.\n     * @param <T> The type of object that the handler returns\n     * @param sql The SQL statement to execute.\n     * @param param The replacement parameter.\n     * @param rsh The handler used to create the result object from\n     * the {@code ResultSet}.\n     *\n     * @return An object generated by the handler.\n     * @throws SQLException if a database access error occurs\n     * @deprecated Use {@link #query(String, ResultSetHandler, Object...)}\n     */\n    @Deprecated\n    public <T> T query(final String sql, final Object param, final ResultSetHandler<T> rsh) throws SQLException {\n        try (Connection conn = prepareConnection()) {\n            return this.<T>query(conn, sql, rsh, param);\n        }\n    }\n\n    /**\n     * Executes the given SELECT SQL query and returns a result object.\n     * The {@code Connection} is retrieved from the\n     * {@code DataSource} set in the constructor.\n     * @param <T> The type of object that the handler returns\n     * @param sql The SQL statement to execute.\n     * @param params Initialize the PreparedStatement's IN parameters with\n     * this array.\n     *\n     * @param rsh The handler used to create the result object from\n     * the {@code ResultSet}.\n     *\n     * @return An object generated by the handler.\n     * @throws SQLException if a database access error occurs\n     * @deprecated Use {@link #query(String, ResultSetHandler, Object...)}\n     */\n    @Deprecated\n    public <T> T query(final String sql, final Object[] params, final ResultSetHandler<T> rsh) throws SQLException {\n        try (Connection conn = prepareConnection()) {\n            return this.<T>query(conn, sql, rsh, params);\n        }\n    }\n\n    /**\n     * Executes the given SELECT SQL without any replacement parameters.\n     * The {@code Connection} is retrieved from the\n     * {@code DataSource} set in the constructor.\n     * @param <T> The type of object that the handler returns\n     * @param sql The SQL statement to execute.\n     * @param rsh The handler used to create the result object from\n     * the {@code ResultSet}.\n     *\n     * @return An object generated by the handler.\n     * @throws SQLException if a database access error occurs\n     */\n    public <T> T query(final String sql, final ResultSetHandler<T> rsh) throws SQLException {\n        try (Connection conn = prepareConnection()) {\n            return this.<T>query(conn, sql, rsh, (Object[]) null);\n        }\n    }\n\n    /**\n     * Executes the given SELECT SQL query and returns a result object.\n     * The {@code Connection} is retrieved from the\n     * {@code DataSource} set in the constructor.\n     * @param <T> The type of object that the handler returns\n     * @param sql The SQL statement to execute.\n     * @param rsh The handler used to create the result object from\n     * the {@code ResultSet}.\n     * @param params Initialize the PreparedStatement's IN parameters with\n     * this array.\n     * @return An object generated by the handler.\n     * @throws SQLException if a database access error occurs\n     */\n    public <T> T query(final String sql, final ResultSetHandler<T> rsh, final Object... params) throws SQLException {\n        try (Connection conn = prepareConnection()) {\n            return this.<T>query(conn, sql, rsh, params);\n        }\n    }\n\n    /**\n     * Set the value on all the {@link OutParameter} instances in the\n     * {@code params} array using the OUT parameter values from the\n     * {@code stmt}.\n     * @param stmt the statement from which to retrieve OUT parameter values\n     * @param params the parameter array for the statement invocation\n     * @throws SQLException when the value could not be retrieved from the\n     * statement.\n     */\n    private void retrieveOutParameters(final CallableStatement stmt, final Object[] params) throws SQLException {\n        if (params != null) {\n            for (int i = 0; i < params.length; i++) {\n                if (params[i] instanceof OutParameter) {\n                    ((OutParameter<?>) params[i]).setValue(stmt, i + 1);\n                }\n            }\n        }\n    }\n\n    /**\n     * Execute an SQL INSERT, UPDATE, or DELETE query without replacement\n     * parameters.\n     *\n     * @param conn The connection to use to run the query.\n     * @param sql The SQL to execute.\n     * @return The number of rows updated.\n     * @throws SQLException if a database access error occurs\n     */\n    public int update(final Connection conn, final String sql) throws SQLException {\n        return this.update(conn, sql, (Object[]) null);\n    }\n\n    /**\n     * Execute an SQL INSERT, UPDATE, or DELETE query with a single replacement\n     * parameter.\n     *\n     * @param conn The connection to use to run the query.\n     * @param sql The SQL to execute.\n     * @param param The replacement parameter.\n     * @return The number of rows updated.\n     * @throws SQLException if a database access error occurs\n     */\n    public int update(final Connection conn, final String sql, final Object param) throws SQLException {\n        return this.update(conn, sql, new Object[] { param });\n    }\n\n    /**\n     * Execute an SQL INSERT, UPDATE, or DELETE query.\n     *\n     * @param conn The connection to use to run the query.\n     * @param sql The SQL to execute.\n     * @param params The query replacement parameters.\n     * @return The number of rows updated.\n     * @throws SQLException if a database access error occurs\n     */\n    public int update(final Connection conn, final String sql, final Object... params) throws SQLException {\n        if (conn == null) {\n            throw new SQLException(\"Null connection\");\n        }\n\n        if (sql == null) {\n            throw new SQLException(\"Null SQL statement\");\n        }\n\n        Statement stmt = null;\n        int rows = 0;\n\n        try {\n            if (params != null && params.length > 0) {\n                final PreparedStatement ps = this.prepareStatement(conn, sql);\n                stmt = ps;\n                this.fillStatement(ps, params);\n                rows = ps.executeUpdate();\n            } else {\n                stmt = conn.createStatement();\n                rows = stmt.executeUpdate(sql);\n            }\n\n        } catch (final SQLException e) {\n            rethrow(e, sql, params);\n\n        } finally {\n            close(stmt);\n        }\n\n        return rows;\n    }\n\n    /**\n     * Executes the given INSERT, UPDATE, or DELETE SQL statement without\n     * any replacement parameters. The {@code Connection} is retrieved\n     * from the {@code DataSource} set in the constructor.  This\n     * {@code Connection} must be in auto-commit mode or the update will\n     * not be saved.\n     *\n     * @param sql The SQL statement to execute.\n     * @throws SQLException if a database access error occurs\n     * @return The number of rows updated.\n     */\n    public int update(final String sql) throws SQLException {\n        try (Connection conn = prepareConnection()) {\n            return this.update(conn, sql, (Object[]) null);\n        }\n    }\n\n    /**\n     * Executes the given INSERT, UPDATE, or DELETE SQL statement with\n     * a single replacement parameter.  The {@code Connection} is\n     * retrieved from the {@code DataSource} set in the constructor.\n     * This {@code Connection} must be in auto-commit mode or the\n     * update will not be saved.\n     *\n     * @param sql The SQL statement to execute.\n     * @param param The replacement parameter.\n     * @throws SQLException if a database access error occurs\n     * @return The number of rows updated.\n     */\n    public int update(final String sql, final Object param) throws SQLException {\n        try (Connection conn = prepareConnection()) {\n            return this.update(conn, sql, param);\n        }\n    }\n\n    /**\n     * Executes the given INSERT, UPDATE, or DELETE SQL statement.  The\n     * {@code Connection} is retrieved from the {@code DataSource}\n     * set in the constructor.  This {@code Connection} must be in\n     * auto-commit mode or the update will not be saved.\n     *\n     * @param sql The SQL statement to execute.\n     * @param params Initializes the PreparedStatement's IN (i.e. '?')\n     * parameters.\n     * @throws SQLException if a database access error occurs\n     * @return The number of rows updated.\n     */\n    public int update(final String sql, final Object... params) throws SQLException {\n        try (Connection conn = prepareConnection()) {\n            return this.update(conn, sql, params);\n        }\n    }\n}\n", "file_hash": "b4e831d26912d142316c289223203684aaad53667668901c348273a6969dbb31", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils;", "import java.sql.CallableStatement;", "import java.sql.Connection;", "import java.sql.ParameterMetaData;", "import java.sql.PreparedStatement;", "import java.sql.ResultSet;", "import java.sql.SQLException;", "import java.sql.Statement;", "import java.util.LinkedList;", "import java.util.List;", "import javax.sql.DataSource;"], "methods": [], "classes": [{"original_string": "public class QueryRunner extends AbstractQueryRunner {\n\n    /**\n     * Constructor for QueryRunner.\n     */\n    public QueryRunner() {\n    }\n\n    /**\n     * Constructor for QueryRunner that controls the use of {@code ParameterMetaData}.\n     *\n     * @param pmdKnownBroken Some drivers don't support {@link java.sql.ParameterMetaData#getParameterType(int) };\n     * if {@code pmdKnownBroken} is set to true, we won't even try it; if false, we'll try it,\n     * and if it breaks, we'll remember not to use it again.\n     */\n    public QueryRunner(final boolean pmdKnownBroken) {\n        super(pmdKnownBroken);\n    }\n\n    /**\n     * Constructor for QueryRunner that takes a {@code DataSource} to use.\n     *\n     * Methods that do not take a {@code Connection} parameter will retrieve connections from this\n     * {@code DataSource}.\n     *\n     * @param ds The {@code DataSource} to retrieve connections from.\n     */\n    public QueryRunner(final DataSource ds) {\n        super(ds);\n    }\n\n    /**\n     * Constructor for QueryRunner that takes a {@code DataSource} and controls the use of {@code ParameterMetaData}.\n     * Methods that do not take a {@code Connection} parameter will retrieve connections from this\n     * {@code DataSource}.\n     *\n     * @param ds The {@code DataSource} to retrieve connections from.\n     * @param pmdKnownBroken Some drivers don't support {@link java.sql.ParameterMetaData#getParameterType(int) };\n     * if {@code pmdKnownBroken} is set to true, we won't even try it; if false, we'll try it,\n     * and if it breaks, we'll remember not to use it again.\n     */\n    public QueryRunner(final DataSource ds, final boolean pmdKnownBroken) {\n        super(ds, pmdKnownBroken);\n    }\n\n    /**\n     * Constructor for QueryRunner that takes a {@code DataSource}, a {@code StatementConfiguration}, and\n     * controls the use of {@code ParameterMetaData}.  Methods that do not take a {@code Connection} parameter\n     * will retrieve connections from this {@code DataSource}.\n     *\n     * @param ds The {@code DataSource} to retrieve connections from.\n     * @param pmdKnownBroken Some drivers don't support {@link java.sql.ParameterMetaData#getParameterType(int) };\n     * if {@code pmdKnownBroken} is set to true, we won't even try it; if false, we'll try it,\n     * and if it breaks, we'll remember not to use it again.\n     * @param stmtConfig The configuration to apply to statements when they are prepared.\n     */\n    public QueryRunner(final DataSource ds, final boolean pmdKnownBroken, final StatementConfiguration stmtConfig) {\n        super(ds, pmdKnownBroken, stmtConfig);\n    }\n\n    /**\n     * Constructor for QueryRunner that takes a {@code DataSource} to use and a {@code StatementConfiguration}.\n     *\n     * Methods that do not take a {@code Connection} parameter will retrieve connections from this\n     * {@code DataSource}.\n     *\n     * @param ds The {@code DataSource} to retrieve connections from.\n     * @param stmtConfig The configuration to apply to statements when they are prepared.\n     */\n    public QueryRunner(final DataSource ds, final StatementConfiguration stmtConfig) {\n        super(ds, stmtConfig);\n    }\n\n    /**\n     * Constructor for QueryRunner that takes a {@code StatementConfiguration} to configure statements when\n     * preparing them.\n     *\n     * @param stmtConfig The configuration to apply to statements when they are prepared.\n     */\n    public QueryRunner(final StatementConfiguration stmtConfig) {\n        super(stmtConfig);\n    }\n\n    /**\n     * Execute a batch of SQL INSERT, UPDATE, or DELETE queries.\n     *\n     * @param conn The Connection to use to run the query.  The caller is\n     * responsible for closing this Connection.\n     * @param sql The SQL to execute.\n     * @param params An array of query replacement parameters.  Each row in\n     * this array is one set of batch replacement values.\n     * @return The number of rows updated per statement.\n     * @throws SQLException if a database access error occurs\n     * @since 1.1\n     */\n    public int[] batch(final Connection conn, final String sql, final Object[][] params) throws SQLException {\n        if (conn == null) {\n            throw new SQLException(\"Null connection\");\n        }\n\n        if (sql == null) {\n            throw new SQLException(\"Null SQL statement\");\n        }\n\n        if (params == null) {\n            throw new SQLException(\"Null parameters. If parameters aren't need, pass an empty array.\");\n        }\n\n        PreparedStatement stmt = null;\n        ParameterMetaData pmd = null;\n        int[] rows = null;\n        try {\n            stmt = this.prepareStatement(conn, sql);\n            // When the batch size is large, prefetching parameter metadata before filling\n            // the statement can reduce lots of JDBC communications.\n            pmd = getParameterMetaData(stmt);\n\n            for (final Object[] param : params) {\n                this.fillStatement(stmt, pmd, param);\n                stmt.addBatch();\n            }\n            rows = stmt.executeBatch();\n\n        } catch (final SQLException e) {\n            rethrow(e, sql, (Object[])params);\n        } finally {\n            close(stmt);\n        }\n\n        return rows;\n    }\n\n    /**\n     * Execute a batch of SQL INSERT, UPDATE, or DELETE queries.  The\n     * {@code Connection} is retrieved from the {@code DataSource}\n     * set in the constructor.  This {@code Connection} must be in\n     * auto-commit mode or the update will not be saved.\n     *\n     * @param sql The SQL to execute.\n     * @param params An array of query replacement parameters.  Each row in\n     * this array is one set of batch replacement values.\n     * @return The number of rows updated per statement.\n     * @throws SQLException if a database access error occurs\n     * @since 1.1\n     */\n    public int[] batch(final String sql, final Object[][] params) throws SQLException {\n        try (Connection conn = prepareConnection()) {\n            return this.batch(conn, sql, params);\n        }\n    }\n\n    /**\n     * Execute an SQL statement, including a stored procedure call, which does\n     * not return any result sets.\n     * Any parameters which are instances of {@link OutParameter} will be\n     * registered as OUT parameters.\n     * <p>\n     * Use this method when invoking a stored procedure with OUT parameters\n     * that does not return any result sets.  If you are not invoking a stored\n     * procedure, or the stored procedure has no OUT parameters, consider using\n     * {@link #update(java.sql.Connection, String, Object...) }.\n     * If the stored procedure returns result sets, use\n     * {@link #execute(java.sql.Connection, String, org.apache.commons.dbutils.ResultSetHandler, Object...) }.\n     *\n     * @param conn The connection to use to run the query.\n     * @param sql The SQL to execute.\n     * @param params The query replacement parameters.\n     * @return The number of rows updated.\n     * @throws SQLException if a database access error occurs\n     */\n    public int execute(final Connection conn, final String sql, final Object... params) throws SQLException {\n        if (conn == null) {\n            throw new SQLException(\"Null connection\");\n        }\n\n        if (sql == null) {\n            throw new SQLException(\"Null SQL statement\");\n        }\n\n        CallableStatement stmt = null;\n        int rows = 0;\n\n        try {\n            stmt = prepareCall(conn, sql);\n            this.fillStatement(stmt, params);\n            stmt.execute();\n            rows = stmt.getUpdateCount();\n            retrieveOutParameters(stmt, params);\n\n        } catch (final SQLException e) {\n            rethrow(e, sql, params);\n\n        } finally {\n            close(stmt);\n        }\n\n        return rows;\n    }\n\n    /**\n     * Execute an SQL statement, including a stored procedure call, which\n     * returns one or more result sets.\n     * Any parameters which are instances of {@link OutParameter} will be\n     * registered as OUT parameters.\n     * <p>\n     * Use this method when: a) running SQL statements that return multiple\n     * result sets; b) invoking a stored procedure that return result\n     * sets and OUT parameters.  Otherwise you may wish to use\n     * {@link #query(java.sql.Connection, String, org.apache.commons.dbutils.ResultSetHandler, Object...) }\n     * (if there are no OUT parameters) or\n     * {@link #execute(java.sql.Connection, String, Object...) }\n     * (if there are no result sets).\n     *\n     * @param <T> The type of object that the handler returns\n     * @param conn The connection to use to run the query.\n     * @param sql The SQL to execute.\n     * @param rsh The result set handler\n     * @param params The query replacement parameters.\n     * @return A list of objects generated by the handler\n     * @throws SQLException if a database access error occurs\n     */\n    public <T> List<T> execute(final Connection conn, final String sql, final ResultSetHandler<T> rsh, final Object... params) throws SQLException {\n        if (conn == null) {\n            throw new SQLException(\"Null connection\");\n        }\n\n        if (sql == null) {\n            throw new SQLException(\"Null SQL statement\");\n        }\n\n        if (rsh == null) {\n            throw new SQLException(\"Null ResultSetHandler\");\n        }\n\n        CallableStatement stmt = null;\n        final List<T> results = new LinkedList<>();\n\n        try {\n            stmt = prepareCall(conn, sql);\n            this.fillStatement(stmt, params);\n            boolean moreResultSets = stmt.execute();\n            // Handle multiple result sets by passing them through the handler\n            // retaining the final result\n            while (moreResultSets) {\n                try (@SuppressWarnings(\"resource\")\n                // assume the ResultSet wrapper properly closes\n                ResultSet resultSet = wrap(stmt.getResultSet())) {\n                    results.add(rsh.handle(resultSet));\n                    moreResultSets = stmt.getMoreResults();\n                }\n            }\n            retrieveOutParameters(stmt, params);\n\n        } catch (final SQLException e) {\n            rethrow(e, sql, params);\n\n        } finally {\n            close(stmt);\n        }\n\n        return results;\n    }\n\n    /**\n     * Execute an SQL statement, including a stored procedure call, which does\n     * not return any result sets.\n     * Any parameters which are instances of {@link OutParameter} will be\n     * registered as OUT parameters.\n     * <p>\n     * Use this method when invoking a stored procedure with OUT parameters\n     * that does not return any result sets.  If you are not invoking a stored\n     * procedure, or the stored procedure has no OUT parameters, consider using\n     * {@link #update(String, Object...) }.\n     * If the stored procedure returns result sets, use\n     * {@link #execute(String, org.apache.commons.dbutils.ResultSetHandler, Object...) }.\n     * <p>\n     * The {@code Connection} is retrieved from the {@code DataSource}\n     * set in the constructor.  This {@code Connection} must be in\n     * auto-commit mode or the update will not be saved.\n     *\n     * @param sql The SQL statement to execute.\n     * @param params Initializes the CallableStatement's parameters (i.e. '?').\n     * @throws SQLException if a database access error occurs\n     * @return The number of rows updated.\n     */\n    public int execute(final String sql, final Object... params) throws SQLException {\n        try (Connection conn = prepareConnection()) {\n            return this.execute(conn, sql, params);\n        }\n    }\n\n    /**\n     * Execute an SQL statement, including a stored procedure call, which\n     * returns one or more result sets.\n     * Any parameters which are instances of {@link OutParameter} will be\n     * registered as OUT parameters.\n     * <p>\n     * Use this method when: a) running SQL statements that return multiple\n     * result sets; b) invoking a stored procedure that return result\n     * sets and OUT parameters.  Otherwise you may wish to use\n     * {@link #query(String, org.apache.commons.dbutils.ResultSetHandler, Object...) }\n     * (if there are no OUT parameters) or\n     * {@link #execute(String, Object...) }\n     * (if there are no result sets).\n     *\n     * @param <T> The type of object that the handler returns\n     * @param sql The SQL to execute.\n     * @param rsh The result set handler\n     * @param params The query replacement parameters.\n     * @return A list of objects generated by the handler\n     * @throws SQLException if a database access error occurs\n     */\n    public <T> List<T> execute(final String sql, final ResultSetHandler<T> rsh, final Object... params) throws SQLException {\n        try (Connection conn = prepareConnection()) {\n            return this.execute(conn, sql, rsh, params);\n        }\n    }\n\n    /**\n     * Execute an SQL INSERT query without replacement parameters.\n     * @param <T> The type of object that the handler returns\n     * @param conn The connection to use to run the query.\n     * @param sql The SQL to execute.\n     * @param rsh The handler used to create the result object from\n     * the {@code ResultSet} of auto-generated keys.\n     * @return An object generated by the handler.\n     * @throws SQLException if a database access error occurs\n     * @since 1.6\n     */\n    public <T> T insert(final Connection conn, final String sql, final ResultSetHandler<T> rsh) throws SQLException {\n        return insert(conn, sql, rsh, (Object[]) null);\n    }\n\n    /**\n     * Execute an SQL INSERT query.\n     * @param <T> The type of object that the handler returns\n     * @param conn The connection to use to run the query.\n     * @param sql The SQL to execute.\n     * @param rsh The handler used to create the result object from\n     * the {@code ResultSet} of auto-generated keys.\n     * @param params The query replacement parameters.\n     * @return An object generated by the handler.\n     * @throws SQLException if a database access error occurs\n     * @since 1.6\n     */\n    public <T> T insert(final Connection conn, final String sql, final ResultSetHandler<T> rsh, final Object... params) throws SQLException {\n        if (conn == null) {\n            throw new SQLException(\"Null connection\");\n        }\n\n        if (sql == null) {\n            throw new SQLException(\"Null SQL statement\");\n        }\n\n        if (rsh == null) {\n            throw new SQLException(\"Null ResultSetHandler\");\n        }\n\n        Statement stmt = null;\n        T generatedKeys = null;\n\n        try {\n            if (params != null && params.length > 0) {\n                final PreparedStatement ps = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);\n                stmt = ps;\n                this.fillStatement(ps, params);\n                ps.executeUpdate();\n            } else {\n                stmt = conn.createStatement();\n                stmt.executeUpdate(sql, Statement.RETURN_GENERATED_KEYS);\n            }\n            try (ResultSet resultSet = stmt.getGeneratedKeys()) {\n                generatedKeys = rsh.handle(resultSet);\n            }\n        } catch (final SQLException e) {\n            rethrow(e, sql, params);\n        } finally {\n            close(stmt);\n        }\n\n        return generatedKeys;\n    }\n\n    /**\n     * Executes the given INSERT SQL without any replacement parameters.\n     * The {@code Connection} is retrieved from the\n     * {@code DataSource} set in the constructor.\n     * @param <T> The type of object that the handler returns\n     * @param sql The SQL statement to execute.\n     * @param rsh The handler used to create the result object from\n     * the {@code ResultSet} of auto-generated keys.\n     * @return An object generated by the handler.\n     * @throws SQLException if a database access error occurs\n     * @since 1.6\n     */\n    public <T> T insert(final String sql, final ResultSetHandler<T> rsh) throws SQLException {\n        try (Connection conn = prepareConnection()) {\n            return insert(conn, sql, rsh, (Object[]) null);\n        }\n    }\n\n    /**\n     * Executes the given INSERT SQL statement. The\n     * {@code Connection} is retrieved from the {@code DataSource}\n     * set in the constructor.  This {@code Connection} must be in\n     * auto-commit mode or the insert will not be saved.\n     * @param <T> The type of object that the handler returns\n     * @param sql The SQL statement to execute.\n     * @param rsh The handler used to create the result object from\n     * the {@code ResultSet} of auto-generated keys.\n     * @param params Initializes the PreparedStatement's IN (i.e. '?')\n     * @return An object generated by the handler.\n     * @throws SQLException if a database access error occurs\n     * @since 1.6\n     */\n    public <T> T insert(final String sql, final ResultSetHandler<T> rsh, final Object... params) throws SQLException {\n        try (Connection conn = prepareConnection()) {\n            return insert(conn, sql, rsh, params);\n        }\n    }\n\n    /**\n     * Executes the given batch of INSERT SQL statements.\n     * @param <T> The type of object that the handler returns\n     * @param conn The connection to use to run the query.\n     * @param sql The SQL to execute.\n     * @param rsh The handler used to create the result object from\n     * the {@code ResultSet} of auto-generated keys.\n     * @param params The query replacement parameters.\n     * @return The result generated by the handler.\n     * @throws SQLException if a database access error occurs\n     * @since 1.6\n     */\n    public <T> T insertBatch(final Connection conn, final String sql, final ResultSetHandler<T> rsh, final Object[][] params) throws SQLException {\n        if (conn == null) {\n            throw new SQLException(\"Null connection\");\n        }\n\n        if (sql == null) {\n            throw new SQLException(\"Null SQL statement\");\n        }\n\n        if (params == null) {\n            throw new SQLException(\"Null parameters. If parameters aren't need, pass an empty array.\");\n        }\n\n        PreparedStatement stmt = null;\n        T generatedKeys = null;\n        try {\n            stmt = this.prepareStatement(conn, sql, Statement.RETURN_GENERATED_KEYS);\n\n            for (final Object[] param : params) {\n                this.fillStatement(stmt, param);\n                stmt.addBatch();\n            }\n            stmt.executeBatch();\n            try (ResultSet resultSet = stmt.getGeneratedKeys()) {\n                generatedKeys = rsh.handle(resultSet);\n            }\n        } catch (final SQLException e) {\n            rethrow(e, sql, (Object[])params);\n        } finally {\n            close(stmt);\n        }\n\n        return generatedKeys;\n    }\n\n    /**\n     * Executes the given batch of INSERT SQL statements. The\n     * {@code Connection} is retrieved from the {@code DataSource}\n     * set in the constructor.  This {@code Connection} must be in\n     * auto-commit mode or the insert will not be saved.\n     * @param <T> The type of object that the handler returns\n     * @param sql The SQL statement to execute.\n     * @param rsh The handler used to create the result object from\n     * the {@code ResultSet} of auto-generated keys.\n     * @param params Initializes the PreparedStatement's IN (i.e. '?')\n     * @return The result generated by the handler.\n     * @throws SQLException if a database access error occurs\n     * @since 1.6\n     */\n    public <T> T insertBatch(final String sql, final ResultSetHandler<T> rsh, final Object[][] params) throws SQLException {\n        try (Connection conn = prepareConnection()) {\n            return insertBatch(conn, sql, rsh, params);\n        }\n    }\n\n    /**\n     * Execute an SQL SELECT query with a single replacement parameter. The\n     * caller is responsible for closing the connection.\n     * @param <T> The type of object that the handler returns\n     * @param conn The connection to execute the query in.\n     * @param sql The query to execute.\n     * @param param The replacement parameter.\n     * @param rsh The handler that converts the results into an object.\n     * @return The object returned by the handler.\n     * @throws SQLException if a database access error occurs\n     * @deprecated Use {@link #query(Connection, String, ResultSetHandler, Object...)}\n     */\n    @Deprecated\n    public <T> T query(final Connection conn, final String sql, final Object param, final ResultSetHandler<T> rsh) throws SQLException {\n        return this.<T>query(conn, sql, rsh, param);\n    }\n\n    /**\n     * Execute an SQL SELECT query with replacement parameters.  The\n     * caller is responsible for closing the connection.\n     * @param <T> The type of object that the handler returns\n     * @param conn The connection to execute the query in.\n     * @param sql The query to execute.\n     * @param params The replacement parameters.\n     * @param rsh The handler that converts the results into an object.\n     * @return The object returned by the handler.\n     * @throws SQLException if a database access error occurs\n     * @deprecated Use {@link #query(Connection,String,ResultSetHandler,Object...)} instead\n     */\n    @Deprecated\n    public <T> T query(final Connection conn, final String sql, final Object[] params, final ResultSetHandler<T> rsh) throws SQLException {\n        return this.<T>query(conn, sql, rsh, params);\n    }\n\n    /**\n     * Execute an SQL SELECT query without any replacement parameters.  The\n     * caller is responsible for closing the connection.\n     * @param <T> The type of object that the handler returns\n     * @param conn The connection to execute the query in.\n     * @param sql The query to execute.\n     * @param rsh The handler that converts the results into an object.\n     * @return The object returned by the handler.\n     * @throws SQLException if a database access error occurs\n     */\n    public <T> T query(final Connection conn, final String sql, final ResultSetHandler<T> rsh) throws SQLException {\n        return this.<T>query(conn, sql, rsh, (Object[]) null);\n    }\n\n    /**\n     * Execute an SQL SELECT query with replacement parameters.  The\n     * caller is responsible for closing the connection.\n     * @param <T> The type of object that the handler returns\n     * @param conn The connection to execute the query in.\n     * @param sql The query to execute.\n     * @param rsh The handler that converts the results into an object.\n     * @param params The replacement parameters.\n     * @return The object returned by the handler.\n     * @throws SQLException if a database access error occurs\n     */\n    public <T> T query(final Connection conn, final String sql, final ResultSetHandler<T> rsh, final Object... params) throws SQLException {\n        if (conn == null) {\n            throw new SQLException(\"Null connection\");\n        }\n\n        if (sql == null) {\n            throw new SQLException(\"Null SQL statement\");\n        }\n\n        if (rsh == null) {\n            throw new SQLException(\"Null ResultSetHandler\");\n        }\n\n        Statement stmt = null;\n        ResultSet resultSet = null;\n        T result = null;\n\n        try {\n            if (params != null && params.length > 0) {\n                final PreparedStatement ps = this.prepareStatement(conn, sql);\n                stmt = ps;\n                this.fillStatement(ps, params);\n                resultSet = wrap(ps.executeQuery());\n            } else {\n                stmt = conn.createStatement();\n                resultSet = wrap(stmt.executeQuery(sql));\n            }\n            result = rsh.handle(resultSet);\n\n        } catch (final SQLException e) {\n            rethrow(e, sql, params);\n\n        } finally {\n            closeQuietly(resultSet);\n            closeQuietly(stmt);\n        }\n\n        return result;\n    }\n\n    /**\n     * Executes the given SELECT SQL with a single replacement parameter.\n     * The {@code Connection} is retrieved from the\n     * {@code DataSource} set in the constructor.\n     * @param <T> The type of object that the handler returns\n     * @param sql The SQL statement to execute.\n     * @param param The replacement parameter.\n     * @param rsh The handler used to create the result object from\n     * the {@code ResultSet}.\n     *\n     * @return An object generated by the handler.\n     * @throws SQLException if a database access error occurs\n     * @deprecated Use {@link #query(String, ResultSetHandler, Object...)}\n     */\n    @Deprecated\n    public <T> T query(final String sql, final Object param, final ResultSetHandler<T> rsh) throws SQLException {\n        try (Connection conn = prepareConnection()) {\n            return this.<T>query(conn, sql, rsh, param);\n        }\n    }\n\n    /**\n     * Executes the given SELECT SQL query and returns a result object.\n     * The {@code Connection} is retrieved from the\n     * {@code DataSource} set in the constructor.\n     * @param <T> The type of object that the handler returns\n     * @param sql The SQL statement to execute.\n     * @param params Initialize the PreparedStatement's IN parameters with\n     * this array.\n     *\n     * @param rsh The handler used to create the result object from\n     * the {@code ResultSet}.\n     *\n     * @return An object generated by the handler.\n     * @throws SQLException if a database access error occurs\n     * @deprecated Use {@link #query(String, ResultSetHandler, Object...)}\n     */\n    @Deprecated\n    public <T> T query(final String sql, final Object[] params, final ResultSetHandler<T> rsh) throws SQLException {\n        try (Connection conn = prepareConnection()) {\n            return this.<T>query(conn, sql, rsh, params);\n        }\n    }\n\n    /**\n     * Executes the given SELECT SQL without any replacement parameters.\n     * The {@code Connection} is retrieved from the\n     * {@code DataSource} set in the constructor.\n     * @param <T> The type of object that the handler returns\n     * @param sql The SQL statement to execute.\n     * @param rsh The handler used to create the result object from\n     * the {@code ResultSet}.\n     *\n     * @return An object generated by the handler.\n     * @throws SQLException if a database access error occurs\n     */\n    public <T> T query(final String sql, final ResultSetHandler<T> rsh) throws SQLException {\n        try (Connection conn = prepareConnection()) {\n            return this.<T>query(conn, sql, rsh, (Object[]) null);\n        }\n    }\n\n    /**\n     * Executes the given SELECT SQL query and returns a result object.\n     * The {@code Connection} is retrieved from the\n     * {@code DataSource} set in the constructor.\n     * @param <T> The type of object that the handler returns\n     * @param sql The SQL statement to execute.\n     * @param rsh The handler used to create the result object from\n     * the {@code ResultSet}.\n     * @param params Initialize the PreparedStatement's IN parameters with\n     * this array.\n     * @return An object generated by the handler.\n     * @throws SQLException if a database access error occurs\n     */\n    public <T> T query(final String sql, final ResultSetHandler<T> rsh, final Object... params) throws SQLException {\n        try (Connection conn = prepareConnection()) {\n            return this.<T>query(conn, sql, rsh, params);\n        }\n    }\n\n    /**\n     * Set the value on all the {@link OutParameter} instances in the\n     * {@code params} array using the OUT parameter values from the\n     * {@code stmt}.\n     * @param stmt the statement from which to retrieve OUT parameter values\n     * @param params the parameter array for the statement invocation\n     * @throws SQLException when the value could not be retrieved from the\n     * statement.\n     */\n    private void retrieveOutParameters(final CallableStatement stmt, final Object[] params) throws SQLException {\n        if (params != null) {\n            for (int i = 0; i < params.length; i++) {\n                if (params[i] instanceof OutParameter) {\n                    ((OutParameter<?>) params[i]).setValue(stmt, i + 1);\n                }\n            }\n        }\n    }\n\n    /**\n     * Execute an SQL INSERT, UPDATE, or DELETE query without replacement\n     * parameters.\n     *\n     * @param conn The connection to use to run the query.\n     * @param sql The SQL to execute.\n     * @return The number of rows updated.\n     * @throws SQLException if a database access error occurs\n     */\n    public int update(final Connection conn, final String sql) throws SQLException {\n        return this.update(conn, sql, (Object[]) null);\n    }\n\n    /**\n     * Execute an SQL INSERT, UPDATE, or DELETE query with a single replacement\n     * parameter.\n     *\n     * @param conn The connection to use to run the query.\n     * @param sql The SQL to execute.\n     * @param param The replacement parameter.\n     * @return The number of rows updated.\n     * @throws SQLException if a database access error occurs\n     */\n    public int update(final Connection conn, final String sql, final Object param) throws SQLException {\n        return this.update(conn, sql, new Object[] { param });\n    }\n\n    /**\n     * Execute an SQL INSERT, UPDATE, or DELETE query.\n     *\n     * @param conn The connection to use to run the query.\n     * @param sql The SQL to execute.\n     * @param params The query replacement parameters.\n     * @return The number of rows updated.\n     * @throws SQLException if a database access error occurs\n     */\n    public int update(final Connection conn, final String sql, final Object... params) throws SQLException {\n        if (conn == null) {\n            throw new SQLException(\"Null connection\");\n        }\n\n        if (sql == null) {\n            throw new SQLException(\"Null SQL statement\");\n        }\n\n        Statement stmt = null;\n        int rows = 0;\n\n        try {\n            if (params != null && params.length > 0) {\n                final PreparedStatement ps = this.prepareStatement(conn, sql);\n                stmt = ps;\n                this.fillStatement(ps, params);\n                rows = ps.executeUpdate();\n            } else {\n                stmt = conn.createStatement();\n                rows = stmt.executeUpdate(sql);\n            }\n\n        } catch (final SQLException e) {\n            rethrow(e, sql, params);\n\n        } finally {\n            close(stmt);\n        }\n\n        return rows;\n    }\n\n    /**\n     * Executes the given INSERT, UPDATE, or DELETE SQL statement without\n     * any replacement parameters. The {@code Connection} is retrieved\n     * from the {@code DataSource} set in the constructor.  This\n     * {@code Connection} must be in auto-commit mode or the update will\n     * not be saved.\n     *\n     * @param sql The SQL statement to execute.\n     * @throws SQLException if a database access error occurs\n     * @return The number of rows updated.\n     */\n    public int update(final String sql) throws SQLException {\n        try (Connection conn = prepareConnection()) {\n            return this.update(conn, sql, (Object[]) null);\n        }\n    }\n\n    /**\n     * Executes the given INSERT, UPDATE, or DELETE SQL statement with\n     * a single replacement parameter.  The {@code Connection} is\n     * retrieved from the {@code DataSource} set in the constructor.\n     * This {@code Connection} must be in auto-commit mode or the\n     * update will not be saved.\n     *\n     * @param sql The SQL statement to execute.\n     * @param param The replacement parameter.\n     * @throws SQLException if a database access error occurs\n     * @return The number of rows updated.\n     */\n    public int update(final String sql, final Object param) throws SQLException {\n        try (Connection conn = prepareConnection()) {\n            return this.update(conn, sql, param);\n        }\n    }\n\n    /**\n     * Executes the given INSERT, UPDATE, or DELETE SQL statement.  The\n     * {@code Connection} is retrieved from the {@code DataSource}\n     * set in the constructor.  This {@code Connection} must be in\n     * auto-commit mode or the update will not be saved.\n     *\n     * @param sql The SQL statement to execute.\n     * @param params Initializes the PreparedStatement's IN (i.e. '?')\n     * parameters.\n     * @throws SQLException if a database access error occurs\n     * @return The number of rows updated.\n     */\n    public int update(final String sql, final Object... params) throws SQLException {\n        try (Connection conn = prepareConnection()) {\n            return this.update(conn, sql, params);\n        }\n    }\n}", "definition": "public class QueryRunner extends AbstractQueryRunner", "class_docstring": "\nExecutes SQL queries with pluggable strategies for handling\n{@code ResultSet}s.  This class is thread safe.\n\n@see ResultSetHandler\n", "name": "QueryRunner", "super_interfaces": [], "superclasses": "AbstractQueryRunner", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public QueryRunner() {\n    }", "docstring": "\nConstructor for QueryRunner.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "QueryRunner", "params": [], "body": "                         {\n    }", "signature": "public QueryRunner()"}, {"syntax_pass": true, "original_string": "    public QueryRunner(final boolean pmdKnownBroken) {\n        super(pmdKnownBroken);\n    }", "docstring": "\nConstructor for QueryRunner that controls the use of {@code ParameterMetaData}.\n\n@param pmdKnownBroken Some drivers don't support {@link java.sql.ParameterMetaData#getParameterType(int) };\nif {@code pmdKnownBroken} is set to true, we won't even try it; if false, we'll try it,\nand if it breaks, we'll remember not to use it again.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "QueryRunner", "params": [{"name": "pmdKnownBroken", "type": "boolean"}], "body": "                                                     {\n        super(pmdKnownBroken);\n    }", "signature": "public QueryRunner(final boolean pmdKnownBroken)"}, {"syntax_pass": true, "original_string": "    public QueryRunner(final DataSource ds) {\n        super(ds);\n    }", "docstring": "\nConstructor for QueryRunner that takes a {@code DataSource} to use.\n\nMethods that do not take a {@code Connection} parameter will retrieve connections from this\n{@code DataSource}.\n\n@param ds The {@code DataSource} to retrieve connections from.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "QueryRunner", "params": [{"name": "ds", "type": "DataSource"}], "body": "                                            {\n        super(ds);\n    }", "signature": "public QueryRunner(final DataSource ds)"}, {"syntax_pass": true, "original_string": "    public QueryRunner(final DataSource ds, final boolean pmdKnownBroken) {\n        super(ds, pmdKnownBroken);\n    }", "docstring": "\nConstructor for QueryRunner that takes a {@code DataSource} and controls the use of {@code ParameterMetaData}.\nMethods that do not take a {@code Connection} parameter will retrieve connections from this\n{@code DataSource}.\n\n@param ds The {@code DataSource} to retrieve connections from.\n@param pmdKnownBroken Some drivers don't support {@link java.sql.ParameterMetaData#getParameterType(int) };\nif {@code pmdKnownBroken} is set to true, we won't even try it; if false, we'll try it,\nand if it breaks, we'll remember not to use it again.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "QueryRunner", "params": [{"name": "ds", "type": "DataSource"}, {"name": "pmdKnownBroken", "type": "boolean"}], "body": "                                                                          {\n        super(ds, pmdKnownBroken);\n    }", "signature": "public QueryRunner(final DataSource ds, final boolean pmdKnownBroken)"}, {"syntax_pass": true, "original_string": "    public QueryRunner(final DataSource ds, final boolean pmdKnownBroken, final StatementConfiguration stmtConfig) {\n        super(ds, pmdKnownBroken, stmtConfig);\n    }", "docstring": "\nConstructor for QueryRunner that takes a {@code DataSource}, a {@code StatementConfiguration}, and\ncontrols the use of {@code ParameterMetaData}.  Methods that do not take a {@code Connection} parameter\nwill retrieve connections from this {@code DataSource}.\n\n@param ds The {@code DataSource} to retrieve connections from.\n@param pmdKnownBroken Some drivers don't support {@link java.sql.ParameterMetaData#getParameterType(int) };\nif {@code pmdKnownBroken} is set to true, we won't even try it; if false, we'll try it,\nand if it breaks, we'll remember not to use it again.\n@param stmtConfig The configuration to apply to statements when they are prepared.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "QueryRunner", "params": [{"name": "ds", "type": "DataSource"}, {"name": "pmdKnownBroken", "type": "boolean"}, {"name": "stmtConfig", "type": "StatementConfiguration"}], "body": "                                                                                                                   {\n        super(ds, pmdKnownBroken, stmtConfig);\n    }", "signature": "public QueryRunner(final DataSource ds, final boolean pmdKnownBroken, final StatementConfiguration stmtConfig)"}, {"syntax_pass": true, "original_string": "    public QueryRunner(final DataSource ds, final StatementConfiguration stmtConfig) {\n        super(ds, stmtConfig);\n    }", "docstring": "\nConstructor for QueryRunner that takes a {@code DataSource} to use and a {@code StatementConfiguration}.\n\nMethods that do not take a {@code Connection} parameter will retrieve connections from this\n{@code DataSource}.\n\n@param ds The {@code DataSource} to retrieve connections from.\n@param stmtConfig The configuration to apply to statements when they are prepared.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "QueryRunner", "params": [{"name": "ds", "type": "DataSource"}, {"name": "stmtConfig", "type": "StatementConfiguration"}], "body": "                                                                                     {\n        super(ds, stmtConfig);\n    }", "signature": "public QueryRunner(final DataSource ds, final StatementConfiguration stmtConfig)"}, {"syntax_pass": true, "original_string": "    public QueryRunner(final StatementConfiguration stmtConfig) {\n        super(stmtConfig);\n    }", "docstring": "\nConstructor for QueryRunner that takes a {@code StatementConfiguration} to configure statements when\npreparing them.\n\n@param stmtConfig The configuration to apply to statements when they are prepared.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "QueryRunner", "params": [{"name": "stmtConfig", "type": "StatementConfiguration"}], "body": "                                                                {\n        super(stmtConfig);\n    }", "signature": "public QueryRunner(final StatementConfiguration stmtConfig)"}, {"syntax_pass": true, "original_string": "    public int[] batch(final Connection conn, final String sql, final Object[][] params) throws SQLException {\n        if (conn == null) {\n            throw new SQLException(\"Null connection\");\n        }\n\n        if (sql == null) {\n            throw new SQLException(\"Null SQL statement\");\n        }\n\n        if (params == null) {\n            throw new SQLException(\"Null parameters. If parameters aren't need, pass an empty array.\");\n        }\n\n        PreparedStatement stmt = null;\n        ParameterMetaData pmd = null;\n        int[] rows = null;\n        try {\n            stmt = this.prepareStatement(conn, sql);\n            // When the batch size is large, prefetching parameter metadata before filling\n            // the statement can reduce lots of JDBC communications.\n            pmd = getParameterMetaData(stmt);\n\n            for (final Object[] param : params) {\n                this.fillStatement(stmt, pmd, param);\n                stmt.addBatch();\n            }\n            rows = stmt.executeBatch();\n\n        } catch (final SQLException e) {\n            rethrow(e, sql, (Object[])params);\n        } finally {\n            close(stmt);\n        }\n\n        return rows;\n    }", "docstring": "\nExecute a batch of SQL INSERT, UPDATE, or DELETE queries.\n\n@param conn The Connection to use to run the query.  The caller is\nresponsible for closing this Connection.\n@param sql The SQL to execute.\n@param params An array of query replacement parameters.  Each row in\nthis array is one set of batch replacement values.\n@return The number of rows updated per statement.\n@throws SQLException if a database access error occurs\n@since 1.1\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int[]", "classes": []}, "name": "batch", "params": [{"name": "conn", "type": "Connection"}, {"name": "sql", "type": "String"}, {"name": "params", "type": "Object[][]"}], "body": "                                                                                                             {\n        if (conn == null) {\n            throw new SQLException(\"Null connection\");\n        }\n\n        if (sql == null) {\n            throw new SQLException(\"Null SQL statement\");\n        }\n\n        if (params == null) {\n            throw new SQLException(\"Null parameters. If parameters aren't need, pass an empty array.\");\n        }\n\n        PreparedStatement stmt = null;\n        ParameterMetaData pmd = null;\n        int[] rows = null;\n        try {\n            stmt = this.prepareStatement(conn, sql);\n            // When the batch size is large, prefetching parameter metadata before filling\n            // the statement can reduce lots of JDBC communications.\n            pmd = getParameterMetaData(stmt);\n\n            for (final Object[] param : params) {\n                this.fillStatement(stmt, pmd, param);\n                stmt.addBatch();\n            }\n            rows = stmt.executeBatch();\n\n        } catch (final SQLException e) {\n            rethrow(e, sql, (Object[])params);\n        } finally {\n            close(stmt);\n        }\n\n        return rows;\n    }", "signature": "public int[] batch(final Connection conn, final String sql, final Object[][] params)"}, {"syntax_pass": true, "original_string": "    public int[] batch(final String sql, final Object[][] params) throws SQLException {\n        try (Connection conn = prepareConnection()) {\n            return this.batch(conn, sql, params);\n        }\n    }", "docstring": "\nExecute a batch of SQL INSERT, UPDATE, or DELETE queries.  The\n{@code Connection} is retrieved from the {@code DataSource}\nset in the constructor.  This {@code Connection} must be in\nauto-commit mode or the update will not be saved.\n\n@param sql The SQL to execute.\n@param params An array of query replacement parameters.  Each row in\nthis array is one set of batch replacement values.\n@return The number of rows updated per statement.\n@throws SQLException if a database access error occurs\n@since 1.1\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int[]", "classes": []}, "name": "batch", "params": [{"name": "sql", "type": "String"}, {"name": "params", "type": "Object[][]"}], "body": "                                                                                      {\n        try (Connection conn = prepareConnection()) {\n            return this.batch(conn, sql, params);\n        }\n    }", "signature": "public int[] batch(final String sql, final Object[][] params)"}, {"syntax_pass": true, "original_string": "    public int execute(final Connection conn, final String sql, final Object... params) throws SQLException {\n        if (conn == null) {\n            throw new SQLException(\"Null connection\");\n        }\n\n        if (sql == null) {\n            throw new SQLException(\"Null SQL statement\");\n        }\n\n        CallableStatement stmt = null;\n        int rows = 0;\n\n        try {\n            stmt = prepareCall(conn, sql);\n            this.fillStatement(stmt, params);\n            stmt.execute();\n            rows = stmt.getUpdateCount();\n            retrieveOutParameters(stmt, params);\n\n        } catch (final SQLException e) {\n            rethrow(e, sql, params);\n\n        } finally {\n            close(stmt);\n        }\n\n        return rows;\n    }", "docstring": "\nExecute an SQL statement, including a stored procedure call, which does\nnot return any result sets.\nAny parameters which are instances of {@link OutParameter} will be\nregistered as OUT parameters.\n<p>\nUse this method when invoking a stored procedure with OUT parameters\nthat does not return any result sets.  If you are not invoking a stored\nprocedure, or the stored procedure has no OUT parameters, consider using\n{@link #update(java.sql.Connection, String, Object...) }.\nIf the stored procedure returns result sets, use\n{@link #execute(java.sql.Connection, String, org.apache.commons.dbutils.ResultSetHandler, Object...) }.\n\n@param conn The connection to use to run the query.\n@param sql The SQL to execute.\n@param params The query replacement parameters.\n@return The number of rows updated.\n@throws SQLException if a database access error occurs\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "execute", "params": [{"name": "conn", "type": "Connection"}, {"name": "sql", "type": "String"}], "body": "                                                                                                            {\n        if (conn == null) {\n            throw new SQLException(\"Null connection\");\n        }\n\n        if (sql == null) {\n            throw new SQLException(\"Null SQL statement\");\n        }\n\n        CallableStatement stmt = null;\n        int rows = 0;\n\n        try {\n            stmt = prepareCall(conn, sql);\n            this.fillStatement(stmt, params);\n            stmt.execute();\n            rows = stmt.getUpdateCount();\n            retrieveOutParameters(stmt, params);\n\n        } catch (final SQLException e) {\n            rethrow(e, sql, params);\n\n        } finally {\n            close(stmt);\n        }\n\n        return rows;\n    }", "signature": "public int execute(final Connection conn, final String sql, final Object... params)"}, {"syntax_pass": true, "original_string": "    public <T> List<T> execute(final Connection conn, final String sql, final ResultSetHandler<T> rsh, final Object... params) throws SQLException {\n        if (conn == null) {\n            throw new SQLException(\"Null connection\");\n        }\n\n        if (sql == null) {\n            throw new SQLException(\"Null SQL statement\");\n        }\n\n        if (rsh == null) {\n            throw new SQLException(\"Null ResultSetHandler\");\n        }\n\n        CallableStatement stmt = null;\n        final List<T> results = new LinkedList<>();\n\n        try {\n            stmt = prepareCall(conn, sql);\n            this.fillStatement(stmt, params);\n            boolean moreResultSets = stmt.execute();\n            // Handle multiple result sets by passing them through the handler\n            // retaining the final result\n            while (moreResultSets) {\n                try (@SuppressWarnings(\"resource\")\n                // assume the ResultSet wrapper properly closes\n                ResultSet resultSet = wrap(stmt.getResultSet())) {\n                    results.add(rsh.handle(resultSet));\n                    moreResultSets = stmt.getMoreResults();\n                }\n            }\n            retrieveOutParameters(stmt, params);\n\n        } catch (final SQLException e) {\n            rethrow(e, sql, params);\n\n        } finally {\n            close(stmt);\n        }\n\n        return results;\n    }", "docstring": "\nExecute an SQL statement, including a stored procedure call, which\nreturns one or more result sets.\nAny parameters which are instances of {@link OutParameter} will be\nregistered as OUT parameters.\n<p>\nUse this method when: a) running SQL statements that return multiple\nresult sets; b) invoking a stored procedure that return result\nsets and OUT parameters.  Otherwise you may wish to use\n{@link #query(java.sql.Connection, String, org.apache.commons.dbutils.ResultSetHandler, Object...) }\n(if there are no OUT parameters) or\n{@link #execute(java.sql.Connection, String, Object...) }\n(if there are no result sets).\n\n@param <T> The type of object that the handler returns\n@param conn The connection to use to run the query.\n@param sql The SQL to execute.\n@param rsh The result set handler\n@param params The query replacement parameters.\n@return A list of objects generated by the handler\n@throws SQLException if a database access error occurs\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<T>", "classes": []}, "name": "execute", "params": [{"name": "conn", "type": "Connection"}, {"name": "sql", "type": "String"}, {"name": "rsh", "type": "ResultSetHandler<T>"}], "body": "                                                                                                                                                   {\n        if (conn == null) {\n            throw new SQLException(\"Null connection\");\n        }\n\n        if (sql == null) {\n            throw new SQLException(\"Null SQL statement\");\n        }\n\n        if (rsh == null) {\n            throw new SQLException(\"Null ResultSetHandler\");\n        }\n\n        CallableStatement stmt = null;\n        final List<T> results = new LinkedList<>();\n\n        try {\n            stmt = prepareCall(conn, sql);\n            this.fillStatement(stmt, params);\n            boolean moreResultSets = stmt.execute();\n            // Handle multiple result sets by passing them through the handler\n            // retaining the final result\n            while (moreResultSets) {\n                try (@SuppressWarnings(\"resource\")\n                // assume the ResultSet wrapper properly closes\n                ResultSet resultSet = wrap(stmt.getResultSet())) {\n                    results.add(rsh.handle(resultSet));\n                    moreResultSets = stmt.getMoreResults();\n                }\n            }\n            retrieveOutParameters(stmt, params);\n\n        } catch (final SQLException e) {\n            rethrow(e, sql, params);\n\n        } finally {\n            close(stmt);\n        }\n\n        return results;\n    }", "signature": "public <T> List<T> execute(final Connection conn, final String sql, final ResultSetHandler<T> rsh, final Object... params)"}, {"syntax_pass": true, "original_string": "    public int execute(final String sql, final Object... params) throws SQLException {\n        try (Connection conn = prepareConnection()) {\n            return this.execute(conn, sql, params);\n        }\n    }", "docstring": "\nExecute an SQL statement, including a stored procedure call, which does\nnot return any result sets.\nAny parameters which are instances of {@link OutParameter} will be\nregistered as OUT parameters.\n<p>\nUse this method when invoking a stored procedure with OUT parameters\nthat does not return any result sets.  If you are not invoking a stored\nprocedure, or the stored procedure has no OUT parameters, consider using\n{@link #update(String, Object...) }.\nIf the stored procedure returns result sets, use\n{@link #execute(String, org.apache.commons.dbutils.ResultSetHandler, Object...) }.\n<p>\nThe {@code Connection} is retrieved from the {@code DataSource}\nset in the constructor.  This {@code Connection} must be in\nauto-commit mode or the update will not be saved.\n\n@param sql The SQL statement to execute.\n@param params Initializes the CallableStatement's parameters (i.e. '?').\n@throws SQLException if a database access error occurs\n@return The number of rows updated.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "execute", "params": [{"name": "sql", "type": "String"}], "body": "                                                                                     {\n        try (Connection conn = prepareConnection()) {\n            return this.execute(conn, sql, params);\n        }\n    }", "signature": "public int execute(final String sql, final Object... params)"}, {"syntax_pass": true, "original_string": "    public <T> List<T> execute(final String sql, final ResultSetHandler<T> rsh, final Object... params) throws SQLException {\n        try (Connection conn = prepareConnection()) {\n            return this.execute(conn, sql, rsh, params);\n        }\n    }", "docstring": "\nExecute an SQL statement, including a stored procedure call, which\nreturns one or more result sets.\nAny parameters which are instances of {@link OutParameter} will be\nregistered as OUT parameters.\n<p>\nUse this method when: a) running SQL statements that return multiple\nresult sets; b) invoking a stored procedure that return result\nsets and OUT parameters.  Otherwise you may wish to use\n{@link #query(String, org.apache.commons.dbutils.ResultSetHandler, Object...) }\n(if there are no OUT parameters) or\n{@link #execute(String, Object...) }\n(if there are no result sets).\n\n@param <T> The type of object that the handler returns\n@param sql The SQL to execute.\n@param rsh The result set handler\n@param params The query replacement parameters.\n@return A list of objects generated by the handler\n@throws SQLException if a database access error occurs\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<T>", "classes": []}, "name": "execute", "params": [{"name": "sql", "type": "String"}, {"name": "rsh", "type": "ResultSetHandler<T>"}], "body": "                                                                                                                            {\n        try (Connection conn = prepareConnection()) {\n            return this.execute(conn, sql, rsh, params);\n        }\n    }", "signature": "public <T> List<T> execute(final String sql, final ResultSetHandler<T> rsh, final Object... params)"}, {"syntax_pass": true, "original_string": "    public <T> T insert(final Connection conn, final String sql, final ResultSetHandler<T> rsh) throws SQLException {\n        return insert(conn, sql, rsh, (Object[]) null);\n    }", "docstring": "\nExecute an SQL INSERT query without replacement parameters.\n@param <T> The type of object that the handler returns\n@param conn The connection to use to run the query.\n@param sql The SQL to execute.\n@param rsh The handler used to create the result object from\nthe {@code ResultSet} of auto-generated keys.\n@return An object generated by the handler.\n@throws SQLException if a database access error occurs\n@since 1.6\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "T", "classes": []}, "name": "insert", "params": [{"name": "conn", "type": "Connection"}, {"name": "sql", "type": "String"}, {"name": "rsh", "type": "ResultSetHandler<T>"}], "body": "                                                                                                                    {\n        return insert(conn, sql, rsh, (Object[]) null);\n    }", "signature": "public <T> T insert(final Connection conn, final String sql, final ResultSetHandler<T> rsh)"}, {"syntax_pass": true, "original_string": "    public <T> T insert(final Connection conn, final String sql, final ResultSetHandler<T> rsh, final Object... params) throws SQLException {\n        if (conn == null) {\n            throw new SQLException(\"Null connection\");\n        }\n\n        if (sql == null) {\n            throw new SQLException(\"Null SQL statement\");\n        }\n\n        if (rsh == null) {\n            throw new SQLException(\"Null ResultSetHandler\");\n        }\n\n        Statement stmt = null;\n        T generatedKeys = null;\n\n        try {\n            if (params != null && params.length > 0) {\n                final PreparedStatement ps = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);\n                stmt = ps;\n                this.fillStatement(ps, params);\n                ps.executeUpdate();\n            } else {\n                stmt = conn.createStatement();\n                stmt.executeUpdate(sql, Statement.RETURN_GENERATED_KEYS);\n            }\n            try (ResultSet resultSet = stmt.getGeneratedKeys()) {\n                generatedKeys = rsh.handle(resultSet);\n            }\n        } catch (final SQLException e) {\n            rethrow(e, sql, params);\n        } finally {\n            close(stmt);\n        }\n\n        return generatedKeys;\n    }", "docstring": "\nExecute an SQL INSERT query.\n@param <T> The type of object that the handler returns\n@param conn The connection to use to run the query.\n@param sql The SQL to execute.\n@param rsh The handler used to create the result object from\nthe {@code ResultSet} of auto-generated keys.\n@param params The query replacement parameters.\n@return An object generated by the handler.\n@throws SQLException if a database access error occurs\n@since 1.6\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "T", "classes": []}, "name": "insert", "params": [{"name": "conn", "type": "Connection"}, {"name": "sql", "type": "String"}, {"name": "rsh", "type": "ResultSetHandler<T>"}], "body": "                                                                                                                                            {\n        if (conn == null) {\n            throw new SQLException(\"Null connection\");\n        }\n\n        if (sql == null) {\n            throw new SQLException(\"Null SQL statement\");\n        }\n\n        if (rsh == null) {\n            throw new SQLException(\"Null ResultSetHandler\");\n        }\n\n        Statement stmt = null;\n        T generatedKeys = null;\n\n        try {\n            if (params != null && params.length > 0) {\n                final PreparedStatement ps = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);\n                stmt = ps;\n                this.fillStatement(ps, params);\n                ps.executeUpdate();\n            } else {\n                stmt = conn.createStatement();\n                stmt.executeUpdate(sql, Statement.RETURN_GENERATED_KEYS);\n            }\n            try (ResultSet resultSet = stmt.getGeneratedKeys()) {\n                generatedKeys = rsh.handle(resultSet);\n            }\n        } catch (final SQLException e) {\n            rethrow(e, sql, params);\n        } finally {\n            close(stmt);\n        }\n\n        return generatedKeys;\n    }", "signature": "public <T> T insert(final Connection conn, final String sql, final ResultSetHandler<T> rsh, final Object... params)"}, {"syntax_pass": true, "original_string": "    public <T> T insert(final String sql, final ResultSetHandler<T> rsh) throws SQLException {\n        try (Connection conn = prepareConnection()) {\n            return insert(conn, sql, rsh, (Object[]) null);\n        }\n    }", "docstring": "\nExecutes the given INSERT SQL without any replacement parameters.\nThe {@code Connection} is retrieved from the\n{@code DataSource} set in the constructor.\n@param <T> The type of object that the handler returns\n@param sql The SQL statement to execute.\n@param rsh The handler used to create the result object from\nthe {@code ResultSet} of auto-generated keys.\n@return An object generated by the handler.\n@throws SQLException if a database access error occurs\n@since 1.6\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "T", "classes": []}, "name": "insert", "params": [{"name": "sql", "type": "String"}, {"name": "rsh", "type": "ResultSetHandler<T>"}], "body": "                                                                                             {\n        try (Connection conn = prepareConnection()) {\n            return insert(conn, sql, rsh, (Object[]) null);\n        }\n    }", "signature": "public <T> T insert(final String sql, final ResultSetHandler<T> rsh)"}, {"syntax_pass": true, "original_string": "    public <T> T insert(final String sql, final ResultSetHandler<T> rsh, final Object... params) throws SQLException {\n        try (Connection conn = prepareConnection()) {\n            return insert(conn, sql, rsh, params);\n        }\n    }", "docstring": "\nExecutes the given INSERT SQL statement. The\n{@code Connection} is retrieved from the {@code DataSource}\nset in the constructor.  This {@code Connection} must be in\nauto-commit mode or the insert will not be saved.\n@param <T> The type of object that the handler returns\n@param sql The SQL statement to execute.\n@param rsh The handler used to create the result object from\nthe {@code ResultSet} of auto-generated keys.\n@param params Initializes the PreparedStatement's IN (i.e. '?')\n@return An object generated by the handler.\n@throws SQLException if a database access error occurs\n@since 1.6\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "T", "classes": []}, "name": "insert", "params": [{"name": "sql", "type": "String"}, {"name": "rsh", "type": "ResultSetHandler<T>"}], "body": "                                                                                                                     {\n        try (Connection conn = prepareConnection()) {\n            return insert(conn, sql, rsh, params);\n        }\n    }", "signature": "public <T> T insert(final String sql, final ResultSetHandler<T> rsh, final Object... params)"}, {"syntax_pass": true, "original_string": "    public <T> T insertBatch(final Connection conn, final String sql, final ResultSetHandler<T> rsh, final Object[][] params) throws SQLException {\n        if (conn == null) {\n            throw new SQLException(\"Null connection\");\n        }\n\n        if (sql == null) {\n            throw new SQLException(\"Null SQL statement\");\n        }\n\n        if (params == null) {\n            throw new SQLException(\"Null parameters. If parameters aren't need, pass an empty array.\");\n        }\n\n        PreparedStatement stmt = null;\n        T generatedKeys = null;\n        try {\n            stmt = this.prepareStatement(conn, sql, Statement.RETURN_GENERATED_KEYS);\n\n            for (final Object[] param : params) {\n                this.fillStatement(stmt, param);\n                stmt.addBatch();\n            }\n            stmt.executeBatch();\n            try (ResultSet resultSet = stmt.getGeneratedKeys()) {\n                generatedKeys = rsh.handle(resultSet);\n            }\n        } catch (final SQLException e) {\n            rethrow(e, sql, (Object[])params);\n        } finally {\n            close(stmt);\n        }\n\n        return generatedKeys;\n    }", "docstring": "\nExecutes the given batch of INSERT SQL statements.\n@param <T> The type of object that the handler returns\n@param conn The connection to use to run the query.\n@param sql The SQL to execute.\n@param rsh The handler used to create the result object from\nthe {@code ResultSet} of auto-generated keys.\n@param params The query replacement parameters.\n@return The result generated by the handler.\n@throws SQLException if a database access error occurs\n@since 1.6\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "T", "classes": []}, "name": "insertBatch", "params": [{"name": "conn", "type": "Connection"}, {"name": "sql", "type": "String"}, {"name": "rsh", "type": "ResultSetHandler<T>"}, {"name": "params", "type": "Object[][]"}], "body": "                                                                                                                                                  {\n        if (conn == null) {\n            throw new SQLException(\"Null connection\");\n        }\n\n        if (sql == null) {\n            throw new SQLException(\"Null SQL statement\");\n        }\n\n        if (params == null) {\n            throw new SQLException(\"Null parameters. If parameters aren't need, pass an empty array.\");\n        }\n\n        PreparedStatement stmt = null;\n        T generatedKeys = null;\n        try {\n            stmt = this.prepareStatement(conn, sql, Statement.RETURN_GENERATED_KEYS);\n\n            for (final Object[] param : params) {\n                this.fillStatement(stmt, param);\n                stmt.addBatch();\n            }\n            stmt.executeBatch();\n            try (ResultSet resultSet = stmt.getGeneratedKeys()) {\n                generatedKeys = rsh.handle(resultSet);\n            }\n        } catch (final SQLException e) {\n            rethrow(e, sql, (Object[])params);\n        } finally {\n            close(stmt);\n        }\n\n        return generatedKeys;\n    }", "signature": "public <T> T insertBatch(final Connection conn, final String sql, final ResultSetHandler<T> rsh, final Object[][] params)"}, {"syntax_pass": true, "original_string": "    public <T> T insertBatch(final String sql, final ResultSetHandler<T> rsh, final Object[][] params) throws SQLException {\n        try (Connection conn = prepareConnection()) {\n            return insertBatch(conn, sql, rsh, params);\n        }\n    }", "docstring": "\nExecutes the given batch of INSERT SQL statements. The\n{@code Connection} is retrieved from the {@code DataSource}\nset in the constructor.  This {@code Connection} must be in\nauto-commit mode or the insert will not be saved.\n@param <T> The type of object that the handler returns\n@param sql The SQL statement to execute.\n@param rsh The handler used to create the result object from\nthe {@code ResultSet} of auto-generated keys.\n@param params Initializes the PreparedStatement's IN (i.e. '?')\n@return The result generated by the handler.\n@throws SQLException if a database access error occurs\n@since 1.6\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "T", "classes": []}, "name": "insertBatch", "params": [{"name": "sql", "type": "String"}, {"name": "rsh", "type": "ResultSetHandler<T>"}, {"name": "params", "type": "Object[][]"}], "body": "                                                                                                                           {\n        try (Connection conn = prepareConnection()) {\n            return insertBatch(conn, sql, rsh, params);\n        }\n    }", "signature": "public <T> T insertBatch(final String sql, final ResultSetHandler<T> rsh, final Object[][] params)"}, {"syntax_pass": true, "original_string": "    @Deprecated\n    public <T> T query(final Connection conn, final String sql, final Object param, final ResultSetHandler<T> rsh) throws SQLException {\n        return this.<T>query(conn, sql, rsh, param);\n    }", "docstring": "\nExecute an SQL SELECT query with a single replacement parameter. The\ncaller is responsible for closing the connection.\n@param <T> The type of object that the handler returns\n@param conn The connection to execute the query in.\n@param sql The query to execute.\n@param param The replacement parameter.\n@param rsh The handler that converts the results into an object.\n@return The object returned by the handler.\n@throws SQLException if a database access error occurs\n@deprecated Use {@link #query(Connection, String, ResultSetHandler, Object...)}\n", "attributes": {"modifiers": "@Deprecated\n    public", "marker_annotations": ["@Deprecated"], "non_marker_annotations": ["public"], "comments": [], "return_type": "T", "classes": []}, "name": "query", "params": [{"name": "conn", "type": "Connection"}, {"name": "sql", "type": "String"}, {"name": "param", "type": "Object"}, {"name": "rsh", "type": "ResultSetHandler<T>"}], "body": "                                                                                                                                       {\n        return this.<T>query(conn, sql, rsh, param);\n    }", "signature": "@Deprecated\n    public <T> T query(final Connection conn, final String sql, final Object param, final ResultSetHandler<T> rsh)"}, {"syntax_pass": true, "original_string": "    @Deprecated\n    public <T> T query(final Connection conn, final String sql, final Object[] params, final ResultSetHandler<T> rsh) throws SQLException {\n        return this.<T>query(conn, sql, rsh, params);\n    }", "docstring": "\nExecute an SQL SELECT query with replacement parameters.  The\ncaller is responsible for closing the connection.\n@param <T> The type of object that the handler returns\n@param conn The connection to execute the query in.\n@param sql The query to execute.\n@param params The replacement parameters.\n@param rsh The handler that converts the results into an object.\n@return The object returned by the handler.\n@throws SQLException if a database access error occurs\n@deprecated Use {@link #query(Connection,String,ResultSetHandler,Object...)} instead\n", "attributes": {"modifiers": "@Deprecated\n    public", "marker_annotations": ["@Deprecated"], "non_marker_annotations": ["public"], "comments": [], "return_type": "T", "classes": []}, "name": "query", "params": [{"name": "conn", "type": "Connection"}, {"name": "sql", "type": "String"}, {"name": "params", "type": "Object[]"}, {"name": "rsh", "type": "ResultSetHandler<T>"}], "body": "                                                                                                                                          {\n        return this.<T>query(conn, sql, rsh, params);\n    }", "signature": "@Deprecated\n    public <T> T query(final Connection conn, final String sql, final Object[] params, final ResultSetHandler<T> rsh)"}, {"syntax_pass": true, "original_string": "    public <T> T query(final Connection conn, final String sql, final ResultSetHandler<T> rsh) throws SQLException {\n        return this.<T>query(conn, sql, rsh, (Object[]) null);\n    }", "docstring": "\nExecute an SQL SELECT query without any replacement parameters.  The\ncaller is responsible for closing the connection.\n@param <T> The type of object that the handler returns\n@param conn The connection to execute the query in.\n@param sql The query to execute.\n@param rsh The handler that converts the results into an object.\n@return The object returned by the handler.\n@throws SQLException if a database access error occurs\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "T", "classes": []}, "name": "query", "params": [{"name": "conn", "type": "Connection"}, {"name": "sql", "type": "String"}, {"name": "rsh", "type": "ResultSetHandler<T>"}], "body": "                                                                                                                   {\n        return this.<T>query(conn, sql, rsh, (Object[]) null);\n    }", "signature": "public <T> T query(final Connection conn, final String sql, final ResultSetHandler<T> rsh)"}, {"syntax_pass": true, "original_string": "    public <T> T query(final Connection conn, final String sql, final ResultSetHandler<T> rsh, final Object... params) throws SQLException {\n        if (conn == null) {\n            throw new SQLException(\"Null connection\");\n        }\n\n        if (sql == null) {\n            throw new SQLException(\"Null SQL statement\");\n        }\n\n        if (rsh == null) {\n            throw new SQLException(\"Null ResultSetHandler\");\n        }\n\n        Statement stmt = null;\n        ResultSet resultSet = null;\n        T result = null;\n\n        try {\n            if (params != null && params.length > 0) {\n                final PreparedStatement ps = this.prepareStatement(conn, sql);\n                stmt = ps;\n                this.fillStatement(ps, params);\n                resultSet = wrap(ps.executeQuery());\n            } else {\n                stmt = conn.createStatement();\n                resultSet = wrap(stmt.executeQuery(sql));\n            }\n            result = rsh.handle(resultSet);\n\n        } catch (final SQLException e) {\n            rethrow(e, sql, params);\n\n        } finally {\n            closeQuietly(resultSet);\n            closeQuietly(stmt);\n        }\n\n        return result;\n    }", "docstring": "\nExecute an SQL SELECT query with replacement parameters.  The\ncaller is responsible for closing the connection.\n@param <T> The type of object that the handler returns\n@param conn The connection to execute the query in.\n@param sql The query to execute.\n@param rsh The handler that converts the results into an object.\n@param params The replacement parameters.\n@return The object returned by the handler.\n@throws SQLException if a database access error occurs\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "T", "classes": []}, "name": "query", "params": [{"name": "conn", "type": "Connection"}, {"name": "sql", "type": "String"}, {"name": "rsh", "type": "ResultSetHandler<T>"}], "body": "                                                                                                                                           {\n        if (conn == null) {\n            throw new SQLException(\"Null connection\");\n        }\n\n        if (sql == null) {\n            throw new SQLException(\"Null SQL statement\");\n        }\n\n        if (rsh == null) {\n            throw new SQLException(\"Null ResultSetHandler\");\n        }\n\n        Statement stmt = null;\n        ResultSet resultSet = null;\n        T result = null;\n\n        try {\n            if (params != null && params.length > 0) {\n                final PreparedStatement ps = this.prepareStatement(conn, sql);\n                stmt = ps;\n                this.fillStatement(ps, params);\n                resultSet = wrap(ps.executeQuery());\n            } else {\n                stmt = conn.createStatement();\n                resultSet = wrap(stmt.executeQuery(sql));\n            }\n            result = rsh.handle(resultSet);\n\n        } catch (final SQLException e) {\n            rethrow(e, sql, params);\n\n        } finally {\n            closeQuietly(resultSet);\n            closeQuietly(stmt);\n        }\n\n        return result;\n    }", "signature": "public <T> T query(final Connection conn, final String sql, final ResultSetHandler<T> rsh, final Object... params)"}, {"syntax_pass": true, "original_string": "    @Deprecated\n    public <T> T query(final String sql, final Object param, final ResultSetHandler<T> rsh) throws SQLException {\n        try (Connection conn = prepareConnection()) {\n            return this.<T>query(conn, sql, rsh, param);\n        }\n    }", "docstring": "\nExecutes the given SELECT SQL with a single replacement parameter.\nThe {@code Connection} is retrieved from the\n{@code DataSource} set in the constructor.\n@param <T> The type of object that the handler returns\n@param sql The SQL statement to execute.\n@param param The replacement parameter.\n@param rsh The handler used to create the result object from\nthe {@code ResultSet}.\n\n@return An object generated by the handler.\n@throws SQLException if a database access error occurs\n@deprecated Use {@link #query(String, ResultSetHandler, Object...)}\n", "attributes": {"modifiers": "@Deprecated\n    public", "marker_annotations": ["@Deprecated"], "non_marker_annotations": ["public"], "comments": [], "return_type": "T", "classes": []}, "name": "query", "params": [{"name": "sql", "type": "String"}, {"name": "param", "type": "Object"}, {"name": "rsh", "type": "ResultSetHandler<T>"}], "body": "                                                                                                                {\n        try (Connection conn = prepareConnection()) {\n            return this.<T>query(conn, sql, rsh, param);\n        }\n    }", "signature": "@Deprecated\n    public <T> T query(final String sql, final Object param, final ResultSetHandler<T> rsh)"}, {"syntax_pass": true, "original_string": "    @Deprecated\n    public <T> T query(final String sql, final Object[] params, final ResultSetHandler<T> rsh) throws SQLException {\n        try (Connection conn = prepareConnection()) {\n            return this.<T>query(conn, sql, rsh, params);\n        }\n    }", "docstring": "\nExecutes the given SELECT SQL query and returns a result object.\nThe {@code Connection} is retrieved from the\n{@code DataSource} set in the constructor.\n@param <T> The type of object that the handler returns\n@param sql The SQL statement to execute.\n@param params Initialize the PreparedStatement's IN parameters with\nthis array.\n\n@param rsh The handler used to create the result object from\nthe {@code ResultSet}.\n\n@return An object generated by the handler.\n@throws SQLException if a database access error occurs\n@deprecated Use {@link #query(String, ResultSetHandler, Object...)}\n", "attributes": {"modifiers": "@Deprecated\n    public", "marker_annotations": ["@Deprecated"], "non_marker_annotations": ["public"], "comments": [], "return_type": "T", "classes": []}, "name": "query", "params": [{"name": "sql", "type": "String"}, {"name": "params", "type": "Object[]"}, {"name": "rsh", "type": "ResultSetHandler<T>"}], "body": "                                                                                                                   {\n        try (Connection conn = prepareConnection()) {\n            return this.<T>query(conn, sql, rsh, params);\n        }\n    }", "signature": "@Deprecated\n    public <T> T query(final String sql, final Object[] params, final ResultSetHandler<T> rsh)"}, {"syntax_pass": true, "original_string": "    public <T> T query(final String sql, final ResultSetHandler<T> rsh) throws SQLException {\n        try (Connection conn = prepareConnection()) {\n            return this.<T>query(conn, sql, rsh, (Object[]) null);\n        }\n    }", "docstring": "\nExecutes the given SELECT SQL without any replacement parameters.\nThe {@code Connection} is retrieved from the\n{@code DataSource} set in the constructor.\n@param <T> The type of object that the handler returns\n@param sql The SQL statement to execute.\n@param rsh The handler used to create the result object from\nthe {@code ResultSet}.\n\n@return An object generated by the handler.\n@throws SQLException if a database access error occurs\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "T", "classes": []}, "name": "query", "params": [{"name": "sql", "type": "String"}, {"name": "rsh", "type": "ResultSetHandler<T>"}], "body": "                                                                                            {\n        try (Connection conn = prepareConnection()) {\n            return this.<T>query(conn, sql, rsh, (Object[]) null);\n        }\n    }", "signature": "public <T> T query(final String sql, final ResultSetHandler<T> rsh)"}, {"syntax_pass": true, "original_string": "    public <T> T query(final String sql, final ResultSetHandler<T> rsh, final Object... params) throws SQLException {\n        try (Connection conn = prepareConnection()) {\n            return this.<T>query(conn, sql, rsh, params);\n        }\n    }", "docstring": "\nExecutes the given SELECT SQL query and returns a result object.\nThe {@code Connection} is retrieved from the\n{@code DataSource} set in the constructor.\n@param <T> The type of object that the handler returns\n@param sql The SQL statement to execute.\n@param rsh The handler used to create the result object from\nthe {@code ResultSet}.\n@param params Initialize the PreparedStatement's IN parameters with\nthis array.\n@return An object generated by the handler.\n@throws SQLException if a database access error occurs\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "T", "classes": []}, "name": "query", "params": [{"name": "sql", "type": "String"}, {"name": "rsh", "type": "ResultSetHandler<T>"}], "body": "                                                                                                                    {\n        try (Connection conn = prepareConnection()) {\n            return this.<T>query(conn, sql, rsh, params);\n        }\n    }", "signature": "public <T> T query(final String sql, final ResultSetHandler<T> rsh, final Object... params)"}, {"syntax_pass": true, "original_string": "    private void retrieveOutParameters(final CallableStatement stmt, final Object[] params) throws SQLException {\n        if (params != null) {\n            for (int i = 0; i < params.length; i++) {\n                if (params[i] instanceof OutParameter) {\n                    ((OutParameter<?>) params[i]).setValue(stmt, i + 1);\n                }\n            }\n        }\n    }", "docstring": "\nSet the value on all the {@link OutParameter} instances in the\n{@code params} array using the OUT parameter values from the\n{@code stmt}.\n@param stmt the statement from which to retrieve OUT parameter values\n@param params the parameter array for the statement invocation\n@throws SQLException when the value could not be retrieved from the\nstatement.\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "retrieveOutParameters", "params": [{"name": "stmt", "type": "CallableStatement"}, {"name": "params", "type": "Object[]"}], "body": "                                                                                                                {\n        if (params != null) {\n            for (int i = 0; i < params.length; i++) {\n                if (params[i] instanceof OutParameter) {\n                    ((OutParameter<?>) params[i]).setValue(stmt, i + 1);\n                }\n            }\n        }\n    }", "signature": "private void retrieveOutParameters(final CallableStatement stmt, final Object[] params)"}, {"syntax_pass": true, "original_string": "    public int update(final Connection conn, final String sql) throws SQLException {\n        return this.update(conn, sql, (Object[]) null);\n    }", "docstring": "\nExecute an SQL INSERT, UPDATE, or DELETE query without replacement\nparameters.\n\n@param conn The connection to use to run the query.\n@param sql The SQL to execute.\n@return The number of rows updated.\n@throws SQLException if a database access error occurs\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "update", "params": [{"name": "conn", "type": "Connection"}, {"name": "sql", "type": "String"}], "body": "                                                                                   {\n        return this.update(conn, sql, (Object[]) null);\n    }", "signature": "public int update(final Connection conn, final String sql)"}, {"syntax_pass": true, "original_string": "    public int update(final Connection conn, final String sql, final Object param) throws SQLException {\n        return this.update(conn, sql, new Object[] { param });\n    }", "docstring": "\nExecute an SQL INSERT, UPDATE, or DELETE query with a single replacement\nparameter.\n\n@param conn The connection to use to run the query.\n@param sql The SQL to execute.\n@param param The replacement parameter.\n@return The number of rows updated.\n@throws SQLException if a database access error occurs\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "update", "params": [{"name": "conn", "type": "Connection"}, {"name": "sql", "type": "String"}, {"name": "param", "type": "Object"}], "body": "                                                                                                       {\n        return this.update(conn, sql, new Object[] { param });\n    }", "signature": "public int update(final Connection conn, final String sql, final Object param)"}, {"syntax_pass": true, "original_string": "    public int update(final Connection conn, final String sql, final Object... params) throws SQLException {\n        if (conn == null) {\n            throw new SQLException(\"Null connection\");\n        }\n\n        if (sql == null) {\n            throw new SQLException(\"Null SQL statement\");\n        }\n\n        Statement stmt = null;\n        int rows = 0;\n\n        try {\n            if (params != null && params.length > 0) {\n                final PreparedStatement ps = this.prepareStatement(conn, sql);\n                stmt = ps;\n                this.fillStatement(ps, params);\n                rows = ps.executeUpdate();\n            } else {\n                stmt = conn.createStatement();\n                rows = stmt.executeUpdate(sql);\n            }\n\n        } catch (final SQLException e) {\n            rethrow(e, sql, params);\n\n        } finally {\n            close(stmt);\n        }\n\n        return rows;\n    }", "docstring": "\nExecute an SQL INSERT, UPDATE, or DELETE query.\n\n@param conn The connection to use to run the query.\n@param sql The SQL to execute.\n@param params The query replacement parameters.\n@return The number of rows updated.\n@throws SQLException if a database access error occurs\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "update", "params": [{"name": "conn", "type": "Connection"}, {"name": "sql", "type": "String"}], "body": "                                                                                                           {\n        if (conn == null) {\n            throw new SQLException(\"Null connection\");\n        }\n\n        if (sql == null) {\n            throw new SQLException(\"Null SQL statement\");\n        }\n\n        Statement stmt = null;\n        int rows = 0;\n\n        try {\n            if (params != null && params.length > 0) {\n                final PreparedStatement ps = this.prepareStatement(conn, sql);\n                stmt = ps;\n                this.fillStatement(ps, params);\n                rows = ps.executeUpdate();\n            } else {\n                stmt = conn.createStatement();\n                rows = stmt.executeUpdate(sql);\n            }\n\n        } catch (final SQLException e) {\n            rethrow(e, sql, params);\n\n        } finally {\n            close(stmt);\n        }\n\n        return rows;\n    }", "signature": "public int update(final Connection conn, final String sql, final Object... params)"}, {"syntax_pass": true, "original_string": "    public int update(final String sql) throws SQLException {\n        try (Connection conn = prepareConnection()) {\n            return this.update(conn, sql, (Object[]) null);\n        }\n    }", "docstring": "\nExecutes the given INSERT, UPDATE, or DELETE SQL statement without\nany replacement parameters. The {@code Connection} is retrieved\nfrom the {@code DataSource} set in the constructor.  This\n{@code Connection} must be in auto-commit mode or the update will\nnot be saved.\n\n@param sql The SQL statement to execute.\n@throws SQLException if a database access error occurs\n@return The number of rows updated.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "update", "params": [{"name": "sql", "type": "String"}], "body": "                                                            {\n        try (Connection conn = prepareConnection()) {\n            return this.update(conn, sql, (Object[]) null);\n        }\n    }", "signature": "public int update(final String sql)"}, {"syntax_pass": true, "original_string": "    public int update(final String sql, final Object param) throws SQLException {\n        try (Connection conn = prepareConnection()) {\n            return this.update(conn, sql, param);\n        }\n    }", "docstring": "\nExecutes the given INSERT, UPDATE, or DELETE SQL statement with\na single replacement parameter.  The {@code Connection} is\nretrieved from the {@code DataSource} set in the constructor.\nThis {@code Connection} must be in auto-commit mode or the\nupdate will not be saved.\n\n@param sql The SQL statement to execute.\n@param param The replacement parameter.\n@throws SQLException if a database access error occurs\n@return The number of rows updated.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "update", "params": [{"name": "sql", "type": "String"}, {"name": "param", "type": "Object"}], "body": "                                                                                {\n        try (Connection conn = prepareConnection()) {\n            return this.update(conn, sql, param);\n        }\n    }", "signature": "public int update(final String sql, final Object param)"}, {"syntax_pass": true, "original_string": "    public int update(final String sql, final Object... params) throws SQLException {\n        try (Connection conn = prepareConnection()) {\n            return this.update(conn, sql, params);\n        }\n    }", "docstring": "\nExecutes the given INSERT, UPDATE, or DELETE SQL statement.  The\n{@code Connection} is retrieved from the {@code DataSource}\nset in the constructor.  This {@code Connection} must be in\nauto-commit mode or the update will not be saved.\n\n@param sql The SQL statement to execute.\n@param params Initializes the PreparedStatement's IN (i.e. '?')\nparameters.\n@throws SQLException if a database access error occurs\n@return The number of rows updated.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "update", "params": [{"name": "sql", "type": "String"}], "body": "                                                                                    {\n        try (Connection conn = prepareConnection()) {\n            return this.update(conn, sql, params);\n        }\n    }", "signature": "public int update(final String sql, final Object... params)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/apache/commons/dbutils/PropertyHandler.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils;\n\n/**\n * Defines how to handle properties when constructing a bean from a {@link java.sql.ResultSet}. Instances coerce values into a target types.\n */\npublic interface PropertyHandler {\n\n    /**\n     * Stores the given {@code value} into an instance of type {@code parameter}. This method is only called if {@link #match(Class, Object)} return true.\n     *\n     * @param parameter The type of the target parameter.\n     * @param value     The value to set.\n     * @return The converted value or the original value if something doesn't work out.\n     */\n    Object apply(Class<?> parameter, Object value);\n\n    /**\n     * Tests whether to handle setting {@code value} into an instance of {@code parameter}.\n     *\n     * @param parameter The type of the target parameter.\n     * @param value     The value to be set.\n     * @return true is this property handler can/wants to handle this value; false otherwise.\n     */\n    boolean match(Class<?> parameter, Object value);\n}\n", "file_hash": "bf9f485f3a55b8c209396aa6f3526f5c99e367c63c34fcfa80bb4c6435df83e6", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils;"], "methods": [], "classes": [], "interfaces": [{"original_string": "public interface PropertyHandler {\n\n    /**\n     * Stores the given {@code value} into an instance of type {@code parameter}. This method is only called if {@link #match(Class, Object)} return true.\n     *\n     * @param parameter The type of the target parameter.\n     * @param value     The value to set.\n     * @return The converted value or the original value if something doesn't work out.\n     */\n    Object apply(Class<?> parameter, Object value);\n\n    /**\n     * Tests whether to handle setting {@code value} into an instance of {@code parameter}.\n     *\n     * @param parameter The type of the target parameter.\n     * @param value     The value to be set.\n     * @return true is this property handler can/wants to handle this value; false otherwise.\n     */\n    boolean match(Class<?> parameter, Object value);\n}", "definition": "public interface PropertyHandler", "interface_docstring": "\nDefines how to handle properties when constructing a bean from a {@link java.sql.ResultSet}. Instances coerce values into a target types.\n", "name": "PropertyHandler", "extends_interfaces": [], "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Object apply(Class<?> parameter, Object value);", "docstring": "\nStores the given {@code value} into an instance of type {@code parameter}. This method is only called if {@link #match(Class, Object)} return true.\n\n@param parameter The type of the target parameter.\n@param value     The value to set.\n@return The converted value or the original value if something doesn't work out.\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Object", "classes": []}, "name": "apply", "params": [{"name": "parameter", "type": "Class<?>"}, {"name": "value", "type": "Object"}], "body": "", "signature": "Object apply(Class<?> parameter, Object value)"}, {"syntax_pass": true, "original_string": "    boolean match(Class<?> parameter, Object value);", "docstring": "\nTests whether to handle setting {@code value} into an instance of {@code parameter}.\n\n@param parameter The type of the target parameter.\n@param value     The value to be set.\n@return true is this property handler can/wants to handle this value; false otherwise.\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "boolean", "classes": []}, "name": "match", "params": [{"name": "parameter", "type": "Class<?>"}, {"name": "value", "type": "Object"}], "body": "", "signature": "boolean match(Class<?> parameter, Object value)"}]}], "records": []}, {"relative_path": "src/main/java/org/apache/commons/dbutils/BaseResultSetHandler.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils;\n\nimport java.io.InputStream;\nimport java.io.Reader;\nimport java.math.BigDecimal;\nimport java.net.URL;\nimport java.sql.Array;\nimport java.sql.Blob;\nimport java.sql.Clob;\nimport java.sql.Date;\nimport java.sql.NClob;\nimport java.sql.Ref;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.RowId;\nimport java.sql.SQLException;\nimport java.sql.SQLWarning;\nimport java.sql.SQLXML;\nimport java.sql.Statement;\nimport java.sql.Time;\nimport java.sql.Timestamp;\nimport java.util.Calendar;\nimport java.util.Map;\n\n/**\n * Extensions of this class convert ResultSets into other objects.\n * <p>\n * According to the <em>DRY</em> principle (Don't Repeat Yourself), repeating {@code resultSet} variable inside the {@link ResultSetHandler#handle(ResultSet)}\n * over and over for each iteration can get a little tedious, {@code AbstractResultSetHandler} implicitly gives users access to {@code ResultSet}'s methods.\n * </p>\n * <p>\n * <b>NOTE</b> This class is <em>NOT</em> thread safe!\n * </p>\n *\n * @param <T> the target type the input ResultSet will be converted to.\n * @since 1.6\n */\npublic abstract class BaseResultSetHandler<T> implements ResultSetHandler<T> {\n\n    /**\n     * The adapted ResultSet.\n     */\n    private ResultSet resultSet;\n\n    /**\n     * TODO. A\n     */\n    protected final boolean absolute(final int row) throws SQLException {\n        return resultSet.absolute(row);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void afterLast() throws SQLException {\n        resultSet.afterLast();\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void beforeFirst() throws SQLException {\n        resultSet.beforeFirst();\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void cancelRowUpdates() throws SQLException {\n        resultSet.cancelRowUpdates();\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void clearWarnings() throws SQLException {\n        resultSet.clearWarnings();\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void close() throws SQLException {\n        resultSet.close();\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void deleteRow() throws SQLException {\n        resultSet.deleteRow();\n    }\n\n    /**\n     * TODO.\n     */\n    protected final int findColumn(final String columnLabel) throws SQLException {\n        return resultSet.findColumn(columnLabel);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final boolean first() throws SQLException {\n        return resultSet.first();\n    }\n\n    protected final ResultSet getAdaptedResultSet() {\n        return resultSet;\n    }\n\n    /**\n     * TODO.\n     */\n    protected final Array getArray(final int columnIndex) throws SQLException {\n        return resultSet.getArray(columnIndex);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final Array getArray(final String columnLabel) throws SQLException {\n        return resultSet.getArray(columnLabel);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final InputStream getAsciiStream(final int columnIndex) throws SQLException {\n        return resultSet.getAsciiStream(columnIndex);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final InputStream getAsciiStream(final String columnLabel) throws SQLException {\n        return resultSet.getAsciiStream(columnLabel);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final BigDecimal getBigDecimal(final int columnIndex) throws SQLException {\n        return resultSet.getBigDecimal(columnIndex);\n    }\n\n    /**\n     * TODO.\n     */\n    @Deprecated\n    protected final BigDecimal getBigDecimal(final int columnIndex, final int scale) throws SQLException {\n        return resultSet.getBigDecimal(columnIndex, scale);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final BigDecimal getBigDecimal(final String columnLabel) throws SQLException {\n        return resultSet.getBigDecimal(columnLabel);\n    }\n\n    /**\n     * TODO.\n     */\n    @Deprecated\n    protected final BigDecimal getBigDecimal(final String columnLabel, final int scale) throws SQLException {\n        return resultSet.getBigDecimal(columnLabel, scale);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final InputStream getBinaryStream(final int columnIndex) throws SQLException {\n        return resultSet.getBinaryStream(columnIndex);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final InputStream getBinaryStream(final String columnLabel) throws SQLException {\n        return resultSet.getBinaryStream(columnLabel);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final Blob getBlob(final int columnIndex) throws SQLException {\n        return resultSet.getBlob(columnIndex);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final Blob getBlob(final String columnLabel) throws SQLException {\n        return resultSet.getBlob(columnLabel);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final boolean getBoolean(final int columnIndex) throws SQLException {\n        return resultSet.getBoolean(columnIndex);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final boolean getBoolean(final String columnLabel) throws SQLException {\n        return resultSet.getBoolean(columnLabel);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final byte getByte(final int columnIndex) throws SQLException {\n        return resultSet.getByte(columnIndex);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final byte getByte(final String columnLabel) throws SQLException {\n        return resultSet.getByte(columnLabel);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final byte[] getBytes(final int columnIndex) throws SQLException {\n        return resultSet.getBytes(columnIndex);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final byte[] getBytes(final String columnLabel) throws SQLException {\n        return resultSet.getBytes(columnLabel);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final Reader getCharacterStream(final int columnIndex) throws SQLException {\n        return resultSet.getCharacterStream(columnIndex);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final Reader getCharacterStream(final String columnLabel) throws SQLException {\n        return resultSet.getCharacterStream(columnLabel);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final Clob getClob(final int columnIndex) throws SQLException {\n        return resultSet.getClob(columnIndex);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final Clob getClob(final String columnLabel) throws SQLException {\n        return resultSet.getClob(columnLabel);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final int getConcurrency() throws SQLException {\n        return resultSet.getConcurrency();\n    }\n\n    /**\n     * TODO.\n     */\n    protected final String getCursorName() throws SQLException {\n        return resultSet.getCursorName();\n    }\n\n    /**\n     * TODO.\n     */\n    protected final Date getDate(final int columnIndex) throws SQLException {\n        return resultSet.getDate(columnIndex);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final Date getDate(final int columnIndex, final Calendar cal) throws SQLException {\n        return resultSet.getDate(columnIndex, cal);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final Date getDate(final String columnLabel) throws SQLException {\n        return resultSet.getDate(columnLabel);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final Date getDate(final String columnLabel, final Calendar cal) throws SQLException {\n        return resultSet.getDate(columnLabel, cal);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final double getDouble(final int columnIndex) throws SQLException {\n        return resultSet.getDouble(columnIndex);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final double getDouble(final String columnLabel) throws SQLException {\n        return resultSet.getDouble(columnLabel);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final int getFetchDirection() throws SQLException {\n        return resultSet.getFetchDirection();\n    }\n\n    /**\n     * TODO.\n     */\n    protected final int getFetchSize() throws SQLException {\n        return resultSet.getFetchSize();\n    }\n\n    /**\n     * TODO.\n     */\n    protected final float getFloat(final int columnIndex) throws SQLException {\n        return resultSet.getFloat(columnIndex);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final float getFloat(final String columnLabel) throws SQLException {\n        return resultSet.getFloat(columnLabel);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final int getHoldability() throws SQLException {\n        return resultSet.getHoldability();\n    }\n\n    /**\n     * TODO.\n     */\n    protected final int getInt(final int columnIndex) throws SQLException {\n        return resultSet.getInt(columnIndex);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final int getInt(final String columnLabel) throws SQLException {\n        return resultSet.getInt(columnLabel);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final long getLong(final int columnIndex) throws SQLException {\n        return resultSet.getLong(columnIndex);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final long getLong(final String columnLabel) throws SQLException {\n        return resultSet.getLong(columnLabel);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final ResultSetMetaData getMetaData() throws SQLException {\n        return resultSet.getMetaData();\n    }\n\n    /**\n     * TODO.\n     */\n    protected final Reader getNCharacterStream(final int columnIndex) throws SQLException {\n        return resultSet.getNCharacterStream(columnIndex);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final Reader getNCharacterStream(final String columnLabel) throws SQLException {\n        return resultSet.getNCharacterStream(columnLabel);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final NClob getNClob(final int columnIndex) throws SQLException {\n        return resultSet.getNClob(columnIndex);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final NClob getNClob(final String columnLabel) throws SQLException {\n        return resultSet.getNClob(columnLabel);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final String getNString(final int columnIndex) throws SQLException {\n        return resultSet.getNString(columnIndex);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final String getNString(final String columnLabel) throws SQLException {\n        return resultSet.getNString(columnLabel);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final Object getObject(final int columnIndex) throws SQLException {\n        return resultSet.getObject(columnIndex);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final Object getObject(final int columnIndex, final Map<String, Class<?>> map) throws SQLException {\n        return resultSet.getObject(columnIndex, map);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final Object getObject(final String columnLabel) throws SQLException {\n        return resultSet.getObject(columnLabel);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final Object getObject(final String columnLabel, final Map<String, Class<?>> map) throws SQLException {\n        return resultSet.getObject(columnLabel, map);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final Ref getRef(final int columnIndex) throws SQLException {\n        return resultSet.getRef(columnIndex);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final Ref getRef(final String columnLabel) throws SQLException {\n        return resultSet.getRef(columnLabel);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final int getRow() throws SQLException {\n        return resultSet.getRow();\n    }\n\n    /**\n     * TODO.\n     */\n    protected final RowId getRowId(final int columnIndex) throws SQLException {\n        return resultSet.getRowId(columnIndex);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final RowId getRowId(final String columnLabel) throws SQLException {\n        return resultSet.getRowId(columnLabel);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final short getShort(final int columnIndex) throws SQLException {\n        return resultSet.getShort(columnIndex);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final short getShort(final String columnLabel) throws SQLException {\n        return resultSet.getShort(columnLabel);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final SQLXML getSQLXML(final int columnIndex) throws SQLException {\n        return resultSet.getSQLXML(columnIndex);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final SQLXML getSQLXML(final String columnLabel) throws SQLException {\n        return resultSet.getSQLXML(columnLabel);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final Statement getStatement() throws SQLException {\n        return resultSet.getStatement();\n    }\n\n    /**\n     * TODO.\n     */\n    protected final String getString(final int columnIndex) throws SQLException {\n        return resultSet.getString(columnIndex);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final String getString(final String columnLabel) throws SQLException {\n        return resultSet.getString(columnLabel);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final Time getTime(final int columnIndex) throws SQLException {\n        return resultSet.getTime(columnIndex);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final Time getTime(final int columnIndex, final Calendar cal) throws SQLException {\n        return resultSet.getTime(columnIndex, cal);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final Time getTime(final String columnLabel) throws SQLException {\n        return resultSet.getTime(columnLabel);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final Time getTime(final String columnLabel, final Calendar cal) throws SQLException {\n        return resultSet.getTime(columnLabel, cal);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final Timestamp getTimestamp(final int columnIndex) throws SQLException {\n        return resultSet.getTimestamp(columnIndex);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final Timestamp getTimestamp(final int columnIndex, final Calendar cal) throws SQLException {\n        return resultSet.getTimestamp(columnIndex, cal);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final Timestamp getTimestamp(final String columnLabel) throws SQLException {\n        return resultSet.getTimestamp(columnLabel);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final Timestamp getTimestamp(final String columnLabel, final Calendar cal) throws SQLException {\n        return resultSet.getTimestamp(columnLabel, cal);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final int getType() throws SQLException {\n        return resultSet.getType();\n    }\n\n    /**\n     * TODO.\n     */\n    @Deprecated\n    protected final InputStream getUnicodeStream(final int columnIndex) throws SQLException {\n        return resultSet.getUnicodeStream(columnIndex);\n    }\n\n    /**\n     * TODO.\n     */\n    @Deprecated\n    protected final InputStream getUnicodeStream(final String columnLabel) throws SQLException {\n        return resultSet.getUnicodeStream(columnLabel);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final URL getURL(final int columnIndex) throws SQLException {\n        return resultSet.getURL(columnIndex);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final URL getURL(final String columnLabel) throws SQLException {\n        return resultSet.getURL(columnLabel);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final SQLWarning getWarnings() throws SQLException {\n        return resultSet.getWarnings();\n    }\n\n    /**\n     * Turn the {@code ResultSet} into an Object.\n     *\n     * @return An Object initialized with {@code ResultSet} data\n     * @throws SQLException if a database access error occurs\n     * @see ResultSetHandler#handle(ResultSet)\n     */\n    protected abstract T handle() throws SQLException;\n\n    /**\n     * TODO.\n     */\n    @Override\n    public final T handle(final ResultSet rs) throws SQLException {\n        if (this.resultSet != null) {\n            throw new IllegalStateException(\"Re-entry not allowed!\");\n        }\n\n        this.resultSet = rs;\n\n        try {\n            return handle();\n        } finally {\n            this.resultSet = null;\n        }\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void insertRow() throws SQLException {\n        resultSet.insertRow();\n    }\n\n    /**\n     * TODO.\n     */\n    protected final boolean isAfterLast() throws SQLException {\n        return resultSet.isAfterLast();\n    }\n\n    /**\n     * TODO.\n     */\n    protected final boolean isBeforeFirst() throws SQLException {\n        return resultSet.isBeforeFirst();\n    }\n\n    /**\n     * TODO.\n     */\n    protected final boolean isClosed() throws SQLException {\n        return resultSet.isClosed();\n    }\n\n    /**\n     * TODO.\n     */\n    protected final boolean isFirst() throws SQLException {\n        return resultSet.isFirst();\n    }\n\n    /**\n     * TODO.\n     */\n    protected final boolean isLast() throws SQLException {\n        return resultSet.isLast();\n    }\n\n    /**\n     * TODO.\n     */\n    protected final boolean isWrapperFor(final Class<?> iface) throws SQLException {\n        return resultSet.isWrapperFor(iface);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final boolean last() throws SQLException {\n        return resultSet.last();\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void moveToCurrentRow() throws SQLException {\n        resultSet.moveToCurrentRow();\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void moveToInsertRow() throws SQLException {\n        resultSet.moveToInsertRow();\n    }\n\n    /**\n     * TODO.\n     */\n    protected final boolean next() throws SQLException {\n        return resultSet.next();\n    }\n\n    /**\n     * TODO.\n     */\n    protected final boolean previous() throws SQLException {\n        return resultSet.previous();\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void refreshRow() throws SQLException {\n        resultSet.refreshRow();\n    }\n\n    /**\n     * TODO.\n     */\n    protected final boolean relative(final int rows) throws SQLException {\n        return resultSet.relative(rows);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final boolean rowDeleted() throws SQLException {\n        return resultSet.rowDeleted();\n    }\n\n    /**\n     * TODO.\n     */\n    protected final boolean rowInserted() throws SQLException {\n        return resultSet.rowInserted();\n    }\n\n    /**\n     * TODO.\n     */\n    protected final boolean rowUpdated() throws SQLException {\n        return resultSet.rowUpdated();\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void setFetchDirection(final int direction) throws SQLException {\n        resultSet.setFetchDirection(direction);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void setFetchSize(final int rows) throws SQLException {\n        resultSet.setFetchSize(rows);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final <E> E unwrap(final Class<E> iface) throws SQLException {\n        return resultSet.unwrap(iface);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateArray(final int columnIndex, final Array x) throws SQLException {\n        resultSet.updateArray(columnIndex, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateArray(final String columnLabel, final Array x) throws SQLException {\n        resultSet.updateArray(columnLabel, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateAsciiStream(final int columnIndex, final InputStream x) throws SQLException {\n        resultSet.updateAsciiStream(columnIndex, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateAsciiStream(final int columnIndex, final InputStream x, final int length) throws SQLException {\n        resultSet.updateAsciiStream(columnIndex, x, length);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateAsciiStream(final int columnIndex, final InputStream x, final long length) throws SQLException {\n        resultSet.updateAsciiStream(columnIndex, x, length);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateAsciiStream(final String columnLabel, final InputStream x) throws SQLException {\n        resultSet.updateAsciiStream(columnLabel, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateAsciiStream(final String columnLabel, final InputStream x, final int length) throws SQLException {\n        resultSet.updateAsciiStream(columnLabel, x, length);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateAsciiStream(final String columnLabel, final InputStream x, final long length) throws SQLException {\n        resultSet.updateAsciiStream(columnLabel, x, length);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateBigDecimal(final int columnIndex, final BigDecimal x) throws SQLException {\n        resultSet.updateBigDecimal(columnIndex, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateBigDecimal(final String columnLabel, final BigDecimal x) throws SQLException {\n        resultSet.updateBigDecimal(columnLabel, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateBinaryStream(final int columnIndex, final InputStream x) throws SQLException {\n        resultSet.updateBinaryStream(columnIndex, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateBinaryStream(final int columnIndex, final InputStream x, final int length) throws SQLException {\n        resultSet.updateBinaryStream(columnIndex, x, length);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateBinaryStream(final int columnIndex, final InputStream x, final long length) throws SQLException {\n        resultSet.updateBinaryStream(columnIndex, x, length);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateBinaryStream(final String columnLabel, final InputStream x) throws SQLException {\n        resultSet.updateBinaryStream(columnLabel, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateBinaryStream(final String columnLabel, final InputStream x, final int length) throws SQLException {\n        resultSet.updateBinaryStream(columnLabel, x, length);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateBinaryStream(final String columnLabel, final InputStream x, final long length) throws SQLException {\n        resultSet.updateBinaryStream(columnLabel, x, length);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateBlob(final int columnIndex, final Blob x) throws SQLException {\n        resultSet.updateBlob(columnIndex, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateBlob(final int columnIndex, final InputStream inputStream) throws SQLException {\n        resultSet.updateBlob(columnIndex, inputStream);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateBlob(final int columnIndex, final InputStream inputStream, final long length) throws SQLException {\n        resultSet.updateBlob(columnIndex, inputStream, length);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateBlob(final String columnLabel, final Blob x) throws SQLException {\n        resultSet.updateBlob(columnLabel, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateBlob(final String columnLabel, final InputStream inputStream) throws SQLException {\n        resultSet.updateBlob(columnLabel, inputStream);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateBlob(final String columnLabel, final InputStream inputStream, final long length) throws SQLException {\n        resultSet.updateBlob(columnLabel, inputStream, length);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateBoolean(final int columnIndex, final boolean x) throws SQLException {\n        resultSet.updateBoolean(columnIndex, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateBoolean(final String columnLabel, final boolean x) throws SQLException {\n        resultSet.updateBoolean(columnLabel, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateByte(final int columnIndex, final byte x) throws SQLException {\n        resultSet.updateByte(columnIndex, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateByte(final String columnLabel, final byte x) throws SQLException {\n        resultSet.updateByte(columnLabel, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateBytes(final int columnIndex, final byte[] x) throws SQLException {\n        resultSet.updateBytes(columnIndex, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateBytes(final String columnLabel, final byte[] x) throws SQLException {\n        resultSet.updateBytes(columnLabel, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateCharacterStream(final int columnIndex, final Reader x) throws SQLException {\n        resultSet.updateCharacterStream(columnIndex, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateCharacterStream(final int columnIndex, final Reader x, final int length) throws SQLException {\n        resultSet.updateCharacterStream(columnIndex, x, length);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateCharacterStream(final int columnIndex, final Reader x, final long length) throws SQLException {\n        resultSet.updateCharacterStream(columnIndex, x, length);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateCharacterStream(final String columnLabel, final Reader reader) throws SQLException {\n        resultSet.updateCharacterStream(columnLabel, reader);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateCharacterStream(final String columnLabel, final Reader reader, final int length) throws SQLException {\n        resultSet.updateCharacterStream(columnLabel, reader, length);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateCharacterStream(final String columnLabel, final Reader reader, final long length) throws SQLException {\n        resultSet.updateCharacterStream(columnLabel, reader, length);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateClob(final int columnIndex, final Clob x) throws SQLException {\n        resultSet.updateClob(columnIndex, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateClob(final int columnIndex, final Reader reader) throws SQLException {\n        resultSet.updateClob(columnIndex, reader);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateClob(final int columnIndex, final Reader reader, final long length) throws SQLException {\n        resultSet.updateClob(columnIndex, reader, length);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateClob(final String columnLabel, final Clob x) throws SQLException {\n        resultSet.updateClob(columnLabel, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateClob(final String columnLabel, final Reader reader) throws SQLException {\n        resultSet.updateClob(columnLabel, reader);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateClob(final String columnLabel, final Reader reader, final long length) throws SQLException {\n        resultSet.updateClob(columnLabel, reader, length);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateDate(final int columnIndex, final Date x) throws SQLException {\n        resultSet.updateDate(columnIndex, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateDate(final String columnLabel, final Date x) throws SQLException {\n        resultSet.updateDate(columnLabel, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateDouble(final int columnIndex, final double x) throws SQLException {\n        resultSet.updateDouble(columnIndex, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateDouble(final String columnLabel, final double x) throws SQLException {\n        resultSet.updateDouble(columnLabel, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateFloat(final int columnIndex, final float x) throws SQLException {\n        resultSet.updateFloat(columnIndex, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateFloat(final String columnLabel, final float x) throws SQLException {\n        resultSet.updateFloat(columnLabel, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateInt(final int columnIndex, final int x) throws SQLException {\n        resultSet.updateInt(columnIndex, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateInt(final String columnLabel, final int x) throws SQLException {\n        resultSet.updateInt(columnLabel, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateLong(final int columnIndex, final long x) throws SQLException {\n        resultSet.updateLong(columnIndex, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateLong(final String columnLabel, final long x) throws SQLException {\n        resultSet.updateLong(columnLabel, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateNCharacterStream(final int columnIndex, final Reader x) throws SQLException {\n        resultSet.updateNCharacterStream(columnIndex, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateNCharacterStream(final int columnIndex, final Reader x, final long length) throws SQLException {\n        resultSet.updateNCharacterStream(columnIndex, x, length);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateNCharacterStream(final String columnLabel, final Reader reader) throws SQLException {\n        resultSet.updateNCharacterStream(columnLabel, reader);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateNCharacterStream(final String columnLabel, final Reader reader, final long length) throws SQLException {\n        resultSet.updateNCharacterStream(columnLabel, reader, length);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateNClob(final int columnIndex, final NClob nClob) throws SQLException {\n        resultSet.updateNClob(columnIndex, nClob);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateNClob(final int columnIndex, final Reader reader) throws SQLException {\n        resultSet.updateNClob(columnIndex, reader);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateNClob(final int columnIndex, final Reader reader, final long length) throws SQLException {\n        resultSet.updateNClob(columnIndex, reader, length);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateNClob(final String columnLabel, final NClob nClob) throws SQLException {\n        resultSet.updateNClob(columnLabel, nClob);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateNClob(final String columnLabel, final Reader reader) throws SQLException {\n        resultSet.updateNClob(columnLabel, reader);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateNClob(final String columnLabel, final Reader reader, final long length) throws SQLException {\n        resultSet.updateNClob(columnLabel, reader, length);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateNString(final int columnIndex, final String nString) throws SQLException {\n        resultSet.updateNString(columnIndex, nString);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateNString(final String columnLabel, final String nString) throws SQLException {\n        resultSet.updateNString(columnLabel, nString);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateNull(final int columnIndex) throws SQLException {\n        resultSet.updateNull(columnIndex);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateNull(final String columnLabel) throws SQLException {\n        resultSet.updateNull(columnLabel);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateObject(final int columnIndex, final Object x) throws SQLException {\n        resultSet.updateObject(columnIndex, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateObject(final int columnIndex, final Object x, final int scaleOrLength) throws SQLException {\n        resultSet.updateObject(columnIndex, x, scaleOrLength);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateObject(final String columnLabel, final Object x) throws SQLException {\n        resultSet.updateObject(columnLabel, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateObject(final String columnLabel, final Object x, final int scaleOrLength) throws SQLException {\n        resultSet.updateObject(columnLabel, x, scaleOrLength);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateRef(final int columnIndex, final Ref x) throws SQLException {\n        resultSet.updateRef(columnIndex, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateRef(final String columnLabel, final Ref x) throws SQLException {\n        resultSet.updateRef(columnLabel, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateRow() throws SQLException {\n        resultSet.updateRow();\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateRowId(final int columnIndex, final RowId x) throws SQLException {\n        resultSet.updateRowId(columnIndex, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateRowId(final String columnLabel, final RowId x) throws SQLException {\n        resultSet.updateRowId(columnLabel, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateShort(final int columnIndex, final short x) throws SQLException {\n        resultSet.updateShort(columnIndex, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateShort(final String columnLabel, final short x) throws SQLException {\n        resultSet.updateShort(columnLabel, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateSQLXML(final int columnIndex, final SQLXML xmlObject) throws SQLException {\n        resultSet.updateSQLXML(columnIndex, xmlObject);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateSQLXML(final String columnLabel, final SQLXML xmlObject) throws SQLException {\n        resultSet.updateSQLXML(columnLabel, xmlObject);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateString(final int columnIndex, final String x) throws SQLException {\n        resultSet.updateString(columnIndex, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateString(final String columnLabel, final String x) throws SQLException {\n        resultSet.updateString(columnLabel, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateTime(final int columnIndex, final Time x) throws SQLException {\n        resultSet.updateTime(columnIndex, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateTime(final String columnLabel, final Time x) throws SQLException {\n        resultSet.updateTime(columnLabel, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateTimestamp(final int columnIndex, final Timestamp x) throws SQLException {\n        resultSet.updateTimestamp(columnIndex, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateTimestamp(final String columnLabel, final Timestamp x) throws SQLException {\n        resultSet.updateTimestamp(columnLabel, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final boolean wasNull() throws SQLException {\n        return resultSet.wasNull();\n    }\n\n}", "file_hash": "b94c3eeef0497c276c23deb3b7a1f2d0a5b7b78ae2e5f45329ec32012570bea5", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils;", "import java.io.InputStream;", "import java.io.Reader;", "import java.math.BigDecimal;", "import java.net.URL;", "import java.sql.Array;", "import java.sql.Blob;", "import java.sql.Clob;", "import java.sql.Date;", "import java.sql.NClob;", "import java.sql.Ref;", "import java.sql.ResultSet;", "import java.sql.ResultSetMetaData;", "import java.sql.RowId;", "import java.sql.SQLException;", "import java.sql.SQLWarning;", "import java.sql.SQLXML;", "import java.sql.Statement;", "import java.sql.Time;", "import java.sql.Timestamp;", "import java.util.Calendar;", "import java.util.Map;"], "methods": [], "classes": [{"original_string": "public abstract class BaseResultSetHandler<T> implements ResultSetHandler<T> {\n\n    /**\n     * The adapted ResultSet.\n     */\n    private ResultSet resultSet;\n\n    /**\n     * TODO. A\n     */\n    protected final boolean absolute(final int row) throws SQLException {\n        return resultSet.absolute(row);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void afterLast() throws SQLException {\n        resultSet.afterLast();\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void beforeFirst() throws SQLException {\n        resultSet.beforeFirst();\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void cancelRowUpdates() throws SQLException {\n        resultSet.cancelRowUpdates();\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void clearWarnings() throws SQLException {\n        resultSet.clearWarnings();\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void close() throws SQLException {\n        resultSet.close();\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void deleteRow() throws SQLException {\n        resultSet.deleteRow();\n    }\n\n    /**\n     * TODO.\n     */\n    protected final int findColumn(final String columnLabel) throws SQLException {\n        return resultSet.findColumn(columnLabel);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final boolean first() throws SQLException {\n        return resultSet.first();\n    }\n\n    protected final ResultSet getAdaptedResultSet() {\n        return resultSet;\n    }\n\n    /**\n     * TODO.\n     */\n    protected final Array getArray(final int columnIndex) throws SQLException {\n        return resultSet.getArray(columnIndex);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final Array getArray(final String columnLabel) throws SQLException {\n        return resultSet.getArray(columnLabel);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final InputStream getAsciiStream(final int columnIndex) throws SQLException {\n        return resultSet.getAsciiStream(columnIndex);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final InputStream getAsciiStream(final String columnLabel) throws SQLException {\n        return resultSet.getAsciiStream(columnLabel);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final BigDecimal getBigDecimal(final int columnIndex) throws SQLException {\n        return resultSet.getBigDecimal(columnIndex);\n    }\n\n    /**\n     * TODO.\n     */\n    @Deprecated\n    protected final BigDecimal getBigDecimal(final int columnIndex, final int scale) throws SQLException {\n        return resultSet.getBigDecimal(columnIndex, scale);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final BigDecimal getBigDecimal(final String columnLabel) throws SQLException {\n        return resultSet.getBigDecimal(columnLabel);\n    }\n\n    /**\n     * TODO.\n     */\n    @Deprecated\n    protected final BigDecimal getBigDecimal(final String columnLabel, final int scale) throws SQLException {\n        return resultSet.getBigDecimal(columnLabel, scale);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final InputStream getBinaryStream(final int columnIndex) throws SQLException {\n        return resultSet.getBinaryStream(columnIndex);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final InputStream getBinaryStream(final String columnLabel) throws SQLException {\n        return resultSet.getBinaryStream(columnLabel);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final Blob getBlob(final int columnIndex) throws SQLException {\n        return resultSet.getBlob(columnIndex);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final Blob getBlob(final String columnLabel) throws SQLException {\n        return resultSet.getBlob(columnLabel);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final boolean getBoolean(final int columnIndex) throws SQLException {\n        return resultSet.getBoolean(columnIndex);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final boolean getBoolean(final String columnLabel) throws SQLException {\n        return resultSet.getBoolean(columnLabel);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final byte getByte(final int columnIndex) throws SQLException {\n        return resultSet.getByte(columnIndex);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final byte getByte(final String columnLabel) throws SQLException {\n        return resultSet.getByte(columnLabel);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final byte[] getBytes(final int columnIndex) throws SQLException {\n        return resultSet.getBytes(columnIndex);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final byte[] getBytes(final String columnLabel) throws SQLException {\n        return resultSet.getBytes(columnLabel);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final Reader getCharacterStream(final int columnIndex) throws SQLException {\n        return resultSet.getCharacterStream(columnIndex);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final Reader getCharacterStream(final String columnLabel) throws SQLException {\n        return resultSet.getCharacterStream(columnLabel);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final Clob getClob(final int columnIndex) throws SQLException {\n        return resultSet.getClob(columnIndex);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final Clob getClob(final String columnLabel) throws SQLException {\n        return resultSet.getClob(columnLabel);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final int getConcurrency() throws SQLException {\n        return resultSet.getConcurrency();\n    }\n\n    /**\n     * TODO.\n     */\n    protected final String getCursorName() throws SQLException {\n        return resultSet.getCursorName();\n    }\n\n    /**\n     * TODO.\n     */\n    protected final Date getDate(final int columnIndex) throws SQLException {\n        return resultSet.getDate(columnIndex);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final Date getDate(final int columnIndex, final Calendar cal) throws SQLException {\n        return resultSet.getDate(columnIndex, cal);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final Date getDate(final String columnLabel) throws SQLException {\n        return resultSet.getDate(columnLabel);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final Date getDate(final String columnLabel, final Calendar cal) throws SQLException {\n        return resultSet.getDate(columnLabel, cal);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final double getDouble(final int columnIndex) throws SQLException {\n        return resultSet.getDouble(columnIndex);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final double getDouble(final String columnLabel) throws SQLException {\n        return resultSet.getDouble(columnLabel);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final int getFetchDirection() throws SQLException {\n        return resultSet.getFetchDirection();\n    }\n\n    /**\n     * TODO.\n     */\n    protected final int getFetchSize() throws SQLException {\n        return resultSet.getFetchSize();\n    }\n\n    /**\n     * TODO.\n     */\n    protected final float getFloat(final int columnIndex) throws SQLException {\n        return resultSet.getFloat(columnIndex);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final float getFloat(final String columnLabel) throws SQLException {\n        return resultSet.getFloat(columnLabel);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final int getHoldability() throws SQLException {\n        return resultSet.getHoldability();\n    }\n\n    /**\n     * TODO.\n     */\n    protected final int getInt(final int columnIndex) throws SQLException {\n        return resultSet.getInt(columnIndex);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final int getInt(final String columnLabel) throws SQLException {\n        return resultSet.getInt(columnLabel);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final long getLong(final int columnIndex) throws SQLException {\n        return resultSet.getLong(columnIndex);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final long getLong(final String columnLabel) throws SQLException {\n        return resultSet.getLong(columnLabel);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final ResultSetMetaData getMetaData() throws SQLException {\n        return resultSet.getMetaData();\n    }\n\n    /**\n     * TODO.\n     */\n    protected final Reader getNCharacterStream(final int columnIndex) throws SQLException {\n        return resultSet.getNCharacterStream(columnIndex);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final Reader getNCharacterStream(final String columnLabel) throws SQLException {\n        return resultSet.getNCharacterStream(columnLabel);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final NClob getNClob(final int columnIndex) throws SQLException {\n        return resultSet.getNClob(columnIndex);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final NClob getNClob(final String columnLabel) throws SQLException {\n        return resultSet.getNClob(columnLabel);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final String getNString(final int columnIndex) throws SQLException {\n        return resultSet.getNString(columnIndex);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final String getNString(final String columnLabel) throws SQLException {\n        return resultSet.getNString(columnLabel);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final Object getObject(final int columnIndex) throws SQLException {\n        return resultSet.getObject(columnIndex);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final Object getObject(final int columnIndex, final Map<String, Class<?>> map) throws SQLException {\n        return resultSet.getObject(columnIndex, map);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final Object getObject(final String columnLabel) throws SQLException {\n        return resultSet.getObject(columnLabel);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final Object getObject(final String columnLabel, final Map<String, Class<?>> map) throws SQLException {\n        return resultSet.getObject(columnLabel, map);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final Ref getRef(final int columnIndex) throws SQLException {\n        return resultSet.getRef(columnIndex);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final Ref getRef(final String columnLabel) throws SQLException {\n        return resultSet.getRef(columnLabel);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final int getRow() throws SQLException {\n        return resultSet.getRow();\n    }\n\n    /**\n     * TODO.\n     */\n    protected final RowId getRowId(final int columnIndex) throws SQLException {\n        return resultSet.getRowId(columnIndex);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final RowId getRowId(final String columnLabel) throws SQLException {\n        return resultSet.getRowId(columnLabel);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final short getShort(final int columnIndex) throws SQLException {\n        return resultSet.getShort(columnIndex);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final short getShort(final String columnLabel) throws SQLException {\n        return resultSet.getShort(columnLabel);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final SQLXML getSQLXML(final int columnIndex) throws SQLException {\n        return resultSet.getSQLXML(columnIndex);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final SQLXML getSQLXML(final String columnLabel) throws SQLException {\n        return resultSet.getSQLXML(columnLabel);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final Statement getStatement() throws SQLException {\n        return resultSet.getStatement();\n    }\n\n    /**\n     * TODO.\n     */\n    protected final String getString(final int columnIndex) throws SQLException {\n        return resultSet.getString(columnIndex);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final String getString(final String columnLabel) throws SQLException {\n        return resultSet.getString(columnLabel);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final Time getTime(final int columnIndex) throws SQLException {\n        return resultSet.getTime(columnIndex);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final Time getTime(final int columnIndex, final Calendar cal) throws SQLException {\n        return resultSet.getTime(columnIndex, cal);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final Time getTime(final String columnLabel) throws SQLException {\n        return resultSet.getTime(columnLabel);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final Time getTime(final String columnLabel, final Calendar cal) throws SQLException {\n        return resultSet.getTime(columnLabel, cal);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final Timestamp getTimestamp(final int columnIndex) throws SQLException {\n        return resultSet.getTimestamp(columnIndex);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final Timestamp getTimestamp(final int columnIndex, final Calendar cal) throws SQLException {\n        return resultSet.getTimestamp(columnIndex, cal);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final Timestamp getTimestamp(final String columnLabel) throws SQLException {\n        return resultSet.getTimestamp(columnLabel);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final Timestamp getTimestamp(final String columnLabel, final Calendar cal) throws SQLException {\n        return resultSet.getTimestamp(columnLabel, cal);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final int getType() throws SQLException {\n        return resultSet.getType();\n    }\n\n    /**\n     * TODO.\n     */\n    @Deprecated\n    protected final InputStream getUnicodeStream(final int columnIndex) throws SQLException {\n        return resultSet.getUnicodeStream(columnIndex);\n    }\n\n    /**\n     * TODO.\n     */\n    @Deprecated\n    protected final InputStream getUnicodeStream(final String columnLabel) throws SQLException {\n        return resultSet.getUnicodeStream(columnLabel);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final URL getURL(final int columnIndex) throws SQLException {\n        return resultSet.getURL(columnIndex);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final URL getURL(final String columnLabel) throws SQLException {\n        return resultSet.getURL(columnLabel);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final SQLWarning getWarnings() throws SQLException {\n        return resultSet.getWarnings();\n    }\n\n    /**\n     * Turn the {@code ResultSet} into an Object.\n     *\n     * @return An Object initialized with {@code ResultSet} data\n     * @throws SQLException if a database access error occurs\n     * @see ResultSetHandler#handle(ResultSet)\n     */\n    protected abstract T handle() throws SQLException;\n\n    /**\n     * TODO.\n     */\n    @Override\n    public final T handle(final ResultSet rs) throws SQLException {\n        if (this.resultSet != null) {\n            throw new IllegalStateException(\"Re-entry not allowed!\");\n        }\n\n        this.resultSet = rs;\n\n        try {\n            return handle();\n        } finally {\n            this.resultSet = null;\n        }\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void insertRow() throws SQLException {\n        resultSet.insertRow();\n    }\n\n    /**\n     * TODO.\n     */\n    protected final boolean isAfterLast() throws SQLException {\n        return resultSet.isAfterLast();\n    }\n\n    /**\n     * TODO.\n     */\n    protected final boolean isBeforeFirst() throws SQLException {\n        return resultSet.isBeforeFirst();\n    }\n\n    /**\n     * TODO.\n     */\n    protected final boolean isClosed() throws SQLException {\n        return resultSet.isClosed();\n    }\n\n    /**\n     * TODO.\n     */\n    protected final boolean isFirst() throws SQLException {\n        return resultSet.isFirst();\n    }\n\n    /**\n     * TODO.\n     */\n    protected final boolean isLast() throws SQLException {\n        return resultSet.isLast();\n    }\n\n    /**\n     * TODO.\n     */\n    protected final boolean isWrapperFor(final Class<?> iface) throws SQLException {\n        return resultSet.isWrapperFor(iface);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final boolean last() throws SQLException {\n        return resultSet.last();\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void moveToCurrentRow() throws SQLException {\n        resultSet.moveToCurrentRow();\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void moveToInsertRow() throws SQLException {\n        resultSet.moveToInsertRow();\n    }\n\n    /**\n     * TODO.\n     */\n    protected final boolean next() throws SQLException {\n        return resultSet.next();\n    }\n\n    /**\n     * TODO.\n     */\n    protected final boolean previous() throws SQLException {\n        return resultSet.previous();\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void refreshRow() throws SQLException {\n        resultSet.refreshRow();\n    }\n\n    /**\n     * TODO.\n     */\n    protected final boolean relative(final int rows) throws SQLException {\n        return resultSet.relative(rows);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final boolean rowDeleted() throws SQLException {\n        return resultSet.rowDeleted();\n    }\n\n    /**\n     * TODO.\n     */\n    protected final boolean rowInserted() throws SQLException {\n        return resultSet.rowInserted();\n    }\n\n    /**\n     * TODO.\n     */\n    protected final boolean rowUpdated() throws SQLException {\n        return resultSet.rowUpdated();\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void setFetchDirection(final int direction) throws SQLException {\n        resultSet.setFetchDirection(direction);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void setFetchSize(final int rows) throws SQLException {\n        resultSet.setFetchSize(rows);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final <E> E unwrap(final Class<E> iface) throws SQLException {\n        return resultSet.unwrap(iface);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateArray(final int columnIndex, final Array x) throws SQLException {\n        resultSet.updateArray(columnIndex, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateArray(final String columnLabel, final Array x) throws SQLException {\n        resultSet.updateArray(columnLabel, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateAsciiStream(final int columnIndex, final InputStream x) throws SQLException {\n        resultSet.updateAsciiStream(columnIndex, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateAsciiStream(final int columnIndex, final InputStream x, final int length) throws SQLException {\n        resultSet.updateAsciiStream(columnIndex, x, length);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateAsciiStream(final int columnIndex, final InputStream x, final long length) throws SQLException {\n        resultSet.updateAsciiStream(columnIndex, x, length);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateAsciiStream(final String columnLabel, final InputStream x) throws SQLException {\n        resultSet.updateAsciiStream(columnLabel, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateAsciiStream(final String columnLabel, final InputStream x, final int length) throws SQLException {\n        resultSet.updateAsciiStream(columnLabel, x, length);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateAsciiStream(final String columnLabel, final InputStream x, final long length) throws SQLException {\n        resultSet.updateAsciiStream(columnLabel, x, length);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateBigDecimal(final int columnIndex, final BigDecimal x) throws SQLException {\n        resultSet.updateBigDecimal(columnIndex, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateBigDecimal(final String columnLabel, final BigDecimal x) throws SQLException {\n        resultSet.updateBigDecimal(columnLabel, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateBinaryStream(final int columnIndex, final InputStream x) throws SQLException {\n        resultSet.updateBinaryStream(columnIndex, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateBinaryStream(final int columnIndex, final InputStream x, final int length) throws SQLException {\n        resultSet.updateBinaryStream(columnIndex, x, length);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateBinaryStream(final int columnIndex, final InputStream x, final long length) throws SQLException {\n        resultSet.updateBinaryStream(columnIndex, x, length);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateBinaryStream(final String columnLabel, final InputStream x) throws SQLException {\n        resultSet.updateBinaryStream(columnLabel, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateBinaryStream(final String columnLabel, final InputStream x, final int length) throws SQLException {\n        resultSet.updateBinaryStream(columnLabel, x, length);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateBinaryStream(final String columnLabel, final InputStream x, final long length) throws SQLException {\n        resultSet.updateBinaryStream(columnLabel, x, length);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateBlob(final int columnIndex, final Blob x) throws SQLException {\n        resultSet.updateBlob(columnIndex, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateBlob(final int columnIndex, final InputStream inputStream) throws SQLException {\n        resultSet.updateBlob(columnIndex, inputStream);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateBlob(final int columnIndex, final InputStream inputStream, final long length) throws SQLException {\n        resultSet.updateBlob(columnIndex, inputStream, length);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateBlob(final String columnLabel, final Blob x) throws SQLException {\n        resultSet.updateBlob(columnLabel, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateBlob(final String columnLabel, final InputStream inputStream) throws SQLException {\n        resultSet.updateBlob(columnLabel, inputStream);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateBlob(final String columnLabel, final InputStream inputStream, final long length) throws SQLException {\n        resultSet.updateBlob(columnLabel, inputStream, length);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateBoolean(final int columnIndex, final boolean x) throws SQLException {\n        resultSet.updateBoolean(columnIndex, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateBoolean(final String columnLabel, final boolean x) throws SQLException {\n        resultSet.updateBoolean(columnLabel, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateByte(final int columnIndex, final byte x) throws SQLException {\n        resultSet.updateByte(columnIndex, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateByte(final String columnLabel, final byte x) throws SQLException {\n        resultSet.updateByte(columnLabel, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateBytes(final int columnIndex, final byte[] x) throws SQLException {\n        resultSet.updateBytes(columnIndex, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateBytes(final String columnLabel, final byte[] x) throws SQLException {\n        resultSet.updateBytes(columnLabel, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateCharacterStream(final int columnIndex, final Reader x) throws SQLException {\n        resultSet.updateCharacterStream(columnIndex, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateCharacterStream(final int columnIndex, final Reader x, final int length) throws SQLException {\n        resultSet.updateCharacterStream(columnIndex, x, length);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateCharacterStream(final int columnIndex, final Reader x, final long length) throws SQLException {\n        resultSet.updateCharacterStream(columnIndex, x, length);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateCharacterStream(final String columnLabel, final Reader reader) throws SQLException {\n        resultSet.updateCharacterStream(columnLabel, reader);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateCharacterStream(final String columnLabel, final Reader reader, final int length) throws SQLException {\n        resultSet.updateCharacterStream(columnLabel, reader, length);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateCharacterStream(final String columnLabel, final Reader reader, final long length) throws SQLException {\n        resultSet.updateCharacterStream(columnLabel, reader, length);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateClob(final int columnIndex, final Clob x) throws SQLException {\n        resultSet.updateClob(columnIndex, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateClob(final int columnIndex, final Reader reader) throws SQLException {\n        resultSet.updateClob(columnIndex, reader);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateClob(final int columnIndex, final Reader reader, final long length) throws SQLException {\n        resultSet.updateClob(columnIndex, reader, length);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateClob(final String columnLabel, final Clob x) throws SQLException {\n        resultSet.updateClob(columnLabel, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateClob(final String columnLabel, final Reader reader) throws SQLException {\n        resultSet.updateClob(columnLabel, reader);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateClob(final String columnLabel, final Reader reader, final long length) throws SQLException {\n        resultSet.updateClob(columnLabel, reader, length);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateDate(final int columnIndex, final Date x) throws SQLException {\n        resultSet.updateDate(columnIndex, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateDate(final String columnLabel, final Date x) throws SQLException {\n        resultSet.updateDate(columnLabel, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateDouble(final int columnIndex, final double x) throws SQLException {\n        resultSet.updateDouble(columnIndex, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateDouble(final String columnLabel, final double x) throws SQLException {\n        resultSet.updateDouble(columnLabel, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateFloat(final int columnIndex, final float x) throws SQLException {\n        resultSet.updateFloat(columnIndex, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateFloat(final String columnLabel, final float x) throws SQLException {\n        resultSet.updateFloat(columnLabel, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateInt(final int columnIndex, final int x) throws SQLException {\n        resultSet.updateInt(columnIndex, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateInt(final String columnLabel, final int x) throws SQLException {\n        resultSet.updateInt(columnLabel, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateLong(final int columnIndex, final long x) throws SQLException {\n        resultSet.updateLong(columnIndex, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateLong(final String columnLabel, final long x) throws SQLException {\n        resultSet.updateLong(columnLabel, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateNCharacterStream(final int columnIndex, final Reader x) throws SQLException {\n        resultSet.updateNCharacterStream(columnIndex, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateNCharacterStream(final int columnIndex, final Reader x, final long length) throws SQLException {\n        resultSet.updateNCharacterStream(columnIndex, x, length);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateNCharacterStream(final String columnLabel, final Reader reader) throws SQLException {\n        resultSet.updateNCharacterStream(columnLabel, reader);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateNCharacterStream(final String columnLabel, final Reader reader, final long length) throws SQLException {\n        resultSet.updateNCharacterStream(columnLabel, reader, length);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateNClob(final int columnIndex, final NClob nClob) throws SQLException {\n        resultSet.updateNClob(columnIndex, nClob);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateNClob(final int columnIndex, final Reader reader) throws SQLException {\n        resultSet.updateNClob(columnIndex, reader);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateNClob(final int columnIndex, final Reader reader, final long length) throws SQLException {\n        resultSet.updateNClob(columnIndex, reader, length);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateNClob(final String columnLabel, final NClob nClob) throws SQLException {\n        resultSet.updateNClob(columnLabel, nClob);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateNClob(final String columnLabel, final Reader reader) throws SQLException {\n        resultSet.updateNClob(columnLabel, reader);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateNClob(final String columnLabel, final Reader reader, final long length) throws SQLException {\n        resultSet.updateNClob(columnLabel, reader, length);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateNString(final int columnIndex, final String nString) throws SQLException {\n        resultSet.updateNString(columnIndex, nString);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateNString(final String columnLabel, final String nString) throws SQLException {\n        resultSet.updateNString(columnLabel, nString);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateNull(final int columnIndex) throws SQLException {\n        resultSet.updateNull(columnIndex);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateNull(final String columnLabel) throws SQLException {\n        resultSet.updateNull(columnLabel);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateObject(final int columnIndex, final Object x) throws SQLException {\n        resultSet.updateObject(columnIndex, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateObject(final int columnIndex, final Object x, final int scaleOrLength) throws SQLException {\n        resultSet.updateObject(columnIndex, x, scaleOrLength);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateObject(final String columnLabel, final Object x) throws SQLException {\n        resultSet.updateObject(columnLabel, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateObject(final String columnLabel, final Object x, final int scaleOrLength) throws SQLException {\n        resultSet.updateObject(columnLabel, x, scaleOrLength);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateRef(final int columnIndex, final Ref x) throws SQLException {\n        resultSet.updateRef(columnIndex, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateRef(final String columnLabel, final Ref x) throws SQLException {\n        resultSet.updateRef(columnLabel, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateRow() throws SQLException {\n        resultSet.updateRow();\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateRowId(final int columnIndex, final RowId x) throws SQLException {\n        resultSet.updateRowId(columnIndex, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateRowId(final String columnLabel, final RowId x) throws SQLException {\n        resultSet.updateRowId(columnLabel, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateShort(final int columnIndex, final short x) throws SQLException {\n        resultSet.updateShort(columnIndex, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateShort(final String columnLabel, final short x) throws SQLException {\n        resultSet.updateShort(columnLabel, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateSQLXML(final int columnIndex, final SQLXML xmlObject) throws SQLException {\n        resultSet.updateSQLXML(columnIndex, xmlObject);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateSQLXML(final String columnLabel, final SQLXML xmlObject) throws SQLException {\n        resultSet.updateSQLXML(columnLabel, xmlObject);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateString(final int columnIndex, final String x) throws SQLException {\n        resultSet.updateString(columnIndex, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateString(final String columnLabel, final String x) throws SQLException {\n        resultSet.updateString(columnLabel, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateTime(final int columnIndex, final Time x) throws SQLException {\n        resultSet.updateTime(columnIndex, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateTime(final String columnLabel, final Time x) throws SQLException {\n        resultSet.updateTime(columnLabel, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateTimestamp(final int columnIndex, final Timestamp x) throws SQLException {\n        resultSet.updateTimestamp(columnIndex, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final void updateTimestamp(final String columnLabel, final Timestamp x) throws SQLException {\n        resultSet.updateTimestamp(columnLabel, x);\n    }\n\n    /**\n     * TODO.\n     */\n    protected final boolean wasNull() throws SQLException {\n        return resultSet.wasNull();\n    }\n\n}", "definition": "public abstract class BaseResultSetHandler<T> implements ResultSetHandler<T>", "class_docstring": "\nExtensions of this class convert ResultSets into other objects.\n<p>\nAccording to the <em>DRY</em> principle (Don't Repeat Yourself), repeating {@code resultSet} variable inside the {@link ResultSetHandler#handle(ResultSet)}\nover and over for each iteration can get a little tedious, {@code AbstractResultSetHandler} implicitly gives users access to {@code ResultSet}'s methods.\n</p>\n<p>\n<b>NOTE</b> This class is <em>NOT</em> thread safe!\n</p>\n\n@param <T> the target type the input ResultSet will be converted to.\n@since 1.6\n", "name": "BaseResultSetHandler", "super_interfaces": ["ResultSetHandler<T>"], "superclasses": "", "attributes": {"modifiers": "public abstract", "marker_annotations": [], "non_marker_annotations": ["public", "abstract"], "comments": [], "fields": [{"attribute_expression": "private ResultSet resultSet;", "docstring": "\nThe adapted ResultSet.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ResultSet", "name": "resultSet", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    protected final boolean absolute(final int row) throws SQLException {\n        return resultSet.absolute(row);\n    }", "docstring": "\nTODO. A\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "boolean", "classes": []}, "name": "absolute", "params": [{"name": "row", "type": "int"}], "body": "                                                                        {\n        return resultSet.absolute(row);\n    }", "signature": "protected final boolean absolute(final int row)"}, {"syntax_pass": true, "original_string": "    protected final void afterLast() throws SQLException {\n        resultSet.afterLast();\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "afterLast", "params": [], "body": "                                                         {\n        resultSet.afterLast();\n    }", "signature": "protected final void afterLast()"}, {"syntax_pass": true, "original_string": "    protected final void beforeFirst() throws SQLException {\n        resultSet.beforeFirst();\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "beforeFirst", "params": [], "body": "                                                           {\n        resultSet.beforeFirst();\n    }", "signature": "protected final void beforeFirst()"}, {"syntax_pass": true, "original_string": "    protected final void cancelRowUpdates() throws SQLException {\n        resultSet.cancelRowUpdates();\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "cancelRowUpdates", "params": [], "body": "                                                                {\n        resultSet.cancelRowUpdates();\n    }", "signature": "protected final void cancelRowUpdates()"}, {"syntax_pass": true, "original_string": "    protected final void clearWarnings() throws SQLException {\n        resultSet.clearWarnings();\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "clearWarnings", "params": [], "body": "                                                             {\n        resultSet.clearWarnings();\n    }", "signature": "protected final void clearWarnings()"}, {"syntax_pass": true, "original_string": "    protected final void close() throws SQLException {\n        resultSet.close();\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "close", "params": [], "body": "                                                     {\n        resultSet.close();\n    }", "signature": "protected final void close()"}, {"syntax_pass": true, "original_string": "    protected final void deleteRow() throws SQLException {\n        resultSet.deleteRow();\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "deleteRow", "params": [], "body": "                                                         {\n        resultSet.deleteRow();\n    }", "signature": "protected final void deleteRow()"}, {"syntax_pass": true, "original_string": "    protected final int findColumn(final String columnLabel) throws SQLException {\n        return resultSet.findColumn(columnLabel);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "int", "classes": []}, "name": "findColumn", "params": [{"name": "columnLabel", "type": "String"}], "body": "                                                                                 {\n        return resultSet.findColumn(columnLabel);\n    }", "signature": "protected final int findColumn(final String columnLabel)"}, {"syntax_pass": true, "original_string": "    protected final boolean first() throws SQLException {\n        return resultSet.first();\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "boolean", "classes": []}, "name": "first", "params": [], "body": "                                                        {\n        return resultSet.first();\n    }", "signature": "protected final boolean first()"}, {"syntax_pass": true, "original_string": "    protected final ResultSet getAdaptedResultSet() {\n        return resultSet;\n    }", "docstring": "", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "ResultSet", "classes": []}, "name": "getAdaptedResultSet", "params": [], "body": "                                                    {\n        return resultSet;\n    }", "signature": "protected final ResultSet getAdaptedResultSet()"}, {"syntax_pass": true, "original_string": "    protected final Array getArray(final int columnIndex) throws SQLException {\n        return resultSet.getArray(columnIndex);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "Array", "classes": []}, "name": "getArray", "params": [{"name": "columnIndex", "type": "int"}], "body": "                                                                              {\n        return resultSet.getArray(columnIndex);\n    }", "signature": "protected final Array getArray(final int columnIndex)"}, {"syntax_pass": true, "original_string": "    protected final Array getArray(final String columnLabel) throws SQLException {\n        return resultSet.getArray(columnLabel);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "Array", "classes": []}, "name": "getArray", "params": [{"name": "columnLabel", "type": "String"}], "body": "                                                                                 {\n        return resultSet.getArray(columnLabel);\n    }", "signature": "protected final Array getArray(final String columnLabel)"}, {"syntax_pass": true, "original_string": "    protected final InputStream getAsciiStream(final int columnIndex) throws SQLException {\n        return resultSet.getAsciiStream(columnIndex);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "InputStream", "classes": []}, "name": "getAsciiStream", "params": [{"name": "columnIndex", "type": "int"}], "body": "                                                                                          {\n        return resultSet.getAsciiStream(columnIndex);\n    }", "signature": "protected final InputStream getAsciiStream(final int columnIndex)"}, {"syntax_pass": true, "original_string": "    protected final InputStream getAsciiStream(final String columnLabel) throws SQLException {\n        return resultSet.getAsciiStream(columnLabel);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "InputStream", "classes": []}, "name": "getAsciiStream", "params": [{"name": "columnLabel", "type": "String"}], "body": "                                                                                             {\n        return resultSet.getAsciiStream(columnLabel);\n    }", "signature": "protected final InputStream getAsciiStream(final String columnLabel)"}, {"syntax_pass": true, "original_string": "    protected final BigDecimal getBigDecimal(final int columnIndex) throws SQLException {\n        return resultSet.getBigDecimal(columnIndex);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "BigDecimal", "classes": []}, "name": "getBigDecimal", "params": [{"name": "columnIndex", "type": "int"}], "body": "                                                                                        {\n        return resultSet.getBigDecimal(columnIndex);\n    }", "signature": "protected final BigDecimal getBigDecimal(final int columnIndex)"}, {"syntax_pass": true, "original_string": "    @Deprecated\n    protected final BigDecimal getBigDecimal(final int columnIndex, final int scale) throws SQLException {\n        return resultSet.getBigDecimal(columnIndex, scale);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "@Deprecated\n    protected final", "marker_annotations": ["@Deprecated"], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "BigDecimal", "classes": []}, "name": "getBigDecimal", "params": [{"name": "columnIndex", "type": "int"}, {"name": "scale", "type": "int"}], "body": "                                                                                                         {\n        return resultSet.getBigDecimal(columnIndex, scale);\n    }", "signature": "@Deprecated\n    protected final BigDecimal getBigDecimal(final int columnIndex, final int scale)"}, {"syntax_pass": true, "original_string": "    protected final BigDecimal getBigDecimal(final String columnLabel) throws SQLException {\n        return resultSet.getBigDecimal(columnLabel);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "BigDecimal", "classes": []}, "name": "getBigDecimal", "params": [{"name": "columnLabel", "type": "String"}], "body": "                                                                                           {\n        return resultSet.getBigDecimal(columnLabel);\n    }", "signature": "protected final BigDecimal getBigDecimal(final String columnLabel)"}, {"syntax_pass": true, "original_string": "    @Deprecated\n    protected final BigDecimal getBigDecimal(final String columnLabel, final int scale) throws SQLException {\n        return resultSet.getBigDecimal(columnLabel, scale);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "@Deprecated\n    protected final", "marker_annotations": ["@Deprecated"], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "BigDecimal", "classes": []}, "name": "getBigDecimal", "params": [{"name": "columnLabel", "type": "String"}, {"name": "scale", "type": "int"}], "body": "                                                                                                            {\n        return resultSet.getBigDecimal(columnLabel, scale);\n    }", "signature": "@Deprecated\n    protected final BigDecimal getBigDecimal(final String columnLabel, final int scale)"}, {"syntax_pass": true, "original_string": "    protected final InputStream getBinaryStream(final int columnIndex) throws SQLException {\n        return resultSet.getBinaryStream(columnIndex);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "InputStream", "classes": []}, "name": "getBinaryStream", "params": [{"name": "columnIndex", "type": "int"}], "body": "                                                                                           {\n        return resultSet.getBinaryStream(columnIndex);\n    }", "signature": "protected final InputStream getBinaryStream(final int columnIndex)"}, {"syntax_pass": true, "original_string": "    protected final InputStream getBinaryStream(final String columnLabel) throws SQLException {\n        return resultSet.getBinaryStream(columnLabel);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "InputStream", "classes": []}, "name": "getBinaryStream", "params": [{"name": "columnLabel", "type": "String"}], "body": "                                                                                              {\n        return resultSet.getBinaryStream(columnLabel);\n    }", "signature": "protected final InputStream getBinaryStream(final String columnLabel)"}, {"syntax_pass": true, "original_string": "    protected final Blob getBlob(final int columnIndex) throws SQLException {\n        return resultSet.getBlob(columnIndex);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "Blob", "classes": []}, "name": "getBlob", "params": [{"name": "columnIndex", "type": "int"}], "body": "                                                                            {\n        return resultSet.getBlob(columnIndex);\n    }", "signature": "protected final Blob getBlob(final int columnIndex)"}, {"syntax_pass": true, "original_string": "    protected final Blob getBlob(final String columnLabel) throws SQLException {\n        return resultSet.getBlob(columnLabel);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "Blob", "classes": []}, "name": "getBlob", "params": [{"name": "columnLabel", "type": "String"}], "body": "                                                                               {\n        return resultSet.getBlob(columnLabel);\n    }", "signature": "protected final Blob getBlob(final String columnLabel)"}, {"syntax_pass": true, "original_string": "    protected final boolean getBoolean(final int columnIndex) throws SQLException {\n        return resultSet.getBoolean(columnIndex);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "boolean", "classes": []}, "name": "getBoolean", "params": [{"name": "columnIndex", "type": "int"}], "body": "                                                                                  {\n        return resultSet.getBoolean(columnIndex);\n    }", "signature": "protected final boolean getBoolean(final int columnIndex)"}, {"syntax_pass": true, "original_string": "    protected final boolean getBoolean(final String columnLabel) throws SQLException {\n        return resultSet.getBoolean(columnLabel);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "boolean", "classes": []}, "name": "getBoolean", "params": [{"name": "columnLabel", "type": "String"}], "body": "                                                                                     {\n        return resultSet.getBoolean(columnLabel);\n    }", "signature": "protected final boolean getBoolean(final String columnLabel)"}, {"syntax_pass": true, "original_string": "    protected final byte getByte(final int columnIndex) throws SQLException {\n        return resultSet.getByte(columnIndex);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "byte", "classes": []}, "name": "getByte", "params": [{"name": "columnIndex", "type": "int"}], "body": "                                                                            {\n        return resultSet.getByte(columnIndex);\n    }", "signature": "protected final byte getByte(final int columnIndex)"}, {"syntax_pass": true, "original_string": "    protected final byte getByte(final String columnLabel) throws SQLException {\n        return resultSet.getByte(columnLabel);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "byte", "classes": []}, "name": "getByte", "params": [{"name": "columnLabel", "type": "String"}], "body": "                                                                               {\n        return resultSet.getByte(columnLabel);\n    }", "signature": "protected final byte getByte(final String columnLabel)"}, {"syntax_pass": true, "original_string": "    protected final byte[] getBytes(final int columnIndex) throws SQLException {\n        return resultSet.getBytes(columnIndex);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "byte[]", "classes": []}, "name": "getBytes", "params": [{"name": "columnIndex", "type": "int"}], "body": "                                                                               {\n        return resultSet.getBytes(columnIndex);\n    }", "signature": "protected final byte[] getBytes(final int columnIndex)"}, {"syntax_pass": true, "original_string": "    protected final byte[] getBytes(final String columnLabel) throws SQLException {\n        return resultSet.getBytes(columnLabel);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "byte[]", "classes": []}, "name": "getBytes", "params": [{"name": "columnLabel", "type": "String"}], "body": "                                                                                  {\n        return resultSet.getBytes(columnLabel);\n    }", "signature": "protected final byte[] getBytes(final String columnLabel)"}, {"syntax_pass": true, "original_string": "    protected final Reader getCharacterStream(final int columnIndex) throws SQLException {\n        return resultSet.getCharacterStream(columnIndex);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "Reader", "classes": []}, "name": "getCharacterStream", "params": [{"name": "columnIndex", "type": "int"}], "body": "                                                                                         {\n        return resultSet.getCharacterStream(columnIndex);\n    }", "signature": "protected final Reader getCharacterStream(final int columnIndex)"}, {"syntax_pass": true, "original_string": "    protected final Reader getCharacterStream(final String columnLabel) throws SQLException {\n        return resultSet.getCharacterStream(columnLabel);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "Reader", "classes": []}, "name": "getCharacterStream", "params": [{"name": "columnLabel", "type": "String"}], "body": "                                                                                            {\n        return resultSet.getCharacterStream(columnLabel);\n    }", "signature": "protected final Reader getCharacterStream(final String columnLabel)"}, {"syntax_pass": true, "original_string": "    protected final Clob getClob(final int columnIndex) throws SQLException {\n        return resultSet.getClob(columnIndex);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "Clob", "classes": []}, "name": "getClob", "params": [{"name": "columnIndex", "type": "int"}], "body": "                                                                            {\n        return resultSet.getClob(columnIndex);\n    }", "signature": "protected final Clob getClob(final int columnIndex)"}, {"syntax_pass": true, "original_string": "    protected final Clob getClob(final String columnLabel) throws SQLException {\n        return resultSet.getClob(columnLabel);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "Clob", "classes": []}, "name": "getClob", "params": [{"name": "columnLabel", "type": "String"}], "body": "                                                                               {\n        return resultSet.getClob(columnLabel);\n    }", "signature": "protected final Clob getClob(final String columnLabel)"}, {"syntax_pass": true, "original_string": "    protected final int getConcurrency() throws SQLException {\n        return resultSet.getConcurrency();\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "int", "classes": []}, "name": "getConcurrency", "params": [], "body": "                                                             {\n        return resultSet.getConcurrency();\n    }", "signature": "protected final int getConcurrency()"}, {"syntax_pass": true, "original_string": "    protected final String getCursorName() throws SQLException {\n        return resultSet.getCursorName();\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "String", "classes": []}, "name": "getCursorName", "params": [], "body": "                                                               {\n        return resultSet.getCursorName();\n    }", "signature": "protected final String getCursorName()"}, {"syntax_pass": true, "original_string": "    protected final Date getDate(final int columnIndex) throws SQLException {\n        return resultSet.getDate(columnIndex);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "Date", "classes": []}, "name": "getDate", "params": [{"name": "columnIndex", "type": "int"}], "body": "                                                                            {\n        return resultSet.getDate(columnIndex);\n    }", "signature": "protected final Date getDate(final int columnIndex)"}, {"syntax_pass": true, "original_string": "    protected final Date getDate(final int columnIndex, final Calendar cal) throws SQLException {\n        return resultSet.getDate(columnIndex, cal);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "Date", "classes": []}, "name": "getDate", "params": [{"name": "columnIndex", "type": "int"}, {"name": "cal", "type": "Calendar"}], "body": "                                                                                                {\n        return resultSet.getDate(columnIndex, cal);\n    }", "signature": "protected final Date getDate(final int columnIndex, final Calendar cal)"}, {"syntax_pass": true, "original_string": "    protected final Date getDate(final String columnLabel) throws SQLException {\n        return resultSet.getDate(columnLabel);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "Date", "classes": []}, "name": "getDate", "params": [{"name": "columnLabel", "type": "String"}], "body": "                                                                               {\n        return resultSet.getDate(columnLabel);\n    }", "signature": "protected final Date getDate(final String columnLabel)"}, {"syntax_pass": true, "original_string": "    protected final Date getDate(final String columnLabel, final Calendar cal) throws SQLException {\n        return resultSet.getDate(columnLabel, cal);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "Date", "classes": []}, "name": "getDate", "params": [{"name": "columnLabel", "type": "String"}, {"name": "cal", "type": "Calendar"}], "body": "                                                                                                   {\n        return resultSet.getDate(columnLabel, cal);\n    }", "signature": "protected final Date getDate(final String columnLabel, final Calendar cal)"}, {"syntax_pass": true, "original_string": "    protected final double getDouble(final int columnIndex) throws SQLException {\n        return resultSet.getDouble(columnIndex);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "double", "classes": []}, "name": "getDouble", "params": [{"name": "columnIndex", "type": "int"}], "body": "                                                                                {\n        return resultSet.getDouble(columnIndex);\n    }", "signature": "protected final double getDouble(final int columnIndex)"}, {"syntax_pass": true, "original_string": "    protected final double getDouble(final String columnLabel) throws SQLException {\n        return resultSet.getDouble(columnLabel);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "double", "classes": []}, "name": "getDouble", "params": [{"name": "columnLabel", "type": "String"}], "body": "                                                                                   {\n        return resultSet.getDouble(columnLabel);\n    }", "signature": "protected final double getDouble(final String columnLabel)"}, {"syntax_pass": true, "original_string": "    protected final int getFetchDirection() throws SQLException {\n        return resultSet.getFetchDirection();\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "int", "classes": []}, "name": "getFetchDirection", "params": [], "body": "                                                                {\n        return resultSet.getFetchDirection();\n    }", "signature": "protected final int getFetchDirection()"}, {"syntax_pass": true, "original_string": "    protected final int getFetchSize() throws SQLException {\n        return resultSet.getFetchSize();\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "int", "classes": []}, "name": "getFetchSize", "params": [], "body": "                                                           {\n        return resultSet.getFetchSize();\n    }", "signature": "protected final int getFetchSize()"}, {"syntax_pass": true, "original_string": "    protected final float getFloat(final int columnIndex) throws SQLException {\n        return resultSet.getFloat(columnIndex);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "float", "classes": []}, "name": "getFloat", "params": [{"name": "columnIndex", "type": "int"}], "body": "                                                                              {\n        return resultSet.getFloat(columnIndex);\n    }", "signature": "protected final float getFloat(final int columnIndex)"}, {"syntax_pass": true, "original_string": "    protected final float getFloat(final String columnLabel) throws SQLException {\n        return resultSet.getFloat(columnLabel);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "float", "classes": []}, "name": "getFloat", "params": [{"name": "columnLabel", "type": "String"}], "body": "                                                                                 {\n        return resultSet.getFloat(columnLabel);\n    }", "signature": "protected final float getFloat(final String columnLabel)"}, {"syntax_pass": true, "original_string": "    protected final int getHoldability() throws SQLException {\n        return resultSet.getHoldability();\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "int", "classes": []}, "name": "getHoldability", "params": [], "body": "                                                             {\n        return resultSet.getHoldability();\n    }", "signature": "protected final int getHoldability()"}, {"syntax_pass": true, "original_string": "    protected final int getInt(final int columnIndex) throws SQLException {\n        return resultSet.getInt(columnIndex);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "int", "classes": []}, "name": "getInt", "params": [{"name": "columnIndex", "type": "int"}], "body": "                                                                          {\n        return resultSet.getInt(columnIndex);\n    }", "signature": "protected final int getInt(final int columnIndex)"}, {"syntax_pass": true, "original_string": "    protected final int getInt(final String columnLabel) throws SQLException {\n        return resultSet.getInt(columnLabel);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "int", "classes": []}, "name": "getInt", "params": [{"name": "columnLabel", "type": "String"}], "body": "                                                                             {\n        return resultSet.getInt(columnLabel);\n    }", "signature": "protected final int getInt(final String columnLabel)"}, {"syntax_pass": true, "original_string": "    protected final long getLong(final int columnIndex) throws SQLException {\n        return resultSet.getLong(columnIndex);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "long", "classes": []}, "name": "getLong", "params": [{"name": "columnIndex", "type": "int"}], "body": "                                                                            {\n        return resultSet.getLong(columnIndex);\n    }", "signature": "protected final long getLong(final int columnIndex)"}, {"syntax_pass": true, "original_string": "    protected final long getLong(final String columnLabel) throws SQLException {\n        return resultSet.getLong(columnLabel);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "long", "classes": []}, "name": "getLong", "params": [{"name": "columnLabel", "type": "String"}], "body": "                                                                               {\n        return resultSet.getLong(columnLabel);\n    }", "signature": "protected final long getLong(final String columnLabel)"}, {"syntax_pass": true, "original_string": "    protected final ResultSetMetaData getMetaData() throws SQLException {\n        return resultSet.getMetaData();\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "ResultSetMetaData", "classes": []}, "name": "getMetaData", "params": [], "body": "                                                                        {\n        return resultSet.getMetaData();\n    }", "signature": "protected final ResultSetMetaData getMetaData()"}, {"syntax_pass": true, "original_string": "    protected final Reader getNCharacterStream(final int columnIndex) throws SQLException {\n        return resultSet.getNCharacterStream(columnIndex);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "Reader", "classes": []}, "name": "getNCharacterStream", "params": [{"name": "columnIndex", "type": "int"}], "body": "                                                                                          {\n        return resultSet.getNCharacterStream(columnIndex);\n    }", "signature": "protected final Reader getNCharacterStream(final int columnIndex)"}, {"syntax_pass": true, "original_string": "    protected final Reader getNCharacterStream(final String columnLabel) throws SQLException {\n        return resultSet.getNCharacterStream(columnLabel);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "Reader", "classes": []}, "name": "getNCharacterStream", "params": [{"name": "columnLabel", "type": "String"}], "body": "                                                                                             {\n        return resultSet.getNCharacterStream(columnLabel);\n    }", "signature": "protected final Reader getNCharacterStream(final String columnLabel)"}, {"syntax_pass": true, "original_string": "    protected final NClob getNClob(final int columnIndex) throws SQLException {\n        return resultSet.getNClob(columnIndex);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "NClob", "classes": []}, "name": "getNClob", "params": [{"name": "columnIndex", "type": "int"}], "body": "                                                                              {\n        return resultSet.getNClob(columnIndex);\n    }", "signature": "protected final NClob getNClob(final int columnIndex)"}, {"syntax_pass": true, "original_string": "    protected final NClob getNClob(final String columnLabel) throws SQLException {\n        return resultSet.getNClob(columnLabel);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "NClob", "classes": []}, "name": "getNClob", "params": [{"name": "columnLabel", "type": "String"}], "body": "                                                                                 {\n        return resultSet.getNClob(columnLabel);\n    }", "signature": "protected final NClob getNClob(final String columnLabel)"}, {"syntax_pass": true, "original_string": "    protected final String getNString(final int columnIndex) throws SQLException {\n        return resultSet.getNString(columnIndex);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "String", "classes": []}, "name": "getNString", "params": [{"name": "columnIndex", "type": "int"}], "body": "                                                                                 {\n        return resultSet.getNString(columnIndex);\n    }", "signature": "protected final String getNString(final int columnIndex)"}, {"syntax_pass": true, "original_string": "    protected final String getNString(final String columnLabel) throws SQLException {\n        return resultSet.getNString(columnLabel);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "String", "classes": []}, "name": "getNString", "params": [{"name": "columnLabel", "type": "String"}], "body": "                                                                                    {\n        return resultSet.getNString(columnLabel);\n    }", "signature": "protected final String getNString(final String columnLabel)"}, {"syntax_pass": true, "original_string": "    protected final Object getObject(final int columnIndex) throws SQLException {\n        return resultSet.getObject(columnIndex);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "Object", "classes": []}, "name": "getObject", "params": [{"name": "columnIndex", "type": "int"}], "body": "                                                                                {\n        return resultSet.getObject(columnIndex);\n    }", "signature": "protected final Object getObject(final int columnIndex)"}, {"syntax_pass": true, "original_string": "    protected final Object getObject(final int columnIndex, final Map<String, Class<?>> map) throws SQLException {\n        return resultSet.getObject(columnIndex, map);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "Object", "classes": []}, "name": "getObject", "params": [{"name": "columnIndex", "type": "int"}, {"name": "map", "type": "Map<String, Class<?>>"}], "body": "                                                                                                                 {\n        return resultSet.getObject(columnIndex, map);\n    }", "signature": "protected final Object getObject(final int columnIndex, final Map<String, Class<?>> map)"}, {"syntax_pass": true, "original_string": "    protected final Object getObject(final String columnLabel) throws SQLException {\n        return resultSet.getObject(columnLabel);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "Object", "classes": []}, "name": "getObject", "params": [{"name": "columnLabel", "type": "String"}], "body": "                                                                                   {\n        return resultSet.getObject(columnLabel);\n    }", "signature": "protected final Object getObject(final String columnLabel)"}, {"syntax_pass": true, "original_string": "    protected final Object getObject(final String columnLabel, final Map<String, Class<?>> map) throws SQLException {\n        return resultSet.getObject(columnLabel, map);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "Object", "classes": []}, "name": "getObject", "params": [{"name": "columnLabel", "type": "String"}, {"name": "map", "type": "Map<String, Class<?>>"}], "body": "                                                                                                                    {\n        return resultSet.getObject(columnLabel, map);\n    }", "signature": "protected final Object getObject(final String columnLabel, final Map<String, Class<?>> map)"}, {"syntax_pass": true, "original_string": "    protected final Ref getRef(final int columnIndex) throws SQLException {\n        return resultSet.getRef(columnIndex);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "Ref", "classes": []}, "name": "getRef", "params": [{"name": "columnIndex", "type": "int"}], "body": "                                                                          {\n        return resultSet.getRef(columnIndex);\n    }", "signature": "protected final Ref getRef(final int columnIndex)"}, {"syntax_pass": true, "original_string": "    protected final Ref getRef(final String columnLabel) throws SQLException {\n        return resultSet.getRef(columnLabel);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "Ref", "classes": []}, "name": "getRef", "params": [{"name": "columnLabel", "type": "String"}], "body": "                                                                             {\n        return resultSet.getRef(columnLabel);\n    }", "signature": "protected final Ref getRef(final String columnLabel)"}, {"syntax_pass": true, "original_string": "    protected final int getRow() throws SQLException {\n        return resultSet.getRow();\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "int", "classes": []}, "name": "getRow", "params": [], "body": "                                                     {\n        return resultSet.getRow();\n    }", "signature": "protected final int getRow()"}, {"syntax_pass": true, "original_string": "    protected final RowId getRowId(final int columnIndex) throws SQLException {\n        return resultSet.getRowId(columnIndex);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "RowId", "classes": []}, "name": "getRowId", "params": [{"name": "columnIndex", "type": "int"}], "body": "                                                                              {\n        return resultSet.getRowId(columnIndex);\n    }", "signature": "protected final RowId getRowId(final int columnIndex)"}, {"syntax_pass": true, "original_string": "    protected final RowId getRowId(final String columnLabel) throws SQLException {\n        return resultSet.getRowId(columnLabel);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "RowId", "classes": []}, "name": "getRowId", "params": [{"name": "columnLabel", "type": "String"}], "body": "                                                                                 {\n        return resultSet.getRowId(columnLabel);\n    }", "signature": "protected final RowId getRowId(final String columnLabel)"}, {"syntax_pass": true, "original_string": "    protected final short getShort(final int columnIndex) throws SQLException {\n        return resultSet.getShort(columnIndex);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "short", "classes": []}, "name": "getShort", "params": [{"name": "columnIndex", "type": "int"}], "body": "                                                                              {\n        return resultSet.getShort(columnIndex);\n    }", "signature": "protected final short getShort(final int columnIndex)"}, {"syntax_pass": true, "original_string": "    protected final short getShort(final String columnLabel) throws SQLException {\n        return resultSet.getShort(columnLabel);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "short", "classes": []}, "name": "getShort", "params": [{"name": "columnLabel", "type": "String"}], "body": "                                                                                 {\n        return resultSet.getShort(columnLabel);\n    }", "signature": "protected final short getShort(final String columnLabel)"}, {"syntax_pass": true, "original_string": "    protected final SQLXML getSQLXML(final int columnIndex) throws SQLException {\n        return resultSet.getSQLXML(columnIndex);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "SQLXML", "classes": []}, "name": "getSQLXML", "params": [{"name": "columnIndex", "type": "int"}], "body": "                                                                                {\n        return resultSet.getSQLXML(columnIndex);\n    }", "signature": "protected final SQLXML getSQLXML(final int columnIndex)"}, {"syntax_pass": true, "original_string": "    protected final SQLXML getSQLXML(final String columnLabel) throws SQLException {\n        return resultSet.getSQLXML(columnLabel);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "SQLXML", "classes": []}, "name": "getSQLXML", "params": [{"name": "columnLabel", "type": "String"}], "body": "                                                                                   {\n        return resultSet.getSQLXML(columnLabel);\n    }", "signature": "protected final SQLXML getSQLXML(final String columnLabel)"}, {"syntax_pass": true, "original_string": "    protected final Statement getStatement() throws SQLException {\n        return resultSet.getStatement();\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "Statement", "classes": []}, "name": "getStatement", "params": [], "body": "                                                                 {\n        return resultSet.getStatement();\n    }", "signature": "protected final Statement getStatement()"}, {"syntax_pass": true, "original_string": "    protected final String getString(final int columnIndex) throws SQLException {\n        return resultSet.getString(columnIndex);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "String", "classes": []}, "name": "getString", "params": [{"name": "columnIndex", "type": "int"}], "body": "                                                                                {\n        return resultSet.getString(columnIndex);\n    }", "signature": "protected final String getString(final int columnIndex)"}, {"syntax_pass": true, "original_string": "    protected final String getString(final String columnLabel) throws SQLException {\n        return resultSet.getString(columnLabel);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "String", "classes": []}, "name": "getString", "params": [{"name": "columnLabel", "type": "String"}], "body": "                                                                                   {\n        return resultSet.getString(columnLabel);\n    }", "signature": "protected final String getString(final String columnLabel)"}, {"syntax_pass": true, "original_string": "    protected final Time getTime(final int columnIndex) throws SQLException {\n        return resultSet.getTime(columnIndex);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "Time", "classes": []}, "name": "getTime", "params": [{"name": "columnIndex", "type": "int"}], "body": "                                                                            {\n        return resultSet.getTime(columnIndex);\n    }", "signature": "protected final Time getTime(final int columnIndex)"}, {"syntax_pass": true, "original_string": "    protected final Time getTime(final int columnIndex, final Calendar cal) throws SQLException {\n        return resultSet.getTime(columnIndex, cal);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "Time", "classes": []}, "name": "getTime", "params": [{"name": "columnIndex", "type": "int"}, {"name": "cal", "type": "Calendar"}], "body": "                                                                                                {\n        return resultSet.getTime(columnIndex, cal);\n    }", "signature": "protected final Time getTime(final int columnIndex, final Calendar cal)"}, {"syntax_pass": true, "original_string": "    protected final Time getTime(final String columnLabel) throws SQLException {\n        return resultSet.getTime(columnLabel);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "Time", "classes": []}, "name": "getTime", "params": [{"name": "columnLabel", "type": "String"}], "body": "                                                                               {\n        return resultSet.getTime(columnLabel);\n    }", "signature": "protected final Time getTime(final String columnLabel)"}, {"syntax_pass": true, "original_string": "    protected final Time getTime(final String columnLabel, final Calendar cal) throws SQLException {\n        return resultSet.getTime(columnLabel, cal);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "Time", "classes": []}, "name": "getTime", "params": [{"name": "columnLabel", "type": "String"}, {"name": "cal", "type": "Calendar"}], "body": "                                                                                                   {\n        return resultSet.getTime(columnLabel, cal);\n    }", "signature": "protected final Time getTime(final String columnLabel, final Calendar cal)"}, {"syntax_pass": true, "original_string": "    protected final Timestamp getTimestamp(final int columnIndex) throws SQLException {\n        return resultSet.getTimestamp(columnIndex);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "Timestamp", "classes": []}, "name": "getTimestamp", "params": [{"name": "columnIndex", "type": "int"}], "body": "                                                                                      {\n        return resultSet.getTimestamp(columnIndex);\n    }", "signature": "protected final Timestamp getTimestamp(final int columnIndex)"}, {"syntax_pass": true, "original_string": "    protected final Timestamp getTimestamp(final int columnIndex, final Calendar cal) throws SQLException {\n        return resultSet.getTimestamp(columnIndex, cal);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "Timestamp", "classes": []}, "name": "getTimestamp", "params": [{"name": "columnIndex", "type": "int"}, {"name": "cal", "type": "Calendar"}], "body": "                                                                                                          {\n        return resultSet.getTimestamp(columnIndex, cal);\n    }", "signature": "protected final Timestamp getTimestamp(final int columnIndex, final Calendar cal)"}, {"syntax_pass": true, "original_string": "    protected final Timestamp getTimestamp(final String columnLabel) throws SQLException {\n        return resultSet.getTimestamp(columnLabel);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "Timestamp", "classes": []}, "name": "getTimestamp", "params": [{"name": "columnLabel", "type": "String"}], "body": "                                                                                         {\n        return resultSet.getTimestamp(columnLabel);\n    }", "signature": "protected final Timestamp getTimestamp(final String columnLabel)"}, {"syntax_pass": true, "original_string": "    protected final Timestamp getTimestamp(final String columnLabel, final Calendar cal) throws SQLException {\n        return resultSet.getTimestamp(columnLabel, cal);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "Timestamp", "classes": []}, "name": "getTimestamp", "params": [{"name": "columnLabel", "type": "String"}, {"name": "cal", "type": "Calendar"}], "body": "                                                                                                             {\n        return resultSet.getTimestamp(columnLabel, cal);\n    }", "signature": "protected final Timestamp getTimestamp(final String columnLabel, final Calendar cal)"}, {"syntax_pass": true, "original_string": "    protected final int getType() throws SQLException {\n        return resultSet.getType();\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "int", "classes": []}, "name": "getType", "params": [], "body": "                                                      {\n        return resultSet.getType();\n    }", "signature": "protected final int getType()"}, {"syntax_pass": true, "original_string": "    @Deprecated\n    protected final InputStream getUnicodeStream(final int columnIndex) throws SQLException {\n        return resultSet.getUnicodeStream(columnIndex);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "@Deprecated\n    protected final", "marker_annotations": ["@Deprecated"], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "InputStream", "classes": []}, "name": "getUnicodeStream", "params": [{"name": "columnIndex", "type": "int"}], "body": "                                                                                            {\n        return resultSet.getUnicodeStream(columnIndex);\n    }", "signature": "@Deprecated\n    protected final InputStream getUnicodeStream(final int columnIndex)"}, {"syntax_pass": true, "original_string": "    @Deprecated\n    protected final InputStream getUnicodeStream(final String columnLabel) throws SQLException {\n        return resultSet.getUnicodeStream(columnLabel);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "@Deprecated\n    protected final", "marker_annotations": ["@Deprecated"], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "InputStream", "classes": []}, "name": "getUnicodeStream", "params": [{"name": "columnLabel", "type": "String"}], "body": "                                                                                               {\n        return resultSet.getUnicodeStream(columnLabel);\n    }", "signature": "@Deprecated\n    protected final InputStream getUnicodeStream(final String columnLabel)"}, {"syntax_pass": true, "original_string": "    protected final URL getURL(final int columnIndex) throws SQLException {\n        return resultSet.getURL(columnIndex);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "URL", "classes": []}, "name": "getURL", "params": [{"name": "columnIndex", "type": "int"}], "body": "                                                                          {\n        return resultSet.getURL(columnIndex);\n    }", "signature": "protected final URL getURL(final int columnIndex)"}, {"syntax_pass": true, "original_string": "    protected final URL getURL(final String columnLabel) throws SQLException {\n        return resultSet.getURL(columnLabel);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "URL", "classes": []}, "name": "getURL", "params": [{"name": "columnLabel", "type": "String"}], "body": "                                                                             {\n        return resultSet.getURL(columnLabel);\n    }", "signature": "protected final URL getURL(final String columnLabel)"}, {"syntax_pass": true, "original_string": "    protected final SQLWarning getWarnings() throws SQLException {\n        return resultSet.getWarnings();\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "SQLWarning", "classes": []}, "name": "getWarnings", "params": [], "body": "                                                                 {\n        return resultSet.getWarnings();\n    }", "signature": "protected final SQLWarning getWarnings()"}, {"syntax_pass": true, "original_string": "    protected abstract T handle() throws SQLException;", "docstring": "\nTurn the {@code ResultSet} into an Object.\n\n@return An Object initialized with {@code ResultSet} data\n@throws SQLException if a database access error occurs\n@see ResultSetHandler#handle(ResultSet)\n", "attributes": {"modifiers": "protected abstract", "marker_annotations": [], "non_marker_annotations": ["protected", "abstract"], "comments": [], "return_type": "T", "classes": []}, "name": "handle", "params": [], "body": "", "signature": "protected abstract T handle()"}, {"syntax_pass": true, "original_string": "    @Override\n    public final T handle(final ResultSet rs) throws SQLException {\n        if (this.resultSet != null) {\n            throw new IllegalStateException(\"Re-entry not allowed!\");\n        }\n\n        this.resultSet = rs;\n\n        try {\n            return handle();\n        } finally {\n            this.resultSet = null;\n        }\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "@Override\n    public final", "marker_annotations": ["@Override"], "non_marker_annotations": ["public", "final"], "comments": [], "return_type": "T", "classes": []}, "name": "handle", "params": [{"name": "rs", "type": "ResultSet"}], "body": "                                                                  {\n        if (this.resultSet != null) {\n            throw new IllegalStateException(\"Re-entry not allowed!\");\n        }\n\n        this.resultSet = rs;\n\n        try {\n            return handle();\n        } finally {\n            this.resultSet = null;\n        }\n    }", "signature": "@Override\n    public final T handle(final ResultSet rs)"}, {"syntax_pass": true, "original_string": "    protected final void insertRow() throws SQLException {\n        resultSet.insertRow();\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "insertRow", "params": [], "body": "                                                         {\n        resultSet.insertRow();\n    }", "signature": "protected final void insertRow()"}, {"syntax_pass": true, "original_string": "    protected final boolean isAfterLast() throws SQLException {\n        return resultSet.isAfterLast();\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isAfterLast", "params": [], "body": "                                                              {\n        return resultSet.isAfterLast();\n    }", "signature": "protected final boolean isAfterLast()"}, {"syntax_pass": true, "original_string": "    protected final boolean isBeforeFirst() throws SQLException {\n        return resultSet.isBeforeFirst();\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isBeforeFirst", "params": [], "body": "                                                                {\n        return resultSet.isBeforeFirst();\n    }", "signature": "protected final boolean isBeforeFirst()"}, {"syntax_pass": true, "original_string": "    protected final boolean isClosed() throws SQLException {\n        return resultSet.isClosed();\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isClosed", "params": [], "body": "                                                           {\n        return resultSet.isClosed();\n    }", "signature": "protected final boolean isClosed()"}, {"syntax_pass": true, "original_string": "    protected final boolean isFirst() throws SQLException {\n        return resultSet.isFirst();\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isFirst", "params": [], "body": "                                                          {\n        return resultSet.isFirst();\n    }", "signature": "protected final boolean isFirst()"}, {"syntax_pass": true, "original_string": "    protected final boolean isLast() throws SQLException {\n        return resultSet.isLast();\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isLast", "params": [], "body": "                                                         {\n        return resultSet.isLast();\n    }", "signature": "protected final boolean isLast()"}, {"syntax_pass": true, "original_string": "    protected final boolean isWrapperFor(final Class<?> iface) throws SQLException {\n        return resultSet.isWrapperFor(iface);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isWrapperFor", "params": [{"name": "iface", "type": "Class<?>"}], "body": "                                                                                   {\n        return resultSet.isWrapperFor(iface);\n    }", "signature": "protected final boolean isWrapperFor(final Class<?> iface)"}, {"syntax_pass": true, "original_string": "    protected final boolean last() throws SQLException {\n        return resultSet.last();\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "boolean", "classes": []}, "name": "last", "params": [], "body": "                                                       {\n        return resultSet.last();\n    }", "signature": "protected final boolean last()"}, {"syntax_pass": true, "original_string": "    protected final void moveToCurrentRow() throws SQLException {\n        resultSet.moveToCurrentRow();\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "moveToCurrentRow", "params": [], "body": "                                                                {\n        resultSet.moveToCurrentRow();\n    }", "signature": "protected final void moveToCurrentRow()"}, {"syntax_pass": true, "original_string": "    protected final void moveToInsertRow() throws SQLException {\n        resultSet.moveToInsertRow();\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "moveToInsertRow", "params": [], "body": "                                                               {\n        resultSet.moveToInsertRow();\n    }", "signature": "protected final void moveToInsertRow()"}, {"syntax_pass": true, "original_string": "    protected final boolean next() throws SQLException {\n        return resultSet.next();\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "boolean", "classes": []}, "name": "next", "params": [], "body": "                                                       {\n        return resultSet.next();\n    }", "signature": "protected final boolean next()"}, {"syntax_pass": true, "original_string": "    protected final boolean previous() throws SQLException {\n        return resultSet.previous();\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "boolean", "classes": []}, "name": "previous", "params": [], "body": "                                                           {\n        return resultSet.previous();\n    }", "signature": "protected final boolean previous()"}, {"syntax_pass": true, "original_string": "    protected final void refreshRow() throws SQLException {\n        resultSet.refreshRow();\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "refreshRow", "params": [], "body": "                                                          {\n        resultSet.refreshRow();\n    }", "signature": "protected final void refreshRow()"}, {"syntax_pass": true, "original_string": "    protected final boolean relative(final int rows) throws SQLException {\n        return resultSet.relative(rows);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "boolean", "classes": []}, "name": "relative", "params": [{"name": "rows", "type": "int"}], "body": "                                                                         {\n        return resultSet.relative(rows);\n    }", "signature": "protected final boolean relative(final int rows)"}, {"syntax_pass": true, "original_string": "    protected final boolean rowDeleted() throws SQLException {\n        return resultSet.rowDeleted();\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "boolean", "classes": []}, "name": "rowDeleted", "params": [], "body": "                                                             {\n        return resultSet.rowDeleted();\n    }", "signature": "protected final boolean rowDeleted()"}, {"syntax_pass": true, "original_string": "    protected final boolean rowInserted() throws SQLException {\n        return resultSet.rowInserted();\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "boolean", "classes": []}, "name": "rowInserted", "params": [], "body": "                                                              {\n        return resultSet.rowInserted();\n    }", "signature": "protected final boolean rowInserted()"}, {"syntax_pass": true, "original_string": "    protected final boolean rowUpdated() throws SQLException {\n        return resultSet.rowUpdated();\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "boolean", "classes": []}, "name": "rowUpdated", "params": [], "body": "                                                             {\n        return resultSet.rowUpdated();\n    }", "signature": "protected final boolean rowUpdated()"}, {"syntax_pass": true, "original_string": "    protected final void setFetchDirection(final int direction) throws SQLException {\n        resultSet.setFetchDirection(direction);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "setFetchDirection", "params": [{"name": "direction", "type": "int"}], "body": "                                                                                    {\n        resultSet.setFetchDirection(direction);\n    }", "signature": "protected final void setFetchDirection(final int direction)"}, {"syntax_pass": true, "original_string": "    protected final void setFetchSize(final int rows) throws SQLException {\n        resultSet.setFetchSize(rows);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "setFetchSize", "params": [{"name": "rows", "type": "int"}], "body": "                                                                          {\n        resultSet.setFetchSize(rows);\n    }", "signature": "protected final void setFetchSize(final int rows)"}, {"syntax_pass": true, "original_string": "    protected final <E> E unwrap(final Class<E> iface) throws SQLException {\n        return resultSet.unwrap(iface);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "E", "classes": []}, "name": "unwrap", "params": [{"name": "iface", "type": "Class<E>"}], "body": "                                                                           {\n        return resultSet.unwrap(iface);\n    }", "signature": "protected final <E> E unwrap(final Class<E> iface)"}, {"syntax_pass": true, "original_string": "    protected final void updateArray(final int columnIndex, final Array x) throws SQLException {\n        resultSet.updateArray(columnIndex, x);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateArray", "params": [{"name": "columnIndex", "type": "int"}, {"name": "x", "type": "Array"}], "body": "                                                                                               {\n        resultSet.updateArray(columnIndex, x);\n    }", "signature": "protected final void updateArray(final int columnIndex, final Array x)"}, {"syntax_pass": true, "original_string": "    protected final void updateArray(final String columnLabel, final Array x) throws SQLException {\n        resultSet.updateArray(columnLabel, x);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateArray", "params": [{"name": "columnLabel", "type": "String"}, {"name": "x", "type": "Array"}], "body": "                                                                                                  {\n        resultSet.updateArray(columnLabel, x);\n    }", "signature": "protected final void updateArray(final String columnLabel, final Array x)"}, {"syntax_pass": true, "original_string": "    protected final void updateAsciiStream(final int columnIndex, final InputStream x) throws SQLException {\n        resultSet.updateAsciiStream(columnIndex, x);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateAsciiStream", "params": [{"name": "columnIndex", "type": "int"}, {"name": "x", "type": "InputStream"}], "body": "                                                                                                           {\n        resultSet.updateAsciiStream(columnIndex, x);\n    }", "signature": "protected final void updateAsciiStream(final int columnIndex, final InputStream x)"}, {"syntax_pass": true, "original_string": "    protected final void updateAsciiStream(final int columnIndex, final InputStream x, final int length) throws SQLException {\n        resultSet.updateAsciiStream(columnIndex, x, length);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateAsciiStream", "params": [{"name": "columnIndex", "type": "int"}, {"name": "x", "type": "InputStream"}, {"name": "length", "type": "int"}], "body": "                                                                                                                             {\n        resultSet.updateAsciiStream(columnIndex, x, length);\n    }", "signature": "protected final void updateAsciiStream(final int columnIndex, final InputStream x, final int length)"}, {"syntax_pass": true, "original_string": "    protected final void updateAsciiStream(final int columnIndex, final InputStream x, final long length) throws SQLException {\n        resultSet.updateAsciiStream(columnIndex, x, length);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateAsciiStream", "params": [{"name": "columnIndex", "type": "int"}, {"name": "x", "type": "InputStream"}, {"name": "length", "type": "long"}], "body": "                                                                                                                              {\n        resultSet.updateAsciiStream(columnIndex, x, length);\n    }", "signature": "protected final void updateAsciiStream(final int columnIndex, final InputStream x, final long length)"}, {"syntax_pass": true, "original_string": "    protected final void updateAsciiStream(final String columnLabel, final InputStream x) throws SQLException {\n        resultSet.updateAsciiStream(columnLabel, x);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateAsciiStream", "params": [{"name": "columnLabel", "type": "String"}, {"name": "x", "type": "InputStream"}], "body": "                                                                                                              {\n        resultSet.updateAsciiStream(columnLabel, x);\n    }", "signature": "protected final void updateAsciiStream(final String columnLabel, final InputStream x)"}, {"syntax_pass": true, "original_string": "    protected final void updateAsciiStream(final String columnLabel, final InputStream x, final int length) throws SQLException {\n        resultSet.updateAsciiStream(columnLabel, x, length);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateAsciiStream", "params": [{"name": "columnLabel", "type": "String"}, {"name": "x", "type": "InputStream"}, {"name": "length", "type": "int"}], "body": "                                                                                                                                {\n        resultSet.updateAsciiStream(columnLabel, x, length);\n    }", "signature": "protected final void updateAsciiStream(final String columnLabel, final InputStream x, final int length)"}, {"syntax_pass": true, "original_string": "    protected final void updateAsciiStream(final String columnLabel, final InputStream x, final long length) throws SQLException {\n        resultSet.updateAsciiStream(columnLabel, x, length);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateAsciiStream", "params": [{"name": "columnLabel", "type": "String"}, {"name": "x", "type": "InputStream"}, {"name": "length", "type": "long"}], "body": "                                                                                                                                 {\n        resultSet.updateAsciiStream(columnLabel, x, length);\n    }", "signature": "protected final void updateAsciiStream(final String columnLabel, final InputStream x, final long length)"}, {"syntax_pass": true, "original_string": "    protected final void updateBigDecimal(final int columnIndex, final BigDecimal x) throws SQLException {\n        resultSet.updateBigDecimal(columnIndex, x);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateBigDecimal", "params": [{"name": "columnIndex", "type": "int"}, {"name": "x", "type": "BigDecimal"}], "body": "                                                                                                         {\n        resultSet.updateBigDecimal(columnIndex, x);\n    }", "signature": "protected final void updateBigDecimal(final int columnIndex, final BigDecimal x)"}, {"syntax_pass": true, "original_string": "    protected final void updateBigDecimal(final String columnLabel, final BigDecimal x) throws SQLException {\n        resultSet.updateBigDecimal(columnLabel, x);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateBigDecimal", "params": [{"name": "columnLabel", "type": "String"}, {"name": "x", "type": "BigDecimal"}], "body": "                                                                                                            {\n        resultSet.updateBigDecimal(columnLabel, x);\n    }", "signature": "protected final void updateBigDecimal(final String columnLabel, final BigDecimal x)"}, {"syntax_pass": true, "original_string": "    protected final void updateBinaryStream(final int columnIndex, final InputStream x) throws SQLException {\n        resultSet.updateBinaryStream(columnIndex, x);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateBinaryStream", "params": [{"name": "columnIndex", "type": "int"}, {"name": "x", "type": "InputStream"}], "body": "                                                                                                            {\n        resultSet.updateBinaryStream(columnIndex, x);\n    }", "signature": "protected final void updateBinaryStream(final int columnIndex, final InputStream x)"}, {"syntax_pass": true, "original_string": "    protected final void updateBinaryStream(final int columnIndex, final InputStream x, final int length) throws SQLException {\n        resultSet.updateBinaryStream(columnIndex, x, length);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateBinaryStream", "params": [{"name": "columnIndex", "type": "int"}, {"name": "x", "type": "InputStream"}, {"name": "length", "type": "int"}], "body": "                                                                                                                              {\n        resultSet.updateBinaryStream(columnIndex, x, length);\n    }", "signature": "protected final void updateBinaryStream(final int columnIndex, final InputStream x, final int length)"}, {"syntax_pass": true, "original_string": "    protected final void updateBinaryStream(final int columnIndex, final InputStream x, final long length) throws SQLException {\n        resultSet.updateBinaryStream(columnIndex, x, length);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateBinaryStream", "params": [{"name": "columnIndex", "type": "int"}, {"name": "x", "type": "InputStream"}, {"name": "length", "type": "long"}], "body": "                                                                                                                               {\n        resultSet.updateBinaryStream(columnIndex, x, length);\n    }", "signature": "protected final void updateBinaryStream(final int columnIndex, final InputStream x, final long length)"}, {"syntax_pass": true, "original_string": "    protected final void updateBinaryStream(final String columnLabel, final InputStream x) throws SQLException {\n        resultSet.updateBinaryStream(columnLabel, x);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateBinaryStream", "params": [{"name": "columnLabel", "type": "String"}, {"name": "x", "type": "InputStream"}], "body": "                                                                                                               {\n        resultSet.updateBinaryStream(columnLabel, x);\n    }", "signature": "protected final void updateBinaryStream(final String columnLabel, final InputStream x)"}, {"syntax_pass": true, "original_string": "    protected final void updateBinaryStream(final String columnLabel, final InputStream x, final int length) throws SQLException {\n        resultSet.updateBinaryStream(columnLabel, x, length);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateBinaryStream", "params": [{"name": "columnLabel", "type": "String"}, {"name": "x", "type": "InputStream"}, {"name": "length", "type": "int"}], "body": "                                                                                                                                 {\n        resultSet.updateBinaryStream(columnLabel, x, length);\n    }", "signature": "protected final void updateBinaryStream(final String columnLabel, final InputStream x, final int length)"}, {"syntax_pass": true, "original_string": "    protected final void updateBinaryStream(final String columnLabel, final InputStream x, final long length) throws SQLException {\n        resultSet.updateBinaryStream(columnLabel, x, length);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateBinaryStream", "params": [{"name": "columnLabel", "type": "String"}, {"name": "x", "type": "InputStream"}, {"name": "length", "type": "long"}], "body": "                                                                                                                                  {\n        resultSet.updateBinaryStream(columnLabel, x, length);\n    }", "signature": "protected final void updateBinaryStream(final String columnLabel, final InputStream x, final long length)"}, {"syntax_pass": true, "original_string": "    protected final void updateBlob(final int columnIndex, final Blob x) throws SQLException {\n        resultSet.updateBlob(columnIndex, x);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateBlob", "params": [{"name": "columnIndex", "type": "int"}, {"name": "x", "type": "Blob"}], "body": "                                                                                             {\n        resultSet.updateBlob(columnIndex, x);\n    }", "signature": "protected final void updateBlob(final int columnIndex, final Blob x)"}, {"syntax_pass": true, "original_string": "    protected final void updateBlob(final int columnIndex, final InputStream inputStream) throws SQLException {\n        resultSet.updateBlob(columnIndex, inputStream);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateBlob", "params": [{"name": "columnIndex", "type": "int"}, {"name": "inputStream", "type": "InputStream"}], "body": "                                                                                                              {\n        resultSet.updateBlob(columnIndex, inputStream);\n    }", "signature": "protected final void updateBlob(final int columnIndex, final InputStream inputStream)"}, {"syntax_pass": true, "original_string": "    protected final void updateBlob(final int columnIndex, final InputStream inputStream, final long length) throws SQLException {\n        resultSet.updateBlob(columnIndex, inputStream, length);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateBlob", "params": [{"name": "columnIndex", "type": "int"}, {"name": "inputStream", "type": "InputStream"}, {"name": "length", "type": "long"}], "body": "                                                                                                                                 {\n        resultSet.updateBlob(columnIndex, inputStream, length);\n    }", "signature": "protected final void updateBlob(final int columnIndex, final InputStream inputStream, final long length)"}, {"syntax_pass": true, "original_string": "    protected final void updateBlob(final String columnLabel, final Blob x) throws SQLException {\n        resultSet.updateBlob(columnLabel, x);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateBlob", "params": [{"name": "columnLabel", "type": "String"}, {"name": "x", "type": "Blob"}], "body": "                                                                                                {\n        resultSet.updateBlob(columnLabel, x);\n    }", "signature": "protected final void updateBlob(final String columnLabel, final Blob x)"}, {"syntax_pass": true, "original_string": "    protected final void updateBlob(final String columnLabel, final InputStream inputStream) throws SQLException {\n        resultSet.updateBlob(columnLabel, inputStream);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateBlob", "params": [{"name": "columnLabel", "type": "String"}, {"name": "inputStream", "type": "InputStream"}], "body": "                                                                                                                 {\n        resultSet.updateBlob(columnLabel, inputStream);\n    }", "signature": "protected final void updateBlob(final String columnLabel, final InputStream inputStream)"}, {"syntax_pass": true, "original_string": "    protected final void updateBlob(final String columnLabel, final InputStream inputStream, final long length) throws SQLException {\n        resultSet.updateBlob(columnLabel, inputStream, length);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateBlob", "params": [{"name": "columnLabel", "type": "String"}, {"name": "inputStream", "type": "InputStream"}, {"name": "length", "type": "long"}], "body": "                                                                                                                                    {\n        resultSet.updateBlob(columnLabel, inputStream, length);\n    }", "signature": "protected final void updateBlob(final String columnLabel, final InputStream inputStream, final long length)"}, {"syntax_pass": true, "original_string": "    protected final void updateBoolean(final int columnIndex, final boolean x) throws SQLException {\n        resultSet.updateBoolean(columnIndex, x);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateBoolean", "params": [{"name": "columnIndex", "type": "int"}, {"name": "x", "type": "boolean"}], "body": "                                                                                                   {\n        resultSet.updateBoolean(columnIndex, x);\n    }", "signature": "protected final void updateBoolean(final int columnIndex, final boolean x)"}, {"syntax_pass": true, "original_string": "    protected final void updateBoolean(final String columnLabel, final boolean x) throws SQLException {\n        resultSet.updateBoolean(columnLabel, x);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateBoolean", "params": [{"name": "columnLabel", "type": "String"}, {"name": "x", "type": "boolean"}], "body": "                                                                                                      {\n        resultSet.updateBoolean(columnLabel, x);\n    }", "signature": "protected final void updateBoolean(final String columnLabel, final boolean x)"}, {"syntax_pass": true, "original_string": "    protected final void updateByte(final int columnIndex, final byte x) throws SQLException {\n        resultSet.updateByte(columnIndex, x);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateByte", "params": [{"name": "columnIndex", "type": "int"}, {"name": "x", "type": "byte"}], "body": "                                                                                             {\n        resultSet.updateByte(columnIndex, x);\n    }", "signature": "protected final void updateByte(final int columnIndex, final byte x)"}, {"syntax_pass": true, "original_string": "    protected final void updateByte(final String columnLabel, final byte x) throws SQLException {\n        resultSet.updateByte(columnLabel, x);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateByte", "params": [{"name": "columnLabel", "type": "String"}, {"name": "x", "type": "byte"}], "body": "                                                                                                {\n        resultSet.updateByte(columnLabel, x);\n    }", "signature": "protected final void updateByte(final String columnLabel, final byte x)"}, {"syntax_pass": true, "original_string": "    protected final void updateBytes(final int columnIndex, final byte[] x) throws SQLException {\n        resultSet.updateBytes(columnIndex, x);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateBytes", "params": [{"name": "columnIndex", "type": "int"}, {"name": "x", "type": "byte[]"}], "body": "                                                                                                {\n        resultSet.updateBytes(columnIndex, x);\n    }", "signature": "protected final void updateBytes(final int columnIndex, final byte[] x)"}, {"syntax_pass": true, "original_string": "    protected final void updateBytes(final String columnLabel, final byte[] x) throws SQLException {\n        resultSet.updateBytes(columnLabel, x);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateBytes", "params": [{"name": "columnLabel", "type": "String"}, {"name": "x", "type": "byte[]"}], "body": "                                                                                                   {\n        resultSet.updateBytes(columnLabel, x);\n    }", "signature": "protected final void updateBytes(final String columnLabel, final byte[] x)"}, {"syntax_pass": true, "original_string": "    protected final void updateCharacterStream(final int columnIndex, final Reader x) throws SQLException {\n        resultSet.updateCharacterStream(columnIndex, x);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateCharacterStream", "params": [{"name": "columnIndex", "type": "int"}, {"name": "x", "type": "Reader"}], "body": "                                                                                                          {\n        resultSet.updateCharacterStream(columnIndex, x);\n    }", "signature": "protected final void updateCharacterStream(final int columnIndex, final Reader x)"}, {"syntax_pass": true, "original_string": "    protected final void updateCharacterStream(final int columnIndex, final Reader x, final int length) throws SQLException {\n        resultSet.updateCharacterStream(columnIndex, x, length);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateCharacterStream", "params": [{"name": "columnIndex", "type": "int"}, {"name": "x", "type": "Reader"}, {"name": "length", "type": "int"}], "body": "                                                                                                                            {\n        resultSet.updateCharacterStream(columnIndex, x, length);\n    }", "signature": "protected final void updateCharacterStream(final int columnIndex, final Reader x, final int length)"}, {"syntax_pass": true, "original_string": "    protected final void updateCharacterStream(final int columnIndex, final Reader x, final long length) throws SQLException {\n        resultSet.updateCharacterStream(columnIndex, x, length);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateCharacterStream", "params": [{"name": "columnIndex", "type": "int"}, {"name": "x", "type": "Reader"}, {"name": "length", "type": "long"}], "body": "                                                                                                                             {\n        resultSet.updateCharacterStream(columnIndex, x, length);\n    }", "signature": "protected final void updateCharacterStream(final int columnIndex, final Reader x, final long length)"}, {"syntax_pass": true, "original_string": "    protected final void updateCharacterStream(final String columnLabel, final Reader reader) throws SQLException {\n        resultSet.updateCharacterStream(columnLabel, reader);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateCharacterStream", "params": [{"name": "columnLabel", "type": "String"}, {"name": "reader", "type": "Reader"}], "body": "                                                                                                                  {\n        resultSet.updateCharacterStream(columnLabel, reader);\n    }", "signature": "protected final void updateCharacterStream(final String columnLabel, final Reader reader)"}, {"syntax_pass": true, "original_string": "    protected final void updateCharacterStream(final String columnLabel, final Reader reader, final int length) throws SQLException {\n        resultSet.updateCharacterStream(columnLabel, reader, length);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateCharacterStream", "params": [{"name": "columnLabel", "type": "String"}, {"name": "reader", "type": "Reader"}, {"name": "length", "type": "int"}], "body": "                                                                                                                                    {\n        resultSet.updateCharacterStream(columnLabel, reader, length);\n    }", "signature": "protected final void updateCharacterStream(final String columnLabel, final Reader reader, final int length)"}, {"syntax_pass": true, "original_string": "    protected final void updateCharacterStream(final String columnLabel, final Reader reader, final long length) throws SQLException {\n        resultSet.updateCharacterStream(columnLabel, reader, length);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateCharacterStream", "params": [{"name": "columnLabel", "type": "String"}, {"name": "reader", "type": "Reader"}, {"name": "length", "type": "long"}], "body": "                                                                                                                                     {\n        resultSet.updateCharacterStream(columnLabel, reader, length);\n    }", "signature": "protected final void updateCharacterStream(final String columnLabel, final Reader reader, final long length)"}, {"syntax_pass": true, "original_string": "    protected final void updateClob(final int columnIndex, final Clob x) throws SQLException {\n        resultSet.updateClob(columnIndex, x);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateClob", "params": [{"name": "columnIndex", "type": "int"}, {"name": "x", "type": "Clob"}], "body": "                                                                                             {\n        resultSet.updateClob(columnIndex, x);\n    }", "signature": "protected final void updateClob(final int columnIndex, final Clob x)"}, {"syntax_pass": true, "original_string": "    protected final void updateClob(final int columnIndex, final Reader reader) throws SQLException {\n        resultSet.updateClob(columnIndex, reader);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateClob", "params": [{"name": "columnIndex", "type": "int"}, {"name": "reader", "type": "Reader"}], "body": "                                                                                                    {\n        resultSet.updateClob(columnIndex, reader);\n    }", "signature": "protected final void updateClob(final int columnIndex, final Reader reader)"}, {"syntax_pass": true, "original_string": "    protected final void updateClob(final int columnIndex, final Reader reader, final long length) throws SQLException {\n        resultSet.updateClob(columnIndex, reader, length);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateClob", "params": [{"name": "columnIndex", "type": "int"}, {"name": "reader", "type": "Reader"}, {"name": "length", "type": "long"}], "body": "                                                                                                                       {\n        resultSet.updateClob(columnIndex, reader, length);\n    }", "signature": "protected final void updateClob(final int columnIndex, final Reader reader, final long length)"}, {"syntax_pass": true, "original_string": "    protected final void updateClob(final String columnLabel, final Clob x) throws SQLException {\n        resultSet.updateClob(columnLabel, x);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateClob", "params": [{"name": "columnLabel", "type": "String"}, {"name": "x", "type": "Clob"}], "body": "                                                                                                {\n        resultSet.updateClob(columnLabel, x);\n    }", "signature": "protected final void updateClob(final String columnLabel, final Clob x)"}, {"syntax_pass": true, "original_string": "    protected final void updateClob(final String columnLabel, final Reader reader) throws SQLException {\n        resultSet.updateClob(columnLabel, reader);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateClob", "params": [{"name": "columnLabel", "type": "String"}, {"name": "reader", "type": "Reader"}], "body": "                                                                                                       {\n        resultSet.updateClob(columnLabel, reader);\n    }", "signature": "protected final void updateClob(final String columnLabel, final Reader reader)"}, {"syntax_pass": true, "original_string": "    protected final void updateClob(final String columnLabel, final Reader reader, final long length) throws SQLException {\n        resultSet.updateClob(columnLabel, reader, length);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateClob", "params": [{"name": "columnLabel", "type": "String"}, {"name": "reader", "type": "Reader"}, {"name": "length", "type": "long"}], "body": "                                                                                                                          {\n        resultSet.updateClob(columnLabel, reader, length);\n    }", "signature": "protected final void updateClob(final String columnLabel, final Reader reader, final long length)"}, {"syntax_pass": true, "original_string": "    protected final void updateDate(final int columnIndex, final Date x) throws SQLException {\n        resultSet.updateDate(columnIndex, x);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateDate", "params": [{"name": "columnIndex", "type": "int"}, {"name": "x", "type": "Date"}], "body": "                                                                                             {\n        resultSet.updateDate(columnIndex, x);\n    }", "signature": "protected final void updateDate(final int columnIndex, final Date x)"}, {"syntax_pass": true, "original_string": "    protected final void updateDate(final String columnLabel, final Date x) throws SQLException {\n        resultSet.updateDate(columnLabel, x);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateDate", "params": [{"name": "columnLabel", "type": "String"}, {"name": "x", "type": "Date"}], "body": "                                                                                                {\n        resultSet.updateDate(columnLabel, x);\n    }", "signature": "protected final void updateDate(final String columnLabel, final Date x)"}, {"syntax_pass": true, "original_string": "    protected final void updateDouble(final int columnIndex, final double x) throws SQLException {\n        resultSet.updateDouble(columnIndex, x);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateDouble", "params": [{"name": "columnIndex", "type": "int"}, {"name": "x", "type": "double"}], "body": "                                                                                                 {\n        resultSet.updateDouble(columnIndex, x);\n    }", "signature": "protected final void updateDouble(final int columnIndex, final double x)"}, {"syntax_pass": true, "original_string": "    protected final void updateDouble(final String columnLabel, final double x) throws SQLException {\n        resultSet.updateDouble(columnLabel, x);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateDouble", "params": [{"name": "columnLabel", "type": "String"}, {"name": "x", "type": "double"}], "body": "                                                                                                    {\n        resultSet.updateDouble(columnLabel, x);\n    }", "signature": "protected final void updateDouble(final String columnLabel, final double x)"}, {"syntax_pass": true, "original_string": "    protected final void updateFloat(final int columnIndex, final float x) throws SQLException {\n        resultSet.updateFloat(columnIndex, x);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateFloat", "params": [{"name": "columnIndex", "type": "int"}, {"name": "x", "type": "float"}], "body": "                                                                                               {\n        resultSet.updateFloat(columnIndex, x);\n    }", "signature": "protected final void updateFloat(final int columnIndex, final float x)"}, {"syntax_pass": true, "original_string": "    protected final void updateFloat(final String columnLabel, final float x) throws SQLException {\n        resultSet.updateFloat(columnLabel, x);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateFloat", "params": [{"name": "columnLabel", "type": "String"}, {"name": "x", "type": "float"}], "body": "                                                                                                  {\n        resultSet.updateFloat(columnLabel, x);\n    }", "signature": "protected final void updateFloat(final String columnLabel, final float x)"}, {"syntax_pass": true, "original_string": "    protected final void updateInt(final int columnIndex, final int x) throws SQLException {\n        resultSet.updateInt(columnIndex, x);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateInt", "params": [{"name": "columnIndex", "type": "int"}, {"name": "x", "type": "int"}], "body": "                                                                                           {\n        resultSet.updateInt(columnIndex, x);\n    }", "signature": "protected final void updateInt(final int columnIndex, final int x)"}, {"syntax_pass": true, "original_string": "    protected final void updateInt(final String columnLabel, final int x) throws SQLException {\n        resultSet.updateInt(columnLabel, x);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateInt", "params": [{"name": "columnLabel", "type": "String"}, {"name": "x", "type": "int"}], "body": "                                                                                              {\n        resultSet.updateInt(columnLabel, x);\n    }", "signature": "protected final void updateInt(final String columnLabel, final int x)"}, {"syntax_pass": true, "original_string": "    protected final void updateLong(final int columnIndex, final long x) throws SQLException {\n        resultSet.updateLong(columnIndex, x);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateLong", "params": [{"name": "columnIndex", "type": "int"}, {"name": "x", "type": "long"}], "body": "                                                                                             {\n        resultSet.updateLong(columnIndex, x);\n    }", "signature": "protected final void updateLong(final int columnIndex, final long x)"}, {"syntax_pass": true, "original_string": "    protected final void updateLong(final String columnLabel, final long x) throws SQLException {\n        resultSet.updateLong(columnLabel, x);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateLong", "params": [{"name": "columnLabel", "type": "String"}, {"name": "x", "type": "long"}], "body": "                                                                                                {\n        resultSet.updateLong(columnLabel, x);\n    }", "signature": "protected final void updateLong(final String columnLabel, final long x)"}, {"syntax_pass": true, "original_string": "    protected final void updateNCharacterStream(final int columnIndex, final Reader x) throws SQLException {\n        resultSet.updateNCharacterStream(columnIndex, x);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateNCharacterStream", "params": [{"name": "columnIndex", "type": "int"}, {"name": "x", "type": "Reader"}], "body": "                                                                                                           {\n        resultSet.updateNCharacterStream(columnIndex, x);\n    }", "signature": "protected final void updateNCharacterStream(final int columnIndex, final Reader x)"}, {"syntax_pass": true, "original_string": "    protected final void updateNCharacterStream(final int columnIndex, final Reader x, final long length) throws SQLException {\n        resultSet.updateNCharacterStream(columnIndex, x, length);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateNCharacterStream", "params": [{"name": "columnIndex", "type": "int"}, {"name": "x", "type": "Reader"}, {"name": "length", "type": "long"}], "body": "                                                                                                                              {\n        resultSet.updateNCharacterStream(columnIndex, x, length);\n    }", "signature": "protected final void updateNCharacterStream(final int columnIndex, final Reader x, final long length)"}, {"syntax_pass": true, "original_string": "    protected final void updateNCharacterStream(final String columnLabel, final Reader reader) throws SQLException {\n        resultSet.updateNCharacterStream(columnLabel, reader);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateNCharacterStream", "params": [{"name": "columnLabel", "type": "String"}, {"name": "reader", "type": "Reader"}], "body": "                                                                                                                   {\n        resultSet.updateNCharacterStream(columnLabel, reader);\n    }", "signature": "protected final void updateNCharacterStream(final String columnLabel, final Reader reader)"}, {"syntax_pass": true, "original_string": "    protected final void updateNCharacterStream(final String columnLabel, final Reader reader, final long length) throws SQLException {\n        resultSet.updateNCharacterStream(columnLabel, reader, length);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateNCharacterStream", "params": [{"name": "columnLabel", "type": "String"}, {"name": "reader", "type": "Reader"}, {"name": "length", "type": "long"}], "body": "                                                                                                                                      {\n        resultSet.updateNCharacterStream(columnLabel, reader, length);\n    }", "signature": "protected final void updateNCharacterStream(final String columnLabel, final Reader reader, final long length)"}, {"syntax_pass": true, "original_string": "    protected final void updateNClob(final int columnIndex, final NClob nClob) throws SQLException {\n        resultSet.updateNClob(columnIndex, nClob);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateNClob", "params": [{"name": "columnIndex", "type": "int"}, {"name": "nClob", "type": "NClob"}], "body": "                                                                                                   {\n        resultSet.updateNClob(columnIndex, nClob);\n    }", "signature": "protected final void updateNClob(final int columnIndex, final NClob nClob)"}, {"syntax_pass": true, "original_string": "    protected final void updateNClob(final int columnIndex, final Reader reader) throws SQLException {\n        resultSet.updateNClob(columnIndex, reader);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateNClob", "params": [{"name": "columnIndex", "type": "int"}, {"name": "reader", "type": "Reader"}], "body": "                                                                                                     {\n        resultSet.updateNClob(columnIndex, reader);\n    }", "signature": "protected final void updateNClob(final int columnIndex, final Reader reader)"}, {"syntax_pass": true, "original_string": "    protected final void updateNClob(final int columnIndex, final Reader reader, final long length) throws SQLException {\n        resultSet.updateNClob(columnIndex, reader, length);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateNClob", "params": [{"name": "columnIndex", "type": "int"}, {"name": "reader", "type": "Reader"}, {"name": "length", "type": "long"}], "body": "                                                                                                                        {\n        resultSet.updateNClob(columnIndex, reader, length);\n    }", "signature": "protected final void updateNClob(final int columnIndex, final Reader reader, final long length)"}, {"syntax_pass": true, "original_string": "    protected final void updateNClob(final String columnLabel, final NClob nClob) throws SQLException {\n        resultSet.updateNClob(columnLabel, nClob);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateNClob", "params": [{"name": "columnLabel", "type": "String"}, {"name": "nClob", "type": "NClob"}], "body": "                                                                                                      {\n        resultSet.updateNClob(columnLabel, nClob);\n    }", "signature": "protected final void updateNClob(final String columnLabel, final NClob nClob)"}, {"syntax_pass": true, "original_string": "    protected final void updateNClob(final String columnLabel, final Reader reader) throws SQLException {\n        resultSet.updateNClob(columnLabel, reader);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateNClob", "params": [{"name": "columnLabel", "type": "String"}, {"name": "reader", "type": "Reader"}], "body": "                                                                                                        {\n        resultSet.updateNClob(columnLabel, reader);\n    }", "signature": "protected final void updateNClob(final String columnLabel, final Reader reader)"}, {"syntax_pass": true, "original_string": "    protected final void updateNClob(final String columnLabel, final Reader reader, final long length) throws SQLException {\n        resultSet.updateNClob(columnLabel, reader, length);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateNClob", "params": [{"name": "columnLabel", "type": "String"}, {"name": "reader", "type": "Reader"}, {"name": "length", "type": "long"}], "body": "                                                                                                                           {\n        resultSet.updateNClob(columnLabel, reader, length);\n    }", "signature": "protected final void updateNClob(final String columnLabel, final Reader reader, final long length)"}, {"syntax_pass": true, "original_string": "    protected final void updateNString(final int columnIndex, final String nString) throws SQLException {\n        resultSet.updateNString(columnIndex, nString);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateNString", "params": [{"name": "columnIndex", "type": "int"}, {"name": "nString", "type": "String"}], "body": "                                                                                                        {\n        resultSet.updateNString(columnIndex, nString);\n    }", "signature": "protected final void updateNString(final int columnIndex, final String nString)"}, {"syntax_pass": true, "original_string": "    protected final void updateNString(final String columnLabel, final String nString) throws SQLException {\n        resultSet.updateNString(columnLabel, nString);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateNString", "params": [{"name": "columnLabel", "type": "String"}, {"name": "nString", "type": "String"}], "body": "                                                                                                           {\n        resultSet.updateNString(columnLabel, nString);\n    }", "signature": "protected final void updateNString(final String columnLabel, final String nString)"}, {"syntax_pass": true, "original_string": "    protected final void updateNull(final int columnIndex) throws SQLException {\n        resultSet.updateNull(columnIndex);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateNull", "params": [{"name": "columnIndex", "type": "int"}], "body": "                                                                               {\n        resultSet.updateNull(columnIndex);\n    }", "signature": "protected final void updateNull(final int columnIndex)"}, {"syntax_pass": true, "original_string": "    protected final void updateNull(final String columnLabel) throws SQLException {\n        resultSet.updateNull(columnLabel);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateNull", "params": [{"name": "columnLabel", "type": "String"}], "body": "                                                                                  {\n        resultSet.updateNull(columnLabel);\n    }", "signature": "protected final void updateNull(final String columnLabel)"}, {"syntax_pass": true, "original_string": "    protected final void updateObject(final int columnIndex, final Object x) throws SQLException {\n        resultSet.updateObject(columnIndex, x);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateObject", "params": [{"name": "columnIndex", "type": "int"}, {"name": "x", "type": "Object"}], "body": "                                                                                                 {\n        resultSet.updateObject(columnIndex, x);\n    }", "signature": "protected final void updateObject(final int columnIndex, final Object x)"}, {"syntax_pass": true, "original_string": "    protected final void updateObject(final int columnIndex, final Object x, final int scaleOrLength) throws SQLException {\n        resultSet.updateObject(columnIndex, x, scaleOrLength);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateObject", "params": [{"name": "columnIndex", "type": "int"}, {"name": "x", "type": "Object"}, {"name": "scaleOrLength", "type": "int"}], "body": "                                                                                                                          {\n        resultSet.updateObject(columnIndex, x, scaleOrLength);\n    }", "signature": "protected final void updateObject(final int columnIndex, final Object x, final int scaleOrLength)"}, {"syntax_pass": true, "original_string": "    protected final void updateObject(final String columnLabel, final Object x) throws SQLException {\n        resultSet.updateObject(columnLabel, x);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateObject", "params": [{"name": "columnLabel", "type": "String"}, {"name": "x", "type": "Object"}], "body": "                                                                                                    {\n        resultSet.updateObject(columnLabel, x);\n    }", "signature": "protected final void updateObject(final String columnLabel, final Object x)"}, {"syntax_pass": true, "original_string": "    protected final void updateObject(final String columnLabel, final Object x, final int scaleOrLength) throws SQLException {\n        resultSet.updateObject(columnLabel, x, scaleOrLength);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateObject", "params": [{"name": "columnLabel", "type": "String"}, {"name": "x", "type": "Object"}, {"name": "scaleOrLength", "type": "int"}], "body": "                                                                                                                             {\n        resultSet.updateObject(columnLabel, x, scaleOrLength);\n    }", "signature": "protected final void updateObject(final String columnLabel, final Object x, final int scaleOrLength)"}, {"syntax_pass": true, "original_string": "    protected final void updateRef(final int columnIndex, final Ref x) throws SQLException {\n        resultSet.updateRef(columnIndex, x);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateRef", "params": [{"name": "columnIndex", "type": "int"}, {"name": "x", "type": "Ref"}], "body": "                                                                                           {\n        resultSet.updateRef(columnIndex, x);\n    }", "signature": "protected final void updateRef(final int columnIndex, final Ref x)"}, {"syntax_pass": true, "original_string": "    protected final void updateRef(final String columnLabel, final Ref x) throws SQLException {\n        resultSet.updateRef(columnLabel, x);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateRef", "params": [{"name": "columnLabel", "type": "String"}, {"name": "x", "type": "Ref"}], "body": "                                                                                              {\n        resultSet.updateRef(columnLabel, x);\n    }", "signature": "protected final void updateRef(final String columnLabel, final Ref x)"}, {"syntax_pass": true, "original_string": "    protected final void updateRow() throws SQLException {\n        resultSet.updateRow();\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateRow", "params": [], "body": "                                                         {\n        resultSet.updateRow();\n    }", "signature": "protected final void updateRow()"}, {"syntax_pass": true, "original_string": "    protected final void updateRowId(final int columnIndex, final RowId x) throws SQLException {\n        resultSet.updateRowId(columnIndex, x);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateRowId", "params": [{"name": "columnIndex", "type": "int"}, {"name": "x", "type": "RowId"}], "body": "                                                                                               {\n        resultSet.updateRowId(columnIndex, x);\n    }", "signature": "protected final void updateRowId(final int columnIndex, final RowId x)"}, {"syntax_pass": true, "original_string": "    protected final void updateRowId(final String columnLabel, final RowId x) throws SQLException {\n        resultSet.updateRowId(columnLabel, x);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateRowId", "params": [{"name": "columnLabel", "type": "String"}, {"name": "x", "type": "RowId"}], "body": "                                                                                                  {\n        resultSet.updateRowId(columnLabel, x);\n    }", "signature": "protected final void updateRowId(final String columnLabel, final RowId x)"}, {"syntax_pass": true, "original_string": "    protected final void updateShort(final int columnIndex, final short x) throws SQLException {\n        resultSet.updateShort(columnIndex, x);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateShort", "params": [{"name": "columnIndex", "type": "int"}, {"name": "x", "type": "short"}], "body": "                                                                                               {\n        resultSet.updateShort(columnIndex, x);\n    }", "signature": "protected final void updateShort(final int columnIndex, final short x)"}, {"syntax_pass": true, "original_string": "    protected final void updateShort(final String columnLabel, final short x) throws SQLException {\n        resultSet.updateShort(columnLabel, x);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateShort", "params": [{"name": "columnLabel", "type": "String"}, {"name": "x", "type": "short"}], "body": "                                                                                                  {\n        resultSet.updateShort(columnLabel, x);\n    }", "signature": "protected final void updateShort(final String columnLabel, final short x)"}, {"syntax_pass": true, "original_string": "    protected final void updateSQLXML(final int columnIndex, final SQLXML xmlObject) throws SQLException {\n        resultSet.updateSQLXML(columnIndex, xmlObject);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateSQLXML", "params": [{"name": "columnIndex", "type": "int"}, {"name": "xmlObject", "type": "SQLXML"}], "body": "                                                                                                         {\n        resultSet.updateSQLXML(columnIndex, xmlObject);\n    }", "signature": "protected final void updateSQLXML(final int columnIndex, final SQLXML xmlObject)"}, {"syntax_pass": true, "original_string": "    protected final void updateSQLXML(final String columnLabel, final SQLXML xmlObject) throws SQLException {\n        resultSet.updateSQLXML(columnLabel, xmlObject);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateSQLXML", "params": [{"name": "columnLabel", "type": "String"}, {"name": "xmlObject", "type": "SQLXML"}], "body": "                                                                                                            {\n        resultSet.updateSQLXML(columnLabel, xmlObject);\n    }", "signature": "protected final void updateSQLXML(final String columnLabel, final SQLXML xmlObject)"}, {"syntax_pass": true, "original_string": "    protected final void updateString(final int columnIndex, final String x) throws SQLException {\n        resultSet.updateString(columnIndex, x);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateString", "params": [{"name": "columnIndex", "type": "int"}, {"name": "x", "type": "String"}], "body": "                                                                                                 {\n        resultSet.updateString(columnIndex, x);\n    }", "signature": "protected final void updateString(final int columnIndex, final String x)"}, {"syntax_pass": true, "original_string": "    protected final void updateString(final String columnLabel, final String x) throws SQLException {\n        resultSet.updateString(columnLabel, x);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateString", "params": [{"name": "columnLabel", "type": "String"}, {"name": "x", "type": "String"}], "body": "                                                                                                    {\n        resultSet.updateString(columnLabel, x);\n    }", "signature": "protected final void updateString(final String columnLabel, final String x)"}, {"syntax_pass": true, "original_string": "    protected final void updateTime(final int columnIndex, final Time x) throws SQLException {\n        resultSet.updateTime(columnIndex, x);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateTime", "params": [{"name": "columnIndex", "type": "int"}, {"name": "x", "type": "Time"}], "body": "                                                                                             {\n        resultSet.updateTime(columnIndex, x);\n    }", "signature": "protected final void updateTime(final int columnIndex, final Time x)"}, {"syntax_pass": true, "original_string": "    protected final void updateTime(final String columnLabel, final Time x) throws SQLException {\n        resultSet.updateTime(columnLabel, x);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateTime", "params": [{"name": "columnLabel", "type": "String"}, {"name": "x", "type": "Time"}], "body": "                                                                                                {\n        resultSet.updateTime(columnLabel, x);\n    }", "signature": "protected final void updateTime(final String columnLabel, final Time x)"}, {"syntax_pass": true, "original_string": "    protected final void updateTimestamp(final int columnIndex, final Timestamp x) throws SQLException {\n        resultSet.updateTimestamp(columnIndex, x);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateTimestamp", "params": [{"name": "columnIndex", "type": "int"}, {"name": "x", "type": "Timestamp"}], "body": "                                                                                                       {\n        resultSet.updateTimestamp(columnIndex, x);\n    }", "signature": "protected final void updateTimestamp(final int columnIndex, final Timestamp x)"}, {"syntax_pass": true, "original_string": "    protected final void updateTimestamp(final String columnLabel, final Timestamp x) throws SQLException {\n        resultSet.updateTimestamp(columnLabel, x);\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "updateTimestamp", "params": [{"name": "columnLabel", "type": "String"}, {"name": "x", "type": "Timestamp"}], "body": "                                                                                                          {\n        resultSet.updateTimestamp(columnLabel, x);\n    }", "signature": "protected final void updateTimestamp(final String columnLabel, final Timestamp x)"}, {"syntax_pass": true, "original_string": "    protected final boolean wasNull() throws SQLException {\n        return resultSet.wasNull();\n    }", "docstring": "\nTODO.\n", "attributes": {"modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "boolean", "classes": []}, "name": "wasNull", "params": [], "body": "                                                          {\n        return resultSet.wasNull();\n    }", "signature": "protected final boolean wasNull()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/apache/commons/dbutils/RowProcessor.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils;\n\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * {@code RowProcessor} implementations convert\n * {@code ResultSet} rows into various other objects.  Implementations\n * can extend {@code BasicRowProcessor} to protect themselves\n * from changes to this interface.\n *\n * @see BasicRowProcessor\n */\npublic interface RowProcessor {\n\n    /**\n     * Create an {@code Object[]} from the column values in one\n     * {@code ResultSet} row.  The {@code ResultSet} should be\n     * positioned on a valid row before passing it to this method.\n     * Implementations of this method must not alter the row position of\n     * the {@code ResultSet}.\n     *\n     * @param resultSet ResultSet that supplies the array data\n     * @throws SQLException if a database access error occurs\n     * @return the newly created array\n     */\n    Object[] toArray(ResultSet resultSet) throws SQLException;\n\n    /**\n     * Create a JavaBean from the column values in one {@code ResultSet}\n     * row.  The {@code ResultSet} should be positioned on a valid row before\n     * passing it to this method.  Implementations of this method must not\n     * alter the row position of the {@code ResultSet}.\n     * @param <T> The type of bean to create\n     * @param resultSet ResultSet that supplies the bean data\n     * @param type Class from which to create the bean instance\n     * @throws SQLException if a database access error occurs\n     * @return the newly created bean\n     */\n    <T> T toBean(ResultSet resultSet, Class<? extends T> type) throws SQLException;\n\n    /**\n     * Create a {@code List} of JavaBeans from the column values in all\n     * {@code ResultSet} rows.  {@code ResultSet.next()} should\n     * <strong>not</strong> be called before passing it to this method.\n     * @param <T> The type of bean to create\n     * @param resultSet ResultSet that supplies the bean data\n     * @param type Class from which to create the bean instance\n     * @throws SQLException if a database access error occurs\n     * @return A {@code List} of beans with the given type in the order\n     * they were returned by the {@code ResultSet}.\n     */\n    <T> List<T> toBeanList(ResultSet resultSet, Class<? extends T> type) throws SQLException;\n\n    /**\n     * Create a {@code Map} from the column values in one\n     * {@code ResultSet} row.  The {@code ResultSet} should be\n     * positioned on a valid row before\n     * passing it to this method.  Implementations of this method must not\n     * alter the row position of the {@code ResultSet}.\n     *\n     * @param resultSet ResultSet that supplies the map data\n     * @throws SQLException if a database access error occurs\n     * @return the newly created Map\n     */\n    Map<String, Object> toMap(ResultSet resultSet) throws SQLException;\n\n}\n", "file_hash": "12d5d5bc552c3b468d70ad7511123e1879b6916730f27666d48e07d528e8e6fe", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils;", "import java.sql.ResultSet;", "import java.sql.SQLException;", "import java.util.List;", "import java.util.Map;"], "methods": [], "classes": [], "interfaces": [{"original_string": "public interface RowProcessor {\n\n    /**\n     * Create an {@code Object[]} from the column values in one\n     * {@code ResultSet} row.  The {@code ResultSet} should be\n     * positioned on a valid row before passing it to this method.\n     * Implementations of this method must not alter the row position of\n     * the {@code ResultSet}.\n     *\n     * @param resultSet ResultSet that supplies the array data\n     * @throws SQLException if a database access error occurs\n     * @return the newly created array\n     */\n    Object[] toArray(ResultSet resultSet) throws SQLException;\n\n    /**\n     * Create a JavaBean from the column values in one {@code ResultSet}\n     * row.  The {@code ResultSet} should be positioned on a valid row before\n     * passing it to this method.  Implementations of this method must not\n     * alter the row position of the {@code ResultSet}.\n     * @param <T> The type of bean to create\n     * @param resultSet ResultSet that supplies the bean data\n     * @param type Class from which to create the bean instance\n     * @throws SQLException if a database access error occurs\n     * @return the newly created bean\n     */\n    <T> T toBean(ResultSet resultSet, Class<? extends T> type) throws SQLException;\n\n    /**\n     * Create a {@code List} of JavaBeans from the column values in all\n     * {@code ResultSet} rows.  {@code ResultSet.next()} should\n     * <strong>not</strong> be called before passing it to this method.\n     * @param <T> The type of bean to create\n     * @param resultSet ResultSet that supplies the bean data\n     * @param type Class from which to create the bean instance\n     * @throws SQLException if a database access error occurs\n     * @return A {@code List} of beans with the given type in the order\n     * they were returned by the {@code ResultSet}.\n     */\n    <T> List<T> toBeanList(ResultSet resultSet, Class<? extends T> type) throws SQLException;\n\n    /**\n     * Create a {@code Map} from the column values in one\n     * {@code ResultSet} row.  The {@code ResultSet} should be\n     * positioned on a valid row before\n     * passing it to this method.  Implementations of this method must not\n     * alter the row position of the {@code ResultSet}.\n     *\n     * @param resultSet ResultSet that supplies the map data\n     * @throws SQLException if a database access error occurs\n     * @return the newly created Map\n     */\n    Map<String, Object> toMap(ResultSet resultSet) throws SQLException;\n\n}", "definition": "public interface RowProcessor", "interface_docstring": "\n{@code RowProcessor} implementations convert\n{@code ResultSet} rows into various other objects.  Implementations\ncan extend {@code BasicRowProcessor} to protect themselves\nfrom changes to this interface.\n\n@see BasicRowProcessor\n", "name": "RowProcessor", "extends_interfaces": [], "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    Object[] toArray(ResultSet resultSet) throws SQLException;", "docstring": "\nCreate an {@code Object[]} from the column values in one\n{@code ResultSet} row.  The {@code ResultSet} should be\npositioned on a valid row before passing it to this method.\nImplementations of this method must not alter the row position of\nthe {@code ResultSet}.\n\n@param resultSet ResultSet that supplies the array data\n@throws SQLException if a database access error occurs\n@return the newly created array\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Object[]", "classes": []}, "name": "toArray", "params": [{"name": "resultSet", "type": "ResultSet"}], "body": "", "signature": "Object[] toArray(ResultSet resultSet)"}, {"syntax_pass": true, "original_string": "    <T> T toBean(ResultSet resultSet, Class<? extends T> type) throws SQLException;", "docstring": "\nCreate a JavaBean from the column values in one {@code ResultSet}\nrow.  The {@code ResultSet} should be positioned on a valid row before\npassing it to this method.  Implementations of this method must not\nalter the row position of the {@code ResultSet}.\n@param <T> The type of bean to create\n@param resultSet ResultSet that supplies the bean data\n@param type Class from which to create the bean instance\n@throws SQLException if a database access error occurs\n@return the newly created bean\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "T", "classes": []}, "name": "toBean", "params": [{"name": "resultSet", "type": "ResultSet"}, {"name": "type", "type": "Class<? extends T>"}], "body": "", "signature": "<T> T toBean(ResultSet resultSet, Class<? extends T> type)"}, {"syntax_pass": true, "original_string": "    <T> List<T> toBeanList(ResultSet resultSet, Class<? extends T> type) throws SQLException;", "docstring": "\nCreate a {@code List} of JavaBeans from the column values in all\n{@code ResultSet} rows.  {@code ResultSet.next()} should\n<strong>not</strong> be called before passing it to this method.\n@param <T> The type of bean to create\n@param resultSet ResultSet that supplies the bean data\n@param type Class from which to create the bean instance\n@throws SQLException if a database access error occurs\n@return A {@code List} of beans with the given type in the order\nthey were returned by the {@code ResultSet}.\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "List<T>", "classes": []}, "name": "toBeanList", "params": [{"name": "resultSet", "type": "ResultSet"}, {"name": "type", "type": "Class<? extends T>"}], "body": "", "signature": "<T> List<T> toBeanList(ResultSet resultSet, Class<? extends T> type)"}, {"syntax_pass": true, "original_string": "    Map<String, Object> toMap(ResultSet resultSet) throws SQLException;", "docstring": "\nCreate a {@code Map} from the column values in one\n{@code ResultSet} row.  The {@code ResultSet} should be\npositioned on a valid row before\npassing it to this method.  Implementations of this method must not\nalter the row position of the {@code ResultSet}.\n\n@param resultSet ResultSet that supplies the map data\n@throws SQLException if a database access error occurs\n@return the newly created Map\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Map<String, Object>", "classes": []}, "name": "toMap", "params": [{"name": "resultSet", "type": "ResultSet"}], "body": "", "signature": "Map<String, Object> toMap(ResultSet resultSet)"}]}], "records": []}, {"relative_path": "src/main/java/org/apache/commons/dbutils/DbUtils.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils;\n\nimport static java.sql.DriverManager.registerDriver;\n\nimport java.io.PrintWriter;\nimport java.lang.reflect.Constructor;\nimport java.sql.Connection;\nimport java.sql.Driver;\nimport java.sql.DriverPropertyInfo;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.SQLFeatureNotSupportedException;\nimport java.sql.Statement;\nimport java.util.Properties;\nimport java.util.logging.Logger;\n\n/**\n * A collection of JDBC helper methods.  This class is thread safe.\n */\npublic final class DbUtils {\n\n    /**\n     * Simple {@link Driver} proxy class that proxies a JDBC Driver loaded dynamically.\n     *\n     * @since 1.6\n     */\n    static final class DriverProxy implements Driver {\n\n        /**\n         * The adapted JDBC Driver loaded dynamically.\n         */\n        private final Driver adapted;\n\n        /**\n         * Creates a new JDBC Driver that adapts a JDBC Driver loaded dynamically.\n         *\n         * @param adapted the adapted JDBC Driver loaded dynamically.\n         */\n        public DriverProxy(final Driver adapted) {\n            this.adapted = adapted;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public boolean acceptsURL(final String url) throws SQLException {\n            return adapted.acceptsURL(url);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public Connection connect(final String url, final Properties info) throws SQLException {\n            return adapted.connect(url, info);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public int getMajorVersion() {\n            return adapted.getMajorVersion();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public int getMinorVersion() {\n            return adapted.getMinorVersion();\n        }\n\n        /**\n         * Java 1.7 method.\n         */\n        @Override\n        public Logger getParentLogger() throws SQLFeatureNotSupportedException {\n            return adapted.getParentLogger();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public DriverPropertyInfo[] getPropertyInfo(final String url, final Properties info) throws SQLException {\n            return adapted.getPropertyInfo(url, info);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public boolean jdbcCompliant() {\n            return adapted.jdbcCompliant();\n        }\n\n    }\n\n    /**\n     * Close a {@code Connection}, avoid closing if null.\n     *\n     * @param conn Connection to close.\n     * @throws SQLException if a database access error occurs\n     */\n    public static void close(final Connection conn) throws SQLException {\n        if (conn != null) {\n            conn.close();\n        }\n    }\n\n    /**\n     * Close a {@code ResultSet}, avoid closing if null.\n     *\n     * @param resultSet ResultSet to close.\n     * @throws SQLException if a database access error occurs\n     */\n    public static void close(final ResultSet resultSet) throws SQLException {\n        if (resultSet != null) {\n            resultSet.close();\n        }\n    }\n\n    /**\n     * Close a {@code Statement}, avoid closing if null.\n     *\n     * @param stmt Statement to close.\n     * @throws SQLException if a database access error occurs\n     */\n    public static void close(final Statement stmt) throws SQLException {\n        if (stmt != null) {\n            stmt.close();\n        }\n    }\n\n    /**\n     * Close a {@code Connection}, avoid closing if null and hide\n     * any SQLExceptions that occur.\n     *\n     * @param conn Connection to close.\n     */\n    public static void closeQuietly(final Connection conn) {\n        try {\n            close(conn);\n        } catch (final SQLException e) { // NOPMD\n            // quiet\n        }\n    }\n\n    /**\n     * Close a {@code Connection}, {@code Statement} and\n     * {@code ResultSet}.  Avoid closing if null and hide any\n     * SQLExceptions that occur.\n     *\n     * @param conn Connection to close.\n     * @param stmt Statement to close.\n     * @param rs ResultSet to close.\n     */\n    public static void closeQuietly(final Connection conn, final Statement stmt,\n            final ResultSet rs) {\n\n        try {\n            closeQuietly(rs);\n        } finally {\n            try {\n                closeQuietly(stmt);\n            } finally {\n                closeQuietly(conn);\n            }\n        }\n\n    }\n\n    /**\n     * Close a {@code ResultSet}, avoid closing if null and hide any\n     * SQLExceptions that occur.\n     *\n     * @param resultSet ResultSet to close.\n     */\n    public static void closeQuietly(final ResultSet resultSet) {\n        try {\n            close(resultSet);\n        } catch (final SQLException e) { // NOPMD\n            // quiet\n        }\n    }\n\n    /**\n     * Close a {@code Statement}, avoid closing if null and hide\n     * any SQLExceptions that occur.\n     *\n     * @param stmt Statement to close.\n     */\n    public static void closeQuietly(final Statement stmt) {\n        try {\n            close(stmt);\n        } catch (final SQLException e) { // NOPMD\n            // quiet\n        }\n    }\n\n    /**\n     * Commits a {@code Connection} then closes it, avoid closing if null.\n     *\n     * @param conn Connection to close.\n     * @throws SQLException if a database access error occurs\n     */\n    public static void commitAndClose(final Connection conn) throws SQLException {\n        if (conn != null) {\n            try {\n                conn.commit();\n            } finally {\n                conn.close();\n            }\n        }\n    }\n\n    /**\n     * Commits a {@code Connection} then closes it, avoid closing if null\n     * and hide any SQLExceptions that occur.\n     *\n     * @param conn Connection to close.\n     */\n    public static void commitAndCloseQuietly(final Connection conn) {\n        try {\n            commitAndClose(conn);\n        } catch (final SQLException e) { // NOPMD\n            // quiet\n        }\n    }\n\n    /**\n     * Loads and registers a database driver class.\n     * If this succeeds, it returns true, else it returns false.\n     *\n     * @param classLoader the class loader used to load the driver class\n     * @param driverClassName of driver to load\n     * @return boolean {@code true} if the driver was found, otherwise {@code false}\n     * @since 1.4\n     */\n    public static boolean loadDriver(final ClassLoader classLoader, final String driverClassName) {\n        try {\n            final Class<?> loadedClass = classLoader.loadClass(driverClassName);\n\n            if (!Driver.class.isAssignableFrom(loadedClass)) {\n                return false;\n            }\n\n            @SuppressWarnings(\"unchecked\") // guarded by previous check\n            final\n            Class<Driver> driverClass = (Class<Driver>) loadedClass;\n            final Constructor<Driver> driverConstructor = driverClass.getConstructor();\n\n            // make Constructor accessible if it is private\n            @SuppressWarnings(\"deprecation\")\n            // TODO This is deprecated in Java9 and canAccess() should be used. Adding suppression for building on\n            //      later JDKs without a warning.\n            final boolean isConstructorAccessible = driverConstructor.isAccessible();\n            if (!isConstructorAccessible) {\n                driverConstructor.setAccessible(true);\n            }\n\n            try {\n                final Driver driver = driverConstructor.newInstance();\n                registerDriver(new DriverProxy(driver));\n            } finally {\n                driverConstructor.setAccessible(isConstructorAccessible);\n            }\n\n            return true;\n        } catch (final Exception e) {\n            return false;\n        }\n    }\n\n    /**\n     * Loads and registers a database driver class.\n     * If this succeeds, it returns true, else it returns false.\n     *\n     * @param driverClassName of driver to load\n     * @return boolean {@code true} if the driver was found, otherwise {@code false}\n     */\n    public static boolean loadDriver(final String driverClassName) {\n        return loadDriver(DbUtils.class.getClassLoader(), driverClassName);\n    }\n\n    /**\n     * Print the stack trace for a SQLException to STDERR.\n     *\n     * @param e SQLException to print stack trace of\n     */\n    public static void printStackTrace(final SQLException e) {\n        printStackTrace(e, new PrintWriter(System.err));\n    }\n\n    /**\n     * Print the stack trace for a SQLException to a\n     * specified PrintWriter.\n     *\n     * @param e SQLException to print stack trace of\n     * @param pw PrintWriter to print to\n     */\n    public static void printStackTrace(final SQLException e, final PrintWriter pw) {\n\n        SQLException next = e;\n        while (next != null) {\n            next.printStackTrace(pw);\n            next = next.getNextException();\n            if (next != null) {\n                pw.println(\"Next SQLException:\");\n            }\n        }\n    }\n\n    /**\n     * Print warnings on a Connection to STDERR.\n     *\n     * @param conn Connection to print warnings from\n     */\n    public static void printWarnings(final Connection conn) {\n        printWarnings(conn, new PrintWriter(System.err));\n    }\n\n    /**\n     * Print warnings on a Connection to a specified PrintWriter.\n     *\n     * @param conn Connection to print warnings from\n     * @param pw PrintWriter to print to\n     */\n    public static void printWarnings(final Connection conn, final PrintWriter pw) {\n        if (conn != null) {\n            try {\n                printStackTrace(conn.getWarnings(), pw);\n            } catch (final SQLException e) {\n                printStackTrace(e, pw);\n            }\n        }\n    }\n\n    /**\n     * Rollback any changes made on the given connection.\n     * @param conn Connection to rollback.  A null value is legal.\n     * @throws SQLException if a database access error occurs\n     */\n    public static void rollback(final Connection conn) throws SQLException {\n        if (conn != null) {\n            conn.rollback();\n        }\n    }\n\n    /**\n     * Performs a rollback on the {@code Connection} then closes it,\n     * avoid closing if null.\n     *\n     * @param conn Connection to rollback.  A null value is legal.\n     * @throws SQLException if a database access error occurs\n     * @since 1.1\n     */\n    public static void rollbackAndClose(final Connection conn) throws SQLException {\n        if (conn != null) {\n            try {\n                conn.rollback();\n            } finally {\n                conn.close();\n            }\n        }\n    }\n\n    /**\n     * Performs a rollback on the {@code Connection} then closes it,\n     * avoid closing if null and hide any SQLExceptions that occur.\n     *\n     * @param conn Connection to rollback.  A null value is legal.\n     * @since 1.1\n     */\n    public static void rollbackAndCloseQuietly(final Connection conn) {\n        try {\n            rollbackAndClose(conn);\n        } catch (final SQLException e) { // NOPMD\n            // quiet\n        }\n    }\n\n    /**\n     * Performs a rollback on the {@code Connection}, avoid\n     * closing if null and hide any SQLExceptions that occur.\n     *\n     * @param conn Connection to rollback.  A null value is legal.\n     * @since DbUtils 2.0\n     */\n    public static void rollbackQuietly(final Connection conn) {\n        try {\n            rollback(conn);\n        } catch (final SQLException e) { // NOPMD\n            // quiet\n        }\n    }\n\n    /**\n     * Default constructor.\n     *\n     * Utility classes should not have a public or default constructor,\n     * but this one preserves retro-compatibility.\n     *\n     * @since 1.4\n     */\n    public DbUtils() {\n        // do nothing\n    }\n\n}\n", "file_hash": "e3956cbd9e2a332ec1b0335b7268bbc14667a6d3832298bdcc31b12b021020cc", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils;", "import static java.sql.DriverManager.registerDriver;", "import java.io.PrintWriter;", "import java.lang.reflect.Constructor;", "import java.sql.Connection;", "import java.sql.Driver;", "import java.sql.DriverPropertyInfo;", "import java.sql.ResultSet;", "import java.sql.SQLException;", "import java.sql.SQLFeatureNotSupportedException;", "import java.sql.Statement;", "import java.util.Properties;", "import java.util.logging.Logger;"], "methods": [], "classes": [{"original_string": "public final class DbUtils {\n\n    /**\n     * Simple {@link Driver} proxy class that proxies a JDBC Driver loaded dynamically.\n     *\n     * @since 1.6\n     */\n    static final class DriverProxy implements Driver {\n\n        /**\n         * The adapted JDBC Driver loaded dynamically.\n         */\n        private final Driver adapted;\n\n        /**\n         * Creates a new JDBC Driver that adapts a JDBC Driver loaded dynamically.\n         *\n         * @param adapted the adapted JDBC Driver loaded dynamically.\n         */\n        public DriverProxy(final Driver adapted) {\n            this.adapted = adapted;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public boolean acceptsURL(final String url) throws SQLException {\n            return adapted.acceptsURL(url);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public Connection connect(final String url, final Properties info) throws SQLException {\n            return adapted.connect(url, info);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public int getMajorVersion() {\n            return adapted.getMajorVersion();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public int getMinorVersion() {\n            return adapted.getMinorVersion();\n        }\n\n        /**\n         * Java 1.7 method.\n         */\n        @Override\n        public Logger getParentLogger() throws SQLFeatureNotSupportedException {\n            return adapted.getParentLogger();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public DriverPropertyInfo[] getPropertyInfo(final String url, final Properties info) throws SQLException {\n            return adapted.getPropertyInfo(url, info);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public boolean jdbcCompliant() {\n            return adapted.jdbcCompliant();\n        }\n\n    }\n\n    /**\n     * Close a {@code Connection}, avoid closing if null.\n     *\n     * @param conn Connection to close.\n     * @throws SQLException if a database access error occurs\n     */\n    public static void close(final Connection conn) throws SQLException {\n        if (conn != null) {\n            conn.close();\n        }\n    }\n\n    /**\n     * Close a {@code ResultSet}, avoid closing if null.\n     *\n     * @param resultSet ResultSet to close.\n     * @throws SQLException if a database access error occurs\n     */\n    public static void close(final ResultSet resultSet) throws SQLException {\n        if (resultSet != null) {\n            resultSet.close();\n        }\n    }\n\n    /**\n     * Close a {@code Statement}, avoid closing if null.\n     *\n     * @param stmt Statement to close.\n     * @throws SQLException if a database access error occurs\n     */\n    public static void close(final Statement stmt) throws SQLException {\n        if (stmt != null) {\n            stmt.close();\n        }\n    }\n\n    /**\n     * Close a {@code Connection}, avoid closing if null and hide\n     * any SQLExceptions that occur.\n     *\n     * @param conn Connection to close.\n     */\n    public static void closeQuietly(final Connection conn) {\n        try {\n            close(conn);\n        } catch (final SQLException e) { // NOPMD\n            // quiet\n        }\n    }\n\n    /**\n     * Close a {@code Connection}, {@code Statement} and\n     * {@code ResultSet}.  Avoid closing if null and hide any\n     * SQLExceptions that occur.\n     *\n     * @param conn Connection to close.\n     * @param stmt Statement to close.\n     * @param rs ResultSet to close.\n     */\n    public static void closeQuietly(final Connection conn, final Statement stmt,\n            final ResultSet rs) {\n\n        try {\n            closeQuietly(rs);\n        } finally {\n            try {\n                closeQuietly(stmt);\n            } finally {\n                closeQuietly(conn);\n            }\n        }\n\n    }\n\n    /**\n     * Close a {@code ResultSet}, avoid closing if null and hide any\n     * SQLExceptions that occur.\n     *\n     * @param resultSet ResultSet to close.\n     */\n    public static void closeQuietly(final ResultSet resultSet) {\n        try {\n            close(resultSet);\n        } catch (final SQLException e) { // NOPMD\n            // quiet\n        }\n    }\n\n    /**\n     * Close a {@code Statement}, avoid closing if null and hide\n     * any SQLExceptions that occur.\n     *\n     * @param stmt Statement to close.\n     */\n    public static void closeQuietly(final Statement stmt) {\n        try {\n            close(stmt);\n        } catch (final SQLException e) { // NOPMD\n            // quiet\n        }\n    }\n\n    /**\n     * Commits a {@code Connection} then closes it, avoid closing if null.\n     *\n     * @param conn Connection to close.\n     * @throws SQLException if a database access error occurs\n     */\n    public static void commitAndClose(final Connection conn) throws SQLException {\n        if (conn != null) {\n            try {\n                conn.commit();\n            } finally {\n                conn.close();\n            }\n        }\n    }\n\n    /**\n     * Commits a {@code Connection} then closes it, avoid closing if null\n     * and hide any SQLExceptions that occur.\n     *\n     * @param conn Connection to close.\n     */\n    public static void commitAndCloseQuietly(final Connection conn) {\n        try {\n            commitAndClose(conn);\n        } catch (final SQLException e) { // NOPMD\n            // quiet\n        }\n    }\n\n    /**\n     * Loads and registers a database driver class.\n     * If this succeeds, it returns true, else it returns false.\n     *\n     * @param classLoader the class loader used to load the driver class\n     * @param driverClassName of driver to load\n     * @return boolean {@code true} if the driver was found, otherwise {@code false}\n     * @since 1.4\n     */\n    public static boolean loadDriver(final ClassLoader classLoader, final String driverClassName) {\n        try {\n            final Class<?> loadedClass = classLoader.loadClass(driverClassName);\n\n            if (!Driver.class.isAssignableFrom(loadedClass)) {\n                return false;\n            }\n\n            @SuppressWarnings(\"unchecked\") // guarded by previous check\n            final\n            Class<Driver> driverClass = (Class<Driver>) loadedClass;\n            final Constructor<Driver> driverConstructor = driverClass.getConstructor();\n\n            // make Constructor accessible if it is private\n            @SuppressWarnings(\"deprecation\")\n            // TODO This is deprecated in Java9 and canAccess() should be used. Adding suppression for building on\n            //      later JDKs without a warning.\n            final boolean isConstructorAccessible = driverConstructor.isAccessible();\n            if (!isConstructorAccessible) {\n                driverConstructor.setAccessible(true);\n            }\n\n            try {\n                final Driver driver = driverConstructor.newInstance();\n                registerDriver(new DriverProxy(driver));\n            } finally {\n                driverConstructor.setAccessible(isConstructorAccessible);\n            }\n\n            return true;\n        } catch (final Exception e) {\n            return false;\n        }\n    }\n\n    /**\n     * Loads and registers a database driver class.\n     * If this succeeds, it returns true, else it returns false.\n     *\n     * @param driverClassName of driver to load\n     * @return boolean {@code true} if the driver was found, otherwise {@code false}\n     */\n    public static boolean loadDriver(final String driverClassName) {\n        return loadDriver(DbUtils.class.getClassLoader(), driverClassName);\n    }\n\n    /**\n     * Print the stack trace for a SQLException to STDERR.\n     *\n     * @param e SQLException to print stack trace of\n     */\n    public static void printStackTrace(final SQLException e) {\n        printStackTrace(e, new PrintWriter(System.err));\n    }\n\n    /**\n     * Print the stack trace for a SQLException to a\n     * specified PrintWriter.\n     *\n     * @param e SQLException to print stack trace of\n     * @param pw PrintWriter to print to\n     */\n    public static void printStackTrace(final SQLException e, final PrintWriter pw) {\n\n        SQLException next = e;\n        while (next != null) {\n            next.printStackTrace(pw);\n            next = next.getNextException();\n            if (next != null) {\n                pw.println(\"Next SQLException:\");\n            }\n        }\n    }\n\n    /**\n     * Print warnings on a Connection to STDERR.\n     *\n     * @param conn Connection to print warnings from\n     */\n    public static void printWarnings(final Connection conn) {\n        printWarnings(conn, new PrintWriter(System.err));\n    }\n\n    /**\n     * Print warnings on a Connection to a specified PrintWriter.\n     *\n     * @param conn Connection to print warnings from\n     * @param pw PrintWriter to print to\n     */\n    public static void printWarnings(final Connection conn, final PrintWriter pw) {\n        if (conn != null) {\n            try {\n                printStackTrace(conn.getWarnings(), pw);\n            } catch (final SQLException e) {\n                printStackTrace(e, pw);\n            }\n        }\n    }\n\n    /**\n     * Rollback any changes made on the given connection.\n     * @param conn Connection to rollback.  A null value is legal.\n     * @throws SQLException if a database access error occurs\n     */\n    public static void rollback(final Connection conn) throws SQLException {\n        if (conn != null) {\n            conn.rollback();\n        }\n    }\n\n    /**\n     * Performs a rollback on the {@code Connection} then closes it,\n     * avoid closing if null.\n     *\n     * @param conn Connection to rollback.  A null value is legal.\n     * @throws SQLException if a database access error occurs\n     * @since 1.1\n     */\n    public static void rollbackAndClose(final Connection conn) throws SQLException {\n        if (conn != null) {\n            try {\n                conn.rollback();\n            } finally {\n                conn.close();\n            }\n        }\n    }\n\n    /**\n     * Performs a rollback on the {@code Connection} then closes it,\n     * avoid closing if null and hide any SQLExceptions that occur.\n     *\n     * @param conn Connection to rollback.  A null value is legal.\n     * @since 1.1\n     */\n    public static void rollbackAndCloseQuietly(final Connection conn) {\n        try {\n            rollbackAndClose(conn);\n        } catch (final SQLException e) { // NOPMD\n            // quiet\n        }\n    }\n\n    /**\n     * Performs a rollback on the {@code Connection}, avoid\n     * closing if null and hide any SQLExceptions that occur.\n     *\n     * @param conn Connection to rollback.  A null value is legal.\n     * @since DbUtils 2.0\n     */\n    public static void rollbackQuietly(final Connection conn) {\n        try {\n            rollback(conn);\n        } catch (final SQLException e) { // NOPMD\n            // quiet\n        }\n    }\n\n    /**\n     * Default constructor.\n     *\n     * Utility classes should not have a public or default constructor,\n     * but this one preserves retro-compatibility.\n     *\n     * @since 1.4\n     */\n    public DbUtils() {\n        // do nothing\n    }\n\n}", "definition": "public final class DbUtils", "class_docstring": "\nA collection of JDBC helper methods.  This class is thread safe.\n", "name": "DbUtils", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "fields": [], "classes": [{"original_string": "    static final class DriverProxy implements Driver {\n\n        /**\n         * The adapted JDBC Driver loaded dynamically.\n         */\n        private final Driver adapted;\n\n        /**\n         * Creates a new JDBC Driver that adapts a JDBC Driver loaded dynamically.\n         *\n         * @param adapted the adapted JDBC Driver loaded dynamically.\n         */\n        public DriverProxy(final Driver adapted) {\n            this.adapted = adapted;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public boolean acceptsURL(final String url) throws SQLException {\n            return adapted.acceptsURL(url);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public Connection connect(final String url, final Properties info) throws SQLException {\n            return adapted.connect(url, info);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public int getMajorVersion() {\n            return adapted.getMajorVersion();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public int getMinorVersion() {\n            return adapted.getMinorVersion();\n        }\n\n        /**\n         * Java 1.7 method.\n         */\n        @Override\n        public Logger getParentLogger() throws SQLFeatureNotSupportedException {\n            return adapted.getParentLogger();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public DriverPropertyInfo[] getPropertyInfo(final String url, final Properties info) throws SQLException {\n            return adapted.getPropertyInfo(url, info);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public boolean jdbcCompliant() {\n            return adapted.jdbcCompliant();\n        }\n\n    }", "definition": "    static final class DriverProxy implements Driver", "class_docstring": "\nSimple {@link Driver} proxy class that proxies a JDBC Driver loaded dynamically.\n\n@since 1.6\n", "name": "DriverProxy", "super_interfaces": ["Driver"], "superclasses": "", "attributes": {"modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "fields": [{"attribute_expression": "private final Driver adapted;", "docstring": "\nThe adapted JDBC Driver loaded dynamically.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Driver", "name": "adapted", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public DriverProxy(final Driver adapted) {\n            this.adapted = adapted;\n        }", "docstring": "\nCreates a new JDBC Driver that adapts a JDBC Driver loaded dynamically.\n\n@param adapted the adapted JDBC Driver loaded dynamically.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "DriverProxy", "params": [{"name": "adapted", "type": "Driver"}], "body": "                                                 {\n            this.adapted = adapted;\n        }", "signature": "public DriverProxy(final Driver adapted)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean acceptsURL(final String url) throws SQLException {\n            return adapted.acceptsURL(url);\n        }", "docstring": "\n{@inheritDoc}\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "acceptsURL", "params": [{"name": "url", "type": "String"}], "body": "                                                                        {\n            return adapted.acceptsURL(url);\n        }", "signature": "@Override\n        public boolean acceptsURL(final String url)"}, {"syntax_pass": true, "original_string": "        @Override\n        public Connection connect(final String url, final Properties info) throws SQLException {\n            return adapted.connect(url, info);\n        }", "docstring": "\n{@inheritDoc}\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Connection", "classes": []}, "name": "connect", "params": [{"name": "url", "type": "String"}, {"name": "info", "type": "Properties"}], "body": "                                                                                               {\n            return adapted.connect(url, info);\n        }", "signature": "@Override\n        public Connection connect(final String url, final Properties info)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int getMajorVersion() {\n            return adapted.getMajorVersion();\n        }", "docstring": "\n{@inheritDoc}\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "getMajorVersion", "params": [], "body": "                                     {\n            return adapted.getMajorVersion();\n        }", "signature": "@Override\n        public int getMajorVersion()"}, {"syntax_pass": true, "original_string": "        @Override\n        public int getMinorVersion() {\n            return adapted.getMinorVersion();\n        }", "docstring": "\n{@inheritDoc}\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "getMinorVersion", "params": [], "body": "                                     {\n            return adapted.getMinorVersion();\n        }", "signature": "@Override\n        public int getMinorVersion()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Logger getParentLogger() throws SQLFeatureNotSupportedException {\n            return adapted.getParentLogger();\n        }", "docstring": "\nJava 1.7 method.\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Logger", "classes": []}, "name": "getParentLogger", "params": [], "body": "                                                                               {\n            return adapted.getParentLogger();\n        }", "signature": "@Override\n        public Logger getParentLogger()"}, {"syntax_pass": true, "original_string": "        @Override\n        public DriverPropertyInfo[] getPropertyInfo(final String url, final Properties info) throws SQLException {\n            return adapted.getPropertyInfo(url, info);\n        }", "docstring": "\n{@inheritDoc}\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "DriverPropertyInfo[]", "classes": []}, "name": "getPropertyInfo", "params": [{"name": "url", "type": "String"}, {"name": "info", "type": "Properties"}], "body": "                                                                                                                 {\n            return adapted.getPropertyInfo(url, info);\n        }", "signature": "@Override\n        public DriverPropertyInfo[] getPropertyInfo(final String url, final Properties info)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean jdbcCompliant() {\n            return adapted.jdbcCompliant();\n        }", "docstring": "\n{@inheritDoc}\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "jdbcCompliant", "params": [], "body": "                                       {\n            return adapted.jdbcCompliant();\n        }", "signature": "@Override\n        public boolean jdbcCompliant()"}]}]}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public static void close(final Connection conn) throws SQLException {\n        if (conn != null) {\n            conn.close();\n        }\n    }", "docstring": "\nClose a {@code Connection}, avoid closing if null.\n\n@param conn Connection to close.\n@throws SQLException if a database access error occurs\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "close", "params": [{"name": "conn", "type": "Connection"}], "body": "                                                                        {\n        if (conn != null) {\n            conn.close();\n        }\n    }", "signature": "public static void close(final Connection conn)"}, {"syntax_pass": true, "original_string": "    public static void close(final ResultSet resultSet) throws SQLException {\n        if (resultSet != null) {\n            resultSet.close();\n        }\n    }", "docstring": "\nClose a {@code ResultSet}, avoid closing if null.\n\n@param resultSet ResultSet to close.\n@throws SQLException if a database access error occurs\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "close", "params": [{"name": "resultSet", "type": "ResultSet"}], "body": "                                                                            {\n        if (resultSet != null) {\n            resultSet.close();\n        }\n    }", "signature": "public static void close(final ResultSet resultSet)"}, {"syntax_pass": true, "original_string": "    public static void close(final Statement stmt) throws SQLException {\n        if (stmt != null) {\n            stmt.close();\n        }\n    }", "docstring": "\nClose a {@code Statement}, avoid closing if null.\n\n@param stmt Statement to close.\n@throws SQLException if a database access error occurs\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "close", "params": [{"name": "stmt", "type": "Statement"}], "body": "                                                                       {\n        if (stmt != null) {\n            stmt.close();\n        }\n    }", "signature": "public static void close(final Statement stmt)"}, {"syntax_pass": true, "original_string": "    public static void closeQuietly(final Connection conn) {\n        try {\n            close(conn);\n        } catch (final SQLException e) { // NOPMD\n            // quiet\n        }\n    }", "docstring": "\nClose a {@code Connection}, avoid closing if null and hide\nany SQLExceptions that occur.\n\n@param conn Connection to close.\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "closeQuietly", "params": [{"name": "conn", "type": "Connection"}], "body": "                                                           {\n        try {\n            close(conn);\n        } catch (final SQLException e) { // NOPMD\n            // quiet\n        }\n    }", "signature": "public static void closeQuietly(final Connection conn)"}, {"syntax_pass": true, "original_string": "    public static void closeQuietly(final Connection conn, final Statement stmt,\n            final ResultSet rs) {\n\n        try {\n            closeQuietly(rs);\n        } finally {\n            try {\n                closeQuietly(stmt);\n            } finally {\n                closeQuietly(conn);\n            }\n        }\n\n    }", "docstring": "\nClose a {@code Connection}, {@code Statement} and\n{@code ResultSet}.  Avoid closing if null and hide any\nSQLExceptions that occur.\n\n@param conn Connection to close.\n@param stmt Statement to close.\n@param rs ResultSet to close.\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "closeQuietly", "params": [{"name": "conn", "type": "Connection"}, {"name": "stmt", "type": "Statement"}, {"name": "rs", "type": "ResultSet"}], "body": "                                {\n\n        try {\n            closeQuietly(rs);\n        } finally {\n            try {\n                closeQuietly(stmt);\n            } finally {\n                closeQuietly(conn);\n            }\n        }\n\n    }", "signature": "public static void closeQuietly(final Connection conn, final Statement stmt,\n            final ResultSet rs)"}, {"syntax_pass": true, "original_string": "    public static void closeQuietly(final ResultSet resultSet) {\n        try {\n            close(resultSet);\n        } catch (final SQLException e) { // NOPMD\n            // quiet\n        }\n    }", "docstring": "\nClose a {@code ResultSet}, avoid closing if null and hide any\nSQLExceptions that occur.\n\n@param resultSet ResultSet to close.\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "closeQuietly", "params": [{"name": "resultSet", "type": "ResultSet"}], "body": "                                                               {\n        try {\n            close(resultSet);\n        } catch (final SQLException e) { // NOPMD\n            // quiet\n        }\n    }", "signature": "public static void closeQuietly(final ResultSet resultSet)"}, {"syntax_pass": true, "original_string": "    public static void closeQuietly(final Statement stmt) {\n        try {\n            close(stmt);\n        } catch (final SQLException e) { // NOPMD\n            // quiet\n        }\n    }", "docstring": "\nClose a {@code Statement}, avoid closing if null and hide\nany SQLExceptions that occur.\n\n@param stmt Statement to close.\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "closeQuietly", "params": [{"name": "stmt", "type": "Statement"}], "body": "                                                          {\n        try {\n            close(stmt);\n        } catch (final SQLException e) { // NOPMD\n            // quiet\n        }\n    }", "signature": "public static void closeQuietly(final Statement stmt)"}, {"syntax_pass": true, "original_string": "    public static void commitAndClose(final Connection conn) throws SQLException {\n        if (conn != null) {\n            try {\n                conn.commit();\n            } finally {\n                conn.close();\n            }\n        }\n    }", "docstring": "\nCommits a {@code Connection} then closes it, avoid closing if null.\n\n@param conn Connection to close.\n@throws SQLException if a database access error occurs\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "commitAndClose", "params": [{"name": "conn", "type": "Connection"}], "body": "                                                                                 {\n        if (conn != null) {\n            try {\n                conn.commit();\n            } finally {\n                conn.close();\n            }\n        }\n    }", "signature": "public static void commitAndClose(final Connection conn)"}, {"syntax_pass": true, "original_string": "    public static void commitAndCloseQuietly(final Connection conn) {\n        try {\n            commitAndClose(conn);\n        } catch (final SQLException e) { // NOPMD\n            // quiet\n        }\n    }", "docstring": "\nCommits a {@code Connection} then closes it, avoid closing if null\nand hide any SQLExceptions that occur.\n\n@param conn Connection to close.\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "commitAndCloseQuietly", "params": [{"name": "conn", "type": "Connection"}], "body": "                                                                    {\n        try {\n            commitAndClose(conn);\n        } catch (final SQLException e) { // NOPMD\n            // quiet\n        }\n    }", "signature": "public static void commitAndCloseQuietly(final Connection conn)"}, {"syntax_pass": true, "original_string": "    public static boolean loadDriver(final ClassLoader classLoader, final String driverClassName) {\n        try {\n            final Class<?> loadedClass = classLoader.loadClass(driverClassName);\n\n            if (!Driver.class.isAssignableFrom(loadedClass)) {\n                return false;\n            }\n\n            @SuppressWarnings(\"unchecked\") // guarded by previous check\n            final\n            Class<Driver> driverClass = (Class<Driver>) loadedClass;\n            final Constructor<Driver> driverConstructor = driverClass.getConstructor();\n\n            // make Constructor accessible if it is private\n            @SuppressWarnings(\"deprecation\")\n            // TODO This is deprecated in Java9 and canAccess() should be used. Adding suppression for building on\n            //      later JDKs without a warning.\n            final boolean isConstructorAccessible = driverConstructor.isAccessible();\n            if (!isConstructorAccessible) {\n                driverConstructor.setAccessible(true);\n            }\n\n            try {\n                final Driver driver = driverConstructor.newInstance();\n                registerDriver(new DriverProxy(driver));\n            } finally {\n                driverConstructor.setAccessible(isConstructorAccessible);\n            }\n\n            return true;\n        } catch (final Exception e) {\n            return false;\n        }\n    }", "docstring": "\nLoads and registers a database driver class.\nIf this succeeds, it returns true, else it returns false.\n\n@param classLoader the class loader used to load the driver class\n@param driverClassName of driver to load\n@return boolean {@code true} if the driver was found, otherwise {@code false}\n@since 1.4\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "boolean", "classes": []}, "name": "loadDriver", "params": [{"name": "classLoader", "type": "ClassLoader"}, {"name": "driverClassName", "type": "String"}], "body": "                                                                                                  {\n        try {\n            final Class<?> loadedClass = classLoader.loadClass(driverClassName);\n\n            if (!Driver.class.isAssignableFrom(loadedClass)) {\n                return false;\n            }\n\n            @SuppressWarnings(\"unchecked\") // guarded by previous check\n            final\n            Class<Driver> driverClass = (Class<Driver>) loadedClass;\n            final Constructor<Driver> driverConstructor = driverClass.getConstructor();\n\n            // make Constructor accessible if it is private\n            @SuppressWarnings(\"deprecation\")\n            // TODO This is deprecated in Java9 and canAccess() should be used. Adding suppression for building on\n            //      later JDKs without a warning.\n            final boolean isConstructorAccessible = driverConstructor.isAccessible();\n            if (!isConstructorAccessible) {\n                driverConstructor.setAccessible(true);\n            }\n\n            try {\n                final Driver driver = driverConstructor.newInstance();\n                registerDriver(new DriverProxy(driver));\n            } finally {\n                driverConstructor.setAccessible(isConstructorAccessible);\n            }\n\n            return true;\n        } catch (final Exception e) {\n            return false;\n        }\n    }", "signature": "public static boolean loadDriver(final ClassLoader classLoader, final String driverClassName)"}, {"syntax_pass": true, "original_string": "    public static boolean loadDriver(final String driverClassName) {\n        return loadDriver(DbUtils.class.getClassLoader(), driverClassName);\n    }", "docstring": "\nLoads and registers a database driver class.\nIf this succeeds, it returns true, else it returns false.\n\n@param driverClassName of driver to load\n@return boolean {@code true} if the driver was found, otherwise {@code false}\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "boolean", "classes": []}, "name": "loadDriver", "params": [{"name": "driverClassName", "type": "String"}], "body": "                                                                   {\n        return loadDriver(DbUtils.class.getClassLoader(), driverClassName);\n    }", "signature": "public static boolean loadDriver(final String driverClassName)"}, {"syntax_pass": true, "original_string": "    public static void printStackTrace(final SQLException e) {\n        printStackTrace(e, new PrintWriter(System.err));\n    }", "docstring": "\nPrint the stack trace for a SQLException to STDERR.\n\n@param e SQLException to print stack trace of\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "printStackTrace", "params": [{"name": "e", "type": "SQLException"}], "body": "                                                             {\n        printStackTrace(e, new PrintWriter(System.err));\n    }", "signature": "public static void printStackTrace(final SQLException e)"}, {"syntax_pass": true, "original_string": "    public static void printStackTrace(final SQLException e, final PrintWriter pw) {\n\n        SQLException next = e;\n        while (next != null) {\n            next.printStackTrace(pw);\n            next = next.getNextException();\n            if (next != null) {\n                pw.println(\"Next SQLException:\");\n            }\n        }\n    }", "docstring": "\nPrint the stack trace for a SQLException to a\nspecified PrintWriter.\n\n@param e SQLException to print stack trace of\n@param pw PrintWriter to print to\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "printStackTrace", "params": [{"name": "e", "type": "SQLException"}, {"name": "pw", "type": "PrintWriter"}], "body": "                                                                                   {\n\n        SQLException next = e;\n        while (next != null) {\n            next.printStackTrace(pw);\n            next = next.getNextException();\n            if (next != null) {\n                pw.println(\"Next SQLException:\");\n            }\n        }\n    }", "signature": "public static void printStackTrace(final SQLException e, final PrintWriter pw)"}, {"syntax_pass": true, "original_string": "    public static void printWarnings(final Connection conn) {\n        printWarnings(conn, new PrintWriter(System.err));\n    }", "docstring": "\nPrint warnings on a Connection to STDERR.\n\n@param conn Connection to print warnings from\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "printWarnings", "params": [{"name": "conn", "type": "Connection"}], "body": "                                                            {\n        printWarnings(conn, new PrintWriter(System.err));\n    }", "signature": "public static void printWarnings(final Connection conn)"}, {"syntax_pass": true, "original_string": "    public static void printWarnings(final Connection conn, final PrintWriter pw) {\n        if (conn != null) {\n            try {\n                printStackTrace(conn.getWarnings(), pw);\n            } catch (final SQLException e) {\n                printStackTrace(e, pw);\n            }\n        }\n    }", "docstring": "\nPrint warnings on a Connection to a specified PrintWriter.\n\n@param conn Connection to print warnings from\n@param pw PrintWriter to print to\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "printWarnings", "params": [{"name": "conn", "type": "Connection"}, {"name": "pw", "type": "PrintWriter"}], "body": "                                                                                  {\n        if (conn != null) {\n            try {\n                printStackTrace(conn.getWarnings(), pw);\n            } catch (final SQLException e) {\n                printStackTrace(e, pw);\n            }\n        }\n    }", "signature": "public static void printWarnings(final Connection conn, final PrintWriter pw)"}, {"syntax_pass": true, "original_string": "    public static void rollback(final Connection conn) throws SQLException {\n        if (conn != null) {\n            conn.rollback();\n        }\n    }", "docstring": "\nRollback any changes made on the given connection.\n@param conn Connection to rollback.  A null value is legal.\n@throws SQLException if a database access error occurs\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "rollback", "params": [{"name": "conn", "type": "Connection"}], "body": "                                                                           {\n        if (conn != null) {\n            conn.rollback();\n        }\n    }", "signature": "public static void rollback(final Connection conn)"}, {"syntax_pass": true, "original_string": "    public static void rollbackAndClose(final Connection conn) throws SQLException {\n        if (conn != null) {\n            try {\n                conn.rollback();\n            } finally {\n                conn.close();\n            }\n        }\n    }", "docstring": "\nPerforms a rollback on the {@code Connection} then closes it,\navoid closing if null.\n\n@param conn Connection to rollback.  A null value is legal.\n@throws SQLException if a database access error occurs\n@since 1.1\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "rollbackAndClose", "params": [{"name": "conn", "type": "Connection"}], "body": "                                                                                   {\n        if (conn != null) {\n            try {\n                conn.rollback();\n            } finally {\n                conn.close();\n            }\n        }\n    }", "signature": "public static void rollbackAndClose(final Connection conn)"}, {"syntax_pass": true, "original_string": "    public static void rollbackAndCloseQuietly(final Connection conn) {\n        try {\n            rollbackAndClose(conn);\n        } catch (final SQLException e) { // NOPMD\n            // quiet\n        }\n    }", "docstring": "\nPerforms a rollback on the {@code Connection} then closes it,\navoid closing if null and hide any SQLExceptions that occur.\n\n@param conn Connection to rollback.  A null value is legal.\n@since 1.1\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "rollbackAndCloseQuietly", "params": [{"name": "conn", "type": "Connection"}], "body": "                                                                      {\n        try {\n            rollbackAndClose(conn);\n        } catch (final SQLException e) { // NOPMD\n            // quiet\n        }\n    }", "signature": "public static void rollbackAndCloseQuietly(final Connection conn)"}, {"syntax_pass": true, "original_string": "    public static void rollbackQuietly(final Connection conn) {\n        try {\n            rollback(conn);\n        } catch (final SQLException e) { // NOPMD\n            // quiet\n        }\n    }", "docstring": "\nPerforms a rollback on the {@code Connection}, avoid\nclosing if null and hide any SQLExceptions that occur.\n\n@param conn Connection to rollback.  A null value is legal.\n@since DbUtils 2.0\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "void", "classes": []}, "name": "rollbackQuietly", "params": [{"name": "conn", "type": "Connection"}], "body": "                                                              {\n        try {\n            rollback(conn);\n        } catch (final SQLException e) { // NOPMD\n            // quiet\n        }\n    }", "signature": "public static void rollbackQuietly(final Connection conn)"}, {"syntax_pass": true, "original_string": "    public DbUtils() {\n        // do nothing\n    }", "docstring": "\nDefault constructor.\n\nUtility classes should not have a public or default constructor,\nbut this one preserves retro-compatibility.\n\n@since 1.4\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "DbUtils", "params": [], "body": "                     {\n        // do nothing\n    }", "signature": "public DbUtils()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/apache/commons/dbutils/QueryLoader.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.regex.Pattern;\n\n/**\n * {@code QueryLoader} is a registry for sets of queries so\n * that multiple copies of the same queries aren't loaded into memory.\n * This implementation loads properties files filled with query name to\n * SQL mappings.  This class is thread safe.\n */\npublic class QueryLoader {\n\n    /**\n     * The Singleton INSTANCE of this class.\n     */\n    private static final QueryLoader INSTANCE = new QueryLoader();\n\n    /**\n     * Matches .xml file extensions.\n     */\n    private static final Pattern dotXml = Pattern.compile(\".+\\\\.[xX][mM][lL]\");\n\n    /**\n     * Return an INSTANCE of this class.\n     * @return The Singleton INSTANCE.\n     */\n    public static QueryLoader instance() {\n        return INSTANCE;\n    }\n\n    /**\n     * Maps query set names to Maps of their queries.\n     */\n    private final Map<String, Map<String, String>> queries = new HashMap<>();\n\n    /**\n     * QueryLoader constructor.\n     */\n    protected QueryLoader() {\n    }\n\n    /**\n     * Loads a Map of query names to SQL values.  The Maps are cached so a\n     * subsequent request to load queries from the same path will return\n     * the cached Map.  The properties file to load can be in either\n     * line-oriented or XML format.  XML formatted properties files must use a\n     * {@code .xml} file extension.\n     *\n     * @param path The path that the ClassLoader will use to find the file.\n     * This is <strong>not</strong> a file system path.  If you had a jarred\n     * Queries.properties file in the com.yourcorp.app.jdbc package you would\n     * pass \"/com/yourcorp/app/jdbc/Queries.properties\" to this method.\n     * @throws IOException if a file access error occurs\n     * @throws IllegalArgumentException if the ClassLoader can't find a file at\n     * the given path.\n     * @throws java.util.InvalidPropertiesFormatException if the XML properties file is\n     * invalid\n     * @return Map of query names to SQL values\n     * @see java.util.Properties\n     */\n    public synchronized Map<String, String> load(final String path) throws IOException {\n\n        Map<String, String> queryMap = this.queries.get(path);\n\n        if (queryMap == null) {\n            queryMap = loadQueries(path);\n            this.queries.put(path, queryMap);\n        }\n\n        return queryMap;\n    }\n\n    /**\n     * Loads a set of named queries into a Map object.  This implementation\n     * reads a properties file at the given path.  The properties file can be\n     * in either line-oriented or XML format.  XML formatted properties files\n     * must use a {@code .xml} file extension.\n\n     * @param path The path that the ClassLoader will use to find the file.\n     * @throws IOException if a file access error occurs\n     * @throws IllegalArgumentException if the ClassLoader can't find a file at\n     * the given path.\n     * @throws java.util.InvalidPropertiesFormatException if the XML properties file is\n     * invalid\n     * @since 1.1\n     * @return Map of query names to SQL values\n     * @see java.util.Properties\n     */\n    protected Map<String, String> loadQueries(final String path) throws IOException {\n        // Findbugs flags getClass().getResource as a bad practice; maybe we should change the API?\n        final Properties props;\n        try (InputStream in = getClass().getResourceAsStream(path)) {\n\n            if (in == null) {\n                throw new IllegalArgumentException(path + \" not found.\");\n            }\n            props = new Properties();\n            if (dotXml.matcher(path).matches()) {\n                props.loadFromXML(in);\n            } else {\n                props.load(in);\n            }\n        }\n\n        // Copy to HashMap for better performance\n\n        @SuppressWarnings({\"rawtypes\", \"unchecked\" }) // load() always creates <String,String> entries\n        final HashMap<String, String> hashMap = new HashMap(props);\n        return hashMap;\n    }\n\n    /**\n     * Removes the queries for the given path from the cache.\n     * @param path The path that the queries were loaded from.\n     */\n    public synchronized void unload(final String path) {\n        this.queries.remove(path);\n    }\n\n}\n", "file_hash": "aff0d9cb5a66ca33ad91016b48b4d4a38022141e7d530524efac0f1f2c593a09", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils;", "import java.io.IOException;", "import java.io.InputStream;", "import java.util.HashMap;", "import java.util.Map;", "import java.util.Properties;", "import java.util.regex.Pattern;"], "methods": [], "classes": [{"original_string": "public class QueryLoader {\n\n    /**\n     * The Singleton INSTANCE of this class.\n     */\n    private static final QueryLoader INSTANCE = new QueryLoader();\n\n    /**\n     * Matches .xml file extensions.\n     */\n    private static final Pattern dotXml = Pattern.compile(\".+\\\\.[xX][mM][lL]\");\n\n    /**\n     * Return an INSTANCE of this class.\n     * @return The Singleton INSTANCE.\n     */\n    public static QueryLoader instance() {\n        return INSTANCE;\n    }\n\n    /**\n     * Maps query set names to Maps of their queries.\n     */\n    private final Map<String, Map<String, String>> queries = new HashMap<>();\n\n    /**\n     * QueryLoader constructor.\n     */\n    protected QueryLoader() {\n    }\n\n    /**\n     * Loads a Map of query names to SQL values.  The Maps are cached so a\n     * subsequent request to load queries from the same path will return\n     * the cached Map.  The properties file to load can be in either\n     * line-oriented or XML format.  XML formatted properties files must use a\n     * {@code .xml} file extension.\n     *\n     * @param path The path that the ClassLoader will use to find the file.\n     * This is <strong>not</strong> a file system path.  If you had a jarred\n     * Queries.properties file in the com.yourcorp.app.jdbc package you would\n     * pass \"/com/yourcorp/app/jdbc/Queries.properties\" to this method.\n     * @throws IOException if a file access error occurs\n     * @throws IllegalArgumentException if the ClassLoader can't find a file at\n     * the given path.\n     * @throws java.util.InvalidPropertiesFormatException if the XML properties file is\n     * invalid\n     * @return Map of query names to SQL values\n     * @see java.util.Properties\n     */\n    public synchronized Map<String, String> load(final String path) throws IOException {\n\n        Map<String, String> queryMap = this.queries.get(path);\n\n        if (queryMap == null) {\n            queryMap = loadQueries(path);\n            this.queries.put(path, queryMap);\n        }\n\n        return queryMap;\n    }\n\n    /**\n     * Loads a set of named queries into a Map object.  This implementation\n     * reads a properties file at the given path.  The properties file can be\n     * in either line-oriented or XML format.  XML formatted properties files\n     * must use a {@code .xml} file extension.\n\n     * @param path The path that the ClassLoader will use to find the file.\n     * @throws IOException if a file access error occurs\n     * @throws IllegalArgumentException if the ClassLoader can't find a file at\n     * the given path.\n     * @throws java.util.InvalidPropertiesFormatException if the XML properties file is\n     * invalid\n     * @since 1.1\n     * @return Map of query names to SQL values\n     * @see java.util.Properties\n     */\n    protected Map<String, String> loadQueries(final String path) throws IOException {\n        // Findbugs flags getClass().getResource as a bad practice; maybe we should change the API?\n        final Properties props;\n        try (InputStream in = getClass().getResourceAsStream(path)) {\n\n            if (in == null) {\n                throw new IllegalArgumentException(path + \" not found.\");\n            }\n            props = new Properties();\n            if (dotXml.matcher(path).matches()) {\n                props.loadFromXML(in);\n            } else {\n                props.load(in);\n            }\n        }\n\n        // Copy to HashMap for better performance\n\n        @SuppressWarnings({\"rawtypes\", \"unchecked\" }) // load() always creates <String,String> entries\n        final HashMap<String, String> hashMap = new HashMap(props);\n        return hashMap;\n    }\n\n    /**\n     * Removes the queries for the given path from the cache.\n     * @param path The path that the queries were loaded from.\n     */\n    public synchronized void unload(final String path) {\n        this.queries.remove(path);\n    }\n\n}", "definition": "public class QueryLoader", "class_docstring": "\n{@code QueryLoader} is a registry for sets of queries so\nthat multiple copies of the same queries aren't loaded into memory.\nThis implementation loads properties files filled with query name to\nSQL mappings.  This class is thread safe.\n", "name": "QueryLoader", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private static final QueryLoader INSTANCE = new QueryLoader();", "docstring": "\nThe Singleton INSTANCE of this class.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "QueryLoader", "name": "INSTANCE = new QueryLoader()", "syntax_pass": true}, {"attribute_expression": "private static final Pattern dotXml = Pattern.compile(\".+\\\\.[xX][mM][lL]\");", "docstring": "\nMatches .xml file extensions.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Pattern", "name": "dotXml = Pattern.compile(\".+\\\\.[xX][mM][lL]\")", "syntax_pass": true}, {"attribute_expression": "private final Map<String, Map<String, String>> queries = new HashMap<>();", "docstring": "\nMaps query set names to Maps of their queries.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Map<String, Map<String, String>>", "name": "queries = new HashMap<>()", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public static QueryLoader instance() {\n        return INSTANCE;\n    }", "docstring": "\nReturn an INSTANCE of this class.\n@return The Singleton INSTANCE.\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "QueryLoader", "classes": []}, "name": "instance", "params": [], "body": "                                         {\n        return INSTANCE;\n    }", "signature": "public static QueryLoader instance()"}, {"syntax_pass": true, "original_string": "    protected QueryLoader() {\n    }", "docstring": "\nQueryLoader constructor.\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "name": "QueryLoader", "params": [], "body": "                            {\n    }", "signature": "protected QueryLoader()"}, {"syntax_pass": true, "original_string": "    public synchronized Map<String, String> load(final String path) throws IOException {\n\n        Map<String, String> queryMap = this.queries.get(path);\n\n        if (queryMap == null) {\n            queryMap = loadQueries(path);\n            this.queries.put(path, queryMap);\n        }\n\n        return queryMap;\n    }", "docstring": "\nLoads a Map of query names to SQL values.  The Maps are cached so a\nsubsequent request to load queries from the same path will return\nthe cached Map.  The properties file to load can be in either\nline-oriented or XML format.  XML formatted properties files must use a\n{@code .xml} file extension.\n\n@param path The path that the ClassLoader will use to find the file.\nThis is <strong>not</strong> a file system path.  If you had a jarred\nQueries.properties file in the com.yourcorp.app.jdbc package you would\npass \"/com/yourcorp/app/jdbc/Queries.properties\" to this method.\n@throws IOException if a file access error occurs\n@throws IllegalArgumentException if the ClassLoader can't find a file at\nthe given path.\n@throws java.util.InvalidPropertiesFormatException if the XML properties file is\ninvalid\n@return Map of query names to SQL values\n@see java.util.Properties\n", "attributes": {"modifiers": "public synchronized", "marker_annotations": [], "non_marker_annotations": ["public", "synchronized"], "comments": [], "return_type": "Map<String, String>", "classes": []}, "name": "load", "params": [{"name": "path", "type": "String"}], "body": "                                                                                       {\n\n        Map<String, String> queryMap = this.queries.get(path);\n\n        if (queryMap == null) {\n            queryMap = loadQueries(path);\n            this.queries.put(path, queryMap);\n        }\n\n        return queryMap;\n    }", "signature": "public synchronized Map<String, String> load(final String path)"}, {"syntax_pass": true, "original_string": "    protected Map<String, String> loadQueries(final String path) throws IOException {\n        // Findbugs flags getClass().getResource as a bad practice; maybe we should change the API?\n        final Properties props;\n        try (InputStream in = getClass().getResourceAsStream(path)) {\n\n            if (in == null) {\n                throw new IllegalArgumentException(path + \" not found.\");\n            }\n            props = new Properties();\n            if (dotXml.matcher(path).matches()) {\n                props.loadFromXML(in);\n            } else {\n                props.load(in);\n            }\n        }\n\n        // Copy to HashMap for better performance\n\n        @SuppressWarnings({\"rawtypes\", \"unchecked\" }) // load() always creates <String,String> entries\n        final HashMap<String, String> hashMap = new HashMap(props);\n        return hashMap;\n    }", "docstring": "\nLoads a set of named queries into a Map object.  This implementation\nreads a properties file at the given path.  The properties file can be\nin either line-oriented or XML format.  XML formatted properties files\nmust use a {@code .xml} file extension.\n\n@param path The path that the ClassLoader will use to find the file.\n@throws IOException if a file access error occurs\n@throws IllegalArgumentException if the ClassLoader can't find a file at\nthe given path.\n@throws java.util.InvalidPropertiesFormatException if the XML properties file is\ninvalid\n@since 1.1\n@return Map of query names to SQL values\n@see java.util.Properties\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Map<String, String>", "classes": []}, "name": "loadQueries", "params": [{"name": "path", "type": "String"}], "body": "                                                                                    {\n        // Findbugs flags getClass().getResource as a bad practice; maybe we should change the API?\n        final Properties props;\n        try (InputStream in = getClass().getResourceAsStream(path)) {\n\n            if (in == null) {\n                throw new IllegalArgumentException(path + \" not found.\");\n            }\n            props = new Properties();\n            if (dotXml.matcher(path).matches()) {\n                props.loadFromXML(in);\n            } else {\n                props.load(in);\n            }\n        }\n\n        // Copy to HashMap for better performance\n\n        @SuppressWarnings({\"rawtypes\", \"unchecked\" }) // load() always creates <String,String> entries\n        final HashMap<String, String> hashMap = new HashMap(props);\n        return hashMap;\n    }", "signature": "protected Map<String, String> loadQueries(final String path)"}, {"syntax_pass": true, "original_string": "    public synchronized void unload(final String path) {\n        this.queries.remove(path);\n    }", "docstring": "\nRemoves the queries for the given path from the cache.\n@param path The path that the queries were loaded from.\n", "attributes": {"modifiers": "public synchronized", "marker_annotations": [], "non_marker_annotations": ["public", "synchronized"], "comments": [], "return_type": "void", "classes": []}, "name": "unload", "params": [{"name": "path", "type": "String"}], "body": "                                                       {\n        this.queries.remove(path);\n    }", "signature": "public synchronized void unload(final String path)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/apache/commons/dbutils/AsyncQueryRunner.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Future;\n\nimport javax.sql.DataSource;\n\n/**\n * Executes SQL queries with pluggable strategies for handling\n * {@code ResultSet}s.  This class is thread safe.\n *\n * @see ResultSetHandler\n * @since 1.4\n */\npublic class AsyncQueryRunner extends AbstractQueryRunner {\n\n    /**\n     * @deprecated No longer used by this class. Will be removed in a future version.\n     * Class that encapsulates the continuation for batch calls.\n     */\n    @Deprecated\n    protected class BatchCallableStatement implements Callable<int[]> {\n        private final String sql;\n        private final Object[][] params;\n        private final Connection conn;\n        private final boolean closeConn;\n        private final PreparedStatement ps;\n\n        /**\n         * Creates a new BatchCallableStatement instance.\n         *\n         * @param sql The SQL statement to execute.\n         * @param params An array of query replacement parameters.  Each row in\n         *        this array is one set of batch replacement values.\n         * @param conn The connection to use for the batch call.\n         * @param closeConn True if the connection should be closed, false otherwise.\n         * @param ps The {@link PreparedStatement} to be executed.\n         */\n        public BatchCallableStatement(final String sql, final Object[][] params, final Connection conn, final boolean closeConn, final PreparedStatement ps) {\n            this.sql = sql;\n            this.params = params.clone();\n            this.conn = conn;\n            this.closeConn = closeConn;\n            this.ps = ps;\n        }\n\n        /**\n         * The actual call to executeBatch.\n         *\n         * @return an array of update counts containing one element for each command in the batch.\n         * @throws SQLException if a database access error occurs or one of the commands sent to the database fails.\n         * @see PreparedStatement#executeBatch()\n         */\n        @Override\n        public int[] call() throws SQLException {\n            int[] ret = null;\n\n            try {\n                ret = ps.executeBatch();\n            } catch (final SQLException e) {\n                rethrow(e, sql, (Object[])params);\n            } finally {\n                close(ps);\n                if (closeConn) {\n                    close(conn);\n                }\n            }\n\n            return ret;\n        }\n    }\n    /**\n     * Class that encapsulates the continuation for query calls.\n     * @param <T> The type of the result from the call to handle.\n     */\n    protected class QueryCallableStatement<T> implements Callable<T> {\n        private final String sql;\n        private final Object[] params;\n        private final Connection conn;\n        private final boolean closeConn;\n        private final PreparedStatement ps;\n        private final ResultSetHandler<T> rsh;\n\n        /**\n         * Creates a new {@code QueryCallableStatement} instance.\n         *\n         * @param conn The connection to use for the batch call.\n         * @param closeConn True if the connection should be closed, false otherwise.\n         * @param ps The {@link PreparedStatement} to be executed.\n         * @param rsh The handler that converts the results into an object.\n         * @param sql The SQL statement to execute.\n         * @param params An array of query replacement parameters.  Each row in\n         *        this array is one set of batch replacement values.\n         */\n        public QueryCallableStatement(final Connection conn, final boolean closeConn, final PreparedStatement ps,\n                final ResultSetHandler<T> rsh, final String sql, final Object... params) {\n            this.sql = sql;\n            this.params = params;\n            this.conn = conn;\n            this.closeConn = closeConn;\n            this.ps = ps;\n            this.rsh = rsh;\n        }\n\n        /**\n         * The actual call to {@code handle()} method.\n         *\n         * @return an array of update counts containing one element for each command in the batch.\n         * @throws SQLException if a database access error occurs.\n         * @see ResultSetHandler#handle(ResultSet)\n         */\n        @Override\n        public T call() throws SQLException {\n            ResultSet resultSet = null;\n            T ret = null;\n\n            try {\n                resultSet = wrap(ps.executeQuery());\n                ret = rsh.handle(resultSet);\n            } catch (final SQLException e) {\n                rethrow(e, sql, params);\n            } finally {\n                try {\n                    close(resultSet);\n                } finally {\n                    close(ps);\n                    if (closeConn) {\n                        close(conn);\n                    }\n                }\n            }\n\n            return ret;\n        }\n\n    }\n\n    /**\n     * Class that encapsulates the continuation for update calls.\n     *\n     * @deprecated No longer used by this class. Will be removed in a future version.\n     */\n    @Deprecated\n    protected class UpdateCallableStatement implements Callable<Integer> {\n        private final String sql;\n        private final Object[] params;\n        private final Connection conn;\n        private final boolean closeConn;\n        private final PreparedStatement ps;\n\n        /**\n         * Constructs a new instance.\n         *\n         * @param conn The connection to use for the batch call.\n         * @param closeConn True if the connection should be closed, false otherwise.\n         * @param ps The {@link PreparedStatement} to be executed.\n         * @param sql The SQL statement to execute.\n         * @param params An array of query replacement parameters.  Each row in\n         *        this array is one set of batch replacement values.\n         */\n        public UpdateCallableStatement(final Connection conn, final boolean closeConn, final PreparedStatement ps, final String sql, final Object... params) {\n            this.sql = sql;\n            this.params = params;\n            this.conn = conn;\n            this.closeConn = closeConn;\n            this.ps = ps;\n        }\n\n        /**\n         * The actual call to {@code executeUpdate()} method.\n         *\n         * @return either (1) the row count for SQL Data Manipulation Language (DML) statements or\n         *                (2) 0 for SQL statements that return nothing\n         * @throws SQLException if a database access error occurs.\n         * @see PreparedStatement#executeUpdate()\n         */\n        @Override\n        public Integer call() throws SQLException {\n            int rows = 0;\n\n            try {\n                rows = ps.executeUpdate();\n            } catch (final SQLException e) {\n                rethrow(e, sql, params);\n            } finally {\n                close(ps);\n                if (closeConn) {\n                    close(conn);\n                }\n            }\n\n            return Integer.valueOf(rows);\n        }\n\n    }\n\n    private final ExecutorService executorService;\n\n    private final QueryRunner queryRunner;\n\n    /**\n     * @deprecated Use {@link #AsyncQueryRunner(ExecutorService, QueryRunner)} instead.\n     * Constructor for AsyncQueryRunner that controls the use of {@code ParameterMetaData}.\n     *\n     * @param pmdKnownBroken Some drivers don't support {@link java.sql.ParameterMetaData#getParameterType(int) };\n     * if {@code pmdKnownBroken} is set to true, we won't even try it; if false, we'll try it,\n     * and if it breaks, we'll remember not to use it again.\n     * @param executorService the {@code ExecutorService} instance used to run JDBC invocations concurrently.\n     */\n    @Deprecated\n    public AsyncQueryRunner(final boolean pmdKnownBroken, final ExecutorService executorService) {\n        this(null, pmdKnownBroken, executorService);\n    }\n\n    /**\n     * @deprecated Use {@link #AsyncQueryRunner(ExecutorService, QueryRunner)} instead.\n     * Constructor for AsyncQueryRunner that take a {@code DataSource} and controls the use of {@code ParameterMetaData}.\n     * Methods that do not take a {@code Connection} parameter will retrieve connections from this\n     * {@code DataSource}.\n     *\n     * @param ds The {@code DataSource} to retrieve connections from.\n     * @param pmdKnownBroken Some drivers don't support {@link java.sql.ParameterMetaData#getParameterType(int) };\n     * if {@code pmdKnownBroken} is set to true, we won't even try it; if false, we'll try it,\n     * and if it breaks, we'll remember not to use it again.\n     * @param executorService the {@code ExecutorService} instance used to run JDBC invocations concurrently.\n     */\n    @Deprecated\n    public AsyncQueryRunner(final DataSource ds, final boolean pmdKnownBroken, final ExecutorService executorService) {\n        super(ds, pmdKnownBroken);\n        this.executorService = executorService;\n        this.queryRunner = new QueryRunner(ds, pmdKnownBroken);\n    }\n\n    /**\n     * @deprecated Use {@link #AsyncQueryRunner(ExecutorService, QueryRunner)} instead.\n     * Constructor for AsyncQueryRunner that takes a {@code DataSource}.\n     *\n     * Methods that do not take a {@code Connection} parameter will retrieve connections from this\n     * {@code DataSource}.\n     *\n     * @param ds The {@code DataSource} to retrieve connections from.\n     * @param executorService the {@code ExecutorService} instance used to run JDBC invocations concurrently.\n     */\n    @Deprecated\n    public AsyncQueryRunner(final DataSource ds, final ExecutorService executorService) {\n        this(ds, false, executorService);\n    }\n\n    /**\n     * Constructor for AsyncQueryRunner.\n     *\n     * @param executorService the {@code ExecutorService} instance used to run JDBC invocations concurrently.\n     */\n    public AsyncQueryRunner(final ExecutorService executorService) {\n        this(null, false, executorService);\n    }\n\n    /**\n     * Constructor for AsyncQueryRunner which uses a provided ExecutorService and underlying QueryRunner.\n     *\n     * @param executorService the {@code ExecutorService} instance used to run JDBC invocations concurrently.\n     * @param queryRunner the {@code QueryRunner} instance to use for the queries.\n     * @since 1.5\n     */\n    public AsyncQueryRunner(final ExecutorService executorService, final QueryRunner queryRunner) {\n        this.executorService = executorService;\n        this.queryRunner = queryRunner;\n    }\n\n    /**\n     * Execute a batch of SQL INSERT, UPDATE, or DELETE queries.\n     *\n     * @param conn The {@code Connection} to use to run the query.  The caller is\n     * responsible for closing this Connection.\n     * @param sql The SQL to execute.\n     * @param params An array of query replacement parameters.  Each row in\n     * this array is one set of batch replacement values.\n     * @return A {@code Future} which returns the number of rows updated per statement.\n     * @throws SQLException if a database access error occurs\n     */\n    public Future<int[]> batch(final Connection conn, final String sql, final Object[][] params) throws SQLException {\n        return executorService.submit(() -> queryRunner.batch(conn, sql, params));\n    }\n\n    /**\n     * Execute a batch of SQL INSERT, UPDATE, or DELETE queries.  The\n     * {@code Connection} is retrieved from the {@code DataSource}\n     * set in the constructor.  This {@code Connection} must be in\n     * auto-commit mode or the update will not be saved.\n     *\n     * @param sql The SQL to execute.\n     * @param params An array of query replacement parameters.  Each row in\n     * this array is one set of batch replacement values.\n     * @return A {@code Future} which returns the number of rows updated per statement.\n     * @throws SQLException if a database access error occurs\n     */\n    public Future<int[]> batch(final String sql, final Object[][] params) throws SQLException {\n        return executorService.submit(() -> queryRunner.batch(sql, params));\n    }\n\n    /**\n     * Executes {@link QueryRunner#insert(Connection, String, ResultSetHandler)} asynchronously.\n     *\n     * @param <T> Return type expected\n     * @param conn {@link Connection} to use to execute the SQL statement\n     * @param sql SQL insert statement to execute\n     * @param rsh {@link ResultSetHandler} for handling the results\n     * @return {@link Future} that executes a query runner insert\n     * @see QueryRunner#insert(Connection, String, ResultSetHandler)\n     * @throws SQLException if a database access error occurs\n     * @since 1.6\n     */\n    public <T> Future<T> insert(final Connection conn, final String sql, final ResultSetHandler<T> rsh) throws SQLException {\n        return executorService.submit(() -> queryRunner.insert(conn, sql, rsh));\n    }\n\n    /**\n     * Executes {@link QueryRunner#insert(Connection, String, ResultSetHandler, Object...)} asynchronously.\n     *\n     * @param <T> Return type expected\n     * @param conn {@link Connection} to use to execute the SQL statement\n     * @param sql SQL insert statement to execute\n     * @param rsh {@link ResultSetHandler} for handling the results\n     * @param params Parameter values for substitution in the SQL statement\n     * @return {@link Future} that executes a query runner insert\n     * @see QueryRunner#insert(Connection, String, ResultSetHandler, Object...)\n     * @throws SQLException if a database access error occurs\n     * @since 1.6\n     */\n    public <T> Future<T> insert(final Connection conn, final String sql, final ResultSetHandler<T> rsh, final Object... params) throws SQLException {\n        return executorService.submit(() -> queryRunner.insert(conn, sql, rsh, params));\n    }\n\n    /**\n     * Executes {@link QueryRunner#insert(String, ResultSetHandler)} asynchronously.\n     *\n     * @param <T> Return type expected\n     * @param sql SQL insert statement to execute\n     * @param rsh {@link ResultSetHandler} for handling the results\n     * @return {@link Future} that executes a query runner insert\n     * @see QueryRunner#insert(String, ResultSetHandler)\n     * @throws SQLException if a database access error occurs\n     * @since 1.6\n     */\n    public <T> Future<T> insert(final String sql, final ResultSetHandler<T> rsh) throws SQLException {\n        return executorService.submit(() -> queryRunner.insert(sql, rsh));\n    }\n\n    /**\n     * Executes {@link QueryRunner#insert(String, ResultSetHandler, Object...)} asynchronously.\n     *\n     * @param <T> Return type expected\n     * @param sql SQL insert statement to execute\n     * @param rsh {@link ResultSetHandler} for handling the results\n     * @param params Parameter values for substitution in the SQL statement\n     * @return {@link Future} that executes a query runner insert\n     * @see QueryRunner#insert(String, ResultSetHandler, Object...)\n     * @throws SQLException if a database access error occurs\n     * @since 1.6\n     */\n    public <T> Future<T> insert(final String sql, final ResultSetHandler<T> rsh, final Object... params) throws SQLException {\n        return executorService.submit(() -> queryRunner.insert(sql, rsh, params));\n    }\n\n    /**\n     * {@link QueryRunner#insertBatch(Connection, String, ResultSetHandler, Object[][])} asynchronously.\n     *\n     * @param <T> Return type expected\n     * @param conn {@link Connection} to use to execute the SQL statement\n     * @param sql SQL insert statement to execute\n     * @param rsh {@link ResultSetHandler} for handling the results\n     * @param params An array of query replacement parameters.  Each row in\n     *        this array is one set of batch replacement values.\n     * @return {@link Future} that executes a query runner batch insert\n     * @see QueryRunner#insertBatch(Connection, String, ResultSetHandler, Object[][])\n     * @throws SQLException if a database access error occurs\n     * @since 1.6\n     */\n    public <T> Future<T> insertBatch(final Connection conn, final String sql, final ResultSetHandler<T> rsh, final Object[][] params) throws SQLException {\n        return executorService.submit(() -> queryRunner.insertBatch(conn, sql, rsh, params));\n    }\n\n    /**\n     * {@link QueryRunner#insertBatch(String, ResultSetHandler, Object[][])} asynchronously.\n     *\n     * @param <T> Return type expected\n     * @param sql SQL insert statement to execute\n     * @param rsh {@link ResultSetHandler} for handling the results\n     * @param params An array of query replacement parameters.  Each row in\n     *        this array is one set of batch replacement values.\n     * @return {@link Future} that executes a query runner batch insert\n     * @see QueryRunner#insertBatch(String, ResultSetHandler, Object[][])\n     * @throws SQLException if a database access error occurs\n     * @since 1.6\n     */\n    public <T> Future<T> insertBatch(final String sql, final ResultSetHandler<T> rsh, final Object[][] params) throws SQLException {\n        return executorService.submit(() -> queryRunner.insertBatch(sql, rsh, params));\n    }\n\n    /**\n     * Execute an SQL SELECT query without any replacement parameters.  The\n     * caller is responsible for closing the connection.\n     * @param <T> The type of object that the handler returns\n     * @param conn The connection to execute the query in.\n     * @param sql The query to execute.\n     * @param rsh The handler that converts the results into an object.\n     * @return A {@code Future} which returns the result of the query call.\n     * @throws SQLException if a database access error occurs\n     */\n    public <T> Future<T> query(final Connection conn, final String sql, final ResultSetHandler<T> rsh) throws SQLException {\n        return executorService.submit(() -> queryRunner.query(conn, sql, rsh));\n    }\n\n    /**\n     * Execute an SQL SELECT query with replacement parameters.  The\n     * caller is responsible for closing the connection.\n     * @param <T> The type of object that the handler returns\n     * @param conn The connection to execute the query in.\n     * @param sql The query to execute.\n     * @param rsh The handler that converts the results into an object.\n     * @param params The replacement parameters.\n     * @return A {@code Future} which returns the result of the query call.\n     * @throws SQLException if a database access error occurs\n     */\n    public <T> Future<T> query(final Connection conn, final String sql, final ResultSetHandler<T> rsh, final Object... params)\n            throws SQLException {\n        return executorService.submit(() -> queryRunner.query(conn, sql, rsh, params));\n    }\n\n    /**\n     * Executes the given SELECT SQL without any replacement parameters.\n     * The {@code Connection} is retrieved from the\n     * {@code DataSource} set in the constructor.\n     * @param <T> The type of object that the handler returns\n     * @param sql The SQL statement to execute.\n     * @param rsh The handler used to create the result object from\n     * the {@code ResultSet}.\n     *\n     * @return A {@code Future} which returns the result of the query call.\n     * @throws SQLException if a database access error occurs\n     */\n    public <T> Future<T> query(final String sql, final ResultSetHandler<T> rsh) throws SQLException {\n        return executorService.submit(() -> queryRunner.query(sql, rsh));\n    }\n\n    /**\n     * Executes the given SELECT SQL query and returns a result object.\n     * The {@code Connection} is retrieved from the\n     * {@code DataSource} set in the constructor.\n     * @param <T> The type of object that the handler returns\n     * @param sql The SQL statement to execute.\n     * @param rsh The handler used to create the result object from\n     * the {@code ResultSet}.\n     * @param params Initialize the PreparedStatement's IN parameters with\n     * this array.\n     * @return A {@code Future} which returns the result of the query call.\n     * @throws SQLException if a database access error occurs\n     */\n    public <T> Future<T> query(final String sql, final ResultSetHandler<T> rsh, final Object... params) throws SQLException {\n        return executorService.submit(() -> queryRunner.query(sql, rsh, params));\n    }\n\n    /**\n     * Execute an SQL INSERT, UPDATE, or DELETE query without replacement\n     * parameters.\n     *\n     * @param conn The connection to use to run the query.\n     * @param sql The SQL to execute.\n     * @return A {@code Future} which returns the number of rows updated.\n     * @throws SQLException if a database access error occurs\n     */\n    public Future<Integer> update(final Connection conn, final String sql) throws SQLException {\n        return executorService.submit(() -> Integer.valueOf(queryRunner.update(conn, sql)));\n    }\n\n    /**\n     * Execute an SQL INSERT, UPDATE, or DELETE query with a single replacement\n     * parameter.\n     *\n     * @param conn The connection to use to run the query.\n     * @param sql The SQL to execute.\n     * @param param The replacement parameter.\n     * @return A {@code Future} which returns the number of rows updated.\n     * @throws SQLException if a database access error occurs\n     */\n    public Future<Integer> update(final Connection conn, final String sql, final Object param) throws SQLException {\n        return executorService.submit(() -> Integer.valueOf(queryRunner.update(conn, sql, param)));\n    }\n\n    /**\n     * Execute an SQL INSERT, UPDATE, or DELETE query.\n     *\n     * @param conn The connection to use to run the query.\n     * @param sql The SQL to execute.\n     * @param params The query replacement parameters.\n     * @return A {@code Future} which returns the number of rows updated.\n     * @throws SQLException if a database access error occurs\n     */\n    public Future<Integer> update(final Connection conn, final String sql, final Object... params) throws SQLException {\n        return executorService.submit(() -> Integer.valueOf(queryRunner.update(conn, sql, params)));\n    }\n\n    /**\n     * Executes the given INSERT, UPDATE, or DELETE SQL statement without\n     * any replacement parameters. The {@code Connection} is retrieved\n     * from the {@code DataSource} set in the constructor.  This\n     * {@code Connection} must be in auto-commit mode or the update will\n     * not be saved.\n     *\n     * @param sql The SQL statement to execute.\n     * @throws SQLException if a database access error occurs\n     * @return A {@code Future} which returns the number of rows updated.\n     */\n    public Future<Integer> update(final String sql) throws SQLException {\n        return executorService.submit(() -> Integer.valueOf(queryRunner.update(sql)));\n    }\n\n    /**\n     * Executes the given INSERT, UPDATE, or DELETE SQL statement with\n     * a single replacement parameter.  The {@code Connection} is\n     * retrieved from the {@code DataSource} set in the constructor.\n     * This {@code Connection} must be in auto-commit mode or the\n     * update will not be saved.\n     *\n     * @param sql The SQL statement to execute.\n     * @param param The replacement parameter.\n     * @throws SQLException if a database access error occurs\n     * @return A {@code Future} which returns the number of rows updated.\n     */\n    public Future<Integer> update(final String sql, final Object param) throws SQLException {\n        return executorService.submit(() -> Integer.valueOf(queryRunner.update(sql, param)));\n    }\n\n    /**\n     * Executes the given INSERT, UPDATE, or DELETE SQL statement.  The\n     * {@code Connection} is retrieved from the {@code DataSource}\n     * set in the constructor.  This {@code Connection} must be in\n     * auto-commit mode or the update will not be saved.\n     *\n     * @param sql The SQL statement to execute.\n     * @param params Initializes the PreparedStatement's IN (i.e. '?')\n     * parameters.\n     * @throws SQLException if a database access error occurs\n     * @return A {@code Future} which returns the number of rows updated.\n     */\n    public Future<Integer> update(final String sql, final Object... params) throws SQLException {\n        return executorService.submit(() -> Integer.valueOf(queryRunner.update(sql, params)));\n    }\n\n}\n", "file_hash": "c2744adf8eb167e14fccdc48763e4971d503e12c826326aa6de1058fb7ab718e", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils;", "import java.sql.Connection;", "import java.sql.PreparedStatement;", "import java.sql.ResultSet;", "import java.sql.SQLException;", "import java.util.concurrent.Callable;", "import java.util.concurrent.ExecutorService;", "import java.util.concurrent.Future;", "import javax.sql.DataSource;"], "methods": [], "classes": [{"original_string": "public class AsyncQueryRunner extends AbstractQueryRunner {\n\n    /**\n     * @deprecated No longer used by this class. Will be removed in a future version.\n     * Class that encapsulates the continuation for batch calls.\n     */\n    @Deprecated\n    protected class BatchCallableStatement implements Callable<int[]> {\n        private final String sql;\n        private final Object[][] params;\n        private final Connection conn;\n        private final boolean closeConn;\n        private final PreparedStatement ps;\n\n        /**\n         * Creates a new BatchCallableStatement instance.\n         *\n         * @param sql The SQL statement to execute.\n         * @param params An array of query replacement parameters.  Each row in\n         *        this array is one set of batch replacement values.\n         * @param conn The connection to use for the batch call.\n         * @param closeConn True if the connection should be closed, false otherwise.\n         * @param ps The {@link PreparedStatement} to be executed.\n         */\n        public BatchCallableStatement(final String sql, final Object[][] params, final Connection conn, final boolean closeConn, final PreparedStatement ps) {\n            this.sql = sql;\n            this.params = params.clone();\n            this.conn = conn;\n            this.closeConn = closeConn;\n            this.ps = ps;\n        }\n\n        /**\n         * The actual call to executeBatch.\n         *\n         * @return an array of update counts containing one element for each command in the batch.\n         * @throws SQLException if a database access error occurs or one of the commands sent to the database fails.\n         * @see PreparedStatement#executeBatch()\n         */\n        @Override\n        public int[] call() throws SQLException {\n            int[] ret = null;\n\n            try {\n                ret = ps.executeBatch();\n            } catch (final SQLException e) {\n                rethrow(e, sql, (Object[])params);\n            } finally {\n                close(ps);\n                if (closeConn) {\n                    close(conn);\n                }\n            }\n\n            return ret;\n        }\n    }\n    /**\n     * Class that encapsulates the continuation for query calls.\n     * @param <T> The type of the result from the call to handle.\n     */\n    protected class QueryCallableStatement<T> implements Callable<T> {\n        private final String sql;\n        private final Object[] params;\n        private final Connection conn;\n        private final boolean closeConn;\n        private final PreparedStatement ps;\n        private final ResultSetHandler<T> rsh;\n\n        /**\n         * Creates a new {@code QueryCallableStatement} instance.\n         *\n         * @param conn The connection to use for the batch call.\n         * @param closeConn True if the connection should be closed, false otherwise.\n         * @param ps The {@link PreparedStatement} to be executed.\n         * @param rsh The handler that converts the results into an object.\n         * @param sql The SQL statement to execute.\n         * @param params An array of query replacement parameters.  Each row in\n         *        this array is one set of batch replacement values.\n         */\n        public QueryCallableStatement(final Connection conn, final boolean closeConn, final PreparedStatement ps,\n                final ResultSetHandler<T> rsh, final String sql, final Object... params) {\n            this.sql = sql;\n            this.params = params;\n            this.conn = conn;\n            this.closeConn = closeConn;\n            this.ps = ps;\n            this.rsh = rsh;\n        }\n\n        /**\n         * The actual call to {@code handle()} method.\n         *\n         * @return an array of update counts containing one element for each command in the batch.\n         * @throws SQLException if a database access error occurs.\n         * @see ResultSetHandler#handle(ResultSet)\n         */\n        @Override\n        public T call() throws SQLException {\n            ResultSet resultSet = null;\n            T ret = null;\n\n            try {\n                resultSet = wrap(ps.executeQuery());\n                ret = rsh.handle(resultSet);\n            } catch (final SQLException e) {\n                rethrow(e, sql, params);\n            } finally {\n                try {\n                    close(resultSet);\n                } finally {\n                    close(ps);\n                    if (closeConn) {\n                        close(conn);\n                    }\n                }\n            }\n\n            return ret;\n        }\n\n    }\n\n    /**\n     * Class that encapsulates the continuation for update calls.\n     *\n     * @deprecated No longer used by this class. Will be removed in a future version.\n     */\n    @Deprecated\n    protected class UpdateCallableStatement implements Callable<Integer> {\n        private final String sql;\n        private final Object[] params;\n        private final Connection conn;\n        private final boolean closeConn;\n        private final PreparedStatement ps;\n\n        /**\n         * Constructs a new instance.\n         *\n         * @param conn The connection to use for the batch call.\n         * @param closeConn True if the connection should be closed, false otherwise.\n         * @param ps The {@link PreparedStatement} to be executed.\n         * @param sql The SQL statement to execute.\n         * @param params An array of query replacement parameters.  Each row in\n         *        this array is one set of batch replacement values.\n         */\n        public UpdateCallableStatement(final Connection conn, final boolean closeConn, final PreparedStatement ps, final String sql, final Object... params) {\n            this.sql = sql;\n            this.params = params;\n            this.conn = conn;\n            this.closeConn = closeConn;\n            this.ps = ps;\n        }\n\n        /**\n         * The actual call to {@code executeUpdate()} method.\n         *\n         * @return either (1) the row count for SQL Data Manipulation Language (DML) statements or\n         *                (2) 0 for SQL statements that return nothing\n         * @throws SQLException if a database access error occurs.\n         * @see PreparedStatement#executeUpdate()\n         */\n        @Override\n        public Integer call() throws SQLException {\n            int rows = 0;\n\n            try {\n                rows = ps.executeUpdate();\n            } catch (final SQLException e) {\n                rethrow(e, sql, params);\n            } finally {\n                close(ps);\n                if (closeConn) {\n                    close(conn);\n                }\n            }\n\n            return Integer.valueOf(rows);\n        }\n\n    }\n\n    private final ExecutorService executorService;\n\n    private final QueryRunner queryRunner;\n\n    /**\n     * @deprecated Use {@link #AsyncQueryRunner(ExecutorService, QueryRunner)} instead.\n     * Constructor for AsyncQueryRunner that controls the use of {@code ParameterMetaData}.\n     *\n     * @param pmdKnownBroken Some drivers don't support {@link java.sql.ParameterMetaData#getParameterType(int) };\n     * if {@code pmdKnownBroken} is set to true, we won't even try it; if false, we'll try it,\n     * and if it breaks, we'll remember not to use it again.\n     * @param executorService the {@code ExecutorService} instance used to run JDBC invocations concurrently.\n     */\n    @Deprecated\n    public AsyncQueryRunner(final boolean pmdKnownBroken, final ExecutorService executorService) {\n        this(null, pmdKnownBroken, executorService);\n    }\n\n    /**\n     * @deprecated Use {@link #AsyncQueryRunner(ExecutorService, QueryRunner)} instead.\n     * Constructor for AsyncQueryRunner that take a {@code DataSource} and controls the use of {@code ParameterMetaData}.\n     * Methods that do not take a {@code Connection} parameter will retrieve connections from this\n     * {@code DataSource}.\n     *\n     * @param ds The {@code DataSource} to retrieve connections from.\n     * @param pmdKnownBroken Some drivers don't support {@link java.sql.ParameterMetaData#getParameterType(int) };\n     * if {@code pmdKnownBroken} is set to true, we won't even try it; if false, we'll try it,\n     * and if it breaks, we'll remember not to use it again.\n     * @param executorService the {@code ExecutorService} instance used to run JDBC invocations concurrently.\n     */\n    @Deprecated\n    public AsyncQueryRunner(final DataSource ds, final boolean pmdKnownBroken, final ExecutorService executorService) {\n        super(ds, pmdKnownBroken);\n        this.executorService = executorService;\n        this.queryRunner = new QueryRunner(ds, pmdKnownBroken);\n    }\n\n    /**\n     * @deprecated Use {@link #AsyncQueryRunner(ExecutorService, QueryRunner)} instead.\n     * Constructor for AsyncQueryRunner that takes a {@code DataSource}.\n     *\n     * Methods that do not take a {@code Connection} parameter will retrieve connections from this\n     * {@code DataSource}.\n     *\n     * @param ds The {@code DataSource} to retrieve connections from.\n     * @param executorService the {@code ExecutorService} instance used to run JDBC invocations concurrently.\n     */\n    @Deprecated\n    public AsyncQueryRunner(final DataSource ds, final ExecutorService executorService) {\n        this(ds, false, executorService);\n    }\n\n    /**\n     * Constructor for AsyncQueryRunner.\n     *\n     * @param executorService the {@code ExecutorService} instance used to run JDBC invocations concurrently.\n     */\n    public AsyncQueryRunner(final ExecutorService executorService) {\n        this(null, false, executorService);\n    }\n\n    /**\n     * Constructor for AsyncQueryRunner which uses a provided ExecutorService and underlying QueryRunner.\n     *\n     * @param executorService the {@code ExecutorService} instance used to run JDBC invocations concurrently.\n     * @param queryRunner the {@code QueryRunner} instance to use for the queries.\n     * @since 1.5\n     */\n    public AsyncQueryRunner(final ExecutorService executorService, final QueryRunner queryRunner) {\n        this.executorService = executorService;\n        this.queryRunner = queryRunner;\n    }\n\n    /**\n     * Execute a batch of SQL INSERT, UPDATE, or DELETE queries.\n     *\n     * @param conn The {@code Connection} to use to run the query.  The caller is\n     * responsible for closing this Connection.\n     * @param sql The SQL to execute.\n     * @param params An array of query replacement parameters.  Each row in\n     * this array is one set of batch replacement values.\n     * @return A {@code Future} which returns the number of rows updated per statement.\n     * @throws SQLException if a database access error occurs\n     */\n    public Future<int[]> batch(final Connection conn, final String sql, final Object[][] params) throws SQLException {\n        return executorService.submit(() -> queryRunner.batch(conn, sql, params));\n    }\n\n    /**\n     * Execute a batch of SQL INSERT, UPDATE, or DELETE queries.  The\n     * {@code Connection} is retrieved from the {@code DataSource}\n     * set in the constructor.  This {@code Connection} must be in\n     * auto-commit mode or the update will not be saved.\n     *\n     * @param sql The SQL to execute.\n     * @param params An array of query replacement parameters.  Each row in\n     * this array is one set of batch replacement values.\n     * @return A {@code Future} which returns the number of rows updated per statement.\n     * @throws SQLException if a database access error occurs\n     */\n    public Future<int[]> batch(final String sql, final Object[][] params) throws SQLException {\n        return executorService.submit(() -> queryRunner.batch(sql, params));\n    }\n\n    /**\n     * Executes {@link QueryRunner#insert(Connection, String, ResultSetHandler)} asynchronously.\n     *\n     * @param <T> Return type expected\n     * @param conn {@link Connection} to use to execute the SQL statement\n     * @param sql SQL insert statement to execute\n     * @param rsh {@link ResultSetHandler} for handling the results\n     * @return {@link Future} that executes a query runner insert\n     * @see QueryRunner#insert(Connection, String, ResultSetHandler)\n     * @throws SQLException if a database access error occurs\n     * @since 1.6\n     */\n    public <T> Future<T> insert(final Connection conn, final String sql, final ResultSetHandler<T> rsh) throws SQLException {\n        return executorService.submit(() -> queryRunner.insert(conn, sql, rsh));\n    }\n\n    /**\n     * Executes {@link QueryRunner#insert(Connection, String, ResultSetHandler, Object...)} asynchronously.\n     *\n     * @param <T> Return type expected\n     * @param conn {@link Connection} to use to execute the SQL statement\n     * @param sql SQL insert statement to execute\n     * @param rsh {@link ResultSetHandler} for handling the results\n     * @param params Parameter values for substitution in the SQL statement\n     * @return {@link Future} that executes a query runner insert\n     * @see QueryRunner#insert(Connection, String, ResultSetHandler, Object...)\n     * @throws SQLException if a database access error occurs\n     * @since 1.6\n     */\n    public <T> Future<T> insert(final Connection conn, final String sql, final ResultSetHandler<T> rsh, final Object... params) throws SQLException {\n        return executorService.submit(() -> queryRunner.insert(conn, sql, rsh, params));\n    }\n\n    /**\n     * Executes {@link QueryRunner#insert(String, ResultSetHandler)} asynchronously.\n     *\n     * @param <T> Return type expected\n     * @param sql SQL insert statement to execute\n     * @param rsh {@link ResultSetHandler} for handling the results\n     * @return {@link Future} that executes a query runner insert\n     * @see QueryRunner#insert(String, ResultSetHandler)\n     * @throws SQLException if a database access error occurs\n     * @since 1.6\n     */\n    public <T> Future<T> insert(final String sql, final ResultSetHandler<T> rsh) throws SQLException {\n        return executorService.submit(() -> queryRunner.insert(sql, rsh));\n    }\n\n    /**\n     * Executes {@link QueryRunner#insert(String, ResultSetHandler, Object...)} asynchronously.\n     *\n     * @param <T> Return type expected\n     * @param sql SQL insert statement to execute\n     * @param rsh {@link ResultSetHandler} for handling the results\n     * @param params Parameter values for substitution in the SQL statement\n     * @return {@link Future} that executes a query runner insert\n     * @see QueryRunner#insert(String, ResultSetHandler, Object...)\n     * @throws SQLException if a database access error occurs\n     * @since 1.6\n     */\n    public <T> Future<T> insert(final String sql, final ResultSetHandler<T> rsh, final Object... params) throws SQLException {\n        return executorService.submit(() -> queryRunner.insert(sql, rsh, params));\n    }\n\n    /**\n     * {@link QueryRunner#insertBatch(Connection, String, ResultSetHandler, Object[][])} asynchronously.\n     *\n     * @param <T> Return type expected\n     * @param conn {@link Connection} to use to execute the SQL statement\n     * @param sql SQL insert statement to execute\n     * @param rsh {@link ResultSetHandler} for handling the results\n     * @param params An array of query replacement parameters.  Each row in\n     *        this array is one set of batch replacement values.\n     * @return {@link Future} that executes a query runner batch insert\n     * @see QueryRunner#insertBatch(Connection, String, ResultSetHandler, Object[][])\n     * @throws SQLException if a database access error occurs\n     * @since 1.6\n     */\n    public <T> Future<T> insertBatch(final Connection conn, final String sql, final ResultSetHandler<T> rsh, final Object[][] params) throws SQLException {\n        return executorService.submit(() -> queryRunner.insertBatch(conn, sql, rsh, params));\n    }\n\n    /**\n     * {@link QueryRunner#insertBatch(String, ResultSetHandler, Object[][])} asynchronously.\n     *\n     * @param <T> Return type expected\n     * @param sql SQL insert statement to execute\n     * @param rsh {@link ResultSetHandler} for handling the results\n     * @param params An array of query replacement parameters.  Each row in\n     *        this array is one set of batch replacement values.\n     * @return {@link Future} that executes a query runner batch insert\n     * @see QueryRunner#insertBatch(String, ResultSetHandler, Object[][])\n     * @throws SQLException if a database access error occurs\n     * @since 1.6\n     */\n    public <T> Future<T> insertBatch(final String sql, final ResultSetHandler<T> rsh, final Object[][] params) throws SQLException {\n        return executorService.submit(() -> queryRunner.insertBatch(sql, rsh, params));\n    }\n\n    /**\n     * Execute an SQL SELECT query without any replacement parameters.  The\n     * caller is responsible for closing the connection.\n     * @param <T> The type of object that the handler returns\n     * @param conn The connection to execute the query in.\n     * @param sql The query to execute.\n     * @param rsh The handler that converts the results into an object.\n     * @return A {@code Future} which returns the result of the query call.\n     * @throws SQLException if a database access error occurs\n     */\n    public <T> Future<T> query(final Connection conn, final String sql, final ResultSetHandler<T> rsh) throws SQLException {\n        return executorService.submit(() -> queryRunner.query(conn, sql, rsh));\n    }\n\n    /**\n     * Execute an SQL SELECT query with replacement parameters.  The\n     * caller is responsible for closing the connection.\n     * @param <T> The type of object that the handler returns\n     * @param conn The connection to execute the query in.\n     * @param sql The query to execute.\n     * @param rsh The handler that converts the results into an object.\n     * @param params The replacement parameters.\n     * @return A {@code Future} which returns the result of the query call.\n     * @throws SQLException if a database access error occurs\n     */\n    public <T> Future<T> query(final Connection conn, final String sql, final ResultSetHandler<T> rsh, final Object... params)\n            throws SQLException {\n        return executorService.submit(() -> queryRunner.query(conn, sql, rsh, params));\n    }\n\n    /**\n     * Executes the given SELECT SQL without any replacement parameters.\n     * The {@code Connection} is retrieved from the\n     * {@code DataSource} set in the constructor.\n     * @param <T> The type of object that the handler returns\n     * @param sql The SQL statement to execute.\n     * @param rsh The handler used to create the result object from\n     * the {@code ResultSet}.\n     *\n     * @return A {@code Future} which returns the result of the query call.\n     * @throws SQLException if a database access error occurs\n     */\n    public <T> Future<T> query(final String sql, final ResultSetHandler<T> rsh) throws SQLException {\n        return executorService.submit(() -> queryRunner.query(sql, rsh));\n    }\n\n    /**\n     * Executes the given SELECT SQL query and returns a result object.\n     * The {@code Connection} is retrieved from the\n     * {@code DataSource} set in the constructor.\n     * @param <T> The type of object that the handler returns\n     * @param sql The SQL statement to execute.\n     * @param rsh The handler used to create the result object from\n     * the {@code ResultSet}.\n     * @param params Initialize the PreparedStatement's IN parameters with\n     * this array.\n     * @return A {@code Future} which returns the result of the query call.\n     * @throws SQLException if a database access error occurs\n     */\n    public <T> Future<T> query(final String sql, final ResultSetHandler<T> rsh, final Object... params) throws SQLException {\n        return executorService.submit(() -> queryRunner.query(sql, rsh, params));\n    }\n\n    /**\n     * Execute an SQL INSERT, UPDATE, or DELETE query without replacement\n     * parameters.\n     *\n     * @param conn The connection to use to run the query.\n     * @param sql The SQL to execute.\n     * @return A {@code Future} which returns the number of rows updated.\n     * @throws SQLException if a database access error occurs\n     */\n    public Future<Integer> update(final Connection conn, final String sql) throws SQLException {\n        return executorService.submit(() -> Integer.valueOf(queryRunner.update(conn, sql)));\n    }\n\n    /**\n     * Execute an SQL INSERT, UPDATE, or DELETE query with a single replacement\n     * parameter.\n     *\n     * @param conn The connection to use to run the query.\n     * @param sql The SQL to execute.\n     * @param param The replacement parameter.\n     * @return A {@code Future} which returns the number of rows updated.\n     * @throws SQLException if a database access error occurs\n     */\n    public Future<Integer> update(final Connection conn, final String sql, final Object param) throws SQLException {\n        return executorService.submit(() -> Integer.valueOf(queryRunner.update(conn, sql, param)));\n    }\n\n    /**\n     * Execute an SQL INSERT, UPDATE, or DELETE query.\n     *\n     * @param conn The connection to use to run the query.\n     * @param sql The SQL to execute.\n     * @param params The query replacement parameters.\n     * @return A {@code Future} which returns the number of rows updated.\n     * @throws SQLException if a database access error occurs\n     */\n    public Future<Integer> update(final Connection conn, final String sql, final Object... params) throws SQLException {\n        return executorService.submit(() -> Integer.valueOf(queryRunner.update(conn, sql, params)));\n    }\n\n    /**\n     * Executes the given INSERT, UPDATE, or DELETE SQL statement without\n     * any replacement parameters. The {@code Connection} is retrieved\n     * from the {@code DataSource} set in the constructor.  This\n     * {@code Connection} must be in auto-commit mode or the update will\n     * not be saved.\n     *\n     * @param sql The SQL statement to execute.\n     * @throws SQLException if a database access error occurs\n     * @return A {@code Future} which returns the number of rows updated.\n     */\n    public Future<Integer> update(final String sql) throws SQLException {\n        return executorService.submit(() -> Integer.valueOf(queryRunner.update(sql)));\n    }\n\n    /**\n     * Executes the given INSERT, UPDATE, or DELETE SQL statement with\n     * a single replacement parameter.  The {@code Connection} is\n     * retrieved from the {@code DataSource} set in the constructor.\n     * This {@code Connection} must be in auto-commit mode or the\n     * update will not be saved.\n     *\n     * @param sql The SQL statement to execute.\n     * @param param The replacement parameter.\n     * @throws SQLException if a database access error occurs\n     * @return A {@code Future} which returns the number of rows updated.\n     */\n    public Future<Integer> update(final String sql, final Object param) throws SQLException {\n        return executorService.submit(() -> Integer.valueOf(queryRunner.update(sql, param)));\n    }\n\n    /**\n     * Executes the given INSERT, UPDATE, or DELETE SQL statement.  The\n     * {@code Connection} is retrieved from the {@code DataSource}\n     * set in the constructor.  This {@code Connection} must be in\n     * auto-commit mode or the update will not be saved.\n     *\n     * @param sql The SQL statement to execute.\n     * @param params Initializes the PreparedStatement's IN (i.e. '?')\n     * parameters.\n     * @throws SQLException if a database access error occurs\n     * @return A {@code Future} which returns the number of rows updated.\n     */\n    public Future<Integer> update(final String sql, final Object... params) throws SQLException {\n        return executorService.submit(() -> Integer.valueOf(queryRunner.update(sql, params)));\n    }\n\n}", "definition": "public class AsyncQueryRunner extends AbstractQueryRunner", "class_docstring": "\nExecutes SQL queries with pluggable strategies for handling\n{@code ResultSet}s.  This class is thread safe.\n\n@see ResultSetHandler\n@since 1.4\n", "name": "AsyncQueryRunner", "super_interfaces": [], "superclasses": "AbstractQueryRunner", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final ExecutorService executorService;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ExecutorService", "name": "executorService", "syntax_pass": true}, {"attribute_expression": "private final QueryRunner queryRunner;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "QueryRunner", "name": "queryRunner", "syntax_pass": true}], "classes": [{"original_string": "    @Deprecated\n    protected class BatchCallableStatement implements Callable<int[]> {\n        private final String sql;\n        private final Object[][] params;\n        private final Connection conn;\n        private final boolean closeConn;\n        private final PreparedStatement ps;\n\n        /**\n         * Creates a new BatchCallableStatement instance.\n         *\n         * @param sql The SQL statement to execute.\n         * @param params An array of query replacement parameters.  Each row in\n         *        this array is one set of batch replacement values.\n         * @param conn The connection to use for the batch call.\n         * @param closeConn True if the connection should be closed, false otherwise.\n         * @param ps The {@link PreparedStatement} to be executed.\n         */\n        public BatchCallableStatement(final String sql, final Object[][] params, final Connection conn, final boolean closeConn, final PreparedStatement ps) {\n            this.sql = sql;\n            this.params = params.clone();\n            this.conn = conn;\n            this.closeConn = closeConn;\n            this.ps = ps;\n        }\n\n        /**\n         * The actual call to executeBatch.\n         *\n         * @return an array of update counts containing one element for each command in the batch.\n         * @throws SQLException if a database access error occurs or one of the commands sent to the database fails.\n         * @see PreparedStatement#executeBatch()\n         */\n        @Override\n        public int[] call() throws SQLException {\n            int[] ret = null;\n\n            try {\n                ret = ps.executeBatch();\n            } catch (final SQLException e) {\n                rethrow(e, sql, (Object[])params);\n            } finally {\n                close(ps);\n                if (closeConn) {\n                    close(conn);\n                }\n            }\n\n            return ret;\n        }\n    }", "definition": "    @Deprecated\n    protected class BatchCallableStatement implements Callable<int[]>", "class_docstring": "\n@deprecated No longer used by this class. Will be removed in a future version.\nClass that encapsulates the continuation for batch calls.\n", "name": "BatchCallableStatement", "super_interfaces": ["Callable<int[]>"], "superclasses": "", "attributes": {"modifiers": "@Deprecated\n    protected", "marker_annotations": ["@Deprecated"], "non_marker_annotations": ["protected"], "comments": [], "fields": [{"attribute_expression": "private final String sql;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "sql", "syntax_pass": true}, {"attribute_expression": "private final Object[][] params;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Object[][]", "name": "params", "syntax_pass": true}, {"attribute_expression": "private final Connection conn;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Connection", "name": "conn", "syntax_pass": true}, {"attribute_expression": "private final boolean closeConn;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "boolean", "name": "closeConn", "syntax_pass": true}, {"attribute_expression": "private final PreparedStatement ps;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "PreparedStatement", "name": "ps", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public BatchCallableStatement(final String sql, final Object[][] params, final Connection conn, final boolean closeConn, final PreparedStatement ps) {\n            this.sql = sql;\n            this.params = params.clone();\n            this.conn = conn;\n            this.closeConn = closeConn;\n            this.ps = ps;\n        }", "docstring": "\nCreates a new BatchCallableStatement instance.\n\n@param sql The SQL statement to execute.\n@param params An array of query replacement parameters.  Each row in\n       this array is one set of batch replacement values.\n@param conn The connection to use for the batch call.\n@param closeConn True if the connection should be closed, false otherwise.\n@param ps The {@link PreparedStatement} to be executed.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "BatchCallableStatement", "params": [{"name": "sql", "type": "String"}, {"name": "params", "type": "Object[][]"}, {"name": "conn", "type": "Connection"}, {"name": "closeConn", "type": "boolean"}, {"name": "ps", "type": "PreparedStatement"}], "body": "                                                                                                                                                             {\n            this.sql = sql;\n            this.params = params.clone();\n            this.conn = conn;\n            this.closeConn = closeConn;\n            this.ps = ps;\n        }", "signature": "public BatchCallableStatement(final String sql, final Object[][] params, final Connection conn, final boolean closeConn, final PreparedStatement ps)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int[] call() throws SQLException {\n            int[] ret = null;\n\n            try {\n                ret = ps.executeBatch();\n            } catch (final SQLException e) {\n                rethrow(e, sql, (Object[])params);\n            } finally {\n                close(ps);\n                if (closeConn) {\n                    close(conn);\n                }\n            }\n\n            return ret;\n        }", "docstring": "\nThe actual call to executeBatch.\n\n@return an array of update counts containing one element for each command in the batch.\n@throws SQLException if a database access error occurs or one of the commands sent to the database fails.\n@see PreparedStatement#executeBatch()\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int[]", "classes": []}, "name": "call", "params": [], "body": "                                                {\n            int[] ret = null;\n\n            try {\n                ret = ps.executeBatch();\n            } catch (final SQLException e) {\n                rethrow(e, sql, (Object[])params);\n            } finally {\n                close(ps);\n                if (closeConn) {\n                    close(conn);\n                }\n            }\n\n            return ret;\n        }", "signature": "@Override\n        public int[] call()"}]}, {"original_string": "    protected class QueryCallableStatement<T> implements Callable<T> {\n        private final String sql;\n        private final Object[] params;\n        private final Connection conn;\n        private final boolean closeConn;\n        private final PreparedStatement ps;\n        private final ResultSetHandler<T> rsh;\n\n        /**\n         * Creates a new {@code QueryCallableStatement} instance.\n         *\n         * @param conn The connection to use for the batch call.\n         * @param closeConn True if the connection should be closed, false otherwise.\n         * @param ps The {@link PreparedStatement} to be executed.\n         * @param rsh The handler that converts the results into an object.\n         * @param sql The SQL statement to execute.\n         * @param params An array of query replacement parameters.  Each row in\n         *        this array is one set of batch replacement values.\n         */\n        public QueryCallableStatement(final Connection conn, final boolean closeConn, final PreparedStatement ps,\n                final ResultSetHandler<T> rsh, final String sql, final Object... params) {\n            this.sql = sql;\n            this.params = params;\n            this.conn = conn;\n            this.closeConn = closeConn;\n            this.ps = ps;\n            this.rsh = rsh;\n        }\n\n        /**\n         * The actual call to {@code handle()} method.\n         *\n         * @return an array of update counts containing one element for each command in the batch.\n         * @throws SQLException if a database access error occurs.\n         * @see ResultSetHandler#handle(ResultSet)\n         */\n        @Override\n        public T call() throws SQLException {\n            ResultSet resultSet = null;\n            T ret = null;\n\n            try {\n                resultSet = wrap(ps.executeQuery());\n                ret = rsh.handle(resultSet);\n            } catch (final SQLException e) {\n                rethrow(e, sql, params);\n            } finally {\n                try {\n                    close(resultSet);\n                } finally {\n                    close(ps);\n                    if (closeConn) {\n                        close(conn);\n                    }\n                }\n            }\n\n            return ret;\n        }\n\n    }", "definition": "    protected class QueryCallableStatement<T> implements Callable<T>", "class_docstring": "\nClass that encapsulates the continuation for query calls.\n@param <T> The type of the result from the call to handle.\n", "name": "QueryCallableStatement", "super_interfaces": ["Callable<T>"], "superclasses": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "fields": [{"attribute_expression": "private final String sql;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "sql", "syntax_pass": true}, {"attribute_expression": "private final Object[] params;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Object[]", "name": "params", "syntax_pass": true}, {"attribute_expression": "private final Connection conn;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Connection", "name": "conn", "syntax_pass": true}, {"attribute_expression": "private final boolean closeConn;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "boolean", "name": "closeConn", "syntax_pass": true}, {"attribute_expression": "private final PreparedStatement ps;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "PreparedStatement", "name": "ps", "syntax_pass": true}, {"attribute_expression": "private final ResultSetHandler<T> rsh;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ResultSetHandler<T>", "name": "rsh", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public QueryCallableStatement(final Connection conn, final boolean closeConn, final PreparedStatement ps,\n                final ResultSetHandler<T> rsh, final String sql, final Object... params) {\n            this.sql = sql;\n            this.params = params;\n            this.conn = conn;\n            this.closeConn = closeConn;\n            this.ps = ps;\n            this.rsh = rsh;\n        }", "docstring": "\nCreates a new {@code QueryCallableStatement} instance.\n\n@param conn The connection to use for the batch call.\n@param closeConn True if the connection should be closed, false otherwise.\n@param ps The {@link PreparedStatement} to be executed.\n@param rsh The handler that converts the results into an object.\n@param sql The SQL statement to execute.\n@param params An array of query replacement parameters.  Each row in\n       this array is one set of batch replacement values.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "QueryCallableStatement", "params": [{"name": "conn", "type": "Connection"}, {"name": "closeConn", "type": "boolean"}, {"name": "ps", "type": "PreparedStatement"}, {"name": "rsh", "type": "ResultSetHandler<T>"}, {"name": "sql", "type": "String"}], "body": "                                                                                         {\n            this.sql = sql;\n            this.params = params;\n            this.conn = conn;\n            this.closeConn = closeConn;\n            this.ps = ps;\n            this.rsh = rsh;\n        }", "signature": "public QueryCallableStatement(final Connection conn, final boolean closeConn, final PreparedStatement ps,\n                final ResultSetHandler<T> rsh, final String sql, final Object... params)"}, {"syntax_pass": true, "original_string": "        @Override\n        public T call() throws SQLException {\n            ResultSet resultSet = null;\n            T ret = null;\n\n            try {\n                resultSet = wrap(ps.executeQuery());\n                ret = rsh.handle(resultSet);\n            } catch (final SQLException e) {\n                rethrow(e, sql, params);\n            } finally {\n                try {\n                    close(resultSet);\n                } finally {\n                    close(ps);\n                    if (closeConn) {\n                        close(conn);\n                    }\n                }\n            }\n\n            return ret;\n        }", "docstring": "\nThe actual call to {@code handle()} method.\n\n@return an array of update counts containing one element for each command in the batch.\n@throws SQLException if a database access error occurs.\n@see ResultSetHandler#handle(ResultSet)\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "T", "classes": []}, "name": "call", "params": [], "body": "                                            {\n            ResultSet resultSet = null;\n            T ret = null;\n\n            try {\n                resultSet = wrap(ps.executeQuery());\n                ret = rsh.handle(resultSet);\n            } catch (final SQLException e) {\n                rethrow(e, sql, params);\n            } finally {\n                try {\n                    close(resultSet);\n                } finally {\n                    close(ps);\n                    if (closeConn) {\n                        close(conn);\n                    }\n                }\n            }\n\n            return ret;\n        }", "signature": "@Override\n        public T call()"}]}, {"original_string": "    @Deprecated\n    protected class UpdateCallableStatement implements Callable<Integer> {\n        private final String sql;\n        private final Object[] params;\n        private final Connection conn;\n        private final boolean closeConn;\n        private final PreparedStatement ps;\n\n        /**\n         * Constructs a new instance.\n         *\n         * @param conn The connection to use for the batch call.\n         * @param closeConn True if the connection should be closed, false otherwise.\n         * @param ps The {@link PreparedStatement} to be executed.\n         * @param sql The SQL statement to execute.\n         * @param params An array of query replacement parameters.  Each row in\n         *        this array is one set of batch replacement values.\n         */\n        public UpdateCallableStatement(final Connection conn, final boolean closeConn, final PreparedStatement ps, final String sql, final Object... params) {\n            this.sql = sql;\n            this.params = params;\n            this.conn = conn;\n            this.closeConn = closeConn;\n            this.ps = ps;\n        }\n\n        /**\n         * The actual call to {@code executeUpdate()} method.\n         *\n         * @return either (1) the row count for SQL Data Manipulation Language (DML) statements or\n         *                (2) 0 for SQL statements that return nothing\n         * @throws SQLException if a database access error occurs.\n         * @see PreparedStatement#executeUpdate()\n         */\n        @Override\n        public Integer call() throws SQLException {\n            int rows = 0;\n\n            try {\n                rows = ps.executeUpdate();\n            } catch (final SQLException e) {\n                rethrow(e, sql, params);\n            } finally {\n                close(ps);\n                if (closeConn) {\n                    close(conn);\n                }\n            }\n\n            return Integer.valueOf(rows);\n        }\n\n    }", "definition": "    @Deprecated\n    protected class UpdateCallableStatement implements Callable<Integer>", "class_docstring": "\nClass that encapsulates the continuation for update calls.\n\n@deprecated No longer used by this class. Will be removed in a future version.\n", "name": "UpdateCallableStatement", "super_interfaces": ["Callable<Integer>"], "superclasses": "", "attributes": {"modifiers": "@Deprecated\n    protected", "marker_annotations": ["@Deprecated"], "non_marker_annotations": ["protected"], "comments": [], "fields": [{"attribute_expression": "private final String sql;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "sql", "syntax_pass": true}, {"attribute_expression": "private final Object[] params;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Object[]", "name": "params", "syntax_pass": true}, {"attribute_expression": "private final Connection conn;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Connection", "name": "conn", "syntax_pass": true}, {"attribute_expression": "private final boolean closeConn;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "boolean", "name": "closeConn", "syntax_pass": true}, {"attribute_expression": "private final PreparedStatement ps;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "PreparedStatement", "name": "ps", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public UpdateCallableStatement(final Connection conn, final boolean closeConn, final PreparedStatement ps, final String sql, final Object... params) {\n            this.sql = sql;\n            this.params = params;\n            this.conn = conn;\n            this.closeConn = closeConn;\n            this.ps = ps;\n        }", "docstring": "\nConstructs a new instance.\n\n@param conn The connection to use for the batch call.\n@param closeConn True if the connection should be closed, false otherwise.\n@param ps The {@link PreparedStatement} to be executed.\n@param sql The SQL statement to execute.\n@param params An array of query replacement parameters.  Each row in\n       this array is one set of batch replacement values.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "UpdateCallableStatement", "params": [{"name": "conn", "type": "Connection"}, {"name": "closeConn", "type": "boolean"}, {"name": "ps", "type": "PreparedStatement"}, {"name": "sql", "type": "String"}], "body": "                                                                                                                                                             {\n            this.sql = sql;\n            this.params = params;\n            this.conn = conn;\n            this.closeConn = closeConn;\n            this.ps = ps;\n        }", "signature": "public UpdateCallableStatement(final Connection conn, final boolean closeConn, final PreparedStatement ps, final String sql, final Object... params)"}, {"syntax_pass": true, "original_string": "        @Override\n        public Integer call() throws SQLException {\n            int rows = 0;\n\n            try {\n                rows = ps.executeUpdate();\n            } catch (final SQLException e) {\n                rethrow(e, sql, params);\n            } finally {\n                close(ps);\n                if (closeConn) {\n                    close(conn);\n                }\n            }\n\n            return Integer.valueOf(rows);\n        }", "docstring": "\nThe actual call to {@code executeUpdate()} method.\n\n@return either (1) the row count for SQL Data Manipulation Language (DML) statements or\n               (2) 0 for SQL statements that return nothing\n@throws SQLException if a database access error occurs.\n@see PreparedStatement#executeUpdate()\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Integer", "classes": []}, "name": "call", "params": [], "body": "                                                  {\n            int rows = 0;\n\n            try {\n                rows = ps.executeUpdate();\n            } catch (final SQLException e) {\n                rethrow(e, sql, params);\n            } finally {\n                close(ps);\n                if (closeConn) {\n                    close(conn);\n                }\n            }\n\n            return Integer.valueOf(rows);\n        }", "signature": "@Override\n        public Integer call()"}]}]}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Deprecated\n    public AsyncQueryRunner(final boolean pmdKnownBroken, final ExecutorService executorService) {\n        this(null, pmdKnownBroken, executorService);\n    }", "docstring": "\n@deprecated Use {@link #AsyncQueryRunner(ExecutorService, QueryRunner)} instead.\nConstructor for AsyncQueryRunner that controls the use of {@code ParameterMetaData}.\n\n@param pmdKnownBroken Some drivers don't support {@link java.sql.ParameterMetaData#getParameterType(int) };\nif {@code pmdKnownBroken} is set to true, we won't even try it; if false, we'll try it,\nand if it breaks, we'll remember not to use it again.\n@param executorService the {@code ExecutorService} instance used to run JDBC invocations concurrently.\n", "attributes": {"modifiers": "@Deprecated\n    public", "marker_annotations": ["@Deprecated"], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "AsyncQueryRunner", "params": [{"name": "pmdKnownBroken", "type": "boolean"}, {"name": "executorService", "type": "ExecutorService"}], "body": "                                                                                                 {\n        this(null, pmdKnownBroken, executorService);\n    }", "signature": "@Deprecated\n    public AsyncQueryRunner(final boolean pmdKnownBroken, final ExecutorService executorService)"}, {"syntax_pass": true, "original_string": "    @Deprecated\n    public AsyncQueryRunner(final DataSource ds, final boolean pmdKnownBroken, final ExecutorService executorService) {\n        super(ds, pmdKnownBroken);\n        this.executorService = executorService;\n        this.queryRunner = new QueryRunner(ds, pmdKnownBroken);\n    }", "docstring": "\n@deprecated Use {@link #AsyncQueryRunner(ExecutorService, QueryRunner)} instead.\nConstructor for AsyncQueryRunner that take a {@code DataSource} and controls the use of {@code ParameterMetaData}.\nMethods that do not take a {@code Connection} parameter will retrieve connections from this\n{@code DataSource}.\n\n@param ds The {@code DataSource} to retrieve connections from.\n@param pmdKnownBroken Some drivers don't support {@link java.sql.ParameterMetaData#getParameterType(int) };\nif {@code pmdKnownBroken} is set to true, we won't even try it; if false, we'll try it,\nand if it breaks, we'll remember not to use it again.\n@param executorService the {@code ExecutorService} instance used to run JDBC invocations concurrently.\n", "attributes": {"modifiers": "@Deprecated\n    public", "marker_annotations": ["@Deprecated"], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "AsyncQueryRunner", "params": [{"name": "ds", "type": "DataSource"}, {"name": "pmdKnownBroken", "type": "boolean"}, {"name": "executorService", "type": "ExecutorService"}], "body": "                                                                                                                      {\n        super(ds, pmdKnownBroken);\n        this.executorService = executorService;\n        this.queryRunner = new QueryRunner(ds, pmdKnownBroken);\n    }", "signature": "@Deprecated\n    public AsyncQueryRunner(final DataSource ds, final boolean pmdKnownBroken, final ExecutorService executorService)"}, {"syntax_pass": true, "original_string": "    @Deprecated\n    public AsyncQueryRunner(final DataSource ds, final ExecutorService executorService) {\n        this(ds, false, executorService);\n    }", "docstring": "\n@deprecated Use {@link #AsyncQueryRunner(ExecutorService, QueryRunner)} instead.\nConstructor for AsyncQueryRunner that takes a {@code DataSource}.\n\nMethods that do not take a {@code Connection} parameter will retrieve connections from this\n{@code DataSource}.\n\n@param ds The {@code DataSource} to retrieve connections from.\n@param executorService the {@code ExecutorService} instance used to run JDBC invocations concurrently.\n", "attributes": {"modifiers": "@Deprecated\n    public", "marker_annotations": ["@Deprecated"], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "AsyncQueryRunner", "params": [{"name": "ds", "type": "DataSource"}, {"name": "executorService", "type": "ExecutorService"}], "body": "                                                                                        {\n        this(ds, false, executorService);\n    }", "signature": "@Deprecated\n    public AsyncQueryRunner(final DataSource ds, final ExecutorService executorService)"}, {"syntax_pass": true, "original_string": "    public AsyncQueryRunner(final ExecutorService executorService) {\n        this(null, false, executorService);\n    }", "docstring": "\nConstructor for AsyncQueryRunner.\n\n@param executorService the {@code ExecutorService} instance used to run JDBC invocations concurrently.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "AsyncQueryRunner", "params": [{"name": "executorService", "type": "ExecutorService"}], "body": "                                                                   {\n        this(null, false, executorService);\n    }", "signature": "public AsyncQueryRunner(final ExecutorService executorService)"}, {"syntax_pass": true, "original_string": "    public AsyncQueryRunner(final ExecutorService executorService, final QueryRunner queryRunner) {\n        this.executorService = executorService;\n        this.queryRunner = queryRunner;\n    }", "docstring": "\nConstructor for AsyncQueryRunner which uses a provided ExecutorService and underlying QueryRunner.\n\n@param executorService the {@code ExecutorService} instance used to run JDBC invocations concurrently.\n@param queryRunner the {@code QueryRunner} instance to use for the queries.\n@since 1.5\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "AsyncQueryRunner", "params": [{"name": "executorService", "type": "ExecutorService"}, {"name": "queryRunner", "type": "QueryRunner"}], "body": "                                                                                                  {\n        this.executorService = executorService;\n        this.queryRunner = queryRunner;\n    }", "signature": "public AsyncQueryRunner(final ExecutorService executorService, final QueryRunner queryRunner)"}, {"syntax_pass": true, "original_string": "    public Future<int[]> batch(final Connection conn, final String sql, final Object[][] params) throws SQLException {\n        return executorService.submit(() -> queryRunner.batch(conn, sql, params));\n    }", "docstring": "\nExecute a batch of SQL INSERT, UPDATE, or DELETE queries.\n\n@param conn The {@code Connection} to use to run the query.  The caller is\nresponsible for closing this Connection.\n@param sql The SQL to execute.\n@param params An array of query replacement parameters.  Each row in\nthis array is one set of batch replacement values.\n@return A {@code Future} which returns the number of rows updated per statement.\n@throws SQLException if a database access error occurs\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Future<int[]>", "classes": []}, "name": "batch", "params": [{"name": "conn", "type": "Connection"}, {"name": "sql", "type": "String"}, {"name": "params", "type": "Object[][]"}], "body": "                                                                                                                     {\n        return executorService.submit(() -> queryRunner.batch(conn, sql, params));\n    }", "signature": "public Future<int[]> batch(final Connection conn, final String sql, final Object[][] params)"}, {"syntax_pass": true, "original_string": "    public Future<int[]> batch(final String sql, final Object[][] params) throws SQLException {\n        return executorService.submit(() -> queryRunner.batch(sql, params));\n    }", "docstring": "\nExecute a batch of SQL INSERT, UPDATE, or DELETE queries.  The\n{@code Connection} is retrieved from the {@code DataSource}\nset in the constructor.  This {@code Connection} must be in\nauto-commit mode or the update will not be saved.\n\n@param sql The SQL to execute.\n@param params An array of query replacement parameters.  Each row in\nthis array is one set of batch replacement values.\n@return A {@code Future} which returns the number of rows updated per statement.\n@throws SQLException if a database access error occurs\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Future<int[]>", "classes": []}, "name": "batch", "params": [{"name": "sql", "type": "String"}, {"name": "params", "type": "Object[][]"}], "body": "                                                                                              {\n        return executorService.submit(() -> queryRunner.batch(sql, params));\n    }", "signature": "public Future<int[]> batch(final String sql, final Object[][] params)"}, {"syntax_pass": true, "original_string": "    public <T> Future<T> insert(final Connection conn, final String sql, final ResultSetHandler<T> rsh) throws SQLException {\n        return executorService.submit(() -> queryRunner.insert(conn, sql, rsh));\n    }", "docstring": "\nExecutes {@link QueryRunner#insert(Connection, String, ResultSetHandler)} asynchronously.\n\n@param <T> Return type expected\n@param conn {@link Connection} to use to execute the SQL statement\n@param sql SQL insert statement to execute\n@param rsh {@link ResultSetHandler} for handling the results\n@return {@link Future} that executes a query runner insert\n@see QueryRunner#insert(Connection, String, ResultSetHandler)\n@throws SQLException if a database access error occurs\n@since 1.6\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Future<T>", "classes": []}, "name": "insert", "params": [{"name": "conn", "type": "Connection"}, {"name": "sql", "type": "String"}, {"name": "rsh", "type": "ResultSetHandler<T>"}], "body": "                                                                                                                            {\n        return executorService.submit(() -> queryRunner.insert(conn, sql, rsh));\n    }", "signature": "public <T> Future<T> insert(final Connection conn, final String sql, final ResultSetHandler<T> rsh)"}, {"syntax_pass": true, "original_string": "    public <T> Future<T> insert(final Connection conn, final String sql, final ResultSetHandler<T> rsh, final Object... params) throws SQLException {\n        return executorService.submit(() -> queryRunner.insert(conn, sql, rsh, params));\n    }", "docstring": "\nExecutes {@link QueryRunner#insert(Connection, String, ResultSetHandler, Object...)} asynchronously.\n\n@param <T> Return type expected\n@param conn {@link Connection} to use to execute the SQL statement\n@param sql SQL insert statement to execute\n@param rsh {@link ResultSetHandler} for handling the results\n@param params Parameter values for substitution in the SQL statement\n@return {@link Future} that executes a query runner insert\n@see QueryRunner#insert(Connection, String, ResultSetHandler, Object...)\n@throws SQLException if a database access error occurs\n@since 1.6\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Future<T>", "classes": []}, "name": "insert", "params": [{"name": "conn", "type": "Connection"}, {"name": "sql", "type": "String"}, {"name": "rsh", "type": "ResultSetHandler<T>"}], "body": "                                                                                                                                                    {\n        return executorService.submit(() -> queryRunner.insert(conn, sql, rsh, params));\n    }", "signature": "public <T> Future<T> insert(final Connection conn, final String sql, final ResultSetHandler<T> rsh, final Object... params)"}, {"syntax_pass": true, "original_string": "    public <T> Future<T> insert(final String sql, final ResultSetHandler<T> rsh) throws SQLException {\n        return executorService.submit(() -> queryRunner.insert(sql, rsh));\n    }", "docstring": "\nExecutes {@link QueryRunner#insert(String, ResultSetHandler)} asynchronously.\n\n@param <T> Return type expected\n@param sql SQL insert statement to execute\n@param rsh {@link ResultSetHandler} for handling the results\n@return {@link Future} that executes a query runner insert\n@see QueryRunner#insert(String, ResultSetHandler)\n@throws SQLException if a database access error occurs\n@since 1.6\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Future<T>", "classes": []}, "name": "insert", "params": [{"name": "sql", "type": "String"}, {"name": "rsh", "type": "ResultSetHandler<T>"}], "body": "                                                                                                     {\n        return executorService.submit(() -> queryRunner.insert(sql, rsh));\n    }", "signature": "public <T> Future<T> insert(final String sql, final ResultSetHandler<T> rsh)"}, {"syntax_pass": true, "original_string": "    public <T> Future<T> insert(final String sql, final ResultSetHandler<T> rsh, final Object... params) throws SQLException {\n        return executorService.submit(() -> queryRunner.insert(sql, rsh, params));\n    }", "docstring": "\nExecutes {@link QueryRunner#insert(String, ResultSetHandler, Object...)} asynchronously.\n\n@param <T> Return type expected\n@param sql SQL insert statement to execute\n@param rsh {@link ResultSetHandler} for handling the results\n@param params Parameter values for substitution in the SQL statement\n@return {@link Future} that executes a query runner insert\n@see QueryRunner#insert(String, ResultSetHandler, Object...)\n@throws SQLException if a database access error occurs\n@since 1.6\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Future<T>", "classes": []}, "name": "insert", "params": [{"name": "sql", "type": "String"}, {"name": "rsh", "type": "ResultSetHandler<T>"}], "body": "                                                                                                                             {\n        return executorService.submit(() -> queryRunner.insert(sql, rsh, params));\n    }", "signature": "public <T> Future<T> insert(final String sql, final ResultSetHandler<T> rsh, final Object... params)"}, {"syntax_pass": true, "original_string": "    public <T> Future<T> insertBatch(final Connection conn, final String sql, final ResultSetHandler<T> rsh, final Object[][] params) throws SQLException {\n        return executorService.submit(() -> queryRunner.insertBatch(conn, sql, rsh, params));\n    }", "docstring": "\n{@link QueryRunner#insertBatch(Connection, String, ResultSetHandler, Object[][])} asynchronously.\n\n@param <T> Return type expected\n@param conn {@link Connection} to use to execute the SQL statement\n@param sql SQL insert statement to execute\n@param rsh {@link ResultSetHandler} for handling the results\n@param params An array of query replacement parameters.  Each row in\n       this array is one set of batch replacement values.\n@return {@link Future} that executes a query runner batch insert\n@see QueryRunner#insertBatch(Connection, String, ResultSetHandler, Object[][])\n@throws SQLException if a database access error occurs\n@since 1.6\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Future<T>", "classes": []}, "name": "insertBatch", "params": [{"name": "conn", "type": "Connection"}, {"name": "sql", "type": "String"}, {"name": "rsh", "type": "ResultSetHandler<T>"}, {"name": "params", "type": "Object[][]"}], "body": "                                                                                                                                                          {\n        return executorService.submit(() -> queryRunner.insertBatch(conn, sql, rsh, params));\n    }", "signature": "public <T> Future<T> insertBatch(final Connection conn, final String sql, final ResultSetHandler<T> rsh, final Object[][] params)"}, {"syntax_pass": true, "original_string": "    public <T> Future<T> insertBatch(final String sql, final ResultSetHandler<T> rsh, final Object[][] params) throws SQLException {\n        return executorService.submit(() -> queryRunner.insertBatch(sql, rsh, params));\n    }", "docstring": "\n{@link QueryRunner#insertBatch(String, ResultSetHandler, Object[][])} asynchronously.\n\n@param <T> Return type expected\n@param sql SQL insert statement to execute\n@param rsh {@link ResultSetHandler} for handling the results\n@param params An array of query replacement parameters.  Each row in\n       this array is one set of batch replacement values.\n@return {@link Future} that executes a query runner batch insert\n@see QueryRunner#insertBatch(String, ResultSetHandler, Object[][])\n@throws SQLException if a database access error occurs\n@since 1.6\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Future<T>", "classes": []}, "name": "insertBatch", "params": [{"name": "sql", "type": "String"}, {"name": "rsh", "type": "ResultSetHandler<T>"}, {"name": "params", "type": "Object[][]"}], "body": "                                                                                                                                   {\n        return executorService.submit(() -> queryRunner.insertBatch(sql, rsh, params));\n    }", "signature": "public <T> Future<T> insertBatch(final String sql, final ResultSetHandler<T> rsh, final Object[][] params)"}, {"syntax_pass": true, "original_string": "    public <T> Future<T> query(final Connection conn, final String sql, final ResultSetHandler<T> rsh) throws SQLException {\n        return executorService.submit(() -> queryRunner.query(conn, sql, rsh));\n    }", "docstring": "\nExecute an SQL SELECT query without any replacement parameters.  The\ncaller is responsible for closing the connection.\n@param <T> The type of object that the handler returns\n@param conn The connection to execute the query in.\n@param sql The query to execute.\n@param rsh The handler that converts the results into an object.\n@return A {@code Future} which returns the result of the query call.\n@throws SQLException if a database access error occurs\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Future<T>", "classes": []}, "name": "query", "params": [{"name": "conn", "type": "Connection"}, {"name": "sql", "type": "String"}, {"name": "rsh", "type": "ResultSetHandler<T>"}], "body": "                                                                                                                           {\n        return executorService.submit(() -> queryRunner.query(conn, sql, rsh));\n    }", "signature": "public <T> Future<T> query(final Connection conn, final String sql, final ResultSetHandler<T> rsh)"}, {"syntax_pass": true, "original_string": "    public <T> Future<T> query(final Connection conn, final String sql, final ResultSetHandler<T> rsh, final Object... params)\n            throws SQLException {\n        return executorService.submit(() -> queryRunner.query(conn, sql, rsh, params));\n    }", "docstring": "\nExecute an SQL SELECT query with replacement parameters.  The\ncaller is responsible for closing the connection.\n@param <T> The type of object that the handler returns\n@param conn The connection to execute the query in.\n@param sql The query to execute.\n@param rsh The handler that converts the results into an object.\n@param params The replacement parameters.\n@return A {@code Future} which returns the result of the query call.\n@throws SQLException if a database access error occurs\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Future<T>", "classes": []}, "name": "query", "params": [{"name": "conn", "type": "Connection"}, {"name": "sql", "type": "String"}, {"name": "rsh", "type": "ResultSetHandler<T>"}], "body": "                                {\n        return executorService.submit(() -> queryRunner.query(conn, sql, rsh, params));\n    }", "signature": "public <T> Future<T> query(final Connection conn, final String sql, final ResultSetHandler<T> rsh, final Object... params)"}, {"syntax_pass": true, "original_string": "    public <T> Future<T> query(final String sql, final ResultSetHandler<T> rsh) throws SQLException {\n        return executorService.submit(() -> queryRunner.query(sql, rsh));\n    }", "docstring": "\nExecutes the given SELECT SQL without any replacement parameters.\nThe {@code Connection} is retrieved from the\n{@code DataSource} set in the constructor.\n@param <T> The type of object that the handler returns\n@param sql The SQL statement to execute.\n@param rsh The handler used to create the result object from\nthe {@code ResultSet}.\n\n@return A {@code Future} which returns the result of the query call.\n@throws SQLException if a database access error occurs\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Future<T>", "classes": []}, "name": "query", "params": [{"name": "sql", "type": "String"}, {"name": "rsh", "type": "ResultSetHandler<T>"}], "body": "                                                                                                    {\n        return executorService.submit(() -> queryRunner.query(sql, rsh));\n    }", "signature": "public <T> Future<T> query(final String sql, final ResultSetHandler<T> rsh)"}, {"syntax_pass": true, "original_string": "    public <T> Future<T> query(final String sql, final ResultSetHandler<T> rsh, final Object... params) throws SQLException {\n        return executorService.submit(() -> queryRunner.query(sql, rsh, params));\n    }", "docstring": "\nExecutes the given SELECT SQL query and returns a result object.\nThe {@code Connection} is retrieved from the\n{@code DataSource} set in the constructor.\n@param <T> The type of object that the handler returns\n@param sql The SQL statement to execute.\n@param rsh The handler used to create the result object from\nthe {@code ResultSet}.\n@param params Initialize the PreparedStatement's IN parameters with\nthis array.\n@return A {@code Future} which returns the result of the query call.\n@throws SQLException if a database access error occurs\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Future<T>", "classes": []}, "name": "query", "params": [{"name": "sql", "type": "String"}, {"name": "rsh", "type": "ResultSetHandler<T>"}], "body": "                                                                                                                            {\n        return executorService.submit(() -> queryRunner.query(sql, rsh, params));\n    }", "signature": "public <T> Future<T> query(final String sql, final ResultSetHandler<T> rsh, final Object... params)"}, {"syntax_pass": true, "original_string": "    public Future<Integer> update(final Connection conn, final String sql) throws SQLException {\n        return executorService.submit(() -> Integer.valueOf(queryRunner.update(conn, sql)));\n    }", "docstring": "\nExecute an SQL INSERT, UPDATE, or DELETE query without replacement\nparameters.\n\n@param conn The connection to use to run the query.\n@param sql The SQL to execute.\n@return A {@code Future} which returns the number of rows updated.\n@throws SQLException if a database access error occurs\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Future<Integer>", "classes": []}, "name": "update", "params": [{"name": "conn", "type": "Connection"}, {"name": "sql", "type": "String"}], "body": "                                                                                               {\n        return executorService.submit(() -> Integer.valueOf(queryRunner.update(conn, sql)));\n    }", "signature": "public Future<Integer> update(final Connection conn, final String sql)"}, {"syntax_pass": true, "original_string": "    public Future<Integer> update(final Connection conn, final String sql, final Object param) throws SQLException {\n        return executorService.submit(() -> Integer.valueOf(queryRunner.update(conn, sql, param)));\n    }", "docstring": "\nExecute an SQL INSERT, UPDATE, or DELETE query with a single replacement\nparameter.\n\n@param conn The connection to use to run the query.\n@param sql The SQL to execute.\n@param param The replacement parameter.\n@return A {@code Future} which returns the number of rows updated.\n@throws SQLException if a database access error occurs\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Future<Integer>", "classes": []}, "name": "update", "params": [{"name": "conn", "type": "Connection"}, {"name": "sql", "type": "String"}, {"name": "param", "type": "Object"}], "body": "                                                                                                                   {\n        return executorService.submit(() -> Integer.valueOf(queryRunner.update(conn, sql, param)));\n    }", "signature": "public Future<Integer> update(final Connection conn, final String sql, final Object param)"}, {"syntax_pass": true, "original_string": "    public Future<Integer> update(final Connection conn, final String sql, final Object... params) throws SQLException {\n        return executorService.submit(() -> Integer.valueOf(queryRunner.update(conn, sql, params)));\n    }", "docstring": "\nExecute an SQL INSERT, UPDATE, or DELETE query.\n\n@param conn The connection to use to run the query.\n@param sql The SQL to execute.\n@param params The query replacement parameters.\n@return A {@code Future} which returns the number of rows updated.\n@throws SQLException if a database access error occurs\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Future<Integer>", "classes": []}, "name": "update", "params": [{"name": "conn", "type": "Connection"}, {"name": "sql", "type": "String"}], "body": "                                                                                                                       {\n        return executorService.submit(() -> Integer.valueOf(queryRunner.update(conn, sql, params)));\n    }", "signature": "public Future<Integer> update(final Connection conn, final String sql, final Object... params)"}, {"syntax_pass": true, "original_string": "    public Future<Integer> update(final String sql) throws SQLException {\n        return executorService.submit(() -> Integer.valueOf(queryRunner.update(sql)));\n    }", "docstring": "\nExecutes the given INSERT, UPDATE, or DELETE SQL statement without\nany replacement parameters. The {@code Connection} is retrieved\nfrom the {@code DataSource} set in the constructor.  This\n{@code Connection} must be in auto-commit mode or the update will\nnot be saved.\n\n@param sql The SQL statement to execute.\n@throws SQLException if a database access error occurs\n@return A {@code Future} which returns the number of rows updated.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Future<Integer>", "classes": []}, "name": "update", "params": [{"name": "sql", "type": "String"}], "body": "                                                                        {\n        return executorService.submit(() -> Integer.valueOf(queryRunner.update(sql)));\n    }", "signature": "public Future<Integer> update(final String sql)"}, {"syntax_pass": true, "original_string": "    public Future<Integer> update(final String sql, final Object param) throws SQLException {\n        return executorService.submit(() -> Integer.valueOf(queryRunner.update(sql, param)));\n    }", "docstring": "\nExecutes the given INSERT, UPDATE, or DELETE SQL statement with\na single replacement parameter.  The {@code Connection} is\nretrieved from the {@code DataSource} set in the constructor.\nThis {@code Connection} must be in auto-commit mode or the\nupdate will not be saved.\n\n@param sql The SQL statement to execute.\n@param param The replacement parameter.\n@throws SQLException if a database access error occurs\n@return A {@code Future} which returns the number of rows updated.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Future<Integer>", "classes": []}, "name": "update", "params": [{"name": "sql", "type": "String"}, {"name": "param", "type": "Object"}], "body": "                                                                                            {\n        return executorService.submit(() -> Integer.valueOf(queryRunner.update(sql, param)));\n    }", "signature": "public Future<Integer> update(final String sql, final Object param)"}, {"syntax_pass": true, "original_string": "    public Future<Integer> update(final String sql, final Object... params) throws SQLException {\n        return executorService.submit(() -> Integer.valueOf(queryRunner.update(sql, params)));\n    }", "docstring": "\nExecutes the given INSERT, UPDATE, or DELETE SQL statement.  The\n{@code Connection} is retrieved from the {@code DataSource}\nset in the constructor.  This {@code Connection} must be in\nauto-commit mode or the update will not be saved.\n\n@param sql The SQL statement to execute.\n@param params Initializes the PreparedStatement's IN (i.e. '?')\nparameters.\n@throws SQLException if a database access error occurs\n@return A {@code Future} which returns the number of rows updated.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Future<Integer>", "classes": []}, "name": "update", "params": [{"name": "sql", "type": "String"}], "body": "                                                                                                {\n        return executorService.submit(() -> Integer.valueOf(queryRunner.update(sql, params)));\n    }", "signature": "public Future<Integer> update(final String sql, final Object... params)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/apache/commons/dbutils/AbstractQueryRunner.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils;\n\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.sql.CallableStatement;\nimport java.sql.Connection;\nimport java.sql.ParameterMetaData;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.SQLFeatureNotSupportedException;\nimport java.sql.Statement;\nimport java.sql.Types;\nimport java.util.Arrays;\n\nimport javax.sql.DataSource;\n\n/**\n * The base class for QueryRunner &amp; AsyncQueryRunner. This class is thread safe.\n *\n * @since 1.4 (mostly extracted from QueryRunner)\n */\npublic abstract class AbstractQueryRunner {\n    /**\n     * Is {@link ParameterMetaData#getParameterType(int)} broken (have we tried\n     * it yet)?\n     */\n    private volatile boolean pmdKnownBroken;\n\n    /**\n     * The DataSource to retrieve connections from.\n     * @deprecated Access to this field should be through {@link #getDataSource()}.\n     */\n    @Deprecated\n    protected final DataSource ds;\n\n    /**\n     * Configuration to use when preparing statements.\n     */\n    private final StatementConfiguration stmtConfig;\n\n    /**\n     * Default constructor, sets pmdKnownBroken to false, ds to null and stmtConfig to null.\n     */\n    public AbstractQueryRunner() {\n        ds = null;\n        this.stmtConfig = null;\n    }\n\n    /**\n     * Constructor to control the use of {@code ParameterMetaData}.\n     *\n     * @param pmdKnownBroken\n     *            Some drivers don't support\n     *            {@link ParameterMetaData#getParameterType(int) }; if\n     *            {@code pmdKnownBroken} is set to true, we won't even try\n     *            it; if false, we'll try it, and if it breaks, we'll remember\n     *            not to use it again.\n     */\n    public AbstractQueryRunner(final boolean pmdKnownBroken) {\n        this.pmdKnownBroken = pmdKnownBroken;\n        ds = null;\n        this.stmtConfig = null;\n    }\n\n    /**\n     * Constructor to provide a {@code DataSource}. Methods that do not\n     * take a {@code Connection} parameter will retrieve connections from\n     * this {@code DataSource}.\n     *\n     * @param ds\n     *            The {@code DataSource} to retrieve connections from.\n     */\n    public AbstractQueryRunner(final DataSource ds) {\n        this.ds = ds;\n        this.stmtConfig = null;\n    }\n\n    /**\n     * Constructor to provide a {@code DataSource} and control the use of\n     * {@code ParameterMetaData}. Methods that do not take a\n     * {@code Connection} parameter will retrieve connections from this\n     * {@code DataSource}.\n     *\n     * @param ds\n     *            The {@code DataSource} to retrieve connections from.\n     * @param pmdKnownBroken\n     *            Some drivers don't support\n     *            {@link ParameterMetaData#getParameterType(int) }; if\n     *            {@code pmdKnownBroken} is set to true, we won't even try\n     *            it; if false, we'll try it, and if it breaks, we'll remember\n     *            not to use it again.\n     */\n    public AbstractQueryRunner(final DataSource ds, final boolean pmdKnownBroken) {\n        this.pmdKnownBroken = pmdKnownBroken;\n        this.ds = ds;\n        this.stmtConfig = null;\n    }\n\n    /**\n     * Constructor for QueryRunner that takes a {@code DataSource}, a {@code StatementConfiguration}, and\n     * controls the use of {@code ParameterMetaData}.  Methods that do not take a {@code Connection} parameter\n     * will retrieve connections from this {@code DataSource}.\n     *\n     * @param ds The {@code DataSource} to retrieve connections from.\n     * @param pmdKnownBroken Some drivers don't support {@link java.sql.ParameterMetaData#getParameterType(int) };\n     * if {@code pmdKnownBroken} is set to true, we won't even try it; if false, we'll try it,\n     * and if it breaks, we'll remember not to use it again.\n     * @param stmtConfig The configuration to apply to statements when they are prepared.\n     */\n    public AbstractQueryRunner(final DataSource ds, final boolean pmdKnownBroken, final StatementConfiguration stmtConfig) {\n        this.pmdKnownBroken = pmdKnownBroken;\n        this.ds = ds;\n        this.stmtConfig = stmtConfig;\n    }\n\n    /**\n     * Constructor for QueryRunner that takes a {@code DataSource} to use and a {@code StatementConfiguration}.\n     *\n     * Methods that do not take a {@code Connection} parameter will retrieve connections from this\n     * {@code DataSource}.\n     *\n     * @param ds The {@code DataSource} to retrieve connections from.\n     * @param stmtConfig The configuration to apply to statements when they are prepared.\n     */\n    public AbstractQueryRunner(final DataSource ds, final StatementConfiguration stmtConfig) {\n        this.ds = ds;\n        this.stmtConfig = stmtConfig;\n    }\n\n    /**\n     * Constructor for QueryRunner that takes a {@code StatementConfiguration} to configure statements when\n     * preparing them.\n     *\n     * @param stmtConfig The configuration to apply to statements when they are prepared.\n     */\n    public AbstractQueryRunner(final StatementConfiguration stmtConfig) {\n        this.ds = null;\n        this.stmtConfig = stmtConfig;\n    }\n\n    /**\n     * Close a {@code Connection}. This implementation avoids closing if\n     * null and does <strong>not</strong> suppress any exceptions. Subclasses\n     * can override to provide special handling like logging.\n     *\n     * @param conn\n     *            Connection to close\n     * @throws SQLException\n     *             if a database access error occurs\n     * @since 1.1\n     */\n    protected void close(final Connection conn) throws SQLException {\n        DbUtils.close(conn);\n    }\n\n    /**\n     * Close a {@code ResultSet}. This implementation avoids closing if\n     * null and does <strong>not</strong> suppress any exceptions. Subclasses\n     * can override to provide special handling like logging.\n     *\n     * @param resultSet\n     *            ResultSet to close\n     * @throws SQLException\n     *             if a database access error occurs\n     * @since 1.1\n     */\n    protected void close(final ResultSet resultSet) throws SQLException {\n        DbUtils.close(resultSet);\n    }\n\n    /**\n     * Close a {@code Statement}. This implementation avoids closing if\n     * null and does <strong>not</strong> suppress any exceptions. Subclasses\n     * can override to provide special handling like logging.\n     *\n     * @param stmt\n     *            Statement to close\n     * @throws SQLException\n     *             if a database access error occurs\n     * @since 1.1\n     */\n    protected void close(final Statement stmt) throws SQLException {\n        DbUtils.close(stmt);\n    }\n\n    /**\n     * Calls {@link DbUtils#closeQuietly(Connection)}.\n     *\n     * @param conn Connection to close.\n     * @since 1.8.0\n     */\n    protected void closeQuietly(final Connection conn) {\n        DbUtils.closeQuietly(conn);\n    }\n\n    /**\n     * Calls {@link DbUtils#closeQuietly(ResultSet)}.\n     *\n     * @param resultSet ResultSet to close.\n     * @since 1.8.0\n     */\n    protected void closeQuietly(final ResultSet resultSet) {\n        DbUtils.closeQuietly(resultSet);\n    }\n\n    /**\n     * Calls {@link DbUtils#closeQuietly(Statement)}.\n     *\n     * @param statement ResultSet to close.\n     * @since 1.8.0\n     */\n    protected void closeQuietly(final Statement statement) {\n        DbUtils.closeQuietly(statement);\n    }\n\n    private void configureStatement(final Statement stmt) throws SQLException {\n\n        if (stmtConfig != null) {\n            if (stmtConfig.isFetchDirectionSet()) {\n                stmt.setFetchDirection(stmtConfig.getFetchDirection());\n            }\n\n            if (stmtConfig.isFetchSizeSet()) {\n                stmt.setFetchSize(stmtConfig.getFetchSize());\n            }\n\n            if (stmtConfig.isMaxFieldSizeSet()) {\n                stmt.setMaxFieldSize(stmtConfig.getMaxFieldSize());\n            }\n\n            if (stmtConfig.isMaxRowsSet()) {\n                stmt.setMaxRows(stmtConfig.getMaxRows());\n            }\n\n            if (stmtConfig.isQueryTimeoutSet()) {\n                stmt.setQueryTimeout(stmtConfig.getQueryTimeout());\n            }\n        }\n    }\n\n    /**\n     * Fill the {@code PreparedStatement} replacement parameters with the\n     * given objects.\n     *\n     * @param stmt\n     *            PreparedStatement to fill\n     * @param params\n     *            Query replacement parameters; {@code null} is a valid\n     *            value to pass in.\n     * @throws SQLException\n     *             if a database access error occurs\n     */\n    public void fillStatement(final PreparedStatement stmt, final Object... params) throws SQLException {\n        ParameterMetaData pmd = null;\n        if (!pmdKnownBroken) {\n            try {\n                pmd = getParameterMetaData(stmt);\n                if (pmd == null) { // can be returned by implementations that don't support the method\n                    pmdKnownBroken = true;\n                }\n            } catch (final SQLFeatureNotSupportedException ex) {\n                pmdKnownBroken = true;\n            }\n            // TODO see DBUTILS-117: would it make sense to catch any other SQLEx types here?\n        }\n        fillStatement(stmt, pmd, params);\n    }\n\n    /**\n     * Fill the {@code PreparedStatement} replacement parameters with the\n     * given objects, and prefetched parameter metadata.\n     *\n     * @param stmt\n     *            PreparedStatement to fill\n     * @param pmd\n     *            Prefetched parameter metadata\n     * @param params\n     *            Query replacement parameters; {@code null} is a valid\n     *            value to pass in.\n     * @throws SQLException\n     *             if a database access error occurs\n     */\n    public void fillStatement(final PreparedStatement stmt, final ParameterMetaData pmd, final Object... params)\n            throws SQLException {\n\n        // check the parameter count, if we can\n        if (!pmdKnownBroken && pmd != null) {\n            final int stmtCount = pmd.getParameterCount();\n            final int paramsCount = params == null ? 0 : params.length;\n\n            if (stmtCount != paramsCount) {\n                throw new SQLException(\"Wrong number of parameters: expected \"\n                        + stmtCount + \", was given \" + paramsCount);\n            }\n        }\n\n        // nothing to do here\n        if (params == null) {\n            return;\n        }\n\n        CallableStatement call = null;\n        if (stmt instanceof CallableStatement) {\n            call = (CallableStatement) stmt;\n        }\n\n        for (int i = 0; i < params.length; i++) {\n            if (params[i] != null) {\n                if (call != null && params[i] instanceof OutParameter) {\n                    ((OutParameter<?>) params[i]).register(call, i + 1);\n                } else {\n                    stmt.setObject(i + 1, params[i]);\n                }\n            } else {\n                // VARCHAR works with many drivers regardless\n                // of the actual column type. Oddly, NULL and\n                // OTHER don't work with Oracle's drivers.\n                int sqlType = Types.VARCHAR;\n                if (!pmdKnownBroken) {\n                    // TODO see DBUTILS-117: does it make sense to catch SQLEx here?\n                    try {\n                        /*\n                         * It's not possible for pmdKnownBroken to change from true to false, (once true, always true) so pmd cannot be null here.\n                         */\n                        sqlType = pmd.getParameterType(i + 1);\n                    } catch (final SQLException e) {\n                        pmdKnownBroken = true;\n                    }\n                }\n                stmt.setNull(i + 1, sqlType);\n            }\n        }\n    }\n\n    /**\n     * Fill the {@code PreparedStatement} replacement parameters with the\n     * given object's bean property values.\n     *\n     * @param stmt\n     *            PreparedStatement to fill\n     * @param bean\n     *            a JavaBean object\n     * @param properties\n     *            an ordered array of properties; this gives the order to insert\n     *            values in the statement\n     * @throws SQLException\n     *             if a database access error occurs\n     */\n    public void fillStatementWithBean(final PreparedStatement stmt, final Object bean,\n            final PropertyDescriptor[] properties) throws SQLException {\n        final Object[] params = new Object[properties.length];\n        for (int i = 0; i < properties.length; i++) {\n            final PropertyDescriptor property = properties[i];\n            Object value = null;\n            final Method method = property.getReadMethod();\n            if (method == null) {\n                throw new IllegalArgumentException(\"No read method for bean property \" + bean.getClass() + \" \" + property.getName());\n            }\n            try {\n                value = method.invoke(bean);\n            } catch (final IllegalArgumentException e) {\n                throw new IllegalArgumentException(\"Couldn't invoke method with 0 arguments: \" + method, e);\n            } catch (final InvocationTargetException | IllegalAccessException e) {\n                throw new IllegalArgumentException(\"Couldn't invoke method: \" + method, e);\n            }\n            params[i] = value;\n        }\n        fillStatement(stmt, params);\n    }\n\n    /**\n     * Fill the {@code PreparedStatement} replacement parameters with the\n     * given object's bean property values.\n     *\n     * @param stmt\n     *            PreparedStatement to fill\n     * @param bean\n     *            A JavaBean object\n     * @param propertyNames\n     *            An ordered array of property names (these should match the\n     *            getters/setters); this gives the order to insert values in the\n     *            statement\n     * @throws SQLException\n     *             If a database access error occurs\n     */\n    public void fillStatementWithBean(final PreparedStatement stmt, final Object bean,\n            final String... propertyNames) throws SQLException {\n        PropertyDescriptor[] descriptors;\n        try {\n            descriptors = Introspector.getBeanInfo(bean.getClass()).getPropertyDescriptors();\n        } catch (final IntrospectionException e) {\n            throw new IllegalArgumentException(\"Couldn't introspect bean \" + bean.getClass().toString(), e);\n        }\n        final PropertyDescriptor[] sorted = new PropertyDescriptor[propertyNames.length];\n        for (int i = 0; i < propertyNames.length; i++) {\n            final String propertyName = propertyNames[i];\n            if (propertyName == null) {\n                throw new NullPointerException(\"propertyName can't be null: \" + i);\n            }\n            boolean found = false;\n            for (final PropertyDescriptor descriptor : descriptors) {\n                if (propertyName.equals(descriptor.getName())) {\n                    sorted[i] = descriptor;\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                throw new IllegalStateException(\"Couldn't find bean property: \" + bean.getClass() + \" \" + propertyName);\n            }\n        }\n        fillStatementWithBean(stmt, bean, sorted);\n    }\n\n    /**\n     * Returns the {@code DataSource} this runner is using.\n     * {@code QueryRunner} methods always call this method to get the\n     * {@code DataSource} so subclasses can provide specialized behavior.\n     *\n     * @return DataSource the runner is using\n     */\n    public DataSource getDataSource() {\n        return this.ds;\n    }\n\n    /**\n     * Gets the {@code ParameterMetaData} of the prepared statement, if the {@code pmdKnownBroken}\n     * is set to false.\n     *\n     * @param stmt\n     *            PreparedStatement of which to query the metadata of parameters\n     * @return the metadata of parameters\n     * @throws SQLException\n     *            if a database access error occurs\n     */\n    public ParameterMetaData getParameterMetaData(final PreparedStatement stmt) throws SQLException {\n        ParameterMetaData pmd = null;\n        if (!pmdKnownBroken) {\n            try {\n                pmd = stmt.getParameterMetaData();\n            } catch (final SQLFeatureNotSupportedException ex) {\n                pmdKnownBroken = true;\n            }\n        }\n        return pmd;\n    }\n\n    /**\n     * Some drivers don't support\n     * {@link ParameterMetaData#getParameterType(int) }; if\n     * {@code pmdKnownBroken} is set to true, we won't even try it; if\n     * false, we'll try it, and if it breaks, we'll remember not to use it\n     * again.\n     *\n     * @return the flag to skip (or not)\n     *         {@link ParameterMetaData#getParameterType(int) }\n     * @since 1.4\n     */\n    public boolean isPmdKnownBroken() {\n        return pmdKnownBroken;\n    }\n\n    /**\n     * Factory method that creates and initializes a\n     * {@code CallableStatement} object for the given SQL.\n     * {@code QueryRunner} methods always call this method to prepare\n     * callable statements for them. Subclasses can override this method to\n     * provide special CallableStatement configuration if needed. This\n     * implementation simply calls {@code conn.prepareCall(sql)}.\n     *\n     * @param conn\n     *            The {@code Connection} used to create the\n     *            {@code CallableStatement}\n     * @param sql\n     *            The SQL statement to prepare.\n     * @return An initialized {@code CallableStatement}.\n     * @throws SQLException\n     *             if a database access error occurs\n     */\n    protected CallableStatement prepareCall(final Connection conn, final String sql)\n            throws SQLException {\n\n        return conn.prepareCall(sql);\n    }\n\n    /**\n     * Factory method that creates and initializes a {@code Connection}\n     * object. {@code QueryRunner} methods always call this method to\n     * retrieve connections from its DataSource. Subclasses can override this\n     * method to provide special {@code Connection} configuration if\n     * needed. This implementation simply calls {@code ds.getConnection()}.\n     *\n     * @return An initialized {@code Connection}.\n     * @throws SQLException\n     *             if a database access error occurs\n     * @since 1.1\n     */\n    protected Connection prepareConnection() throws SQLException {\n        if (getDataSource() == null) {\n            throw new SQLException(\n                    \"QueryRunner requires a DataSource to be \"\n                            + \"invoked in this way, or a Connection should be passed in\");\n        }\n        return getDataSource().getConnection();\n    }\n\n    /**\n     * Factory method that creates and initializes a\n     * {@code PreparedStatement} object for the given SQL.\n     * {@code QueryRunner} methods always call this method to prepare\n     * statements for them. Subclasses can override this method to provide\n     * special PreparedStatement configuration if needed. This implementation\n     * simply calls {@code conn.prepareStatement(sql)}.\n     *\n     * @param conn\n     *            The {@code Connection} used to create the\n     *            {@code PreparedStatement}\n     * @param sql\n     *            The SQL statement to prepare.\n     * @return An initialized {@code PreparedStatement}.\n     * @throws SQLException\n     *             if a database access error occurs\n     */\n    protected PreparedStatement prepareStatement(final Connection conn, final String sql)\n            throws SQLException {\n\n        @SuppressWarnings(\"resource\")\n        final\n        PreparedStatement ps = conn.prepareStatement(sql);\n        try {\n            configureStatement(ps);\n        } catch (final SQLException e) {\n            ps.close();\n            throw e;\n        }\n        return ps;\n    }\n\n    /**\n     * Factory method that creates and initializes a\n     * {@code PreparedStatement} object for the given SQL.\n     * {@code QueryRunner} methods always call this method to prepare\n     * statements for them. Subclasses can override this method to provide\n     * special PreparedStatement configuration if needed. This implementation\n     * simply calls {@code conn.prepareStatement(sql, returnedKeys)}\n     * which will result in the ability to retrieve the automatically-generated\n     * keys from an auto_increment column.\n     *\n     * @param conn\n     *            The {@code Connection} used to create the\n     *            {@code PreparedStatement}\n     * @param sql\n     *            The SQL statement to prepare.\n     * @param returnedKeys\n     *            Flag indicating whether to return generated keys or not.\n     *\n     * @return An initialized {@code PreparedStatement}.\n     * @throws SQLException\n     *             if a database access error occurs\n     * @since 1.6\n     */\n    protected PreparedStatement prepareStatement(final Connection conn, final String sql, final int returnedKeys)\n            throws SQLException {\n\n        @SuppressWarnings(\"resource\")\n        final\n        PreparedStatement ps = conn.prepareStatement(sql, returnedKeys);\n        try {\n            configureStatement(ps);\n        } catch (final SQLException e) {\n            ps.close();\n            throw e;\n        }\n        return ps;\n    }\n\n    /**\n     * Throws a new exception with a more informative error message.\n     *\n     * @param cause\n     *            The original exception that will be chained to the new\n     *            exception when it's rethrown.\n     *\n     * @param sql\n     *            The query that was executing when the exception happened.\n     *\n     * @param params\n     *            The query replacement parameters; {@code null} is a valid\n     *            value to pass in.\n     *\n     * @throws SQLException\n     *             if a database access error occurs\n     */\n    protected void rethrow(final SQLException cause, final String sql, final Object... params)\n            throws SQLException {\n\n        String causeMessage = cause.getMessage();\n        if (causeMessage == null) {\n            causeMessage = \"\";\n        }\n        final StringBuilder msg = new StringBuilder(causeMessage);\n\n        msg.append(\" Query: \");\n        msg.append(sql);\n        msg.append(\" Parameters: \");\n\n        if (params == null) {\n            msg.append(\"[]\");\n        } else {\n            msg.append(Arrays.deepToString(params));\n        }\n\n        final SQLException e = new SQLException(msg.toString(), cause.getSQLState(),\n                cause.getErrorCode());\n        e.setNextException(cause);\n\n        throw e;\n    }\n\n    /**\n     * Wrap the {@code ResultSet} in a decorator before processing it. This\n     * implementation returns the {@code ResultSet} it is given without any\n     * decoration.\n     *\n     * <p>\n     * Often, the implementation of this method can be done in an anonymous\n     * inner class like this:\n     * </p>\n     *\n     * <pre>\n     * QueryRunner run = new QueryRunner() {\n     *     protected ResultSet wrap(ResultSet rs) {\n     *         return StringTrimmedResultSet.wrap(rs);\n     *     }\n     * };\n     * </pre>\n     *\n     * @param rs\n     *            The {@code ResultSet} to decorate; never\n     *            {@code null}.\n     * @return The {@code ResultSet} wrapped in some decorator.\n     */\n    protected ResultSet wrap(final ResultSet rs) {\n        return rs;\n    }\n\n}\n", "file_hash": "979341cfbf20d0f4aa50bca5a9c5b89fee18dc80818fbfb94804a878819e75e2", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils;", "import java.beans.IntrospectionException;", "import java.beans.Introspector;", "import java.beans.PropertyDescriptor;", "import java.lang.reflect.InvocationTargetException;", "import java.lang.reflect.Method;", "import java.sql.CallableStatement;", "import java.sql.Connection;", "import java.sql.ParameterMetaData;", "import java.sql.PreparedStatement;", "import java.sql.ResultSet;", "import java.sql.SQLException;", "import java.sql.SQLFeatureNotSupportedException;", "import java.sql.Statement;", "import java.sql.Types;", "import java.util.Arrays;", "import javax.sql.DataSource;"], "methods": [], "classes": [{"original_string": "public abstract class AbstractQueryRunner {\n    /**\n     * Is {@link ParameterMetaData#getParameterType(int)} broken (have we tried\n     * it yet)?\n     */\n    private volatile boolean pmdKnownBroken;\n\n    /**\n     * The DataSource to retrieve connections from.\n     * @deprecated Access to this field should be through {@link #getDataSource()}.\n     */\n    @Deprecated\n    protected final DataSource ds;\n\n    /**\n     * Configuration to use when preparing statements.\n     */\n    private final StatementConfiguration stmtConfig;\n\n    /**\n     * Default constructor, sets pmdKnownBroken to false, ds to null and stmtConfig to null.\n     */\n    public AbstractQueryRunner() {\n        ds = null;\n        this.stmtConfig = null;\n    }\n\n    /**\n     * Constructor to control the use of {@code ParameterMetaData}.\n     *\n     * @param pmdKnownBroken\n     *            Some drivers don't support\n     *            {@link ParameterMetaData#getParameterType(int) }; if\n     *            {@code pmdKnownBroken} is set to true, we won't even try\n     *            it; if false, we'll try it, and if it breaks, we'll remember\n     *            not to use it again.\n     */\n    public AbstractQueryRunner(final boolean pmdKnownBroken) {\n        this.pmdKnownBroken = pmdKnownBroken;\n        ds = null;\n        this.stmtConfig = null;\n    }\n\n    /**\n     * Constructor to provide a {@code DataSource}. Methods that do not\n     * take a {@code Connection} parameter will retrieve connections from\n     * this {@code DataSource}.\n     *\n     * @param ds\n     *            The {@code DataSource} to retrieve connections from.\n     */\n    public AbstractQueryRunner(final DataSource ds) {\n        this.ds = ds;\n        this.stmtConfig = null;\n    }\n\n    /**\n     * Constructor to provide a {@code DataSource} and control the use of\n     * {@code ParameterMetaData}. Methods that do not take a\n     * {@code Connection} parameter will retrieve connections from this\n     * {@code DataSource}.\n     *\n     * @param ds\n     *            The {@code DataSource} to retrieve connections from.\n     * @param pmdKnownBroken\n     *            Some drivers don't support\n     *            {@link ParameterMetaData#getParameterType(int) }; if\n     *            {@code pmdKnownBroken} is set to true, we won't even try\n     *            it; if false, we'll try it, and if it breaks, we'll remember\n     *            not to use it again.\n     */\n    public AbstractQueryRunner(final DataSource ds, final boolean pmdKnownBroken) {\n        this.pmdKnownBroken = pmdKnownBroken;\n        this.ds = ds;\n        this.stmtConfig = null;\n    }\n\n    /**\n     * Constructor for QueryRunner that takes a {@code DataSource}, a {@code StatementConfiguration}, and\n     * controls the use of {@code ParameterMetaData}.  Methods that do not take a {@code Connection} parameter\n     * will retrieve connections from this {@code DataSource}.\n     *\n     * @param ds The {@code DataSource} to retrieve connections from.\n     * @param pmdKnownBroken Some drivers don't support {@link java.sql.ParameterMetaData#getParameterType(int) };\n     * if {@code pmdKnownBroken} is set to true, we won't even try it; if false, we'll try it,\n     * and if it breaks, we'll remember not to use it again.\n     * @param stmtConfig The configuration to apply to statements when they are prepared.\n     */\n    public AbstractQueryRunner(final DataSource ds, final boolean pmdKnownBroken, final StatementConfiguration stmtConfig) {\n        this.pmdKnownBroken = pmdKnownBroken;\n        this.ds = ds;\n        this.stmtConfig = stmtConfig;\n    }\n\n    /**\n     * Constructor for QueryRunner that takes a {@code DataSource} to use and a {@code StatementConfiguration}.\n     *\n     * Methods that do not take a {@code Connection} parameter will retrieve connections from this\n     * {@code DataSource}.\n     *\n     * @param ds The {@code DataSource} to retrieve connections from.\n     * @param stmtConfig The configuration to apply to statements when they are prepared.\n     */\n    public AbstractQueryRunner(final DataSource ds, final StatementConfiguration stmtConfig) {\n        this.ds = ds;\n        this.stmtConfig = stmtConfig;\n    }\n\n    /**\n     * Constructor for QueryRunner that takes a {@code StatementConfiguration} to configure statements when\n     * preparing them.\n     *\n     * @param stmtConfig The configuration to apply to statements when they are prepared.\n     */\n    public AbstractQueryRunner(final StatementConfiguration stmtConfig) {\n        this.ds = null;\n        this.stmtConfig = stmtConfig;\n    }\n\n    /**\n     * Close a {@code Connection}. This implementation avoids closing if\n     * null and does <strong>not</strong> suppress any exceptions. Subclasses\n     * can override to provide special handling like logging.\n     *\n     * @param conn\n     *            Connection to close\n     * @throws SQLException\n     *             if a database access error occurs\n     * @since 1.1\n     */\n    protected void close(final Connection conn) throws SQLException {\n        DbUtils.close(conn);\n    }\n\n    /**\n     * Close a {@code ResultSet}. This implementation avoids closing if\n     * null and does <strong>not</strong> suppress any exceptions. Subclasses\n     * can override to provide special handling like logging.\n     *\n     * @param resultSet\n     *            ResultSet to close\n     * @throws SQLException\n     *             if a database access error occurs\n     * @since 1.1\n     */\n    protected void close(final ResultSet resultSet) throws SQLException {\n        DbUtils.close(resultSet);\n    }\n\n    /**\n     * Close a {@code Statement}. This implementation avoids closing if\n     * null and does <strong>not</strong> suppress any exceptions. Subclasses\n     * can override to provide special handling like logging.\n     *\n     * @param stmt\n     *            Statement to close\n     * @throws SQLException\n     *             if a database access error occurs\n     * @since 1.1\n     */\n    protected void close(final Statement stmt) throws SQLException {\n        DbUtils.close(stmt);\n    }\n\n    /**\n     * Calls {@link DbUtils#closeQuietly(Connection)}.\n     *\n     * @param conn Connection to close.\n     * @since 1.8.0\n     */\n    protected void closeQuietly(final Connection conn) {\n        DbUtils.closeQuietly(conn);\n    }\n\n    /**\n     * Calls {@link DbUtils#closeQuietly(ResultSet)}.\n     *\n     * @param resultSet ResultSet to close.\n     * @since 1.8.0\n     */\n    protected void closeQuietly(final ResultSet resultSet) {\n        DbUtils.closeQuietly(resultSet);\n    }\n\n    /**\n     * Calls {@link DbUtils#closeQuietly(Statement)}.\n     *\n     * @param statement ResultSet to close.\n     * @since 1.8.0\n     */\n    protected void closeQuietly(final Statement statement) {\n        DbUtils.closeQuietly(statement);\n    }\n\n    private void configureStatement(final Statement stmt) throws SQLException {\n\n        if (stmtConfig != null) {\n            if (stmtConfig.isFetchDirectionSet()) {\n                stmt.setFetchDirection(stmtConfig.getFetchDirection());\n            }\n\n            if (stmtConfig.isFetchSizeSet()) {\n                stmt.setFetchSize(stmtConfig.getFetchSize());\n            }\n\n            if (stmtConfig.isMaxFieldSizeSet()) {\n                stmt.setMaxFieldSize(stmtConfig.getMaxFieldSize());\n            }\n\n            if (stmtConfig.isMaxRowsSet()) {\n                stmt.setMaxRows(stmtConfig.getMaxRows());\n            }\n\n            if (stmtConfig.isQueryTimeoutSet()) {\n                stmt.setQueryTimeout(stmtConfig.getQueryTimeout());\n            }\n        }\n    }\n\n    /**\n     * Fill the {@code PreparedStatement} replacement parameters with the\n     * given objects.\n     *\n     * @param stmt\n     *            PreparedStatement to fill\n     * @param params\n     *            Query replacement parameters; {@code null} is a valid\n     *            value to pass in.\n     * @throws SQLException\n     *             if a database access error occurs\n     */\n    public void fillStatement(final PreparedStatement stmt, final Object... params) throws SQLException {\n        ParameterMetaData pmd = null;\n        if (!pmdKnownBroken) {\n            try {\n                pmd = getParameterMetaData(stmt);\n                if (pmd == null) { // can be returned by implementations that don't support the method\n                    pmdKnownBroken = true;\n                }\n            } catch (final SQLFeatureNotSupportedException ex) {\n                pmdKnownBroken = true;\n            }\n            // TODO see DBUTILS-117: would it make sense to catch any other SQLEx types here?\n        }\n        fillStatement(stmt, pmd, params);\n    }\n\n    /**\n     * Fill the {@code PreparedStatement} replacement parameters with the\n     * given objects, and prefetched parameter metadata.\n     *\n     * @param stmt\n     *            PreparedStatement to fill\n     * @param pmd\n     *            Prefetched parameter metadata\n     * @param params\n     *            Query replacement parameters; {@code null} is a valid\n     *            value to pass in.\n     * @throws SQLException\n     *             if a database access error occurs\n     */\n    public void fillStatement(final PreparedStatement stmt, final ParameterMetaData pmd, final Object... params)\n            throws SQLException {\n\n        // check the parameter count, if we can\n        if (!pmdKnownBroken && pmd != null) {\n            final int stmtCount = pmd.getParameterCount();\n            final int paramsCount = params == null ? 0 : params.length;\n\n            if (stmtCount != paramsCount) {\n                throw new SQLException(\"Wrong number of parameters: expected \"\n                        + stmtCount + \", was given \" + paramsCount);\n            }\n        }\n\n        // nothing to do here\n        if (params == null) {\n            return;\n        }\n\n        CallableStatement call = null;\n        if (stmt instanceof CallableStatement) {\n            call = (CallableStatement) stmt;\n        }\n\n        for (int i = 0; i < params.length; i++) {\n            if (params[i] != null) {\n                if (call != null && params[i] instanceof OutParameter) {\n                    ((OutParameter<?>) params[i]).register(call, i + 1);\n                } else {\n                    stmt.setObject(i + 1, params[i]);\n                }\n            } else {\n                // VARCHAR works with many drivers regardless\n                // of the actual column type. Oddly, NULL and\n                // OTHER don't work with Oracle's drivers.\n                int sqlType = Types.VARCHAR;\n                if (!pmdKnownBroken) {\n                    // TODO see DBUTILS-117: does it make sense to catch SQLEx here?\n                    try {\n                        /*\n                         * It's not possible for pmdKnownBroken to change from true to false, (once true, always true) so pmd cannot be null here.\n                         */\n                        sqlType = pmd.getParameterType(i + 1);\n                    } catch (final SQLException e) {\n                        pmdKnownBroken = true;\n                    }\n                }\n                stmt.setNull(i + 1, sqlType);\n            }\n        }\n    }\n\n    /**\n     * Fill the {@code PreparedStatement} replacement parameters with the\n     * given object's bean property values.\n     *\n     * @param stmt\n     *            PreparedStatement to fill\n     * @param bean\n     *            a JavaBean object\n     * @param properties\n     *            an ordered array of properties; this gives the order to insert\n     *            values in the statement\n     * @throws SQLException\n     *             if a database access error occurs\n     */\n    public void fillStatementWithBean(final PreparedStatement stmt, final Object bean,\n            final PropertyDescriptor[] properties) throws SQLException {\n        final Object[] params = new Object[properties.length];\n        for (int i = 0; i < properties.length; i++) {\n            final PropertyDescriptor property = properties[i];\n            Object value = null;\n            final Method method = property.getReadMethod();\n            if (method == null) {\n                throw new IllegalArgumentException(\"No read method for bean property \" + bean.getClass() + \" \" + property.getName());\n            }\n            try {\n                value = method.invoke(bean);\n            } catch (final IllegalArgumentException e) {\n                throw new IllegalArgumentException(\"Couldn't invoke method with 0 arguments: \" + method, e);\n            } catch (final InvocationTargetException | IllegalAccessException e) {\n                throw new IllegalArgumentException(\"Couldn't invoke method: \" + method, e);\n            }\n            params[i] = value;\n        }\n        fillStatement(stmt, params);\n    }\n\n    /**\n     * Fill the {@code PreparedStatement} replacement parameters with the\n     * given object's bean property values.\n     *\n     * @param stmt\n     *            PreparedStatement to fill\n     * @param bean\n     *            A JavaBean object\n     * @param propertyNames\n     *            An ordered array of property names (these should match the\n     *            getters/setters); this gives the order to insert values in the\n     *            statement\n     * @throws SQLException\n     *             If a database access error occurs\n     */\n    public void fillStatementWithBean(final PreparedStatement stmt, final Object bean,\n            final String... propertyNames) throws SQLException {\n        PropertyDescriptor[] descriptors;\n        try {\n            descriptors = Introspector.getBeanInfo(bean.getClass()).getPropertyDescriptors();\n        } catch (final IntrospectionException e) {\n            throw new IllegalArgumentException(\"Couldn't introspect bean \" + bean.getClass().toString(), e);\n        }\n        final PropertyDescriptor[] sorted = new PropertyDescriptor[propertyNames.length];\n        for (int i = 0; i < propertyNames.length; i++) {\n            final String propertyName = propertyNames[i];\n            if (propertyName == null) {\n                throw new NullPointerException(\"propertyName can't be null: \" + i);\n            }\n            boolean found = false;\n            for (final PropertyDescriptor descriptor : descriptors) {\n                if (propertyName.equals(descriptor.getName())) {\n                    sorted[i] = descriptor;\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                throw new IllegalStateException(\"Couldn't find bean property: \" + bean.getClass() + \" \" + propertyName);\n            }\n        }\n        fillStatementWithBean(stmt, bean, sorted);\n    }\n\n    /**\n     * Returns the {@code DataSource} this runner is using.\n     * {@code QueryRunner} methods always call this method to get the\n     * {@code DataSource} so subclasses can provide specialized behavior.\n     *\n     * @return DataSource the runner is using\n     */\n    public DataSource getDataSource() {\n        return this.ds;\n    }\n\n    /**\n     * Gets the {@code ParameterMetaData} of the prepared statement, if the {@code pmdKnownBroken}\n     * is set to false.\n     *\n     * @param stmt\n     *            PreparedStatement of which to query the metadata of parameters\n     * @return the metadata of parameters\n     * @throws SQLException\n     *            if a database access error occurs\n     */\n    public ParameterMetaData getParameterMetaData(final PreparedStatement stmt) throws SQLException {\n        ParameterMetaData pmd = null;\n        if (!pmdKnownBroken) {\n            try {\n                pmd = stmt.getParameterMetaData();\n            } catch (final SQLFeatureNotSupportedException ex) {\n                pmdKnownBroken = true;\n            }\n        }\n        return pmd;\n    }\n\n    /**\n     * Some drivers don't support\n     * {@link ParameterMetaData#getParameterType(int) }; if\n     * {@code pmdKnownBroken} is set to true, we won't even try it; if\n     * false, we'll try it, and if it breaks, we'll remember not to use it\n     * again.\n     *\n     * @return the flag to skip (or not)\n     *         {@link ParameterMetaData#getParameterType(int) }\n     * @since 1.4\n     */\n    public boolean isPmdKnownBroken() {\n        return pmdKnownBroken;\n    }\n\n    /**\n     * Factory method that creates and initializes a\n     * {@code CallableStatement} object for the given SQL.\n     * {@code QueryRunner} methods always call this method to prepare\n     * callable statements for them. Subclasses can override this method to\n     * provide special CallableStatement configuration if needed. This\n     * implementation simply calls {@code conn.prepareCall(sql)}.\n     *\n     * @param conn\n     *            The {@code Connection} used to create the\n     *            {@code CallableStatement}\n     * @param sql\n     *            The SQL statement to prepare.\n     * @return An initialized {@code CallableStatement}.\n     * @throws SQLException\n     *             if a database access error occurs\n     */\n    protected CallableStatement prepareCall(final Connection conn, final String sql)\n            throws SQLException {\n\n        return conn.prepareCall(sql);\n    }\n\n    /**\n     * Factory method that creates and initializes a {@code Connection}\n     * object. {@code QueryRunner} methods always call this method to\n     * retrieve connections from its DataSource. Subclasses can override this\n     * method to provide special {@code Connection} configuration if\n     * needed. This implementation simply calls {@code ds.getConnection()}.\n     *\n     * @return An initialized {@code Connection}.\n     * @throws SQLException\n     *             if a database access error occurs\n     * @since 1.1\n     */\n    protected Connection prepareConnection() throws SQLException {\n        if (getDataSource() == null) {\n            throw new SQLException(\n                    \"QueryRunner requires a DataSource to be \"\n                            + \"invoked in this way, or a Connection should be passed in\");\n        }\n        return getDataSource().getConnection();\n    }\n\n    /**\n     * Factory method that creates and initializes a\n     * {@code PreparedStatement} object for the given SQL.\n     * {@code QueryRunner} methods always call this method to prepare\n     * statements for them. Subclasses can override this method to provide\n     * special PreparedStatement configuration if needed. This implementation\n     * simply calls {@code conn.prepareStatement(sql)}.\n     *\n     * @param conn\n     *            The {@code Connection} used to create the\n     *            {@code PreparedStatement}\n     * @param sql\n     *            The SQL statement to prepare.\n     * @return An initialized {@code PreparedStatement}.\n     * @throws SQLException\n     *             if a database access error occurs\n     */\n    protected PreparedStatement prepareStatement(final Connection conn, final String sql)\n            throws SQLException {\n\n        @SuppressWarnings(\"resource\")\n        final\n        PreparedStatement ps = conn.prepareStatement(sql);\n        try {\n            configureStatement(ps);\n        } catch (final SQLException e) {\n            ps.close();\n            throw e;\n        }\n        return ps;\n    }\n\n    /**\n     * Factory method that creates and initializes a\n     * {@code PreparedStatement} object for the given SQL.\n     * {@code QueryRunner} methods always call this method to prepare\n     * statements for them. Subclasses can override this method to provide\n     * special PreparedStatement configuration if needed. This implementation\n     * simply calls {@code conn.prepareStatement(sql, returnedKeys)}\n     * which will result in the ability to retrieve the automatically-generated\n     * keys from an auto_increment column.\n     *\n     * @param conn\n     *            The {@code Connection} used to create the\n     *            {@code PreparedStatement}\n     * @param sql\n     *            The SQL statement to prepare.\n     * @param returnedKeys\n     *            Flag indicating whether to return generated keys or not.\n     *\n     * @return An initialized {@code PreparedStatement}.\n     * @throws SQLException\n     *             if a database access error occurs\n     * @since 1.6\n     */\n    protected PreparedStatement prepareStatement(final Connection conn, final String sql, final int returnedKeys)\n            throws SQLException {\n\n        @SuppressWarnings(\"resource\")\n        final\n        PreparedStatement ps = conn.prepareStatement(sql, returnedKeys);\n        try {\n            configureStatement(ps);\n        } catch (final SQLException e) {\n            ps.close();\n            throw e;\n        }\n        return ps;\n    }\n\n    /**\n     * Throws a new exception with a more informative error message.\n     *\n     * @param cause\n     *            The original exception that will be chained to the new\n     *            exception when it's rethrown.\n     *\n     * @param sql\n     *            The query that was executing when the exception happened.\n     *\n     * @param params\n     *            The query replacement parameters; {@code null} is a valid\n     *            value to pass in.\n     *\n     * @throws SQLException\n     *             if a database access error occurs\n     */\n    protected void rethrow(final SQLException cause, final String sql, final Object... params)\n            throws SQLException {\n\n        String causeMessage = cause.getMessage();\n        if (causeMessage == null) {\n            causeMessage = \"\";\n        }\n        final StringBuilder msg = new StringBuilder(causeMessage);\n\n        msg.append(\" Query: \");\n        msg.append(sql);\n        msg.append(\" Parameters: \");\n\n        if (params == null) {\n            msg.append(\"[]\");\n        } else {\n            msg.append(Arrays.deepToString(params));\n        }\n\n        final SQLException e = new SQLException(msg.toString(), cause.getSQLState(),\n                cause.getErrorCode());\n        e.setNextException(cause);\n\n        throw e;\n    }\n\n    /**\n     * Wrap the {@code ResultSet} in a decorator before processing it. This\n     * implementation returns the {@code ResultSet} it is given without any\n     * decoration.\n     *\n     * <p>\n     * Often, the implementation of this method can be done in an anonymous\n     * inner class like this:\n     * </p>\n     *\n     * <pre>\n     * QueryRunner run = new QueryRunner() {\n     *     protected ResultSet wrap(ResultSet rs) {\n     *         return StringTrimmedResultSet.wrap(rs);\n     *     }\n     * };\n     * </pre>\n     *\n     * @param rs\n     *            The {@code ResultSet} to decorate; never\n     *            {@code null}.\n     * @return The {@code ResultSet} wrapped in some decorator.\n     */\n    protected ResultSet wrap(final ResultSet rs) {\n        return rs;\n    }\n\n}", "definition": "public abstract class AbstractQueryRunner", "class_docstring": "\nThe base class for QueryRunner &amp; AsyncQueryRunner. This class is thread safe.\n\n@since 1.4 (mostly extracted from QueryRunner)\n", "name": "AbstractQueryRunner", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public abstract", "marker_annotations": [], "non_marker_annotations": ["public", "abstract"], "comments": [], "fields": [{"attribute_expression": "private volatile boolean pmdKnownBroken;", "docstring": "\nIs {@link ParameterMetaData#getParameterType(int)} broken (have we tried\nit yet)?\n", "modifiers": "private volatile", "marker_annotations": [], "non_marker_annotations": ["private", "volatile"], "comments": [], "type": "boolean", "name": "pmdKnownBroken", "syntax_pass": true}, {"attribute_expression": "@Deprecated\n    protected final DataSource ds;", "docstring": "\nThe DataSource to retrieve connections from.\n@deprecated Access to this field should be through {@link #getDataSource()}.\n", "modifiers": "@Deprecated\n    protected final", "marker_annotations": ["@Deprecated"], "non_marker_annotations": ["protected", "final"], "comments": [], "type": "DataSource", "name": "ds", "syntax_pass": true}, {"attribute_expression": "private final StatementConfiguration stmtConfig;", "docstring": "\nConfiguration to use when preparing statements.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "StatementConfiguration", "name": "stmtConfig", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public AbstractQueryRunner() {\n        ds = null;\n        this.stmtConfig = null;\n    }", "docstring": "\nDefault constructor, sets pmdKnownBroken to false, ds to null and stmtConfig to null.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "AbstractQueryRunner", "params": [], "body": "                                 {\n        ds = null;\n        this.stmtConfig = null;\n    }", "signature": "public AbstractQueryRunner()"}, {"syntax_pass": true, "original_string": "    public AbstractQueryRunner(final boolean pmdKnownBroken) {\n        this.pmdKnownBroken = pmdKnownBroken;\n        ds = null;\n        this.stmtConfig = null;\n    }", "docstring": "\nConstructor to control the use of {@code ParameterMetaData}.\n\n@param pmdKnownBroken\n           Some drivers don't support\n           {@link ParameterMetaData#getParameterType(int) }; if\n           {@code pmdKnownBroken} is set to true, we won't even try\n           it; if false, we'll try it, and if it breaks, we'll remember\n           not to use it again.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "AbstractQueryRunner", "params": [{"name": "pmdKnownBroken", "type": "boolean"}], "body": "                                                             {\n        this.pmdKnownBroken = pmdKnownBroken;\n        ds = null;\n        this.stmtConfig = null;\n    }", "signature": "public AbstractQueryRunner(final boolean pmdKnownBroken)"}, {"syntax_pass": true, "original_string": "    public AbstractQueryRunner(final DataSource ds) {\n        this.ds = ds;\n        this.stmtConfig = null;\n    }", "docstring": "\nConstructor to provide a {@code DataSource}. Methods that do not\ntake a {@code Connection} parameter will retrieve connections from\nthis {@code DataSource}.\n\n@param ds\n           The {@code DataSource} to retrieve connections from.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "AbstractQueryRunner", "params": [{"name": "ds", "type": "DataSource"}], "body": "                                                    {\n        this.ds = ds;\n        this.stmtConfig = null;\n    }", "signature": "public AbstractQueryRunner(final DataSource ds)"}, {"syntax_pass": true, "original_string": "    public AbstractQueryRunner(final DataSource ds, final boolean pmdKnownBroken) {\n        this.pmdKnownBroken = pmdKnownBroken;\n        this.ds = ds;\n        this.stmtConfig = null;\n    }", "docstring": "\nConstructor to provide a {@code DataSource} and control the use of\n{@code ParameterMetaData}. Methods that do not take a\n{@code Connection} parameter will retrieve connections from this\n{@code DataSource}.\n\n@param ds\n           The {@code DataSource} to retrieve connections from.\n@param pmdKnownBroken\n           Some drivers don't support\n           {@link ParameterMetaData#getParameterType(int) }; if\n           {@code pmdKnownBroken} is set to true, we won't even try\n           it; if false, we'll try it, and if it breaks, we'll remember\n           not to use it again.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "AbstractQueryRunner", "params": [{"name": "ds", "type": "DataSource"}, {"name": "pmdKnownBroken", "type": "boolean"}], "body": "                                                                                  {\n        this.pmdKnownBroken = pmdKnownBroken;\n        this.ds = ds;\n        this.stmtConfig = null;\n    }", "signature": "public AbstractQueryRunner(final DataSource ds, final boolean pmdKnownBroken)"}, {"syntax_pass": true, "original_string": "    public AbstractQueryRunner(final DataSource ds, final boolean pmdKnownBroken, final StatementConfiguration stmtConfig) {\n        this.pmdKnownBroken = pmdKnownBroken;\n        this.ds = ds;\n        this.stmtConfig = stmtConfig;\n    }", "docstring": "\nConstructor for QueryRunner that takes a {@code DataSource}, a {@code StatementConfiguration}, and\ncontrols the use of {@code ParameterMetaData}.  Methods that do not take a {@code Connection} parameter\nwill retrieve connections from this {@code DataSource}.\n\n@param ds The {@code DataSource} to retrieve connections from.\n@param pmdKnownBroken Some drivers don't support {@link java.sql.ParameterMetaData#getParameterType(int) };\nif {@code pmdKnownBroken} is set to true, we won't even try it; if false, we'll try it,\nand if it breaks, we'll remember not to use it again.\n@param stmtConfig The configuration to apply to statements when they are prepared.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "AbstractQueryRunner", "params": [{"name": "ds", "type": "DataSource"}, {"name": "pmdKnownBroken", "type": "boolean"}, {"name": "stmtConfig", "type": "StatementConfiguration"}], "body": "                                                                                                                           {\n        this.pmdKnownBroken = pmdKnownBroken;\n        this.ds = ds;\n        this.stmtConfig = stmtConfig;\n    }", "signature": "public AbstractQueryRunner(final DataSource ds, final boolean pmdKnownBroken, final StatementConfiguration stmtConfig)"}, {"syntax_pass": true, "original_string": "    public AbstractQueryRunner(final DataSource ds, final StatementConfiguration stmtConfig) {\n        this.ds = ds;\n        this.stmtConfig = stmtConfig;\n    }", "docstring": "\nConstructor for QueryRunner that takes a {@code DataSource} to use and a {@code StatementConfiguration}.\n\nMethods that do not take a {@code Connection} parameter will retrieve connections from this\n{@code DataSource}.\n\n@param ds The {@code DataSource} to retrieve connections from.\n@param stmtConfig The configuration to apply to statements when they are prepared.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "AbstractQueryRunner", "params": [{"name": "ds", "type": "DataSource"}, {"name": "stmtConfig", "type": "StatementConfiguration"}], "body": "                                                                                             {\n        this.ds = ds;\n        this.stmtConfig = stmtConfig;\n    }", "signature": "public AbstractQueryRunner(final DataSource ds, final StatementConfiguration stmtConfig)"}, {"syntax_pass": true, "original_string": "    public AbstractQueryRunner(final StatementConfiguration stmtConfig) {\n        this.ds = null;\n        this.stmtConfig = stmtConfig;\n    }", "docstring": "\nConstructor for QueryRunner that takes a {@code StatementConfiguration} to configure statements when\npreparing them.\n\n@param stmtConfig The configuration to apply to statements when they are prepared.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "AbstractQueryRunner", "params": [{"name": "stmtConfig", "type": "StatementConfiguration"}], "body": "                                                                        {\n        this.ds = null;\n        this.stmtConfig = stmtConfig;\n    }", "signature": "public AbstractQueryRunner(final StatementConfiguration stmtConfig)"}, {"syntax_pass": true, "original_string": "    protected void close(final Connection conn) throws SQLException {\n        DbUtils.close(conn);\n    }", "docstring": "\nClose a {@code Connection}. This implementation avoids closing if\nnull and does <strong>not</strong> suppress any exceptions. Subclasses\ncan override to provide special handling like logging.\n\n@param conn\n           Connection to close\n@throws SQLException\n            if a database access error occurs\n@since 1.1\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "name": "close", "params": [{"name": "conn", "type": "Connection"}], "body": "                                                                    {\n        DbUtils.close(conn);\n    }", "signature": "protected void close(final Connection conn)"}, {"syntax_pass": true, "original_string": "    protected void close(final ResultSet resultSet) throws SQLException {\n        DbUtils.close(resultSet);\n    }", "docstring": "\nClose a {@code ResultSet}. This implementation avoids closing if\nnull and does <strong>not</strong> suppress any exceptions. Subclasses\ncan override to provide special handling like logging.\n\n@param resultSet\n           ResultSet to close\n@throws SQLException\n            if a database access error occurs\n@since 1.1\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "name": "close", "params": [{"name": "resultSet", "type": "ResultSet"}], "body": "                                                                        {\n        DbUtils.close(resultSet);\n    }", "signature": "protected void close(final ResultSet resultSet)"}, {"syntax_pass": true, "original_string": "    protected void close(final Statement stmt) throws SQLException {\n        DbUtils.close(stmt);\n    }", "docstring": "\nClose a {@code Statement}. This implementation avoids closing if\nnull and does <strong>not</strong> suppress any exceptions. Subclasses\ncan override to provide special handling like logging.\n\n@param stmt\n           Statement to close\n@throws SQLException\n            if a database access error occurs\n@since 1.1\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "name": "close", "params": [{"name": "stmt", "type": "Statement"}], "body": "                                                                   {\n        DbUtils.close(stmt);\n    }", "signature": "protected void close(final Statement stmt)"}, {"syntax_pass": true, "original_string": "    protected void closeQuietly(final Connection conn) {\n        DbUtils.closeQuietly(conn);\n    }", "docstring": "\nCalls {@link DbUtils#closeQuietly(Connection)}.\n\n@param conn Connection to close.\n@since 1.8.0\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "name": "closeQuietly", "params": [{"name": "conn", "type": "Connection"}], "body": "                                                       {\n        DbUtils.closeQuietly(conn);\n    }", "signature": "protected void closeQuietly(final Connection conn)"}, {"syntax_pass": true, "original_string": "    protected void closeQuietly(final ResultSet resultSet) {\n        DbUtils.closeQuietly(resultSet);\n    }", "docstring": "\nCalls {@link DbUtils#closeQuietly(ResultSet)}.\n\n@param resultSet ResultSet to close.\n@since 1.8.0\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "name": "closeQuietly", "params": [{"name": "resultSet", "type": "ResultSet"}], "body": "                                                           {\n        DbUtils.closeQuietly(resultSet);\n    }", "signature": "protected void closeQuietly(final ResultSet resultSet)"}, {"syntax_pass": true, "original_string": "    protected void closeQuietly(final Statement statement) {\n        DbUtils.closeQuietly(statement);\n    }", "docstring": "\nCalls {@link DbUtils#closeQuietly(Statement)}.\n\n@param statement ResultSet to close.\n@since 1.8.0\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "name": "closeQuietly", "params": [{"name": "statement", "type": "Statement"}], "body": "                                                           {\n        DbUtils.closeQuietly(statement);\n    }", "signature": "protected void closeQuietly(final Statement statement)"}, {"syntax_pass": true, "original_string": "    private void configureStatement(final Statement stmt) throws SQLException {\n\n        if (stmtConfig != null) {\n            if (stmtConfig.isFetchDirectionSet()) {\n                stmt.setFetchDirection(stmtConfig.getFetchDirection());\n            }\n\n            if (stmtConfig.isFetchSizeSet()) {\n                stmt.setFetchSize(stmtConfig.getFetchSize());\n            }\n\n            if (stmtConfig.isMaxFieldSizeSet()) {\n                stmt.setMaxFieldSize(stmtConfig.getMaxFieldSize());\n            }\n\n            if (stmtConfig.isMaxRowsSet()) {\n                stmt.setMaxRows(stmtConfig.getMaxRows());\n            }\n\n            if (stmtConfig.isQueryTimeoutSet()) {\n                stmt.setQueryTimeout(stmtConfig.getQueryTimeout());\n            }\n        }\n    }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "configureStatement", "params": [{"name": "stmt", "type": "Statement"}], "body": "                                                                              {\n\n        if (stmtConfig != null) {\n            if (stmtConfig.isFetchDirectionSet()) {\n                stmt.setFetchDirection(stmtConfig.getFetchDirection());\n            }\n\n            if (stmtConfig.isFetchSizeSet()) {\n                stmt.setFetchSize(stmtConfig.getFetchSize());\n            }\n\n            if (stmtConfig.isMaxFieldSizeSet()) {\n                stmt.setMaxFieldSize(stmtConfig.getMaxFieldSize());\n            }\n\n            if (stmtConfig.isMaxRowsSet()) {\n                stmt.setMaxRows(stmtConfig.getMaxRows());\n            }\n\n            if (stmtConfig.isQueryTimeoutSet()) {\n                stmt.setQueryTimeout(stmtConfig.getQueryTimeout());\n            }\n        }\n    }", "signature": "private void configureStatement(final Statement stmt)"}, {"syntax_pass": true, "original_string": "    public void fillStatement(final PreparedStatement stmt, final Object... params) throws SQLException {\n        ParameterMetaData pmd = null;\n        if (!pmdKnownBroken) {\n            try {\n                pmd = getParameterMetaData(stmt);\n                if (pmd == null) { // can be returned by implementations that don't support the method\n                    pmdKnownBroken = true;\n                }\n            } catch (final SQLFeatureNotSupportedException ex) {\n                pmdKnownBroken = true;\n            }\n            // TODO see DBUTILS-117: would it make sense to catch any other SQLEx types here?\n        }\n        fillStatement(stmt, pmd, params);\n    }", "docstring": "\nFill the {@code PreparedStatement} replacement parameters with the\ngiven objects.\n\n@param stmt\n           PreparedStatement to fill\n@param params\n           Query replacement parameters; {@code null} is a valid\n           value to pass in.\n@throws SQLException\n            if a database access error occurs\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "fillStatement", "params": [{"name": "stmt", "type": "PreparedStatement"}], "body": "                                                                                                        {\n        ParameterMetaData pmd = null;\n        if (!pmdKnownBroken) {\n            try {\n                pmd = getParameterMetaData(stmt);\n                if (pmd == null) { // can be returned by implementations that don't support the method\n                    pmdKnownBroken = true;\n                }\n            } catch (final SQLFeatureNotSupportedException ex) {\n                pmdKnownBroken = true;\n            }\n            // TODO see DBUTILS-117: would it make sense to catch any other SQLEx types here?\n        }\n        fillStatement(stmt, pmd, params);\n    }", "signature": "public void fillStatement(final PreparedStatement stmt, final Object... params)"}, {"syntax_pass": true, "original_string": "    public void fillStatement(final PreparedStatement stmt, final ParameterMetaData pmd, final Object... params)\n            throws SQLException {\n\n        // check the parameter count, if we can\n        if (!pmdKnownBroken && pmd != null) {\n            final int stmtCount = pmd.getParameterCount();\n            final int paramsCount = params == null ? 0 : params.length;\n\n            if (stmtCount != paramsCount) {\n                throw new SQLException(\"Wrong number of parameters: expected \"\n                        + stmtCount + \", was given \" + paramsCount);\n            }\n        }\n\n        // nothing to do here\n        if (params == null) {\n            return;\n        }\n\n        CallableStatement call = null;\n        if (stmt instanceof CallableStatement) {\n            call = (CallableStatement) stmt;\n        }\n\n        for (int i = 0; i < params.length; i++) {\n            if (params[i] != null) {\n                if (call != null && params[i] instanceof OutParameter) {\n                    ((OutParameter<?>) params[i]).register(call, i + 1);\n                } else {\n                    stmt.setObject(i + 1, params[i]);\n                }\n            } else {\n                // VARCHAR works with many drivers regardless\n                // of the actual column type. Oddly, NULL and\n                // OTHER don't work with Oracle's drivers.\n                int sqlType = Types.VARCHAR;\n                if (!pmdKnownBroken) {\n                    // TODO see DBUTILS-117: does it make sense to catch SQLEx here?\n                    try {\n                        /*\n                         * It's not possible for pmdKnownBroken to change from true to false, (once true, always true) so pmd cannot be null here.\n                         */\n                        sqlType = pmd.getParameterType(i + 1);\n                    } catch (final SQLException e) {\n                        pmdKnownBroken = true;\n                    }\n                }\n                stmt.setNull(i + 1, sqlType);\n            }\n        }\n    }", "docstring": "\nFill the {@code PreparedStatement} replacement parameters with the\ngiven objects, and prefetched parameter metadata.\n\n@param stmt\n           PreparedStatement to fill\n@param pmd\n           Prefetched parameter metadata\n@param params\n           Query replacement parameters; {@code null} is a valid\n           value to pass in.\n@throws SQLException\n            if a database access error occurs\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "fillStatement", "params": [{"name": "stmt", "type": "PreparedStatement"}, {"name": "pmd", "type": "ParameterMetaData"}], "body": "                                {\n\n        // check the parameter count, if we can\n        if (!pmdKnownBroken && pmd != null) {\n            final int stmtCount = pmd.getParameterCount();\n            final int paramsCount = params == null ? 0 : params.length;\n\n            if (stmtCount != paramsCount) {\n                throw new SQLException(\"Wrong number of parameters: expected \"\n                        + stmtCount + \", was given \" + paramsCount);\n            }\n        }\n\n        // nothing to do here\n        if (params == null) {\n            return;\n        }\n\n        CallableStatement call = null;\n        if (stmt instanceof CallableStatement) {\n            call = (CallableStatement) stmt;\n        }\n\n        for (int i = 0; i < params.length; i++) {\n            if (params[i] != null) {\n                if (call != null && params[i] instanceof OutParameter) {\n                    ((OutParameter<?>) params[i]).register(call, i + 1);\n                } else {\n                    stmt.setObject(i + 1, params[i]);\n                }\n            } else {\n                // VARCHAR works with many drivers regardless\n                // of the actual column type. Oddly, NULL and\n                // OTHER don't work with Oracle's drivers.\n                int sqlType = Types.VARCHAR;\n                if (!pmdKnownBroken) {\n                    // TODO see DBUTILS-117: does it make sense to catch SQLEx here?\n                    try {\n                        /*\n                         * It's not possible for pmdKnownBroken to change from true to false, (once true, always true) so pmd cannot be null here.\n                         */\n                        sqlType = pmd.getParameterType(i + 1);\n                    } catch (final SQLException e) {\n                        pmdKnownBroken = true;\n                    }\n                }\n                stmt.setNull(i + 1, sqlType);\n            }\n        }\n    }", "signature": "public void fillStatement(final PreparedStatement stmt, final ParameterMetaData pmd, final Object... params)"}, {"syntax_pass": true, "original_string": "    public void fillStatementWithBean(final PreparedStatement stmt, final Object bean,\n            final PropertyDescriptor[] properties) throws SQLException {\n        final Object[] params = new Object[properties.length];\n        for (int i = 0; i < properties.length; i++) {\n            final PropertyDescriptor property = properties[i];\n            Object value = null;\n            final Method method = property.getReadMethod();\n            if (method == null) {\n                throw new IllegalArgumentException(\"No read method for bean property \" + bean.getClass() + \" \" + property.getName());\n            }\n            try {\n                value = method.invoke(bean);\n            } catch (final IllegalArgumentException e) {\n                throw new IllegalArgumentException(\"Couldn't invoke method with 0 arguments: \" + method, e);\n            } catch (final InvocationTargetException | IllegalAccessException e) {\n                throw new IllegalArgumentException(\"Couldn't invoke method: \" + method, e);\n            }\n            params[i] = value;\n        }\n        fillStatement(stmt, params);\n    }", "docstring": "\nFill the {@code PreparedStatement} replacement parameters with the\ngiven object's bean property values.\n\n@param stmt\n           PreparedStatement to fill\n@param bean\n           a JavaBean object\n@param properties\n           an ordered array of properties; this gives the order to insert\n           values in the statement\n@throws SQLException\n            if a database access error occurs\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "fillStatementWithBean", "params": [{"name": "stmt", "type": "PreparedStatement"}, {"name": "bean", "type": "Object"}, {"name": "properties", "type": "PropertyDescriptor[]"}], "body": "                                                                       {\n        final Object[] params = new Object[properties.length];\n        for (int i = 0; i < properties.length; i++) {\n            final PropertyDescriptor property = properties[i];\n            Object value = null;\n            final Method method = property.getReadMethod();\n            if (method == null) {\n                throw new IllegalArgumentException(\"No read method for bean property \" + bean.getClass() + \" \" + property.getName());\n            }\n            try {\n                value = method.invoke(bean);\n            } catch (final IllegalArgumentException e) {\n                throw new IllegalArgumentException(\"Couldn't invoke method with 0 arguments: \" + method, e);\n            } catch (final InvocationTargetException | IllegalAccessException e) {\n                throw new IllegalArgumentException(\"Couldn't invoke method: \" + method, e);\n            }\n            params[i] = value;\n        }\n        fillStatement(stmt, params);\n    }", "signature": "public void fillStatementWithBean(final PreparedStatement stmt, final Object bean,\n            final PropertyDescriptor[] properties)"}, {"syntax_pass": true, "original_string": "    public void fillStatementWithBean(final PreparedStatement stmt, final Object bean,\n            final String... propertyNames) throws SQLException {\n        PropertyDescriptor[] descriptors;\n        try {\n            descriptors = Introspector.getBeanInfo(bean.getClass()).getPropertyDescriptors();\n        } catch (final IntrospectionException e) {\n            throw new IllegalArgumentException(\"Couldn't introspect bean \" + bean.getClass().toString(), e);\n        }\n        final PropertyDescriptor[] sorted = new PropertyDescriptor[propertyNames.length];\n        for (int i = 0; i < propertyNames.length; i++) {\n            final String propertyName = propertyNames[i];\n            if (propertyName == null) {\n                throw new NullPointerException(\"propertyName can't be null: \" + i);\n            }\n            boolean found = false;\n            for (final PropertyDescriptor descriptor : descriptors) {\n                if (propertyName.equals(descriptor.getName())) {\n                    sorted[i] = descriptor;\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                throw new IllegalStateException(\"Couldn't find bean property: \" + bean.getClass() + \" \" + propertyName);\n            }\n        }\n        fillStatementWithBean(stmt, bean, sorted);\n    }", "docstring": "\nFill the {@code PreparedStatement} replacement parameters with the\ngiven object's bean property values.\n\n@param stmt\n           PreparedStatement to fill\n@param bean\n           A JavaBean object\n@param propertyNames\n           An ordered array of property names (these should match the\n           getters/setters); this gives the order to insert values in the\n           statement\n@throws SQLException\n            If a database access error occurs\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "fillStatementWithBean", "params": [{"name": "stmt", "type": "PreparedStatement"}, {"name": "bean", "type": "Object"}], "body": "                                                               {\n        PropertyDescriptor[] descriptors;\n        try {\n            descriptors = Introspector.getBeanInfo(bean.getClass()).getPropertyDescriptors();\n        } catch (final IntrospectionException e) {\n            throw new IllegalArgumentException(\"Couldn't introspect bean \" + bean.getClass().toString(), e);\n        }\n        final PropertyDescriptor[] sorted = new PropertyDescriptor[propertyNames.length];\n        for (int i = 0; i < propertyNames.length; i++) {\n            final String propertyName = propertyNames[i];\n            if (propertyName == null) {\n                throw new NullPointerException(\"propertyName can't be null: \" + i);\n            }\n            boolean found = false;\n            for (final PropertyDescriptor descriptor : descriptors) {\n                if (propertyName.equals(descriptor.getName())) {\n                    sorted[i] = descriptor;\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                throw new IllegalStateException(\"Couldn't find bean property: \" + bean.getClass() + \" \" + propertyName);\n            }\n        }\n        fillStatementWithBean(stmt, bean, sorted);\n    }", "signature": "public void fillStatementWithBean(final PreparedStatement stmt, final Object bean,\n            final String... propertyNames)"}, {"syntax_pass": true, "original_string": "    public DataSource getDataSource() {\n        return this.ds;\n    }", "docstring": "\nReturns the {@code DataSource} this runner is using.\n{@code QueryRunner} methods always call this method to get the\n{@code DataSource} so subclasses can provide specialized behavior.\n\n@return DataSource the runner is using\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "DataSource", "classes": []}, "name": "getDataSource", "params": [], "body": "                                      {\n        return this.ds;\n    }", "signature": "public DataSource getDataSource()"}, {"syntax_pass": true, "original_string": "    public ParameterMetaData getParameterMetaData(final PreparedStatement stmt) throws SQLException {\n        ParameterMetaData pmd = null;\n        if (!pmdKnownBroken) {\n            try {\n                pmd = stmt.getParameterMetaData();\n            } catch (final SQLFeatureNotSupportedException ex) {\n                pmdKnownBroken = true;\n            }\n        }\n        return pmd;\n    }", "docstring": "\nGets the {@code ParameterMetaData} of the prepared statement, if the {@code pmdKnownBroken}\nis set to false.\n\n@param stmt\n           PreparedStatement of which to query the metadata of parameters\n@return the metadata of parameters\n@throws SQLException\n           if a database access error occurs\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "ParameterMetaData", "classes": []}, "name": "getParameterMetaData", "params": [{"name": "stmt", "type": "PreparedStatement"}], "body": "                                                                                                    {\n        ParameterMetaData pmd = null;\n        if (!pmdKnownBroken) {\n            try {\n                pmd = stmt.getParameterMetaData();\n            } catch (final SQLFeatureNotSupportedException ex) {\n                pmdKnownBroken = true;\n            }\n        }\n        return pmd;\n    }", "signature": "public ParameterMetaData getParameterMetaData(final PreparedStatement stmt)"}, {"syntax_pass": true, "original_string": "    public boolean isPmdKnownBroken() {\n        return pmdKnownBroken;\n    }", "docstring": "\nSome drivers don't support\n{@link ParameterMetaData#getParameterType(int) }; if\n{@code pmdKnownBroken} is set to true, we won't even try it; if\nfalse, we'll try it, and if it breaks, we'll remember not to use it\nagain.\n\n@return the flag to skip (or not)\n        {@link ParameterMetaData#getParameterType(int) }\n@since 1.4\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isPmdKnownBroken", "params": [], "body": "                                      {\n        return pmdKnownBroken;\n    }", "signature": "public boolean isPmdKnownBroken()"}, {"syntax_pass": true, "original_string": "    protected CallableStatement prepareCall(final Connection conn, final String sql)\n            throws SQLException {\n\n        return conn.prepareCall(sql);\n    }", "docstring": "\nFactory method that creates and initializes a\n{@code CallableStatement} object for the given SQL.\n{@code QueryRunner} methods always call this method to prepare\ncallable statements for them. Subclasses can override this method to\nprovide special CallableStatement configuration if needed. This\nimplementation simply calls {@code conn.prepareCall(sql)}.\n\n@param conn\n           The {@code Connection} used to create the\n           {@code CallableStatement}\n@param sql\n           The SQL statement to prepare.\n@return An initialized {@code CallableStatement}.\n@throws SQLException\n            if a database access error occurs\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "CallableStatement", "classes": []}, "name": "prepareCall", "params": [{"name": "conn", "type": "Connection"}, {"name": "sql", "type": "String"}], "body": "                                {\n\n        return conn.prepareCall(sql);\n    }", "signature": "protected CallableStatement prepareCall(final Connection conn, final String sql)"}, {"syntax_pass": true, "original_string": "    protected Connection prepareConnection() throws SQLException {\n        if (getDataSource() == null) {\n            throw new SQLException(\n                    \"QueryRunner requires a DataSource to be \"\n                            + \"invoked in this way, or a Connection should be passed in\");\n        }\n        return getDataSource().getConnection();\n    }", "docstring": "\nFactory method that creates and initializes a {@code Connection}\nobject. {@code QueryRunner} methods always call this method to\nretrieve connections from its DataSource. Subclasses can override this\nmethod to provide special {@code Connection} configuration if\nneeded. This implementation simply calls {@code ds.getConnection()}.\n\n@return An initialized {@code Connection}.\n@throws SQLException\n            if a database access error occurs\n@since 1.1\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Connection", "classes": []}, "name": "prepareConnection", "params": [], "body": "                                                                 {\n        if (getDataSource() == null) {\n            throw new SQLException(\n                    \"QueryRunner requires a DataSource to be \"\n                            + \"invoked in this way, or a Connection should be passed in\");\n        }\n        return getDataSource().getConnection();\n    }", "signature": "protected Connection prepareConnection()"}, {"syntax_pass": true, "original_string": "    protected PreparedStatement prepareStatement(final Connection conn, final String sql)\n            throws SQLException {\n\n        @SuppressWarnings(\"resource\")\n        final\n        PreparedStatement ps = conn.prepareStatement(sql);\n        try {\n            configureStatement(ps);\n        } catch (final SQLException e) {\n            ps.close();\n            throw e;\n        }\n        return ps;\n    }", "docstring": "\nFactory method that creates and initializes a\n{@code PreparedStatement} object for the given SQL.\n{@code QueryRunner} methods always call this method to prepare\nstatements for them. Subclasses can override this method to provide\nspecial PreparedStatement configuration if needed. This implementation\nsimply calls {@code conn.prepareStatement(sql)}.\n\n@param conn\n           The {@code Connection} used to create the\n           {@code PreparedStatement}\n@param sql\n           The SQL statement to prepare.\n@return An initialized {@code PreparedStatement}.\n@throws SQLException\n            if a database access error occurs\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "PreparedStatement", "classes": []}, "name": "prepareStatement", "params": [{"name": "conn", "type": "Connection"}, {"name": "sql", "type": "String"}], "body": "                                {\n\n        @SuppressWarnings(\"resource\")\n        final\n        PreparedStatement ps = conn.prepareStatement(sql);\n        try {\n            configureStatement(ps);\n        } catch (final SQLException e) {\n            ps.close();\n            throw e;\n        }\n        return ps;\n    }", "signature": "protected PreparedStatement prepareStatement(final Connection conn, final String sql)"}, {"syntax_pass": true, "original_string": "    protected PreparedStatement prepareStatement(final Connection conn, final String sql, final int returnedKeys)\n            throws SQLException {\n\n        @SuppressWarnings(\"resource\")\n        final\n        PreparedStatement ps = conn.prepareStatement(sql, returnedKeys);\n        try {\n            configureStatement(ps);\n        } catch (final SQLException e) {\n            ps.close();\n            throw e;\n        }\n        return ps;\n    }", "docstring": "\nFactory method that creates and initializes a\n{@code PreparedStatement} object for the given SQL.\n{@code QueryRunner} methods always call this method to prepare\nstatements for them. Subclasses can override this method to provide\nspecial PreparedStatement configuration if needed. This implementation\nsimply calls {@code conn.prepareStatement(sql, returnedKeys)}\nwhich will result in the ability to retrieve the automatically-generated\nkeys from an auto_increment column.\n\n@param conn\n           The {@code Connection} used to create the\n           {@code PreparedStatement}\n@param sql\n           The SQL statement to prepare.\n@param returnedKeys\n           Flag indicating whether to return generated keys or not.\n\n@return An initialized {@code PreparedStatement}.\n@throws SQLException\n            if a database access error occurs\n@since 1.6\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "PreparedStatement", "classes": []}, "name": "prepareStatement", "params": [{"name": "conn", "type": "Connection"}, {"name": "sql", "type": "String"}, {"name": "returnedKeys", "type": "int"}], "body": "                                {\n\n        @SuppressWarnings(\"resource\")\n        final\n        PreparedStatement ps = conn.prepareStatement(sql, returnedKeys);\n        try {\n            configureStatement(ps);\n        } catch (final SQLException e) {\n            ps.close();\n            throw e;\n        }\n        return ps;\n    }", "signature": "protected PreparedStatement prepareStatement(final Connection conn, final String sql, final int returnedKeys)"}, {"syntax_pass": true, "original_string": "    protected void rethrow(final SQLException cause, final String sql, final Object... params)\n            throws SQLException {\n\n        String causeMessage = cause.getMessage();\n        if (causeMessage == null) {\n            causeMessage = \"\";\n        }\n        final StringBuilder msg = new StringBuilder(causeMessage);\n\n        msg.append(\" Query: \");\n        msg.append(sql);\n        msg.append(\" Parameters: \");\n\n        if (params == null) {\n            msg.append(\"[]\");\n        } else {\n            msg.append(Arrays.deepToString(params));\n        }\n\n        final SQLException e = new SQLException(msg.toString(), cause.getSQLState(),\n                cause.getErrorCode());\n        e.setNextException(cause);\n\n        throw e;\n    }", "docstring": "\nThrows a new exception with a more informative error message.\n\n@param cause\n           The original exception that will be chained to the new\n           exception when it's rethrown.\n\n@param sql\n           The query that was executing when the exception happened.\n\n@param params\n           The query replacement parameters; {@code null} is a valid\n           value to pass in.\n\n@throws SQLException\n            if a database access error occurs\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "name": "rethrow", "params": [{"name": "cause", "type": "SQLException"}, {"name": "sql", "type": "String"}], "body": "                                {\n\n        String causeMessage = cause.getMessage();\n        if (causeMessage == null) {\n            causeMessage = \"\";\n        }\n        final StringBuilder msg = new StringBuilder(causeMessage);\n\n        msg.append(\" Query: \");\n        msg.append(sql);\n        msg.append(\" Parameters: \");\n\n        if (params == null) {\n            msg.append(\"[]\");\n        } else {\n            msg.append(Arrays.deepToString(params));\n        }\n\n        final SQLException e = new SQLException(msg.toString(), cause.getSQLState(),\n                cause.getErrorCode());\n        e.setNextException(cause);\n\n        throw e;\n    }", "signature": "protected void rethrow(final SQLException cause, final String sql, final Object... params)"}, {"syntax_pass": true, "original_string": "    protected ResultSet wrap(final ResultSet rs) {\n        return rs;\n    }", "docstring": "\nWrap the {@code ResultSet} in a decorator before processing it. This\nimplementation returns the {@code ResultSet} it is given without any\ndecoration.\n\n<p>\nOften, the implementation of this method can be done in an anonymous\ninner class like this:\n</p>\n\n<pre>\nQueryRunner run = new QueryRunner() {\n    protected ResultSet wrap(ResultSet rs) {\n        return StringTrimmedResultSet.wrap(rs);\n    }\n};\n</pre>\n\n@param rs\n           The {@code ResultSet} to decorate; never\n           {@code null}.\n@return The {@code ResultSet} wrapped in some decorator.\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "ResultSet", "classes": []}, "name": "wrap", "params": [{"name": "rs", "type": "ResultSet"}], "body": "                                                 {\n        return rs;\n    }", "signature": "protected ResultSet wrap(final ResultSet rs)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/apache/commons/dbutils/BasicRowProcessor.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils;\n\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\n\n/**\n * Basic implementation of the {@code RowProcessor} interface.\n *\n * <p>\n * This class is thread-safe.\n * </p>\n *\n * @see RowProcessor\n */\npublic class BasicRowProcessor implements RowProcessor {\n\n    /**\n     * A Map that converts all keys to lowercase Strings for case insensitive\n     * lookups.  This is needed for the toMap() implementation because\n     * databases don't consistently handle the casing of column names.\n     *\n     * <p>The keys are stored as they are given [BUG #DBUTILS-34], so we maintain\n     * an internal mapping from lowercase keys to the real keys in order to\n     * achieve the case insensitive lookup.\n     *\n     * <p>Note: This implementation does not allow {@code null}\n     * for key, whereas {@link LinkedHashMap} does, because of the code:\n     * <pre>\n     * key.toString().toLowerCase()\n     * </pre>\n     */\n    private static final class CaseInsensitiveHashMap extends LinkedHashMap<String, Object> {\n\n        /**\n         * Required for serialization support.\n         *\n         * @see java.io.Serializable\n         */\n        private static final long serialVersionUID = -2848100435296897392L;\n\n        /**\n         * The internal mapping from lowercase keys to the real keys.\n         *\n         * <p>\n         * Any query operation using the key\n         * ({@link #get(Object)}, {@link #containsKey(Object)})\n         * is done in three steps:\n         * <ul>\n         * <li>convert the parameter key to lower case</li>\n         * <li>get the actual key that corresponds to the lower case key</li>\n         * <li>query the map with the actual key</li>\n         * </ul>\n         * </p>\n         */\n        private final Map<String, String> lowerCaseMap = new HashMap<>();\n\n        private CaseInsensitiveHashMap(final int initialCapacity) {\n            super(initialCapacity);\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public boolean containsKey(final Object key) {\n            final Object realKey = lowerCaseMap.get(key.toString().toLowerCase(Locale.ROOT));\n            return super.containsKey(realKey);\n            // Possible optimization here:\n            // Since the lowerCaseMap contains a mapping for all the keys,\n            // we could just do this:\n            // return lowerCaseMap.containsKey(key.toString().toLowerCase());\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public Object get(final Object key) {\n            final Object realKey = lowerCaseMap.get(key.toString().toLowerCase(Locale.ROOT));\n            return super.get(realKey);\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public Object put(final String key, final Object value) {\n            /*\n             * In order to keep the map and lowerCaseMap synchronized,\n             * we have to remove the old mapping before putting the\n             * new one. Indeed, oldKey and key are not necessarily equals.\n             * (That's why we call super.remove(oldKey) and not just\n             * super.put(key, value))\n             */\n            final Object oldKey = lowerCaseMap.put(key.toLowerCase(Locale.ROOT), key);\n            final Object oldValue = super.remove(oldKey);\n            super.put(key, value);\n            return oldValue;\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public void putAll(final Map<? extends String, ?> m) {\n            m.forEach(this::put);\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public Object remove(final Object key) {\n            final Object realKey = lowerCaseMap.remove(key.toString().toLowerCase(Locale.ROOT));\n            return super.remove(realKey);\n        }\n    }\n\n    /**\n     * The default BeanProcessor instance to use if not supplied in the\n     * constructor.\n     */\n    private static final BeanProcessor DEFAULT_CONVERTER = new BeanProcessor();\n\n    /**\n     * The Singleton instance of this class.\n     */\n    private static final BasicRowProcessor INSTANCE = new BasicRowProcessor();\n\n    protected static Map<String, Object> createCaseInsensitiveHashMap(final int cols) {\n        return new CaseInsensitiveHashMap(cols);\n    }\n\n    /**\n     * Returns the Singleton instance of this class.\n     *\n     * @return The single instance of this class.\n     * @deprecated Create instances with the constructors instead.  This will\n     * be removed in 2.0.\n     */\n    @Deprecated\n    public static BasicRowProcessor instance() {\n        return INSTANCE;\n    }\n\n    /**\n     * Use this to process beans.\n     */\n    private final BeanProcessor convert;\n\n    /**\n     * BasicRowProcessor constructor.  Bean processing defaults to a\n     * BeanProcessor instance.\n     */\n    public BasicRowProcessor() {\n        this(DEFAULT_CONVERTER);\n    }\n\n    /**\n     * BasicRowProcessor constructor.\n     * @param convert The BeanProcessor to use when converting columns to\n     * bean properties.\n     * @since 1.1\n     */\n    public BasicRowProcessor(final BeanProcessor convert) {\n        this.convert = convert;\n    }\n\n    /**\n     * Convert a {@code ResultSet} row into an {@code Object[]}.\n     * This implementation copies column values into the array in the same\n     * order they're returned from the {@code ResultSet}.  Array elements\n     * will be set to {@code null} if the column was SQL NULL.\n     *\n     * @see org.apache.commons.dbutils.RowProcessor#toArray(java.sql.ResultSet)\n     * @param resultSet ResultSet that supplies the array data\n     * @throws SQLException if a database access error occurs\n     * @return the newly created array\n     */\n    @Override\n    public Object[] toArray(final ResultSet resultSet) throws SQLException {\n        final ResultSetMetaData meta = resultSet.getMetaData();\n        final int cols = meta.getColumnCount();\n        final Object[] result = new Object[cols];\n\n        for (int i = 0; i < cols; i++) {\n            result[i] = resultSet.getObject(i + 1);\n        }\n\n        return result;\n    }\n\n    /**\n     * Convert a {@code ResultSet} row into a JavaBean.  This\n     * implementation delegates to a BeanProcessor instance.\n     * @see org.apache.commons.dbutils.RowProcessor#toBean(java.sql.ResultSet, Class)\n     * @see org.apache.commons.dbutils.BeanProcessor#toBean(java.sql.ResultSet, Class)\n     * @param <T> The type of bean to create\n     * @param resultSet ResultSet that supplies the bean data\n     * @param type Class from which to create the bean instance\n     * @throws SQLException if a database access error occurs\n     * @return the newly created bean\n     */\n    @Override\n    public <T> T toBean(final ResultSet resultSet, final Class<? extends T> type) throws SQLException {\n        return this.convert.toBean(resultSet, type);\n    }\n\n    /**\n     * Convert a {@code ResultSet} into a {@code List} of JavaBeans.\n     * This implementation delegates to a BeanProcessor instance.\n     * @see org.apache.commons.dbutils.RowProcessor#toBeanList(java.sql.ResultSet, Class)\n     * @see org.apache.commons.dbutils.BeanProcessor#toBeanList(java.sql.ResultSet, Class)\n     * @param <T> The type of bean to create\n     * @param resultSet ResultSet that supplies the bean data\n     * @param type Class from which to create the bean instance\n     * @throws SQLException if a database access error occurs\n     * @return A {@code List} of beans with the given type in the order\n     * they were returned by the {@code ResultSet}.\n     */\n    @Override\n    public <T> List<T> toBeanList(final ResultSet resultSet, final Class<? extends T> type) throws SQLException {\n        return this.convert.toBeanList(resultSet, type);\n    }\n\n    /**\n     * Convert a {@code ResultSet} row into a {@code Map}.\n     *\n     * <p>\n     * This implementation returns a {@code Map} with case insensitive column names as keys. Calls to\n     * {@code map.get(\"COL\")} and {@code map.get(\"col\")} return the same value. Furthermore this implementation\n     * will return an ordered map, that preserves the ordering of the columns in the ResultSet, so that iterating over\n     * the entry set of the returned map will return the first column of the ResultSet, then the second and so forth.\n     * </p>\n     *\n     * @param resultSet ResultSet that supplies the map data\n     * @return the newly created Map\n     * @throws SQLException if a database access error occurs\n     * @see org.apache.commons.dbutils.RowProcessor#toMap(java.sql.ResultSet)\n     */\n    @Override\n    public Map<String, Object> toMap(final ResultSet resultSet) throws SQLException {\n        final ResultSetMetaData rsmd = resultSet.getMetaData();\n        final int cols = rsmd.getColumnCount();\n        final Map<String, Object> result = createCaseInsensitiveHashMap(cols);\n\n        for (int i = 1; i <= cols; i++) {\n            String propKey = rsmd.getColumnLabel(i);\n            if (null == propKey || 0 == propKey.length()) {\n              propKey = rsmd.getColumnName(i);\n            }\n            if (null == propKey || 0 == propKey.length()) {\n              // The column index can't be null\n              propKey = Integer.toString(i);\n            }\n            result.put(propKey, resultSet.getObject(i));\n        }\n\n        return result;\n    }\n\n}\n", "file_hash": "05ca05825a00479969ab73f2e1411f41f2bd258c02f9feff10d00d96654c2363", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils;", "import java.sql.ResultSet;", "import java.sql.ResultSetMetaData;", "import java.sql.SQLException;", "import java.util.HashMap;", "import java.util.LinkedHashMap;", "import java.util.List;", "import java.util.Locale;", "import java.util.Map;"], "methods": [], "classes": [{"original_string": "public class BasicRowProcessor implements RowProcessor {\n\n    /**\n     * A Map that converts all keys to lowercase Strings for case insensitive\n     * lookups.  This is needed for the toMap() implementation because\n     * databases don't consistently handle the casing of column names.\n     *\n     * <p>The keys are stored as they are given [BUG #DBUTILS-34], so we maintain\n     * an internal mapping from lowercase keys to the real keys in order to\n     * achieve the case insensitive lookup.\n     *\n     * <p>Note: This implementation does not allow {@code null}\n     * for key, whereas {@link LinkedHashMap} does, because of the code:\n     * <pre>\n     * key.toString().toLowerCase()\n     * </pre>\n     */\n    private static final class CaseInsensitiveHashMap extends LinkedHashMap<String, Object> {\n\n        /**\n         * Required for serialization support.\n         *\n         * @see java.io.Serializable\n         */\n        private static final long serialVersionUID = -2848100435296897392L;\n\n        /**\n         * The internal mapping from lowercase keys to the real keys.\n         *\n         * <p>\n         * Any query operation using the key\n         * ({@link #get(Object)}, {@link #containsKey(Object)})\n         * is done in three steps:\n         * <ul>\n         * <li>convert the parameter key to lower case</li>\n         * <li>get the actual key that corresponds to the lower case key</li>\n         * <li>query the map with the actual key</li>\n         * </ul>\n         * </p>\n         */\n        private final Map<String, String> lowerCaseMap = new HashMap<>();\n\n        private CaseInsensitiveHashMap(final int initialCapacity) {\n            super(initialCapacity);\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public boolean containsKey(final Object key) {\n            final Object realKey = lowerCaseMap.get(key.toString().toLowerCase(Locale.ROOT));\n            return super.containsKey(realKey);\n            // Possible optimization here:\n            // Since the lowerCaseMap contains a mapping for all the keys,\n            // we could just do this:\n            // return lowerCaseMap.containsKey(key.toString().toLowerCase());\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public Object get(final Object key) {\n            final Object realKey = lowerCaseMap.get(key.toString().toLowerCase(Locale.ROOT));\n            return super.get(realKey);\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public Object put(final String key, final Object value) {\n            /*\n             * In order to keep the map and lowerCaseMap synchronized,\n             * we have to remove the old mapping before putting the\n             * new one. Indeed, oldKey and key are not necessarily equals.\n             * (That's why we call super.remove(oldKey) and not just\n             * super.put(key, value))\n             */\n            final Object oldKey = lowerCaseMap.put(key.toLowerCase(Locale.ROOT), key);\n            final Object oldValue = super.remove(oldKey);\n            super.put(key, value);\n            return oldValue;\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public void putAll(final Map<? extends String, ?> m) {\n            m.forEach(this::put);\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public Object remove(final Object key) {\n            final Object realKey = lowerCaseMap.remove(key.toString().toLowerCase(Locale.ROOT));\n            return super.remove(realKey);\n        }\n    }\n\n    /**\n     * The default BeanProcessor instance to use if not supplied in the\n     * constructor.\n     */\n    private static final BeanProcessor DEFAULT_CONVERTER = new BeanProcessor();\n\n    /**\n     * The Singleton instance of this class.\n     */\n    private static final BasicRowProcessor INSTANCE = new BasicRowProcessor();\n\n    protected static Map<String, Object> createCaseInsensitiveHashMap(final int cols) {\n        return new CaseInsensitiveHashMap(cols);\n    }\n\n    /**\n     * Returns the Singleton instance of this class.\n     *\n     * @return The single instance of this class.\n     * @deprecated Create instances with the constructors instead.  This will\n     * be removed in 2.0.\n     */\n    @Deprecated\n    public static BasicRowProcessor instance() {\n        return INSTANCE;\n    }\n\n    /**\n     * Use this to process beans.\n     */\n    private final BeanProcessor convert;\n\n    /**\n     * BasicRowProcessor constructor.  Bean processing defaults to a\n     * BeanProcessor instance.\n     */\n    public BasicRowProcessor() {\n        this(DEFAULT_CONVERTER);\n    }\n\n    /**\n     * BasicRowProcessor constructor.\n     * @param convert The BeanProcessor to use when converting columns to\n     * bean properties.\n     * @since 1.1\n     */\n    public BasicRowProcessor(final BeanProcessor convert) {\n        this.convert = convert;\n    }\n\n    /**\n     * Convert a {@code ResultSet} row into an {@code Object[]}.\n     * This implementation copies column values into the array in the same\n     * order they're returned from the {@code ResultSet}.  Array elements\n     * will be set to {@code null} if the column was SQL NULL.\n     *\n     * @see org.apache.commons.dbutils.RowProcessor#toArray(java.sql.ResultSet)\n     * @param resultSet ResultSet that supplies the array data\n     * @throws SQLException if a database access error occurs\n     * @return the newly created array\n     */\n    @Override\n    public Object[] toArray(final ResultSet resultSet) throws SQLException {\n        final ResultSetMetaData meta = resultSet.getMetaData();\n        final int cols = meta.getColumnCount();\n        final Object[] result = new Object[cols];\n\n        for (int i = 0; i < cols; i++) {\n            result[i] = resultSet.getObject(i + 1);\n        }\n\n        return result;\n    }\n\n    /**\n     * Convert a {@code ResultSet} row into a JavaBean.  This\n     * implementation delegates to a BeanProcessor instance.\n     * @see org.apache.commons.dbutils.RowProcessor#toBean(java.sql.ResultSet, Class)\n     * @see org.apache.commons.dbutils.BeanProcessor#toBean(java.sql.ResultSet, Class)\n     * @param <T> The type of bean to create\n     * @param resultSet ResultSet that supplies the bean data\n     * @param type Class from which to create the bean instance\n     * @throws SQLException if a database access error occurs\n     * @return the newly created bean\n     */\n    @Override\n    public <T> T toBean(final ResultSet resultSet, final Class<? extends T> type) throws SQLException {\n        return this.convert.toBean(resultSet, type);\n    }\n\n    /**\n     * Convert a {@code ResultSet} into a {@code List} of JavaBeans.\n     * This implementation delegates to a BeanProcessor instance.\n     * @see org.apache.commons.dbutils.RowProcessor#toBeanList(java.sql.ResultSet, Class)\n     * @see org.apache.commons.dbutils.BeanProcessor#toBeanList(java.sql.ResultSet, Class)\n     * @param <T> The type of bean to create\n     * @param resultSet ResultSet that supplies the bean data\n     * @param type Class from which to create the bean instance\n     * @throws SQLException if a database access error occurs\n     * @return A {@code List} of beans with the given type in the order\n     * they were returned by the {@code ResultSet}.\n     */\n    @Override\n    public <T> List<T> toBeanList(final ResultSet resultSet, final Class<? extends T> type) throws SQLException {\n        return this.convert.toBeanList(resultSet, type);\n    }\n\n    /**\n     * Convert a {@code ResultSet} row into a {@code Map}.\n     *\n     * <p>\n     * This implementation returns a {@code Map} with case insensitive column names as keys. Calls to\n     * {@code map.get(\"COL\")} and {@code map.get(\"col\")} return the same value. Furthermore this implementation\n     * will return an ordered map, that preserves the ordering of the columns in the ResultSet, so that iterating over\n     * the entry set of the returned map will return the first column of the ResultSet, then the second and so forth.\n     * </p>\n     *\n     * @param resultSet ResultSet that supplies the map data\n     * @return the newly created Map\n     * @throws SQLException if a database access error occurs\n     * @see org.apache.commons.dbutils.RowProcessor#toMap(java.sql.ResultSet)\n     */\n    @Override\n    public Map<String, Object> toMap(final ResultSet resultSet) throws SQLException {\n        final ResultSetMetaData rsmd = resultSet.getMetaData();\n        final int cols = rsmd.getColumnCount();\n        final Map<String, Object> result = createCaseInsensitiveHashMap(cols);\n\n        for (int i = 1; i <= cols; i++) {\n            String propKey = rsmd.getColumnLabel(i);\n            if (null == propKey || 0 == propKey.length()) {\n              propKey = rsmd.getColumnName(i);\n            }\n            if (null == propKey || 0 == propKey.length()) {\n              // The column index can't be null\n              propKey = Integer.toString(i);\n            }\n            result.put(propKey, resultSet.getObject(i));\n        }\n\n        return result;\n    }\n\n}", "definition": "public class BasicRowProcessor implements RowProcessor", "class_docstring": "\nBasic implementation of the {@code RowProcessor} interface.\n\n<p>\nThis class is thread-safe.\n</p>\n\n@see RowProcessor\n", "name": "BasicRowProcessor", "super_interfaces": ["RowProcessor"], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private static final BeanProcessor DEFAULT_CONVERTER = new BeanProcessor();", "docstring": "\nThe default BeanProcessor instance to use if not supplied in the\nconstructor.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "BeanProcessor", "name": "DEFAULT_CONVERTER = new BeanProcessor()", "syntax_pass": true}, {"attribute_expression": "private static final BasicRowProcessor INSTANCE = new BasicRowProcessor();", "docstring": "\nThe Singleton instance of this class.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "BasicRowProcessor", "name": "INSTANCE = new BasicRowProcessor()", "syntax_pass": true}, {"attribute_expression": "private final BeanProcessor convert;", "docstring": "\nUse this to process beans.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "BeanProcessor", "name": "convert", "syntax_pass": true}], "classes": [{"original_string": "    private static final class CaseInsensitiveHashMap extends LinkedHashMap<String, Object> {\n\n        /**\n         * Required for serialization support.\n         *\n         * @see java.io.Serializable\n         */\n        private static final long serialVersionUID = -2848100435296897392L;\n\n        /**\n         * The internal mapping from lowercase keys to the real keys.\n         *\n         * <p>\n         * Any query operation using the key\n         * ({@link #get(Object)}, {@link #containsKey(Object)})\n         * is done in three steps:\n         * <ul>\n         * <li>convert the parameter key to lower case</li>\n         * <li>get the actual key that corresponds to the lower case key</li>\n         * <li>query the map with the actual key</li>\n         * </ul>\n         * </p>\n         */\n        private final Map<String, String> lowerCaseMap = new HashMap<>();\n\n        private CaseInsensitiveHashMap(final int initialCapacity) {\n            super(initialCapacity);\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public boolean containsKey(final Object key) {\n            final Object realKey = lowerCaseMap.get(key.toString().toLowerCase(Locale.ROOT));\n            return super.containsKey(realKey);\n            // Possible optimization here:\n            // Since the lowerCaseMap contains a mapping for all the keys,\n            // we could just do this:\n            // return lowerCaseMap.containsKey(key.toString().toLowerCase());\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public Object get(final Object key) {\n            final Object realKey = lowerCaseMap.get(key.toString().toLowerCase(Locale.ROOT));\n            return super.get(realKey);\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public Object put(final String key, final Object value) {\n            /*\n             * In order to keep the map and lowerCaseMap synchronized,\n             * we have to remove the old mapping before putting the\n             * new one. Indeed, oldKey and key are not necessarily equals.\n             * (That's why we call super.remove(oldKey) and not just\n             * super.put(key, value))\n             */\n            final Object oldKey = lowerCaseMap.put(key.toLowerCase(Locale.ROOT), key);\n            final Object oldValue = super.remove(oldKey);\n            super.put(key, value);\n            return oldValue;\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public void putAll(final Map<? extends String, ?> m) {\n            m.forEach(this::put);\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public Object remove(final Object key) {\n            final Object realKey = lowerCaseMap.remove(key.toString().toLowerCase(Locale.ROOT));\n            return super.remove(realKey);\n        }\n    }", "definition": "    private static final class CaseInsensitiveHashMap extends LinkedHashMap<String, Object>", "class_docstring": "\nA Map that converts all keys to lowercase Strings for case insensitive\nlookups.  This is needed for the toMap() implementation because\ndatabases don't consistently handle the casing of column names.\n\n<p>The keys are stored as they are given [BUG #DBUTILS-34], so we maintain\nan internal mapping from lowercase keys to the real keys in order to\nachieve the case insensitive lookup.\n\n<p>Note: This implementation does not allow {@code null}\nfor key, whereas {@link LinkedHashMap} does, because of the code:\n<pre>\nkey.toString().toLowerCase()\n</pre>\n", "name": "CaseInsensitiveHashMap", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = -2848100435296897392L;", "docstring": "\nRequired for serialization support.\n\n@see java.io.Serializable\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -2848100435296897392L", "syntax_pass": true}, {"attribute_expression": "private final Map<String, String> lowerCaseMap = new HashMap<>();", "docstring": "\nThe internal mapping from lowercase keys to the real keys.\n\n<p>\nAny query operation using the key\n({@link #get(Object)}, {@link #containsKey(Object)})\nis done in three steps:\n<ul>\n<li>convert the parameter key to lower case</li>\n<li>get the actual key that corresponds to the lower case key</li>\n<li>query the map with the actual key</li>\n</ul>\n</p>\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Map<String, String>", "name": "lowerCaseMap = new HashMap<>()", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        private CaseInsensitiveHashMap(final int initialCapacity) {\n            super(initialCapacity);\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "CaseInsensitiveHashMap", "params": [{"name": "initialCapacity", "type": "int"}], "body": "                                                                  {\n            super(initialCapacity);\n        }", "signature": "private CaseInsensitiveHashMap(final int initialCapacity)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean containsKey(final Object key) {\n            final Object realKey = lowerCaseMap.get(key.toString().toLowerCase(Locale.ROOT));\n            return super.containsKey(realKey);\n            // Possible optimization here:\n            // Since the lowerCaseMap contains a mapping for all the keys,\n            // we could just do this:\n            // return lowerCaseMap.containsKey(key.toString().toLowerCase());\n        }", "docstring": " {@inheritDoc}", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "containsKey", "params": [{"name": "key", "type": "Object"}], "body": "                                                     {\n            final Object realKey = lowerCaseMap.get(key.toString().toLowerCase(Locale.ROOT));\n            return super.containsKey(realKey);\n            // Possible optimization here:\n            // Since the lowerCaseMap contains a mapping for all the keys,\n            // we could just do this:\n            // return lowerCaseMap.containsKey(key.toString().toLowerCase());\n        }", "signature": "@Override\n        public boolean containsKey(final Object key)"}, {"syntax_pass": true, "original_string": "        @Override\n        public Object get(final Object key) {\n            final Object realKey = lowerCaseMap.get(key.toString().toLowerCase(Locale.ROOT));\n            return super.get(realKey);\n        }", "docstring": " {@inheritDoc}", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object", "classes": []}, "name": "get", "params": [{"name": "key", "type": "Object"}], "body": "                                            {\n            final Object realKey = lowerCaseMap.get(key.toString().toLowerCase(Locale.ROOT));\n            return super.get(realKey);\n        }", "signature": "@Override\n        public Object get(final Object key)"}, {"syntax_pass": true, "original_string": "        @Override\n        public Object put(final String key, final Object value) {\n            /*\n             * In order to keep the map and lowerCaseMap synchronized,\n             * we have to remove the old mapping before putting the\n             * new one. Indeed, oldKey and key are not necessarily equals.\n             * (That's why we call super.remove(oldKey) and not just\n             * super.put(key, value))\n             */\n            final Object oldKey = lowerCaseMap.put(key.toLowerCase(Locale.ROOT), key);\n            final Object oldValue = super.remove(oldKey);\n            super.put(key, value);\n            return oldValue;\n        }", "docstring": " {@inheritDoc}", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object", "classes": []}, "name": "put", "params": [{"name": "key", "type": "String"}, {"name": "value", "type": "Object"}], "body": "                                                                {\n            /*\n             * In order to keep the map and lowerCaseMap synchronized,\n             * we have to remove the old mapping before putting the\n             * new one. Indeed, oldKey and key are not necessarily equals.\n             * (That's why we call super.remove(oldKey) and not just\n             * super.put(key, value))\n             */\n            final Object oldKey = lowerCaseMap.put(key.toLowerCase(Locale.ROOT), key);\n            final Object oldValue = super.remove(oldKey);\n            super.put(key, value);\n            return oldValue;\n        }", "signature": "@Override\n        public Object put(final String key, final Object value)"}, {"syntax_pass": true, "original_string": "        @Override\n        public void putAll(final Map<? extends String, ?> m) {\n            m.forEach(this::put);\n        }", "docstring": " {@inheritDoc}", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "putAll", "params": [{"name": "m", "type": "Map<? extends String, ?>"}], "body": "                                                             {\n            m.forEach(this::put);\n        }", "signature": "@Override\n        public void putAll(final Map<? extends String, ?> m)"}, {"syntax_pass": true, "original_string": "        @Override\n        public Object remove(final Object key) {\n            final Object realKey = lowerCaseMap.remove(key.toString().toLowerCase(Locale.ROOT));\n            return super.remove(realKey);\n        }", "docstring": " {@inheritDoc}", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object", "classes": []}, "name": "remove", "params": [{"name": "key", "type": "Object"}], "body": "                                               {\n            final Object realKey = lowerCaseMap.remove(key.toString().toLowerCase(Locale.ROOT));\n            return super.remove(realKey);\n        }", "signature": "@Override\n        public Object remove(final Object key)"}]}]}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    protected static Map<String, Object> createCaseInsensitiveHashMap(final int cols) {\n        return new CaseInsensitiveHashMap(cols);\n    }", "docstring": "", "attributes": {"modifiers": "protected static", "marker_annotations": [], "non_marker_annotations": ["protected", "static"], "comments": [], "return_type": "Map<String, Object>", "classes": []}, "name": "createCaseInsensitiveHashMap", "params": [{"name": "cols", "type": "int"}], "body": "                                                                                      {\n        return new CaseInsensitiveHashMap(cols);\n    }", "signature": "protected static Map<String, Object> createCaseInsensitiveHashMap(final int cols)"}, {"syntax_pass": true, "original_string": "    @Deprecated\n    public static BasicRowProcessor instance() {\n        return INSTANCE;\n    }", "docstring": "\nReturns the Singleton instance of this class.\n\n@return The single instance of this class.\n@deprecated Create instances with the constructors instead.  This will\nbe removed in 2.0.\n", "attributes": {"modifiers": "@Deprecated\n    public static", "marker_annotations": ["@Deprecated"], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "BasicRowProcessor", "classes": []}, "name": "instance", "params": [], "body": "                                               {\n        return INSTANCE;\n    }", "signature": "@Deprecated\n    public static BasicRowProcessor instance()"}, {"syntax_pass": true, "original_string": "    public BasicRowProcessor() {\n        this(DEFAULT_CONVERTER);\n    }", "docstring": "\nBasicRowProcessor constructor.  Bean processing defaults to a\nBeanProcessor instance.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "BasicRowProcessor", "params": [], "body": "                               {\n        this(DEFAULT_CONVERTER);\n    }", "signature": "public BasicRowProcessor()"}, {"syntax_pass": true, "original_string": "    public BasicRowProcessor(final BeanProcessor convert) {\n        this.convert = convert;\n    }", "docstring": "\nBasicRowProcessor constructor.\n@param convert The BeanProcessor to use when converting columns to\nbean properties.\n@since 1.1\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "BasicRowProcessor", "params": [{"name": "convert", "type": "BeanProcessor"}], "body": "                                                          {\n        this.convert = convert;\n    }", "signature": "public BasicRowProcessor(final BeanProcessor convert)"}, {"syntax_pass": true, "original_string": "    @Override\n    public Object[] toArray(final ResultSet resultSet) throws SQLException {\n        final ResultSetMetaData meta = resultSet.getMetaData();\n        final int cols = meta.getColumnCount();\n        final Object[] result = new Object[cols];\n\n        for (int i = 0; i < cols; i++) {\n            result[i] = resultSet.getObject(i + 1);\n        }\n\n        return result;\n    }", "docstring": "\nConvert a {@code ResultSet} row into an {@code Object[]}.\nThis implementation copies column values into the array in the same\norder they're returned from the {@code ResultSet}.  Array elements\nwill be set to {@code null} if the column was SQL NULL.\n\n@see org.apache.commons.dbutils.RowProcessor#toArray(java.sql.ResultSet)\n@param resultSet ResultSet that supplies the array data\n@throws SQLException if a database access error occurs\n@return the newly created array\n", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object[]", "classes": []}, "name": "toArray", "params": [{"name": "resultSet", "type": "ResultSet"}], "body": "                                                                           {\n        final ResultSetMetaData meta = resultSet.getMetaData();\n        final int cols = meta.getColumnCount();\n        final Object[] result = new Object[cols];\n\n        for (int i = 0; i < cols; i++) {\n            result[i] = resultSet.getObject(i + 1);\n        }\n\n        return result;\n    }", "signature": "@Override\n    public Object[] toArray(final ResultSet resultSet)"}, {"syntax_pass": true, "original_string": "    @Override\n    public <T> T toBean(final ResultSet resultSet, final Class<? extends T> type) throws SQLException {\n        return this.convert.toBean(resultSet, type);\n    }", "docstring": "\nConvert a {@code ResultSet} row into a JavaBean.  This\nimplementation delegates to a BeanProcessor instance.\n@see org.apache.commons.dbutils.RowProcessor#toBean(java.sql.ResultSet, Class)\n@see org.apache.commons.dbutils.BeanProcessor#toBean(java.sql.ResultSet, Class)\n@param <T> The type of bean to create\n@param resultSet ResultSet that supplies the bean data\n@param type Class from which to create the bean instance\n@throws SQLException if a database access error occurs\n@return the newly created bean\n", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "T", "classes": []}, "name": "toBean", "params": [{"name": "resultSet", "type": "ResultSet"}, {"name": "type", "type": "Class<? extends T>"}], "body": "                                                                                                      {\n        return this.convert.toBean(resultSet, type);\n    }", "signature": "@Override\n    public <T> T toBean(final ResultSet resultSet, final Class<? extends T> type)"}, {"syntax_pass": true, "original_string": "    @Override\n    public <T> List<T> toBeanList(final ResultSet resultSet, final Class<? extends T> type) throws SQLException {\n        return this.convert.toBeanList(resultSet, type);\n    }", "docstring": "\nConvert a {@code ResultSet} into a {@code List} of JavaBeans.\nThis implementation delegates to a BeanProcessor instance.\n@see org.apache.commons.dbutils.RowProcessor#toBeanList(java.sql.ResultSet, Class)\n@see org.apache.commons.dbutils.BeanProcessor#toBeanList(java.sql.ResultSet, Class)\n@param <T> The type of bean to create\n@param resultSet ResultSet that supplies the bean data\n@param type Class from which to create the bean instance\n@throws SQLException if a database access error occurs\n@return A {@code List} of beans with the given type in the order\nthey were returned by the {@code ResultSet}.\n", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<T>", "classes": []}, "name": "toBeanList", "params": [{"name": "resultSet", "type": "ResultSet"}, {"name": "type", "type": "Class<? extends T>"}], "body": "                                                                                                                {\n        return this.convert.toBeanList(resultSet, type);\n    }", "signature": "@Override\n    public <T> List<T> toBeanList(final ResultSet resultSet, final Class<? extends T> type)"}, {"syntax_pass": true, "original_string": "    @Override\n    public Map<String, Object> toMap(final ResultSet resultSet) throws SQLException {\n        final ResultSetMetaData rsmd = resultSet.getMetaData();\n        final int cols = rsmd.getColumnCount();\n        final Map<String, Object> result = createCaseInsensitiveHashMap(cols);\n\n        for (int i = 1; i <= cols; i++) {\n            String propKey = rsmd.getColumnLabel(i);\n            if (null == propKey || 0 == propKey.length()) {\n              propKey = rsmd.getColumnName(i);\n            }\n            if (null == propKey || 0 == propKey.length()) {\n              // The column index can't be null\n              propKey = Integer.toString(i);\n            }\n            result.put(propKey, resultSet.getObject(i));\n        }\n\n        return result;\n    }", "docstring": "\nConvert a {@code ResultSet} row into a {@code Map}.\n\n<p>\nThis implementation returns a {@code Map} with case insensitive column names as keys. Calls to\n{@code map.get(\"COL\")} and {@code map.get(\"col\")} return the same value. Furthermore this implementation\nwill return an ordered map, that preserves the ordering of the columns in the ResultSet, so that iterating over\nthe entry set of the returned map will return the first column of the ResultSet, then the second and so forth.\n</p>\n\n@param resultSet ResultSet that supplies the map data\n@return the newly created Map\n@throws SQLException if a database access error occurs\n@see org.apache.commons.dbutils.RowProcessor#toMap(java.sql.ResultSet)\n", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map<String, Object>", "classes": []}, "name": "toMap", "params": [{"name": "resultSet", "type": "ResultSet"}], "body": "                                                                                    {\n        final ResultSetMetaData rsmd = resultSet.getMetaData();\n        final int cols = rsmd.getColumnCount();\n        final Map<String, Object> result = createCaseInsensitiveHashMap(cols);\n\n        for (int i = 1; i <= cols; i++) {\n            String propKey = rsmd.getColumnLabel(i);\n            if (null == propKey || 0 == propKey.length()) {\n              propKey = rsmd.getColumnName(i);\n            }\n            if (null == propKey || 0 == propKey.length()) {\n              // The column index can't be null\n              propKey = Integer.toString(i);\n            }\n            result.put(propKey, resultSet.getObject(i));\n        }\n\n        return result;\n    }", "signature": "@Override\n    public Map<String, Object> toMap(final ResultSet resultSet)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/apache/commons/dbutils/GenerousBeanProcessor.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils;\n\nimport java.beans.PropertyDescriptor;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.util.Arrays;\n\n/**\n * Provides generous name matching (e.g. underscore-aware) from DB\n * columns to Java Bean properties.\n *\n * @since 1.6\n */\npublic class GenerousBeanProcessor extends BeanProcessor {\n\n    /**\n     * Default constructor.\n     */\n    public GenerousBeanProcessor() {\n    }\n\n    @Override\n    protected int[] mapColumnsToProperties(final ResultSetMetaData rsmd,\n            final PropertyDescriptor[] props) throws SQLException {\n\n        final int cols = rsmd.getColumnCount();\n        final int[] columnToProperty = new int[cols + 1];\n        Arrays.fill(columnToProperty, PROPERTY_NOT_FOUND);\n\n        for (int col = 1; col <= cols; col++) {\n            String columnName = rsmd.getColumnLabel(col);\n\n            if (null == columnName || 0 == columnName.length()) {\n                columnName = rsmd.getColumnName(col);\n            }\n\n            final String generousColumnName = columnName\n                    .replace(\"_\", \"\")   // more idiomatic to Java\n                    .replace(\" \", \"\");  // can't have spaces in property names\n\n            for (int i = 0; i < props.length; i++) {\n                final String propName = props[i].getName();\n\n                // see if either the column name, or the generous one matches\n                if (columnName.equalsIgnoreCase(propName) ||\n                        generousColumnName.equalsIgnoreCase(propName)) {\n                    columnToProperty[col] = i;\n                    break;\n                }\n            }\n        }\n\n        return columnToProperty;\n    }\n\n}\n", "file_hash": "51c4e224cbb839ebbe778674f0995faf446a046386fa4e5817deb9541d8b5432", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils;", "import java.beans.PropertyDescriptor;", "import java.sql.ResultSetMetaData;", "import java.sql.SQLException;", "import java.util.Arrays;"], "methods": [], "classes": [{"original_string": "public class GenerousBeanProcessor extends BeanProcessor {\n\n    /**\n     * Default constructor.\n     */\n    public GenerousBeanProcessor() {\n    }\n\n    @Override\n    protected int[] mapColumnsToProperties(final ResultSetMetaData rsmd,\n            final PropertyDescriptor[] props) throws SQLException {\n\n        final int cols = rsmd.getColumnCount();\n        final int[] columnToProperty = new int[cols + 1];\n        Arrays.fill(columnToProperty, PROPERTY_NOT_FOUND);\n\n        for (int col = 1; col <= cols; col++) {\n            String columnName = rsmd.getColumnLabel(col);\n\n            if (null == columnName || 0 == columnName.length()) {\n                columnName = rsmd.getColumnName(col);\n            }\n\n            final String generousColumnName = columnName\n                    .replace(\"_\", \"\")   // more idiomatic to Java\n                    .replace(\" \", \"\");  // can't have spaces in property names\n\n            for (int i = 0; i < props.length; i++) {\n                final String propName = props[i].getName();\n\n                // see if either the column name, or the generous one matches\n                if (columnName.equalsIgnoreCase(propName) ||\n                        generousColumnName.equalsIgnoreCase(propName)) {\n                    columnToProperty[col] = i;\n                    break;\n                }\n            }\n        }\n\n        return columnToProperty;\n    }\n\n}", "definition": "public class GenerousBeanProcessor extends BeanProcessor", "class_docstring": "\nProvides generous name matching (e.g. underscore-aware) from DB\ncolumns to Java Bean properties.\n\n@since 1.6\n", "name": "GenerousBeanProcessor", "super_interfaces": [], "superclasses": "BeanProcessor", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public GenerousBeanProcessor() {\n    }", "docstring": "\nDefault constructor.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "GenerousBeanProcessor", "params": [], "body": "                                   {\n    }", "signature": "public GenerousBeanProcessor()"}, {"syntax_pass": true, "original_string": "    @Override\n    protected int[] mapColumnsToProperties(final ResultSetMetaData rsmd,\n            final PropertyDescriptor[] props) throws SQLException {\n\n        final int cols = rsmd.getColumnCount();\n        final int[] columnToProperty = new int[cols + 1];\n        Arrays.fill(columnToProperty, PROPERTY_NOT_FOUND);\n\n        for (int col = 1; col <= cols; col++) {\n            String columnName = rsmd.getColumnLabel(col);\n\n            if (null == columnName || 0 == columnName.length()) {\n                columnName = rsmd.getColumnName(col);\n            }\n\n            final String generousColumnName = columnName\n                    .replace(\"_\", \"\")   // more idiomatic to Java\n                    .replace(\" \", \"\");  // can't have spaces in property names\n\n            for (int i = 0; i < props.length; i++) {\n                final String propName = props[i].getName();\n\n                // see if either the column name, or the generous one matches\n                if (columnName.equalsIgnoreCase(propName) ||\n                        generousColumnName.equalsIgnoreCase(propName)) {\n                    columnToProperty[col] = i;\n                    break;\n                }\n            }\n        }\n\n        return columnToProperty;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "int[]", "classes": []}, "name": "mapColumnsToProperties", "params": [{"name": "rsmd", "type": "ResultSetMetaData"}, {"name": "props", "type": "PropertyDescriptor[]"}], "body": "                                                                  {\n\n        final int cols = rsmd.getColumnCount();\n        final int[] columnToProperty = new int[cols + 1];\n        Arrays.fill(columnToProperty, PROPERTY_NOT_FOUND);\n\n        for (int col = 1; col <= cols; col++) {\n            String columnName = rsmd.getColumnLabel(col);\n\n            if (null == columnName || 0 == columnName.length()) {\n                columnName = rsmd.getColumnName(col);\n            }\n\n            final String generousColumnName = columnName\n                    .replace(\"_\", \"\")   // more idiomatic to Java\n                    .replace(\" \", \"\");  // can't have spaces in property names\n\n            for (int i = 0; i < props.length; i++) {\n                final String propName = props[i].getName();\n\n                // see if either the column name, or the generous one matches\n                if (columnName.equalsIgnoreCase(propName) ||\n                        generousColumnName.equalsIgnoreCase(propName)) {\n                    columnToProperty[col] = i;\n                    break;\n                }\n            }\n        }\n\n        return columnToProperty;\n    }", "signature": "@Override\n    protected int[] mapColumnsToProperties(final ResultSetMetaData rsmd,\n            final PropertyDescriptor[] props)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/apache/commons/dbutils/BeanProcessor.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.ServiceLoader;\n\n/**\n * <p>\n * {@code BeanProcessor} matches column names to bean property names\n * and converts {@code ResultSet} columns into objects for those bean\n * properties.  Subclasses should override the methods in the processing chain\n * to customize behavior.\n * </p>\n *\n * <p>\n * This class is thread-safe.\n * </p>\n *\n * @see BasicRowProcessor\n *\n * @since 1.1\n */\npublic class BeanProcessor {\n\n    /**\n     * Special array value used by {@code mapColumnsToProperties} that\n     * indicates there is no bean property that matches a column from a\n     * {@code ResultSet}.\n     */\n    protected static final int PROPERTY_NOT_FOUND = -1;\n\n    /**\n     * Set a bean's primitive properties to these defaults when SQL NULL\n     * is returned.  These are the same as the defaults that ResultSet get*\n     * methods return in the event of a NULL column.\n     */\n    private static final Map<Class<?>, Object> PRIMITIVE_DEFAULTS = new HashMap<>();\n\n    private static final List<ColumnHandler<?>> COLUMN_HANDLERS = new ArrayList<>();\n\n    private static final List<PropertyHandler> PROPERTY_HANDLERS = new ArrayList<>();\n\n    static {\n        PRIMITIVE_DEFAULTS.put(Integer.TYPE, Integer.valueOf(0));\n        PRIMITIVE_DEFAULTS.put(Short.TYPE, Short.valueOf((short) 0));\n        PRIMITIVE_DEFAULTS.put(Byte.TYPE, Byte.valueOf((byte) 0));\n        PRIMITIVE_DEFAULTS.put(Float.TYPE, Float.valueOf(0f));\n        PRIMITIVE_DEFAULTS.put(Double.TYPE, Double.valueOf(0d));\n        PRIMITIVE_DEFAULTS.put(Long.TYPE, Long.valueOf(0L));\n        PRIMITIVE_DEFAULTS.put(Boolean.TYPE, Boolean.FALSE);\n        PRIMITIVE_DEFAULTS.put(Character.TYPE, Character.valueOf((char) 0));\n\n        // Use a ServiceLoader to find implementations\n        ServiceLoader.load(ColumnHandler.class).forEach(COLUMN_HANDLERS::add);\n\n        // Use a ServiceLoader to find implementations\n        ServiceLoader.load(PropertyHandler.class).forEach(PROPERTY_HANDLERS::add);\n    }\n\n    /**\n     * ResultSet column to bean property name overrides.\n     */\n    private final Map<String, String> columnToPropertyOverrides;\n\n    /**\n     * Constructor for BeanProcessor.\n     */\n    public BeanProcessor() {\n        this(new HashMap<>());\n    }\n\n    /**\n     * Constructor for BeanProcessor configured with column to property name overrides.\n     *\n     * @param columnToPropertyOverrides ResultSet column to bean property name overrides\n     * @since 1.5\n     */\n    public BeanProcessor(final Map<String, String> columnToPropertyOverrides) {\n        if (columnToPropertyOverrides == null) {\n            throw new IllegalArgumentException(\"columnToPropertyOverrides map cannot be null\");\n        }\n        this.columnToPropertyOverrides = columnToPropertyOverrides;\n    }\n\n    /**\n     * Calls the setter method on the target object for the given property.\n     * If no setter method exists for the property, this method does nothing.\n     * @param target The object to set the property on.\n     * @param prop The property to set.\n     * @param value The value to pass into the setter.\n     * @throws SQLException if an error occurs setting the property.\n     */\n    private void callSetter(final Object target, final PropertyDescriptor prop, Object value)\n            throws SQLException {\n\n        final Method setter = getWriteMethod(target, prop, value);\n\n        if (setter == null || setter.getParameterTypes().length != 1) {\n            return;\n        }\n\n        try {\n            final Class<?> firstParam = setter.getParameterTypes()[0];\n            for (final PropertyHandler handler : PROPERTY_HANDLERS) {\n                if (handler.match(firstParam, value)) {\n                    value = handler.apply(firstParam, value);\n                    break;\n                }\n            }\n\n            // Don't call setter if the value object isn't the right type\n            if (!isCompatibleType(value, firstParam)) {\n                throw new SQLException(\n                        \"Cannot set \" + prop.getName() + \": incompatible types, cannot convert \" + value.getClass().getName() + \" to \" + firstParam.getName());\n                // value cannot be null here because isCompatibleType allows null\n            }\n            setter.invoke(target, value);\n\n        } catch (final IllegalArgumentException | IllegalAccessException | InvocationTargetException e) {\n            throw new SQLException(\"Cannot set \" + prop.getName() + \": \" + e.getMessage());\n        }\n    }\n\n    /**\n     * Creates a new object and initializes its fields from the ResultSet.\n     * @param <T> The type of bean to create\n     * @param resultSet The result set.\n     * @param type The bean type (the return type of the object).\n     * @param props The property descriptors.\n     * @param columnToProperty The column indices in the result set.\n     * @return An initialized object.\n     * @throws SQLException if a database error occurs.\n     */\n    private <T> T createBean(final ResultSet resultSet, final Class<T> type, final PropertyDescriptor[] props, final int[] columnToProperty)\n            throws SQLException {\n        return populateBean(resultSet, this.newInstance(type), props, columnToProperty);\n    }\n\n    /** Does nothing. */\n    @Override\n    protected final void finalize() {\n        // SpotBugs CT_CONSTRUCTOR_THROW\n    }\n\n    /**\n     * Gets the write method to use when setting {@code value} to the {@code target}.\n     *\n     * @param target Object where the write method will be called.\n     * @param prop   BeanUtils information.\n     * @param value  The value that will be passed to the write method.\n     * @return The {@link java.lang.reflect.Method} to call on {@code target} to write {@code value} or {@code null} if\n     *         there is no suitable write method.\n     */\n    protected Method getWriteMethod(final Object target, final PropertyDescriptor prop, final Object value) {\n        return prop.getWriteMethod();\n    }\n\n    /**\n     * ResultSet.getObject() returns an Integer object for an INT column.  The\n     * setter method for the property might take an Integer or a primitive int.\n     * This method returns true if the value can be successfully passed into\n     * the setter method.  Remember, Method.invoke() handles the unwrapping\n     * of Integer into an int.\n     *\n     * @param value The value to be passed into the setter method.\n     * @param type The setter's parameter type (non-null)\n     * @return boolean True if the value is compatible (null => true)\n     */\n    private boolean isCompatibleType(final Object value, final Class<?> type) {\n        // Do object check first, then primitives\n        return value == null || type.isInstance(value) || matchesPrimitive(type, value.getClass());\n    }\n\n    /**\n     * The positions in the returned array represent column numbers.  The\n     * values stored at each position represent the index in the\n     * {@code PropertyDescriptor[]} for the bean property that matches\n     * the column name.  If no bean property was found for a column, the\n     * position is set to {@code PROPERTY_NOT_FOUND}.\n     *\n     * @param rsmd The {@code ResultSetMetaData} containing column\n     * information.\n     *\n     * @param props The bean property descriptors.\n     *\n     * @throws SQLException if a database access error occurs\n     *\n     * @return An int[] with column index to property index mappings.  The 0th\n     * element is meaningless because JDBC column indexing starts at 1.\n     */\n    protected int[] mapColumnsToProperties(final ResultSetMetaData rsmd,\n            final PropertyDescriptor[] props) throws SQLException {\n\n        final int cols = rsmd.getColumnCount();\n        final int[] columnToProperty = new int[cols + 1];\n        Arrays.fill(columnToProperty, PROPERTY_NOT_FOUND);\n\n        for (int col = 1; col <= cols; col++) {\n            String columnName = rsmd.getColumnLabel(col);\n            if (null == columnName || 0 == columnName.length()) {\n              columnName = rsmd.getColumnName(col);\n            }\n            String propertyName = columnToPropertyOverrides.get(columnName);\n            if (propertyName == null) {\n                propertyName = columnName;\n            }\n            if (propertyName == null) {\n                propertyName = Integer.toString(col);\n            }\n\n            for (int i = 0; i < props.length; i++) {\n                final PropertyDescriptor prop = props[i];\n                final Method reader = prop.getReadMethod();\n\n                // Check for @Column annotations as explicit marks\n                final Column column;\n                if (reader != null) {\n                    column = reader.getAnnotation(Column.class);\n                } else {\n                    column = null;\n                }\n\n                final String propertyColumnName;\n                if (column != null) {\n                    propertyColumnName = column.name();\n                } else {\n                    propertyColumnName = prop.getName();\n                }\n                if (propertyName.equalsIgnoreCase(propertyColumnName)) {\n                    columnToProperty[col] = i;\n                    break;\n                }\n            }\n        }\n\n        return columnToProperty;\n    }\n\n    /**\n     * Check whether a value is of the same primitive type as {@code targetType}.\n     *\n     * @param targetType The primitive type to target.\n     * @param valueType The value to match to the primitive type.\n     * @return Whether {@code valueType} can be coerced (e.g. autoboxed) into {@code targetType}.\n     */\n    private boolean matchesPrimitive(final Class<?> targetType, final Class<?> valueType) {\n        if (!targetType.isPrimitive()) {\n            return false;\n        }\n\n        try {\n            // see if there is a \"TYPE\" field.  This is present for primitive wrappers.\n            final Field typeField = valueType.getField(\"TYPE\");\n            final Object primitiveValueType = typeField.get(valueType);\n\n            if (targetType == primitiveValueType) {\n                return true;\n            }\n        } catch (final NoSuchFieldException | IllegalAccessException ignored) {\n            // an inaccessible TYPE field is a good sign that we're not working with a primitive wrapper.\n            // nothing to do.  we can't match for compatibility\n        }\n        return false;\n    }\n\n    /**\n     * Factory method that returns a new instance of the given Class.  This\n     * is called at the start of the bean creation process and may be\n     * overridden to provide custom behavior like returning a cached bean\n     * instance.\n     * @param <T> The type of object to create\n     * @param c The Class to create an object from.\n     * @return A newly created object of the Class.\n     * @throws SQLException if creation failed.\n     */\n    protected <T> T newInstance(final Class<T> c) throws SQLException {\n        try {\n            return c.getDeclaredConstructor().newInstance();\n\n        } catch (final IllegalAccessException | InstantiationException | InvocationTargetException |\n            NoSuchMethodException e) {\n            throw new SQLException(\"Cannot create \" + c.getName() + \": \" + e.getMessage());\n        }\n    }\n\n    /**\n     * Initializes the fields of the provided bean from the ResultSet.\n     * @param <T> The type of bean\n     * @param resultSet The result set.\n     * @param bean The bean to be populated.\n     * @return An initialized object.\n     * @throws SQLException if a database error occurs.\n     */\n    public <T> T populateBean(final ResultSet resultSet, final T bean) throws SQLException {\n        final PropertyDescriptor[] props = propertyDescriptors(bean.getClass());\n        final ResultSetMetaData rsmd = resultSet.getMetaData();\n        final int[] columnToProperty = mapColumnsToProperties(rsmd, props);\n\n        return populateBean(resultSet, bean, props, columnToProperty);\n    }\n\n    /**\n     * This method populates a bean from the ResultSet based upon the underlying meta-data.\n     *\n     * @param <T> The type of bean\n     * @param resultSet The result set.\n     * @param bean The bean to be populated.\n     * @param props The property descriptors.\n     * @param columnToProperty The column indices in the result set.\n     * @return An initialized object.\n     * @throws SQLException if a database error occurs.\n     */\n    private <T> T populateBean(final ResultSet resultSet, final T bean,\n            final PropertyDescriptor[] props, final int[] columnToProperty)\n            throws SQLException {\n\n        for (int i = 1; i < columnToProperty.length; i++) {\n\n            if (columnToProperty[i] == PROPERTY_NOT_FOUND) {\n                continue;\n            }\n\n            final PropertyDescriptor prop = props[columnToProperty[i]];\n            final Class<?> propType = prop.getPropertyType();\n\n            Object value = null;\n            if (propType != null) {\n                value = processColumn(resultSet, i, propType);\n\n                if (value == null && propType.isPrimitive()) {\n                    value = PRIMITIVE_DEFAULTS.get(propType);\n                }\n            }\n\n            callSetter(bean, prop, value);\n        }\n\n        return bean;\n    }\n\n    /**\n     * Convert a {@code ResultSet} column into an object.  Simple\n     * implementations could just call {@code rs.getObject(index)} while\n     * more complex implementations could perform type manipulation to match\n     * the column's type to the bean property type.\n     *\n     * <p>\n     * This implementation calls the appropriate {@code ResultSet} getter\n     * method for the given property type to perform the type conversion.  If\n     * the property type doesn't match one of the supported\n     * {@code ResultSet} types, {@code getObject} is called.\n     * </p>\n     *\n     * @param resultSet The {@code ResultSet} currently being processed.  It is\n     * positioned on a valid row before being passed into this method.\n     *\n     * @param index The current column index being processed.\n     *\n     * @param propType The bean property type that this column needs to be\n     * converted into.\n     *\n     * @throws SQLException if a database access error occurs\n     *\n     * @return The object from the {@code ResultSet} at the given column\n     * index after optional type processing or {@code null} if the column\n     * value was SQL NULL.\n     */\n    protected Object processColumn(final ResultSet resultSet, final int index, final Class<?> propType)\n        throws SQLException {\n\n        Object retval = resultSet.getObject(index);\n\n        if ( !propType.isPrimitive() && retval == null ) {\n            return null;\n        }\n\n        for (final ColumnHandler<?> handler : COLUMN_HANDLERS) {\n            if (handler.match(propType)) {\n                retval = handler.apply(resultSet, index);\n                break;\n            }\n        }\n\n        return retval;\n\n    }\n\n    /**\n     * Returns a PropertyDescriptor[] for the given Class.\n     *\n     * @param c The Class to retrieve PropertyDescriptors for.\n     * @return A PropertyDescriptor[] describing the Class.\n     * @throws SQLException if introspection failed.\n     */\n    private PropertyDescriptor[] propertyDescriptors(final Class<?> c)\n        throws SQLException {\n        // Introspector caches BeanInfo classes for better performance\n        BeanInfo beanInfo = null;\n        try {\n            beanInfo = Introspector.getBeanInfo(c);\n\n        } catch (final IntrospectionException e) {\n            throw new SQLException(\n                \"Bean introspection failed: \" + e.getMessage());\n        }\n\n        return beanInfo.getPropertyDescriptors();\n    }\n\n    /**\n     * Convert a {@code ResultSet} row into a JavaBean.  This\n     * implementation uses reflection and {@code BeanInfo} classes to\n     * match column names to bean property names.  Properties are matched to\n     * columns based on several factors:\n     * &lt;br/&gt;\n     * &lt;ol&gt;\n     *     &lt;li&gt;\n     *     The class has a writable property with the same name as a column.\n     *     The name comparison is case insensitive.\n     *     &lt;/li&gt;\n     *\n     *     &lt;li&gt;\n     *     The column type can be converted to the property's set method\n     *     parameter type with a ResultSet.get* method.  If the conversion fails\n     *     (ie. the property was an int and the column was a Timestamp) an\n     *     SQLException is thrown.\n     *     &lt;/li&gt;\n     * &lt;/ol&gt;\n     *\n     * &lt;p&gt;\n     * Primitive bean properties are set to their defaults when SQL NULL is\n     * returned from the {@code ResultSet}.  Numeric fields are set to 0\n     * and booleans are set to false.  Object bean properties are set to\n     * {@code null} when SQL NULL is returned.  This is the same behavior\n     * as the {@code ResultSet} get* methods.\n     * &lt;/p&gt;\n     * @param <T> The type of bean to create\n     * @param rs ResultSet that supplies the bean data\n     * @param type Class from which to create the bean instance\n     * @throws SQLException if a database access error occurs\n     * @return the newly created bean\n     */\n    public <T> T toBean(final ResultSet rs, final Class<? extends T> type) throws SQLException {\n        final T bean = this.newInstance(type);\n        return this.populateBean(rs, bean);\n    }\n\n    /**\n     * Convert a {@code ResultSet} into a {@code List} of JavaBeans.\n     * This implementation uses reflection and {@code BeanInfo} classes to\n     * match column names to bean property names. Properties are matched to\n     * columns based on several factors:\n     * &lt;br/&gt;\n     * &lt;ol&gt;\n     *     &lt;li&gt;\n     *     The class has a writable property with the same name as a column.\n     *     The name comparison is case insensitive.\n     *     &lt;/li&gt;\n     *\n     *     &lt;li&gt;\n     *     The column type can be converted to the property's set method\n     *     parameter type with a ResultSet.get* method.  If the conversion fails\n     *     (ie. the property was an int and the column was a Timestamp) an\n     *     SQLException is thrown.\n     *     &lt;/li&gt;\n     * &lt;/ol&gt;\n     *\n     * <p>\n     * Primitive bean properties are set to their defaults when SQL NULL is\n     * returned from the {@code ResultSet}.  Numeric fields are set to 0\n     * and booleans are set to false.  Object bean properties are set to\n     * {@code null} when SQL NULL is returned.  This is the same behavior\n     * as the {@code ResultSet} get* methods.\n     * &lt;/p&gt;\n     * @param <T> The type of bean to create\n     * @param resultSet ResultSet that supplies the bean data\n     * @param type Class from which to create the bean instance\n     * @throws SQLException if a database access error occurs\n     * @return the newly created List of beans\n     */\n    public <T> List<T> toBeanList(final ResultSet resultSet, final Class<? extends T> type) throws SQLException {\n        final List<T> results = new ArrayList<>();\n        if (!resultSet.next()) {\n            return results;\n        }\n        final PropertyDescriptor[] props = propertyDescriptors(type);\n        final ResultSetMetaData rsmd = resultSet.getMetaData();\n        final int[] columnToProperty = mapColumnsToProperties(rsmd, props);\n        do {\n            results.add(this.createBean(resultSet, type, props, columnToProperty));\n        } while (resultSet.next()); // NOPMD False positive CheckResultSet\n        return results;\n    }\n\n}\n", "file_hash": "dd2967d8aaa8bc5b67bd957ba7eb08e929ac42aeafc89ddc43fa9c2706c2863a", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils;", "import java.beans.BeanInfo;", "import java.beans.IntrospectionException;", "import java.beans.Introspector;", "import java.beans.PropertyDescriptor;", "import java.lang.reflect.Field;", "import java.lang.reflect.InvocationTargetException;", "import java.lang.reflect.Method;", "import java.sql.ResultSet;", "import java.sql.ResultSetMetaData;", "import java.sql.SQLException;", "import java.util.ArrayList;", "import java.util.Arrays;", "import java.util.HashMap;", "import java.util.List;", "import java.util.Map;", "import java.util.ServiceLoader;"], "methods": [], "classes": [{"original_string": "public class BeanProcessor {\n\n    /**\n     * Special array value used by {@code mapColumnsToProperties} that\n     * indicates there is no bean property that matches a column from a\n     * {@code ResultSet}.\n     */\n    protected static final int PROPERTY_NOT_FOUND = -1;\n\n    /**\n     * Set a bean's primitive properties to these defaults when SQL NULL\n     * is returned.  These are the same as the defaults that ResultSet get*\n     * methods return in the event of a NULL column.\n     */\n    private static final Map<Class<?>, Object> PRIMITIVE_DEFAULTS = new HashMap<>();\n\n    private static final List<ColumnHandler<?>> COLUMN_HANDLERS = new ArrayList<>();\n\n    private static final List<PropertyHandler> PROPERTY_HANDLERS = new ArrayList<>();\n\n    static {\n        PRIMITIVE_DEFAULTS.put(Integer.TYPE, Integer.valueOf(0));\n        PRIMITIVE_DEFAULTS.put(Short.TYPE, Short.valueOf((short) 0));\n        PRIMITIVE_DEFAULTS.put(Byte.TYPE, Byte.valueOf((byte) 0));\n        PRIMITIVE_DEFAULTS.put(Float.TYPE, Float.valueOf(0f));\n        PRIMITIVE_DEFAULTS.put(Double.TYPE, Double.valueOf(0d));\n        PRIMITIVE_DEFAULTS.put(Long.TYPE, Long.valueOf(0L));\n        PRIMITIVE_DEFAULTS.put(Boolean.TYPE, Boolean.FALSE);\n        PRIMITIVE_DEFAULTS.put(Character.TYPE, Character.valueOf((char) 0));\n\n        // Use a ServiceLoader to find implementations\n        ServiceLoader.load(ColumnHandler.class).forEach(COLUMN_HANDLERS::add);\n\n        // Use a ServiceLoader to find implementations\n        ServiceLoader.load(PropertyHandler.class).forEach(PROPERTY_HANDLERS::add);\n    }\n\n    /**\n     * ResultSet column to bean property name overrides.\n     */\n    private final Map<String, String> columnToPropertyOverrides;\n\n    /**\n     * Constructor for BeanProcessor.\n     */\n    public BeanProcessor() {\n        this(new HashMap<>());\n    }\n\n    /**\n     * Constructor for BeanProcessor configured with column to property name overrides.\n     *\n     * @param columnToPropertyOverrides ResultSet column to bean property name overrides\n     * @since 1.5\n     */\n    public BeanProcessor(final Map<String, String> columnToPropertyOverrides) {\n        if (columnToPropertyOverrides == null) {\n            throw new IllegalArgumentException(\"columnToPropertyOverrides map cannot be null\");\n        }\n        this.columnToPropertyOverrides = columnToPropertyOverrides;\n    }\n\n    /**\n     * Calls the setter method on the target object for the given property.\n     * If no setter method exists for the property, this method does nothing.\n     * @param target The object to set the property on.\n     * @param prop The property to set.\n     * @param value The value to pass into the setter.\n     * @throws SQLException if an error occurs setting the property.\n     */\n    private void callSetter(final Object target, final PropertyDescriptor prop, Object value)\n            throws SQLException {\n\n        final Method setter = getWriteMethod(target, prop, value);\n\n        if (setter == null || setter.getParameterTypes().length != 1) {\n            return;\n        }\n\n        try {\n            final Class<?> firstParam = setter.getParameterTypes()[0];\n            for (final PropertyHandler handler : PROPERTY_HANDLERS) {\n                if (handler.match(firstParam, value)) {\n                    value = handler.apply(firstParam, value);\n                    break;\n                }\n            }\n\n            // Don't call setter if the value object isn't the right type\n            if (!isCompatibleType(value, firstParam)) {\n                throw new SQLException(\n                        \"Cannot set \" + prop.getName() + \": incompatible types, cannot convert \" + value.getClass().getName() + \" to \" + firstParam.getName());\n                // value cannot be null here because isCompatibleType allows null\n            }\n            setter.invoke(target, value);\n\n        } catch (final IllegalArgumentException | IllegalAccessException | InvocationTargetException e) {\n            throw new SQLException(\"Cannot set \" + prop.getName() + \": \" + e.getMessage());\n        }\n    }\n\n    /**\n     * Creates a new object and initializes its fields from the ResultSet.\n     * @param <T> The type of bean to create\n     * @param resultSet The result set.\n     * @param type The bean type (the return type of the object).\n     * @param props The property descriptors.\n     * @param columnToProperty The column indices in the result set.\n     * @return An initialized object.\n     * @throws SQLException if a database error occurs.\n     */\n    private <T> T createBean(final ResultSet resultSet, final Class<T> type, final PropertyDescriptor[] props, final int[] columnToProperty)\n            throws SQLException {\n        return populateBean(resultSet, this.newInstance(type), props, columnToProperty);\n    }\n\n    /** Does nothing. */\n    @Override\n    protected final void finalize() {\n        // SpotBugs CT_CONSTRUCTOR_THROW\n    }\n\n    /**\n     * Gets the write method to use when setting {@code value} to the {@code target}.\n     *\n     * @param target Object where the write method will be called.\n     * @param prop   BeanUtils information.\n     * @param value  The value that will be passed to the write method.\n     * @return The {@link java.lang.reflect.Method} to call on {@code target} to write {@code value} or {@code null} if\n     *         there is no suitable write method.\n     */\n    protected Method getWriteMethod(final Object target, final PropertyDescriptor prop, final Object value) {\n        return prop.getWriteMethod();\n    }\n\n    /**\n     * ResultSet.getObject() returns an Integer object for an INT column.  The\n     * setter method for the property might take an Integer or a primitive int.\n     * This method returns true if the value can be successfully passed into\n     * the setter method.  Remember, Method.invoke() handles the unwrapping\n     * of Integer into an int.\n     *\n     * @param value The value to be passed into the setter method.\n     * @param type The setter's parameter type (non-null)\n     * @return boolean True if the value is compatible (null => true)\n     */\n    private boolean isCompatibleType(final Object value, final Class<?> type) {\n        // Do object check first, then primitives\n        return value == null || type.isInstance(value) || matchesPrimitive(type, value.getClass());\n    }\n\n    /**\n     * The positions in the returned array represent column numbers.  The\n     * values stored at each position represent the index in the\n     * {@code PropertyDescriptor[]} for the bean property that matches\n     * the column name.  If no bean property was found for a column, the\n     * position is set to {@code PROPERTY_NOT_FOUND}.\n     *\n     * @param rsmd The {@code ResultSetMetaData} containing column\n     * information.\n     *\n     * @param props The bean property descriptors.\n     *\n     * @throws SQLException if a database access error occurs\n     *\n     * @return An int[] with column index to property index mappings.  The 0th\n     * element is meaningless because JDBC column indexing starts at 1.\n     */\n    protected int[] mapColumnsToProperties(final ResultSetMetaData rsmd,\n            final PropertyDescriptor[] props) throws SQLException {\n\n        final int cols = rsmd.getColumnCount();\n        final int[] columnToProperty = new int[cols + 1];\n        Arrays.fill(columnToProperty, PROPERTY_NOT_FOUND);\n\n        for (int col = 1; col <= cols; col++) {\n            String columnName = rsmd.getColumnLabel(col);\n            if (null == columnName || 0 == columnName.length()) {\n              columnName = rsmd.getColumnName(col);\n            }\n            String propertyName = columnToPropertyOverrides.get(columnName);\n            if (propertyName == null) {\n                propertyName = columnName;\n            }\n            if (propertyName == null) {\n                propertyName = Integer.toString(col);\n            }\n\n            for (int i = 0; i < props.length; i++) {\n                final PropertyDescriptor prop = props[i];\n                final Method reader = prop.getReadMethod();\n\n                // Check for @Column annotations as explicit marks\n                final Column column;\n                if (reader != null) {\n                    column = reader.getAnnotation(Column.class);\n                } else {\n                    column = null;\n                }\n\n                final String propertyColumnName;\n                if (column != null) {\n                    propertyColumnName = column.name();\n                } else {\n                    propertyColumnName = prop.getName();\n                }\n                if (propertyName.equalsIgnoreCase(propertyColumnName)) {\n                    columnToProperty[col] = i;\n                    break;\n                }\n            }\n        }\n\n        return columnToProperty;\n    }\n\n    /**\n     * Check whether a value is of the same primitive type as {@code targetType}.\n     *\n     * @param targetType The primitive type to target.\n     * @param valueType The value to match to the primitive type.\n     * @return Whether {@code valueType} can be coerced (e.g. autoboxed) into {@code targetType}.\n     */\n    private boolean matchesPrimitive(final Class<?> targetType, final Class<?> valueType) {\n        if (!targetType.isPrimitive()) {\n            return false;\n        }\n\n        try {\n            // see if there is a \"TYPE\" field.  This is present for primitive wrappers.\n            final Field typeField = valueType.getField(\"TYPE\");\n            final Object primitiveValueType = typeField.get(valueType);\n\n            if (targetType == primitiveValueType) {\n                return true;\n            }\n        } catch (final NoSuchFieldException | IllegalAccessException ignored) {\n            // an inaccessible TYPE field is a good sign that we're not working with a primitive wrapper.\n            // nothing to do.  we can't match for compatibility\n        }\n        return false;\n    }\n\n    /**\n     * Factory method that returns a new instance of the given Class.  This\n     * is called at the start of the bean creation process and may be\n     * overridden to provide custom behavior like returning a cached bean\n     * instance.\n     * @param <T> The type of object to create\n     * @param c The Class to create an object from.\n     * @return A newly created object of the Class.\n     * @throws SQLException if creation failed.\n     */\n    protected <T> T newInstance(final Class<T> c) throws SQLException {\n        try {\n            return c.getDeclaredConstructor().newInstance();\n\n        } catch (final IllegalAccessException | InstantiationException | InvocationTargetException |\n            NoSuchMethodException e) {\n            throw new SQLException(\"Cannot create \" + c.getName() + \": \" + e.getMessage());\n        }\n    }\n\n    /**\n     * Initializes the fields of the provided bean from the ResultSet.\n     * @param <T> The type of bean\n     * @param resultSet The result set.\n     * @param bean The bean to be populated.\n     * @return An initialized object.\n     * @throws SQLException if a database error occurs.\n     */\n    public <T> T populateBean(final ResultSet resultSet, final T bean) throws SQLException {\n        final PropertyDescriptor[] props = propertyDescriptors(bean.getClass());\n        final ResultSetMetaData rsmd = resultSet.getMetaData();\n        final int[] columnToProperty = mapColumnsToProperties(rsmd, props);\n\n        return populateBean(resultSet, bean, props, columnToProperty);\n    }\n\n    /**\n     * This method populates a bean from the ResultSet based upon the underlying meta-data.\n     *\n     * @param <T> The type of bean\n     * @param resultSet The result set.\n     * @param bean The bean to be populated.\n     * @param props The property descriptors.\n     * @param columnToProperty The column indices in the result set.\n     * @return An initialized object.\n     * @throws SQLException if a database error occurs.\n     */\n    private <T> T populateBean(final ResultSet resultSet, final T bean,\n            final PropertyDescriptor[] props, final int[] columnToProperty)\n            throws SQLException {\n\n        for (int i = 1; i < columnToProperty.length; i++) {\n\n            if (columnToProperty[i] == PROPERTY_NOT_FOUND) {\n                continue;\n            }\n\n            final PropertyDescriptor prop = props[columnToProperty[i]];\n            final Class<?> propType = prop.getPropertyType();\n\n            Object value = null;\n            if (propType != null) {\n                value = processColumn(resultSet, i, propType);\n\n                if (value == null && propType.isPrimitive()) {\n                    value = PRIMITIVE_DEFAULTS.get(propType);\n                }\n            }\n\n            callSetter(bean, prop, value);\n        }\n\n        return bean;\n    }\n\n    /**\n     * Convert a {@code ResultSet} column into an object.  Simple\n     * implementations could just call {@code rs.getObject(index)} while\n     * more complex implementations could perform type manipulation to match\n     * the column's type to the bean property type.\n     *\n     * <p>\n     * This implementation calls the appropriate {@code ResultSet} getter\n     * method for the given property type to perform the type conversion.  If\n     * the property type doesn't match one of the supported\n     * {@code ResultSet} types, {@code getObject} is called.\n     * </p>\n     *\n     * @param resultSet The {@code ResultSet} currently being processed.  It is\n     * positioned on a valid row before being passed into this method.\n     *\n     * @param index The current column index being processed.\n     *\n     * @param propType The bean property type that this column needs to be\n     * converted into.\n     *\n     * @throws SQLException if a database access error occurs\n     *\n     * @return The object from the {@code ResultSet} at the given column\n     * index after optional type processing or {@code null} if the column\n     * value was SQL NULL.\n     */\n    protected Object processColumn(final ResultSet resultSet, final int index, final Class<?> propType)\n        throws SQLException {\n\n        Object retval = resultSet.getObject(index);\n\n        if ( !propType.isPrimitive() && retval == null ) {\n            return null;\n        }\n\n        for (final ColumnHandler<?> handler : COLUMN_HANDLERS) {\n            if (handler.match(propType)) {\n                retval = handler.apply(resultSet, index);\n                break;\n            }\n        }\n\n        return retval;\n\n    }\n\n    /**\n     * Returns a PropertyDescriptor[] for the given Class.\n     *\n     * @param c The Class to retrieve PropertyDescriptors for.\n     * @return A PropertyDescriptor[] describing the Class.\n     * @throws SQLException if introspection failed.\n     */\n    private PropertyDescriptor[] propertyDescriptors(final Class<?> c)\n        throws SQLException {\n        // Introspector caches BeanInfo classes for better performance\n        BeanInfo beanInfo = null;\n        try {\n            beanInfo = Introspector.getBeanInfo(c);\n\n        } catch (final IntrospectionException e) {\n            throw new SQLException(\n                \"Bean introspection failed: \" + e.getMessage());\n        }\n\n        return beanInfo.getPropertyDescriptors();\n    }\n\n    /**\n     * Convert a {@code ResultSet} row into a JavaBean.  This\n     * implementation uses reflection and {@code BeanInfo} classes to\n     * match column names to bean property names.  Properties are matched to\n     * columns based on several factors:\n     * &lt;br/&gt;\n     * &lt;ol&gt;\n     *     &lt;li&gt;\n     *     The class has a writable property with the same name as a column.\n     *     The name comparison is case insensitive.\n     *     &lt;/li&gt;\n     *\n     *     &lt;li&gt;\n     *     The column type can be converted to the property's set method\n     *     parameter type with a ResultSet.get* method.  If the conversion fails\n     *     (ie. the property was an int and the column was a Timestamp) an\n     *     SQLException is thrown.\n     *     &lt;/li&gt;\n     * &lt;/ol&gt;\n     *\n     * &lt;p&gt;\n     * Primitive bean properties are set to their defaults when SQL NULL is\n     * returned from the {@code ResultSet}.  Numeric fields are set to 0\n     * and booleans are set to false.  Object bean properties are set to\n     * {@code null} when SQL NULL is returned.  This is the same behavior\n     * as the {@code ResultSet} get* methods.\n     * &lt;/p&gt;\n     * @param <T> The type of bean to create\n     * @param rs ResultSet that supplies the bean data\n     * @param type Class from which to create the bean instance\n     * @throws SQLException if a database access error occurs\n     * @return the newly created bean\n     */\n    public <T> T toBean(final ResultSet rs, final Class<? extends T> type) throws SQLException {\n        final T bean = this.newInstance(type);\n        return this.populateBean(rs, bean);\n    }\n\n    /**\n     * Convert a {@code ResultSet} into a {@code List} of JavaBeans.\n     * This implementation uses reflection and {@code BeanInfo} classes to\n     * match column names to bean property names. Properties are matched to\n     * columns based on several factors:\n     * &lt;br/&gt;\n     * &lt;ol&gt;\n     *     &lt;li&gt;\n     *     The class has a writable property with the same name as a column.\n     *     The name comparison is case insensitive.\n     *     &lt;/li&gt;\n     *\n     *     &lt;li&gt;\n     *     The column type can be converted to the property's set method\n     *     parameter type with a ResultSet.get* method.  If the conversion fails\n     *     (ie. the property was an int and the column was a Timestamp) an\n     *     SQLException is thrown.\n     *     &lt;/li&gt;\n     * &lt;/ol&gt;\n     *\n     * <p>\n     * Primitive bean properties are set to their defaults when SQL NULL is\n     * returned from the {@code ResultSet}.  Numeric fields are set to 0\n     * and booleans are set to false.  Object bean properties are set to\n     * {@code null} when SQL NULL is returned.  This is the same behavior\n     * as the {@code ResultSet} get* methods.\n     * &lt;/p&gt;\n     * @param <T> The type of bean to create\n     * @param resultSet ResultSet that supplies the bean data\n     * @param type Class from which to create the bean instance\n     * @throws SQLException if a database access error occurs\n     * @return the newly created List of beans\n     */\n    public <T> List<T> toBeanList(final ResultSet resultSet, final Class<? extends T> type) throws SQLException {\n        final List<T> results = new ArrayList<>();\n        if (!resultSet.next()) {\n            return results;\n        }\n        final PropertyDescriptor[] props = propertyDescriptors(type);\n        final ResultSetMetaData rsmd = resultSet.getMetaData();\n        final int[] columnToProperty = mapColumnsToProperties(rsmd, props);\n        do {\n            results.add(this.createBean(resultSet, type, props, columnToProperty));\n        } while (resultSet.next()); // NOPMD False positive CheckResultSet\n        return results;\n    }\n\n}", "definition": "public class BeanProcessor", "class_docstring": "\n<p>\n{@code BeanProcessor} matches column names to bean property names\nand converts {@code ResultSet} columns into objects for those bean\nproperties.  Subclasses should override the methods in the processing chain\nto customize behavior.\n</p>\n\n<p>\nThis class is thread-safe.\n</p>\n\n@see BasicRowProcessor\n\n@since 1.1\n", "name": "BeanProcessor", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "protected static final int PROPERTY_NOT_FOUND = -1;", "docstring": "\nSpecial array value used by {@code mapColumnsToProperties} that\nindicates there is no bean property that matches a column from a\n{@code ResultSet}.\n", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "int", "name": "PROPERTY_NOT_FOUND = -1", "syntax_pass": true}, {"attribute_expression": "private static final Map<Class<?>, Object> PRIMITIVE_DEFAULTS = new HashMap<>();", "docstring": "\nSet a bean's primitive properties to these defaults when SQL NULL\nis returned.  These are the same as the defaults that ResultSet get*\nmethods return in the event of a NULL column.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Map<Class<?>, Object>", "name": "PRIMITIVE_DEFAULTS = new HashMap<>()", "syntax_pass": true}, {"attribute_expression": "private static final List<ColumnHandler<?>> COLUMN_HANDLERS = new ArrayList<>();", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "List<ColumnHandler<?>>", "name": "COLUMN_HANDLERS = new ArrayList<>()", "syntax_pass": true}, {"attribute_expression": "private static final List<PropertyHandler> PROPERTY_HANDLERS = new ArrayList<>();", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "List<PropertyHandler>", "name": "PROPERTY_HANDLERS = new ArrayList<>()", "syntax_pass": true}, {"attribute_expression": "private final Map<String, String> columnToPropertyOverrides;", "docstring": "\nResultSet column to bean property name overrides.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Map<String, String>", "name": "columnToPropertyOverrides", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public BeanProcessor() {\n        this(new HashMap<>());\n    }", "docstring": "\nConstructor for BeanProcessor.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "BeanProcessor", "params": [], "body": "                           {\n        this(new HashMap<>());\n    }", "signature": "public BeanProcessor()"}, {"syntax_pass": true, "original_string": "    public BeanProcessor(final Map<String, String> columnToPropertyOverrides) {\n        if (columnToPropertyOverrides == null) {\n            throw new IllegalArgumentException(\"columnToPropertyOverrides map cannot be null\");\n        }\n        this.columnToPropertyOverrides = columnToPropertyOverrides;\n    }", "docstring": "\nConstructor for BeanProcessor configured with column to property name overrides.\n\n@param columnToPropertyOverrides ResultSet column to bean property name overrides\n@since 1.5\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "BeanProcessor", "params": [{"name": "columnToPropertyOverrides", "type": "Map<String, String>"}], "body": "                                                                              {\n        if (columnToPropertyOverrides == null) {\n            throw new IllegalArgumentException(\"columnToPropertyOverrides map cannot be null\");\n        }\n        this.columnToPropertyOverrides = columnToPropertyOverrides;\n    }", "signature": "public BeanProcessor(final Map<String, String> columnToPropertyOverrides)"}, {"syntax_pass": true, "original_string": "    private void callSetter(final Object target, final PropertyDescriptor prop, Object value)\n            throws SQLException {\n\n        final Method setter = getWriteMethod(target, prop, value);\n\n        if (setter == null || setter.getParameterTypes().length != 1) {\n            return;\n        }\n\n        try {\n            final Class<?> firstParam = setter.getParameterTypes()[0];\n            for (final PropertyHandler handler : PROPERTY_HANDLERS) {\n                if (handler.match(firstParam, value)) {\n                    value = handler.apply(firstParam, value);\n                    break;\n                }\n            }\n\n            // Don't call setter if the value object isn't the right type\n            if (!isCompatibleType(value, firstParam)) {\n                throw new SQLException(\n                        \"Cannot set \" + prop.getName() + \": incompatible types, cannot convert \" + value.getClass().getName() + \" to \" + firstParam.getName());\n                // value cannot be null here because isCompatibleType allows null\n            }\n            setter.invoke(target, value);\n\n        } catch (final IllegalArgumentException | IllegalAccessException | InvocationTargetException e) {\n            throw new SQLException(\"Cannot set \" + prop.getName() + \": \" + e.getMessage());\n        }\n    }", "docstring": "\nCalls the setter method on the target object for the given property.\nIf no setter method exists for the property, this method does nothing.\n@param target The object to set the property on.\n@param prop The property to set.\n@param value The value to pass into the setter.\n@throws SQLException if an error occurs setting the property.\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "callSetter", "params": [{"name": "target", "type": "Object"}, {"name": "prop", "type": "PropertyDescriptor"}, {"name": "value", "type": "Object"}], "body": "                                {\n\n        final Method setter = getWriteMethod(target, prop, value);\n\n        if (setter == null || setter.getParameterTypes().length != 1) {\n            return;\n        }\n\n        try {\n            final Class<?> firstParam = setter.getParameterTypes()[0];\n            for (final PropertyHandler handler : PROPERTY_HANDLERS) {\n                if (handler.match(firstParam, value)) {\n                    value = handler.apply(firstParam, value);\n                    break;\n                }\n            }\n\n            // Don't call setter if the value object isn't the right type\n            if (!isCompatibleType(value, firstParam)) {\n                throw new SQLException(\n                        \"Cannot set \" + prop.getName() + \": incompatible types, cannot convert \" + value.getClass().getName() + \" to \" + firstParam.getName());\n                // value cannot be null here because isCompatibleType allows null\n            }\n            setter.invoke(target, value);\n\n        } catch (final IllegalArgumentException | IllegalAccessException | InvocationTargetException e) {\n            throw new SQLException(\"Cannot set \" + prop.getName() + \": \" + e.getMessage());\n        }\n    }", "signature": "private void callSetter(final Object target, final PropertyDescriptor prop, Object value)"}, {"syntax_pass": true, "original_string": "    private <T> T createBean(final ResultSet resultSet, final Class<T> type, final PropertyDescriptor[] props, final int[] columnToProperty)\n            throws SQLException {\n        return populateBean(resultSet, this.newInstance(type), props, columnToProperty);\n    }", "docstring": "\nCreates a new object and initializes its fields from the ResultSet.\n@param <T> The type of bean to create\n@param resultSet The result set.\n@param type The bean type (the return type of the object).\n@param props The property descriptors.\n@param columnToProperty The column indices in the result set.\n@return An initialized object.\n@throws SQLException if a database error occurs.\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "T", "classes": []}, "name": "createBean", "params": [{"name": "resultSet", "type": "ResultSet"}, {"name": "type", "type": "Class<T>"}, {"name": "props", "type": "PropertyDescriptor[]"}, {"name": "columnToProperty", "type": "int[]"}], "body": "                                {\n        return populateBean(resultSet, this.newInstance(type), props, columnToProperty);\n    }", "signature": "private <T> T createBean(final ResultSet resultSet, final Class<T> type, final PropertyDescriptor[] props, final int[] columnToProperty)"}, {"syntax_pass": true, "original_string": "    @Override\n    protected final void finalize() {\n        // SpotBugs CT_CONSTRUCTOR_THROW\n    }", "docstring": " Does nothing.", "attributes": {"modifiers": "@Override\n    protected final", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected", "final"], "comments": [], "return_type": "void", "classes": []}, "name": "finalize", "params": [], "body": "                                    {\n        // SpotBugs CT_CONSTRUCTOR_THROW\n    }", "signature": "@Override\n    protected final void finalize()"}, {"syntax_pass": true, "original_string": "    protected Method getWriteMethod(final Object target, final PropertyDescriptor prop, final Object value) {\n        return prop.getWriteMethod();\n    }", "docstring": "\nGets the write method to use when setting {@code value} to the {@code target}.\n\n@param target Object where the write method will be called.\n@param prop   BeanUtils information.\n@param value  The value that will be passed to the write method.\n@return The {@link java.lang.reflect.Method} to call on {@code target} to write {@code value} or {@code null} if\n        there is no suitable write method.\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Method", "classes": []}, "name": "getWriteMethod", "params": [{"name": "target", "type": "Object"}, {"name": "prop", "type": "PropertyDescriptor"}, {"name": "value", "type": "Object"}], "body": "                                                                                                            {\n        return prop.getWriteMethod();\n    }", "signature": "protected Method getWriteMethod(final Object target, final PropertyDescriptor prop, final Object value)"}, {"syntax_pass": true, "original_string": "    private boolean isCompatibleType(final Object value, final Class<?> type) {\n        // Do object check first, then primitives\n        return value == null || type.isInstance(value) || matchesPrimitive(type, value.getClass());\n    }", "docstring": "\nResultSet.getObject() returns an Integer object for an INT column.  The\nsetter method for the property might take an Integer or a primitive int.\nThis method returns true if the value can be successfully passed into\nthe setter method.  Remember, Method.invoke() handles the unwrapping\nof Integer into an int.\n\n@param value The value to be passed into the setter method.\n@param type The setter's parameter type (non-null)\n@return boolean True if the value is compatible (null => true)\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isCompatibleType", "params": [{"name": "value", "type": "Object"}, {"name": "type", "type": "Class<?>"}], "body": "                                                                              {\n        // Do object check first, then primitives\n        return value == null || type.isInstance(value) || matchesPrimitive(type, value.getClass());\n    }", "signature": "private boolean isCompatibleType(final Object value, final Class<?> type)"}, {"syntax_pass": true, "original_string": "    protected int[] mapColumnsToProperties(final ResultSetMetaData rsmd,\n            final PropertyDescriptor[] props) throws SQLException {\n\n        final int cols = rsmd.getColumnCount();\n        final int[] columnToProperty = new int[cols + 1];\n        Arrays.fill(columnToProperty, PROPERTY_NOT_FOUND);\n\n        for (int col = 1; col <= cols; col++) {\n            String columnName = rsmd.getColumnLabel(col);\n            if (null == columnName || 0 == columnName.length()) {\n              columnName = rsmd.getColumnName(col);\n            }\n            String propertyName = columnToPropertyOverrides.get(columnName);\n            if (propertyName == null) {\n                propertyName = columnName;\n            }\n            if (propertyName == null) {\n                propertyName = Integer.toString(col);\n            }\n\n            for (int i = 0; i < props.length; i++) {\n                final PropertyDescriptor prop = props[i];\n                final Method reader = prop.getReadMethod();\n\n                // Check for @Column annotations as explicit marks\n                final Column column;\n                if (reader != null) {\n                    column = reader.getAnnotation(Column.class);\n                } else {\n                    column = null;\n                }\n\n                final String propertyColumnName;\n                if (column != null) {\n                    propertyColumnName = column.name();\n                } else {\n                    propertyColumnName = prop.getName();\n                }\n                if (propertyName.equalsIgnoreCase(propertyColumnName)) {\n                    columnToProperty[col] = i;\n                    break;\n                }\n            }\n        }\n\n        return columnToProperty;\n    }", "docstring": "\nThe positions in the returned array represent column numbers.  The\nvalues stored at each position represent the index in the\n{@code PropertyDescriptor[]} for the bean property that matches\nthe column name.  If no bean property was found for a column, the\nposition is set to {@code PROPERTY_NOT_FOUND}.\n\n@param rsmd The {@code ResultSetMetaData} containing column\ninformation.\n\n@param props The bean property descriptors.\n\n@throws SQLException if a database access error occurs\n\n@return An int[] with column index to property index mappings.  The 0th\nelement is meaningless because JDBC column indexing starts at 1.\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "int[]", "classes": []}, "name": "mapColumnsToProperties", "params": [{"name": "rsmd", "type": "ResultSetMetaData"}, {"name": "props", "type": "PropertyDescriptor[]"}], "body": "                                                                  {\n\n        final int cols = rsmd.getColumnCount();\n        final int[] columnToProperty = new int[cols + 1];\n        Arrays.fill(columnToProperty, PROPERTY_NOT_FOUND);\n\n        for (int col = 1; col <= cols; col++) {\n            String columnName = rsmd.getColumnLabel(col);\n            if (null == columnName || 0 == columnName.length()) {\n              columnName = rsmd.getColumnName(col);\n            }\n            String propertyName = columnToPropertyOverrides.get(columnName);\n            if (propertyName == null) {\n                propertyName = columnName;\n            }\n            if (propertyName == null) {\n                propertyName = Integer.toString(col);\n            }\n\n            for (int i = 0; i < props.length; i++) {\n                final PropertyDescriptor prop = props[i];\n                final Method reader = prop.getReadMethod();\n\n                // Check for @Column annotations as explicit marks\n                final Column column;\n                if (reader != null) {\n                    column = reader.getAnnotation(Column.class);\n                } else {\n                    column = null;\n                }\n\n                final String propertyColumnName;\n                if (column != null) {\n                    propertyColumnName = column.name();\n                } else {\n                    propertyColumnName = prop.getName();\n                }\n                if (propertyName.equalsIgnoreCase(propertyColumnName)) {\n                    columnToProperty[col] = i;\n                    break;\n                }\n            }\n        }\n\n        return columnToProperty;\n    }", "signature": "protected int[] mapColumnsToProperties(final ResultSetMetaData rsmd,\n            final PropertyDescriptor[] props)"}, {"syntax_pass": true, "original_string": "    private boolean matchesPrimitive(final Class<?> targetType, final Class<?> valueType) {\n        if (!targetType.isPrimitive()) {\n            return false;\n        }\n\n        try {\n            // see if there is a \"TYPE\" field.  This is present for primitive wrappers.\n            final Field typeField = valueType.getField(\"TYPE\");\n            final Object primitiveValueType = typeField.get(valueType);\n\n            if (targetType == primitiveValueType) {\n                return true;\n            }\n        } catch (final NoSuchFieldException | IllegalAccessException ignored) {\n            // an inaccessible TYPE field is a good sign that we're not working with a primitive wrapper.\n            // nothing to do.  we can't match for compatibility\n        }\n        return false;\n    }", "docstring": "\nCheck whether a value is of the same primitive type as {@code targetType}.\n\n@param targetType The primitive type to target.\n@param valueType The value to match to the primitive type.\n@return Whether {@code valueType} can be coerced (e.g. autoboxed) into {@code targetType}.\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "name": "matchesPrimitive", "params": [{"name": "targetType", "type": "Class<?>"}, {"name": "valueType", "type": "Class<?>"}], "body": "                                                                                          {\n        if (!targetType.isPrimitive()) {\n            return false;\n        }\n\n        try {\n            // see if there is a \"TYPE\" field.  This is present for primitive wrappers.\n            final Field typeField = valueType.getField(\"TYPE\");\n            final Object primitiveValueType = typeField.get(valueType);\n\n            if (targetType == primitiveValueType) {\n                return true;\n            }\n        } catch (final NoSuchFieldException | IllegalAccessException ignored) {\n            // an inaccessible TYPE field is a good sign that we're not working with a primitive wrapper.\n            // nothing to do.  we can't match for compatibility\n        }\n        return false;\n    }", "signature": "private boolean matchesPrimitive(final Class<?> targetType, final Class<?> valueType)"}, {"syntax_pass": true, "original_string": "    protected <T> T newInstance(final Class<T> c) throws SQLException {\n        try {\n            return c.getDeclaredConstructor().newInstance();\n\n        } catch (final IllegalAccessException | InstantiationException | InvocationTargetException |\n            NoSuchMethodException e) {\n            throw new SQLException(\"Cannot create \" + c.getName() + \": \" + e.getMessage());\n        }\n    }", "docstring": "\nFactory method that returns a new instance of the given Class.  This\nis called at the start of the bean creation process and may be\noverridden to provide custom behavior like returning a cached bean\ninstance.\n@param <T> The type of object to create\n@param c The Class to create an object from.\n@return A newly created object of the Class.\n@throws SQLException if creation failed.\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "T", "classes": []}, "name": "newInstance", "params": [{"name": "c", "type": "Class<T>"}], "body": "                                                                      {\n        try {\n            return c.getDeclaredConstructor().newInstance();\n\n        } catch (final IllegalAccessException | InstantiationException | InvocationTargetException |\n            NoSuchMethodException e) {\n            throw new SQLException(\"Cannot create \" + c.getName() + \": \" + e.getMessage());\n        }\n    }", "signature": "protected <T> T newInstance(final Class<T> c)"}, {"syntax_pass": true, "original_string": "    public <T> T populateBean(final ResultSet resultSet, final T bean) throws SQLException {\n        final PropertyDescriptor[] props = propertyDescriptors(bean.getClass());\n        final ResultSetMetaData rsmd = resultSet.getMetaData();\n        final int[] columnToProperty = mapColumnsToProperties(rsmd, props);\n\n        return populateBean(resultSet, bean, props, columnToProperty);\n    }", "docstring": "\nInitializes the fields of the provided bean from the ResultSet.\n@param <T> The type of bean\n@param resultSet The result set.\n@param bean The bean to be populated.\n@return An initialized object.\n@throws SQLException if a database error occurs.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "T", "classes": []}, "name": "populateBean", "params": [{"name": "resultSet", "type": "ResultSet"}, {"name": "bean", "type": "T"}], "body": "                                                                                           {\n        final PropertyDescriptor[] props = propertyDescriptors(bean.getClass());\n        final ResultSetMetaData rsmd = resultSet.getMetaData();\n        final int[] columnToProperty = mapColumnsToProperties(rsmd, props);\n\n        return populateBean(resultSet, bean, props, columnToProperty);\n    }", "signature": "public <T> T populateBean(final ResultSet resultSet, final T bean)"}, {"syntax_pass": true, "original_string": "    private <T> T populateBean(final ResultSet resultSet, final T bean,\n            final PropertyDescriptor[] props, final int[] columnToProperty)\n            throws SQLException {\n\n        for (int i = 1; i < columnToProperty.length; i++) {\n\n            if (columnToProperty[i] == PROPERTY_NOT_FOUND) {\n                continue;\n            }\n\n            final PropertyDescriptor prop = props[columnToProperty[i]];\n            final Class<?> propType = prop.getPropertyType();\n\n            Object value = null;\n            if (propType != null) {\n                value = processColumn(resultSet, i, propType);\n\n                if (value == null && propType.isPrimitive()) {\n                    value = PRIMITIVE_DEFAULTS.get(propType);\n                }\n            }\n\n            callSetter(bean, prop, value);\n        }\n\n        return bean;\n    }", "docstring": "\nThis method populates a bean from the ResultSet based upon the underlying meta-data.\n\n@param <T> The type of bean\n@param resultSet The result set.\n@param bean The bean to be populated.\n@param props The property descriptors.\n@param columnToProperty The column indices in the result set.\n@return An initialized object.\n@throws SQLException if a database error occurs.\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "T", "classes": []}, "name": "populateBean", "params": [{"name": "resultSet", "type": "ResultSet"}, {"name": "bean", "type": "T"}, {"name": "props", "type": "PropertyDescriptor[]"}, {"name": "columnToProperty", "type": "int[]"}], "body": "                                {\n\n        for (int i = 1; i < columnToProperty.length; i++) {\n\n            if (columnToProperty[i] == PROPERTY_NOT_FOUND) {\n                continue;\n            }\n\n            final PropertyDescriptor prop = props[columnToProperty[i]];\n            final Class<?> propType = prop.getPropertyType();\n\n            Object value = null;\n            if (propType != null) {\n                value = processColumn(resultSet, i, propType);\n\n                if (value == null && propType.isPrimitive()) {\n                    value = PRIMITIVE_DEFAULTS.get(propType);\n                }\n            }\n\n            callSetter(bean, prop, value);\n        }\n\n        return bean;\n    }", "signature": "private <T> T populateBean(final ResultSet resultSet, final T bean,\n            final PropertyDescriptor[] props, final int[] columnToProperty)"}, {"syntax_pass": true, "original_string": "    protected Object processColumn(final ResultSet resultSet, final int index, final Class<?> propType)\n        throws SQLException {\n\n        Object retval = resultSet.getObject(index);\n\n        if ( !propType.isPrimitive() && retval == null ) {\n            return null;\n        }\n\n        for (final ColumnHandler<?> handler : COLUMN_HANDLERS) {\n            if (handler.match(propType)) {\n                retval = handler.apply(resultSet, index);\n                break;\n            }\n        }\n\n        return retval;\n\n    }", "docstring": "\nConvert a {@code ResultSet} column into an object.  Simple\nimplementations could just call {@code rs.getObject(index)} while\nmore complex implementations could perform type manipulation to match\nthe column's type to the bean property type.\n\n<p>\nThis implementation calls the appropriate {@code ResultSet} getter\nmethod for the given property type to perform the type conversion.  If\nthe property type doesn't match one of the supported\n{@code ResultSet} types, {@code getObject} is called.\n</p>\n\n@param resultSet The {@code ResultSet} currently being processed.  It is\npositioned on a valid row before being passed into this method.\n\n@param index The current column index being processed.\n\n@param propType The bean property type that this column needs to be\nconverted into.\n\n@throws SQLException if a database access error occurs\n\n@return The object from the {@code ResultSet} at the given column\nindex after optional type processing or {@code null} if the column\nvalue was SQL NULL.\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Object", "classes": []}, "name": "processColumn", "params": [{"name": "resultSet", "type": "ResultSet"}, {"name": "index", "type": "int"}, {"name": "propType", "type": "Class<?>"}], "body": "                            {\n\n        Object retval = resultSet.getObject(index);\n\n        if ( !propType.isPrimitive() && retval == null ) {\n            return null;\n        }\n\n        for (final ColumnHandler<?> handler : COLUMN_HANDLERS) {\n            if (handler.match(propType)) {\n                retval = handler.apply(resultSet, index);\n                break;\n            }\n        }\n\n        return retval;\n\n    }", "signature": "protected Object processColumn(final ResultSet resultSet, final int index, final Class<?> propType)"}, {"syntax_pass": true, "original_string": "    private PropertyDescriptor[] propertyDescriptors(final Class<?> c)\n        throws SQLException {\n        // Introspector caches BeanInfo classes for better performance\n        BeanInfo beanInfo = null;\n        try {\n            beanInfo = Introspector.getBeanInfo(c);\n\n        } catch (final IntrospectionException e) {\n            throw new SQLException(\n                \"Bean introspection failed: \" + e.getMessage());\n        }\n\n        return beanInfo.getPropertyDescriptors();\n    }", "docstring": "\nReturns a PropertyDescriptor[] for the given Class.\n\n@param c The Class to retrieve PropertyDescriptors for.\n@return A PropertyDescriptor[] describing the Class.\n@throws SQLException if introspection failed.\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "PropertyDescriptor[]", "classes": []}, "name": "propertyDescriptors", "params": [{"name": "c", "type": "Class<?>"}], "body": "                            {\n        // Introspector caches BeanInfo classes for better performance\n        BeanInfo beanInfo = null;\n        try {\n            beanInfo = Introspector.getBeanInfo(c);\n\n        } catch (final IntrospectionException e) {\n            throw new SQLException(\n                \"Bean introspection failed: \" + e.getMessage());\n        }\n\n        return beanInfo.getPropertyDescriptors();\n    }", "signature": "private PropertyDescriptor[] propertyDescriptors(final Class<?> c)"}, {"syntax_pass": true, "original_string": "    public <T> T toBean(final ResultSet rs, final Class<? extends T> type) throws SQLException {\n        final T bean = this.newInstance(type);\n        return this.populateBean(rs, bean);\n    }", "docstring": "\nConvert a {@code ResultSet} row into a JavaBean.  This\nimplementation uses reflection and {@code BeanInfo} classes to\nmatch column names to bean property names.  Properties are matched to\ncolumns based on several factors:\n&lt;br/&gt;\n&lt;ol&gt;\n    &lt;li&gt;\n    The class has a writable property with the same name as a column.\n    The name comparison is case insensitive.\n    &lt;/li&gt;\n\n    &lt;li&gt;\n    The column type can be converted to the property's set method\n    parameter type with a ResultSet.get* method.  If the conversion fails\n    (ie. the property was an int and the column was a Timestamp) an\n    SQLException is thrown.\n    &lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;\nPrimitive bean properties are set to their defaults when SQL NULL is\nreturned from the {@code ResultSet}.  Numeric fields are set to 0\nand booleans are set to false.  Object bean properties are set to\n{@code null} when SQL NULL is returned.  This is the same behavior\nas the {@code ResultSet} get* methods.\n&lt;/p&gt;\n@param <T> The type of bean to create\n@param rs ResultSet that supplies the bean data\n@param type Class from which to create the bean instance\n@throws SQLException if a database access error occurs\n@return the newly created bean\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "T", "classes": []}, "name": "toBean", "params": [{"name": "rs", "type": "ResultSet"}, {"name": "type", "type": "Class<? extends T>"}], "body": "                                                                                               {\n        final T bean = this.newInstance(type);\n        return this.populateBean(rs, bean);\n    }", "signature": "public <T> T toBean(final ResultSet rs, final Class<? extends T> type)"}, {"syntax_pass": true, "original_string": "    public <T> List<T> toBeanList(final ResultSet resultSet, final Class<? extends T> type) throws SQLException {\n        final List<T> results = new ArrayList<>();\n        if (!resultSet.next()) {\n            return results;\n        }\n        final PropertyDescriptor[] props = propertyDescriptors(type);\n        final ResultSetMetaData rsmd = resultSet.getMetaData();\n        final int[] columnToProperty = mapColumnsToProperties(rsmd, props);\n        do {\n            results.add(this.createBean(resultSet, type, props, columnToProperty));\n        } while (resultSet.next()); // NOPMD False positive CheckResultSet\n        return results;\n    }", "docstring": "\nConvert a {@code ResultSet} into a {@code List} of JavaBeans.\nThis implementation uses reflection and {@code BeanInfo} classes to\nmatch column names to bean property names. Properties are matched to\ncolumns based on several factors:\n&lt;br/&gt;\n&lt;ol&gt;\n    &lt;li&gt;\n    The class has a writable property with the same name as a column.\n    The name comparison is case insensitive.\n    &lt;/li&gt;\n\n    &lt;li&gt;\n    The column type can be converted to the property's set method\n    parameter type with a ResultSet.get* method.  If the conversion fails\n    (ie. the property was an int and the column was a Timestamp) an\n    SQLException is thrown.\n    &lt;/li&gt;\n&lt;/ol&gt;\n\n<p>\nPrimitive bean properties are set to their defaults when SQL NULL is\nreturned from the {@code ResultSet}.  Numeric fields are set to 0\nand booleans are set to false.  Object bean properties are set to\n{@code null} when SQL NULL is returned.  This is the same behavior\nas the {@code ResultSet} get* methods.\n&lt;/p&gt;\n@param <T> The type of bean to create\n@param resultSet ResultSet that supplies the bean data\n@param type Class from which to create the bean instance\n@throws SQLException if a database access error occurs\n@return the newly created List of beans\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<T>", "classes": []}, "name": "toBeanList", "params": [{"name": "resultSet", "type": "ResultSet"}, {"name": "type", "type": "Class<? extends T>"}], "body": "                                                                                                                {\n        final List<T> results = new ArrayList<>();\n        if (!resultSet.next()) {\n            return results;\n        }\n        final PropertyDescriptor[] props = propertyDescriptors(type);\n        final ResultSetMetaData rsmd = resultSet.getMetaData();\n        final int[] columnToProperty = mapColumnsToProperties(rsmd, props);\n        do {\n            results.add(this.createBean(resultSet, type, props, columnToProperty));\n        } while (resultSet.next()); // NOPMD False positive CheckResultSet\n        return results;\n    }", "signature": "public <T> List<T> toBeanList(final ResultSet resultSet, final Class<? extends T> type)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/apache/commons/dbutils/OutParameter.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.dbutils;\n\nimport java.sql.CallableStatement;\nimport java.sql.SQLException;\n\n/**\n * Represents an OUT parameter for a stored procedure.  When running a stored\n * procedure with {@link QueryRunner}, pass an instance of\n * {@code OutParameter} to indicate that the parameter at that index is an\n * OUT parameter.  The value of the parameter may be obtained from the\n * {@code OutParameter} instance via {@link #getValue() }.\n * <p>\n * INOUT parameters are also supported by setting the {@code value} of\n * the {@code OutParameter} instance before invoking the stored procedure.\n *\n * @param <T> the class of the parameter; should be compatible via cast with the\n * class returned by the {@code CallableStatement.getObject(int)} method.\n */\npublic class OutParameter<T> {\n    private final int sqlType;\n    private final Class<T> javaType;\n    private T value;\n\n    /**\n     * Constructs an {@code OutParameter} for the given JDBC SQL type and\n     * Java type.\n     * @param sqlType the JDBC SQL type of the parameter as in\n     * {@link java.sql.Types}.\n     * @param javaType the Java class of the parameter value, cast compatible\n     * with the type returned by {@code CallableStatement.getObject(int)}\n     * for the JDBC type given by {@code sqlType}.\n     */\n    public OutParameter(final int sqlType, final Class<T> javaType) {\n        this.sqlType = sqlType;\n        this.javaType = javaType;\n    }\n\n    /**\n     * Constructs an {@code OutParameter} for the given JDBC SQL type and\n     * Java type and with the given value.  The parameter will be treated as an\n     * INOUT parameter if the value is null.\n     * @param sqlType the JDBC SQL type of the parameter as in\n     * {@link java.sql.Types}.\n     * @param javaType the Java class of the parameter value, cast compatible\n     * with the type returned by {@code CallableStatement.getObject(int)}\n     * for the JDBC type given by {@code sqlType}.\n     * @param value the IN value of the parameter\n     */\n    public OutParameter(final int sqlType, final Class<T> javaType, final T value) {\n        this.sqlType = sqlType;\n        this.javaType = javaType;\n        this.value = value;\n    }\n\n    /**\n     * Gets the Java class for this OUT parameter.\n     * @return the Java class for this OUT parameter.\n     */\n    public Class<T> getJavaType() {\n        return javaType;\n    }\n\n    /**\n     * Gets the JDBC SQL type for this OUT parameter.\n     * @return the JDBC SQL type for this OUT parameter.\n     */\n    public int getSqlType() {\n        return sqlType;\n    }\n\n    /**\n     * Gets the value of the OUT parameter.  After the stored procedure has\n     * been executed, the value is the value returned via this parameter.\n     * @return the value of the OUT parameter.\n     */\n    public T getValue() {\n        return value;\n    }\n\n    /**\n     * Set up the given statement by registering an OUT parameter at the given\n     * index using the {@code sqlType} and {@code value} of this\n     * {@code OutParameter}.  If the value is not null, the parameter is\n     * treated like an INOUT parameter and the value is set on the statement.\n     * @param stmt the statement the parameter should register on.\n     * @param index the (1-based) index of the parameter.\n     * @throws SQLException if the parameter could not be registered, or if the\n     * value of the parameter could not be set.\n     */\n    void register(final CallableStatement stmt, final int index) throws SQLException {\n        stmt.registerOutParameter(index, sqlType);\n        if (value != null) {\n            stmt.setObject(index, value);\n        }\n    }\n\n    /**\n     * Set the value using the return value of the parameter an the given index\n     * from the given {@code CallableStatement}.\n     * @param stmt the already executed statement\n     * @param index the (1-based) index of the parameter\n     * @throws SQLException when the value could not be retrieved from the\n     * statement.\n     */\n    void setValue(final CallableStatement stmt, final int index) throws SQLException {\n        value = javaType.cast(stmt.getObject(index));\n    }\n\n    /**\n     * Set the value of the OUT parameter.  If the value is not null when the\n     * stored procedure is executed, then the parameter will be treated like an\n     * INOUT parameter.\n     * @param value the new value for the parameter.\n     */\n    public void setValue(final T value) {\n        this.value = value;\n    }\n\n    @Override\n    public String toString() {\n        return \"OutParameter{\" + \"sqlType=\" + sqlType + \", javaType=\"\n            + javaType + \", value=\" + value + '}';\n    }\n}\n", "file_hash": "099b554536c3b9456b3ea34bca9791e581ce18c40d54555c39b3586d06de073a", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils;", "import java.sql.CallableStatement;", "import java.sql.SQLException;"], "methods": [], "classes": [{"original_string": "public class OutParameter<T> {\n    private final int sqlType;\n    private final Class<T> javaType;\n    private T value;\n\n    /**\n     * Constructs an {@code OutParameter} for the given JDBC SQL type and\n     * Java type.\n     * @param sqlType the JDBC SQL type of the parameter as in\n     * {@link java.sql.Types}.\n     * @param javaType the Java class of the parameter value, cast compatible\n     * with the type returned by {@code CallableStatement.getObject(int)}\n     * for the JDBC type given by {@code sqlType}.\n     */\n    public OutParameter(final int sqlType, final Class<T> javaType) {\n        this.sqlType = sqlType;\n        this.javaType = javaType;\n    }\n\n    /**\n     * Constructs an {@code OutParameter} for the given JDBC SQL type and\n     * Java type and with the given value.  The parameter will be treated as an\n     * INOUT parameter if the value is null.\n     * @param sqlType the JDBC SQL type of the parameter as in\n     * {@link java.sql.Types}.\n     * @param javaType the Java class of the parameter value, cast compatible\n     * with the type returned by {@code CallableStatement.getObject(int)}\n     * for the JDBC type given by {@code sqlType}.\n     * @param value the IN value of the parameter\n     */\n    public OutParameter(final int sqlType, final Class<T> javaType, final T value) {\n        this.sqlType = sqlType;\n        this.javaType = javaType;\n        this.value = value;\n    }\n\n    /**\n     * Gets the Java class for this OUT parameter.\n     * @return the Java class for this OUT parameter.\n     */\n    public Class<T> getJavaType() {\n        return javaType;\n    }\n\n    /**\n     * Gets the JDBC SQL type for this OUT parameter.\n     * @return the JDBC SQL type for this OUT parameter.\n     */\n    public int getSqlType() {\n        return sqlType;\n    }\n\n    /**\n     * Gets the value of the OUT parameter.  After the stored procedure has\n     * been executed, the value is the value returned via this parameter.\n     * @return the value of the OUT parameter.\n     */\n    public T getValue() {\n        return value;\n    }\n\n    /**\n     * Set up the given statement by registering an OUT parameter at the given\n     * index using the {@code sqlType} and {@code value} of this\n     * {@code OutParameter}.  If the value is not null, the parameter is\n     * treated like an INOUT parameter and the value is set on the statement.\n     * @param stmt the statement the parameter should register on.\n     * @param index the (1-based) index of the parameter.\n     * @throws SQLException if the parameter could not be registered, or if the\n     * value of the parameter could not be set.\n     */\n    void register(final CallableStatement stmt, final int index) throws SQLException {\n        stmt.registerOutParameter(index, sqlType);\n        if (value != null) {\n            stmt.setObject(index, value);\n        }\n    }\n\n    /**\n     * Set the value using the return value of the parameter an the given index\n     * from the given {@code CallableStatement}.\n     * @param stmt the already executed statement\n     * @param index the (1-based) index of the parameter\n     * @throws SQLException when the value could not be retrieved from the\n     * statement.\n     */\n    void setValue(final CallableStatement stmt, final int index) throws SQLException {\n        value = javaType.cast(stmt.getObject(index));\n    }\n\n    /**\n     * Set the value of the OUT parameter.  If the value is not null when the\n     * stored procedure is executed, then the parameter will be treated like an\n     * INOUT parameter.\n     * @param value the new value for the parameter.\n     */\n    public void setValue(final T value) {\n        this.value = value;\n    }\n\n    @Override\n    public String toString() {\n        return \"OutParameter{\" + \"sqlType=\" + sqlType + \", javaType=\"\n            + javaType + \", value=\" + value + '}';\n    }\n}", "definition": "public class OutParameter<T>", "class_docstring": "\nRepresents an OUT parameter for a stored procedure.  When running a stored\nprocedure with {@link QueryRunner}, pass an instance of\n{@code OutParameter} to indicate that the parameter at that index is an\nOUT parameter.  The value of the parameter may be obtained from the\n{@code OutParameter} instance via {@link #getValue() }.\n<p>\nINOUT parameters are also supported by setting the {@code value} of\nthe {@code OutParameter} instance before invoking the stored procedure.\n\n@param <T> the class of the parameter; should be compatible via cast with the\nclass returned by the {@code CallableStatement.getObject(int)} method.\n", "name": "OutParameter", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final int sqlType;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "sqlType", "syntax_pass": true}, {"attribute_expression": "private final Class<T> javaType;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Class<T>", "name": "javaType", "syntax_pass": true}, {"attribute_expression": "private T value;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "T", "name": "value", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public OutParameter(final int sqlType, final Class<T> javaType) {\n        this.sqlType = sqlType;\n        this.javaType = javaType;\n    }", "docstring": "\nConstructs an {@code OutParameter} for the given JDBC SQL type and\nJava type.\n@param sqlType the JDBC SQL type of the parameter as in\n{@link java.sql.Types}.\n@param javaType the Java class of the parameter value, cast compatible\nwith the type returned by {@code CallableStatement.getObject(int)}\nfor the JDBC type given by {@code sqlType}.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "OutParameter", "params": [{"name": "sqlType", "type": "int"}, {"name": "javaType", "type": "Class<T>"}], "body": "                                                                    {\n        this.sqlType = sqlType;\n        this.javaType = javaType;\n    }", "signature": "public OutParameter(final int sqlType, final Class<T> javaType)"}, {"syntax_pass": true, "original_string": "    public OutParameter(final int sqlType, final Class<T> javaType, final T value) {\n        this.sqlType = sqlType;\n        this.javaType = javaType;\n        this.value = value;\n    }", "docstring": "\nConstructs an {@code OutParameter} for the given JDBC SQL type and\nJava type and with the given value.  The parameter will be treated as an\nINOUT parameter if the value is null.\n@param sqlType the JDBC SQL type of the parameter as in\n{@link java.sql.Types}.\n@param javaType the Java class of the parameter value, cast compatible\nwith the type returned by {@code CallableStatement.getObject(int)}\nfor the JDBC type given by {@code sqlType}.\n@param value the IN value of the parameter\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "OutParameter", "params": [{"name": "sqlType", "type": "int"}, {"name": "javaType", "type": "Class<T>"}, {"name": "value", "type": "T"}], "body": "                                                                                   {\n        this.sqlType = sqlType;\n        this.javaType = javaType;\n        this.value = value;\n    }", "signature": "public OutParameter(final int sqlType, final Class<T> javaType, final T value)"}, {"syntax_pass": true, "original_string": "    public Class<T> getJavaType() {\n        return javaType;\n    }", "docstring": "\nGets the Java class for this OUT parameter.\n@return the Java class for this OUT parameter.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Class<T>", "classes": []}, "name": "getJavaType", "params": [], "body": "                                  {\n        return javaType;\n    }", "signature": "public Class<T> getJavaType()"}, {"syntax_pass": true, "original_string": "    public int getSqlType() {\n        return sqlType;\n    }", "docstring": "\nGets the JDBC SQL type for this OUT parameter.\n@return the JDBC SQL type for this OUT parameter.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "getSqlType", "params": [], "body": "                            {\n        return sqlType;\n    }", "signature": "public int getSqlType()"}, {"syntax_pass": true, "original_string": "    public T getValue() {\n        return value;\n    }", "docstring": "\nGets the value of the OUT parameter.  After the stored procedure has\nbeen executed, the value is the value returned via this parameter.\n@return the value of the OUT parameter.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "T", "classes": []}, "name": "getValue", "params": [], "body": "                        {\n        return value;\n    }", "signature": "public T getValue()"}, {"syntax_pass": true, "original_string": "    void register(final CallableStatement stmt, final int index) throws SQLException {\n        stmt.registerOutParameter(index, sqlType);\n        if (value != null) {\n            stmt.setObject(index, value);\n        }\n    }", "docstring": "\nSet up the given statement by registering an OUT parameter at the given\nindex using the {@code sqlType} and {@code value} of this\n{@code OutParameter}.  If the value is not null, the parameter is\ntreated like an INOUT parameter and the value is set on the statement.\n@param stmt the statement the parameter should register on.\n@param index the (1-based) index of the parameter.\n@throws SQLException if the parameter could not be registered, or if the\nvalue of the parameter could not be set.\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "register", "params": [{"name": "stmt", "type": "CallableStatement"}, {"name": "index", "type": "int"}], "body": "                                                                                     {\n        stmt.registerOutParameter(index, sqlType);\n        if (value != null) {\n            stmt.setObject(index, value);\n        }\n    }", "signature": "void register(final CallableStatement stmt, final int index)"}, {"syntax_pass": true, "original_string": "    void setValue(final CallableStatement stmt, final int index) throws SQLException {\n        value = javaType.cast(stmt.getObject(index));\n    }", "docstring": "\nSet the value using the return value of the parameter an the given index\nfrom the given {@code CallableStatement}.\n@param stmt the already executed statement\n@param index the (1-based) index of the parameter\n@throws SQLException when the value could not be retrieved from the\nstatement.\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "setValue", "params": [{"name": "stmt", "type": "CallableStatement"}, {"name": "index", "type": "int"}], "body": "                                                                                     {\n        value = javaType.cast(stmt.getObject(index));\n    }", "signature": "void setValue(final CallableStatement stmt, final int index)"}, {"syntax_pass": true, "original_string": "    public void setValue(final T value) {\n        this.value = value;\n    }", "docstring": "\nSet the value of the OUT parameter.  If the value is not null when the\nstored procedure is executed, then the parameter will be treated like an\nINOUT parameter.\n@param value the new value for the parameter.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setValue", "params": [{"name": "value", "type": "T"}], "body": "                                        {\n        this.value = value;\n    }", "signature": "public void setValue(final T value)"}, {"syntax_pass": true, "original_string": "    @Override\n    public String toString() {\n        return \"OutParameter{\" + \"sqlType=\" + sqlType + \", javaType=\"\n            + javaType + \", value=\" + value + '}';\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                             {\n        return \"OutParameter{\" + \"sqlType=\" + sqlType + \", javaType=\"\n            + javaType + \", value=\" + value + '}';\n    }", "signature": "@Override\n    public String toString()"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/apache/commons/dbutils/package-info.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * DbUtils is a small set of classes designed to make working with JDBC  easier. JDBC resource cleanup code is mundane,\n * error prone work so these classes abstract out all of the cleanup tasks from your code leaving you with what you\n * really wanted to do with JDBC in the first place: query and update data.\n * <p>\n * This package contains the core classes and interfaces - DbUtils, QueryRunner and the ResultSetHandler interface\n * should be your first items of interest.\n * </p>\n */\npackage org.apache.commons.dbutils;\n", "file_hash": "59814128d8ad6b0a67b4edac701d8002aea3689785256120e2dcdf2085c93e50", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils;"], "methods": [], "classes": [], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/apache/commons/dbutils/ResultSetHandler.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils;\n\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\n\n/**\n * Implementations of this interface convert ResultSets into other objects.\n *\n * @param <T> the target type the input ResultSet will be converted to.\n */\npublic interface ResultSetHandler<T> {\n\n    /**\n     * Turn the {@code ResultSet} into an Object.\n     *\n     * @param resultSet The {@code ResultSet} to handle.  It has not been touched\n     * before being passed to this method.\n     *\n     * @return An Object initialized with {@code ResultSet} data. It is\n     * legal for implementations to return {@code null} if the\n     * {@code ResultSet} contained 0 rows.\n     *\n     * @throws SQLException if a database access error occurs\n     */\n    T handle(ResultSet resultSet) throws SQLException;\n\n}", "file_hash": "e2991489149c7d62f298616ac3af72138302ab980d4ffeaed673a304d2ad648a", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils;", "import java.sql.ResultSet;", "import java.sql.SQLException;"], "methods": [], "classes": [], "interfaces": [{"original_string": "public interface ResultSetHandler<T> {\n\n    /**\n     * Turn the {@code ResultSet} into an Object.\n     *\n     * @param resultSet The {@code ResultSet} to handle.  It has not been touched\n     * before being passed to this method.\n     *\n     * @return An Object initialized with {@code ResultSet} data. It is\n     * legal for implementations to return {@code null} if the\n     * {@code ResultSet} contained 0 rows.\n     *\n     * @throws SQLException if a database access error occurs\n     */\n    T handle(ResultSet resultSet) throws SQLException;\n\n}", "definition": "public interface ResultSetHandler<T>", "interface_docstring": "\nImplementations of this interface convert ResultSets into other objects.\n\n@param <T> the target type the input ResultSet will be converted to.\n", "name": "ResultSetHandler", "extends_interfaces": [], "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    T handle(ResultSet resultSet) throws SQLException;", "docstring": "\nTurn the {@code ResultSet} into an Object.\n\n@param resultSet The {@code ResultSet} to handle.  It has not been touched\nbefore being passed to this method.\n\n@return An Object initialized with {@code ResultSet} data. It is\nlegal for implementations to return {@code null} if the\n{@code ResultSet} contained 0 rows.\n\n@throws SQLException if a database access error occurs\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "T", "classes": []}, "name": "handle", "params": [{"name": "resultSet", "type": "ResultSet"}], "body": "", "signature": "T handle(ResultSet resultSet)"}]}], "records": []}, {"relative_path": "src/main/java/org/apache/commons/dbutils/handlers/MapHandler.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils.handlers;\n\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Map;\n\nimport org.apache.commons.dbutils.ResultSetHandler;\nimport org.apache.commons.dbutils.RowProcessor;\n\n/**\n * {@code ResultSetHandler} implementation that converts the first\n * {@code ResultSet} row into a {@code Map}. This class is thread\n * safe.\n *\n * @see org.apache.commons.dbutils.ResultSetHandler\n */\npublic class MapHandler implements ResultSetHandler<Map<String, Object>> {\n\n    /**\n     * The RowProcessor implementation to use when converting rows\n     * into Maps.\n     */\n    private final RowProcessor convert;\n\n    /**\n     * Creates a new instance of MapHandler using a\n     * {@code BasicRowProcessor} for conversion.\n     */\n    public MapHandler() {\n        this(ArrayHandler.ROW_PROCESSOR);\n    }\n\n    /**\n     * Creates a new instance of MapHandler.\n     *\n     * @param convert The {@code RowProcessor} implementation\n     * to use when converting rows into Maps.\n     */\n    public MapHandler(final RowProcessor convert) {\n        this.convert = convert;\n    }\n\n    /**\n     * Converts the first row in the {@code ResultSet} into a\n     * {@code Map}.\n     * @param resultSet {@code ResultSet} to process.\n     * @return A {@code Map} with the values from the first row or\n     * {@code null} if there are no rows in the {@code ResultSet}.\n     *\n     * @throws SQLException if a database access error occurs\n     *\n     * @see org.apache.commons.dbutils.ResultSetHandler#handle(java.sql.ResultSet)\n     */\n    @Override\n    public Map<String, Object> handle(final ResultSet resultSet) throws SQLException {\n        return resultSet.next() ? this.convert.toMap(resultSet) : null;\n    }\n\n}\n", "file_hash": "c2572b809601fa65ff95a1f7d8fbbb216c7da504c14fcd33de94311164aedf65", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils.handlers;", "import java.sql.ResultSet;", "import java.sql.SQLException;", "import java.util.Map;", "import org.apache.commons.dbutils.ResultSetHandler;", "import org.apache.commons.dbutils.RowProcessor;"], "methods": [], "classes": [{"original_string": "public class MapHandler implements ResultSetHandler<Map<String, Object>> {\n\n    /**\n     * The RowProcessor implementation to use when converting rows\n     * into Maps.\n     */\n    private final RowProcessor convert;\n\n    /**\n     * Creates a new instance of MapHandler using a\n     * {@code BasicRowProcessor} for conversion.\n     */\n    public MapHandler() {\n        this(ArrayHandler.ROW_PROCESSOR);\n    }\n\n    /**\n     * Creates a new instance of MapHandler.\n     *\n     * @param convert The {@code RowProcessor} implementation\n     * to use when converting rows into Maps.\n     */\n    public MapHandler(final RowProcessor convert) {\n        this.convert = convert;\n    }\n\n    /**\n     * Converts the first row in the {@code ResultSet} into a\n     * {@code Map}.\n     * @param resultSet {@code ResultSet} to process.\n     * @return A {@code Map} with the values from the first row or\n     * {@code null} if there are no rows in the {@code ResultSet}.\n     *\n     * @throws SQLException if a database access error occurs\n     *\n     * @see org.apache.commons.dbutils.ResultSetHandler#handle(java.sql.ResultSet)\n     */\n    @Override\n    public Map<String, Object> handle(final ResultSet resultSet) throws SQLException {\n        return resultSet.next() ? this.convert.toMap(resultSet) : null;\n    }\n\n}", "definition": "public class MapHandler implements ResultSetHandler<Map<String, Object>>", "class_docstring": "\n{@code ResultSetHandler} implementation that converts the first\n{@code ResultSet} row into a {@code Map}. This class is thread\nsafe.\n\n@see org.apache.commons.dbutils.ResultSetHandler\n", "name": "MapHandler", "super_interfaces": ["ResultSetHandler<Map<String, Object>>"], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final RowProcessor convert;", "docstring": "\nThe RowProcessor implementation to use when converting rows\ninto Maps.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "RowProcessor", "name": "convert", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public MapHandler() {\n        this(ArrayHandler.ROW_PROCESSOR);\n    }", "docstring": "\nCreates a new instance of MapHandler using a\n{@code BasicRowProcessor} for conversion.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "MapHandler", "params": [], "body": "                        {\n        this(ArrayHandler.ROW_PROCESSOR);\n    }", "signature": "public MapHandler()"}, {"syntax_pass": true, "original_string": "    public MapHandler(final RowProcessor convert) {\n        this.convert = convert;\n    }", "docstring": "\nCreates a new instance of MapHandler.\n\n@param convert The {@code RowProcessor} implementation\nto use when converting rows into Maps.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "MapHandler", "params": [{"name": "convert", "type": "RowProcessor"}], "body": "                                                  {\n        this.convert = convert;\n    }", "signature": "public MapHandler(final RowProcessor convert)"}, {"syntax_pass": true, "original_string": "    @Override\n    public Map<String, Object> handle(final ResultSet resultSet) throws SQLException {\n        return resultSet.next() ? this.convert.toMap(resultSet) : null;\n    }", "docstring": "\nConverts the first row in the {@code ResultSet} into a\n{@code Map}.\n@param resultSet {@code ResultSet} to process.\n@return A {@code Map} with the values from the first row or\n{@code null} if there are no rows in the {@code ResultSet}.\n\n@throws SQLException if a database access error occurs\n\n@see org.apache.commons.dbutils.ResultSetHandler#handle(java.sql.ResultSet)\n", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map<String, Object>", "classes": []}, "name": "handle", "params": [{"name": "resultSet", "type": "ResultSet"}], "body": "                                                                                     {\n        return resultSet.next() ? this.convert.toMap(resultSet) : null;\n    }", "signature": "@Override\n    public Map<String, Object> handle(final ResultSet resultSet)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/apache/commons/dbutils/handlers/BeanMapHandler.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils.handlers;\n\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\n\nimport org.apache.commons.dbutils.RowProcessor;\n\n/**\n * <p>\n * {@code ResultSetHandler} implementation that returns a Map of Beans.\n * {@code ResultSet} rows are converted into Beans which are then stored in\n * a Map under the given key.\n * </p>\n * <p>\n * If you had a Person table with a primary key column called ID, you could\n * retrieve rows from the table like this:\n *\n * <pre>\n * ResultSetHandler&lt;Map&lt;Long, Person&gt;&gt; h = new BeanMapHandler&lt;Long, Person&gt;(Person.class, &quot;id&quot;);\n * Map&lt;Long, Person&gt; found = queryRunner.query(&quot;select id, name, age from person&quot;, h);\n * Person jane = found.get(1L); // jane's id is 1\n * String janesName = jane.getName();\n * Integer janesAge = jane.getAge();\n * </pre>\n *\n * Note that the \"id\" passed to BeanMapHandler can be in any case. The data type\n * returned for id is dependent upon how your JDBC driver converts SQL column\n * types from the Person table into Java types. The \"name\" and \"age\" columns are\n * converted according to their property descriptors by DbUtils.\n * &lt;/p&gt;\n * <p>\n * This class is thread safe.\n * &lt;/p&gt;\n *\n * @param <K>\n *            the type of keys maintained by the returned map\n * @param <V>\n *            the type of the bean\n * @see org.apache.commons.dbutils.ResultSetHandler\n * @since 1.5\n */\npublic class BeanMapHandler<K, V> extends AbstractKeyedHandler<K, V> {\n\n    /**\n     * The Class of beans produced by this handler.\n     */\n    private final Class<V> type;\n\n    /**\n     * The RowProcessor implementation to use when converting rows into Objects.\n     */\n    private final RowProcessor convert;\n\n    /**\n     * The column index to retrieve key values from. Defaults to 1.\n     */\n    private final int columnIndex;\n\n    /**\n     * The column name to retrieve key values from. Either columnName or\n     * columnIndex will be used but never both.\n     */\n    private final String columnName;\n\n    /**\n     * Creates a new instance of BeanMapHandler. The value of the first column\n     * of each row will be a key in the Map.\n     *\n     * @param type\n     *            The Class that objects returned from {@code createRow()}\n     *            are created from.\n     */\n    public BeanMapHandler(final Class<V> type) {\n        this(type, ArrayHandler.ROW_PROCESSOR, 1, null);\n    }\n\n    /**\n     * Creates a new instance of BeanMapHandler.\n     *\n     * @param type\n     *            The Class that objects returned from {@code createRow()}\n     *            are created from.\n     * @param columnIndex\n     *            The values to use as keys in the Map are retrieved from the\n     *            column at this index.\n     */\n    public BeanMapHandler(final Class<V> type, final int columnIndex) {\n        this(type, ArrayHandler.ROW_PROCESSOR, columnIndex, null);\n    }\n\n    /**\n     * Creates a new instance of BeanMapHandler. The value of the first column\n     * of each row will be a key in the Map.\n     *\n     * @param type\n     *            The Class that objects returned from {@code createRow()}\n     *            are created from.\n     * @param convert\n     *            The {@code RowProcessor} implementation to use when\n     *            converting rows into Beans\n     */\n    public BeanMapHandler(final Class<V> type, final RowProcessor convert) {\n        this(type, convert, 1, null);\n    }\n\n    /**\n     * Private Helper\n     *\n     * @param convert\n     *            The {@code RowProcessor} implementation to use when\n     *            converting rows into Beans\n     * @param columnIndex\n     *            The values to use as keys in the Map are retrieved from the\n     *            column at this index.\n     * @param columnName\n     *            The values to use as keys in the Map are retrieved from the\n     *            column with this name.\n     */\n    private BeanMapHandler(final Class<V> type, final RowProcessor convert,\n            final int columnIndex, final String columnName) {\n        this.type = type;\n        this.convert = convert;\n        this.columnIndex = columnIndex;\n        this.columnName = columnName;\n    }\n\n    /**\n     * Creates a new instance of BeanMapHandler.\n     *\n     * @param type\n     *            The Class that objects returned from {@code createRow()}\n     *            are created from.\n     * @param columnName\n     *            The values to use as keys in the Map are retrieved from the\n     *            column with this name.\n     */\n    public BeanMapHandler(final Class<V> type, final String columnName) {\n        this(type, ArrayHandler.ROW_PROCESSOR, 1, columnName);\n    }\n\n    /**\n     * This factory method is called by {@code handle()} to retrieve the\n     * key value from the current {@code ResultSet} row.\n     * @param resultSet ResultSet to create a key from\n     *\n     * @return K from the configured key column name/index\n     *\n     * @throws SQLException if a database access error occurs\n     * @throws ClassCastException if the class datatype does not match the column type\n     *\n     * @see org.apache.commons.dbutils.handlers.AbstractKeyedHandler#createKey(ResultSet)\n     */\n    // We assume that the user has picked the correct type to match the column\n    // so getObject will return the appropriate type and the cast will succeed.\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    protected K createKey(final ResultSet resultSet) throws SQLException {\n        return columnName == null ?\n               (K) resultSet.getObject(columnIndex) :\n               (K) resultSet.getObject(columnName);\n    }\n\n    @Override\n    protected V createRow(final ResultSet resultSet) throws SQLException {\n        return this.convert.toBean(resultSet, type);\n    }\n\n}\n", "file_hash": "a882866694e2793cf289cb1e5b00a351671f3647313b7231e9450f9c9b97173e", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils.handlers;", "import java.sql.ResultSet;", "import java.sql.SQLException;", "import org.apache.commons.dbutils.RowProcessor;"], "methods": [], "classes": [{"original_string": "public class BeanMapHandler<K, V> extends AbstractKeyedHandler<K, V> {\n\n    /**\n     * The Class of beans produced by this handler.\n     */\n    private final Class<V> type;\n\n    /**\n     * The RowProcessor implementation to use when converting rows into Objects.\n     */\n    private final RowProcessor convert;\n\n    /**\n     * The column index to retrieve key values from. Defaults to 1.\n     */\n    private final int columnIndex;\n\n    /**\n     * The column name to retrieve key values from. Either columnName or\n     * columnIndex will be used but never both.\n     */\n    private final String columnName;\n\n    /**\n     * Creates a new instance of BeanMapHandler. The value of the first column\n     * of each row will be a key in the Map.\n     *\n     * @param type\n     *            The Class that objects returned from {@code createRow()}\n     *            are created from.\n     */\n    public BeanMapHandler(final Class<V> type) {\n        this(type, ArrayHandler.ROW_PROCESSOR, 1, null);\n    }\n\n    /**\n     * Creates a new instance of BeanMapHandler.\n     *\n     * @param type\n     *            The Class that objects returned from {@code createRow()}\n     *            are created from.\n     * @param columnIndex\n     *            The values to use as keys in the Map are retrieved from the\n     *            column at this index.\n     */\n    public BeanMapHandler(final Class<V> type, final int columnIndex) {\n        this(type, ArrayHandler.ROW_PROCESSOR, columnIndex, null);\n    }\n\n    /**\n     * Creates a new instance of BeanMapHandler. The value of the first column\n     * of each row will be a key in the Map.\n     *\n     * @param type\n     *            The Class that objects returned from {@code createRow()}\n     *            are created from.\n     * @param convert\n     *            The {@code RowProcessor} implementation to use when\n     *            converting rows into Beans\n     */\n    public BeanMapHandler(final Class<V> type, final RowProcessor convert) {\n        this(type, convert, 1, null);\n    }\n\n    /**\n     * Private Helper\n     *\n     * @param convert\n     *            The {@code RowProcessor} implementation to use when\n     *            converting rows into Beans\n     * @param columnIndex\n     *            The values to use as keys in the Map are retrieved from the\n     *            column at this index.\n     * @param columnName\n     *            The values to use as keys in the Map are retrieved from the\n     *            column with this name.\n     */\n    private BeanMapHandler(final Class<V> type, final RowProcessor convert,\n            final int columnIndex, final String columnName) {\n        this.type = type;\n        this.convert = convert;\n        this.columnIndex = columnIndex;\n        this.columnName = columnName;\n    }\n\n    /**\n     * Creates a new instance of BeanMapHandler.\n     *\n     * @param type\n     *            The Class that objects returned from {@code createRow()}\n     *            are created from.\n     * @param columnName\n     *            The values to use as keys in the Map are retrieved from the\n     *            column with this name.\n     */\n    public BeanMapHandler(final Class<V> type, final String columnName) {\n        this(type, ArrayHandler.ROW_PROCESSOR, 1, columnName);\n    }\n\n    /**\n     * This factory method is called by {@code handle()} to retrieve the\n     * key value from the current {@code ResultSet} row.\n     * @param resultSet ResultSet to create a key from\n     *\n     * @return K from the configured key column name/index\n     *\n     * @throws SQLException if a database access error occurs\n     * @throws ClassCastException if the class datatype does not match the column type\n     *\n     * @see org.apache.commons.dbutils.handlers.AbstractKeyedHandler#createKey(ResultSet)\n     */\n    // We assume that the user has picked the correct type to match the column\n    // so getObject will return the appropriate type and the cast will succeed.\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    protected K createKey(final ResultSet resultSet) throws SQLException {\n        return columnName == null ?\n               (K) resultSet.getObject(columnIndex) :\n               (K) resultSet.getObject(columnName);\n    }\n\n    @Override\n    protected V createRow(final ResultSet resultSet) throws SQLException {\n        return this.convert.toBean(resultSet, type);\n    }\n\n}", "definition": "public class BeanMapHandler<K, V> extends AbstractKeyedHandler<K, V>", "class_docstring": "\n<p>\n{@code ResultSetHandler} implementation that returns a Map of Beans.\n{@code ResultSet} rows are converted into Beans which are then stored in\na Map under the given key.\n</p>\n<p>\nIf you had a Person table with a primary key column called ID, you could\nretrieve rows from the table like this:\n\n<pre>\nResultSetHandler&lt;Map&lt;Long, Person&gt;&gt; h = new BeanMapHandler&lt;Long, Person&gt;(Person.class, &quot;id&quot;);\nMap&lt;Long, Person&gt; found = queryRunner.query(&quot;select id, name, age from person&quot;, h);\nPerson jane = found.get(1L); // jane's id is 1\nString janesName = jane.getName();\nInteger janesAge = jane.getAge();\n</pre>\n\nNote that the \"id\" passed to BeanMapHandler can be in any case. The data type\nreturned for id is dependent upon how your JDBC driver converts SQL column\ntypes from the Person table into Java types. The \"name\" and \"age\" columns are\nconverted according to their property descriptors by DbUtils.\n&lt;/p&gt;\n<p>\nThis class is thread safe.\n&lt;/p&gt;\n\n@param <K>\n           the type of keys maintained by the returned map\n@param <V>\n           the type of the bean\n@see org.apache.commons.dbutils.ResultSetHandler\n@since 1.5\n", "name": "BeanMapHandler", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final Class<V> type;", "docstring": "\nThe Class of beans produced by this handler.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Class<V>", "name": "type", "syntax_pass": true}, {"attribute_expression": "private final RowProcessor convert;", "docstring": "\nThe RowProcessor implementation to use when converting rows into Objects.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "RowProcessor", "name": "convert", "syntax_pass": true}, {"attribute_expression": "private final int columnIndex;", "docstring": "\nThe column index to retrieve key values from. Defaults to 1.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "columnIndex", "syntax_pass": true}, {"attribute_expression": "private final String columnName;", "docstring": "\nThe column name to retrieve key values from. Either columnName or\ncolumnIndex will be used but never both.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "columnName", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public BeanMapHandler(final Class<V> type) {\n        this(type, ArrayHandler.ROW_PROCESSOR, 1, null);\n    }", "docstring": "\nCreates a new instance of BeanMapHandler. The value of the first column\nof each row will be a key in the Map.\n\n@param type\n           The Class that objects returned from {@code createRow()}\n           are created from.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "BeanMapHandler", "params": [{"name": "type", "type": "Class<V>"}], "body": "                                               {\n        this(type, ArrayHandler.ROW_PROCESSOR, 1, null);\n    }", "signature": "public BeanMapHandler(final Class<V> type)"}, {"syntax_pass": true, "original_string": "    public BeanMapHandler(final Class<V> type, final int columnIndex) {\n        this(type, ArrayHandler.ROW_PROCESSOR, columnIndex, null);\n    }", "docstring": "\nCreates a new instance of BeanMapHandler.\n\n@param type\n           The Class that objects returned from {@code createRow()}\n           are created from.\n@param columnIndex\n           The values to use as keys in the Map are retrieved from the\n           column at this index.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "BeanMapHandler", "params": [{"name": "type", "type": "Class<V>"}, {"name": "columnIndex", "type": "int"}], "body": "                                                                      {\n        this(type, ArrayHandler.ROW_PROCESSOR, columnIndex, null);\n    }", "signature": "public BeanMapHandler(final Class<V> type, final int columnIndex)"}, {"syntax_pass": true, "original_string": "    public BeanMapHandler(final Class<V> type, final RowProcessor convert) {\n        this(type, convert, 1, null);\n    }", "docstring": "\nCreates a new instance of BeanMapHandler. The value of the first column\nof each row will be a key in the Map.\n\n@param type\n           The Class that objects returned from {@code createRow()}\n           are created from.\n@param convert\n           The {@code RowProcessor} implementation to use when\n           converting rows into Beans\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "BeanMapHandler", "params": [{"name": "type", "type": "Class<V>"}, {"name": "convert", "type": "RowProcessor"}], "body": "                                                                           {\n        this(type, convert, 1, null);\n    }", "signature": "public BeanMapHandler(final Class<V> type, final RowProcessor convert)"}, {"syntax_pass": true, "original_string": "    private BeanMapHandler(final Class<V> type, final RowProcessor convert,\n            final int columnIndex, final String columnName) {\n        this.type = type;\n        this.convert = convert;\n        this.columnIndex = columnIndex;\n        this.columnName = columnName;\n    }", "docstring": "\nPrivate Helper\n\n@param convert\n           The {@code RowProcessor} implementation to use when\n           converting rows into Beans\n@param columnIndex\n           The values to use as keys in the Map are retrieved from the\n           column at this index.\n@param columnName\n           The values to use as keys in the Map are retrieved from the\n           column with this name.\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "BeanMapHandler", "params": [{"name": "type", "type": "Class<V>"}, {"name": "convert", "type": "RowProcessor"}, {"name": "columnIndex", "type": "int"}, {"name": "columnName", "type": "String"}], "body": "                                                            {\n        this.type = type;\n        this.convert = convert;\n        this.columnIndex = columnIndex;\n        this.columnName = columnName;\n    }", "signature": "private BeanMapHandler(final Class<V> type, final RowProcessor convert,\n            final int columnIndex, final String columnName)"}, {"syntax_pass": true, "original_string": "    public BeanMapHandler(final Class<V> type, final String columnName) {\n        this(type, ArrayHandler.ROW_PROCESSOR, 1, columnName);\n    }", "docstring": "\nCreates a new instance of BeanMapHandler.\n\n@param type\n           The Class that objects returned from {@code createRow()}\n           are created from.\n@param columnName\n           The values to use as keys in the Map are retrieved from the\n           column with this name.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "BeanMapHandler", "params": [{"name": "type", "type": "Class<V>"}, {"name": "columnName", "type": "String"}], "body": "                                                                        {\n        this(type, ArrayHandler.ROW_PROCESSOR, 1, columnName);\n    }", "signature": "public BeanMapHandler(final Class<V> type, final String columnName)"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"unchecked\")\n    @Override\n    protected K createKey(final ResultSet resultSet) throws SQLException {\n        return columnName == null ?\n               (K) resultSet.getObject(columnIndex) :\n               (K) resultSet.getObject(columnName);\n    }", "docstring": " so getObject will return the appropriate type and the cast will succeed.", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n    @Override\n    protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "protected"], "comments": [], "return_type": "K", "classes": []}, "name": "createKey", "params": [{"name": "resultSet", "type": "ResultSet"}], "body": "                                                                         {\n        return columnName == null ?\n               (K) resultSet.getObject(columnIndex) :\n               (K) resultSet.getObject(columnName);\n    }", "signature": "@SuppressWarnings(\"unchecked\")\n    @Override\n    protected K createKey(final ResultSet resultSet)"}, {"syntax_pass": true, "original_string": "    @Override\n    protected V createRow(final ResultSet resultSet) throws SQLException {\n        return this.convert.toBean(resultSet, type);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "V", "classes": []}, "name": "createRow", "params": [{"name": "resultSet", "type": "ResultSet"}], "body": "                                                                         {\n        return this.convert.toBean(resultSet, type);\n    }", "signature": "@Override\n    protected V createRow(final ResultSet resultSet)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/apache/commons/dbutils/handlers/ArrayHandler.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils.handlers;\n\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\n\nimport org.apache.commons.dbutils.BasicRowProcessor;\nimport org.apache.commons.dbutils.ResultSetHandler;\nimport org.apache.commons.dbutils.RowProcessor;\n\n/**\n * {@code ResultSetHandler} implementation that converts a\n * {@code ResultSet} into an {@code Object[]}. This class is\n * thread safe.\n *\n * @see org.apache.commons.dbutils.ResultSetHandler\n */\npublic class ArrayHandler implements ResultSetHandler<Object[]> {\n\n    /**\n     * Singleton processor instance that handlers share to save memory.  Notice\n     * the default scoping to allow only classes in this package to use this\n     * instance.\n     */\n    static final RowProcessor ROW_PROCESSOR = new BasicRowProcessor();\n\n    /**\n     * An empty array to return when no more rows are available in the ResultSet.\n     */\n    private static final Object[] EMPTY_ARRAY = {};\n\n    /**\n     * The RowProcessor implementation to use when converting rows\n     * into arrays.\n     */\n    private final RowProcessor convert;\n\n    /**\n     * Creates a new instance of ArrayHandler using a\n     * {@code BasicRowProcessor} for conversion.\n     */\n    public ArrayHandler() {\n        this(ROW_PROCESSOR);\n    }\n\n    /**\n     * Creates a new instance of ArrayHandler.\n     *\n     * @param convert The {@code RowProcessor} implementation\n     * to use when converting rows into arrays.\n     */\n    public ArrayHandler(final RowProcessor convert) {\n        this.convert = convert;\n    }\n\n    /**\n     * Places the column values from the first row in an {@code Object[]}.\n     * @param resultSet {@code ResultSet} to process.\n     * @return An Object[]. If there are no rows in the {@code ResultSet}\n     * an empty array will be returned.\n     *\n     * @throws SQLException if a database access error occurs\n     * @see org.apache.commons.dbutils.ResultSetHandler#handle(java.sql.ResultSet)\n     */\n    @Override\n    public Object[] handle(final ResultSet resultSet) throws SQLException {\n        return resultSet.next() ? this.convert.toArray(resultSet) : EMPTY_ARRAY;\n    }\n\n}\n", "file_hash": "f9e4a8215e2e720a1514e4dfbf1e676b5503d0778c09d8cbf6618ed79c40b5e4", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils.handlers;", "import java.sql.ResultSet;", "import java.sql.SQLException;", "import org.apache.commons.dbutils.BasicRowProcessor;", "import org.apache.commons.dbutils.ResultSetHandler;", "import org.apache.commons.dbutils.RowProcessor;"], "methods": [], "classes": [{"original_string": "public class ArrayHandler implements ResultSetHandler<Object[]> {\n\n    /**\n     * Singleton processor instance that handlers share to save memory.  Notice\n     * the default scoping to allow only classes in this package to use this\n     * instance.\n     */\n    static final RowProcessor ROW_PROCESSOR = new BasicRowProcessor();\n\n    /**\n     * An empty array to return when no more rows are available in the ResultSet.\n     */\n    private static final Object[] EMPTY_ARRAY = {};\n\n    /**\n     * The RowProcessor implementation to use when converting rows\n     * into arrays.\n     */\n    private final RowProcessor convert;\n\n    /**\n     * Creates a new instance of ArrayHandler using a\n     * {@code BasicRowProcessor} for conversion.\n     */\n    public ArrayHandler() {\n        this(ROW_PROCESSOR);\n    }\n\n    /**\n     * Creates a new instance of ArrayHandler.\n     *\n     * @param convert The {@code RowProcessor} implementation\n     * to use when converting rows into arrays.\n     */\n    public ArrayHandler(final RowProcessor convert) {\n        this.convert = convert;\n    }\n\n    /**\n     * Places the column values from the first row in an {@code Object[]}.\n     * @param resultSet {@code ResultSet} to process.\n     * @return An Object[]. If there are no rows in the {@code ResultSet}\n     * an empty array will be returned.\n     *\n     * @throws SQLException if a database access error occurs\n     * @see org.apache.commons.dbutils.ResultSetHandler#handle(java.sql.ResultSet)\n     */\n    @Override\n    public Object[] handle(final ResultSet resultSet) throws SQLException {\n        return resultSet.next() ? this.convert.toArray(resultSet) : EMPTY_ARRAY;\n    }\n\n}", "definition": "public class ArrayHandler implements ResultSetHandler<Object[]>", "class_docstring": "\n{@code ResultSetHandler} implementation that converts a\n{@code ResultSet} into an {@code Object[]}. This class is\nthread safe.\n\n@see org.apache.commons.dbutils.ResultSetHandler\n", "name": "ArrayHandler", "super_interfaces": ["ResultSetHandler<Object[]>"], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "static final RowProcessor ROW_PROCESSOR = new BasicRowProcessor();", "docstring": "\nSingleton processor instance that handlers share to save memory.  Notice\nthe default scoping to allow only classes in this package to use this\ninstance.\n", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "RowProcessor", "name": "ROW_PROCESSOR = new BasicRowProcessor()", "syntax_pass": true}, {"attribute_expression": "private static final Object[] EMPTY_ARRAY = {};", "docstring": "\nAn empty array to return when no more rows are available in the ResultSet.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Object[]", "name": "EMPTY_ARRAY = {}", "syntax_pass": true}, {"attribute_expression": "private final RowProcessor convert;", "docstring": "\nThe RowProcessor implementation to use when converting rows\ninto arrays.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "RowProcessor", "name": "convert", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public ArrayHandler() {\n        this(ROW_PROCESSOR);\n    }", "docstring": "\nCreates a new instance of ArrayHandler using a\n{@code BasicRowProcessor} for conversion.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ArrayHandler", "params": [], "body": "                          {\n        this(ROW_PROCESSOR);\n    }", "signature": "public ArrayHandler()"}, {"syntax_pass": true, "original_string": "    public ArrayHandler(final RowProcessor convert) {\n        this.convert = convert;\n    }", "docstring": "\nCreates a new instance of ArrayHandler.\n\n@param convert The {@code RowProcessor} implementation\nto use when converting rows into arrays.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ArrayHandler", "params": [{"name": "convert", "type": "RowProcessor"}], "body": "                                                    {\n        this.convert = convert;\n    }", "signature": "public ArrayHandler(final RowProcessor convert)"}, {"syntax_pass": true, "original_string": "    @Override\n    public Object[] handle(final ResultSet resultSet) throws SQLException {\n        return resultSet.next() ? this.convert.toArray(resultSet) : EMPTY_ARRAY;\n    }", "docstring": "\nPlaces the column values from the first row in an {@code Object[]}.\n@param resultSet {@code ResultSet} to process.\n@return An Object[]. If there are no rows in the {@code ResultSet}\nan empty array will be returned.\n\n@throws SQLException if a database access error occurs\n@see org.apache.commons.dbutils.ResultSetHandler#handle(java.sql.ResultSet)\n", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object[]", "classes": []}, "name": "handle", "params": [{"name": "resultSet", "type": "ResultSet"}], "body": "                                                                          {\n        return resultSet.next() ? this.convert.toArray(resultSet) : EMPTY_ARRAY;\n    }", "signature": "@Override\n    public Object[] handle(final ResultSet resultSet)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/apache/commons/dbutils/handlers/ColumnListHandler.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils.handlers;\n\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\n\n/**\n * {@code ResultSetHandler} implementation that converts one\n * {@code ResultSet} column into a {@code List} of\n * {@code Object}s. This class is thread safe.\n *\n * @param <T> The type of the column.\n * @see org.apache.commons.dbutils.ResultSetHandler\n * @since 1.1\n */\npublic class ColumnListHandler<T> extends AbstractListHandler<T> {\n\n    /**\n     * The column number to retrieve.\n     */\n    private final int columnIndex;\n\n    /**\n     * The column name to retrieve.  Either columnName or columnIndex\n     * will be used but never both.\n     */\n    private final String columnName;\n\n    /**\n     * Creates a new instance of ColumnListHandler.  The first column of each\n     * row will be returned from {@code handle()}.\n     */\n    public ColumnListHandler() {\n        this(1, null);\n    }\n\n    /**\n     * Creates a new instance of ColumnListHandler.\n     *\n     * @param columnIndex The index of the column to retrieve from the\n     * {@code ResultSet}.\n     */\n    public ColumnListHandler(final int columnIndex) {\n        this(columnIndex, null);\n    }\n\n    /** Private Helper\n     * @param columnIndex The index of the column to retrieve from the\n     * {@code ResultSet}.\n     * @param columnName The name of the column to retrieve from the\n     * {@code ResultSet}.\n     */\n    private ColumnListHandler(final int columnIndex, final String columnName) {\n        this.columnIndex = columnIndex;\n        this.columnName = columnName;\n    }\n\n    /**\n     * Creates a new instance of ColumnListHandler.\n     *\n     * @param columnName The name of the column to retrieve from the\n     * {@code ResultSet}.\n     */\n    public ColumnListHandler(final String columnName) {\n        this(1, columnName);\n    }\n\n    /**\n     * Returns one {@code ResultSet} column value as {@code Object}.\n     * @param resultSet {@code ResultSet} to process.\n     * @return {@code Object}, never {@code null}.\n     *\n     * @throws SQLException if a database access error occurs\n     * @throws ClassCastException if the class datatype does not match the column type\n     *\n     * @see org.apache.commons.dbutils.handlers.AbstractListHandler#handle(ResultSet)\n     */\n    // We assume that the user has picked the correct type to match the column\n    // so getObject will return the appropriate type and the cast will succeed.\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    protected T handleRow(final ResultSet resultSet) throws SQLException {\n        if (this.columnName == null) {\n            return (T) resultSet.getObject(this.columnIndex);\n        }\n        return (T) resultSet.getObject(this.columnName);\n   }\n\n}\n", "file_hash": "534fec1c53bd8229512eece9f8023767f67e4035344584c02b12e8a6b81feb28", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils.handlers;", "import java.sql.ResultSet;", "import java.sql.SQLException;"], "methods": [], "classes": [{"original_string": "public class ColumnListHandler<T> extends AbstractListHandler<T> {\n\n    /**\n     * The column number to retrieve.\n     */\n    private final int columnIndex;\n\n    /**\n     * The column name to retrieve.  Either columnName or columnIndex\n     * will be used but never both.\n     */\n    private final String columnName;\n\n    /**\n     * Creates a new instance of ColumnListHandler.  The first column of each\n     * row will be returned from {@code handle()}.\n     */\n    public ColumnListHandler() {\n        this(1, null);\n    }\n\n    /**\n     * Creates a new instance of ColumnListHandler.\n     *\n     * @param columnIndex The index of the column to retrieve from the\n     * {@code ResultSet}.\n     */\n    public ColumnListHandler(final int columnIndex) {\n        this(columnIndex, null);\n    }\n\n    /** Private Helper\n     * @param columnIndex The index of the column to retrieve from the\n     * {@code ResultSet}.\n     * @param columnName The name of the column to retrieve from the\n     * {@code ResultSet}.\n     */\n    private ColumnListHandler(final int columnIndex, final String columnName) {\n        this.columnIndex = columnIndex;\n        this.columnName = columnName;\n    }\n\n    /**\n     * Creates a new instance of ColumnListHandler.\n     *\n     * @param columnName The name of the column to retrieve from the\n     * {@code ResultSet}.\n     */\n    public ColumnListHandler(final String columnName) {\n        this(1, columnName);\n    }\n\n    /**\n     * Returns one {@code ResultSet} column value as {@code Object}.\n     * @param resultSet {@code ResultSet} to process.\n     * @return {@code Object}, never {@code null}.\n     *\n     * @throws SQLException if a database access error occurs\n     * @throws ClassCastException if the class datatype does not match the column type\n     *\n     * @see org.apache.commons.dbutils.handlers.AbstractListHandler#handle(ResultSet)\n     */\n    // We assume that the user has picked the correct type to match the column\n    // so getObject will return the appropriate type and the cast will succeed.\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    protected T handleRow(final ResultSet resultSet) throws SQLException {\n        if (this.columnName == null) {\n            return (T) resultSet.getObject(this.columnIndex);\n        }\n        return (T) resultSet.getObject(this.columnName);\n   }\n\n}", "definition": "public class ColumnListHandler<T> extends AbstractListHandler<T>", "class_docstring": "\n{@code ResultSetHandler} implementation that converts one\n{@code ResultSet} column into a {@code List} of\n{@code Object}s. This class is thread safe.\n\n@param <T> The type of the column.\n@see org.apache.commons.dbutils.ResultSetHandler\n@since 1.1\n", "name": "ColumnListHandler", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final int columnIndex;", "docstring": "\nThe column number to retrieve.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "columnIndex", "syntax_pass": true}, {"attribute_expression": "private final String columnName;", "docstring": "\nThe column name to retrieve.  Either columnName or columnIndex\nwill be used but never both.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "columnName", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public ColumnListHandler() {\n        this(1, null);\n    }", "docstring": "\nCreates a new instance of ColumnListHandler.  The first column of each\nrow will be returned from {@code handle()}.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ColumnListHandler", "params": [], "body": "                               {\n        this(1, null);\n    }", "signature": "public ColumnListHandler()"}, {"syntax_pass": true, "original_string": "    public ColumnListHandler(final int columnIndex) {\n        this(columnIndex, null);\n    }", "docstring": "\nCreates a new instance of ColumnListHandler.\n\n@param columnIndex The index of the column to retrieve from the\n{@code ResultSet}.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ColumnListHandler", "params": [{"name": "columnIndex", "type": "int"}], "body": "                                                    {\n        this(columnIndex, null);\n    }", "signature": "public ColumnListHandler(final int columnIndex)"}, {"syntax_pass": true, "original_string": "    private ColumnListHandler(final int columnIndex, final String columnName) {\n        this.columnIndex = columnIndex;\n        this.columnName = columnName;\n    }", "docstring": " Private Helper\n@param columnIndex The index of the column to retrieve from the\n{@code ResultSet}.\n@param columnName The name of the column to retrieve from the\n{@code ResultSet}.\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "ColumnListHandler", "params": [{"name": "columnIndex", "type": "int"}, {"name": "columnName", "type": "String"}], "body": "                                                                              {\n        this.columnIndex = columnIndex;\n        this.columnName = columnName;\n    }", "signature": "private ColumnListHandler(final int columnIndex, final String columnName)"}, {"syntax_pass": true, "original_string": "    public ColumnListHandler(final String columnName) {\n        this(1, columnName);\n    }", "docstring": "\nCreates a new instance of ColumnListHandler.\n\n@param columnName The name of the column to retrieve from the\n{@code ResultSet}.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ColumnListHandler", "params": [{"name": "columnName", "type": "String"}], "body": "                                                      {\n        this(1, columnName);\n    }", "signature": "public ColumnListHandler(final String columnName)"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"unchecked\")\n    @Override\n    protected T handleRow(final ResultSet resultSet) throws SQLException {\n        if (this.columnName == null) {\n            return (T) resultSet.getObject(this.columnIndex);\n        }\n        return (T) resultSet.getObject(this.columnName);\n   }", "docstring": " so getObject will return the appropriate type and the cast will succeed.", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n    @Override\n    protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "protected"], "comments": [], "return_type": "T", "classes": []}, "name": "handleRow", "params": [{"name": "resultSet", "type": "ResultSet"}], "body": "                                                                         {\n        if (this.columnName == null) {\n            return (T) resultSet.getObject(this.columnIndex);\n        }\n        return (T) resultSet.getObject(this.columnName);\n   }", "signature": "@SuppressWarnings(\"unchecked\")\n    @Override\n    protected T handleRow(final ResultSet resultSet)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/apache/commons/dbutils/handlers/AbstractListHandler.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils.handlers;\n\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.dbutils.ResultSetHandler;\n\n/**\n * Abstract class that simplify development of {@code ResultSetHandler}\n * classes that convert {@code ResultSet} into {@code List}.\n *\n * @param <T> the target List generic type\n * @see org.apache.commons.dbutils.ResultSetHandler\n */\npublic abstract class AbstractListHandler<T> implements ResultSetHandler<List<T>> {\n\n    /**\n     * Whole {@code ResultSet} handler. It produce {@code List} as\n     * result. To convert individual rows into Java objects it uses\n     * {@code handleRow(ResultSet)} method.\n     *\n     * @see #handleRow(ResultSet)\n     * @param resultSet {@code ResultSet} to process.\n     * @return a list of all rows in the result set\n     * @throws SQLException error occurs\n     */\n    @Override\n    public List<T> handle(final ResultSet resultSet) throws SQLException {\n        final List<T> rows = new ArrayList<>();\n        while (resultSet.next()) {\n            rows.add(this.handleRow(resultSet));\n        }\n        return rows;\n    }\n\n    /**\n     * Row handler. Method converts current row into some Java object.\n     *\n     * @param resultSet {@code ResultSet} to process.\n     * @return row processing result\n     * @throws SQLException error occurs\n     */\n    protected abstract T handleRow(ResultSet resultSet) throws SQLException;\n}\n", "file_hash": "a55becc7883bff01396f3ec72d8b11ce3a23afff7d84c1f8bd8d97ac9627e697", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils.handlers;", "import java.sql.ResultSet;", "import java.sql.SQLException;", "import java.util.ArrayList;", "import java.util.List;", "import org.apache.commons.dbutils.ResultSetHandler;"], "methods": [], "classes": [{"original_string": "public abstract class AbstractListHandler<T> implements ResultSetHandler<List<T>> {\n\n    /**\n     * Whole {@code ResultSet} handler. It produce {@code List} as\n     * result. To convert individual rows into Java objects it uses\n     * {@code handleRow(ResultSet)} method.\n     *\n     * @see #handleRow(ResultSet)\n     * @param resultSet {@code ResultSet} to process.\n     * @return a list of all rows in the result set\n     * @throws SQLException error occurs\n     */\n    @Override\n    public List<T> handle(final ResultSet resultSet) throws SQLException {\n        final List<T> rows = new ArrayList<>();\n        while (resultSet.next()) {\n            rows.add(this.handleRow(resultSet));\n        }\n        return rows;\n    }\n\n    /**\n     * Row handler. Method converts current row into some Java object.\n     *\n     * @param resultSet {@code ResultSet} to process.\n     * @return row processing result\n     * @throws SQLException error occurs\n     */\n    protected abstract T handleRow(ResultSet resultSet) throws SQLException;\n}", "definition": "public abstract class AbstractListHandler<T> implements ResultSetHandler<List<T>>", "class_docstring": "\nAbstract class that simplify development of {@code ResultSetHandler}\nclasses that convert {@code ResultSet} into {@code List}.\n\n@param <T> the target List generic type\n@see org.apache.commons.dbutils.ResultSetHandler\n", "name": "AbstractListHandler", "super_interfaces": ["ResultSetHandler<List<T>>"], "superclasses": "", "attributes": {"modifiers": "public abstract", "marker_annotations": [], "non_marker_annotations": ["public", "abstract"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Override\n    public List<T> handle(final ResultSet resultSet) throws SQLException {\n        final List<T> rows = new ArrayList<>();\n        while (resultSet.next()) {\n            rows.add(this.handleRow(resultSet));\n        }\n        return rows;\n    }", "docstring": "\nWhole {@code ResultSet} handler. It produce {@code List} as\nresult. To convert individual rows into Java objects it uses\n{@code handleRow(ResultSet)} method.\n\n@see #handleRow(ResultSet)\n@param resultSet {@code ResultSet} to process.\n@return a list of all rows in the result set\n@throws SQLException error occurs\n", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<T>", "classes": []}, "name": "handle", "params": [{"name": "resultSet", "type": "ResultSet"}], "body": "                                                                         {\n        final List<T> rows = new ArrayList<>();\n        while (resultSet.next()) {\n            rows.add(this.handleRow(resultSet));\n        }\n        return rows;\n    }", "signature": "@Override\n    public List<T> handle(final ResultSet resultSet)"}, {"syntax_pass": true, "original_string": "    protected abstract T handleRow(ResultSet resultSet) throws SQLException;", "docstring": "\nRow handler. Method converts current row into some Java object.\n\n@param resultSet {@code ResultSet} to process.\n@return row processing result\n@throws SQLException error occurs\n", "attributes": {"modifiers": "protected abstract", "marker_annotations": [], "non_marker_annotations": ["protected", "abstract"], "comments": [], "return_type": "T", "classes": []}, "name": "handleRow", "params": [{"name": "resultSet", "type": "ResultSet"}], "body": "", "signature": "protected abstract T handleRow(ResultSet resultSet)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/apache/commons/dbutils/handlers/AbstractKeyedHandler.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils.handlers;\n\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.apache.commons.dbutils.ResultSetHandler;\n\n/**\n * <p>\n * {@code ResultSetHandler} implementation that returns a Map.\n * {@code ResultSet} rows are converted into objects (Vs) which are then stored\n * in a Map under the given keys (Ks).\n * </p>\n *\n * @param <K> the type of keys maintained by the returned map\n * @param <V> the type of mapped values\n * @see org.apache.commons.dbutils.ResultSetHandler\n * @since 1.3\n */\npublic abstract class AbstractKeyedHandler<K, V> implements ResultSetHandler<Map<K, V>> {\n\n    /**\n     * This factory method is called by {@code handle()} to retrieve the\n     * key value from the current {@code ResultSet} row.\n     * @param resultSet ResultSet to create a key from\n     * @return K from the configured key column name/index\n     * @throws SQLException if a database access error occurs\n     */\n    protected abstract K createKey(ResultSet resultSet) throws SQLException;\n\n    /**\n     * This factory method is called by {@code handle()} to create the Map\n     * to store records in.  This implementation returns a {@code HashMap}\n     * instance.\n     *\n     * @return Map to store records in\n     */\n    protected Map<K, V> createMap() {\n        return new HashMap<>();\n    }\n\n    /**\n     * This factory method is called by {@code handle()} to store the\n     * current {@code ResultSet} row in some object.\n     * @param resultSet ResultSet to create a row from\n     * @return V object created from the current row\n     * @throws SQLException if a database access error occurs\n     */\n    protected abstract V createRow(ResultSet resultSet) throws SQLException;\n\n    /**\n     * Convert each row's columns into a Map and store then\n     * in a {@code Map} under {@code ResultSet.getObject(key)} key.\n     * @param resultSet {@code ResultSet} to process.\n     * @return A {@code Map}, never {@code null}.\n     * @throws SQLException if a database access error occurs\n     * @see org.apache.commons.dbutils.ResultSetHandler#handle(java.sql.ResultSet)\n     */\n    @Override\n    public Map<K, V> handle(final ResultSet resultSet) throws SQLException {\n        final Map<K, V> result = createMap();\n        while (resultSet.next()) {\n            result.put(createKey(resultSet), createRow(resultSet));\n        }\n        return result;\n    }\n\n}\n", "file_hash": "207855636ce1288b592bcddf620c448550056e9e55f642fed1bb5caa75cd292c", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils.handlers;", "import java.sql.ResultSet;", "import java.sql.SQLException;", "import java.util.HashMap;", "import java.util.Map;", "import org.apache.commons.dbutils.ResultSetHandler;"], "methods": [], "classes": [{"original_string": "public abstract class AbstractKeyedHandler<K, V> implements ResultSetHandler<Map<K, V>> {\n\n    /**\n     * This factory method is called by {@code handle()} to retrieve the\n     * key value from the current {@code ResultSet} row.\n     * @param resultSet ResultSet to create a key from\n     * @return K from the configured key column name/index\n     * @throws SQLException if a database access error occurs\n     */\n    protected abstract K createKey(ResultSet resultSet) throws SQLException;\n\n    /**\n     * This factory method is called by {@code handle()} to create the Map\n     * to store records in.  This implementation returns a {@code HashMap}\n     * instance.\n     *\n     * @return Map to store records in\n     */\n    protected Map<K, V> createMap() {\n        return new HashMap<>();\n    }\n\n    /**\n     * This factory method is called by {@code handle()} to store the\n     * current {@code ResultSet} row in some object.\n     * @param resultSet ResultSet to create a row from\n     * @return V object created from the current row\n     * @throws SQLException if a database access error occurs\n     */\n    protected abstract V createRow(ResultSet resultSet) throws SQLException;\n\n    /**\n     * Convert each row's columns into a Map and store then\n     * in a {@code Map} under {@code ResultSet.getObject(key)} key.\n     * @param resultSet {@code ResultSet} to process.\n     * @return A {@code Map}, never {@code null}.\n     * @throws SQLException if a database access error occurs\n     * @see org.apache.commons.dbutils.ResultSetHandler#handle(java.sql.ResultSet)\n     */\n    @Override\n    public Map<K, V> handle(final ResultSet resultSet) throws SQLException {\n        final Map<K, V> result = createMap();\n        while (resultSet.next()) {\n            result.put(createKey(resultSet), createRow(resultSet));\n        }\n        return result;\n    }\n\n}", "definition": "public abstract class AbstractKeyedHandler<K, V> implements ResultSetHandler<Map<K, V>>", "class_docstring": "\n<p>\n{@code ResultSetHandler} implementation that returns a Map.\n{@code ResultSet} rows are converted into objects (Vs) which are then stored\nin a Map under the given keys (Ks).\n</p>\n\n@param <K> the type of keys maintained by the returned map\n@param <V> the type of mapped values\n@see org.apache.commons.dbutils.ResultSetHandler\n@since 1.3\n", "name": "AbstractKeyedHandler", "super_interfaces": ["ResultSetHandler<Map<K, V>>"], "superclasses": "", "attributes": {"modifiers": "public abstract", "marker_annotations": [], "non_marker_annotations": ["public", "abstract"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    protected abstract K createKey(ResultSet resultSet) throws SQLException;", "docstring": "\nThis factory method is called by {@code handle()} to retrieve the\nkey value from the current {@code ResultSet} row.\n@param resultSet ResultSet to create a key from\n@return K from the configured key column name/index\n@throws SQLException if a database access error occurs\n", "attributes": {"modifiers": "protected abstract", "marker_annotations": [], "non_marker_annotations": ["protected", "abstract"], "comments": [], "return_type": "K", "classes": []}, "name": "createKey", "params": [{"name": "resultSet", "type": "ResultSet"}], "body": "", "signature": "protected abstract K createKey(ResultSet resultSet)"}, {"syntax_pass": true, "original_string": "    protected Map<K, V> createMap() {\n        return new HashMap<>();\n    }", "docstring": "\nThis factory method is called by {@code handle()} to create the Map\nto store records in.  This implementation returns a {@code HashMap}\ninstance.\n\n@return Map to store records in\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Map<K, V>", "classes": []}, "name": "createMap", "params": [], "body": "                                    {\n        return new HashMap<>();\n    }", "signature": "protected Map<K, V> createMap()"}, {"syntax_pass": true, "original_string": "    protected abstract V createRow(ResultSet resultSet) throws SQLException;", "docstring": "\nThis factory method is called by {@code handle()} to store the\ncurrent {@code ResultSet} row in some object.\n@param resultSet ResultSet to create a row from\n@return V object created from the current row\n@throws SQLException if a database access error occurs\n", "attributes": {"modifiers": "protected abstract", "marker_annotations": [], "non_marker_annotations": ["protected", "abstract"], "comments": [], "return_type": "V", "classes": []}, "name": "createRow", "params": [{"name": "resultSet", "type": "ResultSet"}], "body": "", "signature": "protected abstract V createRow(ResultSet resultSet)"}, {"syntax_pass": true, "original_string": "    @Override\n    public Map<K, V> handle(final ResultSet resultSet) throws SQLException {\n        final Map<K, V> result = createMap();\n        while (resultSet.next()) {\n            result.put(createKey(resultSet), createRow(resultSet));\n        }\n        return result;\n    }", "docstring": "\nConvert each row's columns into a Map and store then\nin a {@code Map} under {@code ResultSet.getObject(key)} key.\n@param resultSet {@code ResultSet} to process.\n@return A {@code Map}, never {@code null}.\n@throws SQLException if a database access error occurs\n@see org.apache.commons.dbutils.ResultSetHandler#handle(java.sql.ResultSet)\n", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map<K, V>", "classes": []}, "name": "handle", "params": [{"name": "resultSet", "type": "ResultSet"}], "body": "                                                                           {\n        final Map<K, V> result = createMap();\n        while (resultSet.next()) {\n            result.put(createKey(resultSet), createRow(resultSet));\n        }\n        return result;\n    }", "signature": "@Override\n    public Map<K, V> handle(final ResultSet resultSet)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/apache/commons/dbutils/handlers/BeanListHandler.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils.handlers;\n\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.List;\n\nimport org.apache.commons.dbutils.ResultSetHandler;\nimport org.apache.commons.dbutils.RowProcessor;\n\n/**\n * {@code ResultSetHandler} implementation that converts a\n * {@code ResultSet} into a {@code List} of beans. This class is\n * thread safe.\n *\n * @param <T> the target bean type\n * @see org.apache.commons.dbutils.ResultSetHandler\n */\npublic class BeanListHandler<T> implements ResultSetHandler<List<T>> {\n\n    /**\n     * The Class of beans produced by this handler.\n     */\n    private final Class<? extends T> type;\n\n    /**\n     * The RowProcessor implementation to use when converting rows\n     * into beans.\n     */\n    private final RowProcessor convert;\n\n    /**\n     * Creates a new instance of BeanListHandler.\n     *\n     * @param type The Class that objects returned from {@code handle()}\n     * are created from.\n     */\n    public BeanListHandler(final Class<? extends T> type) {\n        this(type, ArrayHandler.ROW_PROCESSOR);\n    }\n\n    /**\n     * Creates a new instance of BeanListHandler.\n     *\n     * @param type The Class that objects returned from {@code handle()}\n     * are created from.\n     * @param convert The {@code RowProcessor} implementation\n     * to use when converting rows into beans.\n     */\n    public BeanListHandler(final Class<? extends T> type, final RowProcessor convert) {\n        this.type = type;\n        this.convert = convert;\n    }\n\n    /**\n     * Convert the whole {@code ResultSet} into a List of beans with\n     * the {@code Class} given in the constructor.\n     *\n     * @param resultSet The {@code ResultSet} to handle.\n     *\n     * @return A List of beans, never {@code null}.\n     *\n     * @throws SQLException if a database access error occurs\n     * @see org.apache.commons.dbutils.RowProcessor#toBeanList(ResultSet, Class)\n     */\n    @Override\n    public List<T> handle(final ResultSet resultSet) throws SQLException {\n        return this.convert.toBeanList(resultSet, type);\n    }\n}\n", "file_hash": "ccb53a812969d0d0a42fd8c322d5a87fb49b794b0528e290ecf3c42ab71dd20b", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils.handlers;", "import java.sql.ResultSet;", "import java.sql.SQLException;", "import java.util.List;", "import org.apache.commons.dbutils.ResultSetHandler;", "import org.apache.commons.dbutils.RowProcessor;"], "methods": [], "classes": [{"original_string": "public class BeanListHandler<T> implements ResultSetHandler<List<T>> {\n\n    /**\n     * The Class of beans produced by this handler.\n     */\n    private final Class<? extends T> type;\n\n    /**\n     * The RowProcessor implementation to use when converting rows\n     * into beans.\n     */\n    private final RowProcessor convert;\n\n    /**\n     * Creates a new instance of BeanListHandler.\n     *\n     * @param type The Class that objects returned from {@code handle()}\n     * are created from.\n     */\n    public BeanListHandler(final Class<? extends T> type) {\n        this(type, ArrayHandler.ROW_PROCESSOR);\n    }\n\n    /**\n     * Creates a new instance of BeanListHandler.\n     *\n     * @param type The Class that objects returned from {@code handle()}\n     * are created from.\n     * @param convert The {@code RowProcessor} implementation\n     * to use when converting rows into beans.\n     */\n    public BeanListHandler(final Class<? extends T> type, final RowProcessor convert) {\n        this.type = type;\n        this.convert = convert;\n    }\n\n    /**\n     * Convert the whole {@code ResultSet} into a List of beans with\n     * the {@code Class} given in the constructor.\n     *\n     * @param resultSet The {@code ResultSet} to handle.\n     *\n     * @return A List of beans, never {@code null}.\n     *\n     * @throws SQLException if a database access error occurs\n     * @see org.apache.commons.dbutils.RowProcessor#toBeanList(ResultSet, Class)\n     */\n    @Override\n    public List<T> handle(final ResultSet resultSet) throws SQLException {\n        return this.convert.toBeanList(resultSet, type);\n    }\n}", "definition": "public class BeanListHandler<T> implements ResultSetHandler<List<T>>", "class_docstring": "\n{@code ResultSetHandler} implementation that converts a\n{@code ResultSet} into a {@code List} of beans. This class is\nthread safe.\n\n@param <T> the target bean type\n@see org.apache.commons.dbutils.ResultSetHandler\n", "name": "BeanListHandler", "super_interfaces": ["ResultSetHandler<List<T>>"], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final Class<? extends T> type;", "docstring": "\nThe Class of beans produced by this handler.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Class<? extends T>", "name": "type", "syntax_pass": true}, {"attribute_expression": "private final RowProcessor convert;", "docstring": "\nThe RowProcessor implementation to use when converting rows\ninto beans.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "RowProcessor", "name": "convert", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public BeanListHandler(final Class<? extends T> type) {\n        this(type, ArrayHandler.ROW_PROCESSOR);\n    }", "docstring": "\nCreates a new instance of BeanListHandler.\n\n@param type The Class that objects returned from {@code handle()}\nare created from.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "BeanListHandler", "params": [{"name": "type", "type": "Class<? extends T>"}], "body": "                                                          {\n        this(type, ArrayHandler.ROW_PROCESSOR);\n    }", "signature": "public BeanListHandler(final Class<? extends T> type)"}, {"syntax_pass": true, "original_string": "    public BeanListHandler(final Class<? extends T> type, final RowProcessor convert) {\n        this.type = type;\n        this.convert = convert;\n    }", "docstring": "\nCreates a new instance of BeanListHandler.\n\n@param type The Class that objects returned from {@code handle()}\nare created from.\n@param convert The {@code RowProcessor} implementation\nto use when converting rows into beans.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "BeanListHandler", "params": [{"name": "type", "type": "Class<? extends T>"}, {"name": "convert", "type": "RowProcessor"}], "body": "                                                                                      {\n        this.type = type;\n        this.convert = convert;\n    }", "signature": "public BeanListHandler(final Class<? extends T> type, final RowProcessor convert)"}, {"syntax_pass": true, "original_string": "    @Override\n    public List<T> handle(final ResultSet resultSet) throws SQLException {\n        return this.convert.toBeanList(resultSet, type);\n    }", "docstring": "\nConvert the whole {@code ResultSet} into a List of beans with\nthe {@code Class} given in the constructor.\n\n@param resultSet The {@code ResultSet} to handle.\n\n@return A List of beans, never {@code null}.\n\n@throws SQLException if a database access error occurs\n@see org.apache.commons.dbutils.RowProcessor#toBeanList(ResultSet, Class)\n", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<T>", "classes": []}, "name": "handle", "params": [{"name": "resultSet", "type": "ResultSet"}], "body": "                                                                         {\n        return this.convert.toBeanList(resultSet, type);\n    }", "signature": "@Override\n    public List<T> handle(final ResultSet resultSet)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/apache/commons/dbutils/handlers/KeyedHandler.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils.handlers;\n\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Map;\n\nimport org.apache.commons.dbutils.RowProcessor;\n\n/**\n * <p>\n * {@code ResultSetHandler} implementation that returns a Map of Maps.\n * {@code ResultSet} rows are converted into Maps which are then stored\n * in a Map under the given key.\n * </p>\n * <p>\n * If you had a Person table with a primary key column called ID, you could\n * retrieve rows from the table like this:\n * <pre>\n * ResultSetHandler h = new KeyedHandler(\"id\");\n * Map found = (Map) queryRunner.query(\"select id, name, age from person\", h);\n * Map jane = (Map) found.get(new Long(1)); // jane's id is 1\n * String janesName = (String) jane.get(\"name\");\n * Integer janesAge = (Integer) jane.get(\"age\");\n * </pre>\n * Note that the \"id\" passed to KeyedHandler and \"name\" and \"age\" passed to the\n * returned Map's get() method can be in any case.  The data types returned for\n * name and age are dependent upon how your JDBC driver converts SQL column\n * types from the Person table into Java types.\n * &lt;/p&gt;\n * <p>This class is thread safe.</p>\n *\n * @param <K> The type of the key\n * @see org.apache.commons.dbutils.ResultSetHandler\n * @since 1.1\n */\npublic class KeyedHandler<K> extends AbstractKeyedHandler<K, Map<String, Object>> {\n\n    /**\n     * The RowProcessor implementation to use when converting rows\n     * into Objects.\n     */\n    protected final RowProcessor convert;\n\n    /**\n     * The column index to retrieve key values from.  Defaults to 1.\n     */\n    protected final int columnIndex;\n\n    /**\n     * The column name to retrieve key values from.  Either columnName or\n     * columnIndex will be used but never both.\n     */\n    protected final String columnName;\n\n    /**\n     * Creates a new instance of KeyedHandler.  The value of the first column\n     * of each row will be a key in the Map.\n     */\n    public KeyedHandler() {\n        this(ArrayHandler.ROW_PROCESSOR, 1, null);\n    }\n\n    /**\n     * Creates a new instance of KeyedHandler.\n     *\n     * @param columnIndex The values to use as keys in the Map are\n     * retrieved from the column at this index.\n     */\n    public KeyedHandler(final int columnIndex) {\n        this(ArrayHandler.ROW_PROCESSOR, columnIndex, null);\n    }\n\n    /**\n     * Creates a new instance of KeyedHandler.  The value of the first column\n     * of each row will be a key in the Map.\n     *\n     * @param convert The {@code RowProcessor} implementation\n     * to use when converting rows into Maps\n     */\n    public KeyedHandler(final RowProcessor convert) {\n        this(convert, 1, null);\n    }\n\n    /** Private Helper\n     * @param convert The {@code RowProcessor} implementation\n     * to use when converting rows into Maps\n     * @param columnIndex The values to use as keys in the Map are\n     * retrieved from the column at this index.\n     * @param columnName The values to use as keys in the Map are\n     * retrieved from the column with this name.\n     */\n    private KeyedHandler(final RowProcessor convert, final int columnIndex,\n            final String columnName) {\n        this.convert = convert;\n        this.columnIndex = columnIndex;\n        this.columnName = columnName;\n    }\n\n    /**\n     * Creates a new instance of KeyedHandler.\n     *\n     * @param columnName The values to use as keys in the Map are\n     * retrieved from the column with this name.\n     */\n    public KeyedHandler(final String columnName) {\n        this(ArrayHandler.ROW_PROCESSOR, 1, columnName);\n    }\n    /**\n     * This factory method is called by {@code handle()} to retrieve the\n     * key value from the current {@code ResultSet} row.  This\n     * implementation returns {@code ResultSet.getObject()} for the\n     * configured key column name or index.\n     * @param rs ResultSet to create a key from\n     * @return Object from the configured key column name/index\n     *\n     * @throws SQLException if a database access error occurs\n     * @throws ClassCastException if the class datatype does not match the column type\n     */\n    // We assume that the user has picked the correct type to match the column\n    // so getObject will return the appropriate type and the cast will succeed.\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    protected K createKey(final ResultSet rs) throws SQLException {\n        return columnName == null ?\n               (K) rs.getObject(columnIndex) :\n               (K) rs.getObject(columnName);\n    }\n\n    /**\n     * This factory method is called by {@code handle()} to store the\n     * current {@code ResultSet} row in some object. This\n     * implementation returns a {@code Map} with case insensitive column\n     * names as keys.  Calls to {@code map.get(\"COL\")} and\n     * {@code map.get(\"col\")} return the same value.\n     * @param resultSet ResultSet to create a row from\n     * @return Object typed Map containing column names to values\n     * @throws SQLException if a database access error occurs\n     */\n    @Override\n    protected Map<String, Object> createRow(final ResultSet resultSet) throws SQLException {\n        return this.convert.toMap(resultSet);\n    }\n\n}\n", "file_hash": "6de1bb641ae4c502f502881d59937f39cd5a596898ae5102507d80ffa43d819f", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils.handlers;", "import java.sql.ResultSet;", "import java.sql.SQLException;", "import java.util.Map;", "import org.apache.commons.dbutils.RowProcessor;"], "methods": [], "classes": [{"original_string": "public class KeyedHandler<K> extends AbstractKeyedHandler<K, Map<String, Object>> {\n\n    /**\n     * The RowProcessor implementation to use when converting rows\n     * into Objects.\n     */\n    protected final RowProcessor convert;\n\n    /**\n     * The column index to retrieve key values from.  Defaults to 1.\n     */\n    protected final int columnIndex;\n\n    /**\n     * The column name to retrieve key values from.  Either columnName or\n     * columnIndex will be used but never both.\n     */\n    protected final String columnName;\n\n    /**\n     * Creates a new instance of KeyedHandler.  The value of the first column\n     * of each row will be a key in the Map.\n     */\n    public KeyedHandler() {\n        this(ArrayHandler.ROW_PROCESSOR, 1, null);\n    }\n\n    /**\n     * Creates a new instance of KeyedHandler.\n     *\n     * @param columnIndex The values to use as keys in the Map are\n     * retrieved from the column at this index.\n     */\n    public KeyedHandler(final int columnIndex) {\n        this(ArrayHandler.ROW_PROCESSOR, columnIndex, null);\n    }\n\n    /**\n     * Creates a new instance of KeyedHandler.  The value of the first column\n     * of each row will be a key in the Map.\n     *\n     * @param convert The {@code RowProcessor} implementation\n     * to use when converting rows into Maps\n     */\n    public KeyedHandler(final RowProcessor convert) {\n        this(convert, 1, null);\n    }\n\n    /** Private Helper\n     * @param convert The {@code RowProcessor} implementation\n     * to use when converting rows into Maps\n     * @param columnIndex The values to use as keys in the Map are\n     * retrieved from the column at this index.\n     * @param columnName The values to use as keys in the Map are\n     * retrieved from the column with this name.\n     */\n    private KeyedHandler(final RowProcessor convert, final int columnIndex,\n            final String columnName) {\n        this.convert = convert;\n        this.columnIndex = columnIndex;\n        this.columnName = columnName;\n    }\n\n    /**\n     * Creates a new instance of KeyedHandler.\n     *\n     * @param columnName The values to use as keys in the Map are\n     * retrieved from the column with this name.\n     */\n    public KeyedHandler(final String columnName) {\n        this(ArrayHandler.ROW_PROCESSOR, 1, columnName);\n    }\n    /**\n     * This factory method is called by {@code handle()} to retrieve the\n     * key value from the current {@code ResultSet} row.  This\n     * implementation returns {@code ResultSet.getObject()} for the\n     * configured key column name or index.\n     * @param rs ResultSet to create a key from\n     * @return Object from the configured key column name/index\n     *\n     * @throws SQLException if a database access error occurs\n     * @throws ClassCastException if the class datatype does not match the column type\n     */\n    // We assume that the user has picked the correct type to match the column\n    // so getObject will return the appropriate type and the cast will succeed.\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    protected K createKey(final ResultSet rs) throws SQLException {\n        return columnName == null ?\n               (K) rs.getObject(columnIndex) :\n               (K) rs.getObject(columnName);\n    }\n\n    /**\n     * This factory method is called by {@code handle()} to store the\n     * current {@code ResultSet} row in some object. This\n     * implementation returns a {@code Map} with case insensitive column\n     * names as keys.  Calls to {@code map.get(\"COL\")} and\n     * {@code map.get(\"col\")} return the same value.\n     * @param resultSet ResultSet to create a row from\n     * @return Object typed Map containing column names to values\n     * @throws SQLException if a database access error occurs\n     */\n    @Override\n    protected Map<String, Object> createRow(final ResultSet resultSet) throws SQLException {\n        return this.convert.toMap(resultSet);\n    }\n\n}", "definition": "public class KeyedHandler<K> extends AbstractKeyedHandler<K, Map<String, Object>>", "class_docstring": "\n<p>\n{@code ResultSetHandler} implementation that returns a Map of Maps.\n{@code ResultSet} rows are converted into Maps which are then stored\nin a Map under the given key.\n</p>\n<p>\nIf you had a Person table with a primary key column called ID, you could\nretrieve rows from the table like this:\n<pre>\nResultSetHandler h = new KeyedHandler(\"id\");\nMap found = (Map) queryRunner.query(\"select id, name, age from person\", h);\nMap jane = (Map) found.get(new Long(1)); // jane's id is 1\nString janesName = (String) jane.get(\"name\");\nInteger janesAge = (Integer) jane.get(\"age\");\n</pre>\nNote that the \"id\" passed to KeyedHandler and \"name\" and \"age\" passed to the\nreturned Map's get() method can be in any case.  The data types returned for\nname and age are dependent upon how your JDBC driver converts SQL column\ntypes from the Person table into Java types.\n&lt;/p&gt;\n<p>This class is thread safe.</p>\n\n@param <K> The type of the key\n@see org.apache.commons.dbutils.ResultSetHandler\n@since 1.1\n", "name": "KeyedHandler", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "protected final RowProcessor convert;", "docstring": "\nThe RowProcessor implementation to use when converting rows\ninto Objects.\n", "modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "type": "RowProcessor", "name": "convert", "syntax_pass": true}, {"attribute_expression": "protected final int columnIndex;", "docstring": "\nThe column index to retrieve key values from.  Defaults to 1.\n", "modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "type": "int", "name": "columnIndex", "syntax_pass": true}, {"attribute_expression": "protected final String columnName;", "docstring": "\nThe column name to retrieve key values from.  Either columnName or\ncolumnIndex will be used but never both.\n", "modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "type": "String", "name": "columnName", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public KeyedHandler() {\n        this(ArrayHandler.ROW_PROCESSOR, 1, null);\n    }", "docstring": "\nCreates a new instance of KeyedHandler.  The value of the first column\nof each row will be a key in the Map.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "KeyedHandler", "params": [], "body": "                          {\n        this(ArrayHandler.ROW_PROCESSOR, 1, null);\n    }", "signature": "public KeyedHandler()"}, {"syntax_pass": true, "original_string": "    public KeyedHandler(final int columnIndex) {\n        this(ArrayHandler.ROW_PROCESSOR, columnIndex, null);\n    }", "docstring": "\nCreates a new instance of KeyedHandler.\n\n@param columnIndex The values to use as keys in the Map are\nretrieved from the column at this index.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "KeyedHandler", "params": [{"name": "columnIndex", "type": "int"}], "body": "                                               {\n        this(ArrayHandler.ROW_PROCESSOR, columnIndex, null);\n    }", "signature": "public KeyedHandler(final int columnIndex)"}, {"syntax_pass": true, "original_string": "    public KeyedHandler(final RowProcessor convert) {\n        this(convert, 1, null);\n    }", "docstring": "\nCreates a new instance of KeyedHandler.  The value of the first column\nof each row will be a key in the Map.\n\n@param convert The {@code RowProcessor} implementation\nto use when converting rows into Maps\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "KeyedHandler", "params": [{"name": "convert", "type": "RowProcessor"}], "body": "                                                    {\n        this(convert, 1, null);\n    }", "signature": "public KeyedHandler(final RowProcessor convert)"}, {"syntax_pass": true, "original_string": "    private KeyedHandler(final RowProcessor convert, final int columnIndex,\n            final String columnName) {\n        this.convert = convert;\n        this.columnIndex = columnIndex;\n        this.columnName = columnName;\n    }", "docstring": " Private Helper\n@param convert The {@code RowProcessor} implementation\nto use when converting rows into Maps\n@param columnIndex The values to use as keys in the Map are\nretrieved from the column at this index.\n@param columnName The values to use as keys in the Map are\nretrieved from the column with this name.\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "KeyedHandler", "params": [{"name": "convert", "type": "RowProcessor"}, {"name": "columnIndex", "type": "int"}, {"name": "columnName", "type": "String"}], "body": "                                     {\n        this.convert = convert;\n        this.columnIndex = columnIndex;\n        this.columnName = columnName;\n    }", "signature": "private KeyedHandler(final RowProcessor convert, final int columnIndex,\n            final String columnName)"}, {"syntax_pass": true, "original_string": "    public KeyedHandler(final String columnName) {\n        this(ArrayHandler.ROW_PROCESSOR, 1, columnName);\n    }", "docstring": "\nCreates a new instance of KeyedHandler.\n\n@param columnName The values to use as keys in the Map are\nretrieved from the column with this name.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "KeyedHandler", "params": [{"name": "columnName", "type": "String"}], "body": "                                                 {\n        this(ArrayHandler.ROW_PROCESSOR, 1, columnName);\n    }", "signature": "public KeyedHandler(final String columnName)"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"unchecked\")\n    @Override\n    protected K createKey(final ResultSet rs) throws SQLException {\n        return columnName == null ?\n               (K) rs.getObject(columnIndex) :\n               (K) rs.getObject(columnName);\n    }", "docstring": " so getObject will return the appropriate type and the cast will succeed.", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n    @Override\n    protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "protected"], "comments": [], "return_type": "K", "classes": []}, "name": "createKey", "params": [{"name": "rs", "type": "ResultSet"}], "body": "                                                                  {\n        return columnName == null ?\n               (K) rs.getObject(columnIndex) :\n               (K) rs.getObject(columnName);\n    }", "signature": "@SuppressWarnings(\"unchecked\")\n    @Override\n    protected K createKey(final ResultSet rs)"}, {"syntax_pass": true, "original_string": "    @Override\n    protected Map<String, Object> createRow(final ResultSet resultSet) throws SQLException {\n        return this.convert.toMap(resultSet);\n    }", "docstring": "\nThis factory method is called by {@code handle()} to store the\ncurrent {@code ResultSet} row in some object. This\nimplementation returns a {@code Map} with case insensitive column\nnames as keys.  Calls to {@code map.get(\"COL\")} and\n{@code map.get(\"col\")} return the same value.\n@param resultSet ResultSet to create a row from\n@return Object typed Map containing column names to values\n@throws SQLException if a database access error occurs\n", "attributes": {"modifiers": "@Override\n    protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Map<String, Object>", "classes": []}, "name": "createRow", "params": [{"name": "resultSet", "type": "ResultSet"}], "body": "                                                                                           {\n        return this.convert.toMap(resultSet);\n    }", "signature": "@Override\n    protected Map<String, Object> createRow(final ResultSet resultSet)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/apache/commons/dbutils/handlers/ArrayListHandler.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils.handlers;\n\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\n\nimport org.apache.commons.dbutils.RowProcessor;\n\n/**\n * {@code ResultSetHandler} implementation that converts the\n * {@code ResultSet} into a {@code List} of {@code Object[]}s.\n * This class is thread safe.\n *\n * @see org.apache.commons.dbutils.ResultSetHandler\n */\npublic class ArrayListHandler extends AbstractListHandler<Object[]> {\n\n    /**\n     * The RowProcessor implementation to use when converting rows\n     * into Object[]s.\n     */\n    private final RowProcessor convert;\n\n    /**\n     * Creates a new instance of ArrayListHandler using a\n     * {@code BasicRowProcessor} for conversions.\n     */\n    public ArrayListHandler() {\n        this(ArrayHandler.ROW_PROCESSOR);\n    }\n\n    /**\n     * Creates a new instance of ArrayListHandler.\n     *\n     * @param convert The {@code RowProcessor} implementation\n     * to use when converting rows into Object[]s.\n     */\n    public ArrayListHandler(final RowProcessor convert) {\n        this.convert = convert;\n    }\n\n    /**\n     * Convert row's columns into an {@code Object[]}.\n     * @param resultSet {@code ResultSet} to process.\n     * @return {@code Object[]}, never {@code null}.\n     *\n     * @throws SQLException if a database access error occurs\n     * @see org.apache.commons.dbutils.handlers.AbstractListHandler#handle(ResultSet)\n     */\n    @Override\n    protected Object[] handleRow(final ResultSet resultSet) throws SQLException {\n        return this.convert.toArray(resultSet);\n    }\n\n}\n", "file_hash": "5f2000c79d50602711bd22252de0dad1e737d26a8d79e68a217dd23a3a0bf8bd", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils.handlers;", "import java.sql.ResultSet;", "import java.sql.SQLException;", "import org.apache.commons.dbutils.RowProcessor;"], "methods": [], "classes": [{"original_string": "public class ArrayListHandler extends AbstractListHandler<Object[]> {\n\n    /**\n     * The RowProcessor implementation to use when converting rows\n     * into Object[]s.\n     */\n    private final RowProcessor convert;\n\n    /**\n     * Creates a new instance of ArrayListHandler using a\n     * {@code BasicRowProcessor} for conversions.\n     */\n    public ArrayListHandler() {\n        this(ArrayHandler.ROW_PROCESSOR);\n    }\n\n    /**\n     * Creates a new instance of ArrayListHandler.\n     *\n     * @param convert The {@code RowProcessor} implementation\n     * to use when converting rows into Object[]s.\n     */\n    public ArrayListHandler(final RowProcessor convert) {\n        this.convert = convert;\n    }\n\n    /**\n     * Convert row's columns into an {@code Object[]}.\n     * @param resultSet {@code ResultSet} to process.\n     * @return {@code Object[]}, never {@code null}.\n     *\n     * @throws SQLException if a database access error occurs\n     * @see org.apache.commons.dbutils.handlers.AbstractListHandler#handle(ResultSet)\n     */\n    @Override\n    protected Object[] handleRow(final ResultSet resultSet) throws SQLException {\n        return this.convert.toArray(resultSet);\n    }\n\n}", "definition": "public class ArrayListHandler extends AbstractListHandler<Object[]>", "class_docstring": "\n{@code ResultSetHandler} implementation that converts the\n{@code ResultSet} into a {@code List} of {@code Object[]}s.\nThis class is thread safe.\n\n@see org.apache.commons.dbutils.ResultSetHandler\n", "name": "ArrayListHandler", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final RowProcessor convert;", "docstring": "\nThe RowProcessor implementation to use when converting rows\ninto Object[]s.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "RowProcessor", "name": "convert", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public ArrayListHandler() {\n        this(ArrayHandler.ROW_PROCESSOR);\n    }", "docstring": "\nCreates a new instance of ArrayListHandler using a\n{@code BasicRowProcessor} for conversions.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ArrayListHandler", "params": [], "body": "                              {\n        this(ArrayHandler.ROW_PROCESSOR);\n    }", "signature": "public ArrayListHandler()"}, {"syntax_pass": true, "original_string": "    public ArrayListHandler(final RowProcessor convert) {\n        this.convert = convert;\n    }", "docstring": "\nCreates a new instance of ArrayListHandler.\n\n@param convert The {@code RowProcessor} implementation\nto use when converting rows into Object[]s.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ArrayListHandler", "params": [{"name": "convert", "type": "RowProcessor"}], "body": "                                                        {\n        this.convert = convert;\n    }", "signature": "public ArrayListHandler(final RowProcessor convert)"}, {"syntax_pass": true, "original_string": "    @Override\n    protected Object[] handleRow(final ResultSet resultSet) throws SQLException {\n        return this.convert.toArray(resultSet);\n    }", "docstring": "\nConvert row's columns into an {@code Object[]}.\n@param resultSet {@code ResultSet} to process.\n@return {@code Object[]}, never {@code null}.\n\n@throws SQLException if a database access error occurs\n@see org.apache.commons.dbutils.handlers.AbstractListHandler#handle(ResultSet)\n", "attributes": {"modifiers": "@Override\n    protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Object[]", "classes": []}, "name": "handleRow", "params": [{"name": "resultSet", "type": "ResultSet"}], "body": "                                                                                {\n        return this.convert.toArray(resultSet);\n    }", "signature": "@Override\n    protected Object[] handleRow(final ResultSet resultSet)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/apache/commons/dbutils/handlers/MapListHandler.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils.handlers;\n\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Map;\n\nimport org.apache.commons.dbutils.RowProcessor;\n\n/**\n * {@code ResultSetHandler} implementation that converts a\n * {@code ResultSet} into a {@code List} of {@code Map}s.\n * This class is thread safe.\n *\n * @see org.apache.commons.dbutils.ResultSetHandler\n */\npublic class MapListHandler extends AbstractListHandler<Map<String, Object>> {\n\n    /**\n     * The RowProcessor implementation to use when converting rows\n     * into Maps.\n     */\n    private final RowProcessor convert;\n\n    /**\n     * Creates a new instance of MapListHandler using a\n     * {@code BasicRowProcessor} for conversion.\n     */\n    public MapListHandler() {\n        this(ArrayHandler.ROW_PROCESSOR);\n    }\n\n    /**\n     * Creates a new instance of MapListHandler.\n     *\n     * @param convert The {@code RowProcessor} implementation\n     * to use when converting rows into Maps.\n     */\n    public MapListHandler(final RowProcessor convert) {\n        this.convert = convert;\n    }\n\n    /**\n     * Converts the {@code ResultSet} row into a {@code Map} object.\n     * @param resultSet {@code ResultSet} to process.\n     * @return A {@code Map}, never null.\n     *\n     * @throws SQLException if a database access error occurs\n     *\n     * @see org.apache.commons.dbutils.handlers.AbstractListHandler#handle(ResultSet)\n     */\n    @Override\n    protected Map<String, Object> handleRow(final ResultSet resultSet) throws SQLException {\n        return this.convert.toMap(resultSet);\n    }\n\n}\n", "file_hash": "059da6024fbe5040143980f1c794b1645a4755955e1f686c341a61ded906baf0", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils.handlers;", "import java.sql.ResultSet;", "import java.sql.SQLException;", "import java.util.Map;", "import org.apache.commons.dbutils.RowProcessor;"], "methods": [], "classes": [{"original_string": "public class MapListHandler extends AbstractListHandler<Map<String, Object>> {\n\n    /**\n     * The RowProcessor implementation to use when converting rows\n     * into Maps.\n     */\n    private final RowProcessor convert;\n\n    /**\n     * Creates a new instance of MapListHandler using a\n     * {@code BasicRowProcessor} for conversion.\n     */\n    public MapListHandler() {\n        this(ArrayHandler.ROW_PROCESSOR);\n    }\n\n    /**\n     * Creates a new instance of MapListHandler.\n     *\n     * @param convert The {@code RowProcessor} implementation\n     * to use when converting rows into Maps.\n     */\n    public MapListHandler(final RowProcessor convert) {\n        this.convert = convert;\n    }\n\n    /**\n     * Converts the {@code ResultSet} row into a {@code Map} object.\n     * @param resultSet {@code ResultSet} to process.\n     * @return A {@code Map}, never null.\n     *\n     * @throws SQLException if a database access error occurs\n     *\n     * @see org.apache.commons.dbutils.handlers.AbstractListHandler#handle(ResultSet)\n     */\n    @Override\n    protected Map<String, Object> handleRow(final ResultSet resultSet) throws SQLException {\n        return this.convert.toMap(resultSet);\n    }\n\n}", "definition": "public class MapListHandler extends AbstractListHandler<Map<String, Object>>", "class_docstring": "\n{@code ResultSetHandler} implementation that converts a\n{@code ResultSet} into a {@code List} of {@code Map}s.\nThis class is thread safe.\n\n@see org.apache.commons.dbutils.ResultSetHandler\n", "name": "MapListHandler", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final RowProcessor convert;", "docstring": "\nThe RowProcessor implementation to use when converting rows\ninto Maps.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "RowProcessor", "name": "convert", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public MapListHandler() {\n        this(ArrayHandler.ROW_PROCESSOR);\n    }", "docstring": "\nCreates a new instance of MapListHandler using a\n{@code BasicRowProcessor} for conversion.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "MapListHandler", "params": [], "body": "                            {\n        this(ArrayHandler.ROW_PROCESSOR);\n    }", "signature": "public MapListHandler()"}, {"syntax_pass": true, "original_string": "    public MapListHandler(final RowProcessor convert) {\n        this.convert = convert;\n    }", "docstring": "\nCreates a new instance of MapListHandler.\n\n@param convert The {@code RowProcessor} implementation\nto use when converting rows into Maps.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "MapListHandler", "params": [{"name": "convert", "type": "RowProcessor"}], "body": "                                                      {\n        this.convert = convert;\n    }", "signature": "public MapListHandler(final RowProcessor convert)"}, {"syntax_pass": true, "original_string": "    @Override\n    protected Map<String, Object> handleRow(final ResultSet resultSet) throws SQLException {\n        return this.convert.toMap(resultSet);\n    }", "docstring": "\nConverts the {@code ResultSet} row into a {@code Map} object.\n@param resultSet {@code ResultSet} to process.\n@return A {@code Map}, never null.\n\n@throws SQLException if a database access error occurs\n\n@see org.apache.commons.dbutils.handlers.AbstractListHandler#handle(ResultSet)\n", "attributes": {"modifiers": "@Override\n    protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Map<String, Object>", "classes": []}, "name": "handleRow", "params": [{"name": "resultSet", "type": "ResultSet"}], "body": "                                                                                           {\n        return this.convert.toMap(resultSet);\n    }", "signature": "@Override\n    protected Map<String, Object> handleRow(final ResultSet resultSet)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/apache/commons/dbutils/handlers/BeanHandler.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils.handlers;\n\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\n\nimport org.apache.commons.dbutils.ResultSetHandler;\nimport org.apache.commons.dbutils.RowProcessor;\n\n/**\n * {@code ResultSetHandler} implementation that converts the first\n * {@code ResultSet} row into a JavaBean. This class is thread safe.\n *\n * @param <T> the target bean type\n * @see org.apache.commons.dbutils.ResultSetHandler\n */\npublic class BeanHandler<T> implements ResultSetHandler<T> {\n\n    /**\n     * The Class of beans produced by this handler.\n     */\n    private final Class<? extends T> type;\n\n    /**\n     * The RowProcessor implementation to use when converting rows\n     * into beans.\n     */\n    private final RowProcessor convert;\n\n    /**\n     * Creates a new instance of BeanHandler.\n     *\n     * @param type The Class that objects returned from {@code handle()}\n     * are created from.\n     */\n    public BeanHandler(final Class<? extends T> type) {\n        this(type, ArrayHandler.ROW_PROCESSOR);\n    }\n\n    /**\n     * Creates a new instance of BeanHandler.\n     *\n     * @param type The Class that objects returned from {@code handle()}\n     * are created from.\n     * @param convert The {@code RowProcessor} implementation\n     * to use when converting rows into beans.\n     */\n    public BeanHandler(final Class<? extends T> type, final RowProcessor convert) {\n        this.type = type;\n        this.convert = convert;\n    }\n\n    /**\n     * Convert the first row of the {@code ResultSet} into a bean with the\n     * {@code Class} given in the constructor.\n     * @param resultSet {@code ResultSet} to process.\n     * @return An initialized JavaBean or {@code null} if there were no\n     * rows in the {@code ResultSet}.\n     *\n     * @throws SQLException if a database access error occurs\n     * @see org.apache.commons.dbutils.ResultSetHandler#handle(java.sql.ResultSet)\n     */\n    @Override\n    public T handle(final ResultSet resultSet) throws SQLException {\n        return resultSet.next() ? this.convert.toBean(resultSet, this.type) : null;\n    }\n\n}\n", "file_hash": "9f37c588cdd924912a777710a430ddaf91058766296791a6e2b0d6208dba22f0", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils.handlers;", "import java.sql.ResultSet;", "import java.sql.SQLException;", "import org.apache.commons.dbutils.ResultSetHandler;", "import org.apache.commons.dbutils.RowProcessor;"], "methods": [], "classes": [{"original_string": "public class BeanHandler<T> implements ResultSetHandler<T> {\n\n    /**\n     * The Class of beans produced by this handler.\n     */\n    private final Class<? extends T> type;\n\n    /**\n     * The RowProcessor implementation to use when converting rows\n     * into beans.\n     */\n    private final RowProcessor convert;\n\n    /**\n     * Creates a new instance of BeanHandler.\n     *\n     * @param type The Class that objects returned from {@code handle()}\n     * are created from.\n     */\n    public BeanHandler(final Class<? extends T> type) {\n        this(type, ArrayHandler.ROW_PROCESSOR);\n    }\n\n    /**\n     * Creates a new instance of BeanHandler.\n     *\n     * @param type The Class that objects returned from {@code handle()}\n     * are created from.\n     * @param convert The {@code RowProcessor} implementation\n     * to use when converting rows into beans.\n     */\n    public BeanHandler(final Class<? extends T> type, final RowProcessor convert) {\n        this.type = type;\n        this.convert = convert;\n    }\n\n    /**\n     * Convert the first row of the {@code ResultSet} into a bean with the\n     * {@code Class} given in the constructor.\n     * @param resultSet {@code ResultSet} to process.\n     * @return An initialized JavaBean or {@code null} if there were no\n     * rows in the {@code ResultSet}.\n     *\n     * @throws SQLException if a database access error occurs\n     * @see org.apache.commons.dbutils.ResultSetHandler#handle(java.sql.ResultSet)\n     */\n    @Override\n    public T handle(final ResultSet resultSet) throws SQLException {\n        return resultSet.next() ? this.convert.toBean(resultSet, this.type) : null;\n    }\n\n}", "definition": "public class BeanHandler<T> implements ResultSetHandler<T>", "class_docstring": "\n{@code ResultSetHandler} implementation that converts the first\n{@code ResultSet} row into a JavaBean. This class is thread safe.\n\n@param <T> the target bean type\n@see org.apache.commons.dbutils.ResultSetHandler\n", "name": "BeanHandler", "super_interfaces": ["ResultSetHandler<T>"], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final Class<? extends T> type;", "docstring": "\nThe Class of beans produced by this handler.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Class<? extends T>", "name": "type", "syntax_pass": true}, {"attribute_expression": "private final RowProcessor convert;", "docstring": "\nThe RowProcessor implementation to use when converting rows\ninto beans.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "RowProcessor", "name": "convert", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public BeanHandler(final Class<? extends T> type) {\n        this(type, ArrayHandler.ROW_PROCESSOR);\n    }", "docstring": "\nCreates a new instance of BeanHandler.\n\n@param type The Class that objects returned from {@code handle()}\nare created from.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "BeanHandler", "params": [{"name": "type", "type": "Class<? extends T>"}], "body": "                                                      {\n        this(type, ArrayHandler.ROW_PROCESSOR);\n    }", "signature": "public BeanHandler(final Class<? extends T> type)"}, {"syntax_pass": true, "original_string": "    public BeanHandler(final Class<? extends T> type, final RowProcessor convert) {\n        this.type = type;\n        this.convert = convert;\n    }", "docstring": "\nCreates a new instance of BeanHandler.\n\n@param type The Class that objects returned from {@code handle()}\nare created from.\n@param convert The {@code RowProcessor} implementation\nto use when converting rows into beans.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "BeanHandler", "params": [{"name": "type", "type": "Class<? extends T>"}, {"name": "convert", "type": "RowProcessor"}], "body": "                                                                                  {\n        this.type = type;\n        this.convert = convert;\n    }", "signature": "public BeanHandler(final Class<? extends T> type, final RowProcessor convert)"}, {"syntax_pass": true, "original_string": "    @Override\n    public T handle(final ResultSet resultSet) throws SQLException {\n        return resultSet.next() ? this.convert.toBean(resultSet, this.type) : null;\n    }", "docstring": "\nConvert the first row of the {@code ResultSet} into a bean with the\n{@code Class} given in the constructor.\n@param resultSet {@code ResultSet} to process.\n@return An initialized JavaBean or {@code null} if there were no\nrows in the {@code ResultSet}.\n\n@throws SQLException if a database access error occurs\n@see org.apache.commons.dbutils.ResultSetHandler#handle(java.sql.ResultSet)\n", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "T", "classes": []}, "name": "handle", "params": [{"name": "resultSet", "type": "ResultSet"}], "body": "                                                                   {\n        return resultSet.next() ? this.convert.toBean(resultSet, this.type) : null;\n    }", "signature": "@Override\n    public T handle(final ResultSet resultSet)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/apache/commons/dbutils/handlers/package-info.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Implementations of the org.apache.commons.dbutils.ResultSetHandler interface.\n */\npackage org.apache.commons.dbutils.handlers;\n", "file_hash": "c0754506be7213ddf224057d43db90c9f5a965343e0f82dae98955c7236a791d", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils.handlers;"], "methods": [], "classes": [], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/apache/commons/dbutils/handlers/ScalarHandler.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils.handlers;\n\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\n\nimport org.apache.commons.dbutils.ResultSetHandler;\n\n/**\n * {@code ResultSetHandler} implementation that converts one\n * {@code ResultSet} column into an Object. This class is thread safe.\n *\n * @param <T> The type of the scalar\n * @see org.apache.commons.dbutils.ResultSetHandler\n */\npublic class ScalarHandler<T> implements ResultSetHandler<T> {\n\n    /**\n     * The column number to retrieve.\n     */\n    private final int columnIndex;\n\n    /**\n     * The column name to retrieve.  Either columnName or columnIndex\n     * will be used but never both.\n     */\n    private final String columnName;\n\n    /**\n     * Creates a new instance of ScalarHandler.  The first column will\n     * be returned from {@code handle()}.\n     */\n    public ScalarHandler() {\n        this(1, null);\n    }\n\n    /**\n     * Creates a new instance of ScalarHandler.\n     *\n     * @param columnIndex The index of the column to retrieve from the\n     * {@code ResultSet}.\n     */\n    public ScalarHandler(final int columnIndex) {\n        this(columnIndex, null);\n    }\n\n    /** Helper constructor\n     * @param columnIndex The index of the column to retrieve from the\n     * {@code ResultSet}.\n     * @param columnName The name of the column to retrieve from the\n     * {@code ResultSet}.\n     */\n    private ScalarHandler(final int columnIndex, final String columnName) {\n        this.columnIndex = columnIndex;\n        this.columnName = columnName;\n    }\n\n    /**\n     * Creates a new instance of ScalarHandler.\n     *\n     * @param columnName The name of the column to retrieve from the\n     * {@code ResultSet}.\n     */\n    public ScalarHandler(final String columnName) {\n        this(1, columnName);\n    }\n\n    /**\n     * Returns one {@code ResultSet} column as an object via the\n     * {@code ResultSet.getObject()} method that performs type\n     * conversions.\n     * @param resultSet {@code ResultSet} to process.\n     * @return The column or {@code null} if there are no rows in\n     * the {@code ResultSet}.\n     *\n     * @throws SQLException if a database access error occurs\n     * @throws ClassCastException if the class datatype does not match the column type\n     *\n     * @see org.apache.commons.dbutils.ResultSetHandler#handle(java.sql.ResultSet)\n     */\n    // We assume that the user has picked the correct type to match the column\n    // so getObject will return the appropriate type and the cast will succeed.\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public T handle(final ResultSet resultSet) throws SQLException {\n\n        if (resultSet.next()) {\n            if (this.columnName == null) {\n                return (T) resultSet.getObject(this.columnIndex);\n            }\n            return (T) resultSet.getObject(this.columnName);\n        }\n        return null;\n    }\n}\n", "file_hash": "9d294b81df1c611b79614ad0eb15796a11e3655bc7b6204108ba4ee11e0a4d01", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils.handlers;", "import java.sql.ResultSet;", "import java.sql.SQLException;", "import org.apache.commons.dbutils.ResultSetHandler;"], "methods": [], "classes": [{"original_string": "public class ScalarHandler<T> implements ResultSetHandler<T> {\n\n    /**\n     * The column number to retrieve.\n     */\n    private final int columnIndex;\n\n    /**\n     * The column name to retrieve.  Either columnName or columnIndex\n     * will be used but never both.\n     */\n    private final String columnName;\n\n    /**\n     * Creates a new instance of ScalarHandler.  The first column will\n     * be returned from {@code handle()}.\n     */\n    public ScalarHandler() {\n        this(1, null);\n    }\n\n    /**\n     * Creates a new instance of ScalarHandler.\n     *\n     * @param columnIndex The index of the column to retrieve from the\n     * {@code ResultSet}.\n     */\n    public ScalarHandler(final int columnIndex) {\n        this(columnIndex, null);\n    }\n\n    /** Helper constructor\n     * @param columnIndex The index of the column to retrieve from the\n     * {@code ResultSet}.\n     * @param columnName The name of the column to retrieve from the\n     * {@code ResultSet}.\n     */\n    private ScalarHandler(final int columnIndex, final String columnName) {\n        this.columnIndex = columnIndex;\n        this.columnName = columnName;\n    }\n\n    /**\n     * Creates a new instance of ScalarHandler.\n     *\n     * @param columnName The name of the column to retrieve from the\n     * {@code ResultSet}.\n     */\n    public ScalarHandler(final String columnName) {\n        this(1, columnName);\n    }\n\n    /**\n     * Returns one {@code ResultSet} column as an object via the\n     * {@code ResultSet.getObject()} method that performs type\n     * conversions.\n     * @param resultSet {@code ResultSet} to process.\n     * @return The column or {@code null} if there are no rows in\n     * the {@code ResultSet}.\n     *\n     * @throws SQLException if a database access error occurs\n     * @throws ClassCastException if the class datatype does not match the column type\n     *\n     * @see org.apache.commons.dbutils.ResultSetHandler#handle(java.sql.ResultSet)\n     */\n    // We assume that the user has picked the correct type to match the column\n    // so getObject will return the appropriate type and the cast will succeed.\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public T handle(final ResultSet resultSet) throws SQLException {\n\n        if (resultSet.next()) {\n            if (this.columnName == null) {\n                return (T) resultSet.getObject(this.columnIndex);\n            }\n            return (T) resultSet.getObject(this.columnName);\n        }\n        return null;\n    }\n}", "definition": "public class ScalarHandler<T> implements ResultSetHandler<T>", "class_docstring": "\n{@code ResultSetHandler} implementation that converts one\n{@code ResultSet} column into an Object. This class is thread safe.\n\n@param <T> The type of the scalar\n@see org.apache.commons.dbutils.ResultSetHandler\n", "name": "ScalarHandler", "super_interfaces": ["ResultSetHandler<T>"], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final int columnIndex;", "docstring": "\nThe column number to retrieve.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "columnIndex", "syntax_pass": true}, {"attribute_expression": "private final String columnName;", "docstring": "\nThe column name to retrieve.  Either columnName or columnIndex\nwill be used but never both.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "columnName", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public ScalarHandler() {\n        this(1, null);\n    }", "docstring": "\nCreates a new instance of ScalarHandler.  The first column will\nbe returned from {@code handle()}.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ScalarHandler", "params": [], "body": "                           {\n        this(1, null);\n    }", "signature": "public ScalarHandler()"}, {"syntax_pass": true, "original_string": "    public ScalarHandler(final int columnIndex) {\n        this(columnIndex, null);\n    }", "docstring": "\nCreates a new instance of ScalarHandler.\n\n@param columnIndex The index of the column to retrieve from the\n{@code ResultSet}.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ScalarHandler", "params": [{"name": "columnIndex", "type": "int"}], "body": "                                                {\n        this(columnIndex, null);\n    }", "signature": "public ScalarHandler(final int columnIndex)"}, {"syntax_pass": true, "original_string": "    private ScalarHandler(final int columnIndex, final String columnName) {\n        this.columnIndex = columnIndex;\n        this.columnName = columnName;\n    }", "docstring": " Helper constructor\n@param columnIndex The index of the column to retrieve from the\n{@code ResultSet}.\n@param columnName The name of the column to retrieve from the\n{@code ResultSet}.\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "ScalarHandler", "params": [{"name": "columnIndex", "type": "int"}, {"name": "columnName", "type": "String"}], "body": "                                                                          {\n        this.columnIndex = columnIndex;\n        this.columnName = columnName;\n    }", "signature": "private ScalarHandler(final int columnIndex, final String columnName)"}, {"syntax_pass": true, "original_string": "    public ScalarHandler(final String columnName) {\n        this(1, columnName);\n    }", "docstring": "\nCreates a new instance of ScalarHandler.\n\n@param columnName The name of the column to retrieve from the\n{@code ResultSet}.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ScalarHandler", "params": [{"name": "columnName", "type": "String"}], "body": "                                                  {\n        this(1, columnName);\n    }", "signature": "public ScalarHandler(final String columnName)"}, {"syntax_pass": true, "original_string": "    @SuppressWarnings(\"unchecked\")\n    @Override\n    public T handle(final ResultSet resultSet) throws SQLException {\n\n        if (resultSet.next()) {\n            if (this.columnName == null) {\n                return (T) resultSet.getObject(this.columnIndex);\n            }\n            return (T) resultSet.getObject(this.columnName);\n        }\n        return null;\n    }", "docstring": " so getObject will return the appropriate type and the cast will succeed.", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n    @Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "T", "classes": []}, "name": "handle", "params": [{"name": "resultSet", "type": "ResultSet"}], "body": "                                                                   {\n\n        if (resultSet.next()) {\n            if (this.columnName == null) {\n                return (T) resultSet.getObject(this.columnIndex);\n            }\n            return (T) resultSet.getObject(this.columnName);\n        }\n        return null;\n    }", "signature": "@SuppressWarnings(\"unchecked\")\n    @Override\n    public T handle(final ResultSet resultSet)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/apache/commons/dbutils/handlers/columns/DoubleColumnHandler.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils.handlers.columns;\n\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\n\nimport org.apache.commons.dbutils.ColumnHandler;\n\npublic class DoubleColumnHandler implements ColumnHandler<Double> {\n\n    @Override\n    public Double apply(final ResultSet resultSet, final int columnIndex) throws SQLException {\n        return Double.valueOf(resultSet.getDouble(columnIndex));\n    }\n\n    @Override\n    public boolean match(final Class<?> propType) {\n        return propType.equals(Double.TYPE) || propType.equals(Double.class);\n    }\n}\n", "file_hash": "310e26a4c1b83bc9f3d9fbddbea5c62f448568c9aaf2efde2e916e02f57ae4d3", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils.handlers.columns;", "import java.sql.ResultSet;", "import java.sql.SQLException;", "import org.apache.commons.dbutils.ColumnHandler;"], "methods": [], "classes": [{"original_string": "public class DoubleColumnHandler implements ColumnHandler<Double> {\n\n    @Override\n    public Double apply(final ResultSet resultSet, final int columnIndex) throws SQLException {\n        return Double.valueOf(resultSet.getDouble(columnIndex));\n    }\n\n    @Override\n    public boolean match(final Class<?> propType) {\n        return propType.equals(Double.TYPE) || propType.equals(Double.class);\n    }\n}", "definition": "public class DoubleColumnHandler implements ColumnHandler<Double>", "class_docstring": "", "name": "DoubleColumnHandler", "super_interfaces": ["ColumnHandler<Double>"], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Override\n    public Double apply(final ResultSet resultSet, final int columnIndex) throws SQLException {\n        return Double.valueOf(resultSet.getDouble(columnIndex));\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Double", "classes": []}, "name": "apply", "params": [{"name": "resultSet", "type": "ResultSet"}, {"name": "columnIndex", "type": "int"}], "body": "                                                                                              {\n        return Double.valueOf(resultSet.getDouble(columnIndex));\n    }", "signature": "@Override\n    public Double apply(final ResultSet resultSet, final int columnIndex)"}, {"syntax_pass": true, "original_string": "    @Override\n    public boolean match(final Class<?> propType) {\n        return propType.equals(Double.TYPE) || propType.equals(Double.class);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "match", "params": [{"name": "propType", "type": "Class<?>"}], "body": "                                                  {\n        return propType.equals(Double.TYPE) || propType.equals(Double.class);\n    }", "signature": "@Override\n    public boolean match(final Class<?> propType)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/apache/commons/dbutils/handlers/columns/StringColumnHandler.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils.handlers.columns;\n\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\n\nimport org.apache.commons.dbutils.ColumnHandler;\n\npublic class StringColumnHandler implements ColumnHandler<String> {\n\n    @Override\n    public String apply(final ResultSet resultSet, final int columnIndex) throws SQLException {\n        return resultSet.getString(columnIndex);\n    }\n\n    @Override\n    public boolean match(final Class<?> propType) {\n        return propType.equals(String.class);\n    }\n}\n", "file_hash": "9ecc1758c7ee0a3d080cc9015b4cd33ababd5fa89c79a06c26801e6948e008a4", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils.handlers.columns;", "import java.sql.ResultSet;", "import java.sql.SQLException;", "import org.apache.commons.dbutils.ColumnHandler;"], "methods": [], "classes": [{"original_string": "public class StringColumnHandler implements ColumnHandler<String> {\n\n    @Override\n    public String apply(final ResultSet resultSet, final int columnIndex) throws SQLException {\n        return resultSet.getString(columnIndex);\n    }\n\n    @Override\n    public boolean match(final Class<?> propType) {\n        return propType.equals(String.class);\n    }\n}", "definition": "public class StringColumnHandler implements ColumnHandler<String>", "class_docstring": "", "name": "StringColumnHandler", "super_interfaces": ["ColumnHandler<String>"], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Override\n    public String apply(final ResultSet resultSet, final int columnIndex) throws SQLException {\n        return resultSet.getString(columnIndex);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "apply", "params": [{"name": "resultSet", "type": "ResultSet"}, {"name": "columnIndex", "type": "int"}], "body": "                                                                                              {\n        return resultSet.getString(columnIndex);\n    }", "signature": "@Override\n    public String apply(final ResultSet resultSet, final int columnIndex)"}, {"syntax_pass": true, "original_string": "    @Override\n    public boolean match(final Class<?> propType) {\n        return propType.equals(String.class);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "match", "params": [{"name": "propType", "type": "Class<?>"}], "body": "                                                  {\n        return propType.equals(String.class);\n    }", "signature": "@Override\n    public boolean match(final Class<?> propType)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/apache/commons/dbutils/handlers/columns/ByteColumnHandler.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils.handlers.columns;\n\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\n\nimport org.apache.commons.dbutils.ColumnHandler;\n\npublic class ByteColumnHandler implements ColumnHandler<Byte> {\n\n    @Override\n    public Byte apply(final ResultSet resultSet, final int columnIndex) throws SQLException {\n        return Byte.valueOf(resultSet.getByte(columnIndex));\n    }\n\n    @Override\n    public boolean match(final Class<?> propType) {\n        return propType.equals(Byte.TYPE) || propType.equals(Byte.class);\n    }\n}\n", "file_hash": "cca598bfc4e61ef8c0ec009b7c1519c7ae1baa9f69eb8af340d404ae5fb08041", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils.handlers.columns;", "import java.sql.ResultSet;", "import java.sql.SQLException;", "import org.apache.commons.dbutils.ColumnHandler;"], "methods": [], "classes": [{"original_string": "public class ByteColumnHandler implements ColumnHandler<Byte> {\n\n    @Override\n    public Byte apply(final ResultSet resultSet, final int columnIndex) throws SQLException {\n        return Byte.valueOf(resultSet.getByte(columnIndex));\n    }\n\n    @Override\n    public boolean match(final Class<?> propType) {\n        return propType.equals(Byte.TYPE) || propType.equals(Byte.class);\n    }\n}", "definition": "public class ByteColumnHandler implements ColumnHandler<Byte>", "class_docstring": "", "name": "ByteColumnHandler", "super_interfaces": ["ColumnHandler<Byte>"], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Override\n    public Byte apply(final ResultSet resultSet, final int columnIndex) throws SQLException {\n        return Byte.valueOf(resultSet.getByte(columnIndex));\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Byte", "classes": []}, "name": "apply", "params": [{"name": "resultSet", "type": "ResultSet"}, {"name": "columnIndex", "type": "int"}], "body": "                                                                                            {\n        return Byte.valueOf(resultSet.getByte(columnIndex));\n    }", "signature": "@Override\n    public Byte apply(final ResultSet resultSet, final int columnIndex)"}, {"syntax_pass": true, "original_string": "    @Override\n    public boolean match(final Class<?> propType) {\n        return propType.equals(Byte.TYPE) || propType.equals(Byte.class);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "match", "params": [{"name": "propType", "type": "Class<?>"}], "body": "                                                  {\n        return propType.equals(Byte.TYPE) || propType.equals(Byte.class);\n    }", "signature": "@Override\n    public boolean match(final Class<?> propType)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/apache/commons/dbutils/handlers/columns/TimestampColumnHandler.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils.handlers.columns;\n\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Timestamp;\n\nimport org.apache.commons.dbutils.ColumnHandler;\n\npublic class TimestampColumnHandler implements ColumnHandler<Timestamp> {\n\n    @Override\n    public Timestamp apply(final ResultSet resultSet, final int columnIndex) throws SQLException {\n        return resultSet.getTimestamp(columnIndex);\n    }\n\n    @Override\n    public boolean match(final Class<?> propType) {\n        return propType.equals(Timestamp.class);\n    }\n}\n", "file_hash": "94a81d7e005970b401898e94227f63a7af6576aa164270bb3ee1e0dd9079f27d", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils.handlers.columns;", "import java.sql.ResultSet;", "import java.sql.SQLException;", "import java.sql.Timestamp;", "import org.apache.commons.dbutils.ColumnHandler;"], "methods": [], "classes": [{"original_string": "public class TimestampColumnHandler implements ColumnHandler<Timestamp> {\n\n    @Override\n    public Timestamp apply(final ResultSet resultSet, final int columnIndex) throws SQLException {\n        return resultSet.getTimestamp(columnIndex);\n    }\n\n    @Override\n    public boolean match(final Class<?> propType) {\n        return propType.equals(Timestamp.class);\n    }\n}", "definition": "public class TimestampColumnHandler implements ColumnHandler<Timestamp>", "class_docstring": "", "name": "TimestampColumnHandler", "super_interfaces": ["ColumnHandler<Timestamp>"], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Override\n    public Timestamp apply(final ResultSet resultSet, final int columnIndex) throws SQLException {\n        return resultSet.getTimestamp(columnIndex);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Timestamp", "classes": []}, "name": "apply", "params": [{"name": "resultSet", "type": "ResultSet"}, {"name": "columnIndex", "type": "int"}], "body": "                                                                                                 {\n        return resultSet.getTimestamp(columnIndex);\n    }", "signature": "@Override\n    public Timestamp apply(final ResultSet resultSet, final int columnIndex)"}, {"syntax_pass": true, "original_string": "    @Override\n    public boolean match(final Class<?> propType) {\n        return propType.equals(Timestamp.class);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "match", "params": [{"name": "propType", "type": "Class<?>"}], "body": "                                                  {\n        return propType.equals(Timestamp.class);\n    }", "signature": "@Override\n    public boolean match(final Class<?> propType)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/apache/commons/dbutils/handlers/columns/SQLXMLColumnHandler.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils.handlers.columns;\n\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.SQLXML;\n\nimport org.apache.commons.dbutils.ColumnHandler;\n\npublic class SQLXMLColumnHandler implements ColumnHandler<SQLXML> {\n\n    @Override\n    public SQLXML apply(final ResultSet resultSet, final int columnIndex) throws SQLException {\n        return resultSet.getSQLXML(columnIndex);\n    }\n\n    @Override\n    public boolean match(final Class<?> propType) {\n        return propType.equals(SQLXML.class);\n    }\n}\n", "file_hash": "bc62ea3e538cc6e09682b7c91a3dac22c126ef2a66fb619690704a4caba0c015", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils.handlers.columns;", "import java.sql.ResultSet;", "import java.sql.SQLException;", "import java.sql.SQLXML;", "import org.apache.commons.dbutils.ColumnHandler;"], "methods": [], "classes": [{"original_string": "public class SQLXMLColumnHandler implements ColumnHandler<SQLXML> {\n\n    @Override\n    public SQLXML apply(final ResultSet resultSet, final int columnIndex) throws SQLException {\n        return resultSet.getSQLXML(columnIndex);\n    }\n\n    @Override\n    public boolean match(final Class<?> propType) {\n        return propType.equals(SQLXML.class);\n    }\n}", "definition": "public class SQLXMLColumnHandler implements ColumnHandler<SQLXML>", "class_docstring": "", "name": "SQLXMLColumnHandler", "super_interfaces": ["ColumnHandler<SQLXML>"], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Override\n    public SQLXML apply(final ResultSet resultSet, final int columnIndex) throws SQLException {\n        return resultSet.getSQLXML(columnIndex);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "SQLXML", "classes": []}, "name": "apply", "params": [{"name": "resultSet", "type": "ResultSet"}, {"name": "columnIndex", "type": "int"}], "body": "                                                                                              {\n        return resultSet.getSQLXML(columnIndex);\n    }", "signature": "@Override\n    public SQLXML apply(final ResultSet resultSet, final int columnIndex)"}, {"syntax_pass": true, "original_string": "    @Override\n    public boolean match(final Class<?> propType) {\n        return propType.equals(SQLXML.class);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "match", "params": [{"name": "propType", "type": "Class<?>"}], "body": "                                                  {\n        return propType.equals(SQLXML.class);\n    }", "signature": "@Override\n    public boolean match(final Class<?> propType)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/apache/commons/dbutils/handlers/columns/BooleanColumnHandler.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils.handlers.columns;\n\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\n\nimport org.apache.commons.dbutils.ColumnHandler;\n\npublic class BooleanColumnHandler implements ColumnHandler<Boolean> {\n\n    @Override\n    public Boolean apply(final ResultSet resultSet, final int columnIndex) throws SQLException {\n        return Boolean.valueOf(resultSet.getBoolean(columnIndex));\n    }\n\n    @Override\n    public boolean match(final Class<?> propType) {\n        return propType.equals(Boolean.TYPE) || propType.equals(Boolean.class);\n    }\n}\n", "file_hash": "88120044128ec4438d11bf19c03bd954d23460cc7cad10b8a1045c53090043a2", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils.handlers.columns;", "import java.sql.ResultSet;", "import java.sql.SQLException;", "import org.apache.commons.dbutils.ColumnHandler;"], "methods": [], "classes": [{"original_string": "public class BooleanColumnHandler implements ColumnHandler<Boolean> {\n\n    @Override\n    public Boolean apply(final ResultSet resultSet, final int columnIndex) throws SQLException {\n        return Boolean.valueOf(resultSet.getBoolean(columnIndex));\n    }\n\n    @Override\n    public boolean match(final Class<?> propType) {\n        return propType.equals(Boolean.TYPE) || propType.equals(Boolean.class);\n    }\n}", "definition": "public class BooleanColumnHandler implements ColumnHandler<Boolean>", "class_docstring": "", "name": "BooleanColumnHandler", "super_interfaces": ["ColumnHandler<Boolean>"], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Override\n    public Boolean apply(final ResultSet resultSet, final int columnIndex) throws SQLException {\n        return Boolean.valueOf(resultSet.getBoolean(columnIndex));\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Boolean", "classes": []}, "name": "apply", "params": [{"name": "resultSet", "type": "ResultSet"}, {"name": "columnIndex", "type": "int"}], "body": "                                                                                               {\n        return Boolean.valueOf(resultSet.getBoolean(columnIndex));\n    }", "signature": "@Override\n    public Boolean apply(final ResultSet resultSet, final int columnIndex)"}, {"syntax_pass": true, "original_string": "    @Override\n    public boolean match(final Class<?> propType) {\n        return propType.equals(Boolean.TYPE) || propType.equals(Boolean.class);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "match", "params": [{"name": "propType", "type": "Class<?>"}], "body": "                                                  {\n        return propType.equals(Boolean.TYPE) || propType.equals(Boolean.class);\n    }", "signature": "@Override\n    public boolean match(final Class<?> propType)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/apache/commons/dbutils/handlers/columns/ShortColumnHandler.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils.handlers.columns;\n\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\n\nimport org.apache.commons.dbutils.ColumnHandler;\n\npublic class ShortColumnHandler implements ColumnHandler<Short> {\n\n    @Override\n    public Short apply(final ResultSet resultSet, final int columnIndex) throws SQLException {\n        return Short.valueOf(resultSet.getShort(columnIndex));\n    }\n\n    @Override\n    public boolean match(final Class<?> propType) {\n        return propType.equals(Short.TYPE) || propType.equals(Short.class);\n    }\n}\n", "file_hash": "3d755675ef4bed90b4067393407f31bae792cf6d0b3d7c1d69355d749f90b6c8", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils.handlers.columns;", "import java.sql.ResultSet;", "import java.sql.SQLException;", "import org.apache.commons.dbutils.ColumnHandler;"], "methods": [], "classes": [{"original_string": "public class ShortColumnHandler implements ColumnHandler<Short> {\n\n    @Override\n    public Short apply(final ResultSet resultSet, final int columnIndex) throws SQLException {\n        return Short.valueOf(resultSet.getShort(columnIndex));\n    }\n\n    @Override\n    public boolean match(final Class<?> propType) {\n        return propType.equals(Short.TYPE) || propType.equals(Short.class);\n    }\n}", "definition": "public class ShortColumnHandler implements ColumnHandler<Short>", "class_docstring": "", "name": "ShortColumnHandler", "super_interfaces": ["ColumnHandler<Short>"], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Override\n    public Short apply(final ResultSet resultSet, final int columnIndex) throws SQLException {\n        return Short.valueOf(resultSet.getShort(columnIndex));\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Short", "classes": []}, "name": "apply", "params": [{"name": "resultSet", "type": "ResultSet"}, {"name": "columnIndex", "type": "int"}], "body": "                                                                                             {\n        return Short.valueOf(resultSet.getShort(columnIndex));\n    }", "signature": "@Override\n    public Short apply(final ResultSet resultSet, final int columnIndex)"}, {"syntax_pass": true, "original_string": "    @Override\n    public boolean match(final Class<?> propType) {\n        return propType.equals(Short.TYPE) || propType.equals(Short.class);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "match", "params": [{"name": "propType", "type": "Class<?>"}], "body": "                                                  {\n        return propType.equals(Short.TYPE) || propType.equals(Short.class);\n    }", "signature": "@Override\n    public boolean match(final Class<?> propType)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/apache/commons/dbutils/handlers/columns/FloatColumnHandler.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils.handlers.columns;\n\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\n\nimport org.apache.commons.dbutils.ColumnHandler;\n\npublic class FloatColumnHandler implements ColumnHandler<Float> {\n\n    @Override\n    public Float apply(final ResultSet resultSet, final int columnIndex) throws SQLException {\n        return Float.valueOf(resultSet.getFloat(columnIndex));\n    }\n\n    @Override\n    public boolean match(final Class<?> propType) {\n        return propType.equals(Float.TYPE) || propType.equals(Float.class);\n    }\n}\n", "file_hash": "f806678ccab2c93fd4696e512864c729b31eef951947085d760d54adeebbfbc1", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils.handlers.columns;", "import java.sql.ResultSet;", "import java.sql.SQLException;", "import org.apache.commons.dbutils.ColumnHandler;"], "methods": [], "classes": [{"original_string": "public class FloatColumnHandler implements ColumnHandler<Float> {\n\n    @Override\n    public Float apply(final ResultSet resultSet, final int columnIndex) throws SQLException {\n        return Float.valueOf(resultSet.getFloat(columnIndex));\n    }\n\n    @Override\n    public boolean match(final Class<?> propType) {\n        return propType.equals(Float.TYPE) || propType.equals(Float.class);\n    }\n}", "definition": "public class FloatColumnHandler implements ColumnHandler<Float>", "class_docstring": "", "name": "FloatColumnHandler", "super_interfaces": ["ColumnHandler<Float>"], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Override\n    public Float apply(final ResultSet resultSet, final int columnIndex) throws SQLException {\n        return Float.valueOf(resultSet.getFloat(columnIndex));\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Float", "classes": []}, "name": "apply", "params": [{"name": "resultSet", "type": "ResultSet"}, {"name": "columnIndex", "type": "int"}], "body": "                                                                                             {\n        return Float.valueOf(resultSet.getFloat(columnIndex));\n    }", "signature": "@Override\n    public Float apply(final ResultSet resultSet, final int columnIndex)"}, {"syntax_pass": true, "original_string": "    @Override\n    public boolean match(final Class<?> propType) {\n        return propType.equals(Float.TYPE) || propType.equals(Float.class);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "match", "params": [{"name": "propType", "type": "Class<?>"}], "body": "                                                  {\n        return propType.equals(Float.TYPE) || propType.equals(Float.class);\n    }", "signature": "@Override\n    public boolean match(final Class<?> propType)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/apache/commons/dbutils/handlers/columns/LongColumnHandler.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils.handlers.columns;\n\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\n\nimport org.apache.commons.dbutils.ColumnHandler;\n\npublic class LongColumnHandler implements ColumnHandler<Long> {\n\n    @Override\n    public Long apply(final ResultSet resultSet, final int columnIndex) throws SQLException {\n        return Long.valueOf(resultSet.getLong(columnIndex));\n    }\n\n    @Override\n    public boolean match(final Class<?> propType) {\n        return propType.equals(Long.TYPE) || propType.equals(Long.class);\n    }\n}\n", "file_hash": "40d4f059d0791a2b54f7b6201a1d633728d0ddd94a863dcc3aadb2f039c7ee42", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils.handlers.columns;", "import java.sql.ResultSet;", "import java.sql.SQLException;", "import org.apache.commons.dbutils.ColumnHandler;"], "methods": [], "classes": [{"original_string": "public class LongColumnHandler implements ColumnHandler<Long> {\n\n    @Override\n    public Long apply(final ResultSet resultSet, final int columnIndex) throws SQLException {\n        return Long.valueOf(resultSet.getLong(columnIndex));\n    }\n\n    @Override\n    public boolean match(final Class<?> propType) {\n        return propType.equals(Long.TYPE) || propType.equals(Long.class);\n    }\n}", "definition": "public class LongColumnHandler implements ColumnHandler<Long>", "class_docstring": "", "name": "LongColumnHandler", "super_interfaces": ["ColumnHandler<Long>"], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Override\n    public Long apply(final ResultSet resultSet, final int columnIndex) throws SQLException {\n        return Long.valueOf(resultSet.getLong(columnIndex));\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Long", "classes": []}, "name": "apply", "params": [{"name": "resultSet", "type": "ResultSet"}, {"name": "columnIndex", "type": "int"}], "body": "                                                                                            {\n        return Long.valueOf(resultSet.getLong(columnIndex));\n    }", "signature": "@Override\n    public Long apply(final ResultSet resultSet, final int columnIndex)"}, {"syntax_pass": true, "original_string": "    @Override\n    public boolean match(final Class<?> propType) {\n        return propType.equals(Long.TYPE) || propType.equals(Long.class);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "match", "params": [{"name": "propType", "type": "Class<?>"}], "body": "                                                  {\n        return propType.equals(Long.TYPE) || propType.equals(Long.class);\n    }", "signature": "@Override\n    public boolean match(final Class<?> propType)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/apache/commons/dbutils/handlers/columns/IntegerColumnHandler.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils.handlers.columns;\n\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\n\nimport org.apache.commons.dbutils.ColumnHandler;\n\npublic class IntegerColumnHandler implements ColumnHandler<Integer> {\n\n    @Override\n    public Integer apply(final ResultSet resultSet, final int columnIndex) throws SQLException {\n        return Integer.valueOf(resultSet.getInt(columnIndex));\n    }\n\n    @Override\n    public boolean match(final Class<?> propType) {\n        return propType.equals(Integer.TYPE) || propType.equals(Integer.class);\n    }\n}\n", "file_hash": "909fe45a0194ff5a3c5a178355fd41f9b5df55edf543eff80daf061960277165", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils.handlers.columns;", "import java.sql.ResultSet;", "import java.sql.SQLException;", "import org.apache.commons.dbutils.ColumnHandler;"], "methods": [], "classes": [{"original_string": "public class IntegerColumnHandler implements ColumnHandler<Integer> {\n\n    @Override\n    public Integer apply(final ResultSet resultSet, final int columnIndex) throws SQLException {\n        return Integer.valueOf(resultSet.getInt(columnIndex));\n    }\n\n    @Override\n    public boolean match(final Class<?> propType) {\n        return propType.equals(Integer.TYPE) || propType.equals(Integer.class);\n    }\n}", "definition": "public class IntegerColumnHandler implements ColumnHandler<Integer>", "class_docstring": "", "name": "IntegerColumnHandler", "super_interfaces": ["ColumnHandler<Integer>"], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Override\n    public Integer apply(final ResultSet resultSet, final int columnIndex) throws SQLException {\n        return Integer.valueOf(resultSet.getInt(columnIndex));\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Integer", "classes": []}, "name": "apply", "params": [{"name": "resultSet", "type": "ResultSet"}, {"name": "columnIndex", "type": "int"}], "body": "                                                                                               {\n        return Integer.valueOf(resultSet.getInt(columnIndex));\n    }", "signature": "@Override\n    public Integer apply(final ResultSet resultSet, final int columnIndex)"}, {"syntax_pass": true, "original_string": "    @Override\n    public boolean match(final Class<?> propType) {\n        return propType.equals(Integer.TYPE) || propType.equals(Integer.class);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "match", "params": [{"name": "propType", "type": "Class<?>"}], "body": "                                                  {\n        return propType.equals(Integer.TYPE) || propType.equals(Integer.class);\n    }", "signature": "@Override\n    public boolean match(final Class<?> propType)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/apache/commons/dbutils/handlers/columns/package-info.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Implementations of the org.apache.commons.dbutils.ColumnHandler interface.\n */\npackage org.apache.commons.dbutils.handlers.columns;\n", "file_hash": "3dd956d14934cd704e109fbe15a54920de18ef9bac93ea7589eed07e36b871fd", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils.handlers.columns;"], "methods": [], "classes": [], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/apache/commons/dbutils/handlers/properties/DatePropertyHandler.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils.handlers.properties;\n\nimport java.sql.Timestamp;\nimport java.util.Date;\n\nimport org.apache.commons.dbutils.PropertyHandler;\n\n/**\n * {@link PropertyHandler} for date fields. Will convert {@link java.sql.Date}, {@link java.sql.Time}, and {@link java.sql.Timestamp} from SQL types to Java\n * types.\n */\npublic class DatePropertyHandler implements PropertyHandler {\n\n    private static final String JAVA_SQL_TIMESTAMP = \"java.sql.Timestamp\";\n    private static final String JAVA_SQL_TIME = \"java.sql.Time\";\n    private static final String JAVA_SQL_DATE = \"java.sql.Date\";\n\n    @Override\n    public Object apply(final Class<?> parameter, Object value) {\n        final String targetType = parameter.getName();\n        final Date dateValue = (Date) value;\n        final long time = dateValue.getTime();\n\n        switch (targetType) {\n        case JAVA_SQL_DATE:\n            value = new java.sql.Date(time);\n            break;\n        case JAVA_SQL_TIME:\n            value = new java.sql.Time(time);\n            break;\n        case JAVA_SQL_TIMESTAMP:\n            value = new Timestamp(time);\n            break;\n        default:\n            break;\n        }\n\n        return value;\n    }\n\n    @Override\n    public boolean match(final Class<?> parameter, final Object value) {\n        if (value instanceof Date) {\n            final String targetType = parameter.getName();\n            if (JAVA_SQL_DATE.equals(targetType)) {\n                return true;\n            }\n            if (JAVA_SQL_TIME.equals(targetType)) {\n                return true;\n            }\n            if (JAVA_SQL_TIMESTAMP.equals(targetType) && !Timestamp.class.isInstance(value)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}\n", "file_hash": "7ddc473fc37620e1d38f4c65837873c9d2cbe0eb367060995c5f6555a50b380c", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils.handlers.properties;", "import java.sql.Timestamp;", "import java.util.Date;", "import org.apache.commons.dbutils.PropertyHandler;"], "methods": [], "classes": [{"original_string": "public class DatePropertyHandler implements PropertyHandler {\n\n    private static final String JAVA_SQL_TIMESTAMP = \"java.sql.Timestamp\";\n    private static final String JAVA_SQL_TIME = \"java.sql.Time\";\n    private static final String JAVA_SQL_DATE = \"java.sql.Date\";\n\n    @Override\n    public Object apply(final Class<?> parameter, Object value) {\n        final String targetType = parameter.getName();\n        final Date dateValue = (Date) value;\n        final long time = dateValue.getTime();\n\n        switch (targetType) {\n        case JAVA_SQL_DATE:\n            value = new java.sql.Date(time);\n            break;\n        case JAVA_SQL_TIME:\n            value = new java.sql.Time(time);\n            break;\n        case JAVA_SQL_TIMESTAMP:\n            value = new Timestamp(time);\n            break;\n        default:\n            break;\n        }\n\n        return value;\n    }\n\n    @Override\n    public boolean match(final Class<?> parameter, final Object value) {\n        if (value instanceof Date) {\n            final String targetType = parameter.getName();\n            if (JAVA_SQL_DATE.equals(targetType)) {\n                return true;\n            }\n            if (JAVA_SQL_TIME.equals(targetType)) {\n                return true;\n            }\n            if (JAVA_SQL_TIMESTAMP.equals(targetType) && !Timestamp.class.isInstance(value)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}", "definition": "public class DatePropertyHandler implements PropertyHandler", "class_docstring": "\n{@link PropertyHandler} for date fields. Will convert {@link java.sql.Date}, {@link java.sql.Time}, and {@link java.sql.Timestamp} from SQL types to Java\ntypes.\n", "name": "DatePropertyHandler", "super_interfaces": ["PropertyHandler"], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private static final String JAVA_SQL_TIMESTAMP = \"java.sql.Timestamp\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "JAVA_SQL_TIMESTAMP = \"java.sql.Timestamp\"", "syntax_pass": true}, {"attribute_expression": "private static final String JAVA_SQL_TIME = \"java.sql.Time\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "JAVA_SQL_TIME = \"java.sql.Time\"", "syntax_pass": true}, {"attribute_expression": "private static final String JAVA_SQL_DATE = \"java.sql.Date\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "JAVA_SQL_DATE = \"java.sql.Date\"", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Override\n    public Object apply(final Class<?> parameter, Object value) {\n        final String targetType = parameter.getName();\n        final Date dateValue = (Date) value;\n        final long time = dateValue.getTime();\n\n        switch (targetType) {\n        case JAVA_SQL_DATE:\n            value = new java.sql.Date(time);\n            break;\n        case JAVA_SQL_TIME:\n            value = new java.sql.Time(time);\n            break;\n        case JAVA_SQL_TIMESTAMP:\n            value = new Timestamp(time);\n            break;\n        default:\n            break;\n        }\n\n        return value;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object", "classes": []}, "name": "apply", "params": [{"name": "parameter", "type": "Class<?>"}, {"name": "value", "type": "Object"}], "body": "                                                                {\n        final String targetType = parameter.getName();\n        final Date dateValue = (Date) value;\n        final long time = dateValue.getTime();\n\n        switch (targetType) {\n        case JAVA_SQL_DATE:\n            value = new java.sql.Date(time);\n            break;\n        case JAVA_SQL_TIME:\n            value = new java.sql.Time(time);\n            break;\n        case JAVA_SQL_TIMESTAMP:\n            value = new Timestamp(time);\n            break;\n        default:\n            break;\n        }\n\n        return value;\n    }", "signature": "@Override\n    public Object apply(final Class<?> parameter, Object value)"}, {"syntax_pass": true, "original_string": "    @Override\n    public boolean match(final Class<?> parameter, final Object value) {\n        if (value instanceof Date) {\n            final String targetType = parameter.getName();\n            if (JAVA_SQL_DATE.equals(targetType)) {\n                return true;\n            }\n            if (JAVA_SQL_TIME.equals(targetType)) {\n                return true;\n            }\n            if (JAVA_SQL_TIMESTAMP.equals(targetType) && !Timestamp.class.isInstance(value)) {\n                return true;\n            }\n        }\n\n        return false;\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "match", "params": [{"name": "parameter", "type": "Class<?>"}, {"name": "value", "type": "Object"}], "body": "                                                                       {\n        if (value instanceof Date) {\n            final String targetType = parameter.getName();\n            if (JAVA_SQL_DATE.equals(targetType)) {\n                return true;\n            }\n            if (JAVA_SQL_TIME.equals(targetType)) {\n                return true;\n            }\n            if (JAVA_SQL_TIMESTAMP.equals(targetType) && !Timestamp.class.isInstance(value)) {\n                return true;\n            }\n        }\n\n        return false;\n    }", "signature": "@Override\n    public boolean match(final Class<?> parameter, final Object value)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/apache/commons/dbutils/handlers/properties/StringEnumPropertyHandler.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils.handlers.properties;\n\nimport org.apache.commons.dbutils.PropertyHandler;\n\n/**\n * {@link PropertyHandler} for enums. Will convert strings to enums.\n */\npublic class StringEnumPropertyHandler implements PropertyHandler {\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public Object apply(final Class<?> parameter, final Object value) {\n        return Enum.valueOf(parameter.asSubclass(Enum.class), (String) value);\n    }\n\n    @Override\n    public boolean match(final Class<?> parameter, final Object value) {\n        return value instanceof String && parameter.isEnum();\n    }\n}\n", "file_hash": "39650aeccb947ea3e7f9364304b5b697344c4e6e16a6388d865b1949a6b46d4f", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils.handlers.properties;", "import org.apache.commons.dbutils.PropertyHandler;"], "methods": [], "classes": [{"original_string": "public class StringEnumPropertyHandler implements PropertyHandler {\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public Object apply(final Class<?> parameter, final Object value) {\n        return Enum.valueOf(parameter.asSubclass(Enum.class), (String) value);\n    }\n\n    @Override\n    public boolean match(final Class<?> parameter, final Object value) {\n        return value instanceof String && parameter.isEnum();\n    }\n}", "definition": "public class StringEnumPropertyHandler implements PropertyHandler", "class_docstring": "\n{@link PropertyHandler} for enums. Will convert strings to enums.\n", "name": "StringEnumPropertyHandler", "super_interfaces": ["PropertyHandler"], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    @Override\n    @SuppressWarnings(\"unchecked\")\n    public Object apply(final Class<?> parameter, final Object value) {\n        return Enum.valueOf(parameter.asSubclass(Enum.class), (String) value);\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    @SuppressWarnings(\"unchecked\")\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "Object", "classes": []}, "name": "apply", "params": [{"name": "parameter", "type": "Class<?>"}, {"name": "value", "type": "Object"}], "body": "                                                                      {\n        return Enum.valueOf(parameter.asSubclass(Enum.class), (String) value);\n    }", "signature": "@Override\n    @SuppressWarnings(\"unchecked\")\n    public Object apply(final Class<?> parameter, final Object value)"}, {"syntax_pass": true, "original_string": "    @Override\n    public boolean match(final Class<?> parameter, final Object value) {\n        return value instanceof String && parameter.isEnum();\n    }", "docstring": "", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "match", "params": [{"name": "parameter", "type": "Class<?>"}, {"name": "value", "type": "Object"}], "body": "                                                                       {\n        return value instanceof String && parameter.isEnum();\n    }", "signature": "@Override\n    public boolean match(final Class<?> parameter, final Object value)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/apache/commons/dbutils/handlers/properties/package-info.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Implementations of the org.apache.commons.dbutils.PropertyHandler interface.\n */\npackage org.apache.commons.dbutils.handlers.properties;\n", "file_hash": "b5ef9457d0f3f6a313522b42b26c8da085aa3068f62c8e19a968122b8fc62f3f", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils.handlers.properties;"], "methods": [], "classes": [], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/apache/commons/dbutils/wrappers/StringTrimmedResultSet.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils.wrappers;\n\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.sql.ResultSet;\n\nimport org.apache.commons.dbutils.ProxyFactory;\n\n/**\n * Wraps a {@code ResultSet} to trim strings returned by the\n * {@code getString()} and {@code getObject()} methods.\n *\n * <p>\n * Usage Example:\n * This example shows how to decorate ResultSets so processing continues as\n * normal but all Strings are trimmed before being returned from the\n * {@code ResultSet}.\n * </p>\n *\n * <pre>\n * ResultSet resultSet = // somehow get a ResultSet;\n *\n * // Substitute wrapped ResultSet with additional behavior for real ResultSet\n * resultSet = StringTrimmedResultSet.wrap(resultSet);\n *\n * // Pass wrapped ResultSet to processor\n * List list = new BasicRowProcessor().toBeanList(resultSet);\n * </pre>\n */\npublic class StringTrimmedResultSet implements InvocationHandler {\n\n    /**\n     * Wraps the {@code ResultSet} in an instance of this class.  This is\n     * equivalent to:\n     * <pre>\n     * ProxyFactory.instance().createResultSet(new StringTrimmedResultSet(resultSet));\n     * </pre>\n     *\n     * @param resultSet The {@code ResultSet} to wrap.\n     * @return wrapped ResultSet\n     */\n    public static ResultSet wrap(final ResultSet resultSet) {\n        return ProxyFactory.instance().createResultSet(new StringTrimmedResultSet(resultSet));\n    }\n\n    /**\n     * The wrapped result.\n     */\n    private final ResultSet resultSet;\n\n    /**\n     * Constructs a new instance of {@code StringTrimmedResultSet}\n     * to wrap the specified {@code ResultSet}.\n     * @param resultSet ResultSet to wrap\n     */\n    public StringTrimmedResultSet(final ResultSet resultSet) {\n        this.resultSet = resultSet;\n    }\n\n    /**\n     * Intercept calls to the {@code getString()} and\n     * {@code getObject()} methods and trim any Strings before they're\n     * returned.\n     *\n     * @see java.lang.reflect.InvocationHandler#invoke(Object, java.lang.reflect.Method, Object[])\n     * @param proxy Not used; all method calls go to the internal result set\n     * @param method The method to invoke on the result set\n     * @param args The arguments to pass to the result set\n     * @return string trimmed result\n     * @throws Throwable error\n     */\n    @Override\n    public Object invoke(final Object proxy, final Method method, final Object[] args)\n        throws Throwable {\n\n        Object result = method.invoke(this.resultSet, args);\n\n        if (result instanceof String\n                && (method.getName().equals(\"getObject\")\n                || method.getName().equals(\"getString\"))) {\n            result = ((String) result).trim();\n        }\n\n        return result;\n    }\n\n}\n", "file_hash": "683c49303764429d56043bab0610c4d4214216a0cec0802a4d3749044eaf3cf9", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils.wrappers;", "import java.lang.reflect.InvocationHandler;", "import java.lang.reflect.Method;", "import java.sql.ResultSet;", "import org.apache.commons.dbutils.ProxyFactory;"], "methods": [], "classes": [{"original_string": "public class StringTrimmedResultSet implements InvocationHandler {\n\n    /**\n     * Wraps the {@code ResultSet} in an instance of this class.  This is\n     * equivalent to:\n     * <pre>\n     * ProxyFactory.instance().createResultSet(new StringTrimmedResultSet(resultSet));\n     * </pre>\n     *\n     * @param resultSet The {@code ResultSet} to wrap.\n     * @return wrapped ResultSet\n     */\n    public static ResultSet wrap(final ResultSet resultSet) {\n        return ProxyFactory.instance().createResultSet(new StringTrimmedResultSet(resultSet));\n    }\n\n    /**\n     * The wrapped result.\n     */\n    private final ResultSet resultSet;\n\n    /**\n     * Constructs a new instance of {@code StringTrimmedResultSet}\n     * to wrap the specified {@code ResultSet}.\n     * @param resultSet ResultSet to wrap\n     */\n    public StringTrimmedResultSet(final ResultSet resultSet) {\n        this.resultSet = resultSet;\n    }\n\n    /**\n     * Intercept calls to the {@code getString()} and\n     * {@code getObject()} methods and trim any Strings before they're\n     * returned.\n     *\n     * @see java.lang.reflect.InvocationHandler#invoke(Object, java.lang.reflect.Method, Object[])\n     * @param proxy Not used; all method calls go to the internal result set\n     * @param method The method to invoke on the result set\n     * @param args The arguments to pass to the result set\n     * @return string trimmed result\n     * @throws Throwable error\n     */\n    @Override\n    public Object invoke(final Object proxy, final Method method, final Object[] args)\n        throws Throwable {\n\n        Object result = method.invoke(this.resultSet, args);\n\n        if (result instanceof String\n                && (method.getName().equals(\"getObject\")\n                || method.getName().equals(\"getString\"))) {\n            result = ((String) result).trim();\n        }\n\n        return result;\n    }\n\n}", "definition": "public class StringTrimmedResultSet implements InvocationHandler", "class_docstring": "\nWraps a {@code ResultSet} to trim strings returned by the\n{@code getString()} and {@code getObject()} methods.\n\n<p>\nUsage Example:\nThis example shows how to decorate ResultSets so processing continues as\nnormal but all Strings are trimmed before being returned from the\n{@code ResultSet}.\n</p>\n\n<pre>\nResultSet resultSet = // somehow get a ResultSet;\n\n// Substitute wrapped ResultSet with additional behavior for real ResultSet\nresultSet = StringTrimmedResultSet.wrap(resultSet);\n\n// Pass wrapped ResultSet to processor\nList list = new BasicRowProcessor().toBeanList(resultSet);\n</pre>\n", "name": "StringTrimmedResultSet", "super_interfaces": ["InvocationHandler"], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private final ResultSet resultSet;", "docstring": "\nThe wrapped result.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ResultSet", "name": "resultSet", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public static ResultSet wrap(final ResultSet resultSet) {\n        return ProxyFactory.instance().createResultSet(new StringTrimmedResultSet(resultSet));\n    }", "docstring": "\nWraps the {@code ResultSet} in an instance of this class.  This is\nequivalent to:\n<pre>\nProxyFactory.instance().createResultSet(new StringTrimmedResultSet(resultSet));\n</pre>\n\n@param resultSet The {@code ResultSet} to wrap.\n@return wrapped ResultSet\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "ResultSet", "classes": []}, "name": "wrap", "params": [{"name": "resultSet", "type": "ResultSet"}], "body": "                                                            {\n        return ProxyFactory.instance().createResultSet(new StringTrimmedResultSet(resultSet));\n    }", "signature": "public static ResultSet wrap(final ResultSet resultSet)"}, {"syntax_pass": true, "original_string": "    public StringTrimmedResultSet(final ResultSet resultSet) {\n        this.resultSet = resultSet;\n    }", "docstring": "\nConstructs a new instance of {@code StringTrimmedResultSet}\nto wrap the specified {@code ResultSet}.\n@param resultSet ResultSet to wrap\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "StringTrimmedResultSet", "params": [{"name": "resultSet", "type": "ResultSet"}], "body": "                                                             {\n        this.resultSet = resultSet;\n    }", "signature": "public StringTrimmedResultSet(final ResultSet resultSet)"}, {"syntax_pass": true, "original_string": "    @Override\n    public Object invoke(final Object proxy, final Method method, final Object[] args)\n        throws Throwable {\n\n        Object result = method.invoke(this.resultSet, args);\n\n        if (result instanceof String\n                && (method.getName().equals(\"getObject\")\n                || method.getName().equals(\"getString\"))) {\n            result = ((String) result).trim();\n        }\n\n        return result;\n    }", "docstring": "\nIntercept calls to the {@code getString()} and\n{@code getObject()} methods and trim any Strings before they're\nreturned.\n\n@see java.lang.reflect.InvocationHandler#invoke(Object, java.lang.reflect.Method, Object[])\n@param proxy Not used; all method calls go to the internal result set\n@param method The method to invoke on the result set\n@param args The arguments to pass to the result set\n@return string trimmed result\n@throws Throwable error\n", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object", "classes": []}, "name": "invoke", "params": [{"name": "proxy", "type": "Object"}, {"name": "method", "type": "Method"}, {"name": "args", "type": "Object[]"}], "body": "                         {\n\n        Object result = method.invoke(this.resultSet, args);\n\n        if (result instanceof String\n                && (method.getName().equals(\"getObject\")\n                || method.getName().equals(\"getString\"))) {\n            result = ((String) result).trim();\n        }\n\n        return result;\n    }", "signature": "@Override\n    public Object invoke(final Object proxy, final Method method, final Object[] args)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/apache/commons/dbutils/wrappers/SqlNullCheckedResultSet.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.dbutils.wrappers;\n\nimport java.io.InputStream;\nimport java.io.Reader;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.math.BigDecimal;\nimport java.net.URL;\nimport java.sql.Blob;\nimport java.sql.Clob;\nimport java.sql.Date;\nimport java.sql.Ref;\nimport java.sql.ResultSet;\nimport java.sql.Time;\nimport java.sql.Timestamp;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.apache.commons.dbutils.ProxyFactory;\n\n/**\n * Decorates a {@code ResultSet} with checks for a SQL NULL value on each\n * {@code getXXX} method. If a column value obtained by a\n * {@code getXXX} method is not SQL NULL, the column value is returned. If\n * the column value is SQL null, an alternate value is returned. The alternate\n * value defaults to the Java {@code null} value, which can be overridden\n * for instances of the class.\n *\n * <p>\n * Usage example:\n * <blockquote>\n * <pre>\n * Connection conn = // somehow get a connection\n * Statement stmt = conn.createStatement();\n * ResultSet resultSet = stmt.executeQuery(\"SELECT col1, col2 FROM table1\");\n *\n * // Wrap the result set for SQL NULL checking\n * SqlNullCheckedResultSet wrapper = new SqlNullCheckedResultSet(resultSet);\n * wrapper.setNullString(\"---N/A---\"); // Set null string\n * wrapper.setNullInt(-999); // Set null integer\n * resultSet = ProxyFactory.instance().createResultSet(wrapper);\n *\n * while (resultSet.next()) {\n *     // If col1 is SQL NULL, value returned will be \"---N/A---\"\n *     String col1 = resultSet.getString(\"col1\");\n *     // If col2 is SQL NULL, value returned will be -999\n *     int col2 = resultSet.getInt(\"col2\");\n * }\n * resultSet.close();\n * </pre>\n * </blockquote>\n * &lt;/p&gt;\n * <p>Unlike some other classes in DbUtils, this class is NOT thread-safe.</p>\n */\npublic class SqlNullCheckedResultSet implements InvocationHandler {\n\n    /**\n     * Maps normal method names (ie. \"getBigDecimal\") to the corresponding null\n     * Method object (ie. getNullBigDecimal).\n     */\n    private static final Map<String, Method> NULL_METHODS = new HashMap<>();\n\n    /**\n     * The {@code getNull} string prefix.\n     * @since 1.4\n     */\n    private static final String GET_NULL_PREFIX = \"getNull\";\n\n    static {\n        final Method[] methods = SqlNullCheckedResultSet.class.getMethods();\n        for (final Method method : methods) {\n            final String methodName = method.getName();\n\n            if (methodName.startsWith(GET_NULL_PREFIX)) {\n                final String normalName = \"get\" + methodName.substring(GET_NULL_PREFIX.length());\n                NULL_METHODS.put(normalName, method);\n            }\n        }\n    }\n\n    /**\n     * The factory to create proxies with.\n     */\n    private static final ProxyFactory factory = ProxyFactory.instance();\n\n    /**\n     * Wraps the {@code ResultSet} in an instance of this class.  This is\n     * equivalent to:\n     * <pre>\n     * ProxyFactory.instance().createResultSet(new SqlNullCheckedResultSet(resultSet));\n     * </pre>\n     *\n     * @param resultSet The {@code ResultSet} to wrap.\n     * @return wrapped ResultSet\n     */\n    public static ResultSet wrap(final ResultSet resultSet) {\n        return factory.createResultSet(new SqlNullCheckedResultSet(resultSet));\n    }\n\n    private InputStream nullAsciiStream;\n    private BigDecimal nullBigDecimal;\n    private InputStream nullBinaryStream;\n    private Blob nullBlob;\n    private boolean nullBoolean;\n    private byte nullByte;\n    private byte[] nullBytes;\n    private Reader nullCharacterStream;\n    private Clob nullClob;\n    private Date nullDate;\n    private double nullDouble;\n    private float nullFloat;\n    private int nullInt;\n    private long nullLong;\n    private Object nullObject;\n    private Ref nullRef;\n    private short nullShort;\n    private String nullString;\n    private Time nullTime;\n    private Timestamp nullTimestamp;\n    private URL nullURL;\n\n    /**\n     * The wrapped result.\n     */\n    private final ResultSet resultSet;\n\n    /**\n     * Constructs a new instance of\n     * {@code SqlNullCheckedResultSet}\n     * to wrap the specified {@code ResultSet}.\n     * @param resultSet ResultSet to wrap\n     */\n    public SqlNullCheckedResultSet(final ResultSet resultSet) {\n        this.resultSet = resultSet;\n    }\n\n    /**\n     * Returns the value when a SQL null is encountered as the result of\n     * invoking a {@code getAsciiStream} method.\n     *\n     * @return the value\n     */\n    public InputStream getNullAsciiStream() {\n        return this.nullAsciiStream;\n    }\n\n    /**\n     * Returns the value when a SQL null is encountered as the result of\n     * invoking a {@code getBigDecimal} method.\n     *\n     * @return the value\n     */\n    public BigDecimal getNullBigDecimal() {\n        return this.nullBigDecimal;\n    }\n\n    /**\n     * Returns the value when a SQL null is encountered as the result of\n     * invoking a {@code getBinaryStream} method.\n     *\n     * @return the value\n     */\n    public InputStream getNullBinaryStream() {\n        return this.nullBinaryStream;\n    }\n\n    /**\n     * Returns the value when a SQL null is encountered as the result of\n     * invoking a {@code getBlob} method.\n     *\n     * @return the value\n     */\n    public Blob getNullBlob() {\n        return this.nullBlob;\n    }\n\n    /**\n     * Returns the value when a SQL null is encountered as the result of\n     * invoking a {@code getBoolean} method.\n     *\n     * @return the value\n     */\n    public boolean getNullBoolean() {\n        return this.nullBoolean;\n    }\n\n    /**\n     * Returns the value when a SQL null is encountered as the result of\n     * invoking a {@code getByte} method.\n     *\n     * @return the value\n     */\n    public byte getNullByte() {\n        return this.nullByte;\n    }\n\n    /**\n     * Returns the value when a SQL null is encountered as the result of\n     * invoking a {@code getBytes} method.\n     *\n     * @return the value\n     */\n    public byte[] getNullBytes() {\n        if (this.nullBytes == null) {\n            return null;\n        }\n        return this.nullBytes.clone();\n    }\n\n    /**\n     * Returns the value when a SQL null is encountered as the result of\n     * invoking a {@code getCharacterStream} method.\n     *\n     * @return the value\n     */\n    public Reader getNullCharacterStream() {\n        return this.nullCharacterStream;\n    }\n\n    /**\n     * Returns the value when a SQL null is encountered as the result of\n     * invoking a {@code getClob} method.\n     *\n     * @return the value\n     */\n    public Clob getNullClob() {\n        return this.nullClob;\n    }\n\n    /**\n     * Returns the value when a SQL null is encountered as the result of\n     * invoking a {@code getDate} method.\n     *\n     * @return the value\n     */\n    public Date getNullDate() {\n        return this.nullDate != null ? new Date(this.nullDate.getTime()) : null;\n    }\n\n    /**\n     * Returns the value when a SQL null is encountered as the result of\n     * invoking a {@code getDouble} method.\n     *\n     * @return the value\n     */\n    public double getNullDouble() {\n        return this.nullDouble;\n    }\n\n    /**\n     * Returns the value when a SQL null is encountered as the result of\n     * invoking a {@code getFloat} method.\n     *\n     * @return the value\n     */\n    public float getNullFloat() {\n        return this.nullFloat;\n    }\n\n    /**\n     * Returns the value when a SQL null is encountered as the result of\n     * invoking a {@code getInt} method.\n     *\n     * @return the value\n     */\n    public int getNullInt() {\n        return this.nullInt;\n    }\n\n    /**\n     * Returns the value when a SQL null is encountered as the result of\n     * invoking a {@code getLong} method.\n     *\n     * @return the value\n     */\n    public long getNullLong() {\n        return this.nullLong;\n    }\n\n    /**\n     * Returns the value when a SQL null is encountered as the result of\n     * invoking a {@code getObject} method.\n     *\n     * @return the value\n     */\n    public Object getNullObject() {\n        return this.nullObject;\n    }\n\n    /**\n     * Returns the value when a SQL null is encountered as the result of\n     * invoking a {@code getRef} method.\n     *\n     * @return the value\n     */\n    public Ref getNullRef() {\n        return this.nullRef;\n    }\n\n    /**\n     * Returns the value when a SQL null is encountered as the result of\n     * invoking a {@code getShort} method.\n     *\n     * @return the value\n     */\n    public short getNullShort() {\n        return this.nullShort;\n    }\n\n    /**\n     * Returns the value when a SQL null is encountered as the result of\n     * invoking a {@code getString} method.\n     *\n     * @return the value\n     */\n    public String getNullString() {\n        return this.nullString;\n    }\n\n    /**\n     * Returns the value when a SQL null is encountered as the result of\n     * invoking a {@code getTime} method.\n     *\n     * @return the value\n     */\n    public Time getNullTime() {\n        return this.nullTime != null ? new Time(this.nullTime.getTime()) : null;\n    }\n\n    /**\n     * Returns the value when a SQL null is encountered as the result of\n     * invoking a {@code getTimestamp} method.\n     *\n     * @return the value\n     */\n    public Timestamp getNullTimestamp() {\n        if (this.nullTimestamp == null) {\n            return null;\n        }\n\n        final Timestamp ts = new Timestamp(this.nullTimestamp.getTime());\n        ts.setNanos(this.nullTimestamp.getNanos());\n        return ts;\n    }\n\n    /**\n     * Returns the value when a SQL null is encountered as the result of\n     * invoking a {@code getURL} method.\n     *\n     * @return the value\n     */\n    public URL getNullURL() {\n        return this.nullURL;\n    }\n\n    /**\n     * Intercepts calls to {@code get*} methods and calls the appropriate\n     * {@code getNull*} method if the {@code ResultSet} returned\n     * {@code null}.\n     *\n     * @see java.lang.reflect.InvocationHandler#invoke(Object, java.lang.reflect.Method, Object[])\n     * @param proxy Not used; all method calls go to the internal result set\n     * @param method The method to invoke on the result set\n     * @param args The arguments to pass to the result set\n     * @return null checked result\n     * @throws Throwable error\n     */\n    @Override\n    public Object invoke(final Object proxy, final Method method, final Object[] args)\n        throws Throwable {\n\n        final Object result = method.invoke(this.resultSet, args);\n\n        final Method nullMethod = NULL_METHODS.get(method.getName());\n\n        // Check nullMethod != null first so that we don't call wasNull()\n        // before a true getter method was invoked on the ResultSet.\n        return nullMethod != null && this.resultSet.wasNull()\n            ? nullMethod.invoke(this, (Object[]) null)\n            : result;\n    }\n\n    /**\n     * Sets the value to return when a SQL null is encountered as the result of\n     * invoking a {@code getAsciiStream} method.\n     *\n     * @param nullAsciiStream the value\n     */\n    public void setNullAsciiStream(final InputStream nullAsciiStream) {\n        this.nullAsciiStream = nullAsciiStream;\n    }\n\n    /**\n     * Sets the value to return when a SQL null is encountered as the result of\n     * invoking a {@code getBigDecimal} method.\n     *\n     * @param nullBigDecimal the value\n     */\n    public void setNullBigDecimal(final BigDecimal nullBigDecimal) {\n        this.nullBigDecimal = nullBigDecimal;\n    }\n\n    /**\n     * Sets the value to return when a SQL null is encountered as the result of\n     * invoking a {@code getBinaryStream} method.\n     *\n     * @param nullBinaryStream the value\n     */\n    public void setNullBinaryStream(final InputStream nullBinaryStream) {\n        this.nullBinaryStream = nullBinaryStream;\n    }\n\n    /**\n     * Sets the value to return when a SQL null is encountered as the result of\n     * invoking a {@code getBlob} method.\n     *\n     * @param nullBlob the value\n     */\n    public void setNullBlob(final Blob nullBlob) {\n        this.nullBlob = nullBlob;\n    }\n\n    /**\n     * Sets the value to return when a SQL null is encountered as the result of\n     * invoking a {@code getBoolean} method.\n     *\n     * @param nullBoolean the value\n     */\n    public void setNullBoolean(final boolean nullBoolean) {\n        this.nullBoolean = nullBoolean;\n    }\n\n    /**\n     * Sets the value to return when a SQL null is encountered as the result of\n     * invoking a {@code getByte} method.\n     *\n     * @param nullByte the value\n     */\n    public void setNullByte(final byte nullByte) {\n        this.nullByte = nullByte;\n    }\n\n    /**\n     * Sets the value to return when a SQL null is encountered as the result of\n     * invoking a {@code getBytes} method.\n     *\n     * @param nullBytes the value\n     */\n    public void setNullBytes(final byte[] nullBytes) {\n        if (nullBytes != null) {\n            this.nullBytes = nullBytes.clone();\n        } else {\n            this.nullBytes = null;\n        }\n    }\n\n    /**\n     * Sets the value to return when a SQL null is encountered as the result of\n     * invoking a {@code getCharacterStream} method.\n     *\n     * @param nullCharacterStream the value\n     */\n    public void setNullCharacterStream(final Reader nullCharacterStream) {\n        this.nullCharacterStream = nullCharacterStream;\n    }\n\n    /**\n     * Sets the value to return when a SQL null is encountered as the result of\n     * invoking a {@code getClob} method.\n     *\n     * @param nullClob the value\n     */\n    public void setNullClob(final Clob nullClob) {\n        this.nullClob = nullClob;\n    }\n\n    /**\n     * Sets the value to return when a SQL null is encountered as the result of\n     * invoking a {@code getDate} method.\n     *\n     * @param nullDate the value\n     */\n    public void setNullDate(final Date nullDate) {\n        this.nullDate = nullDate != null ? new Date(nullDate.getTime()) : null;\n    }\n\n    /**\n     * Sets the value to return when a SQL null is encountered as the result of\n     * invoking a {@code getDouble} method.\n     *\n     * @param nullDouble the value\n     */\n    public void setNullDouble(final double nullDouble) {\n        this.nullDouble = nullDouble;\n    }\n\n    /**\n     * Sets the value to return when a SQL null is encountered as the result of\n     * invoking a {@code getFloat} method.\n     *\n     * @param nullFloat the value\n     */\n    public void setNullFloat(final float nullFloat) {\n        this.nullFloat = nullFloat;\n    }\n\n    /**\n     * Sets the value to return when a SQL null is encountered as the result of\n     * invoking a {@code getInt} method.\n     *\n     * @param nullInt the value\n     */\n    public void setNullInt(final int nullInt) {\n        this.nullInt = nullInt;\n    }\n\n    /**\n     * Sets the value to return when a SQL null is encountered as the result of\n     * invoking a {@code getLong} method.\n     *\n     * @param nullLong the value\n     */\n    public void setNullLong(final long nullLong) {\n        this.nullLong = nullLong;\n    }\n\n    /**\n     * Sets the value to return when a SQL null is encountered as the result of\n     * invoking a {@code getObject} method.\n     *\n     * @param nullObject the value\n     */\n    public void setNullObject(final Object nullObject) {\n        this.nullObject = nullObject;\n    }\n\n    /**\n     * Sets the value to return when a SQL null is encountered as the result of\n     * invoking a {@code getRef} method.\n     *\n     * @param nullRef the value\n     */\n    public void setNullRef(final Ref nullRef) {\n        this.nullRef = nullRef;\n    }\n\n    /**\n     * Sets the value to return when a SQL null is encountered as the result of\n     * invoking a {@code getShort} method.\n     *\n     * @param nullShort the value\n     */\n    public void setNullShort(final short nullShort) {\n        this.nullShort = nullShort;\n    }\n\n    /**\n     * Sets the value to return when a SQL null is encountered as the result of\n     * invoking a {@code getString} method.\n     *\n     * @param nullString the value\n     */\n    public void setNullString(final String nullString) {\n        this.nullString = nullString;\n    }\n\n    /**\n     * Sets the value to return when a SQL null is encountered as the result of\n     * invoking a {@code getTime} method.\n     *\n     * @param nullTime the value\n     */\n    public void setNullTime(final Time nullTime) {\n        this.nullTime = nullTime != null ? new Time(nullTime.getTime()) : null;\n    }\n\n    /**\n     * Sets the value to return when a SQL null is encountered as the result of\n     * invoking a {@code getTimestamp} method.\n     *\n     * @param nullTimestamp the value\n     */\n    public void setNullTimestamp(final Timestamp nullTimestamp) {\n        if (nullTimestamp != null) {\n            this.nullTimestamp = new Timestamp(nullTimestamp.getTime());\n            this.nullTimestamp.setNanos(nullTimestamp.getNanos());\n        } else {\n            this.nullTimestamp = null;\n        }\n    }\n\n    /**\n     * Sets the value to return when a SQL null is encountered as the result of\n     * invoking a {@code getURL} method.\n     *\n     * @param nullURL the value\n     */\n    public void setNullURL(final URL nullURL) {\n        this.nullURL = nullURL;\n    }\n\n}\n", "file_hash": "b6d1839b584d1411e78dac70fdcc7e2ced989c78b39e53951003af5da3c158ab", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils.wrappers;", "import java.io.InputStream;", "import java.io.Reader;", "import java.lang.reflect.InvocationHandler;", "import java.lang.reflect.Method;", "import java.math.BigDecimal;", "import java.net.URL;", "import java.sql.Blob;", "import java.sql.Clob;", "import java.sql.Date;", "import java.sql.Ref;", "import java.sql.ResultSet;", "import java.sql.Time;", "import java.sql.Timestamp;", "import java.util.HashMap;", "import java.util.Map;", "import org.apache.commons.dbutils.ProxyFactory;"], "methods": [], "classes": [{"original_string": "public class SqlNullCheckedResultSet implements InvocationHandler {\n\n    /**\n     * Maps normal method names (ie. \"getBigDecimal\") to the corresponding null\n     * Method object (ie. getNullBigDecimal).\n     */\n    private static final Map<String, Method> NULL_METHODS = new HashMap<>();\n\n    /**\n     * The {@code getNull} string prefix.\n     * @since 1.4\n     */\n    private static final String GET_NULL_PREFIX = \"getNull\";\n\n    static {\n        final Method[] methods = SqlNullCheckedResultSet.class.getMethods();\n        for (final Method method : methods) {\n            final String methodName = method.getName();\n\n            if (methodName.startsWith(GET_NULL_PREFIX)) {\n                final String normalName = \"get\" + methodName.substring(GET_NULL_PREFIX.length());\n                NULL_METHODS.put(normalName, method);\n            }\n        }\n    }\n\n    /**\n     * The factory to create proxies with.\n     */\n    private static final ProxyFactory factory = ProxyFactory.instance();\n\n    /**\n     * Wraps the {@code ResultSet} in an instance of this class.  This is\n     * equivalent to:\n     * <pre>\n     * ProxyFactory.instance().createResultSet(new SqlNullCheckedResultSet(resultSet));\n     * </pre>\n     *\n     * @param resultSet The {@code ResultSet} to wrap.\n     * @return wrapped ResultSet\n     */\n    public static ResultSet wrap(final ResultSet resultSet) {\n        return factory.createResultSet(new SqlNullCheckedResultSet(resultSet));\n    }\n\n    private InputStream nullAsciiStream;\n    private BigDecimal nullBigDecimal;\n    private InputStream nullBinaryStream;\n    private Blob nullBlob;\n    private boolean nullBoolean;\n    private byte nullByte;\n    private byte[] nullBytes;\n    private Reader nullCharacterStream;\n    private Clob nullClob;\n    private Date nullDate;\n    private double nullDouble;\n    private float nullFloat;\n    private int nullInt;\n    private long nullLong;\n    private Object nullObject;\n    private Ref nullRef;\n    private short nullShort;\n    private String nullString;\n    private Time nullTime;\n    private Timestamp nullTimestamp;\n    private URL nullURL;\n\n    /**\n     * The wrapped result.\n     */\n    private final ResultSet resultSet;\n\n    /**\n     * Constructs a new instance of\n     * {@code SqlNullCheckedResultSet}\n     * to wrap the specified {@code ResultSet}.\n     * @param resultSet ResultSet to wrap\n     */\n    public SqlNullCheckedResultSet(final ResultSet resultSet) {\n        this.resultSet = resultSet;\n    }\n\n    /**\n     * Returns the value when a SQL null is encountered as the result of\n     * invoking a {@code getAsciiStream} method.\n     *\n     * @return the value\n     */\n    public InputStream getNullAsciiStream() {\n        return this.nullAsciiStream;\n    }\n\n    /**\n     * Returns the value when a SQL null is encountered as the result of\n     * invoking a {@code getBigDecimal} method.\n     *\n     * @return the value\n     */\n    public BigDecimal getNullBigDecimal() {\n        return this.nullBigDecimal;\n    }\n\n    /**\n     * Returns the value when a SQL null is encountered as the result of\n     * invoking a {@code getBinaryStream} method.\n     *\n     * @return the value\n     */\n    public InputStream getNullBinaryStream() {\n        return this.nullBinaryStream;\n    }\n\n    /**\n     * Returns the value when a SQL null is encountered as the result of\n     * invoking a {@code getBlob} method.\n     *\n     * @return the value\n     */\n    public Blob getNullBlob() {\n        return this.nullBlob;\n    }\n\n    /**\n     * Returns the value when a SQL null is encountered as the result of\n     * invoking a {@code getBoolean} method.\n     *\n     * @return the value\n     */\n    public boolean getNullBoolean() {\n        return this.nullBoolean;\n    }\n\n    /**\n     * Returns the value when a SQL null is encountered as the result of\n     * invoking a {@code getByte} method.\n     *\n     * @return the value\n     */\n    public byte getNullByte() {\n        return this.nullByte;\n    }\n\n    /**\n     * Returns the value when a SQL null is encountered as the result of\n     * invoking a {@code getBytes} method.\n     *\n     * @return the value\n     */\n    public byte[] getNullBytes() {\n        if (this.nullBytes == null) {\n            return null;\n        }\n        return this.nullBytes.clone();\n    }\n\n    /**\n     * Returns the value when a SQL null is encountered as the result of\n     * invoking a {@code getCharacterStream} method.\n     *\n     * @return the value\n     */\n    public Reader getNullCharacterStream() {\n        return this.nullCharacterStream;\n    }\n\n    /**\n     * Returns the value when a SQL null is encountered as the result of\n     * invoking a {@code getClob} method.\n     *\n     * @return the value\n     */\n    public Clob getNullClob() {\n        return this.nullClob;\n    }\n\n    /**\n     * Returns the value when a SQL null is encountered as the result of\n     * invoking a {@code getDate} method.\n     *\n     * @return the value\n     */\n    public Date getNullDate() {\n        return this.nullDate != null ? new Date(this.nullDate.getTime()) : null;\n    }\n\n    /**\n     * Returns the value when a SQL null is encountered as the result of\n     * invoking a {@code getDouble} method.\n     *\n     * @return the value\n     */\n    public double getNullDouble() {\n        return this.nullDouble;\n    }\n\n    /**\n     * Returns the value when a SQL null is encountered as the result of\n     * invoking a {@code getFloat} method.\n     *\n     * @return the value\n     */\n    public float getNullFloat() {\n        return this.nullFloat;\n    }\n\n    /**\n     * Returns the value when a SQL null is encountered as the result of\n     * invoking a {@code getInt} method.\n     *\n     * @return the value\n     */\n    public int getNullInt() {\n        return this.nullInt;\n    }\n\n    /**\n     * Returns the value when a SQL null is encountered as the result of\n     * invoking a {@code getLong} method.\n     *\n     * @return the value\n     */\n    public long getNullLong() {\n        return this.nullLong;\n    }\n\n    /**\n     * Returns the value when a SQL null is encountered as the result of\n     * invoking a {@code getObject} method.\n     *\n     * @return the value\n     */\n    public Object getNullObject() {\n        return this.nullObject;\n    }\n\n    /**\n     * Returns the value when a SQL null is encountered as the result of\n     * invoking a {@code getRef} method.\n     *\n     * @return the value\n     */\n    public Ref getNullRef() {\n        return this.nullRef;\n    }\n\n    /**\n     * Returns the value when a SQL null is encountered as the result of\n     * invoking a {@code getShort} method.\n     *\n     * @return the value\n     */\n    public short getNullShort() {\n        return this.nullShort;\n    }\n\n    /**\n     * Returns the value when a SQL null is encountered as the result of\n     * invoking a {@code getString} method.\n     *\n     * @return the value\n     */\n    public String getNullString() {\n        return this.nullString;\n    }\n\n    /**\n     * Returns the value when a SQL null is encountered as the result of\n     * invoking a {@code getTime} method.\n     *\n     * @return the value\n     */\n    public Time getNullTime() {\n        return this.nullTime != null ? new Time(this.nullTime.getTime()) : null;\n    }\n\n    /**\n     * Returns the value when a SQL null is encountered as the result of\n     * invoking a {@code getTimestamp} method.\n     *\n     * @return the value\n     */\n    public Timestamp getNullTimestamp() {\n        if (this.nullTimestamp == null) {\n            return null;\n        }\n\n        final Timestamp ts = new Timestamp(this.nullTimestamp.getTime());\n        ts.setNanos(this.nullTimestamp.getNanos());\n        return ts;\n    }\n\n    /**\n     * Returns the value when a SQL null is encountered as the result of\n     * invoking a {@code getURL} method.\n     *\n     * @return the value\n     */\n    public URL getNullURL() {\n        return this.nullURL;\n    }\n\n    /**\n     * Intercepts calls to {@code get*} methods and calls the appropriate\n     * {@code getNull*} method if the {@code ResultSet} returned\n     * {@code null}.\n     *\n     * @see java.lang.reflect.InvocationHandler#invoke(Object, java.lang.reflect.Method, Object[])\n     * @param proxy Not used; all method calls go to the internal result set\n     * @param method The method to invoke on the result set\n     * @param args The arguments to pass to the result set\n     * @return null checked result\n     * @throws Throwable error\n     */\n    @Override\n    public Object invoke(final Object proxy, final Method method, final Object[] args)\n        throws Throwable {\n\n        final Object result = method.invoke(this.resultSet, args);\n\n        final Method nullMethod = NULL_METHODS.get(method.getName());\n\n        // Check nullMethod != null first so that we don't call wasNull()\n        // before a true getter method was invoked on the ResultSet.\n        return nullMethod != null && this.resultSet.wasNull()\n            ? nullMethod.invoke(this, (Object[]) null)\n            : result;\n    }\n\n    /**\n     * Sets the value to return when a SQL null is encountered as the result of\n     * invoking a {@code getAsciiStream} method.\n     *\n     * @param nullAsciiStream the value\n     */\n    public void setNullAsciiStream(final InputStream nullAsciiStream) {\n        this.nullAsciiStream = nullAsciiStream;\n    }\n\n    /**\n     * Sets the value to return when a SQL null is encountered as the result of\n     * invoking a {@code getBigDecimal} method.\n     *\n     * @param nullBigDecimal the value\n     */\n    public void setNullBigDecimal(final BigDecimal nullBigDecimal) {\n        this.nullBigDecimal = nullBigDecimal;\n    }\n\n    /**\n     * Sets the value to return when a SQL null is encountered as the result of\n     * invoking a {@code getBinaryStream} method.\n     *\n     * @param nullBinaryStream the value\n     */\n    public void setNullBinaryStream(final InputStream nullBinaryStream) {\n        this.nullBinaryStream = nullBinaryStream;\n    }\n\n    /**\n     * Sets the value to return when a SQL null is encountered as the result of\n     * invoking a {@code getBlob} method.\n     *\n     * @param nullBlob the value\n     */\n    public void setNullBlob(final Blob nullBlob) {\n        this.nullBlob = nullBlob;\n    }\n\n    /**\n     * Sets the value to return when a SQL null is encountered as the result of\n     * invoking a {@code getBoolean} method.\n     *\n     * @param nullBoolean the value\n     */\n    public void setNullBoolean(final boolean nullBoolean) {\n        this.nullBoolean = nullBoolean;\n    }\n\n    /**\n     * Sets the value to return when a SQL null is encountered as the result of\n     * invoking a {@code getByte} method.\n     *\n     * @param nullByte the value\n     */\n    public void setNullByte(final byte nullByte) {\n        this.nullByte = nullByte;\n    }\n\n    /**\n     * Sets the value to return when a SQL null is encountered as the result of\n     * invoking a {@code getBytes} method.\n     *\n     * @param nullBytes the value\n     */\n    public void setNullBytes(final byte[] nullBytes) {\n        if (nullBytes != null) {\n            this.nullBytes = nullBytes.clone();\n        } else {\n            this.nullBytes = null;\n        }\n    }\n\n    /**\n     * Sets the value to return when a SQL null is encountered as the result of\n     * invoking a {@code getCharacterStream} method.\n     *\n     * @param nullCharacterStream the value\n     */\n    public void setNullCharacterStream(final Reader nullCharacterStream) {\n        this.nullCharacterStream = nullCharacterStream;\n    }\n\n    /**\n     * Sets the value to return when a SQL null is encountered as the result of\n     * invoking a {@code getClob} method.\n     *\n     * @param nullClob the value\n     */\n    public void setNullClob(final Clob nullClob) {\n        this.nullClob = nullClob;\n    }\n\n    /**\n     * Sets the value to return when a SQL null is encountered as the result of\n     * invoking a {@code getDate} method.\n     *\n     * @param nullDate the value\n     */\n    public void setNullDate(final Date nullDate) {\n        this.nullDate = nullDate != null ? new Date(nullDate.getTime()) : null;\n    }\n\n    /**\n     * Sets the value to return when a SQL null is encountered as the result of\n     * invoking a {@code getDouble} method.\n     *\n     * @param nullDouble the value\n     */\n    public void setNullDouble(final double nullDouble) {\n        this.nullDouble = nullDouble;\n    }\n\n    /**\n     * Sets the value to return when a SQL null is encountered as the result of\n     * invoking a {@code getFloat} method.\n     *\n     * @param nullFloat the value\n     */\n    public void setNullFloat(final float nullFloat) {\n        this.nullFloat = nullFloat;\n    }\n\n    /**\n     * Sets the value to return when a SQL null is encountered as the result of\n     * invoking a {@code getInt} method.\n     *\n     * @param nullInt the value\n     */\n    public void setNullInt(final int nullInt) {\n        this.nullInt = nullInt;\n    }\n\n    /**\n     * Sets the value to return when a SQL null is encountered as the result of\n     * invoking a {@code getLong} method.\n     *\n     * @param nullLong the value\n     */\n    public void setNullLong(final long nullLong) {\n        this.nullLong = nullLong;\n    }\n\n    /**\n     * Sets the value to return when a SQL null is encountered as the result of\n     * invoking a {@code getObject} method.\n     *\n     * @param nullObject the value\n     */\n    public void setNullObject(final Object nullObject) {\n        this.nullObject = nullObject;\n    }\n\n    /**\n     * Sets the value to return when a SQL null is encountered as the result of\n     * invoking a {@code getRef} method.\n     *\n     * @param nullRef the value\n     */\n    public void setNullRef(final Ref nullRef) {\n        this.nullRef = nullRef;\n    }\n\n    /**\n     * Sets the value to return when a SQL null is encountered as the result of\n     * invoking a {@code getShort} method.\n     *\n     * @param nullShort the value\n     */\n    public void setNullShort(final short nullShort) {\n        this.nullShort = nullShort;\n    }\n\n    /**\n     * Sets the value to return when a SQL null is encountered as the result of\n     * invoking a {@code getString} method.\n     *\n     * @param nullString the value\n     */\n    public void setNullString(final String nullString) {\n        this.nullString = nullString;\n    }\n\n    /**\n     * Sets the value to return when a SQL null is encountered as the result of\n     * invoking a {@code getTime} method.\n     *\n     * @param nullTime the value\n     */\n    public void setNullTime(final Time nullTime) {\n        this.nullTime = nullTime != null ? new Time(nullTime.getTime()) : null;\n    }\n\n    /**\n     * Sets the value to return when a SQL null is encountered as the result of\n     * invoking a {@code getTimestamp} method.\n     *\n     * @param nullTimestamp the value\n     */\n    public void setNullTimestamp(final Timestamp nullTimestamp) {\n        if (nullTimestamp != null) {\n            this.nullTimestamp = new Timestamp(nullTimestamp.getTime());\n            this.nullTimestamp.setNanos(nullTimestamp.getNanos());\n        } else {\n            this.nullTimestamp = null;\n        }\n    }\n\n    /**\n     * Sets the value to return when a SQL null is encountered as the result of\n     * invoking a {@code getURL} method.\n     *\n     * @param nullURL the value\n     */\n    public void setNullURL(final URL nullURL) {\n        this.nullURL = nullURL;\n    }\n\n}", "definition": "public class SqlNullCheckedResultSet implements InvocationHandler", "class_docstring": "\nDecorates a {@code ResultSet} with checks for a SQL NULL value on each\n{@code getXXX} method. If a column value obtained by a\n{@code getXXX} method is not SQL NULL, the column value is returned. If\nthe column value is SQL null, an alternate value is returned. The alternate\nvalue defaults to the Java {@code null} value, which can be overridden\nfor instances of the class.\n\n<p>\nUsage example:\n<blockquote>\n<pre>\nConnection conn = // somehow get a connection\nStatement stmt = conn.createStatement();\nResultSet resultSet = stmt.executeQuery(\"SELECT col1, col2 FROM table1\");\n\n// Wrap the result set for SQL NULL checking\nSqlNullCheckedResultSet wrapper = new SqlNullCheckedResultSet(resultSet);\nwrapper.setNullString(\"---N/A---\"); // Set null string\nwrapper.setNullInt(-999); // Set null integer\nresultSet = ProxyFactory.instance().createResultSet(wrapper);\n\nwhile (resultSet.next()) {\n    // If col1 is SQL NULL, value returned will be \"---N/A---\"\n    String col1 = resultSet.getString(\"col1\");\n    // If col2 is SQL NULL, value returned will be -999\n    int col2 = resultSet.getInt(\"col2\");\n}\nresultSet.close();\n</pre>\n</blockquote>\n&lt;/p&gt;\n<p>Unlike some other classes in DbUtils, this class is NOT thread-safe.</p>\n", "name": "SqlNullCheckedResultSet", "super_interfaces": ["InvocationHandler"], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "private static final Map<String, Method> NULL_METHODS = new HashMap<>();", "docstring": "\nMaps normal method names (ie. \"getBigDecimal\") to the corresponding null\nMethod object (ie. getNullBigDecimal).\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Map<String, Method>", "name": "NULL_METHODS = new HashMap<>()", "syntax_pass": true}, {"attribute_expression": "private static final String GET_NULL_PREFIX = \"getNull\";", "docstring": "\nThe {@code getNull} string prefix.\n@since 1.4\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "GET_NULL_PREFIX = \"getNull\"", "syntax_pass": true}, {"attribute_expression": "private static final ProxyFactory factory = ProxyFactory.instance();", "docstring": "\nThe factory to create proxies with.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "ProxyFactory", "name": "factory = ProxyFactory.instance()", "syntax_pass": true}, {"attribute_expression": "private InputStream nullAsciiStream;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "InputStream", "name": "nullAsciiStream", "syntax_pass": true}, {"attribute_expression": "private BigDecimal nullBigDecimal;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "BigDecimal", "name": "nullBigDecimal", "syntax_pass": true}, {"attribute_expression": "private InputStream nullBinaryStream;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "InputStream", "name": "nullBinaryStream", "syntax_pass": true}, {"attribute_expression": "private Blob nullBlob;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Blob", "name": "nullBlob", "syntax_pass": true}, {"attribute_expression": "private boolean nullBoolean;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "nullBoolean", "syntax_pass": true}, {"attribute_expression": "private byte nullByte;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "byte", "name": "nullByte", "syntax_pass": true}, {"attribute_expression": "private byte[] nullBytes;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "byte[]", "name": "nullBytes", "syntax_pass": true}, {"attribute_expression": "private Reader nullCharacterStream;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Reader", "name": "nullCharacterStream", "syntax_pass": true}, {"attribute_expression": "private Clob nullClob;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Clob", "name": "nullClob", "syntax_pass": true}, {"attribute_expression": "private Date nullDate;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Date", "name": "nullDate", "syntax_pass": true}, {"attribute_expression": "private double nullDouble;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "double", "name": "nullDouble", "syntax_pass": true}, {"attribute_expression": "private float nullFloat;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "float", "name": "nullFloat", "syntax_pass": true}, {"attribute_expression": "private int nullInt;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "nullInt", "syntax_pass": true}, {"attribute_expression": "private long nullLong;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "long", "name": "nullLong", "syntax_pass": true}, {"attribute_expression": "private Object nullObject;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Object", "name": "nullObject", "syntax_pass": true}, {"attribute_expression": "private Ref nullRef;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Ref", "name": "nullRef", "syntax_pass": true}, {"attribute_expression": "private short nullShort;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "short", "name": "nullShort", "syntax_pass": true}, {"attribute_expression": "private String nullString;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "nullString", "syntax_pass": true}, {"attribute_expression": "private Time nullTime;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Time", "name": "nullTime", "syntax_pass": true}, {"attribute_expression": "private Timestamp nullTimestamp;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Timestamp", "name": "nullTimestamp", "syntax_pass": true}, {"attribute_expression": "private URL nullURL;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "URL", "name": "nullURL", "syntax_pass": true}, {"attribute_expression": "private final ResultSet resultSet;", "docstring": "\nThe wrapped result.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ResultSet", "name": "resultSet", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "    public static ResultSet wrap(final ResultSet resultSet) {\n        return factory.createResultSet(new SqlNullCheckedResultSet(resultSet));\n    }", "docstring": "\nWraps the {@code ResultSet} in an instance of this class.  This is\nequivalent to:\n<pre>\nProxyFactory.instance().createResultSet(new SqlNullCheckedResultSet(resultSet));\n</pre>\n\n@param resultSet The {@code ResultSet} to wrap.\n@return wrapped ResultSet\n", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "ResultSet", "classes": []}, "name": "wrap", "params": [{"name": "resultSet", "type": "ResultSet"}], "body": "                                                            {\n        return factory.createResultSet(new SqlNullCheckedResultSet(resultSet));\n    }", "signature": "public static ResultSet wrap(final ResultSet resultSet)"}, {"syntax_pass": true, "original_string": "    public SqlNullCheckedResultSet(final ResultSet resultSet) {\n        this.resultSet = resultSet;\n    }", "docstring": "\nConstructs a new instance of\n{@code SqlNullCheckedResultSet}\nto wrap the specified {@code ResultSet}.\n@param resultSet ResultSet to wrap\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "SqlNullCheckedResultSet", "params": [{"name": "resultSet", "type": "ResultSet"}], "body": "                                                              {\n        this.resultSet = resultSet;\n    }", "signature": "public SqlNullCheckedResultSet(final ResultSet resultSet)"}, {"syntax_pass": true, "original_string": "    public InputStream getNullAsciiStream() {\n        return this.nullAsciiStream;\n    }", "docstring": "\nReturns the value when a SQL null is encountered as the result of\ninvoking a {@code getAsciiStream} method.\n\n@return the value\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "InputStream", "classes": []}, "name": "getNullAsciiStream", "params": [], "body": "                                            {\n        return this.nullAsciiStream;\n    }", "signature": "public InputStream getNullAsciiStream()"}, {"syntax_pass": true, "original_string": "    public BigDecimal getNullBigDecimal() {\n        return this.nullBigDecimal;\n    }", "docstring": "\nReturns the value when a SQL null is encountered as the result of\ninvoking a {@code getBigDecimal} method.\n\n@return the value\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "BigDecimal", "classes": []}, "name": "getNullBigDecimal", "params": [], "body": "                                          {\n        return this.nullBigDecimal;\n    }", "signature": "public BigDecimal getNullBigDecimal()"}, {"syntax_pass": true, "original_string": "    public InputStream getNullBinaryStream() {\n        return this.nullBinaryStream;\n    }", "docstring": "\nReturns the value when a SQL null is encountered as the result of\ninvoking a {@code getBinaryStream} method.\n\n@return the value\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "InputStream", "classes": []}, "name": "getNullBinaryStream", "params": [], "body": "                                             {\n        return this.nullBinaryStream;\n    }", "signature": "public InputStream getNullBinaryStream()"}, {"syntax_pass": true, "original_string": "    public Blob getNullBlob() {\n        return this.nullBlob;\n    }", "docstring": "\nReturns the value when a SQL null is encountered as the result of\ninvoking a {@code getBlob} method.\n\n@return the value\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Blob", "classes": []}, "name": "getNullBlob", "params": [], "body": "                              {\n        return this.nullBlob;\n    }", "signature": "public Blob getNullBlob()"}, {"syntax_pass": true, "original_string": "    public boolean getNullBoolean() {\n        return this.nullBoolean;\n    }", "docstring": "\nReturns the value when a SQL null is encountered as the result of\ninvoking a {@code getBoolean} method.\n\n@return the value\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "getNullBoolean", "params": [], "body": "                                    {\n        return this.nullBoolean;\n    }", "signature": "public boolean getNullBoolean()"}, {"syntax_pass": true, "original_string": "    public byte getNullByte() {\n        return this.nullByte;\n    }", "docstring": "\nReturns the value when a SQL null is encountered as the result of\ninvoking a {@code getByte} method.\n\n@return the value\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "byte", "classes": []}, "name": "getNullByte", "params": [], "body": "                              {\n        return this.nullByte;\n    }", "signature": "public byte getNullByte()"}, {"syntax_pass": true, "original_string": "    public byte[] getNullBytes() {\n        if (this.nullBytes == null) {\n            return null;\n        }\n        return this.nullBytes.clone();\n    }", "docstring": "\nReturns the value when a SQL null is encountered as the result of\ninvoking a {@code getBytes} method.\n\n@return the value\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "byte[]", "classes": []}, "name": "getNullBytes", "params": [], "body": "                                 {\n        if (this.nullBytes == null) {\n            return null;\n        }\n        return this.nullBytes.clone();\n    }", "signature": "public byte[] getNullBytes()"}, {"syntax_pass": true, "original_string": "    public Reader getNullCharacterStream() {\n        return this.nullCharacterStream;\n    }", "docstring": "\nReturns the value when a SQL null is encountered as the result of\ninvoking a {@code getCharacterStream} method.\n\n@return the value\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Reader", "classes": []}, "name": "getNullCharacterStream", "params": [], "body": "                                           {\n        return this.nullCharacterStream;\n    }", "signature": "public Reader getNullCharacterStream()"}, {"syntax_pass": true, "original_string": "    public Clob getNullClob() {\n        return this.nullClob;\n    }", "docstring": "\nReturns the value when a SQL null is encountered as the result of\ninvoking a {@code getClob} method.\n\n@return the value\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Clob", "classes": []}, "name": "getNullClob", "params": [], "body": "                              {\n        return this.nullClob;\n    }", "signature": "public Clob getNullClob()"}, {"syntax_pass": true, "original_string": "    public Date getNullDate() {\n        return this.nullDate != null ? new Date(this.nullDate.getTime()) : null;\n    }", "docstring": "\nReturns the value when a SQL null is encountered as the result of\ninvoking a {@code getDate} method.\n\n@return the value\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Date", "classes": []}, "name": "getNullDate", "params": [], "body": "                              {\n        return this.nullDate != null ? new Date(this.nullDate.getTime()) : null;\n    }", "signature": "public Date getNullDate()"}, {"syntax_pass": true, "original_string": "    public double getNullDouble() {\n        return this.nullDouble;\n    }", "docstring": "\nReturns the value when a SQL null is encountered as the result of\ninvoking a {@code getDouble} method.\n\n@return the value\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "double", "classes": []}, "name": "getNullDouble", "params": [], "body": "                                  {\n        return this.nullDouble;\n    }", "signature": "public double getNullDouble()"}, {"syntax_pass": true, "original_string": "    public float getNullFloat() {\n        return this.nullFloat;\n    }", "docstring": "\nReturns the value when a SQL null is encountered as the result of\ninvoking a {@code getFloat} method.\n\n@return the value\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "float", "classes": []}, "name": "getNullFloat", "params": [], "body": "                                {\n        return this.nullFloat;\n    }", "signature": "public float getNullFloat()"}, {"syntax_pass": true, "original_string": "    public int getNullInt() {\n        return this.nullInt;\n    }", "docstring": "\nReturns the value when a SQL null is encountered as the result of\ninvoking a {@code getInt} method.\n\n@return the value\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "getNullInt", "params": [], "body": "                            {\n        return this.nullInt;\n    }", "signature": "public int getNullInt()"}, {"syntax_pass": true, "original_string": "    public long getNullLong() {\n        return this.nullLong;\n    }", "docstring": "\nReturns the value when a SQL null is encountered as the result of\ninvoking a {@code getLong} method.\n\n@return the value\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "long", "classes": []}, "name": "getNullLong", "params": [], "body": "                              {\n        return this.nullLong;\n    }", "signature": "public long getNullLong()"}, {"syntax_pass": true, "original_string": "    public Object getNullObject() {\n        return this.nullObject;\n    }", "docstring": "\nReturns the value when a SQL null is encountered as the result of\ninvoking a {@code getObject} method.\n\n@return the value\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object", "classes": []}, "name": "getNullObject", "params": [], "body": "                                  {\n        return this.nullObject;\n    }", "signature": "public Object getNullObject()"}, {"syntax_pass": true, "original_string": "    public Ref getNullRef() {\n        return this.nullRef;\n    }", "docstring": "\nReturns the value when a SQL null is encountered as the result of\ninvoking a {@code getRef} method.\n\n@return the value\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Ref", "classes": []}, "name": "getNullRef", "params": [], "body": "                            {\n        return this.nullRef;\n    }", "signature": "public Ref getNullRef()"}, {"syntax_pass": true, "original_string": "    public short getNullShort() {\n        return this.nullShort;\n    }", "docstring": "\nReturns the value when a SQL null is encountered as the result of\ninvoking a {@code getShort} method.\n\n@return the value\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "short", "classes": []}, "name": "getNullShort", "params": [], "body": "                                {\n        return this.nullShort;\n    }", "signature": "public short getNullShort()"}, {"syntax_pass": true, "original_string": "    public String getNullString() {\n        return this.nullString;\n    }", "docstring": "\nReturns the value when a SQL null is encountered as the result of\ninvoking a {@code getString} method.\n\n@return the value\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getNullString", "params": [], "body": "                                  {\n        return this.nullString;\n    }", "signature": "public String getNullString()"}, {"syntax_pass": true, "original_string": "    public Time getNullTime() {\n        return this.nullTime != null ? new Time(this.nullTime.getTime()) : null;\n    }", "docstring": "\nReturns the value when a SQL null is encountered as the result of\ninvoking a {@code getTime} method.\n\n@return the value\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Time", "classes": []}, "name": "getNullTime", "params": [], "body": "                              {\n        return this.nullTime != null ? new Time(this.nullTime.getTime()) : null;\n    }", "signature": "public Time getNullTime()"}, {"syntax_pass": true, "original_string": "    public Timestamp getNullTimestamp() {\n        if (this.nullTimestamp == null) {\n            return null;\n        }\n\n        final Timestamp ts = new Timestamp(this.nullTimestamp.getTime());\n        ts.setNanos(this.nullTimestamp.getNanos());\n        return ts;\n    }", "docstring": "\nReturns the value when a SQL null is encountered as the result of\ninvoking a {@code getTimestamp} method.\n\n@return the value\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Timestamp", "classes": []}, "name": "getNullTimestamp", "params": [], "body": "                                        {\n        if (this.nullTimestamp == null) {\n            return null;\n        }\n\n        final Timestamp ts = new Timestamp(this.nullTimestamp.getTime());\n        ts.setNanos(this.nullTimestamp.getNanos());\n        return ts;\n    }", "signature": "public Timestamp getNullTimestamp()"}, {"syntax_pass": true, "original_string": "    public URL getNullURL() {\n        return this.nullURL;\n    }", "docstring": "\nReturns the value when a SQL null is encountered as the result of\ninvoking a {@code getURL} method.\n\n@return the value\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "URL", "classes": []}, "name": "getNullURL", "params": [], "body": "                            {\n        return this.nullURL;\n    }", "signature": "public URL getNullURL()"}, {"syntax_pass": true, "original_string": "    @Override\n    public Object invoke(final Object proxy, final Method method, final Object[] args)\n        throws Throwable {\n\n        final Object result = method.invoke(this.resultSet, args);\n\n        final Method nullMethod = NULL_METHODS.get(method.getName());\n\n        // Check nullMethod != null first so that we don't call wasNull()\n        // before a true getter method was invoked on the ResultSet.\n        return nullMethod != null && this.resultSet.wasNull()\n            ? nullMethod.invoke(this, (Object[]) null)\n            : result;\n    }", "docstring": "\nIntercepts calls to {@code get*} methods and calls the appropriate\n{@code getNull*} method if the {@code ResultSet} returned\n{@code null}.\n\n@see java.lang.reflect.InvocationHandler#invoke(Object, java.lang.reflect.Method, Object[])\n@param proxy Not used; all method calls go to the internal result set\n@param method The method to invoke on the result set\n@param args The arguments to pass to the result set\n@return null checked result\n@throws Throwable error\n", "attributes": {"modifiers": "@Override\n    public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object", "classes": []}, "name": "invoke", "params": [{"name": "proxy", "type": "Object"}, {"name": "method", "type": "Method"}, {"name": "args", "type": "Object[]"}], "body": "                         {\n\n        final Object result = method.invoke(this.resultSet, args);\n\n        final Method nullMethod = NULL_METHODS.get(method.getName());\n\n        // Check nullMethod != null first so that we don't call wasNull()\n        // before a true getter method was invoked on the ResultSet.\n        return nullMethod != null && this.resultSet.wasNull()\n            ? nullMethod.invoke(this, (Object[]) null)\n            : result;\n    }", "signature": "@Override\n    public Object invoke(final Object proxy, final Method method, final Object[] args)"}, {"syntax_pass": true, "original_string": "    public void setNullAsciiStream(final InputStream nullAsciiStream) {\n        this.nullAsciiStream = nullAsciiStream;\n    }", "docstring": "\nSets the value to return when a SQL null is encountered as the result of\ninvoking a {@code getAsciiStream} method.\n\n@param nullAsciiStream the value\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setNullAsciiStream", "params": [{"name": "nullAsciiStream", "type": "InputStream"}], "body": "                                                                      {\n        this.nullAsciiStream = nullAsciiStream;\n    }", "signature": "public void setNullAsciiStream(final InputStream nullAsciiStream)"}, {"syntax_pass": true, "original_string": "    public void setNullBigDecimal(final BigDecimal nullBigDecimal) {\n        this.nullBigDecimal = nullBigDecimal;\n    }", "docstring": "\nSets the value to return when a SQL null is encountered as the result of\ninvoking a {@code getBigDecimal} method.\n\n@param nullBigDecimal the value\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setNullBigDecimal", "params": [{"name": "nullBigDecimal", "type": "BigDecimal"}], "body": "                                                                   {\n        this.nullBigDecimal = nullBigDecimal;\n    }", "signature": "public void setNullBigDecimal(final BigDecimal nullBigDecimal)"}, {"syntax_pass": true, "original_string": "    public void setNullBinaryStream(final InputStream nullBinaryStream) {\n        this.nullBinaryStream = nullBinaryStream;\n    }", "docstring": "\nSets the value to return when a SQL null is encountered as the result of\ninvoking a {@code getBinaryStream} method.\n\n@param nullBinaryStream the value\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setNullBinaryStream", "params": [{"name": "nullBinaryStream", "type": "InputStream"}], "body": "                                                                        {\n        this.nullBinaryStream = nullBinaryStream;\n    }", "signature": "public void setNullBinaryStream(final InputStream nullBinaryStream)"}, {"syntax_pass": true, "original_string": "    public void setNullBlob(final Blob nullBlob) {\n        this.nullBlob = nullBlob;\n    }", "docstring": "\nSets the value to return when a SQL null is encountered as the result of\ninvoking a {@code getBlob} method.\n\n@param nullBlob the value\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setNullBlob", "params": [{"name": "nullBlob", "type": "Blob"}], "body": "                                                 {\n        this.nullBlob = nullBlob;\n    }", "signature": "public void setNullBlob(final Blob nullBlob)"}, {"syntax_pass": true, "original_string": "    public void setNullBoolean(final boolean nullBoolean) {\n        this.nullBoolean = nullBoolean;\n    }", "docstring": "\nSets the value to return when a SQL null is encountered as the result of\ninvoking a {@code getBoolean} method.\n\n@param nullBoolean the value\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setNullBoolean", "params": [{"name": "nullBoolean", "type": "boolean"}], "body": "                                                          {\n        this.nullBoolean = nullBoolean;\n    }", "signature": "public void setNullBoolean(final boolean nullBoolean)"}, {"syntax_pass": true, "original_string": "    public void setNullByte(final byte nullByte) {\n        this.nullByte = nullByte;\n    }", "docstring": "\nSets the value to return when a SQL null is encountered as the result of\ninvoking a {@code getByte} method.\n\n@param nullByte the value\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setNullByte", "params": [{"name": "nullByte", "type": "byte"}], "body": "                                                 {\n        this.nullByte = nullByte;\n    }", "signature": "public void setNullByte(final byte nullByte)"}, {"syntax_pass": true, "original_string": "    public void setNullBytes(final byte[] nullBytes) {\n        if (nullBytes != null) {\n            this.nullBytes = nullBytes.clone();\n        } else {\n            this.nullBytes = null;\n        }\n    }", "docstring": "\nSets the value to return when a SQL null is encountered as the result of\ninvoking a {@code getBytes} method.\n\n@param nullBytes the value\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setNullBytes", "params": [{"name": "nullBytes", "type": "byte[]"}], "body": "                                                     {\n        if (nullBytes != null) {\n            this.nullBytes = nullBytes.clone();\n        } else {\n            this.nullBytes = null;\n        }\n    }", "signature": "public void setNullBytes(final byte[] nullBytes)"}, {"syntax_pass": true, "original_string": "    public void setNullCharacterStream(final Reader nullCharacterStream) {\n        this.nullCharacterStream = nullCharacterStream;\n    }", "docstring": "\nSets the value to return when a SQL null is encountered as the result of\ninvoking a {@code getCharacterStream} method.\n\n@param nullCharacterStream the value\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setNullCharacterStream", "params": [{"name": "nullCharacterStream", "type": "Reader"}], "body": "                                                                         {\n        this.nullCharacterStream = nullCharacterStream;\n    }", "signature": "public void setNullCharacterStream(final Reader nullCharacterStream)"}, {"syntax_pass": true, "original_string": "    public void setNullClob(final Clob nullClob) {\n        this.nullClob = nullClob;\n    }", "docstring": "\nSets the value to return when a SQL null is encountered as the result of\ninvoking a {@code getClob} method.\n\n@param nullClob the value\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setNullClob", "params": [{"name": "nullClob", "type": "Clob"}], "body": "                                                 {\n        this.nullClob = nullClob;\n    }", "signature": "public void setNullClob(final Clob nullClob)"}, {"syntax_pass": true, "original_string": "    public void setNullDate(final Date nullDate) {\n        this.nullDate = nullDate != null ? new Date(nullDate.getTime()) : null;\n    }", "docstring": "\nSets the value to return when a SQL null is encountered as the result of\ninvoking a {@code getDate} method.\n\n@param nullDate the value\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setNullDate", "params": [{"name": "nullDate", "type": "Date"}], "body": "                                                 {\n        this.nullDate = nullDate != null ? new Date(nullDate.getTime()) : null;\n    }", "signature": "public void setNullDate(final Date nullDate)"}, {"syntax_pass": true, "original_string": "    public void setNullDouble(final double nullDouble) {\n        this.nullDouble = nullDouble;\n    }", "docstring": "\nSets the value to return when a SQL null is encountered as the result of\ninvoking a {@code getDouble} method.\n\n@param nullDouble the value\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setNullDouble", "params": [{"name": "nullDouble", "type": "double"}], "body": "                                                       {\n        this.nullDouble = nullDouble;\n    }", "signature": "public void setNullDouble(final double nullDouble)"}, {"syntax_pass": true, "original_string": "    public void setNullFloat(final float nullFloat) {\n        this.nullFloat = nullFloat;\n    }", "docstring": "\nSets the value to return when a SQL null is encountered as the result of\ninvoking a {@code getFloat} method.\n\n@param nullFloat the value\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setNullFloat", "params": [{"name": "nullFloat", "type": "float"}], "body": "                                                    {\n        this.nullFloat = nullFloat;\n    }", "signature": "public void setNullFloat(final float nullFloat)"}, {"syntax_pass": true, "original_string": "    public void setNullInt(final int nullInt) {\n        this.nullInt = nullInt;\n    }", "docstring": "\nSets the value to return when a SQL null is encountered as the result of\ninvoking a {@code getInt} method.\n\n@param nullInt the value\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setNullInt", "params": [{"name": "nullInt", "type": "int"}], "body": "                                              {\n        this.nullInt = nullInt;\n    }", "signature": "public void setNullInt(final int nullInt)"}, {"syntax_pass": true, "original_string": "    public void setNullLong(final long nullLong) {\n        this.nullLong = nullLong;\n    }", "docstring": "\nSets the value to return when a SQL null is encountered as the result of\ninvoking a {@code getLong} method.\n\n@param nullLong the value\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setNullLong", "params": [{"name": "nullLong", "type": "long"}], "body": "                                                 {\n        this.nullLong = nullLong;\n    }", "signature": "public void setNullLong(final long nullLong)"}, {"syntax_pass": true, "original_string": "    public void setNullObject(final Object nullObject) {\n        this.nullObject = nullObject;\n    }", "docstring": "\nSets the value to return when a SQL null is encountered as the result of\ninvoking a {@code getObject} method.\n\n@param nullObject the value\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setNullObject", "params": [{"name": "nullObject", "type": "Object"}], "body": "                                                       {\n        this.nullObject = nullObject;\n    }", "signature": "public void setNullObject(final Object nullObject)"}, {"syntax_pass": true, "original_string": "    public void setNullRef(final Ref nullRef) {\n        this.nullRef = nullRef;\n    }", "docstring": "\nSets the value to return when a SQL null is encountered as the result of\ninvoking a {@code getRef} method.\n\n@param nullRef the value\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setNullRef", "params": [{"name": "nullRef", "type": "Ref"}], "body": "                                              {\n        this.nullRef = nullRef;\n    }", "signature": "public void setNullRef(final Ref nullRef)"}, {"syntax_pass": true, "original_string": "    public void setNullShort(final short nullShort) {\n        this.nullShort = nullShort;\n    }", "docstring": "\nSets the value to return when a SQL null is encountered as the result of\ninvoking a {@code getShort} method.\n\n@param nullShort the value\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setNullShort", "params": [{"name": "nullShort", "type": "short"}], "body": "                                                    {\n        this.nullShort = nullShort;\n    }", "signature": "public void setNullShort(final short nullShort)"}, {"syntax_pass": true, "original_string": "    public void setNullString(final String nullString) {\n        this.nullString = nullString;\n    }", "docstring": "\nSets the value to return when a SQL null is encountered as the result of\ninvoking a {@code getString} method.\n\n@param nullString the value\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setNullString", "params": [{"name": "nullString", "type": "String"}], "body": "                                                       {\n        this.nullString = nullString;\n    }", "signature": "public void setNullString(final String nullString)"}, {"syntax_pass": true, "original_string": "    public void setNullTime(final Time nullTime) {\n        this.nullTime = nullTime != null ? new Time(nullTime.getTime()) : null;\n    }", "docstring": "\nSets the value to return when a SQL null is encountered as the result of\ninvoking a {@code getTime} method.\n\n@param nullTime the value\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setNullTime", "params": [{"name": "nullTime", "type": "Time"}], "body": "                                                 {\n        this.nullTime = nullTime != null ? new Time(nullTime.getTime()) : null;\n    }", "signature": "public void setNullTime(final Time nullTime)"}, {"syntax_pass": true, "original_string": "    public void setNullTimestamp(final Timestamp nullTimestamp) {\n        if (nullTimestamp != null) {\n            this.nullTimestamp = new Timestamp(nullTimestamp.getTime());\n            this.nullTimestamp.setNanos(nullTimestamp.getNanos());\n        } else {\n            this.nullTimestamp = null;\n        }\n    }", "docstring": "\nSets the value to return when a SQL null is encountered as the result of\ninvoking a {@code getTimestamp} method.\n\n@param nullTimestamp the value\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setNullTimestamp", "params": [{"name": "nullTimestamp", "type": "Timestamp"}], "body": "                                                                {\n        if (nullTimestamp != null) {\n            this.nullTimestamp = new Timestamp(nullTimestamp.getTime());\n            this.nullTimestamp.setNanos(nullTimestamp.getNanos());\n        } else {\n            this.nullTimestamp = null;\n        }\n    }", "signature": "public void setNullTimestamp(final Timestamp nullTimestamp)"}, {"syntax_pass": true, "original_string": "    public void setNullURL(final URL nullURL) {\n        this.nullURL = nullURL;\n    }", "docstring": "\nSets the value to return when a SQL null is encountered as the result of\ninvoking a {@code getURL} method.\n\n@param nullURL the value\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setNullURL", "params": [{"name": "nullURL", "type": "URL"}], "body": "                                              {\n        this.nullURL = nullURL;\n    }", "signature": "public void setNullURL(final URL nullURL)"}]}], "interfaces": [], "records": []}, {"relative_path": "src/main/java/org/apache/commons/dbutils/wrappers/package-info.java", "original_string": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Wrappers that add functionality to java.sql classes.\n */\npackage org.apache.commons.dbutils.wrappers;\n", "file_hash": "39f9c980507a9d731a46401d3148e9a66ca8239bfc94f6593dabeb7892c584f8", "file_docstring": "\nLicensed to the Apache Software Foundation (ASF) under one or more\ncontributor license agreements.  See the NOTICE file distributed with\nthis work for additional information regarding copyright ownership.\nThe ASF licenses this file to You under the Apache License, Version 2.0\n(the \"License\"); you may not use this file except in compliance with\nthe License.  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n", "contexts": ["package org.apache.commons.dbutils.wrappers;"], "methods": [], "classes": [], "interfaces": [], "records": []}]